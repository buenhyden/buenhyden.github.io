<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Locking | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Concurrency-Control,Locking,Deadlock-Prevention"><meta name=description content="락킹은 동시 트랜잭션이 같은 데이터를 안전하게 다루게 하는 메커니즘으로, 공유·배타·의도락 등 다양한 모드와 행·페이지·테이블 단위로 접근을 제어한다. 2PL 계열은 직렬성을 보장하지만 데드락과 대기 비용이 생기므로 MVCC나 낙관적 기법과 조합해 성능·일관성의 균형을 맞춘다. 분산 환경에서는 네트워크·타임 동기 문제를 추가로 고려해야 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Locking"><meta property="og:description" content="락킹은 동시 트랜잭션이 같은 데이터를 안전하게 다루게 하는 메커니즘으로, 공유·배타·의도락 등 다양한 모드와 행·페이지·테이블 단위로 접근을 제어한다. 2PL 계열은 직렬성을 보장하지만 데드락과 대기 비용이 생기므로 MVCC나 낙관적 기법과 조합해 성능·일관성의 균형을 맞춘다. 분산 환경에서는 네트워크·타임 동기 문제를 추가로 고려해야 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Locking"><meta name=twitter:description content="락킹은 동시 트랜잭션이 같은 데이터를 안전하게 다루게 하는 메커니즘으로, 공유·배타·의도락 등 다양한 모드와 행·페이지·테이블 단위로 접근을 제어한다. 2PL 계열은 직렬성을 보장하지만 데드락과 대기 비용이 생기므로 MVCC나 낙관적 기법과 조합해 성능·일관성의 균형을 맞춘다. 분산 환경에서는 네트워크·타임 동기 문제를 추가로 고려해야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":6,"name":"Locking","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Locking</h1><div class=post-description>락킹은 동시 트랜잭션이 같은 데이터를 안전하게 다루게 하는 메커니즘으로, 공유·배타·의도락 등 다양한 모드와 행·페이지·테이블 단위로 접근을 제어한다. 2PL 계열은 직렬성을 보장하지만 데드락과 대기 비용이 생기므로 MVCC나 낙관적 기법과 조합해 성능·일관성의 균형을 맞춘다. 분산 환경에서는 네트워크·타임 동기 문제를 추가로 고려해야 한다.</div></header><div class=post-content><h2 id=locking>Locking<a hidden class=anchor aria-hidden=true href=#locking>#</a></h2><p>락은 여러 트랜잭션이 동시에 데이터를 다룰 때 무결성과 일관성을 지키기 위해 자원에 걸리는 보호장치다.<br>공유락은 동시 읽기를 허용하고, 배타락은 쓰기 시 독점을 보장한다.<br>전통적 2 단계 락킹 (2PL) 은 직렬성을 보장하지만 데드락·경합을 유발할 수 있다.<br>이를 보완하려 MVCC 는 읽기 시점의 스냅샷을 제공해 읽기 락을 줄이지만 쓰기 충돌과 가비지 (버전) 관리 문제가 남는다.<br>실무에서는 락 그레인 (행/페이지/테이블) 선택, 트랜잭션 단축, 모니터링 (<code>pg_locks</code>, InnoDB STATUS), 데드락 자동해결, 분산 환경에선 펜싱 토큰·합의 시스템을 통해 안정성을 확보한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li>데이터베이스에서 <strong>락 (Lock)</strong> 은 동시에 여러 트랜잭션이 같은 데이터를 안전하게 다루도록 하는 도구다.</li><li><strong>읽기</strong>는 보통 공유락 (여럿 가능), <strong>쓰기</strong>는 배타락 (단독) 으로 처리한다.</li><li><strong>2PL</strong> 같은 규칙은 직렬성을 보장하지만 락 대기·데드락 같은 부작용이 있다.</li><li><strong>MVCC</strong>는 읽기를 비차단으로 만들어 성능을 올려주지만 버전 관리와 GC(가비지 컬렉션) 를 운영해야 한다.</li><li>실무에서는 <strong>트랜잭션을 짧게 유지</strong>, <strong>모니터링 (락 대기/데드락)</strong>, <strong>재시도 정책</strong>이 핵심이다.</li></ul><table><thead><tr><th>개념 (한글/약어)</th><th>정의 (간단)</th><th>왜 중요한가 (실무 관점)</th><th>실무 예시/비고</th></tr></thead><tbody><tr><td>공유 잠금 (Shared Lock, S)</td><td>여러 트랜잭션이 읽기 가능, 쓰기 차단</td><td>다중 읽기 동시성 보장</td><td>SELECT…(기본은 MVCC 로 읽기 비차단인 DB 도 있음)</td></tr><tr><td>배타 잠금 (Exclusive Lock, X)</td><td>단일 트랜잭션만 읽기/쓰기 허용</td><td>쓰기 원자성/무결성 보장</td><td>UPDATE/DELETE 시 적용</td></tr><tr><td>의도 잠금 (Intent Lock, IS/IX)</td><td>상위 오브젝트가 하위 잠금 의도 표기</td><td>다중 레벨 락 일관성</td><td>테이블 수준 의도 락 → 행락 검사</td></tr><tr><td>그라뉼러리티 (잠금 단위)</td><td>Row / Page / Table 수준</td><td>단위 결정이 성능·경합 좌우</td><td>Row-lock 선호 (경쟁 ↓)</td></tr><tr><td>2 단계 잠금 (2PL)</td><td>성장/축소 단계로 락 관리</td><td>직렬성 보장 표준 프로토콜</td><td>Strict 2PL: 커밋까지 락 보유</td></tr><tr><td>MVCC (다중버전)</td><td>각 트랜잭션에 스냅샷 제공</td><td>읽기 비차단 → 성능 향상</td><td>Postgres/InnoDB/Oracle 구현 차이</td></tr><tr><td>낙관적 잠금 (Optimistic)</td><td>커밋 시 검증, 충돌시 재시도</td><td>충돌 적은 환경에서 성능 우위</td><td>ETag, version 컬럼 방식</td></tr><tr><td>비관적 잠금 (Pessimistic)</td><td>즉시 락 획득</td><td>충돌 높은 환경에서 안전</td><td>금융·재고 시스템 등</td></tr><tr><td>락 승격 (Lock Escalation)</td><td>다수 락 → 상위 락 전환</td><td>메모리 절약 vs 경합 증가</td><td>SQL Server 자동 승격</td></tr><tr><td>데드락 (Deadlock)</td><td>순환 대기로 처리 불능 상태</td><td>서비스 정지 유발 → 탐지·복구 필요</td><td>DB 가 victim 선정 후 abort</td></tr><tr><td>분산 락 (Distributed Lock)</td><td>노드 간 자원 동기화 메커니즘</td><td>분산 시스템에서 자원 조정</td><td>Redis, Zookeeper 기반</td></tr></tbody></table><p>락 전략은 <strong>성능·동시성·무결성</strong> 사이의 균형을 맞추는 도구다. 간단한 규칙: <strong>트랜잭션을 짧게</strong>, <strong>잠금 단위를 세분화</strong>, <strong>충돌이 잦으면 비관적·낙관적 재설계</strong>를 고려하라. MVCC 는 읽기 성능을 개선하지만 운영 (버전·GC) 비용을 동반한다.</p><h4 id=잠금-개념-상호관계-표>잠금 개념 상호관계 표<a hidden class=anchor aria-hidden=true href=#잠금-개념-상호관계-표>#</a></h4><table><thead><tr><th>출발 개념</th><th>영향 대상</th><th style=text-align:right>관계 (무엇을 위해)</th><th>방향성/예시</th></tr></thead><tbody><tr><td>그라뉼러리티 (단위)</td><td>블로킹·경합</td><td style=text-align:right>경합 최소화 / 관리비용 절감</td><td>세분화↑ → 경합↓, 오버헤드↑</td></tr><tr><td>트랜잭션 길이</td><td>락 보유 시간 → 대기·데드락 확률</td><td style=text-align:right>단위 작업 분할로 대기 감소</td><td>짧게 유지 (권장)</td></tr><tr><td>2PL(프로토콜)</td><td>직렬성 보장</td><td style=text-align:right>일관성 보장 위해 락 보유</td><td>성장→축소 단계 구조</td></tr><tr><td>MVCC</td><td>읽기 락 필요성 감소</td><td style=text-align:right>읽기 처리량 증가 목적</td><td>읽기 비차단, 쓰기 충돌시 검사</td></tr><tr><td>락 승격</td><td>메모리 절감 vs 경합 증가</td><td style=text-align:right>메모리/성능 트레이드오프</td><td>다수 행락→테이블락</td></tr><tr><td>낙관적 검증</td><td>재시도 가능성 증가</td><td style=text-align:right>락 획득 줄여 성능↑</td><td>충돌 낮은 환경 유리</td></tr><tr><td>분산 락</td><td>전역 자원 일관성</td><td style=text-align:right>노드 간 동기화 위해 사용</td><td>네트워크 분할 고려 필요</td></tr></tbody></table><p>각 개념은 **목표 (성능·일관성·자원 관리)**를 달성하기 위해 서로 영향을 주고받는다. 설계 시에는 워크로드 (읽기/쓰기 비율), 일관성 요구, 인프라 특성을 고려해 적절히 조합해야 한다.</p><h4 id=개념과-db-별-실무-적용-매핑표>개념과 DB 별 실무 적용 매핑표<a hidden class=anchor aria-hidden=true href=#개념과-db-별-실무-적용-매핑표>#</a></h4><table><thead><tr><th>개념</th><th>DB/도구 구현 예시</th><th>실무 적용 (무엇을 해결)</th><th>고려사항 (왜 주의)</th></tr></thead><tbody><tr><td>MVCC</td><td>PostgreSQL, InnoDB, Oracle</td><td>읽기 비차단 → 조회 성능 향상</td><td>버전누적→VACUUM/undo/purge 필요</td></tr><tr><td>Shared/Exclusive</td><td>대부분 RDBMS (Lock Manager)</td><td>동시 읽기/단독 쓰기 제어</td><td>과도한 X 락→대기/데드락</td></tr><tr><td>SELECT FOR UPDATE</td><td>PostgreSQL, MySQL</td><td>행 잠금으로 동시 수정 방지</td><td>락 보유시간 짧게 설계</td></tr><tr><td>Lock Escalation</td><td>SQL Server(자동), 일부 DB</td><td>메모리 절감</td><td>테이블단위 경합 유발 가능</td></tr><tr><td>Gap Locks</td><td>InnoDB</td><td>Phantom 방지 (레인지 잠금)</td><td>삽입 경합 증가</td></tr><tr><td>Advisory Lock</td><td>Postgres pg_advisory_lock, Redis</td><td>애플리케이션 수준 동기화</td><td>실패복구·타임아웃 설계 필요</td></tr><tr><td>Deadlock Detection</td><td>DB 엔진</td><td>자동 victim 선정·abort</td><td>재시도 로직 필수</td></tr><tr><td>Distributed Lock</td><td>Redis, ZK</td><td>클러스터 작업 조율</td><td>분할/네트워크 지연 고려</td></tr></tbody></table><p>실무에서는 <strong>DB 별 구현상 차이</strong>를 이해한 뒤 적절한 명령 (예: SELECT FOR UPDATE) 과 운영정책 (타임아웃, 재시도, 모니터링) 을 결합해 적용해야 한다. 분산 락은 편리하지만 설계적 위험 (파티션, 시계, 펜싱) 이 있으므로 보수적으로 사용해야 한다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=동시성-제어-락의-원리와-실무>동시성 제어: 락의 원리와 실무<a hidden class=anchor aria-hidden=true href=#동시성-제어-락의-원리와-실무>#</a></h4><p>잠금 (Locking) 은 여러 트랜잭션이 동시에 같은 데이터를 건드릴 때 충돌을 막는 안전장치다.<br>두 가지 핵심 개념은</p><ol><li><strong>어떤 종류의 락을</strong> 거느냐 (읽기용 공유락 vs 쓰기용 배타락)</li><li><strong>어느 범위에</strong> 거느냐 (행 단위가 테이블 단위보다 더 세밀) 이다.</li></ol><p>잠금으로 데이터 일관성은 유지되지만, 락 경쟁이 심하면 처리 지연이나 교착상태가 발생하므로 <code>낙관적 락</code>, <code>MVCC</code> 같은 대안과 모니터링이 필요하다.</p><h5 id=잠금-락-이해와-운영-포인트>잠금 (락) 이해와 운영 포인트<a hidden class=anchor aria-hidden=true href=#잠금-락-이해와-운영-포인트>#</a></h5><ul><li><p><strong>락의 정의</strong></p><ul><li>락 (Lock): 자원 (레코드/테이블 등) 에 대한 접근 권한을 일시적으로 제한하는 논리적 표식.</li></ul></li><li><p><strong>주요 락 타입</strong></p><ul><li>공유락 (S, Shared): 여러 트랜잭션이 읽기 가능, 쓰기는 불가.</li><li>배타락 (X, Exclusive): 단독 접근 허용 (읽기/쓰기 금지).</li><li>업데이트락 (U), 의도락 (IX/IS): 상위 - 하위 단위 혼합 관리에 사용.</li></ul></li><li><p><strong>락 범위와 영향</strong></p><ul><li>행 (Row) 락: 동시성 높음·관리 오버헤드 존재.</li><li>테이블 (Table) 락: 구현 간단·동시성 저하.</li><li>락 상승 (escalation): 다수의 행 락이 테이블 락으로 전환될 수 있음.</li></ul></li><li><p><strong>직렬화 보장 메커니즘</strong></p><ul><li>2 단계 잠금 (2PL): 락 획득 단계와 해제 단계 분리 → 직렬성 보장.</li><li>엄격 2PL: 커밋 전까지 모든 락 유지 → 직렬화성과 회복성 확보.</li></ul></li><li><p><strong>교착상태와 대책</strong></p><ul><li>원인: 상호대기 (circular wait), 자원점유.</li><li>탐지/해결: 타임아웃, 우선순위, 교착검출 알고리즘 (Wait-for graph) 및 트랜잭션 롤백.</li></ul></li><li><p><strong>낙관적 vs 비관적 락</strong></p><ul><li>비관적: 미리 락 획득 (락 기반 DB, 안전하지만 지연).</li><li>낙관적: 충돌 시 검증 후 롤백/재시도 (업데이트가 적을 때 유리).</li></ul></li><li><p><strong>운영 포인트</strong></p><ul><li>모니터링: 락 대기 시간, deadlock 발생 횟수, lock waits.</li><li>튜닝: 트랜잭션 짧게 유지, 인덱스 최적화로 스캔 범위 축소, 타임아웃 설정.</li></ul></li><li><p><strong>분산 환경</strong></p><ul><li>분산 락 관리의 복잡성 (네트워크·부분 실패) → 전용 서비스 사용 (ZooKeeper, etcd) 또는 분산 합의/비동기 패턴 권장.</li></ul></li></ul><h4 id=동시성-제어의-진화-락에서-분산까지>동시성 제어의 진화: 락에서 분산까지<a hidden class=anchor aria-hidden=true href=#동시성-제어의-진화-락에서-분산까지>#</a></h4><p>동시에 여러 사용자가 데이터에 접근하면 값이 깨지거나 누락될 수 있다.<br>이를 막기 위해 시스템은 처음엔 단순히 데이터 블록을 잠그는 방식으로 안전을 보장했지만, 성능 문제가 생겨 잠금 단위를 작게 하고 (행 수준), 충돌을 더 똑똑하게 처리하도록 발전했다.<br>시간이 흐르며 읽기와 쓰기를 서로 방해하지 않게 여러 버전을 두는 (MVCC) 방식이나, 락을 거의 쓰지 않고 검증으로 충돌을 처리하는 낙관적 방식, 그리고 다수 노드에서 일관성을 맞추기 위한 합의 기반 기법까지 등장했다.<br>각 단계는 &rsquo; 어떤 문제를 해결하려고 했는가 &rsquo; 와 &rsquo; 그 해결로 생긴 새로운 문제 &rsquo; 를 함께 고려하며 발전해 왔다.</p><h5 id=락의-역사-등장-이유와-개선-방향>락의 역사: 등장 이유와 개선 방향<a hidden class=anchor aria-hidden=true href=#락의-역사-등장-이유와-개선-방향>#</a></h5><ol><li><p><strong>초기: 페이지/버퍼 단위 락 (단일 사용자→다중 사용자 전환)</strong></p><ul><li>등장 배경: 초기 시스템은 단일 사용자 또는 단순 버퍼 관리 중심이었으나 다중 접속이 늘며 동시 접근 충돌 문제 대두.</li><li>개선점: 기본적인 상호 배제 제공으로 데이터 무결성 확보.</li><li>트레이드오프: 병렬성 낮음 → 성능 한계.</li></ul></li><li><p><strong>행 수준 락·의도 락·그레뉼러리티 (잠금 단위 세분화)</strong></p><ul><li>등장 배경: 페이지 단위 락의 경합을 줄여 병렬성 증가 필요.</li><li>개선점: 더 세분된 락으로 동시성 증가, 의도 락으로 계층적 조정 가능.</li><li>트레이드오프: 락 관리 오버헤드·복잡성 증가.</li></ul></li><li><p><strong>2 단계 락킹 (2PL) 및 교착상태 처리</strong></p><ul><li>등장 배경: 일관성 (직렬화) 을 보장하면서 구현이 단순한 방법 필요.</li><li>개선점: 직렬화 보장 (이론적 안정성).</li><li>트레이드오프: 교착상태 발생 → 데드락 탐지/회복 필요, 성능 저하 가능.</li></ul></li><li><p><strong>낙관적 동시성 제어 (Optimistic Concurrency)</strong></p><ul><li>등장 배경: 락 비용이 큰 환경에서 충돌이 드문 워크로드에 성능 이점 필요.</li><li>개선점: 읽기 위주의 워크로드에서 높은 병렬성 제공, 락 획득 비용 감소.</li><li>트레이드오프: 충돌 발생 시 롤백 비용·복잡한 검증 필요.</li></ul></li><li><p><strong>MVCC(다중 버전) 도입</strong></p><ul><li>등장 배경: 읽기와 쓰기의 상호 차단을 줄여 응답성 향상 필요 (특히 읽기 중심 워크로드).</li><li>개선점: 비차단 읽기 (스냅샷), 높은 동시성, 낮은 락 경합.</li><li>트레이드오프: 버전 누적에 따른 저장소·GC 부담, 일부 격리 이상 (예: SI 의 write-skew).</li></ul></li><li><p><strong>격리·직렬성 보완 (예: SSI)</strong></p><ul><li>등장 배경: MVCC/SI 가 허용하는 일부 비직렬성 문제 (예: write-skew) 해결 요구.</li><li>개선점: SI 의 장점을 유지하면서 직렬성 보장 수준으로 향상 (충돌 검증 등).</li><li>트레이드오프: 런타임 검증 비용·abort 증가 가능.</li></ul></li><li><p><strong>분산 락·합의 기반 (분산 시스템 시대)</strong></p><ul><li>등장 배경: 멀티노드·멀티리전 환경에서 전역 일관성·조정 필요.</li><li>개선점: 노드 간 일관성 확보 (분산 트랜잭션, 전역 스냅샷 등).</li><li>트레이드오프: 네트워크 비용·지연·시스템 복잡도 증가 (합의 알고리즘 비용).</li></ul></li></ol><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>여러 사용자·프로세스가 동시에 데이터에 접근하는 환경이 일반화되면서 데이터 무결성과 일관성 보장이 필수 과제가 되었다.<br>초기에는 단순 배타 (exclusive) 락으로 해결했지만, 동시성 증가에 따른 성능 저하가 문제로 대두되자 락 단위 세분화, 데드락 탐지, 낙관적 접근, MVCC 등 다양한 해결책이 개발되었다.<br>분산·클라우드 시대에는 노드 간 일관성 확보를 위해 합의 프로토콜과 전역 타임스탬프 같은 추가 메커니즘이 필요해졌다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기 (대략)</th><th>기술/개념</th><th>등장 이유 (문제)</th><th>개선된 점 (목표)</th></tr></thead><tbody><tr><td style=text-align:right>1960s–1970s</td><td>블록/페이지 락 → 행 락</td><td>다중 사용자 환경으로 인한 충돌</td><td>무결성 확보 (기본)</td></tr><tr><td style=text-align:right>1976</td><td>2-Phase Locking (2PL)</td><td>직렬화 보장 필요</td><td>이론적 안정성 확보</td></tr><tr><td style=text-align:right>1979</td><td>그레뉼러리티 (의도 락)</td><td>락 충돌 감소 필요</td><td>병렬성 향상</td></tr><tr><td style=text-align:right>1980s</td><td>Deadlock detection/avoidance</td><td>데드락 현실적 문제 발생</td><td>교착 감지·회복 체계화</td></tr><tr><td style=text-align:right>1990s</td><td>낙관적 동시성 제어</td><td>락 비용 높은 환경에 대비</td><td>충돌 적은 워크로드 성능 향상</td></tr><tr><td style=text-align:right>1990s–2000s</td><td>MVCC 도입 확산</td><td>읽기/쓰기 상호 차단 완화 필요</td><td>비차단 읽기·높은 동시성</td></tr><tr><td style=text-align:right>2000s–2010s</td><td>SSI, 런타임 검증</td><td>SI 의 비직렬성 문제 보완</td><td>직렬성 보장 강화</td></tr><tr><td style=text-align:right>2010s–현재</td><td>분산 락·합의 (Raft/Paxos), 분산 MVCC</td><td>멀티노드·멀티리전 일관성 필요</td><td>전역 일관성 확보 (대가: 지연)</td></tr></tbody></table><pre class=mermaid>timeline
  title 락의 등장 배경과 발전 타임라인
  1960 : 블록/페이지 락 등장
  1976 : 2PL 제안(직렬화 보장)
  1979 : 그레뉼러리티·의도 락 도입
  1980 : 데드락 탐지/해결 발전
  1990 : 낙관적 동시성 제어 대두
  1995 : MVCC 확산(비차단 읽기)
  2000 : SSI 등 격리 보완 연구
  2010 : 분산 락·합의 기반 확산
</pre><p>초기 단순 락은 무결성을 보장했지만 병렬성 문제를 유발했고, 이를 해결하려 락 단위 세분화와 2PL 이 도입되었다.<br>이후 락 관리의 복잡도와 성능 비용을 줄이려 낙관적 기법과 MVCC 가 등장했으며, MVCC 는 읽기 성능을 크게 개선했지만 저장·GC 부담을 야기했다.<br>최근에는 분산 환경에서 전역 일관성을 다루기 위해 합의 기반 설계가 도입되었고, 그에 따라 네트워크·운영 복잡도가 핵심 고려사항으로 자리잡았다.</p><h4 id=락-기반-동시성-문제목적운영>락 기반 동시성: 문제·목적·운영<a hidden class=anchor aria-hidden=true href=#락-기반-동시성-문제목적운영>#</a></h4><p>락은 &rsquo; 공유 자원 (특정 레코드나 테이블) 에 대한 접근 &rsquo; 을 제어해 여러 사용자가 동시에 작업할 때 발생할 수 있는 <strong>충돌과 이상 현상</strong>을 막는 도구다.</p><ul><li>읽기와 쓰기를 구분해 **공유 (읽기)**와 <strong>배타 (쓰기)</strong> 락을 적용한다.</li><li>트랜잭션이 시작되면 필요한 락을 얻고, 규칙 (2PL) 에 따라 해제 시점을 관리해 일관성을 보장한다.</li><li>단점은 락 때문에 다른 트랜잭션이 대기하거나 데드락이 생길 수 있다는 점이며, 이를 줄이려면 락의 범위·기간을 최소화하거나 MVCC/낙관적 방법을 병용한다.</li></ul><h5 id=락이-해결하는-주요-문제표>락이 해결하는 주요 문제표<a hidden class=anchor aria-hidden=true href=#락이-해결하는-주요-문제표>#</a></h5><table><thead><tr><th>문제</th><th style=text-align:right>증상 (간단)</th><th>락으로의 해결 방식</th><th>운영 고려사항</th></tr></thead><tbody><tr><td>갱신 손실 (Lost Update)</td><td style=text-align:right>동시 쓰기로 변경 누락</td><td>Exclusive Lock 으로 쓰기 직렬화</td><td>핀포인트 락 적용, 핫스팟 주의</td></tr><tr><td>더티 읽기 (Dirty Read)</td><td style=text-align:right>미확정 데이터 읽음</td><td>엄격 2PL / 읽기 전 공유락/또는 MVCC</td><td>락으로 대기 증가 가능</td></tr><tr><td>반복 불가능 읽기</td><td style=text-align:right>동일 트랜잭션 내 결과 불일치</td><td>트랜잭션 단위 Shared Lock 유지</td><td>장시간 락→GC·성능 영향</td></tr><tr><td>팬텀 읽기 (Phantom)</td><td style=text-align:right>범위 쿼리 결과 변화</td><td>Predicate / Range Lock 또는 SERIALIZABLE</td><td>인덱스 구조 영향, 범위 락 비용</td></tr><tr><td>교착 (Deadlock)</td><td style=text-align:right>무한 대기·정체</td><td>Deadlock 탐지→Abort 또는 예방 정책</td><td>데드락 모니터링·타임아웃 필요</td></tr></tbody></table><p>락은 위 문제들을 직접 차단 (또는 완화) 하지만, <strong>락 자체가 대기·데드락·성능 저하의 원인</strong>이 될 수 있다. 따라서 실무에서는 락의 종류·범위·유지 시간·해제 시점을 정교하게 설계하고 데드락 탐지/모니터링을 반드시 병행해야 한다.</p><h5 id=락의-핵심-목적과-달성-방법표>락의 핵심 목적과 달성 방법표<a hidden class=anchor aria-hidden=true href=#락의-핵심-목적과-달성-방법표>#</a></h5><table><thead><tr><th>목적</th><th style=text-align:right>의미</th><th>락이 기여하는 방식</th><th>성과 측정 지표</th></tr></thead><tbody><tr><td>데이터 일관성</td><td style=text-align:right>무결한 상태 유지</td><td>직렬화된 업데이트 보장</td><td>무결성 위반 발생률, 오류 건수</td></tr><tr><td>트랜잭션 격리</td><td style=text-align:right>독립적 실행 보장</td><td>격리 레벨별 락 유지/범위 락</td><td>비교 쿼리 재현성, 트랜잭션 오류율</td></tr><tr><td>직렬화 가능성</td><td style=text-align:right>동시 실행 ≒ 순차 실행</td><td>엄격 2PL / 범위 락</td><td>직렬화 위반 사례 수</td></tr><tr><td>성능 최적화</td><td style=text-align:right>대기·데드락 최소화</td><td>그레뉼러리티·에스컬레이션 조정</td><td>대기 시간, TPS, 데드락 빈도</td></tr></tbody></table><p>락의 목적은 <strong>정확성 (Consistency/Serializability)</strong> 과 <strong>운영성 (성능, 가용성)</strong> 사이의 균형을 맞추는 것이다. 최고의 일관성을 확보하면 동시성은 희생되므로, 실제 시스템에서는 업무 중요도에 따라 격리 수준과 락 정책을 선택한다.</p><h5 id=문제와-목적의-연관성-매트릭스>문제와 목적의 연관성 매트릭스<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연관성-매트릭스>#</a></h5><table><thead><tr><th>문제 \ 목적</th><th style=text-align:center>데이터 일관성</th><th style=text-align:center>트랜잭션 격리</th><th style=text-align:center>직렬화 가능성</th><th style=text-align:center>성능 최적화</th></tr></thead><tbody><tr><td>갱신 손실</td><td style=text-align:center>● 직접 개선</td><td style=text-align:center>○ 간접</td><td style=text-align:center>● 직접</td><td style=text-align:center>−(성능저하 가능)</td></tr><tr><td>더티 읽기</td><td style=text-align:center>● 직접 개선</td><td style=text-align:center>● 직접</td><td style=text-align:center>○ 간접</td><td style=text-align:center>−(대기 증가 우려)</td></tr><tr><td>반복 불가능 읽기</td><td style=text-align:center>● 직접 개선</td><td style=text-align:center>● 직접</td><td style=text-align:center>○ 간접</td><td style=text-align:center>−(락 유지 비용)</td></tr><tr><td>팬텀 읽기</td><td style=text-align:center>● 직접 개선</td><td style=text-align:center>● 직접</td><td style=text-align:center>● 직접</td><td style=text-align:center>−(범위 락 비용)</td></tr><tr><td>교착 (Deadlock)</td><td style=text-align:center>−(유발 가능)</td><td style=text-align:center>−(유발 가능)</td><td style=text-align:center>−(유발 가능)</td><td style=text-align:center>● 성능질서 확보 (탐지 후 회복)</td></tr></tbody></table><p>락은 <strong>일관성과 직렬성 확보에 매우 강력</strong>하지만, 동일 메커니즘이 **성능 저하 (대기·데드락)**를 유발할 수 있다. 따라서 목적별 우선순위를 명확히 하고 락 정책을 설계해야 한다.</p><h4 id=locking-설계운영-핵심-요구사항>Locking 설계·운영 핵심 요구사항<a hidden class=anchor aria-hidden=true href=#locking-설계운영-핵심-요구사항>#</a></h4><p>Locking 이 안정적으로 동작하려면 <strong>트랜잭션 경계 제어</strong>, <strong>효율적인 락 관리자와 락 상태 저장소</strong>, <strong>데드락 탐지·타임아웃 정책</strong>, 그리고 <strong>분산 환경에서는 lease/fencing·장애 모델</strong> 같은 추가 메커니즘이 필요하다.<br>또한 락을 관리하는 데는 메모리와 CPU 오버헤드가 발생하므로 시스템별 자원 예산과 성능 목표 (락 획득 지연, 데드락 탐지 시간) 를 사전에 정의해 두어야 한다. 운영 관점에서는 장기 트랜잭션을 금지하고 모니터링/알람을 통해 이상을 빠르게 해결하는 것이 핵심이다.</p><h5 id=locking-전제조건과-운영-요구사항>Locking 전제조건과 운영 요구사항<a hidden class=anchor aria-hidden=true href=#locking-전제조건과-운영-요구사항>#</a></h5><h6 id=핵심-전제조건-및-이유>핵심 전제조건 및 이유<a hidden class=anchor aria-hidden=true href=#핵심-전제조건-및-이유>#</a></h6><ol><li><p><strong>트랜잭션 관리 시스템</strong></p><ul><li>근거: 락은 트랜잭션 경계 (시작/커밋/롤백) 에 따라 의미가 결정되므로 트랜잭션 컨트롤이 전제.</li></ul></li><li><p><strong>락 관리자 (Lock Manager)</strong></p><ul><li>근거: 중앙 (또는 분산) 에서 락 테이블을 관리해야 동시성 충돌 감지·대기큐 관리·권한 위임이 가능함.</li></ul></li><li><p><strong>락 테이블 (상태 저장 구조)</strong></p><ul><li>근거: 어떤 트랜잭션이 어떤 자원을 점유하는지 즉시 판단하려면 효율적인 인메모리 데이터구조 (해시/트리) 가 필요.</li></ul></li><li><p><strong>타임아웃·교착 탐지·복구 정책</strong></p><ul><li>근거: 2PL 계열에서 데드락은 피할 수 없으므로 자동 탐지·회복 (타임아웃/젖산법/선점) 이 운영 요구.</li></ul></li><li><p><strong>클록/장애 모델 (분산 적용 시)</strong></p><ul><li>근거: 분산 락은 네트워크 분리·시계 불일치 등 실패 모드가 존재해 lease·fencing 등의 보완이 필요.</li></ul></li><li><p><strong>성능·자원 한계 명세</strong></p><ul><li>근거: 락 관리자는 메모리·CPU 를 사용하므로 시스템별 예산 (예: 전체 메모리의 몇 % 이내) 과 목표 응답시간을 사전에 정해야 운영 안정성 확보.</li></ul></li></ol><h6 id=등장-전-관련-기술과의-차별점>등장 전 관련 기술과의 차별점<a hidden class=anchor aria-hidden=true href=#등장-전-관련-기술과의-차별점>#</a></h6><ul><li><p><strong>직전 (전통)</strong>: 단순 전역 락 (테이블 단위) 또는 2PL 만 사용 → 구현 단순, 단일 노드 일관성 쉽지만 동시성 저하 심함.</p></li><li><p><strong>Locking 의 발전/차별화</strong>: 세분화된 락 (행/페이지/의도락), 교착 탐지·타임아웃 정책, 분산 락 (lease/fencing) 도입 → 목표는 동시성 확보와 장애 허용성 확대.</p></li><li><p><strong>대체 기술</strong>: MVCC/낙관적 동시성은 읽기 비차단을 제공하지만 쓰기 충돌·DDL·인덱스 변경 등에서는 여전히 락이 필요 → 실무에서는 혼합 사용 (락 + MVCC) 이 일반적.</p></li></ul><h5 id=locking-전제조건성능-요구표>Locking 전제조건·성능 요구표<a hidden class=anchor aria-hidden=true href=#locking-전제조건성능-요구표>#</a></h5><table><thead><tr><th>분류</th><th>항목</th><th>설명</th><th style=text-align:right>권장/참고값 (출발점)</th></tr></thead><tbody><tr><td>기능적 전제</td><td>트랜잭션 관리</td><td>트랜잭션 시작/커밋/롤백 관리 체계 필요</td><td style=text-align:right>필수</td></tr><tr><td>기능적 전제</td><td>락 관리자</td><td>락 획득·대기큐·해제·충돌 판별 담당</td><td style=text-align:right>중앙/분산 구현 명세 필요</td></tr><tr><td>기능적 전제</td><td>락 상태 저장 (X)</td><td>Lock Table(인메모리 해시/트리), 영속화 정책</td><td style=text-align:right>메모리 우선 (빠른 접근)</td></tr><tr><td>운영 요구</td><td>타임아웃 정책</td><td>idle/long tx 타임아웃 설정, deadlock timeout</td><td style=text-align:right>idle_tx_timeout: 1–30min(정책적)</td></tr><tr><td>운영 요구</td><td>교착 탐지·복구</td><td>Wait-for 그래프/타임아웃/선점 회복 전략</td><td style=text-align:right>탐지 주기: 초 단위</td></tr><tr><td>성능 요구</td><td>획득/해제 지연</td><td>마이크로초~수십 마이크로초 목표 (가능 시)</td><td style=text-align:right>서비스 요구에 따름</td></tr><tr><td>자원 요구</td><td>메모리 예산</td><td>락 테이블·대기큐 저장용 메모리</td><td style=text-align:right>총 메모리의 3–10% 권장 (워크로드 의존)</td></tr><tr><td>장애/분산</td><td>클럭·장애 모델</td><td>분산에서는 lease/fencing·leader election 필요</td><td style=text-align:right>lease TTL 설정 필요</td></tr><tr><td>확장성</td><td>수평 확장 전략</td><td>Lock sharding/partitioning, 분산 coordination</td><td style=text-align:right>설계 필수</td></tr><tr><td>복구</td><td>로그 기반 복구</td><td>장애 복구 시 락 상태 복원 또는 재구성 방안 필요</td><td style=text-align:right>WAL/로그 활용</td></tr></tbody></table><ul><li><p>핵심은 **기능 (무엇을 제공해야 하는가)**과 <strong>운영 (어떻게 운영·모니터링할 것인가)</strong>, <strong>성능 (응답 목표·자원 예산)</strong> 세 축을 설계 초기부터 함께 정하는 것이다.</p></li><li><p>특히 분산 환경에서는 단순히 락만 옮기는 것으로 끝나지 않고 <strong>lease/fencing, leader election, 네트워크 파티션 시 행동 규약</strong>을 반드시 설계해야 한다.</p></li><li><p>메모리·지연 목표는 베이스라인으로 제시한 권장값에서 출발하되, 최종값은 실제 워크로드 벤치마크로 결정해야 한다.</p></li></ul><h4 id=락-기반-동시성-핵심근거차별점>락 기반 동시성: 핵심·근거·차별점<a hidden class=anchor aria-hidden=true href=#락-기반-동시성-핵심근거차별점>#</a></h4><p>락은 여러 트랜잭션이 동시에 같은 데이터를 다룰 때 충돌을 막는 규칙이다.<br>시스템은 읽기용 공유락과 쓰기용 배타락을 주로 사용하고, 테이블·페이지·행 같은 여러 수준에서 락을 잡아 성능과 안전을 조절한다.<br>2 단계 락킹 (2PL) 은 락 획득·해제 규칙으로 데이터의 직렬성을 보장하고, 데드락은 탐지·희생자 선정으로 자동 해결한다.<br>대신 읽기가 많은 시스템에서는 MVCC 처럼 버전을 써서 읽기 락을 줄이는 기법을 병행하는게 일반적이다.</p><h5 id=락-기법의-기술적-근거와-차별점>락 기법의 기술적 근거와 차별점<a hidden class=anchor aria-hidden=true href=#락-기법의-기술적-근거와-차별점>#</a></h5><h6 id=호환성-매트릭스>호환성 매트릭스<a hidden class=anchor aria-hidden=true href=#호환성-매트릭스>#</a></h6><ul><li>기술적 근거: 단일 비트/플래그 수준에서 락 타입 간 호환성 여부를 정의하면 락 획득 경로가 O(1) 로 판정됨. DB 내부 구현 (락테이블) 에서 빠르게 체크 가능.</li><li>차별점: MVCC 는 읽기 동작에서 락을 거의 필요로 하지 않으므로 매트릭스 기반 비교는 주로 쓰기 경합 제어에 집중된다.</li></ul><h6 id=계층적-락킹--의도락>계층적 락킹 & 의도락<a hidden class=anchor aria-hidden=true href=#계층적-락킹--의도락>#</a></h6><ul><li>기술적 근거: 의도락 (IS/IX) 은 상위 레벨에서 하위 레벨 락의 의도를 선언해 테이블 스캔 등에서 불필요한 전역 락을 방지.</li><li>차별점: 단순 행락만 있는 시스템보다 상위 - 하위 일관성 확보에 유리하나, 구현·튜닝 복잡도가 증가.</li></ul><h6 id=strict-2pl-프로토콜-기반>Strict 2PL (프로토콜 기반)<a hidden class=anchor aria-hidden=true href=#strict-2pl-프로토콜-기반>#</a></h6><ul><li>기술적 근거: 이론적으로 2PL 은 직렬가능성 (Serializability) 을 보장—데이터베이스 교과서의 표준.</li><li>차별점: 타임스탬프 주문 (TO)·MVCC·낙관적 제어와 비교하면 <strong>직렬성 보장이 직관적</strong>인 대신, 락 대기로 인한 성능 저하와 데드락이 단점.</li></ul><h6 id=데드락-처리>데드락 처리<a hidden class=anchor aria-hidden=true href=#데드락-처리>#</a></h6><ul><li>기술적 근거: Wait-for 그래프로 순환검출 O(N) 알고리즘 실행 후 희생자 선정 (예: 적게 수행된 작업 또는 낮은 우선순위) 으로 롤백.</li><li>차별점: 낙관적 접근은 데드락 대신 충돌 후 재시도를 사용하므로 운영상 다른 트레이드오프 (rollback 비율) 가 발생.</li></ul><h5 id=락-기반-동시성-특징-한눈표>락 기반 동시성 특징 한눈표<a hidden class=anchor aria-hidden=true href=#락-기반-동시성-특징-한눈표>#</a></h5><table><thead><tr><th>핵심 특징</th><th>무엇 (설명)</th><th>기술적 근거</th><th>다른 기법과의 차별점</th></tr></thead><tbody><tr><td>호환성 기반 제어</td><td>락 타입 간 허용 여부 매트릭스로 판정</td><td>빠른 O(1) 호환 체크, 락테이블 구현</td><td>MVCC 는 읽기 락 회피—호환성 매트릭스는 주로 쓰기 충돌 제어</td></tr><tr><td>계층적 락킹 + 의도락</td><td>테이블→페이지→행 그레인과 의도락 사용</td><td>상위 - 하위 충돌 사전 표지로 불필요 락 회피</td><td>단일 그레인보다 유연하지만 복잡도↑</td></tr><tr><td>Strict 2PL</td><td>성장/축소 단계로 직렬성 보장</td><td>이론적 직렬가능성 보장 (교과서 표준)</td><td>낙관적·타임스탬프·MVCC 에 비해 블로킹·데드락 빈도↑</td></tr><tr><td>데드락 처리</td><td>탐지 (Wait-for) → 희생자 선정 → 롤백</td><td>순환검출 알고리즘 + 정책 기반 희생자선정</td><td>낙관적 제어는 충돌 후 재시도 방식으로 문제회피</td></tr></tbody></table><p>락 기반 동시성 제어는 <strong>명시적 블로킹</strong>을 통해 직렬성·무결성을 강력히 보장한다. 그 핵심은 <strong>호환성 매트릭스, 계층적 락 (의도락 포함), 2PL 프로토콜, 데드락 자동 처리</strong>에 있다. 반면 읽기 중심·대규모 분산 환경에서는 MVCC·낙관적 제어·타임스탬프 기반 기법과의 혼용이 일반적이다—각각의 기법은 <strong>직렬성 보장 수준, 성능, 운영 복잡도</strong>에서 상이한 트레이드오프를 가진다.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=락킹-원칙철학실무-요건>락킹 원칙·철학·실무 요건<a hidden class=anchor aria-hidden=true href=#락킹-원칙철학실무-요건>#</a></h4><p>락킹 설계는 " 데이터 일관성을 해치지 않으면서 동시성은 최대한 살리는 것 " 이 목표다. 이를 위해 네 가지 원칙 (원자성, 순서 보장, 최소 권한, 교착 방지) 을 지키고, 설계 철학으로는 직렬 가능성 확보를 최우선으로 두되 실제 성능을 위해 읽기 비차단 (MVCC 병행), 쓰기 충돌 제한, 관측성 내장, 분산 실패 모델 대비를 병행한다. 실무에서는 락 단위를 작게 하고 (행 단위 우선), 길게 유지하지 않도록 트랜잭션을 짧게 설계하며, 데드락 탐지와 자동 회복, 로그·메트릭 수집을 통해 운영 부담을 줄인다.</p><h5 id=락킹-핵심-원칙-정리>락킹 핵심 원칙 정리<a hidden class=anchor aria-hidden=true href=#락킹-핵심-원칙-정리>#</a></h5><ol><li><p><strong>원자성 보장 (Atomicity Principle)</strong></p><ul><li>설명: 락의 획득·해제는 불가분의 단위로 다뤄야 하며, 중간 상태에서 다른 트랜잭션의 개입을 허용하지 않음.</li><li>목적: 일관성 깨짐 (부분 적용 상태) 을 막아 트랜잭션 원자성을 유지.</li><li>이유: 부분적으로 락이 적용되면 데이터 손상·비결정적 동작 발생 가능성이 높아 복구·검증 비용 증가.</li></ul></li><li><p><strong>순서 보장 (Ordering / Fairness Principle)</strong></p><ul><li>설명: 락 요청 처리에 공정성 (예: FIFO) 또는 우선순위 정책을 적용해 기아 (starvation) 를 방지.</li><li>목적: 특정 트랜잭션이 무한히 대기하는 것을 막고 전반적 응답 공정성 확보.</li><li>이유: 장기 기아는 시스템 예측 불가능성·성능 편차를 초래하고, SLA 위반으로 이어질 수 있음.</li></ul></li><li><p><strong>최소 권한 원칙 (Least Privilege)</strong></p><ul><li>설명: 가능한 한 범위 (행 > 페이지 > 테이블) 와 기간을 최소화해 락을 획득.</li><li>목적: 동시성 최대화와 락 경쟁 최소화.</li><li>이유: 과도한 범위나 장시간 락은 컨텐션을 키워 전체 처리량 저하 및 데드락 증가를 유발.</li></ul></li><li><p><strong>교착 상태 방지 (Deadlock Prevention)</strong></p><ul><li>설명: 순환 대기 조건을 사전에 차단하거나 (타임스탬프 기반, 고정 락 순서), 탐지 후 회복하는 전략 채택.</li><li>목적: 데드락으로 인한 시스템 정지·롤백 반복 방지.</li><li>이유: 데드락이 빈번하면 롤백 비용 (작업 재시도) 과 지연이 누적되어 서비스 불안정 초래.</li></ul></li><li><p><strong>원자적·관측 가능한 해제 (Observable Unlocks)</strong></p><ul><li>설명: 락 해제 시점과 상태 변화가 관찰 가능하게 로그·메트릭으로 기록.</li><li>목적: 디버깅·운영 대응 (교착 추적, 대기 큐 분석) 용이.</li><li>이유: 락 문제는 재현이 어렵기 때문에 관측성 없이는 근본 원인 분석이 불가능.</li></ul></li></ol><table><thead><tr><th>원칙</th><th>설명</th><th style=text-align:right>목적</th><th>왜 필요한가</th></tr></thead><tbody><tr><td>원자성</td><td>락 획득·해제는 불가분 연산</td><td style=text-align:right>중간 상태 차단, 트랜잭션 원자성 보장</td><td>부분 적용시 데이터 무결성 훼손 우려</td></tr><tr><td>순서 보장</td><td>요청 공정 처리 (FIFO/우선순위)</td><td style=text-align:right>기아 방지·예측 가능한 응답성</td><td>기아는 SLA·성능 편차 초래</td></tr><tr><td>최소 권한</td><td>최소 범위·최단 시간 락</td><td style=text-align:right>동시성 극대화</td><td>과도한 락은 컨텐션·성능 저하 유발</td></tr><tr><td>교착 방지</td><td>순환대기 차단/탐지·회복</td><td style=text-align:right>데드락으로 인한 정지 예방</td><td>데드락은 롤백·지연 비용 급증</td></tr><tr><td>관측 가능한 해제</td><td>락 이벤트 로깅·메트릭</td><td style=text-align:right>운영·디버깅 효율화</td><td>문제재현 어려워 로그·지표 필수</td></tr></tbody></table><p>핵심 원칙들은 데이터 무결성 (직렬성) 과 운영적 가용성 (지연·기아·데드락) 을 균형있게 관리하기 위한 규칙이다. 설계 시 각 원칙의 트레이드오프를 워크로드 특성에 맞춰 조정해야 한다.</p><h5 id=락킹-설계-철학-정리>락킹 설계 철학 정리<a hidden class=anchor aria-hidden=true href=#락킹-설계-철학-정리>#</a></h5><ol><li><p><strong>직렬 가능성 (Serializability) 우선</strong></p><ul><li>설명: 가능한 한 트랜잭션의 실행이 어떤 직렬 실행과 동등하도록 보장.</li><li>목적: 데이터 무결성의 최종 보장.</li><li>이유: 비직렬적 실행은 복잡한 논리적 버그·무결성 위반을 초래하므로 우선 목표로 삼음.</li></ul></li><li><p><strong>읽기 비차단 (Read-nonblocking) 지향</strong></p><ul><li>설명: 읽기 연산은 가능한 잠금 없이 처리 (예: MVCC 병행) 하여 전체 동시성을 향상.</li><li>목적: 읽기 우선 워크로드에서 성능 극대화.</li><li>이유: 대부분 시스템은 읽기가 많아 읽기 차단이 곧 사용자 체감 성능 저하임.</li></ul></li><li><p><strong>쓰기 충돌 최소화 (Write-conflict Control)</strong></p><ul><li>설명: 쓰기 충돌만을 엄격히 제어하고 나머지는 낙관적 접근 허용.</li><li>목적: 불필요한 차단 축소.</li><li>이유: 쓰기는 쓰기끼리만 충돌을 해결하면 전체 동시성 유지를 더 쉽게 달성.</li></ul></li><li><p><strong>관측성·복구 쉬운 설계 (Operability)</strong></p><ul><li>설명: 락 이벤트·대기·데드락 로그, 메트릭을 기본으로 제공.</li><li>목적: 운영·디버깅 비용 최소화.</li><li>이유: 락 문제는 현장 문제 해석에 많은 시간이 소요되므로 설계 단계에서 로그·메트릭을 내장해야 함.</li></ul></li><li><p><strong>분산의 불확실성 수용 (Distributed-resilient Design)</strong></p><ul><li>설명: 분산 환경의 네트워크 분리·시계 차이를 가정한 lease/fencing/leader 패턴 적용.</li><li>목적: 분산 락 안전성 확보 (잘못된 소유권 방지).</li><li>이유: 단순 중앙락 모델은 네트워크 오류 시 데이터 손상·중복 실행을 일으킴.</li></ul></li></ol><table><thead><tr><th>설계 철학</th><th>설명</th><th style=text-align:right>목적</th><th>왜 필요한가</th></tr></thead><tbody><tr><td>직렬 가능성 우선</td><td>트랜잭션 실행을 직렬 실행과 동등하게</td><td style=text-align:right>데이터 무결성 최우선</td><td>논리적 무결성 위반 방지</td></tr><tr><td>읽기 비차단 지향</td><td>읽기는 가능한 비차단 처리 (MVCC 병행)</td><td style=text-align:right>읽기 성능 극대화</td><td>사용자 체감 성능 개선</td></tr><tr><td>쓰기 충돌 최소화</td><td>쓰기 충돌에만 엄격 제어 적용</td><td style=text-align:right>불필요한 차단 제거</td><td>동시성 유지·복구 비용 절감</td></tr><tr><td>관측성·운영성</td><td>락 메트릭·로그 기본 제공</td><td style=text-align:right>빠른 문제탐지·대응</td><td>락 문제는 재현 어려움</td></tr><tr><td>분산 내성</td><td>lease/fencing 등 분산 안전성 고려</td><td style=text-align:right>네트워크 장애 대응</td><td>분산 환경에서 데이터 손상 방지</td></tr></tbody></table><p>설계 철학은 시스템의 목표 (무결성·성능·운영성) 에 따라 어떤 원칙을 우선할지 결정하는 가이드다. 예컨대 금융 서비스는 직렬성 우선, 읽기집중 서비스는 읽기 비차단을 우선하는 식으로 적용된다.</p><h4 id=락-동작-원리와-운영-메커니즘>락 동작 원리와 운영 메커니즘<a hidden class=anchor aria-hidden=true href=#락-동작-원리와-운영-메커니즘>#</a></h4><p>락은 여러 트랜잭션이 동시에 같은 데이터를 다룰 때 데이터 무결성과 일관성을 지키기 위해 사용하는 규칙이야. 트랜잭션은 접근 전에 락을 요청하고, 락 매니저는 현재 보유 락과의 <strong>호환성 매트릭스</strong>로 즉시 승인하거나 대기시킨다. 충돌로 인해 대기 상태가 순환하면 <strong>데드락</strong>이 발생하므로 시스템은 탐지하고 희생자를 골라 롤백한다. **2 단계 락킹 (2PL)**은 락 획득·해제의 명확한 규칙으로 직렬성을 보장한다. 운영에서는 <code>NOWAIT</code>·<code>SKIP LOCKED</code> 같은 비대기 옵션과 락 모니터링을 활용해 성능·가용성을 관리한다.</p><h5 id=락-동작-메커니즘-요약>락 동작 메커니즘 요약<a hidden class=anchor aria-hidden=true href=#락-동작-메커니즘-요약>#</a></h5><ul><li><p><strong>락 요청 & 호환성 검사</strong>: 요청은 <code>(txID, objectID, mode)</code> 로 전달된다. 락 테이블에서 현재 소유 목록과 비교해 허용하면 소유자 목록에 등록.</p></li><li><p><strong>대기 큐 관리</strong>: 충돌 시 요청은 대기 큐 (객체별) 로 들어가며, 큐에서 승인이 날 때까지 블로킹. 대기 시간 관측은 <code>lock wait time</code> 지표로 수집.</p></li><li><p><strong>데드락 탐지</strong>: 주기적/이벤트 기반으로 Wait-for 그래프 생성 → 사이클 존재 시 희생자 선정 (youngest/least-cost) → 롤백 및 락 해제.</p></li><li><p><strong>2PL(Strict)</strong>: 모든 락은 커밋/롤백 시에 해제. 단순하지만 읽기 중심 워크로드에서는 병목 유발.</p></li><li><p><strong>락 에스컬레이션</strong>: 메모리·관리 오버헤드 제어를 위해 다수의 행락을 테이블 락으로 승격. 임계치·시점 조정 필요.</p></li><li><p><strong>NOWAIT / SKIP LOCKED</strong>: 즉시 실패 (NOWAIT) 또는 잠긴 행 건너뛰기 (SKIP LOCKED) 로 소비자 큐 패턴에 유용.</p></li></ul><h5 id=락-동작-메커니즘-요약표>락 동작 메커니즘 요약표<a hidden class=anchor aria-hidden=true href=#락-동작-메커니즘-요약표>#</a></h5><table><thead><tr><th>메커니즘</th><th style=text-align:right>목적</th><th>동작 방식 (요약)</th><th>운영 포인트/메트릭</th></tr></thead><tbody><tr><td>락 요청 & 호환성 검사</td><td style=text-align:right>안전한 동시 접근 판정</td><td>락 매니저가 호환성 매트릭스로 승인/거절</td><td>lock request rate, grant latency</td></tr><tr><td>대기 큐 (Blocking)</td><td style=text-align:right>충돌 시 순서화된 대기</td><td>요청을 객체별 대기 큐에 삽입</td><td>평균 대기 시간, queue length</td></tr><tr><td>데드락 탐지/해결</td><td style=text-align:right>무한 대기 방지</td><td>Wait-for 그래프 → 사이클 탐지 → 희생자 롤백</td><td>deadlock count, avg resolution time</td></tr><tr><td>2 단계 락킹 (2PL)</td><td style=text-align:right>직렬성 보장</td><td>성장 (획득)→축소 (해제) 규칙 적용 (Strict: 커밋 시 해제)</td><td>abort rate, lock hold time</td></tr><tr><td>락 에스컬레이션</td><td style=text-align:right>락 관리 오버헤드 감소</td><td>행락이 임계치 넘으면 상위 락으로 승격</td><td>escalation events, concurrency drop</td></tr><tr><td>NOWAIT / SKIP LOCKED</td><td style=text-align:right>블로킹 회피 패턴 지원</td><td>즉시 실패 또는 잠긴 행 건너뛰기</td><td>failed-nowait count, skipped rows</td></tr></tbody></table><p>락 시스템은 <strong>요청→검사→승인/대기→해제</strong>의 순환을 반복한다. 핵심 운영 항목은 <strong>대기 시간, 데드락 빈도, 락 보유시간, 에스컬레이션 발생</strong>이며, 이들을 모니터링·알람화해 병목을 조기 탐지·조치해야 한다.</p><h5 id=락-획득대기해제-흐름도>락 획득·대기·해제 흐름도<a hidden class=anchor aria-hidden=true href=#락-획득대기해제-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  Start[트랜잭션 시작] --&gt; NeedLock{락 필요?}
  NeedLock -- NO --&gt; Execute[작업 수행]
  NeedLock -- YES --&gt; Req[&#34;락 요청 (to LockManager)&#34;]
  Req --&gt; Check{호환성 검사}
  Check -- 호환됨 --&gt; Grant[락 승인 → 소유자 등록]
  Grant --&gt; Execute
  Check -- 충돌 --&gt; WaitQ[대기 큐에 삽입]
  WaitQ --&gt; DeadlockCheck{데드락 탐지 주기/이벤트}
  DeadlockCheck -- 사이클 탐지 --&gt; Victim[희생자 선정 → 해당 Tx 롤백]
  Victim --&gt; ReleaseLocks[락 해제 → 대기 큐에 알림]
  DeadlockCheck -- 이상 없음 --&gt; Wait[대기 / 타임아웃/백오프]
  Wait --&gt; Retry{NOWAIT/SKIP_LOCKED?}
  Retry -- NOWAIT --&gt; Fail[즉시 실패 리턴]
  Retry -- SKIP_LOCKED --&gt; Skip[다음 항목으로 건너뛰기]
  Retry -- 일반 --&gt; Grant
  Execute --&gt; EndChk{2PL 여부}
  EndChk -- Strict(예) --&gt; Commit[커밋 → 락 일괄 해제]
  EndChk -- 비Strict --&gt; PartialRelease[단계적 해제]
  Commit --&gt; End[트랜잭션 종료]
  PartialRelease --&gt; Execute
</pre><p>다이어그램은 트랜잭션의 락 관련 전체 흐름을 보여준다. 트랜잭션이 락을 필요로 하면 락 매니저에 요청하고, 매니저는 <strong>호환성 검사</strong>로 즉시 승인하거나 <strong>대기 큐</strong>에 삽입한다. 대기 중 순환이 발생하면 <strong>데드락 탐지</strong>가 실행되어 희생자를 골라 롤백하고 락을 해제한다. <code>NOWAIT</code>·<code>SKIP LOCKED</code> 옵션은 블로킹을 회피하는 경로다. Strict 2PL 이면 모든 락은 커밋 시 일괄 해제되고, 비 Strict 이면 단계적 해제가 가능하다. 운영상 락 에스컬레이션·대기 시간·deadlock 빈도는 반드시 모니터링해야 한다.</p><h4 id=락-제어-흐름과-생명주기>락 제어 흐름과 생명주기<a hidden class=anchor aria-hidden=true href=#락-제어-흐름과-생명주기>#</a></h4><ul><li>트랜잭션이 데이터를 읽거나 쓸 때는 <strong>락을 먼저 요청</strong>한다.</li><li>락 관리자는 이미 잡힌 락들과 <strong>호환성 검사</strong>를 해서 승인하거나 대기시킨다.</li><li>너무 오래 기다리면 <strong>타임아웃</strong>이나 <strong>데드락 탐지</strong>로 트랜잭션을 중단·회복한다.</li><li>실무에서는 <strong>읽기 작업을 MVCC 로 비차단 처리</strong>, <strong>의도 락</strong>으로 계층적 충돌 검사, <strong>백오프·재시도 정책</strong>, 그리고 <strong>모니터링·알람</strong>을 반드시 함께 설계해야 안정적으로 운영된다.</li></ul><h5 id=락-요청---승인---해제-흐름>락 요청 - 승인 - 해제 흐름<a hidden class=anchor aria-hidden=true href=#락-요청---승인---해제-흐름>#</a></h5><ol><li>트랜잭션 시작 → 데이터 접근 요청</li><li>(읽기이면) MVCC 경로 확인: 스냅샷으로 읽기 → 락 요청 생략 (읽기 비차단)</li><li>(쓰기/갱신이면) 락 요청 → 의도 락 설정 (상위 단위) → 락 관리자에서 호환성 검사</li><li>승인 → 데이터 접근 실행 → 트랜잭션 커밋/롤백 → 모든 락 해제</li><li>비호환 → 대기 큐 진입 → 데드락 탐지/타임아웃/백오프/우선순위 규칙 적용 → 중단/재시도 또는 계속 대기</li><li>락 해제 시 대기 큐에서 다음 트랜잭션 승인 → 반복</li></ol><h5 id=락-데이터제어-흐름-요약표>락 데이터·제어 흐름 요약표<a hidden class=anchor aria-hidden=true href=#락-데이터제어-흐름-요약표>#</a></h5><table><thead><tr><th>단계</th><th>동작</th><th>세부 설명</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>1. 요청</td><td>트랜잭션 → 락 요청</td><td>읽기/쓰기 유형 식별 (MVCC 읽기 분기)</td><td>요청 유형 비율, TX 길이</td></tr><tr><td>2. 의도 표시</td><td>계층적 의도 락 설정</td><td>테이블→페이지→행 순서로 의도 락 등록</td><td>의도락 비율</td></tr><tr><td>3. 호환성 검사</td><td>Lock Manager 검사</td><td>기존 락과의 호환성 판정</td><td>lock wait time, queue length</td></tr><tr><td>4a. 승인</td><td>락 부여 → 실행</td><td>데이터 읽기/쓰기 수행</td><td>성공률, 응답시간</td></tr><tr><td>4b. 대기</td><td>대기 큐로 이동</td><td>타임아웃·데드락 감지 대상</td><td>wait timeout 발생률</td></tr><tr><td>5. 복구/정책</td><td>타임아웃, 데드락 탐지/재시도</td><td>Wound-Wait/Wait-Die/백오프 적용</td><td>deadlock count, retry rate</td></tr><tr><td>6. 해제</td><td>트랜잭션 완료 → 락 해제</td><td>대기자 승계, 락 소멸</td><td>lock table size, GC 필요 알림</td></tr></tbody></table><p>데이터 접근은 요청→의도표시→호환성검사→(승인/대기)→해제의 순환이며, MVCC·의도락·타임아웃·데드락 탐지·모니터링이 실무 완결성의 핵심이다.</p><h5 id=락-데이터제어-흐름>락 데이터·제어 흐름<a hidden class=anchor aria-hidden=true href=#락-데이터제어-흐름>#</a></h5><pre class=mermaid>flowchart TD
  A[트랜잭션 시작] --&gt; B[데이터 접근 요청]
  B --&gt; C{읽기 or 쓰기?}
  C --&gt;|&#34;읽기 (MVCC)&#34;| D[스냅샷 읽기: 락 불필요]
  C --&gt;|쓰기/갱신| E[&#34;의도 락 설정(IS/IX)&#34;]
  E --&gt; F[락 관리자: 호환성 검사]
  F --&gt;|호환| G[락 승인 → 데이터 실행]
  F --&gt;|비호환| H[대기 큐에 추가]
  H --&gt; I{데드락 탐지?}
  I --&gt;|발생| J[데드락 해결: victim abort]
  I --&gt;|미발생| K{타임아웃?}
  K --&gt;|예: 타임아웃| L[트랜잭션 중단 → 롤백]
  K --&gt;|아니오| M[&#34;백오프/재시도(지수적)/우선순위 적용&#34;]
  G --&gt; N{트랜잭션 완료?}
  N --&gt;|아니오| B
  N --&gt;|예| O[모든 락 해제]
  O --&gt; P[대기 큐 다음 승인 처리]
  P --&gt; Q[트랜잭션 종료]
</pre><p>이 흐름도는 실제 DB 의 락 제어 흐름을 보여준다. 읽기 요청은 MVCC 스냅샷으로 비차단 처리 (D). 쓰기/갱신은 의도 락을 먼저 등록 (E) 하고 Lock Manager 가 기존 락과 호환성을 검사 (F). 비호환이면 대기 큐 (H) 에 들어가며, 데드락 탐지 (I) 가 주기적으로 수행된다. 데드락이 확인되면 하나의 트랜잭션을 희생 (victim) 으로 정해 abort(J) 하고 락을 회수한다. 일반 대기 상황에서는 타임아웃 (L), 백오프·우선순위 (M) 정책으로 혼잡을 완화한다. 트랜잭션 완료 시 모든 락을 해제 (O) 하고, 대기 큐에서 다음 트랜잭션을 승계 (P) 한다.</p><h5 id=락-생명주기-생성유지소멸>락 생명주기 (생성→유지→소멸)<a hidden class=anchor aria-hidden=true href=#락-생명주기-생성유지소멸>#</a></h5><pre class=mermaid>flowchart TD
  A[락 요청 수신] --&gt; B{락 테이블에 엔트리 존재?}
  B --&gt;|아니오| C[락 객체 생성 -&gt; 엔트리 추가]
  B --&gt;|예| D[기존 엔트리 조회]
  C --&gt; E[호환성 검사/대기큐 초기화]
  D --&gt; E
  E --&gt; F{호환?}
  F --&gt;|예| G[락 승인: 소유자 목록에 추가]
  F --&gt;|아니오| H[대기 큐에 추가 -&gt; wait state]
  G --&gt; I[락 유지 중: 모니터링 지표 업데이트]
  I --&gt; J{마지막 소유자 해제?}
  J --&gt;|아니오| I
  J --&gt;|예| K[락 소멸: 엔트리 제거, 메모리 해제]
  H --&gt; L{타임아웃/데드락/우선순위 변경?}
  L --&gt;|타임아웃/중단| M[대기 트랜잭션 중단/알림]
  L --&gt;|우선순위 변동| N[큐 재정렬 -&gt; 다시 호환성 검사]
  K --&gt; O[&#34;대기 큐에서 다음 승인(있다면)&#34;]
  O --&gt; P[메트릭/로깅/알람 갱신]
</pre><p>락 생명주기는 (1) 요청 수신 → (2) 락 테이블에 해당 엔트리 존재 여부 확인 → (3) 없으면 락 객체 생성, 있으면 기존 엔트리를 조회 → (4) 호환성 검사 결과에 따라 승인되면 소유자 목록에 추가되어 유지되고, 비호환이면 대기 큐에 추가된다. 대기 중에는 타임아웃·데드락 탐지·우선순위 변경 등이 발생할 수 있으며, 마지막 소유자가 해제되면 락 엔트리가 소멸되고 대기 큐에서 다음 트랜잭션을 승인한다. 이 모든 과정에서 <strong>메트릭 갱신과 알람</strong>은 운영 안전성 확보를 위해 필수다.</p><h4 id=잠금-시스템-구조구성요소-종합-분석>잠금 시스템: 구조·구성요소 종합 분석<a hidden class=anchor aria-hidden=true href=#잠금-시스템-구조구성요소-종합-분석>#</a></h4><p>잠금 시스템은 데이터베이스의 동시성 제어 핵심 블록으로, 중앙의 <strong>Lock Manager</strong>가 락 요청을 받아 <strong>Lock Table</strong>에서 현재 보유자/대기자를 확인하고 즉시 부여하거나 <strong>Wait Queue</strong>에 넣는다.<br>대기 관계가 복잡해지면 <strong>Deadlock Detector</strong>가 그래프를 검사해 순환을 발견하고 희생자를 골라 롤백한다.<br>자원이 과다하게 잠기면 <strong>Escalation Controller</strong>가 행 단위 락을 테이블 단위로 올려 메모리를 아끼지만 동시성은 낮아진다.<br>실무에서는 락 테이블 접근 자체의 병목을 줄이기 위해 <strong>버킷 분할/striping</strong>을 적용하고, 분산 환경에선 external coordinator(예: ZK/etcd) 로 분산 락을 관리한다.<br>모니터링 (대기시간·deadlock 율) 은 안정 운영의 핵심이다.</p><h5 id=락-구조-모듈별-역할과-흐름>락 구조: 모듈별 역할과 흐름<a hidden class=anchor aria-hidden=true href=#락-구조-모듈별-역할과-흐름>#</a></h5><ul><li><strong>Lock Manager</strong>: 락의 중앙 컨트롤러. 정책 적용 및 외부 트랜잭션과 인터페이스 담당.</li><li><strong>Lock Table</strong>: 각 데이터 항목의 현재 락 상태 저장소. 해시로 빠르게 찾는다.</li><li><strong>Wait Queue Manager</strong>: 락을 못 받은 트랜잭션의 대기열을 관리. 우선순위·타임아웃 처리.</li><li><strong>Deadlock Detector</strong>: 트랜잭션 간 대기 그래프를 보고 교착 여부를 감지·해결.</li><li><strong>Escalation Controller</strong>: 잠금 오브젝트 수가 많을 때 락을 상위 단위로 올려 메모리/오버헤드를 관리.</li><li><strong>Transaction Manager</strong>: 트랜잭션 시작·커밋·롤백을 관리하고 락 해제와 연계.</li><li><strong>Monitoring</strong>: 락 통계와 알람 제공으로 운영 가시성 제공.</li><li><strong>Distributed Adapter</strong>: 분산 환경에서 lease/consensus 기반 락을 제공 (선택적).</li></ul><h6 id=락-시스템-구조별-핵심-정보>락 시스템 구조별 핵심 정보<a hidden class=anchor aria-hidden=true href=#락-시스템-구조별-핵심-정보>#</a></h6><table><thead><tr><th>항목</th><th>설명</th><th>역할</th><th>기능</th><th>특징</th><th>상호관계</th></tr></thead><tbody><tr><td>Lock Manager</td><td>중앙 제어 모듈</td><td>요청 조정·정책 적용</td><td>lock()/unlock(), compatibility 검사, escalation 트리거</td><td>중앙 집중형, 성능 중요</td><td>Lock Table, Wait Queue, TM, Deadlock Detector</td></tr><tr><td>Lock Table</td><td>해시 기반 상태 저장</td><td>보유자/대기자 추적</td><td>락 오브젝트 CRUD, bucket 분할</td><td>고빈도 접근, 버킷 락 필요</td><td>Lock Manager 가 직접 조작</td></tr><tr><td>Wait Queue Manager</td><td>대기열 관리</td><td>대기 순서·기아 방지</td><td>enqueue/dequeue, timeout, priority</td><td>대기자 관리 핵심</td><td>Lock Table 의 각 항목에 연결</td></tr><tr><td>Deadlock Detector</td><td>교착 탐지기</td><td>사이클 탐지·회복</td><td>wait-for 그래프, victim 선정</td><td>이벤트/주기 탐지 전략 있음</td><td>Wait Queue, TM, LM 연동</td></tr><tr><td>Escalation Controller</td><td>락 상승 관리자</td><td>락 수 제한·메모리 제어</td><td>threshold 검사·상승/하강 실행</td><td>트레이드오프 존재</td><td>Lock Table + Lock Manager</td></tr><tr><td>Transaction Manager</td><td>트랜잭션 생명주기</td><td>tx 상태·락 소유 관리</td><td>begin/commit/rollback, timeout</td><td>트랜잭션 길이가 문제 유발</td><td>Lock Manager 와 긴밀</td></tr><tr><td>Monitoring</td><td>통계 모듈</td><td>메트릭·알람 제공</td><td>lock waits, deadlock rate 집계</td><td>운영 대시보드 핵심</td><td>모든 컴포넌트에서 이벤트 수집</td></tr><tr><td>Distributed Adapter</td><td>분산 락 연동</td><td>분산 환경 락 제공</td><td>lease, renew, leader elect</td><td>네트워크 비용 발생</td><td>Lock Manager 또는 외부 서비스와 연동</td></tr></tbody></table><p>위 표는 락 시스템의 모듈 관점으로 각 모듈이 무엇을 담당하고 어떤 기능을 제공하는지 요약한다. 설계 시 Lock Manager 를 어떻게 분산/복제할지, Lock Table 의 파티셔닝 수준, Deadlock 탐지 빈도와 victim 정책 등이 전체 성능·가용성에 큰 영향을 준다.</p><h6 id=구조별-성능확장운영-속성>구조별 성능·확장·운영 속성<a hidden class=anchor aria-hidden=true href=#구조별-성능확장운영-속성>#</a></h6><table><thead><tr><th>항목</th><th>성능 특성</th><th>확장성/병목</th><th>오류/복구 고려</th><th>운영 파라미터 (예시)</th></tr></thead><tbody><tr><td>Lock Manager</td><td>높은 QPS 요구</td><td>중앙화 시 병목 → 분산 필요</td><td>단일 실패점, 고가용성 필요</td><td>worker pool size, lock timeout</td></tr><tr><td>Lock Table</td><td>O(1) lookup 목표</td><td>버킷 파티셔닝으로 확장</td><td>메모리 폭증 시 OOM</td><td>bucket count, stripe size</td></tr><tr><td>Wait Queue</td><td>enqueue/dequeue 지연 영향</td><td>대기열 길이 ↑ → latency</td><td>시간 초과 트랜잭션 rollback</td><td>max queue length, aging policy</td></tr><tr><td>Deadlock Detector</td><td>비용 (그래프 탐색) 존재</td><td>그래프 커지면 CPU 부담</td><td>victim rollback 필요</td><td>detection interval, trigger threshold</td></tr><tr><td>Escalation</td><td>락 갯수 감소 효과</td><td>빈번 시 동시성 저하</td><td>잘못된 threshold → throughput ↓</td><td>escalation threshold N</td></tr><tr><td>Transaction Manager</td><td>tx duration 영향 큼</td><td>긴 tx 는 시스템 억제</td><td>rollback/compensation 필요</td><td>tx timeout, max tx size</td></tr><tr><td>Monitoring</td><td>약간의 오버헤드</td><td>집계비용, 샘플링 필요</td><td>부정확한 알람 위험</td><td>sampling rate, retention</td></tr></tbody></table><p>각 구조가 실제 운영에서 어떤 성능 특성·병목·복구 이슈를 가지는지 요약한다. 설계 시에는 각 항목의 운영 파라미터 (예: detection interval, bucket 수) 를 워크로드에 맞춰 조정해야 한다.</p><h6 id=락-시스템-모듈-구조도>락 시스템 모듈 구조도<a hidden class=anchor aria-hidden=true href=#락-시스템-모듈-구조도>#</a></h6><pre class=mermaid>flowchart LR
  subgraph LOCK_SUBSYSTEM[&#34;Locking Subsystem&#34;]
    LM[Lock Manager]
    LT[Lock Table]
    WQ[Wait Queue Manager]
    DD[Deadlock Detector]
    EC[Escalation Controller]
    TM[Transaction Manager]
    MON[Monitoring / Stats]
    DA[Distributed Adapter]
  end

  TM --&gt;|requests lock/unlock| LM
  LM --&gt;|lookup/update| LT
  LT --&gt;|enqueue/dequeue| WQ
  WQ --&gt;|notifies| DD
  DD --&gt;|victim decision| TM
  LM --&gt;|apply escalation| EC
  EC --&gt; LT
  LM --&gt; MON
  LT --&gt; MON
  TM --&gt; MON
  LM --- DA
  DA --- LT
</pre><ul><li><strong>TM(Transaction Manager) → LM(Lock Manager)</strong>: 트랜잭션이 락을 요청하면 TM 이 LM 에 API 호출.</li><li><strong>LM(Lock Manager) ↔ LT(Lock Table)</strong>: LM 은 LT 에서 lock object 조회·갱신.</li><li><strong>LT(Lock Table) ↔ WQ</strong>(Wait Queue Manager): 락 미부여 시 대기열에 등록. WQ 는 대기자 우선순위·timeout 관리.</li><li><strong>WQ(Wait Queue Manager) → DD(Deadlock Detector)</strong>: 대기 발생 이벤트를 DD 에 전달해 교착 여부 검사 트리거.</li><li><strong>DD(Deadlock Detector) → TM(Transaction Manager)</strong>: victim 선택 후 TM 에 롤백 요청.</li><li><strong>LM(Lock Manager) → EC(Escalation Controller) → LT(Lock Table)</strong>: 많은 행 락을 감지하면 EC 가 threshold 초과 판단 후 LT 에 락 상승 명령.</li><li><strong>MON</strong>(Monitoring / Stats): 모든 주요 모듈로부터 이벤트/메트릭을 수집.</li></ul><h5 id=락-구성요소-데이터알고리즘-맵>락 구성요소: 데이터·알고리즘 맵<a hidden class=anchor aria-hidden=true href=#락-구성요소-데이터알고리즘-맵>#</a></h5><p>구성 요소는 실제 동작하는 데이터 구조와 알고리즘이다.<br>예: <strong>Lock Object</strong>(키별 상태) 와 <strong>Lock Request</strong>(요청자 정보) 는 Lock Table/Wait Queue 의 기본 단위다.<br><strong>Wait-for Graph</strong>는 교착 검출을 위한 논리 모델이며, <strong>Victim Selector</strong>는 교착 발생시 누가 롤백될지 결정한다. 운영에는 <strong>Stats Collector</strong>와 <strong>Timeout Manager</strong>가 필수다.</p><h6 id=락-구성-요소별-상세표>락 구성 요소별 상세표<a hidden class=anchor aria-hidden=true href=#락-구성-요소별-상세표>#</a></h6><table><thead><tr><th>구성 요소</th><th>설명</th><th>역할</th><th>기능</th><th>특징</th><th>상호관계</th><th style=text-align:right>필수/선택</th><th>속한 구조</th></tr></thead><tbody><tr><td>Lock Object</td><td>키별 락 레코드</td><td>holder/waiter 추적</td><td>mode, holders, queue pointer</td><td>메모리 중요</td><td>LM↔LT↔WQ</td><td style=text-align:right>필수</td><td>Lock Table</td></tr><tr><td>Lock Request</td><td>락 요청 레코드</td><td>요청자 식별</td><td>mode, ttl, priority</td><td>많은 수 존재</td><td>WQ↔DD</td><td style=text-align:right>필수</td><td>Wait Queue</td></tr><tr><td>Wait-for Graph</td><td>tx 간 대기 그래프</td><td>교착 탐지 모델</td><td>사이클 탐지</td><td>메모리 증감</td><td>DD↔TM</td><td style=text-align:right>필수 (교착 사용시)</td><td>Deadlock Detector</td></tr><tr><td>Victim Selector</td><td>victim 선택 모듈</td><td>victim 결정</td><td>scoring, policy</td><td>정책 영향 큼</td><td>DD→TM</td><td style=text-align:right>필수 (교착 사용시)</td><td>Deadlock Detector</td></tr><tr><td>Bucket Lock / Stripe</td><td>락 테이블 동시성 제어</td><td>bucket 단위 동시 접근 제어</td><td>stripe lock</td><td>병목 완화</td><td>LT 내부</td><td style=text-align:right>필수 (고동시성)</td><td>Lock Table</td></tr><tr><td>Escalation Policy</td><td>락 상승 파라미터</td><td>escalation 기준 제공</td><td>threshold, hysteresis</td><td>설계 민감</td><td>EC↔LM↔LT</td><td style=text-align:right>선택</td><td>Escalation Controller</td></tr><tr><td>Lock API</td><td>외부 인터페이스</td><td>락 요청/해제 API</td><td>lock/try/upgrade/unlock</td><td>사용성 영향</td><td>LM ↔ client</td><td style=text-align:right>필수</td><td>Lock Manager</td></tr><tr><td>Stats Collector</td><td>메트릭 수집</td><td>운영 지표 제공</td><td>counters, histograms</td><td>낮은 오버헤드 필요</td><td>MON ↔ LM/LT</td><td style=text-align:right>필수 (운영)</td><td>Monitoring</td></tr></tbody></table><p>구현 레벨에서 반드시 필요한 데이터 구조와 알고리즘을 정리한다. 실제 코드는 <code>Lock Object</code>(key→bucket) 와 <code>Lock Request</code> 의 효율적 할당/해제를 중심으로 최적화해야 한다. <code>Bucket Lock</code>/<code>Stripe</code> 는 락 테이블 내부 병목 완화를 위해 필수적으로 고려된다.</p><h6 id=구성-요소-운영복구-속성표>구성 요소 운영·복구 속성표<a hidden class=anchor aria-hidden=true href=#구성-요소-운영복구-속성표>#</a></h6><table><thead><tr><th>구성 요소</th><th style=text-align:right>메모리 오버헤드</th><th>복구 행동 (장애시)</th><th style=text-align:right>구현 복잡도</th><th>운영 파라미터</th></tr></thead><tbody><tr><td>Lock Object</td><td style=text-align:right>중</td><td>재시작 시 일반적으로 비휘발성으로 복원하지 않음 (트랜잭션 재시작)</td><td style=text-align:right>중</td><td>bucket size, GC interval</td></tr><tr><td>Lock Request</td><td style=text-align:right>낮~중</td><td>재시작 시 취소 필요</td><td style=text-align:right>낮</td><td>request TTL, retry interval</td></tr><tr><td>Wait-for Graph</td><td style=text-align:right>높 (트랜잭션 수에 비례)</td><td>재시작 시 전량 재구성 불가 (실시간)</td><td style=text-align:right>중</td><td>detection interval</td></tr><tr><td>Victim Selector</td><td style=text-align:right>낮</td><td>정책 파일 복구 가능</td><td style=text-align:right>낮</td><td>victim policy (youngest/least-work)</td></tr><tr><td>Bucket Lock</td><td style=text-align:right>낮</td><td>복구 없음</td><td style=text-align:right>낮</td><td>stripe count</td></tr><tr><td>Escalation Policy</td><td style=text-align:right>낮</td><td>설정 복구</td><td style=text-align:right>낮</td><td>threshold, hysteresis</td></tr><tr><td>Stats Collector</td><td style=text-align:right>낮</td><td>지속 로그/시계열 DB 로 보관</td><td style=text-align:right>낮</td><td>sampling rate, retention</td></tr></tbody></table><p>표 4 는 각 구성요소의 운영·복구 관련 속성을 요약한다. 특히 Wait-for Graph 는 트랜잭션 수가 많을 경우 메모리·CPU 비용이 커지므로 감시가 필요하며, Lock Object 의 경우 재시작 시 락 상태가 사라지는 것이 정상적이다 (트랜잭션이 재시작되어 재획득 필요).</p><h6 id=락-구성요소-데이터-흐름도>락 구성요소 데이터 흐름도<a hidden class=anchor aria-hidden=true href=#락-구성요소-데이터-흐름도>#</a></h6><pre class=mermaid>graph LR
  subgraph Locking_Component_View
    LO[Lock Object]
    LR[Lock Request]
    WB[Lock Bucket / Stripe]
    WN[Wait Queue Node]
    WFG[Wait-for Graph]
    VS[Victim Selector]
    API[Lock API]
    SC[Stats Collector]
  end

  API --&gt; LR
  LR --&gt; LO
  LO --&gt; WB
  LO --&gt; WN
  WN --&gt; WFG
  WFG --&gt; VS
  VS --&gt; API
  LO --&gt; SC
  LR --&gt; SC
</pre><ul><li>클라이언트 (애플리케이션) 나 트랜잭션 관리자가 <strong>Lock API</strong>를 호출해 락을 요청한다.</li><li><strong>Lock Request (LR)</strong> 레코드가 생성되어 요청 정보 (트랜잭션 ID, 모드, 우선순위, TTL 등) 를 캡처한다.</li><li>LR 은 대상 <strong>Lock Object (LO)</strong> 를 조회/조작한다. LO 는 특정 키 (테이블/페이지/행) 를 대표하는 락 엔트리다.</li><li>LO 는 내부적으로 <strong>Lock Bucket / Stripe (WB)</strong> 에 속해 있어 병목을 줄이기 위해 버킷 단위로 물리 분할된다.</li><li>LO 가 즉시 부여 불가하면 LR 은 <strong>Wait Queue Node (WN)</strong> 로 대기열에 들어간다.</li><li>WN 의 상태는 <strong>Wait-for Graph (WFG)</strong> 를 통해 트랜잭션 간 대기 관계로 모델링되어 Deadlock 탐지에 사용된다.</li><li>WFG 에서 교착 (사이클) 이 감지되면 <strong>Victim Selector (VS)</strong> 가 실행되어 희생자 트랜잭션을 선정하고 롤백/회복을 지시한다.</li><li>동시에 <strong>Stats Collector (SC)</strong> 가 LO 와 LR 의 이벤트 (획득/대기/해제 등) 를 수집해 운영 지표를 만든다.</li></ul><h4 id=락-패턴과-품질-속성의-설계-지도>락 패턴과 품질 속성의 설계 지도<a hidden class=anchor aria-hidden=true href=#락-패턴과-품질-속성의-설계-지도>#</a></h4><p>락은 여러 사용자가 같은 자원 (데이터) 을 동시에 바꿀 때 충돌을 막는 &rsquo; 열쇠 &rsquo; 다.<br>이 열쇠를 어떻게 쥐어줄지 (패턴) 가 다양하고, 각 방식은 성능·정확성·가용성 등에 다른 영향을 준다.<br>예를 들어 아주 작은 단위 (레코드) 를 잠그면 동시 작업이 많아져 속도가 빨라지지만 관리 비용이 커지고, 반대로 큰 덩어리 (테이블) 를 잠그면 관리가 쉬워지지만 동시성이 떨어진다. 그래서 DB 들은 의도 락, 락 에스컬레이션, 낙관적 검증, MVCC 같은 여러 기법을 조합해 적절한 균형을 맞춘다.<br>운영에서는 락 경합 지표를 모니터링하고 에스컬레이션 임계값·타임아웃을 잘 설정하는 것이 핵심이다.</p><h5 id=락-패턴-구조-분류와-설명>락 패턴 구조 분류와 설명<a hidden class=anchor aria-hidden=true href=#락-패턴-구조-분류와-설명>#</a></h5><p>패턴 구조는 <strong>락의 범위 (단위)</strong>, <strong>획득/해제 방식</strong>, <strong>충돌 판정 규칙</strong>, <strong>분산/로컬 특성</strong>으로 분류할 수 있다.<br>실무에서는 다음 패턴들을 조합해 사용한다:</p><ol><li>계층적 락 (의도 락 포함)</li><li>세밀한 레코드 락</li><li>락 에스컬레이션</li><li>낙관적 검증</li><li>분산 락 (서비스·합의)</li><li>락 스트라이핑·파티셔닝</li><li>락 -free 알고리즘</li></ol><table><thead><tr><th>패턴</th><th style=text-align:right>핵심 동작</th><th>장점</th><th>단점 / 운영 고려</th></tr></thead><tbody><tr><td>계층적 락</td><td style=text-align:right>DB→Table→Page→Record 계층 락</td><td>충돌 판정 효율화, 병렬성</td><td>구현 복잡성</td></tr><tr><td>의도 락 (IS/IX/SIX)</td><td style=text-align:right>상위에 의도 표시</td><td>빠른 충돌 판정</td><td>이해·디버깅 어려움</td></tr><tr><td>세밀한 레코드 락</td><td style=text-align:right>레코드 단위 락</td><td>높은 동시성</td><td>락 관리 오버헤드</td></tr><tr><td>락 에스컬레이션</td><td style=text-align:right>다수 락 → 상위 단위로 승격</td><td>락 테이블 제어</td><td>병렬성 급감 가능</td></tr><tr><td>낙관적 검증</td><td style=text-align:right>검증시 충돌 검사/롤백</td><td>락 비용 절감 (읽기 위주)</td><td>롤백 비용, 구현 복잡</td></tr><tr><td>분산 락 (lease/consensus)</td><td style=text-align:right>외부 코디네이터로 조율</td><td>멀티노드 일관성</td><td>네트워크·지연·복잡</td></tr><tr><td>락 스트라이핑</td><td style=text-align:right>락 버킷 분할</td><td>병목 완화</td><td>해시 분포 불균형 이슈</td></tr><tr><td>락 -free</td><td style=text-align:right>CAS 등 원자 연산</td><td>저지연·고성능</td><td>알고리즘 복잡·디버깅 어려움</td></tr></tbody></table><p>패턴 선택은 워크로드 (읽기 vs 쓰기, 충돌 빈도), 시스템 범위 (단일 노드 vs 분산), 운영 정책 (모니터링·에스컬레이션 기준) 에 따라 달라진다. 예컨대 읽기 중심·충돌 적은 환경에서는 낙관적 검증이나 MVCC 가 유리하고, 분산 멀티리전 환경에서는 분산 락/lease 와 합의가 필수적이다.</p><h5 id=품질-속성별-핵심-메커니즘-비교>품질 속성별 핵심 메커니즘 비교<a hidden class=anchor aria-hidden=true href=#품질-속성별-핵심-메커니즘-비교>#</a></h5><p>품질 속성 메커니즘은 " 어떤 메커니즘으로 특정 품질 (정확성·성능·가용성·확장성 등) 을 보장하거나 향상시키는지 " 를 명확히 보여주는 지도다.<br>각 메커니즘은 장점뿐 아니라 트레이드오프 (추가 비용·복잡성) 를 동반하므로, 설계 시 우선순위를 정해 적용해야 한다.</p><table><thead><tr><th>품질 속성</th><th style=text-align:right>대표 메커니즘</th><th>기대 효과</th><th>운영 리스크</th></tr></thead><tbody><tr><td>정확성</td><td style=text-align:right>2PL, 호환성 매트릭스</td><td>직렬성·무결성 보장</td><td>데드락·성능 저하</td></tr><tr><td>성능</td><td style=text-align:right>레코드 락, 락 스트라이프, 낙관적 검증</td><td>처리량·지연 개선</td><td>오버헤드·복잡성</td></tr><tr><td>가용성</td><td style=text-align:right>타임아웃, lease, MVCC 읽기</td><td>서비스 연속성 유지</td><td>부정확한 타임아웃으로 과도한 abort</td></tr><tr><td>확장성</td><td style=text-align:right>파티셔닝·샤딩, 분산 합의 최소화</td><td>수평 확장성 확보</td><td>분산 트랜잭션 복잡</td></tr><tr><td>복원력</td><td style=text-align:right>데드락 탐지·백오프</td><td>장애복구·교착 해소</td><td>탐지/복구 비용</td></tr><tr><td>운영성</td><td style=text-align:right>지표·트레이스·자동 튜닝</td><td>문제 탐지·정책 최적화</td><td>모니터링 비용</td></tr></tbody></table><p>설계자는 시스템 목표 (정확성 우선 vs 성능 우선 등) 에 따라 메커니즘을 선택해야 한다. 트랜잭션 무결성을 최우선으로 하면 2PL·직렬화류를 선택하지만 성능 희생이 따른다. 반대로 초고성능·저지연을 원하면 낙관적 검증이나 락 -free, MVCC 같은 기법을 선택하되 운영상 GC·모니터링 부담을 감수해야 한다.</p><h4 id=분산중앙-락-아키텍처와-서비스-모델>분산·중앙 락 아키텍처와 서비스 모델<a hidden class=anchor aria-hidden=true href=#분산중앙-락-아키텍처와-서비스-모델>#</a></h4><p>시스템 아키텍처는 <strong>어디서 누가 락을 관리하고, 락 획득·해제·충돌 해소를 어떻게 처리하는가</strong>를 규정한다.<br>서비스 모델은 <strong>그 락 관리 장치를 중앙에서 둘 것인가, 분산으로 둘 것인가, 섞을 것인가</strong>를 결정한다.</p><ul><li>중앙: 설계 단순 → 운영 쉬움, 그러나 단일 장애점·확장성 한계</li><li>분산: 확장성 우수 → 복잡도·합의 비용 증가</li><li>하이브리드: 성능과 일관성 균형을 목표로 현업에서 자주 선택</li></ul><h5 id=락-관리-아키텍처-유형-정리>락 관리 아키텍처 유형 정리<a hidden class=anchor aria-hidden=true href=#락-관리-아키텍처-유형-정리>#</a></h5><p>시스템 아키텍처는 <strong>애플리케이션 → 쿼리 처리 → 트랜잭션 관리 → 저장소</strong> 의 계층으로 구성된다.</p><p>각 계층에서 락 관련 책임은 다음과 같다.</p><ul><li>Application Layer: 트랜잭션 경계 지정 (시작/커밋/롤백), 클라이언트 측 재시도 로직</li><li>Query Processing Layer: 쿼리 실행 계획에서 필요한 범위/행을 결정 (범위 락 판단)</li><li>Transaction Management Layer: 실제 락 획득·해제, 락 테이블 관리, 데드락 탐지 및 정책 실행</li><li>Storage Management Layer: 버퍼/페이지 단위 락 적용 (물리적 레벨), 로그 기반 복구</li></ul><h6 id=아키텍처-유형별-카테고리화-프로토콜-스택-기준>아키텍처 유형별 카테고리화 (프로토콜 스택 기준)<a hidden class=anchor aria-hidden=true href=#아키텍처-유형별-카테고리화-프로토콜-스택-기준>#</a></h6><p>각 유형을 <strong>프로토콜·스택 관점</strong>으로 정의하고, 기능·역할·구체 내용을 정리한다.</p><ol><li><p>중앙집중형 (Monolithic / Central Lock Manager)</p><ul><li><strong>정의/설명</strong>: 모든 락 요청을 하나의 중앙 매니저가 처리.</li><li><strong>기능/역할</strong>: 전역 락 테이블 유지, 데드락 탐지, 우선순위 정책.</li><li><strong>구체사항</strong>: 낮은 로직 복잡도, 내부 메모리 기반 락테이블, 빠른 로컬 응답 (단일 프로세스)</li><li><strong>장단점</strong>: 단일 장애점 (SPOF), 수직 확장 필요, 동시 연결 폭주 시 병목 가능.</li></ul></li><li><p>파티셔닝형 (Shard-local Lock Managers)</p><ul><li><strong>정의/설명</strong>: 데이터 샤드별로 로컬 락 매니저를 둠.</li><li><strong>기능/역할</strong>: 로컬 트랜잭션은 로컬 락으로 처리, 크로스 - 샤드 트랜잭션은 조정 필요.</li><li><strong>구체사항</strong>: 파티셔닝 키 기준으로 락 분산, 파티션 간 조정은 2PC/분산 트랜잭션 사용</li><li><strong>장단점</strong>: 확장성 우수, 로컬 처리 지연 낮음. 그러나 분산 트랜잭션 비용 (2PC) 발생 가능.</li></ul></li><li><p>분산 합의 기반 Lock Service (Consensus-backed)</p><ul><li><strong>정의/설명</strong>: etcd/ZooKeeper/Chubby 같은 합의 (raft/paxos) 기반으로 락 토큰·리더십 관리.</li><li><strong>기능/역할</strong>: 강력한 일관성 보장, 리더 선출, lease(임대) 기반 소유권.</li><li><strong>구체사항</strong>: 락 획득은 consensus 로그 또는 ephemeral node 생성, lease 만료로 자동 해제 가능</li><li><strong>장단점</strong>: 일관성 강함 (내결함성 보장), 네트워크 왕복·레이턴시 비용 존재.</li></ul></li><li><p>하이브리드 (Local fast-path + Global coordinator)</p><ul><li><strong>정의/설명</strong>: 로컬 락 (빠른 경합 해결) + 글로벌 조정 (다중 샤드/크로스 트랜잭션)</li><li><strong>기능/역할</strong>: 로컬 우선 처리, 필요 시 글로벌 합의/조정 수행</li><li><strong>구체사항</strong>: 로컬 캐시 가능한 락 토큰, 글로벌 충돌 시 토큰 제출/해제 절차</li><li><strong>장단점</strong>: 성능과 정합성의 절충. 구현 복잡성 존재.</li></ul></li><li><p>클라이언트 - 오케스트레이트 (Optimistic / MVCC 중심)</p><ul><li><strong>정의/설명</strong>: 읽기/가능한 쓰기를 락 없이 허용하고 커밋 시 충돌 검사 (낙관적). MVCC 는 읽기 스냅샷 제공.</li><li><strong>기능/역할</strong>: 버전 관리, 커밋 시 검증·재시도, snapshot 읽기 제공</li><li><strong>구체사항</strong>: 높은 읽기 확장성, 쓰기 충돌 시 롤백/재시도 처리 필요</li><li><strong>장단점</strong>: 읽기 성능 매우 우수, 복잡한 충돌 시나리오 존재.</li></ul></li></ol><h6 id=락-아키텍처-유형-비교표>락 아키텍처 유형 비교표<a hidden class=anchor aria-hidden=true href=#락-아키텍처-유형-비교표>#</a></h6><table><thead><tr><th>유형</th><th>핵심 프로토콜/모델</th><th>장점</th><th>단점</th><th>대표 사용 사례 (예시)</th></tr></thead><tbody><tr><td>중앙집중형</td><td>단일 락테이블, RPC/직접 호출</td><td>구현 단순, 낮은 로컬 오버헤드</td><td>SPOF, 수평 확장성 낮음</td><td>소규모 DB, 임베디드 DB</td></tr><tr><td>파티셔닝형</td><td>샤드별 로컬 락 + 2PC (필요시)</td><td>확장성 우수, 로컬 처리 빠름</td><td>분산 트랜잭션 비용</td><td>샤드 기반 OLTP</td></tr><tr><td>합의기반 분산</td><td>Raft/Paxos + lease/ephemeral</td><td>강한 일관성, 내결함성</td><td>높은 레이턴시, 네트워크 의존</td><td>글로벌 키 - 서비스 (leader election)</td></tr><tr><td>하이브리드</td><td>로컬 fast-path + 글로벌 coordinator</td><td>성능·정합성 균형</td><td>설계·운영 복잡</td><td>대규모 분산 DB(혼합 워크로드)</td></tr><tr><td>낙관적/MVCC</td><td>버전 검사, 스냅샷</td><td>읽기 확장성 우수</td><td>쓰기 충돌 재시도 필요</td><td>읽기 중심 서비스, Postgres/InnoDB 설정</td></tr></tbody></table><p>각 아키텍처 유형은 <strong>성능·확장성·정합성·운영 복잡성</strong> 사이에서 서로 다른 균형을 선택한다. 설계 시 워크로드 특성 (읽기 vs 쓰기, 트랜잭션 분포), 장애 허용도, 운영 역량을 고려해 아키텍처를 결정해야 한다.</p><h5 id=락-서비스-메시지동작-모델>락 서비스 메시지·동작 모델<a hidden class=anchor aria-hidden=true href=#락-서비스-메시지동작-모델>#</a></h5><p>서비스 모델은 락 관련 <strong>통신 패턴 (메시지 형식)</strong> 과 <strong>관리 주체 분포 (중앙/분산/하이브리드)</strong> 를 규정한다.<br>메시지 형식은 락 요청/응답, lease 갱신, 해제, 알림 (해제/충돌) 등으로 구성된다.</p><h6 id=유형별-카테고리화-메시지-형식-기준>유형별 카테고리화 (메시지 형식 기준)<a hidden class=anchor aria-hidden=true href=#유형별-카테고리화-메시지-형식-기준>#</a></h6><p>각 모델을 메시지·동작 관점에서 정리한다.</p><ol><li><p>동기 RPC 기반 (Synchronous RPC)</p><ul><li><strong>정의/설명</strong>: 클라이언트가 락 요청을 보내고 응답을 기다림 (예: gRPC, Thrift).</li><li><strong>기능/역할</strong>: 즉시 성공/실패 반환, 간단한 재시도/타임아웃 정책.</li><li><strong>구체사항</strong>: 낮은 레이턴시 네트워크 환경에서 적합, 동기화된 로직 단순화.</li><li><strong>주의</strong>: 네트워크 지연 시 클라이언트 블로킹.</li></ul></li><li><p>비동기 메시지 / 큐 기반</p><ul><li><strong>정의/설명</strong>: 락 요청을 비동기 큐에 넣고 콜백/알림으로 처리 결과 전달.</li><li><strong>기능/역할</strong>: 높은 처리량, 느슨한 결합, 이벤트 기반 재시도</li><li><strong>구체사항</strong>: 메시지 순서·중복 처리 고려 필요 (Exactly-once 보장 문제).</li></ul></li><li><p>Lease / Token 기반 (시간 기반 소유권)</p><ul><li><strong>정의/설명</strong>: 락 소유권을 일정 기간 (lease) 만 발급, 주기적 갱신 (heartbeat) 필요.</li><li><strong>기능/역할</strong>: 실패 시 자동 해제 (lease 만료), 네트워크 분할에서 안전성 제공</li><li><strong>구체사항</strong>: clock skew/lease 만료 경계 처리 주의. 예: 분산 락 서비스에서 자주 사용.</li></ul></li><li><p>Consensus 로그/토폴로지 기반 (Append-only)</p><ul><li><strong>정의/설명</strong>: 락 관련 이벤트 (획득/해제) 를 합의 로그에 기록해 상태를 결정.</li><li><strong>기능/역할</strong>: 강한 일관성, 순서 보장</li><li><strong>구체사항</strong>: 레이턴시 높음, 내결함성 우수.</li></ul></li><li><p>Callback / Watch / Notify</p><ul><li><strong>정의/설명</strong>: 락이 해제되면 대기 클라이언트에게 푸시 알림 (또는 watch) 이 전달.</li><li><strong>기능/역할</strong>: 폴링 대신 효율적 알림, 대기 비용 절감</li><li><strong>구체사항</strong>: Watch 의 수명과 누수 관리 필요.<br>``</li></ul></li></ol><h6 id=락-서비스-메시지-유형-비교표>락 서비스 메시지 유형 비교표<a hidden class=anchor aria-hidden=true href=#락-서비스-메시지-유형-비교표>#</a></h6><table><thead><tr><th>모델 (메시지 형식)</th><th>동작 패턴</th><th>장점</th><th>단점</th><th>적합 사례</th></tr></thead><tbody><tr><td>동기 RPC</td><td>요청→응답 (블로킹)</td><td>단순, 즉시 실패 인지</td><td>클라이언트 블로킹, 네트워크 의존</td><td>낮지연 내부 네트워크</td></tr><tr><td>비동기 큐</td><td>요청 비동기 처리·콜백</td><td>높은 처리량, 비동기화 유리</td><td>복잡한 에러·중복 처리</td><td>이벤트 기반 시스템</td></tr><tr><td>Lease/Token</td><td>소유권 임대·갱신</td><td>실패 안전 (자동 해제)</td><td>클럭문제·만료 경계</td><td>분산 락 (leader election)</td></tr><tr><td>Consensus 로그</td><td>합의 기반 이벤트</td><td>강한 일관성·순서 보장</td><td>높은 레이턴시</td><td>글로벌 정합성 필요 시스템</td></tr><tr><td>Watch/Notify</td><td>해제 시 푸시 알림</td><td>효율적 대기 해제 통보</td><td>연결 유지·스케일 문제</td><td>대기자가 많은 환경</td></tr></tbody></table><p>서비스 모델은 메시지 패턴 (동기/비동기/lease/consensus/notify) 에 따라 <strong>지연, 처리량, 일관성, 구현 복잡도</strong>가 달라진다. 실무선택은 네트워크 특성, 장애 모델, 동시성 요구사항에 의해 결정된다.</p><h5 id=분산-시스템에서의-락-연동-실무분석>분산 시스템에서의 락 연동 실무분석<a hidden class=anchor aria-hidden=true href=#분산-시스템에서의-락-연동-실무분석>#</a></h5><p>여러 시스템이 같은 자원 (데이터, 파일, 캐시 키 등) 에 접근할 때 <strong>락을 사용해 충돌을 막는 건 기본</strong>이다.<br>그러나 분산 환경에서는 프로세스가 갑자기 죽거나 네트워크가 끊기는 일이 생기므로, 단순히 &rsquo; 락을 잡았다/풀었다 &rsquo; 만으로는 안전하지 않다.<br>신뢰성 높은 분산 락은 <strong>시간 (lease), 순번/토큰 (fencing), 합의 (consensus)</strong> 같은 추가 메커니즘을 사용해 &rsquo; 누가 진짜 락을 갖고 있는가 &rsquo; 를 보장한다.<br>DB 의 MVCC 와 결합할 때는 읽기는 버전으로, 쓰기·범위 문제는 락으로 보완하는 식으로 설계하는 게 보편적이다.</p><h6 id=시스템별-락-상호작용과-실무-유의점>시스템별 락 상호작용과 실무 유의점<a hidden class=anchor aria-hidden=true href=#시스템별-락-상호작용과-실무-유의점>#</a></h6><p>아래는 대표 시스템별 상호작용 메커니즘과 실무상 주의사항·권장 대응이다.</p><ol><li><p><strong>관계형 DB (내부 락 vs MVCC)</strong></p><ul><li><strong>상호작용 목적</strong>: 트랜잭션 수준 일관성 확보, phantom/범위 문제 해결.</li><li><strong>메커니즘</strong>: 로컬 락 (행/범위/테이블) 또는 MVCC + gap/predicate lock(예: InnoDB).</li><li><strong>주의</strong>: 범위 락은 인덱스 구조와 성능에 민감 → 인덱스 설계 중요.</li></ul></li><li><p><strong>분산 코디네이터 (ZooKeeper / etcd / Consul)</strong></p><ul><li><strong>목적</strong>: 분산 락, 리더 선출, 구성 데이터의 일관적 저장.</li><li><strong>메커니즘</strong>: Consensus(대표: Raft, Zab) 기반의 세션·lease 로 락 보장.</li><li><strong>주의</strong>: 높은 신뢰성 제공하나 지연·복잡성 발생 → latency 민감 path 엔 주의.</li></ul></li><li><p><strong>인메모리 키 - 값 (예: Redis)</strong></p><ul><li><strong>목적</strong>: 경량 분산 락, 캐시 무효화 직렬화.</li><li><strong>메커니즘</strong>: SETNX + expire 패턴, Redlock 같은 분산 알고리즘 (의견 분분).</li><li><strong>주의</strong>: 프로세스 죽음·네트워크 분리에서 안전성 약함 → TTL + fencing 보강 권장. Redlock 은 설계·분산 조건 검토 필요.</li></ul></li><li><p><strong>파일시스템 / 네트워크 파일 (NFS 등)</strong></p><ul><li><strong>목적</strong>: 파일 접근 직렬화 (쓰기 동기화).</li><li><strong>메커니즘</strong>: fcntl/lockf 등의 POSIX 락, 또는 앱 레벨 분산 락.</li><li><strong>주의</strong>: NFS 등은 락 구현/전파가 약할 수 있어 분산 락 서비스와 연계하거나 파일 잠금 대신 메시지 기반 동기화 권장.</li></ul></li><li><p><strong>컨테이너/오케스트레이션 (Kubernetes leader election)</strong></p><ul><li><strong>목적</strong>: 싱글톤 작업자 (leader) 보장, 스케줄링 일관성.</li><li><strong>메커니즘</strong>: ConfigMap/Lease API, 또는 등 d/zookeeper 를 이용한 leader election.</li><li><strong>주의</strong>: leader 가 죽었을 때 재선출과 임시 중복 실행 방지 (운영자 정의 시간/TTL 필요).</li></ul></li><li><p><strong>메시지 큐 / 이벤트 시스템</strong></p><ul><li><strong>목적</strong>: 작업 단위의 직렬화, 중복 처리 방지 (idempotency 보장).</li><li><strong>메커니즘</strong>: 큐 브로커의 메시지 배달 보장 + 외부 락 또는 토큰 (fencing) 사용.</li><li><strong>주의</strong>: 메시지 중복·재시도와 락 타이밍 간 교착 가능성 대비.</li></ul></li></ol><h6 id=시스템별-락-상호작용-요약표>시스템별 락 상호작용 요약표<a hidden class=anchor aria-hidden=true href=#시스템별-락-상호작용-요약표>#</a></h6><table><thead><tr><th>대상 시스템</th><th>일반 메커니즘</th><th style=text-align:right>목적</th><th>주요 리스크 (주의사항)</th><th>권장 대응 패턴</th></tr></thead><tbody><tr><td>관계형 DB</td><td>로컬 락, MVCC+gap lock</td><td style=text-align:right>트랜잭션 일관성, phantom 방지</td><td>범위 락 비용, 인덱스 영향</td><td>인덱스 설계·짧은 Tx·부분 락</td></tr><tr><td>분산 코디네이터 (etcd/ZK)</td><td>Consensus 기반 세션/lease</td><td style=text-align:right>글로벌 락, leader election</td><td>지연·운영 복잡성</td><td>consensus 기반 사용, 모니터링</td></tr><tr><td>Redis / In-memory</td><td>SETNX + TTL, Redlock</td><td style=text-align:right>경량 분산 락, 캐시 직렬화</td><td>TTL 만으로 불충분, split-brain</td><td>TTL+fencing, 중앙 코디네이터 보강</td></tr><tr><td>파일시스템 (NFS)</td><td>POSIX fcntl/lockf</td><td style=text-align:right>파일 접근 직렬화</td><td>NFS 락 전파 한계</td><td>분산 락 서비스 병행 또는 메시지 동기화</td></tr><tr><td>Kubernetes</td><td>Lease/ConfigMap 기반 leader</td><td style=text-align:right>단일 작업자 보장</td><td>leader 재선출 시 중복 수행</td><td>fencing, leader-health 체크</td></tr><tr><td>메시지 큐</td><td>브로커 보장 + 외부 락</td><td style=text-align:right>작업 직렬화·중복 방지</td><td>메시지 재시도와 락 교착</td><td>idempotency 설계, 토큰 기반 제어</td></tr></tbody></table><ul><li><p>핵심: <strong>분산 환경에서는 &rsquo; 락 획득 &rsquo; 만으로 끝나지 않는다</strong>. 프로세스/네트워크 실패에 대비한 <strong>타임아웃 (lease)</strong>, <strong>fencing token(실행 권한증명)</strong>, 그리고 <strong>consensus 기반 코디네이터</strong> 사용 여부가 안전성의 핵심이다.</p></li><li><p>Redis 같은 경량 솔루션은 저지연 장점이 있지만 안전 모델 (프로세스 죽음, 네트워크 분리) 을 명확히 하고 보강해야 쓸 수 있다. 파일 시스템 락은 분산 환경에서 신뢰성이 떨어질 수 있으니 서비스 레벨 동기화 대안을 고려해야 한다.</p></li></ul><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=락킹-장점과-실무-적용지침>락킹 장점과 실무 적용지침<a hidden class=anchor aria-hidden=true href=#락킹-장점과-실무-적용지침>#</a></h4><p>락킹은 여러 사용자가 동시에 데이터에 접근할 때 <strong>정합성</strong>을 보장하는 도구다. 공유 락 (읽기) 과 배타 락 (쓰기) 을 통해 충돌을 제어하고, 2 단계 잠금 같은 프로토콜은 트랜잭션 실행을 직렬화할 수 있게 한다.<br>장점은 데이터 무결성 확보와 운영적 예측성 (용량·SLA) 이며, 단점은 락 경쟁과 데드락·지연이며 이들은 MVCC 나 낙관적 기법과 섞어 해결한다.</p><h5 id=락킹의-핵심-장점-정리>락킹의 핵심 장점 정리<a hidden class=anchor aria-hidden=true href=#락킹의-핵심-장점-정리>#</a></h5><table><thead><tr><th>장점</th><th>근거 (왜 그런가)</th><th>실무 효과 (무엇에 도움이 되는가)</th></tr></thead><tbody><tr><td>데이터 일관성 보장</td><td>2PL·상호배제 이론에 따른 직렬화 보장</td><td>금융·회계 등 정합성 필수 시스템에서 사고 방지</td></tr><tr><td>예측 가능한 성능</td><td>결정적 락 로직 → 용량 예측 가능</td><td>SLA 운영·용량계획·리얼타임 서비스 적합</td></tr><tr><td>충돌·손실 예방</td><td>배타·갱신 락으로 Lost Update 등 방지</td><td>동시 갱신 환경에서 데이터 불일치 감소</td></tr><tr><td>세밀한 제어 가능</td><td>락 모드·단위·에스컬레이션으로 튜닝 가능</td><td>다양한 워크로드에 맞춘 최적화 가능</td></tr><tr><td>성숙성·표준성</td><td>ANSI SQL·오랜 도입 사례로 검증됨</td><td>도입·운영 리스크 축소, 인력 확보 용이</td></tr><tr><td>운영·관리 용이</td><td>Lock Manager/Lock Table 로 상태 관찰 가능</td><td>데드락 대응·원인 분석 시간 단축</td></tr></tbody></table><ul><li>락킹은 <strong>정합성이 최우선</strong>인 경우 탁월한 선택이다.</li><li>또한 <strong>예측 가능성</strong>과 <strong>운영성 (모니터링·복구)</strong> 측면에서 실무적 가치를 제공한다.</li><li>반면 락 경쟁·데드락·성능 저하라는 <strong>비용 (트레이드오프)</strong> 이 있으므로, MVCC·낙관적 동시성 등과 함께 혼용하거나 락 단위·타임아웃·에스컬레이션 정책을 세심히 설계해야 한다.</li></ul><h4 id=락-기반-동시성의-단점제약대응>락 기반 동시성의 단점·제약·대응<a hidden class=anchor aria-hidden=true href=#락-기반-동시성의-단점제약대응>#</a></h4><p>락 기반 동시성 제어는 데이터 무결성을 직접적으로 보장하지만, <strong>데드락·블로킹·기아</strong> 같은 본질적 문제가 따라온다.<br>또한 락 그레인·에스컬레이션·분산 환경의 네트워크 제약은 설계 한계가 된다.<br>실무에서는 트랜잭션을 짧게 유지하고 (트랜잭션 경계 관리), 락 그레인을 세분화하며 (행 단위 우선), 데드락 탐지·타임아웃·재시도 정책을 도입해 완화한다.<br>읽기 중심 워크로드나 분산 시스템에서는 MVCC·낙관적 제어·파티셔닝·리플리카 등 대안을 함께 사용해야 안정성과 성능을 확보할 수 있다.</p><h5 id=락-기반-단점-및-완화-방안>락 기반 단점 및 완화 방안<a hidden class=anchor aria-hidden=true href=#락-기반-단점-및-완화-방안>#</a></h5><table><thead><tr><th>단점</th><th>상세 설명</th><th>원인</th><th>실무 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>데드락</td><td>순환 대기 상태</td><td>락 획득 순서 충돌</td><td>롤백 증가, 응답 지연</td><td>데드락 탐지 + 희생자, 락 순서 규약, 타임아웃</td><td>MVCC, 낙관적 제어</td></tr><tr><td>처리량 저하 (블로킹)</td><td>락 보유로 동시성 감소</td><td>테이블 락/장수 트랜잭션</td><td>TPS 저하, SLA 위반</td><td>그레인 축소, 트랜잭션 단축, 배치화</td><td>MVCC, 리플리카</td></tr><tr><td>기아 (Starvation)</td><td>특정 트랜잭션 지속 대기</td><td>공정성 부족, 우선순위 편향</td><td>일부 요청 지연</td><td>에이징, 공정 큐, 우선순위 조정</td><td>공정 스케줄러</td></tr><tr><td>운영 오버헤드</td><td>락 관리 비용 (메모리/CPU)</td><td>락 수 증가·복잡한 매니저</td><td>리소스 소모, 관리 복잡</td><td>락 테이블 파티셔닝, 모니터링 자동화</td><td>Lock-free 설계</td></tr></tbody></table><p>락 기반 제어는 강력한 무결성 보장을 제공하지만 데드락·블로킹·기아 같은 핵심 단점을 내포한다. 운영 쪽에서는 탐지·타임아웃·우선순위·에스컬레이션 정책을 잘 설계하고, 필요하면 MVCC·낙관적 제어·리플리카·파티셔닝 같은 대안을 병행 적용한다.</p><h5 id=락-적용의-제약조건-및-대응>락 적용의 제약조건 및 대응<a hidden class=anchor aria-hidden=true href=#락-적용의-제약조건-및-대응>#</a></h5><table><thead><tr><th>제약사항</th><th>상세 설명</th><th>원인</th><th>영향</th><th>완화 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>락 그레인 한계</td><td>행/페이지/테이블 선택에 따른 성능 차이</td><td>DB 설계, 스키마</td><td>처리량·응답성 변동</td><td>인덱스 개선, 행단위 우선</td><td>MVCC, 파티셔닝</td></tr><tr><td>분산 환경</td><td>네트워크 파티션·클럭 불일치</td><td>네트워크/시계</td><td>레이턴시↑, 가용성↓</td><td>합의 기반 락, 펜싱 토큰</td><td>이벤트 소싱, CQRS</td></tr><tr><td>장수 트랜잭션</td><td>긴 락 보유 시간</td><td>배치/사용자 행위</td><td>전체 혼잡·bloat</td><td>타임아웃, 청크 처리</td><td>비동기 워크플로우</td></tr><tr><td>자원 제약 (메모리)</td><td>락 테이블 크기 증가</td><td>활성 락 수</td><td>서버 부하, 성능 저하</td><td>락 테이블 최적화, 파티셔닝</td><td>Lock-free 자료구조</td></tr></tbody></table><p>제약사항은 환경적·구조적 한계다. 분산·대규모 환경에서는 단일 글로벌 락에 의존하면 비용이 크므로 합의 기반 기법·펜싱·분산 아키텍처 (파티셔닝, 이벤트 소싱) 가 요구된다. 또한 장수 트랜잭션·자원 제약은 설계 단계에서 예방·모니터링으로 관리해야 한다.</p><h4 id=동시성일관성-트레이드오프와-절충전략>동시성·일관성 트레이드오프와 절충전략<a hidden class=anchor aria-hidden=true href=#동시성일관성-트레이드오프와-절충전략>#</a></h4><ul><li><p><strong>핵심 질문</strong>: " 내 시스템에선 락 (강한 일관성) 과 MVCC(높은 동시성) 중 무엇을 택해야 하나?"</p></li><li><p><strong>간단한 규칙</strong>:</p><ul><li>읽기 위주이고 응답성이 최우선이면 <strong>MVCC(낙관적 처리)</strong>.</li><li>재무·정산처럼 절대적 무결성이 필요하면 <strong>락 (비관적/직렬화)</strong>.</li><li>대부분 현실 시스템은 <strong>혼합</strong>—대부분 MVCC 로 운영하되, 중요한 연산만 직렬화하거나 <code>SELECT FOR UPDATE</code> 로 보호한다.</li></ul></li><li><p><strong>마지막 포인트</strong>: 어떤 선택도 완전한 정답은 없다. 워크로드 측정 → 소규모 파일럿 → 모니터링 기반 튜닝이 필수다.</p></li></ul><h5 id=의사결정-체크리스트>의사결정 체크리스트<a hidden class=anchor aria-hidden=true href=#의사결정-체크리스트>#</a></h5><ol><li><p><strong>워크로드 분석</strong>: 읽기/쓰기 비율, 트랜잭션 길이, 충돌 빈도 (핫스팟) 를 먼저 계량화.</p></li><li><p><strong>요구 일관성 수준</strong>: 비즈니스 규칙이 &rsquo; 완전 직렬성 &rsquo; 을 요구하는지 확인.</p></li><li><p><strong>운영 비용 검토</strong>: 재시도·롤백 비용, 데드락 복구 비용, 스토리지 증가 (버전 보관) 비용을 산정.</p></li><li><p><strong>정책 선택</strong>:</p><ul><li>읽기 우세·일관성 완화 가능 → <strong>MVCC/낙관적</strong> 우선</li><li>강한 일관성 (금융 등) → <strong>락 기반 / SERIALIZABLE</strong> (또는 selective serializable)</li><li>혼합 환경 → 하이브리드 (Selective Serializable, Hybrid Locking 등)</li></ul></li><li><p><strong>모니터링·긴급대응</strong>: lock wait time, deadlock count, retry rate, skip-locked effects 관찰 및 알람.</p></li><li><p><strong>사전 검증</strong>: 실제 워크로드로 A/B 벤치마크, 롤백 시나리오 비용 측정.<br>오프 상세 정리 (A vs B: 장단·고려 기준)</p></li></ol><h5 id=트레이드오프>트레이드오프<a hidden class=anchor aria-hidden=true href=#트레이드오프>#</a></h5><ol><li><p><strong>동시성 vs 일관성</strong></p><ul><li>A: <strong>락 기반 (Strong Locking)</strong><ul><li>장점: 높은 일관성 (직렬성), 예측 가능한 동작</li><li>단점: 락 경합, 데드락, 처리량 저하</li><li>고려 기준: 비즈니스 규칙의 무결성 요구 (예: 금전), 충돌 허용도 낮음</li></ul></li><li>B: <strong>MVCC (Multi-Version)</strong><ul><li>장점: 읽기 비차단, 높은 동시성, 낮은 읽기 대기</li><li>단점: 일부 격리 이상 (SI 의 write-skew), 버전/GC 오버헤드</li><li>고려 기준: 읽기 비율 높음, 스토리지·운영 비용 수용 가능</li></ul></li></ul></li><li><p><strong>성능 vs 정확성 (Granularity)</strong></p><ul><li>A: <strong>세밀한 락 (Row-Level)</strong><ul><li>장점: 병행성 우수</li><li>단점: 락 관리 오버헤드↑</li><li>고려: 트랜잭션 수·트랜잭션당 락 수</li></ul></li><li>B: <strong>거친 락 (Table-Level)</strong><ul><li>장점: 관리 단순, 메모리 절감</li><li>단점: 동시성 급감</li><li>고려: 트랜잭션이 대량 행을 동시에 접근하지 않는가?</li></ul></li></ul></li><li><p><strong>즉시성 vs 처리량 (Pessimistic vs Optimistic)</strong></p><ul><li>A: <strong>비관적 락</strong><ul><li>장점: 즉시 충돌 차단 → 안전</li><li>단점: 처리량 저하, 데드락 가능</li><li>고려: 충돌 확률 높음? 롤백 비용 허용 범위?</li></ul></li><li>B: <strong>낙관적 락</strong><ul><li>장점: 높은 처리량, 낮은 락 오버헤드</li><li>단점: 충돌 시 재시도 비용 (시스템·사용자 영향)</li><li>고려: 충돌 빈도·트랜잭션 재시도 비용</li></ul></li></ul></li></ol><h5 id=락-vs-mvcc-선택표->락 vs. MVCC 선택표 `<a hidden class=anchor aria-hidden=true href=#락-vs-mvcc-선택표->#</a></h5><table><thead><tr><th>판단축</th><th>락/비관적</th><th>MVCC/낙관적</th><th>고려 기준 (선택 포인트)</th></tr></thead><tbody><tr><td>동시성</td><td>낮음 (직렬성 우선)</td><td>높음 (읽기 비차단)</td><td>동시 연결 수, 응답성 요구</td></tr><tr><td>일관성</td><td>강함 (직렬성 가능)</td><td>약간 완화 가능 (SI 한계)</td><td>비즈니스 무결성 요구</td></tr><tr><td>성능 (읽기)</td><td>낮음 (경합 발생)</td><td>우수 (읽기 대기 거의 없음)</td><td>읽기/쓰기 비율</td></tr><tr><td>성능 (쓰기)</td><td>중~높음 (경합 시 저하)</td><td>중~저 (버전·GC 오버헤드)</td><td>쓰기 빈도, 롤백 비용</td></tr><tr><td>운영비용</td><td>낮을 수 있음 (스토리지 적음)</td><td>높음 (스토리지·GC 필요)</td><td>스토리지 비용 수용여부</td></tr><tr><td>복잡성</td><td>낮음 (정책 단순)</td><td>높음 (버전관리·GC·모니터링 필요)</td><td>운영 역량</td></tr></tbody></table><p>락은 **정확성 (직렬성)**을 보장하지만 동시성과 응답성에서 비용을 치르고, MVCC 는 <strong>읽기 응답성·동시성</strong>을 살리는 대신 버전 관리·가비지 컬렉션의 운영 부담을 발생시킨다. 선택은 워크로드 (읽기/쓰기 비율), 비즈니스 일관성 요구, 운영·스토리지 리소스 가용성에 따라 달라진다.</p><h5 id=락mvcc-절충-하이브리드-기법-비교>락·MVCC 절충 (하이브리드) 기법 비교<a hidden class=anchor aria-hidden=true href=#락mvcc-절충-하이브리드-기법-비교>#</a></h5><table><thead><tr><th>하이브리드 기법</th><th style=text-align:right>구성 요소</th><th>적용 목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>선택적 직렬화 (Selective Serializable)</td><td style=text-align:right>기본 MVCC + 특정 트랜잭션만 SERIALIZABLE 또는 FOR UPDATE</td><td>중요 연산만 강일관성 보장</td><td>전체 성능 저하 최소화</td><td>승격 정책 설계, 모니터링 필요</td></tr><tr><td>MVCC + 제한적 락 (Hybrid Locking)</td><td style=text-align:right>읽기 MVCC, 쓰기 핵심 경로에 행락 적용</td><td>쓰기 충돌 제어 + 읽기 성능 유지</td><td>실무에서 범용성 높음</td><td>설계·운영 복잡성 증가</td></tr><tr><td>낙관적 검증 + Conflict Table</td><td style=text-align:right>낙관적 버전 검사 + 명시적 충돌 테이블</td><td>write-skew 같은 보이지 않는 제약 차단</td><td>애플리케이션 레벨으로 정합성 확보</td><td>앱 수정 필요, 설계 복잡</td></tr><tr><td>Skip-Locked / Nowait + Requeue</td><td style=text-align:right>SKIP LOCKED 처리 + 작업 재분배</td><td>지연 감소, 처리량 향상</td><td>지연 민감 워크로드에 유리</td><td>처리 공정성/누락 리스크 관리</td></tr><tr><td>Lock granularity tuning + Escalation control</td><td style=text-align:right>행단위 기본, 승격 임계값 조정</td><td>메모리/동시성 균형</td><td>운영 유연성 확보</td><td>적절 임계값 산정 필요</td></tr></tbody></table><p>하이브리드 기법은 MVCC 와 락의 강점만 골라 쓰는 방식이다. 공통적으로 **정책 설계·모니터링·실험 (벤치마크)**이 필수이며, 잘 설계하면 성능과 정합성 모두에서 상당한 이득을 얻을 수 있다.</p><h4 id=락-적용-판단과-운영원칙>락 적용 판단과 운영원칙<a hidden class=anchor aria-hidden=true href=#락-적용-판단과-운영원칙>#</a></h4><p>락 (Locking) 은 동시에 많은 사용자가 같은 데이터를 수정할 때 **정확성 (무결성)**을 보장하는 도구다. 계좌 이체, 재고 감소, 예약 중복 방지처럼 <strong>정확성이 최우선</strong>인 시스템에서는 락 기반 제어가 필요하다. 반대로 소셜 피드, 로그 수집, 시계열 대량 삽입처럼 <code>최종 일관성</code> 을 허용하고 읽기·쓰기가 매우 많은 환경에서는 락이 병목이 되므로 MVCC, 낙관적 락, 파티셔닝 같은 대안을 검토해야 한다. 분산 환경에선 추가로 <strong>리더 선출·리스·펜싱 토큰</strong> 같은 보완책을 도입해야 안전하다.</p><h5 id=락-적용-적합성-분석>락 적용 적합성 분석<a hidden class=anchor aria-hidden=true href=#락-적용-적합성-분석>#</a></h5><h6 id=설계-관점>설계 관점<a hidden class=anchor aria-hidden=true href=#설계-관점>#</a></h6><ul><li><strong>언제 락을 선택할지</strong>: 트랜잭션이 <em>원자적으로</em> 자원 (잔액, 재고 등) 을 변경해야 하고, 중복/충돌 허용 불가면 락.</li><li><strong>대신 고려할 것</strong>: 핫스팟 분산 (샤드 키 재설계), 큐잉 (리더 - 워커), 낙관적 락 (버전 체크) 으로 병렬성 보전.</li><li><strong>권장 패턴</strong>: 짧은 트랜잭션, 작은 락 범위 (행 단위), 인덱스 최적화로 스캔 축소.</li></ul><h6 id=분석-성능비용-관점>분석 (성능·비용) 관점<a hidden class=anchor aria-hidden=true href=#분석-성능비용-관점>#</a></h6><ul><li><strong>비용</strong>: 락은 동시성 감소 → 처리량·레이턴시 영향. 분산 락은 네트워크 비용·복잡성 증가.</li><li><strong>검증 항목</strong>: 예상 QPS 대비 평균 락 대기시간, deadlock 빈도, 트랜잭션 길이 분포, 핫스팟 존재 여부.</li><li><strong>지표 기반 의사결정</strong>: 허용 가능한 대기시간·SLA 와 비교해 락 사용 여부 판단.</li></ul><h6 id=운영-관점>운영 관점<a hidden class=anchor aria-hidden=true href=#운영-관점>#</a></h6><ul><li><strong>필수 모니터링</strong>: lock wait time, active locks, deadlock rate, SKIP_LOCKED 성공률, 긴 트랜잭션 목록.</li><li><strong>운영 규칙</strong>: 타임아웃·재시도 정책, deadlock 대응 Runbook(자동 로그·경고·강제 롤백), 정기 용량·성능 검증.</li><li><strong>분산 운영</strong>: 리더 선출·펜싱·리스 만료 정책, 네트워크 분할 시 행동 (leader stepdown 등) 문서화.</li></ul><h5 id=락-적용-적합성-표>락 적용 적합성 표<a hidden class=anchor aria-hidden=true href=#락-적용-적합성-표>#</a></h5><table><thead><tr><th>시나리오</th><th style=text-align:right>적합성</th><th>이유</th><th>설계 권장</th><th>운영 권장</th></tr></thead><tbody><tr><td>금융 시스템 (계좌 등)</td><td style=text-align:right>매우 적합</td><td>즉시 일관성·무결성 필수</td><td>Strict 2PL / SSI, 작은 트랜잭션 범위</td><td>엄격 모니터링·deadlock 로그·재시도 정책</td></tr><tr><td>재고/주문관리</td><td style=text-align:right>적합</td><td>재고 오버셀 방지 필요</td><td>행단위 락, 파티셔닝, 큐잉</td><td>SKIP_LOCKED, tx 짧게 유지</td></tr><tr><td>예약 (좌석/룸)</td><td style=text-align:right>적합</td><td>중복 예약 방지 필요</td><td>선점형 락 또는 리더 큐 패턴</td><td>펜싱 토큰·타임아웃 설정</td></tr><tr><td>ERP 마스터데이터</td><td style=text-align:right>적합</td><td>정확성 중요</td><td>트랜잭션 설계 엄격화</td><td>변경 시점 롤링·감사 로깅</td></tr><tr><td>게임 (핵심 자산)</td><td style=text-align:right>조건부</td><td>실시간성 vs 정합성 트레이드오프</td><td>낙관적 락 + 서버 권한자 (리더)</td><td>짧은 tx·충돌재시도</td></tr><tr><td>소셜 미디어</td><td style=text-align:right>비적합</td><td>읽기 우선, 최종 일관성 허용</td><td>MVCC/캐시 중심 설계</td><td>비동기 업데이트, 이벤트 소싱</td></tr><tr><td>로그/분석 (대량 쓰기)</td><td style=text-align:right>비적합</td><td>쓰기 집약 → 락 부적합</td><td>append-only, bulk ingest 파이프라인</td><td>파티셔닝·백프레셔 설계</td></tr><tr><td>IoT 시계열</td><td style=text-align:right>비적합</td><td>대량 삽입, 낮은 정합성 요구</td><td>시계열 DB 최적화, 샤딩</td><td>배치 처리를 통한 처리량 확보</td></tr></tbody></table><p>핵심은 <strong>정합성 우선이면 락, 처리량·확장성 우선이면 대안</strong>이다. 설계 단계에서 워크로드 (읽기: 쓰기 비율, 핫스팟 여부, SLA) 를 프로파일링하여 락 채택 여부를 결정하고, 락을 택하면 <strong>짧은 트랜잭션·작은 락 범위·모니터링·재시도 정책</strong>을 반드시 도입해야 한다.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=락-구현의-계층별-기법과-운영-전략>락 구현의 계층별 기법과 운영 전략<a hidden class=anchor aria-hidden=true href=#락-구현의-계층별-기법과-운영-전략>#</a></h4><p>락 구현 기법은 크게 &rsquo; 어떤 수준에서 (스레드/프로세스/시스템)&rsquo;, &rsquo; 어떤 방식으로 (폴링·블록·원자연산)&rsquo;, &rsquo; 어디에 적용하는가 (로컬 데이터구조·DB 트랜잭션·분산 시스템)&rsquo; 로 나뉜다. 짧게 말하면: 짧은 임계영역엔 스핀락, 긴 작업엔 뮤텍스, 여러 읽기엔 리더 - 라이터, 충돌이 드물면 낙관적 검증, 여러 노드가 관여하면 분산 락 (lease/consensus) 과 fencing 을 쓴다. 설계자는 워크로드 특성과 운영 제약 (지연·CPU·네트워크) 을 보고 적절히 조합해야 한다.</p><h5 id=락-구현-기법-요약표>락 구현 기법 요약표<a hidden class=anchor aria-hidden=true href=#락-구현-기법-요약표>#</a></h5><table><thead><tr><th>기법</th><th style=text-align:right>정의</th><th>특징</th><th>목적</th><th>사용 예시</th></tr></thead><tbody><tr><td>스핀락</td><td style=text-align:right>폴링으로 대기</td><td>짧은 임계영역에 우수, CPU 사용↑</td><td>빠른 락 획득</td><td>인메모리 데이터구조</td></tr><tr><td>뮤텍스</td><td style=text-align:right>블로킹 락</td><td>긴 대기 효율적, 문맥전환</td><td>장기 임계영역</td><td>OS/DB 메타데이터</td></tr><tr><td>세마포어</td><td style=text-align:right>카운팅 락</td><td>동시 N 개 허용</td><td>리소스 풀 제어</td><td>커넥션 풀</td></tr><tr><td>리더 - 라이터</td><td style=text-align:right>읽기/쓰기 구분</td><td>읽기 동시성 ↑</td><td>조회 중심 워크로드</td><td>캐시/통계</td></tr><tr><td>적응형 락</td><td style=text-align:right>스핀/블록 동적전환</td><td>런타임 최적 선택</td><td>혼합 워크로드</td><td>InnoDB adaptive</td></tr><tr><td>락 - 프리</td><td style=text-align:right>CAS 등 원자연산</td><td>저지연·높은 처리량</td><td>초저지연 요구</td><td>lock-free 큐</td></tr><tr><td>낙관적 검증</td><td style=text-align:right>커밋시 충돌검증</td><td>충돌 적을 때 유리</td><td>읽기중심 트랜잭션</td><td>Version 컬럼</td></tr><tr><td>비관적 (2PL)</td><td style=text-align:right>선획득 락</td><td>충돌 예방, 데드락 가능</td><td>충돌 빈도 높음</td><td>SELECT FOR UPDATE</td></tr><tr><td>갭/넥스트키</td><td style=text-align:right>범위 락</td><td>팬텀 방지</td><td>범위 쿼리 정합성</td><td>InnoDB gap lock</td></tr><tr><td>어드바이저리/Named</td><td style=text-align:right>문자열 키 락</td><td>앱단 동기화 가능</td><td>업무 임계영역</td><td>GET_LOCK, pg_advisory_lock</td></tr><tr><td>분산 락</td><td style=text-align:right>lease/consensus/fencing</td><td>네트워크 고려 필수</td><td>글로벌 조정·리더 선출</td><td>ZooKeeper, etcd, Redis</td></tr></tbody></table><h5 id=락-구현의-계층별-분류>락 구현의 계층별 분류<a hidden class=anchor aria-hidden=true href=#락-구현의-계층별-분류>#</a></h5><h6 id=저수준-동기화-primitives-spinmutexsemaphorecas>저수준 동기화 Primitives (Spin/Mutex/Semaphore/CAS)<a hidden class=anchor aria-hidden=true href=#저수준-동기화-primitives-spinmutexsemaphorecas>#</a></h6><p>저수준 동기화 계층은 CPU·메모리 차원의 원자성과 스케줄링 특성을 이용해 동시성 제어를 수행한다. 스핀락은 짧은 임계영역에 최적, 뮤텍스는 긴 대기 효율적, 세마포어는 자원 풀 제어에 적합하고 CAS 는 락 - 프리 구조의 기반이 된다. 설계 시 캐시 라인 경합, 문맥교환 비용, ABA 문제 등을 고려해야 한다.</p><table><thead><tr><th>기법</th><th style=text-align:right>핵심</th><th>장점</th><th>주의점</th></tr></thead><tbody><tr><td>Spinlock</td><td style=text-align:right>폴링 대기</td><td>낮은 지연</td><td>CPU 소모</td></tr><tr><td>Mutex</td><td style=text-align:right>블로킹</td><td>긴 대기 효율</td><td>문맥전환 오버헤드</td></tr><tr><td>Semaphore</td><td style=text-align:right>카운팅</td><td>제한된 리소스 제어</td><td>복잡한 상태관리</td></tr><tr><td>CAS (원자)</td><td style=text-align:right>비교교체</td><td>락 - 프리 구현 가능</td><td>ABA·메모리 재 clamation</td></tr></tbody></table><ul><li>요약: 저수준 primitives 는 시스템 내부 성능 최적화의 기본 단위다. 짧은 임계영역이면 spin, 긴 작업이면 mutex, 리소스 풀엔 semaphore, 초고성능엔 CAS 기반 락 - 프리를 고려하자.</li></ul><h6 id=프로세스스레드-수준-고급-락-reader-writer--adaptive--lock-free>프로세스/스레드 수준 고급 락 (Reader-Writer / Adaptive / Lock-Free)<a hidden class=anchor aria-hidden=true href=#프로세스스레드-수준-고급-락-reader-writer--adaptive--lock-free>#</a></h6><p>이 계층은 애플리케이션·라이브러리 단위에서 동작하며 워크로드 특성에 따라 동작을 바꾼다. Reader-writer 는 읽기 동시성을 극대화하고, adaptive 는 런타임 경합에 따라 전략 전환, lock-free 는 최저지연을 목표로 한다. 운영 시에는 기아·우선순위 역전 등도 체크해야 한다.</p><table><thead><tr><th>기법</th><th style=text-align:right>목적</th><th>장점</th><th>제약</th></tr></thead><tbody><tr><td>Reader-Writer</td><td style=text-align:right>읽기 동시성</td><td>조회 성능↑</td><td>쓰기 기아 가능</td></tr><tr><td>Adaptive Lock</td><td style=text-align:right>런타임 최적화</td><td>워크로드 적응</td><td>복잡도 증가</td></tr><tr><td>Lock-Free</td><td style=text-align:right>초저지연</td><td>고성능</td><td>구현·디버깅 난이도</td></tr></tbody></table><ul><li>요약: 애플리케이션 레벨 동기화는 워크로드 특성 (읽기 대 쓰기 비율) 에 맞춰 선택해야 하며, adaptive 와 lock-free 는 성능 이득이 크지만 구현·운영 복잡성이 증가한다.</li></ul><h6 id=dbms트랜잭션-수준-기법-pessimistic--optimistic--gap--escalation>DBMS/트랜잭션 수준 기법 (Pessimistic / Optimistic / Gap / Escalation)<a hidden class=anchor aria-hidden=true href=#dbms트랜잭션-수준-기법-pessimistic--optimistic--gap--escalation>#</a></h6><p>DBMS 수준 기법은 데이터 정합성과 트랜잭션 의미를 보장하기 위한 고수준 전략이다. 비관적 (2PL) 은 무결성 우선, 낙관적은 충돌이 드물 때 유리, gap/next-key 는 팬텀 방지, 에스컬레이션은 관리 오버헤드 제어용이다.</p><table><thead><tr><th>기법</th><th style=text-align:right>목적</th><th>장점</th><th>운영 고려</th></tr></thead><tbody><tr><td>Pessimistic (2PL)</td><td style=text-align:right>충돌 예방</td><td>강한 정합성</td><td>데드락 가능</td></tr><tr><td>Optimistic</td><td style=text-align:right>락 최소화</td><td>읽기 중심에 유리</td><td>롤백 비용</td></tr><tr><td>Gap / Next-key</td><td style=text-align:right>팬텀 방지</td><td>범위 정합성</td><td>범위 락 경합</td></tr><tr><td>Lock Escalation</td><td style=text-align:right>락 테이블 관리</td><td>관리 오버헤드 감소</td><td>병렬성 감소</td></tr></tbody></table><ul><li>요약: 트랜잭션 수준 선택은 무결성 요구·충돌 확률·성능 목표의 균형으로 결정된다. 운영적으로는 데드락 모니터링·에스컬레이션 임계값 튜닝이 필수다.</li></ul><h6 id=분산글로벌-조정-기법-lease--consensus--fencing--named>분산·글로벌 조정 기법 (Lease / Consensus / Fencing / Named)<a hidden class=anchor aria-hidden=true href=#분산글로벌-조정-기법-lease--consensus--fencing--named>#</a></h6><p>분산 환경에서는 네트워크·노드 실패를 고려한 설계가 필요하다. Lease(토큰 만료) 는 응답성이 좋지만 만료 정책 필요, consensus 기반은 안정적이지만 지연·오버헤드가 크다. fencing token 은 stale client 가 쓰기 못하게 막는다.</p><table><thead><tr><th>기법</th><th style=text-align:right>핵심</th><th>장점</th><th>리스크</th></tr></thead><tbody><tr><td>Lease</td><td style=text-align:right>TTL 기반 소유권</td><td>빠른 반응성</td><td>만료·클록 문제</td></tr><tr><td>Consensus (Raft/Paxos)</td><td style=text-align:right>합의로 락 관리</td><td>강한 일관성</td><td>지연·복잡도</td></tr><tr><td>Fencing</td><td style=text-align:right>토큰으로 안전성 확보</td><td>stale client 차단</td><td>구현 복잡</td></tr><tr><td>Named/Advisory</td><td style=text-align:right>앱단 락</td><td>융통성</td><td>사용자 책임 증가</td></tr></tbody></table><ul><li>요약: 분산 락은 단일 노드보다 설계·운영 부담이 크다. 응답성·일관성 요구에 따라 lease 또는 consensus 를 선택하고, fencing 은 failover 안전성을 높이는 핵심 기법이다.</li></ul><h5 id=락-기법-계층별-요약표>락 기법 계층별 요약표<a hidden class=anchor aria-hidden=true href=#락-기법-계층별-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>대표 기법</th><th>주된 용도</th><th>선택 기준 (권장)</th></tr></thead><tbody><tr><td>저수준 primitives</td><td style=text-align:right>Spin, Mutex, Semaphore, CAS</td><td>임계영역 보호, 리소스 제어</td><td>임계영역 길이·CPU 사용 가능성</td></tr><tr><td>프로세스 수준</td><td style=text-align:right>Reader-Writer, Adaptive, Lock-Free</td><td>라이브러리/앱 동기화</td><td>읽기대비·레이턴시 목표</td></tr><tr><td>DBMS 수준</td><td style=text-align:right>Pessimistic, Optimistic, Gap, Escalation</td><td>트랜잭션 정합성·무결성</td><td>충돌 빈도·무결성 요구</td></tr><tr><td>분산 수준</td><td style=text-align:right>Lease, Consensus, Fencing, Named</td><td>전역 조정·리더 선출</td><td>노드 수·네트워크 특성·SLA</td></tr></tbody></table><h4 id=락-유형범위운영-분류와-실무지침>락 유형·범위·운영 분류와 실무지침<a hidden class=anchor aria-hidden=true href=#락-유형범위운영-분류와-실무지침>#</a></h4><p>락은 " 누가 언제 무엇을 할 수 있는가 " 를 규정하는 규칙 세트다.</p><ul><li>**모드 (S/X 등)**는 읽기/쓰기에 대한 권한을 정하고, **범위 (Row/Page/Table)**는 그 권한의 범위를 정한다.</li><li><strong>수명</strong>은 락이 얼마나 오래 유지되는지를 정해서 일관성 (길게 유지) 과 성능 (짧게 유지) 의 균형을 맞춘다.</li><li><strong>패턴</strong>(NOWAIT 등) 은 락 요청자가 기다릴지 실패할지를 정해 애플리케이션 동작을 단순화하거나 반응성을 높인다.</li><li><strong>분산 락</strong>은 여러 시스템이 협업할 때의 안전장치 (lease, fencing, consensus) 로, 네트워크·프로세스 실패에 대비해야 한다.</li></ul><p>실무에서는 각 축을 조합해 " 어떤 워크로드에 어떤 락 정책이 적합한지 " 를 설계하는 것이 관건이다.</p><h5 id=락-유형별-목적효과-매핑표>락 유형별 목적·효과 매핑표<a hidden class=anchor aria-hidden=true href=#락-유형별-목적효과-매핑표>#</a></h5><table><thead><tr><th>분류 축</th><th>해결하는 문제</th><th style=text-align:right>방식 (메커니즘)</th><th>기대 효과</th></tr></thead><tbody><tr><td>모드 (S/X/IS/IX/SIX/U)</td><td>동시 읽기/쓰기 충돌 제어</td><td style=text-align:right>공유/배타/의도 락으로 접근권한 제어</td><td>데이터 무결성 확보, 충돌 회피</td></tr><tr><td>범위 (Row/Page/Table/Predicate/Gap)</td><td>범위 기반 이상 (팬텀 등)</td><td style=text-align:right>범위 락·프레디케이트 락으로 범위 보호</td><td>팬텀·범위 무결성 보장</td></tr><tr><td>수명 (Statement/Transaction/Session)</td><td>일관성 유지 vs 락 장기 보유 문제</td><td style=text-align:right>락 해제 시점 제어 (즉시/커밋/세션종료)</td><td>재현성 보장·대기 최소화 균형</td></tr><tr><td>패턴 (FOR UPDATE/NOWAIT/SKIP)</td><td>대기·선택적 실패 정책</td><td style=text-align:right>대기 - 블로킹/즉시 실패/스킵 전략</td><td>지연 제어, 작업큐 효율화</td></tr><tr><td>분산 (Lease/Fencing/Advisory)</td><td>분산 환경의 소유권 안전</td><td style=text-align:right>lease(타임아웃), fencing token, consensus</td><td>스플릿브레인 방지, 단일 실행 보장</td></tr><tr><td>에스컬레이션</td><td>대량 락으로 인한 오버헤드</td><td style=text-align:right>자동 레벨 업 (ROW→PAGE→TABLE)</td><td>락 관리 비용 절감 vs 동시성 감소</td></tr></tbody></table><h5 id=락-유형-분류-모드범위운영-축>락 유형 분류: 모드·범위·운영 축<a hidden class=anchor aria-hidden=true href=#락-유형-분류-모드범위운영-축>#</a></h5><h6 id=접근-모드-mode>접근 모드 (Mode)<a hidden class=anchor aria-hidden=true href=#접근-모드-mode>#</a></h6><p><strong>내용</strong></p><ul><li><strong>정의</strong>: 자원에 대한 접근 권한의 종류. 대표적으로 공유락 (S) 과 배타락 (X) 이 있으며, 의도락 (IS/IX), 공유 + 의도 (SIX), 업데이트락 (U) 등이 있다.</li><li><strong>역할/기능</strong>: 동시 읽기는 허용하되 쓰기는 배타적으로 하는 등의 정책을 통해 데이터 무결성을 보장. 의도락은 상위 수준에서 하위 레벨 락 획득 의도를 미리 알려 데드락·충돌을 줄인다.</li><li><strong>특징 (근거)</strong>: 모드 간 <strong>호환성 매트릭스</strong>(어떤 모드가 동시에 허용되는지) 가 락 매니저의 핵심; 의도락은 테이블 - 레코드 혼합 락에서 필수적이다.</li><li><strong>운영 유의</strong>: 잘못된 모드 사용은 과도한 블로킹을 유발하므로 S/X 선택 타이밍과 의도락 사용을 설계 단계에서 결정해야 한다.</li></ul><table><thead><tr><th>모드</th><th>설명</th><th>동시 허용 예</th></tr></thead><tbody><tr><td>S (Shared)</td><td>읽기 전용</td><td>다른 S 허용, X 불허</td></tr><tr><td>X (Exclusive)</td><td>읽기/쓰기 독점</td><td>모든 락과 불허</td></tr><tr><td>IS (Intent S)</td><td>하위 레벨 읽기 의도</td><td>IS/IX/S 와 호환</td></tr><tr><td>IX (Intent X)</td><td>하위 레벨 쓰기 의도</td><td>IS/IX 만 호환</td></tr><tr><td>SIX</td><td>테이블 수준 S + 일부 X 의도</td><td>특정 조합만 허용</td></tr><tr><td>U (Update)</td><td>잠재적 X 로 승격 가능</td><td>데드락 완화용</td></tr></tbody></table><ul><li>핵심: <strong>모드는 권한 모델</strong>이며, 의도락은 멀티레벨 락에서 효율적 충돌 관리를 가능하게 한다.</li></ul><h6 id=범위-granularity>범위 (Granularity)<a hidden class=anchor aria-hidden=true href=#범위-granularity>#</a></h6><p><strong>내용</strong></p><ul><li><strong>정의</strong>: 락이 걸리는 단위 (레코드, 페이지, 테이블, DB, Predicate 등).</li><li><strong>역할/기능</strong>: 작은 단위는 동시성을 높이고, 큰 단위는 오버헤드 감소 및 단순 관리를 제공. Predicate/Gap 락은 범위 삽입 (팬텀) 을 막는다.</li><li><strong>특징 (근거)</strong>: 페이지·테이블 락은 에스컬레이션 (행→페이지→테이블) 으로 자동 전환될 수 있어 운영상 예측 필요. 인덱스 구조가 범위 락 비용에 직접 영향.</li></ul><table><thead><tr><th>범위</th><th>설명</th><th>장단점</th></tr></thead><tbody><tr><td>Row</td><td>개별 레코드 락</td><td>최고 동시성 / 오버헤드 높음</td></tr><tr><td>Page</td><td>디스크 페이지 단위</td><td>균형/범위 쿼리 효율</td></tr><tr><td>Table</td><td>전체 테이블</td><td>낮은 오버헤드 / 동시성 저하</td></tr><tr><td>Predicate/Gap</td><td>인덱스 범위 보호</td><td>팬텀 방지</td></tr></tbody></table><ul><li>핵심: <strong>범위 선택은 동시성 vs 오버헤드 트레이드오프</strong>이며, 인덱스·쿼리 패턴을 고려해 설계해야 한다.</li></ul><h6 id=지속-시간-lifetime>지속 시간 (Lifetime)<a hidden class=anchor aria-hidden=true href=#지속-시간-lifetime>#</a></h6><p><strong>내용</strong></p><ul><li><strong>정의</strong>: 락이 유지되는 기간. Statement(단일 쿼리), Transaction(트랜잭션 전체), Session(세션 종료 시까지), Manual(명시 해제) 등이 있다.</li><li><strong>역할/기능</strong>: 수명이 길수록 재현성·직렬성 보장에 유리하지만 대기·bottleneck 유발. Strict 2PL 은 커밋 시까지 락 보유하여 복구 단순화.</li><li><strong>특징 (근거)</strong>: 장수 트랜잭션은 컨텐션과 데드락을 악화시키므로 트랜잭션 분해·비동기화 권장.</li></ul><table><thead><tr><th>수명</th><th>설명</th><th>해제 시점</th><th>권장 사용</th></tr></thead><tbody><tr><td>Statement</td><td>쿼리 완료 즉시</td><td>즉시</td><td>짧은 연산</td></tr><tr><td>Transaction</td><td>Tx 종료 시</td><td>커밋/롤백</td><td>일관성 필요 시</td></tr><tr><td>Session</td><td>세션 종료 시</td><td>세션 종료</td><td>장기 락 필요 시</td></tr><tr><td>Manual</td><td>명시적 해제</td><td>어플리케이션 제어</td><td>특수 목적</td></tr></tbody></table><ul><li>핵심: <strong>짧게 유지할수록 시스템은 반응성이 좋음</strong>, 장수 락은 필요한 경우에만 사용.</li></ul><h6 id=대기행동-패턴-policies>대기·행동 패턴 (Policies)<a hidden class=anchor aria-hidden=true href=#대기행동-패턴-policies>#</a></h6><p><strong>내용</strong></p><ul><li><strong>정의</strong>: 락 요청 시 발생하는 행동 규칙—블로킹 (대기), NOWAIT(즉시 실패), SKIP LOCKED(잠긴 항목 건너뛰기), FOR UPDATE(명시적 락 요청) 등.</li><li><strong>역할/기능</strong>: 애플리케이션의 반응성·재시도 전략을 단순화하거나 작업 큐 패턴에 적합하도록 설계.</li><li><strong>특징 (근거)</strong>: SKIP LOCKED 는 작업 큐 소비자 간 경쟁에서 유용하지만 일부 작업이 영원히 처리되지 않을 수 있음 (모니터링 필요). NOWAIT 은 실패를 빠르게 인지시켜 사용자에게 피드백 제공.</li></ul><table><thead><tr><th>패턴</th><th>설명</th><th>사용 예</th></tr></thead><tbody><tr><td>FOR UPDATE</td><td>행 잠금 후 처리</td><td>트랜잭션 내 행 수정</td></tr><tr><td>NOWAIT</td><td>잠기면 즉시 실패</td><td>응답성 우선 작업</td></tr><tr><td>SKIP LOCKED</td><td>잠긴 행 건너뜀</td><td>작업 큐 소비자</td></tr></tbody></table><ul><li>핵심: <strong>대기 정책은 애플리케이션 요구 (반응성 vs 보장성) 에 맞춰 선택</strong>해야 한다.</li></ul><h6 id=분산운영-distributed--ops>분산·운영 (Distributed & Ops)<a hidden class=anchor aria-hidden=true href=#분산운영-distributed--ops>#</a></h6><p><strong>내용</strong></p><ul><li><strong>정의</strong>: 여러 노드/프로세스가 동일 자원에 접근할 때 사용하는 패턴—Lease(타임아웃), Fencing(token), Advisory(네임드 락), Consensus 기반 락 (etcd/zookeeper) 등.</li><li><strong>역할/기능</strong>: 네트워크 분리·클라이언트 죽음 같은 장애 모델에서 &rsquo; 진짜 락 소유자 &rsquo; 를 보장해 스플릿브레인·중복 실행을 방지.</li><li><strong>특징 (근거)</strong>: 단일 노드 솔루션 (예: Redis SETNX) 은 저지연이지만 프로세스 실패 시 안전하지 않을 수 있다. etcd/ZK 같은 consensus 기반은 안전성은 높지만 레이턴시·운영 복잡성이 증가한다. Fencing token 은 락 해제 시 최근 소유자가 작업을 수행할 수 없도록 방지하는 기법이다.</li><li><strong>운영 유의</strong>: lease TTL, heartbeat, 모니터링 (lease 만료 빈도) 과 fencing 구현이 필수다.</li></ul><table><thead><tr><th>타입</th><th>설명</th><th>장단점</th><th>권장 상황</th></tr></thead><tbody><tr><td>Lease</td><td>타임아웃 기반 소유권</td><td>간단·저지연 / clock skew 위험</td><td>단일 리더가 빠르게 선출되어야 할 때</td></tr><tr><td>Fencing</td><td>토큰으로 실행 권한 보장</td><td>안전성↑ / 구현 복잡</td><td>외부 시스템과 연동시 필수</td></tr><tr><td>Advisory</td><td>명명된 락 (앱레벨)</td><td>유연함 / 협약 필요</td><td>비동기 잡 조정</td></tr><tr><td>Consensus (etcd/ZK)</td><td>Raft/Zab 기반</td><td>강한 안전성 / 레이턴시</td><td>미션 크리티컬 분산 락</td></tr></tbody></table><ul><li>핵심: <strong>분산 락은 실패 모델을 설계에서 먼저 정의</strong>해야 하며, 안전성 요구에 따라 lease·fencing·consensus 중 적절한 조합을 선택해야 한다.</li></ul><h5 id=락-분류-종합-요약표>락 분류 종합 요약표<a hidden class=anchor aria-hidden=true href=#락-분류-종합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 요소</th><th style=text-align:right>해결 문제 (주요)</th><th>선택 기준 (실무)</th></tr></thead><tbody><tr><td>접근 모드</td><td>S/X/IS/IX/SIX/U</td><td style=text-align:right>읽기/쓰기 충돌 제어</td><td>동시성 수준, 데드락 감수성</td></tr><tr><td>범위</td><td>Row/Page/Table/Predicate</td><td style=text-align:right>팬텀·범위 무결성, 오버헤드</td><td>쿼리 패턴·인덱스 구조</td></tr><tr><td>수명</td><td>Statement/Transaction/Session</td><td style=text-align:right>일관성 vs 락 장기 보유</td><td>트랜잭션 길이·복구 복잡도</td></tr><tr><td>패턴</td><td>FOR UPDATE/NOWAIT/SKIP</td><td style=text-align:right>대기 정책·작업 큐 효율</td><td>응답성 요구·재시도 전략</td></tr><tr><td>분산/운영</td><td>Lease/Fencing/Consensus</td><td style=text-align:right>분산 안전, 리더 보장</td><td>장애 모델·운영 역량</td></tr></tbody></table><h4 id=락-도구-생태계-기능별-비교와-선택지>락 도구 생태계: 기능별 비교와 선택지<a hidden class=anchor aria-hidden=true href=#락-도구-생태계-기능별-비교와-선택지>#</a></h4><p>락 생태계는 크게</p><ol><li>DBMS 내장 락</li><li>분산 코디네이션 서비스</li><li>인메모리 분산 락</li><li>애플리케이션 프레임워크 기능</li><li>모니터링 도구<br>로 나뉜다.<br>선택 기준은 <strong>일관성 요구 강도</strong>, <strong>분산 여부</strong>, <strong>성능 목표 (지연/처리량)</strong>, <strong>운영 여건 (운영 복잡성 수용 여부)</strong> 이다.<br>실무에서는 이들을 혼합해 사용하며, 각 도구의 장애 모델과 보장 (강한 일관성 vs 가용성) 을 정확히 이해하는 것이 핵심이다.</li></ol><h5 id=락-도구-기능별-카테고리>락 도구 기능별 카테고리<a hidden class=anchor aria-hidden=true href=#락-도구-기능별-카테고리>#</a></h5><h6 id=트랜잭션-무결성-제공---rdbms-내장-락>트랜잭션 무결성 제공 - RDBMS 내장 락<a hidden class=anchor aria-hidden=true href=#트랜잭션-무결성-제공---rdbms-내장-락>#</a></h6><p>RDBMS 는 트랜잭션 경계에서 직접 락을 관리해 ACID 를 보장한다. 행/페이지/테이블 단위로 락을 제공하고, 의도락·락 에스컬레이션·데드락 탐지·해당 DB 특화 기능을 포함한다.</p><p><strong>정확한 기능·역할·용도</strong></p><ul><li>행/페이지/테이블 잠금 획득·해제</li><li>의도 락 (intent locks) 로 다중 Granularity 지원</li><li>자동 에스컬레이션 (행→테이블) 로 메모리 보호</li><li>데드락 탐지·로그 제공</li></ul><p><strong>강점</strong></p><ul><li>강한 일관성 (직렬화 보장), 표준화, 낮은 레이턴시</li></ul><p><strong>약점</strong></p><ul><li>단일 노드 컨텐션, 스케일 아웃 한계, 복잡한 튜닝 필요</li></ul><table><thead><tr><th>제품 유형</th><th style=text-align:right>예시 제품</th><th>주된 용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>RDBMS 내장 락</td><td style=text-align:right>Oracle, Postgres, MySQL(InnoDB), MSSQL</td><td>데이터 무결성 보장 (트랜잭션)</td><td>직렬성 보장·표준화</td><td>분산 확장 한계, 데드락</td></tr></tbody></table><ul><li>요약: 미션 크리티컬한 정합성 요구 시 우선 선택지.</li></ul><h6 id=분산-소유권리더선출---zookeeperetcdconsul>분산 소유권·리더선출 - ZooKeeper/etcd/Consul<a hidden class=anchor aria-hidden=true href=#분산-소유권리더선출---zookeeperetcdconsul>#</a></h6><p>분산 코디네이션 시스템은 클러스터 전반의 상태를 일관되게 유지하며, 분산 락·리더 선출·구성 정보 저장에 적합하다.</p><p><strong>정확한 기능·역할·용도</strong></p><ul><li>Ephemeral nodes / sessions 기반 락</li><li>Consensus (ZAB/Raft) 기반 일관성 보장</li><li>Leader election, configuration storage</li></ul><p><strong>강점</strong></p><ul><li>분산 환경에서의 강한 일관성·장애 감지</li></ul><p><strong>약점</strong></p><ul><li>운영 복잡성, 네트워크 지연에 민감</li></ul><table><thead><tr><th>도구</th><th style=text-align:right>알고리즘 기반</th><th>주된 용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>ZooKeeper</td><td style=text-align:right>ZAB</td><td>분산 락·리더선출</td><td>안정적 일관성</td><td>운영·설정 복잡</td></tr><tr><td>etcd</td><td style=text-align:right>Raft</td><td>분산 구성·락</td><td>Raft 안정성</td><td>클러스터 유지 비용</td></tr></tbody></table><ul><li>요약: 분산 서비스의 &rsquo; 중앙 조정자 &rsquo; 역할을 담당.</li></ul><h6 id=고성능-경량-분산-락---redisredlock-hazelcast>고성능 경량 분산 락 - Redis/Redlock, Hazelcast<a hidden class=anchor aria-hidden=true href=#고성능-경량-분산-락---redisredlock-hazelcast>#</a></h6><p>빠른 응답성이 필요한 시나리오에서 Redis 기반 TTL 락이나 Hazelcast 분산 자료구조 락을 사용한다.</p><p><strong>정확한 기능·역할·용도</strong></p><ul><li>TTL 기반 락 (lease), 간단한 상호배제</li><li>분산 캐시와 결합한 동기화</li></ul><p><strong>강점</strong></p><ul><li>낮은 레이턴시, 쉬운 도입</li></ul><p><strong>약점</strong></p><ul><li>강한 안전성 보장 약함 (펜싱 필요), Redlock 안전성 가정 주의</li></ul><table><thead><tr><th>도구</th><th style=text-align:right>주된 메커니즘</th><th>용도</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Redis (Redlock)</td><td style=text-align:right>TTL 기반 락</td><td>캐시/간단 동기화</td><td>빠름, 간편</td><td>파티션 시 위험성</td></tr><tr><td>Hazelcast</td><td style=text-align:right>분산 자료구조 락</td><td>분산 캐시 락</td><td>풍부한 API</td><td>클러스터 복잡성</td></tr></tbody></table><ul><li>요약: 성능 우선 시 검토하되 실패모드 이해 필수.</li></ul><h6 id=개발자-추상화---orm프레임워크>개발자 추상화 - ORM/프레임워크<a hidden class=anchor aria-hidden=true href=#개발자-추상화---orm프레임워크>#</a></h6><p>JPA 의 @Version, SELECT FOR UPDATE 같은 기능으로 개발자가 락 방식을 선언적으로 제어.</p><p><strong>정확한 기능·역할·용도</strong></p><ul><li>낙관적 락 (버전 필드) 및 비관적 락 (명시적 locked select) 제공</li><li>트랜잭션 경계와 결합된 사용</li></ul><p><strong>강점</strong></p><ul><li>개발 생산성, 표준화된 이용법</li></ul><p><strong>약점</strong></p><ul><li>추상화로 인한 성능·논리적 오류 가능</li></ul><table><thead><tr><th>프레임워크</th><th style=text-align:right>기능</th><th>용도</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>JPA/Hibernate</td><td style=text-align:right>@Version, FOR UPDATE</td><td>애플리케이션 레벨 락</td><td>코드 중심 제어</td><td>오용 시 성능 문제</td></tr></tbody></table><ul><li>요약: 개발자가 락 전략을 쉽고 일관되게 적용하게 해줌.</li></ul><h6 id=운영관측---모니터링진단-도구>운영·관측 - 모니터링·진단 도구<a hidden class=anchor aria-hidden=true href=#운영관측---모니터링진단-도구>#</a></h6><p>DB 내장 뷰, APM, Prometheus exporters 등으로 락 대기·데드락을 관측하고 알람을 설정.</p><p><strong>정확한 기능·역할·용도</strong></p><ul><li>락 wait time, lock count, deadlock trace 수집</li><li>자동화된 알람·대응 (reroute, kill) 연계</li></ul><p><strong>강점</strong></p><ul><li>문제 탐지·해결 속도 향상</li></ul><p><strong>약점</strong></p><ul><li>지표 설계·임계값 튜닝 필요</li></ul><table><thead><tr><th>도구</th><th style=text-align:right>지표 유형</th><th>용도</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>DB 내장 뷰</td><td style=text-align:right>pg_locks, INNODB_LOCKS</td><td>락 상태 관찰</td><td>정확한 내부 상태</td><td>쿼리 비용</td></tr><tr><td>Prometheus+Grafana</td><td style=text-align:right>custom export</td><td>대시보드/알람</td><td>시각화·알람</td><td>지표 설계 필요</td></tr></tbody></table><ul><li>요약: 운영 안정성의 핵심, 잘못된 알람은 오히려 방해.</li></ul><h5 id=락-도구프레임워크-종합-비교표>락 도구·프레임워크 종합 비교표<a hidden class=anchor aria-hidden=true href=#락-도구프레임워크-종합-비교표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 도구</th><th>핵심 기능</th><th>적합 사례</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>RDBMS 내장</td><td>Postgres, Oracle, MySQL</td><td>행/테이블 락, 2PL, 의도락</td><td>금융·트랜잭션 시스템</td><td>강한 일관성, 표준</td><td>분산 확장 한계</td></tr><tr><td>분산 코디네이션</td><td>ZooKeeper, etcd, Consul</td><td>Consensus 기반 락, leader election</td><td>마이크로서비스 동기화</td><td>분산 일관성·장애 감지</td><td>운영 복잡성</td></tr><tr><td>인메모리 락</td><td>Redis (Redlock), Hazelcast</td><td>TTL 락, 분산 자료구조 락</td><td>캐시 동기화, 빠른 상호배제</td><td>낮은 레이턴시, 쉬운 도입</td><td>파티션/안전성 위험</td></tr><tr><td>프레임워크 레벨</td><td>JPA, Hibernate</td><td>@Version, SELECT FOR UPDATE</td><td>앱 레벨 락 정책 적용</td><td>개발 편의성</td><td>추상화의 함정</td></tr><tr><td>운영/모니터링</td><td>pg_locks, INNODB_LOCKS, Prometheus</td><td>락 지표/데드락 추적</td><td>운영·디버깅</td><td>문제 탐지 속도↑</td><td>지표 설계 필요</td></tr></tbody></table><h4 id=락-안티패턴-진단예방해결>락 안티패턴: 진단·예방·해결<a hidden class=anchor aria-hidden=true href=#락-안티패턴-진단예방해결>#</a></h4><p>락 안티패턴은 <strong>락을 잘못 잡거나 오래 잡아서 발생하는 문제들</strong>이다.<br>대표적으로 전체 테이블 락·긴 트랜잭션·외부 호출 중 락 보유는 동시성을 망가뜨린다.<br>분산 락을 Redis 단일 인스턴스로만 구현하면 장애 시 치명적이다.<br>해결은 코드 (try-finally, 트랜잭션 축소), DB(인덱스·쿼리 개선), 인프라 (etcd/ZooKeeper, 펜싱), 운영 (모니터링·알람) 세 축에서 조치하는 것이다.</p><h5 id=락-안티패턴과-실무-대응책>락 안티패턴과 실무 대응책<a hidden class=anchor aria-hidden=true href=#락-안티패턴과-실무-대응책>#</a></h5><h6 id=과도한-락킹-over-locking>과도한 락킹 (Over-Locking)<a hidden class=anchor aria-hidden=true href=#과도한-락킹-over-locking>#</a></h6><ul><li><p>문제: 필요 이상으로 넓은 범위 (테이블) 또는 긴 시간 락 보유</p></li><li><p>결과: 전체 동시성 급감, 응답 지연, 장애 전파</p></li><li><p>원인: 안전을 위해 보수적으로 전체 테이블 락 사용, 트랜잭션 범위 과대설계</p></li><li><p>해결책: 락 범위 최소화 (행 단위), 트랜잭션 분해 (청크), 쿼리/인덱스 개선</p></li><li><p>악례 (예시):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LOCK</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=k>EXCLUSIVE</span><span class=w> </span><span class=k>MODE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 전체 테이블 잠금
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;processed&#39;</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>processed</span><span class=o>=</span><span class=k>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>개선 (해결) 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- chunked update + index 사용
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>orders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;processed&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>processed</span><span class=o>=</span><span class=k>false</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 반복해서 작은 범위로 처리
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h6 id=락-누설-lock-leakage>락 누설 (Lock Leakage)<a hidden class=anchor aria-hidden=true href=#락-누설-lock-leakage>#</a></h6><ul><li><p>문제: 예외/오류 시 락이 해제되지 않아 자원 고갈</p></li><li><p>결과: 점진적 락 축적 → 시스템 교착·성능 저하</p></li><li><p>원인: try/catch 누락, 트랜잭션/세션 관리 미비</p></li><li><p>해결책: try-finally/with 문으로 보장된 해제, 커넥션 풀 정책 (타임아웃)</p></li><li><p>악례 (예시—Java JDBC):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>conn</span><span class=p>.</span><span class=na>setAutoCommit</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 예외 발생하면 commit/rollback 못함 -&gt; 락 잔존</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>개선 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>conn</span><span class=p>.</span><span class=na>setAutoCommit</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 작업</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>conn</span><span class=p>.</span><span class=na>commit</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>conn</span><span class=p>.</span><span class=na>rollback</span><span class=p>();</span><span class=w> </span><span class=c1>// 안전하게 해제</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>conn</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h6 id=락-보유-중-외부-호출-external-calls-while-holding-lock>락 보유 중 외부 호출 (External Calls While Holding Lock)<a hidden class=anchor aria-hidden=true href=#락-보유-중-외부-호출-external-calls-while-holding-lock>#</a></h6><ul><li>문제: DB 락을 유지한 채 외부 HTTP/파일/큐 호출</li><li>결과: 락 보유 시간이 비정상적으로 늘어남 → 대기·데드락 증가</li><li>원인: 단일 트랜잭션 내에서 외부 종속 호출 포함</li><li>해결책: 외부 호출은 락 해제 후 수행, 또는 작업을 비동기화 (워크플로우/사가)</li><li>악례: DB 트랜잭션 내에서 REST 호출</li><li>개선: DB commit → 외부 호출 (또는 publish-event 후 worker 가 처리)</li></ul><h6 id=단일-redis-인스턴스에-의존한-분산-락>단일 Redis 인스턴스에 의존한 분산 락<a hidden class=anchor aria-hidden=true href=#단일-redis-인스턴스에-의존한-분산-락>#</a></h6><ul><li>문제: Redis 단일 노드·비결정적 복제에서 락 안전성 부족</li><li>결과: 장애 시 잠겨버린 락, 중복 수행, 데이터 정합성 위협</li><li>원인: 단일 인스턴스 의존 (availability vs safety trade-off 무시)</li><li>해결책: quorum 기반 Redlock(주의해서 사용) 또는 etcd/ZooKeeper 같은 합의 기반 락 + 펜싱 토큰</li><li>악례: <code>SETNX key</code> 만으로 락 구현 (재발급/만료 로직 부실)</li><li>개선: etcd lease + compare-and-swap 또는 Redis with quorum & lease + token 검증</li></ul><h6 id=인덱스-부적합으로-인한-갭락넥스트키락>인덱스 부적합으로 인한 갭락/넥스트키락<a hidden class=anchor aria-hidden=true href=#인덱스-부적합으로-인한-갭락넥스트키락>#</a></h6><ul><li>문제: 불완전한 인덱스/범위 쿼리로 DB 가 범위 락 적용</li><li>결과: 불필요한 경합 (gap locks), 읽기/쓰기 블로킹 증가</li><li>원인: 쿼리 플랜이 전체 스캔 혹은 범위 스캔 유도</li><li>해결책: 적절한 인덱스 설계, 쿼리 리팩터링, 필요시 페이징/배치 처리</li><li>악례: <code>WHERE name LIKE '%foo'</code> (인덱스 미사용)</li><li>개선: <code>WHERE name LIKE 'foo%'</code> + 적절한 인덱스 또는 full-text 인덱스 사용</li></ul><h6 id=모니터링알람-부재>모니터링·알람 부재<a hidden class=anchor aria-hidden=true href=#모니터링알람-부재>#</a></h6><ul><li>문제: 락 관련 지표 미수집 → 장애 전조를 못 잡음</li><li>결과: 갑작스런 장애·SLA 위반</li><li>원인: 관찰 불충분 (대시보드 부재)</li><li>해결책: <code>lock waits</code>, <code>deadlock count</code>, <code>lock hold time</code> 등 지표 수집·알람화, 자동 회복 플레이북 마련</li><li>악례: 운영 로그만 수동 조회</li><li>개선: Grafana/Prometheus 에 알람 룰 등록, 자동 복구 스크립트 준비</li></ul><h6 id=우선순위-역전--기아-priority-inversion--starvation>우선순위 역전 / 기아 (Priority Inversion / Starvation)<a hidden class=anchor aria-hidden=true href=#우선순위-역전--기아-priority-inversion--starvation>#</a></h6><ul><li>문제: 낮은 우선순위 트랜잭션이 높은 우선순위 작업을 차단</li><li>결과: 중요한 작업 지연·SLA 위반</li><li>원인: 공정성 없는 스케줄링, 우선순위 정책 부재</li><li>해결책: 에이징 (대기 시간 따라 우선순위 상승), 우선순위 상속, 공정 큐 도입</li><li>악례: 긴 보고서 생성 작업이 FIFO 로 인해 운영 트랜잭션 차단</li><li>개선: 중요한 트랜잭션에 우선권 부여하거나 긴 작업은 낮은 우선순위로 백그라운드 처리</li></ul><h5 id=락-안티패턴문제대응-요약>락 안티패턴·문제·대응 요약<a hidden class=anchor aria-hidden=true href=#락-안티패턴문제대응-요약>#</a></h5><table><thead><tr><th>안티패턴</th><th>문제 요약</th><th>원인</th><th style=text-align:right>실무 영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>과도한 락킹</td><td>넓은 범위·장시간 락</td><td>테이블 락 남용, 큰 트랜잭션</td><td style=text-align:right>동시성 저하, 지연</td><td>범위 축소, 청크 처리</td></tr><tr><td>락 누설</td><td>예외 시 미해제</td><td>예외 처리 미비</td><td style=text-align:right>락 누적·교착</td><td>try-finally, 타임아웃</td></tr><tr><td>외부 호출 중 락</td><td>락 보유 시간 폭증</td><td>트랜잭션 내부 외부 I/O</td><td style=text-align:right>데드락·대기 증가</td><td>락 해제 후 외부 호출, 사가</td></tr><tr><td>단일 Redis 락 의존</td><td>장애 발생 시 락 유실/중복</td><td>단일 노드 의존</td><td style=text-align:right>정합성 문제</td><td>quorum/etcd/ZK + 펜싱</td></tr><tr><td>인덱스 부재 → 갭락</td><td>불필요 범위 락</td><td>쿼리/인덱스 설계 미흡</td><td style=text-align:right>경합 증가</td><td>인덱스·쿼리 리팩터링</td></tr><tr><td>모니터링 부재</td><td>조기 징후 미검출</td><td>지표 미수집</td><td style=text-align:right>갑작스런 장애</td><td>지표·알람·플레이북</td></tr><tr><td>우선순위 역전/기아</td><td>특정 작업 계속 대기</td><td>공정성 결여</td><td style=text-align:right>SLA 위반</td><td>에이징·우선순위 상속</td></tr></tbody></table><h5 id=락-안티패턴-카테고리-분류>락 안티패턴 카테고리 분류<a hidden class=anchor aria-hidden=true href=#락-안티패턴-카테고리-분류>#</a></h5><h6 id=코드애플리케이션-레벨>코드/애플리케이션 레벨<a hidden class=anchor aria-hidden=true href=#코드애플리케이션-레벨>#</a></h6><p>코드·애플리케이션 차원에서 자주 나오는 안티패턴과 해결책.</p><ul><li>설명: 트랜잭션 경계·예외 처리·외부 I/O 관리를 잘못하면 락이 장시간 유지되거나 해제되지 않는다.</li><li>문제: 락 누설, 외부 호출 중 락 보유, 우선순위 역전 → 시스템 지연·데드락 증가.</li><li>결과: 사용자 대기 증가, 일부 트랜잭션의 반복 실패 (재시도 루프)</li><li>원인: try/finally 미사용, 트랜잭션 범위에 외부 종속 포함, 공정성 없는 큐</li><li>해결책:<ul><li>항상 안전한 자원 해제 패턴 (try-finally / with) 사용</li><li>트랜잭션 내 외부 I/O 금지 (커밋 후 처리 또는 이벤트 발행)</li><li>재시도 정책 (idempotency + 지수 백오프) 및 에이징 적용</li></ul></li><li>예시 (악례): DB 트랜잭션 내 HTTP 호출</li><li>예시 (개선): DB 커밋 → 이벤트 발행 → 비동기 worker 처리</li></ul><table><thead><tr><th>항목</th><th>악례 (간단)</th><th>개선 (간단)</th></tr></thead><tbody><tr><td>락 누설</td><td>try/catch 누락으로 락 미해제</td><td>try-finally 로 항상 rollback/close</td></tr><tr><td>외부 호출 중 락</td><td>트랜잭션 내 HTTP call</td><td>commit 후 외부 호출/비동기화</td></tr><tr><td>우선순위 역전</td><td>긴 보고서로 큐 블로킹</td><td>에이징/우선순위 분리</td></tr></tbody></table><ul><li>애플리케이션 레벨에서의 실수는 운영 전체에 큰 영향을 준다. 트랜잭션을 짧게 유지하고 외부 호출을 분리하며 재시도 정책을 표준화하라.</li></ul><h6 id=db쿼리-수준>DB/쿼리 수준<a hidden class=anchor aria-hidden=true href=#db쿼리-수준>#</a></h6><p>인덱스·쿼리·락 그레인 선택 관련 안티패턴.</p><ul><li>설명: 쿼리·인덱스가 부적절하면 필요 이상의 범위 락을 발생시키고 에스컬레이션을 유발한다.</li><li>문제: 갭락, 넓은 스캔, 에스컬레이션으로 동시성 저하</li><li>결과: 쓰기/읽기 경합 심화, 느린 쿼리</li><li>원인: 잘못된 WHERE 절, 부족한 인덱스, 테이블 스캔 유도</li><li>해결책: 인덱스 재설계, 쿼리 리팩터링, 배치 처리, HOT 업데이트 유도</li><li>예시 (악례): <code>UPDATE orders SET … WHERE created_at &lt; NOW() - interval '1 day'</code> (인덱스 없을 때)</li><li>예시 (개선): 적절한 <code>created_at</code> 인덱스 추가 + 파티셔닝 또는 chunked update</li></ul><table><thead><tr><th>항목</th><th>악례 (간단)</th><th>개선 (간단)</th></tr></thead><tbody><tr><td>갭락 유발 쿼리</td><td>범위 스캔 without index</td><td>인덱스 추가 / 쿼리 리팩터링</td></tr><tr><td>에스컬레이션 유발</td><td>대량 행락 발생</td><td>청크 처리 / 임계치 튜닝</td></tr><tr><td>테이블 락 남용</td><td>LOCK TABLE …</td><td>행단위 업데이트 + 인덱스</td></tr></tbody></table><ul><li>DB 수준 최적화 (인덱스·쿼리·파티셔닝) 가 선행되면 락 경합은 대폭 줄어든다. 배치·청크 전략은 에스컬레이션을 예방한다.</li></ul><h6 id=운영모니터링>운영/모니터링<a hidden class=anchor aria-hidden=true href=#운영모니터링>#</a></h6><p>운영 관점의 안티패턴과 대응.</p><ul><li>설명: 락 관련 지표를 수집·알람하지 않거나 데드락 자동화 대응이 없으면 장애를 키운다.</li><li>문제: 데드락 탐지 미비, 타임아웃·백오프 정책 부재</li><li>결과: 장애 확산, 긴 복구 시간</li><li>원인: 관찰·자동화 미흡, 알람 기준 부적절</li><li>해결책: 지표 수집 (Prometheus)·대시보드 (Grafana), 자동화 플레이북 (복구 스크립트), 적정 데드락 탐지 주기 설정</li><li>예시 (악례): 수동 로그 점검만으로 대응</li><li>예시 (개선): 실시간 알람 → 자동 롤백 스크립트 실행 후 팀 알림</li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>모니터링 부재</td><td>로그 수동 확인</td><td>lock_waits, deadlocks 알람</td></tr><tr><td>자동복구 없음</td><td>수동 롤백</td><td>자동 희생자 선정 스크립트</td></tr><tr><td>데드락 주기 부적절</td><td>고정 주기 (비효율)</td><td>적응형 검출 주기</td></tr></tbody></table><ul><li>운영은 관찰 가능한 시스템을 전제로 한다. 핵심 지표에 대한 알람과 자동화된 회복 절차를 반드시 갖춰라.</li></ul><h6 id=분산인프라>분산/인프라<a hidden class=anchor aria-hidden=true href=#분산인프라>#</a></h6><p>클러스터·분산 락 관련 안티패턴.</p><ul><li>설명: 분산 락을 단일 노드/비내결함성 솔루션에 의존하면 장애·중복 수행이 발생한다.</li><li>문제: 스플릿 브레인, 중복 작업, 장기 락 유실</li><li>결과: 데이터 정합성 붕괴, 장애 복구 복잡성 증가</li><li>원인: 단일 인스턴스 의존, 클럭 불일치, 네트워크 파티션 미고려</li><li>해결책: 합의 기반 락 (etcd/ZooKeeper), 펜싱 토큰 (lease + token), 멱등 처리, 사가/워크플로우 패턴</li><li>예시 (악례): Redis <code>SETNX</code> 만으로 글로벌 락 구현</li><li>예시 (개선): etcd lease + compare-and-swap or Redis with quorum + token + verification</li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>단일 Redis 의존</td><td>SETNX 단독</td><td>etcd/ZK + 펜싱 토큰</td></tr><tr><td>클럭 의존성</td><td>로컬 타임스탬프 기반</td><td>TrueTime/HLC 또는 펜싱</td></tr><tr><td>파티션 미고려</td><td>미검증 분산 락</td><td>합의·멱등·사가 적용</td></tr></tbody></table><ul><li>분산 락은 설계 난도가 높다. 합의 기반, 펜싱, 멱등성을 결합한 다중 방어 전략을 사용하라.</li></ul><h5 id=락-안티패턴-통합-대응표>락 안티패턴 통합 대응표<a hidden class=anchor aria-hidden=true href=#락-안티패턴-통합-대응표>#</a></h5><table><thead><tr><th>카테고리</th><th>안티패턴</th><th>핵심 원인</th><th>대표 해결책</th></tr></thead><tbody><tr><td>코드/앱</td><td>락 누설, 외부 호출 중 락, 우선순위 역전</td><td>트랜잭션 경계·예외처리 미흡, 외부 I/O 포함</td><td>try-finally, 트랜잭션 축소, 이벤트/사가</td></tr><tr><td>DB/쿼리</td><td>테이블 락 남용, 갭락, 에스컬레이션 오남용</td><td>인덱스·쿼리 부적합, 대량 업데이트</td><td>인덱스 개선, chunking, 파티셔닝</td></tr><tr><td>운영</td><td>모니터링 부재, 데드락 미탐지</td><td>지표·알람 미구축</td><td>지표 수집·알람·자동 복구</td></tr><tr><td>분산</td><td>단일 노드 락 의존, 클럭 파편화</td><td>단일 인스턴스, 파티션, 시간 불일치</td><td>etcd/ZK, 펜싱 토큰, 멱등 설계</td></tr></tbody></table><h4 id=실무-중심-마이그레이션업그레이드-가이드>실무 중심 마이그레이션·업그레이드 가이드<a hidden class=anchor aria-hidden=true href=#실무-중심-마이그레이션업그레이드-가이드>#</a></h4><ul><li><p><strong>무엇을 하는가?</strong>:<br>데이터베이스·아키텍처 변경 (예: 엔진 전환, 스키마 수정, 분산화) 시 서비스 중단을 최소화하면서 안전하게 바꾸는 방법.</p></li><li><p><strong>주요 아이디어</strong>:</p><ol><li>큰 작업은 여러 개의 작은 청크로 나누어 반복 실행 (Chunk + Commit).</li><li>동시에 여러 워커가 같은 작업을 시도하지 않도록 <code>FOR UPDATE SKIP LOCKED</code> 같은 기법으로 충돌 회피.</li><li>분산 환경으로 확장하면 단순 어드바이저리 락 대신 <strong>펜싱 토큰/합의 기반 락</strong>으로 전환해 안전하게 운영.</li></ol></li><li><p><strong>핵심 체크리스트</strong>: 사전 분석 → 리허설 (스테이징) → 점진 이관 (리플리카 이용) → 모니터링·알람 → 롤백/복구 절차 준비.</p></li></ul><h5 id=마이그레이션-핵심-전략-비교표>마이그레이션 핵심 전략 비교표<a hidden class=anchor aria-hidden=true href=#마이그레이션-핵심-전략-비교표>#</a></h5><table><thead><tr><th>전략 / 작업 유형</th><th style=text-align:right>적용 방법 (요약)</th><th>장점</th><th>단점 / 주의사항</th><th>검증/모니터링 포인트</th></tr></thead><tbody><tr><td>청크 + 커밋</td><td style=text-align:right>대량 작업을 작은 배치로 분할해 반복 커밋</td><td>락 시간·트랜잭션 길이 감소 → 가용성 유지</td><td>전체 시간 증가, 중단 없이 완료 보장 필요</td><td>배치 진행률, 실패율, 롤백 비용</td></tr><tr><td>FOR UPDATE SKIP LOCKED</td><td style=text-align:right>작업 큐에서 충돌 행을 건너뛰고 다른 워커가 처리</td><td>작업 중복 방지, 지연 감소</td><td>일부 항목이 처리되지 않을 가능성 → 재시도 정책 필요</td><td>처리율, 누락 항목 수, 재시도 횟수</td></tr><tr><td>어드바이저리 → 펜싱/합의 전환</td><td style=text-align:right>초기엔 앱 내 advisory → 분산락 (zk/etcd/Redis)+ 펜싱 토큰으로 전환</td><td>분산 안전성·파티션시 안전 보장</td><td>분산락 설계/타임아웃·펜싱 필요</td><td>락 소유 로그, 펜싱 실패 비율</td></tr><tr><td>엔진 전환 (MyISAM→InnoDB)</td><td style=text-align:right>Read-only→리플리카로 복제 후 cutover 또는 온라인 변환</td><td>행단위 락 도입으로 동시성↑</td><td>인덱스·쿼리 튜닝 필요, 복구·롤백 복잡</td><td>replication lag, query latency, lock wait</td></tr><tr><td>온라인 스키마 변경 (gh-ost/pt-osc)</td><td style=text-align:right>논리적 DDL 도구로 온라인 인덱스/컬럼 변경</td><td>무중단 변경 가능</td><td>도구 특성 파악 필요 (트리거/replica load)</td><td>binlog 사이즈, replica lag, tool errors</td></tr><tr><td>파티셔닝/샤딩</td><td style=text-align:right>데이터 분할로 마이그레이션 범위 축소</td><td>범위·부하 격리, 관리 단순화</td><td>설계 복잡성, 재분배 비용</td><td>핫파티션 감지, 분배 균형</td></tr></tbody></table><p>마이그레이션 전략은 **작업의 성격 (대량 업데이트, 스키마 변경, 엔진 전환 등)**에 따라 적절한 기법을 골라 결합해야 한다. 청크 기반 배치와 <code>SKIP LOCKED</code> 는 락·지연을 낮추는 기본 도구이며, 분산 확장 시에는 어드바이저리 락에서 펜싱/합의 기반 락으로 단계적 전환이 안전하다. 온라인 스키마 변경 도구와 리플리케이션을 활용하면 가용성을 유지하면서 마이그레이션을 수행할 수 있다.</p><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-mysql-레코드-단위-배타-잠금>실습 예제: MySQL 레코드 단위 배타 잠금<a hidden class=anchor aria-hidden=true href=#실습-예제-mysql-레코드-단위-배타-잠금>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>단일 레코드에 배타적 잠금을 걸어 동시성 환경에서 안전하게 데이터 갱신하는 방법 학습</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>MySQL 8.0 이상</li><li>Node.js 환경 + mysql2/promise 라이브러리</li><li>test_db 및 test_table 사전 생성</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>1 단계: 테이블 및 인덱스 준비</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span><span class=lnt id=hl-10-33><a class=lnlinks href=#hl-10-33>33</a>
</span><span class=lnt id=hl-10-34><a class=lnlinks href=#hl-10-34>34</a>
</span><span class=lnt id=hl-10-35><a class=lnlinks href=#hl-10-35>35</a>
</span><span class=lnt id=hl-10-36><a class=lnlinks href=#hl-10-36>36</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>mysql</span> <span class=kr>from</span> <span class=s1>&#39;mysql2/promise&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>createTestTable</span> <span class=o>=</span> <span class=kr>async</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>connection</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>mysql</span><span class=p>.</span><span class=nx>createConnection</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>host</span><span class=o>:</span> <span class=s1>&#39;localhost&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>user</span><span class=o>:</span> <span class=s1>&#39;root&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>password</span><span class=o>:</span> <span class=s1>&#39;your_password&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>database</span><span class=o>:</span> <span class=s1>&#39;test_db&#39;</span><span class=p>,</span> <span class=c1>// DB 명시
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 기존 테이블 삭제 후 재생성
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span><span class=sb>`DROP TABLE IF EXISTS test_table`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span><span class=sb>`
</span></span></span><span class=line><span class=cl><span class=sb>    CREATE TABLE test_table (
</span></span></span><span class=line><span class=cl><span class=sb>      id INT AUTO_INCREMENT PRIMARY KEY,
</span></span></span><span class=line><span class=cl><span class=sb>      data VARCHAR(255),
</span></span></span><span class=line><span class=cl><span class=sb>      reference_id INT
</span></span></span><span class=line><span class=cl><span class=sb>    )
</span></span></span><span class=line><span class=cl><span class=sb>  `</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 인덱스 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span><span class=sb>`CREATE INDEX idx_reference_id ON test_table (reference_id)`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 샘플 데이터 삽입
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span><span class=sb>`
</span></span></span><span class=line><span class=cl><span class=sb>    INSERT INTO test_table (data, reference_id) VALUES
</span></span></span><span class=line><span class=cl><span class=sb>    (&#39;첫 번째 행&#39;, 1),
</span></span></span><span class=line><span class=cl><span class=sb>    (&#39;두 번째 행&#39;, 2),
</span></span></span><span class=line><span class=cl><span class=sb>    (&#39;세 번째 행&#39;, 3)
</span></span></span><span class=line><span class=cl><span class=sb>  `</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>createTestTable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;테스트 테이블 생성 완료&#39;</span><span class=p>);</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>catch</span><span class=p>((</span><span class=nx>err</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;테이블 생성 오류:&#39;</span><span class=p>,</span> <span class=nx>err</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// 테이블과 인덱스 준비, 레코드 단위 배타적 잠금 실습 환경 구축[6]
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 배타 잠금 트랜잭션 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span><span class=lnt id=hl-11-22><a class=lnlinks href=#hl-11-22>22</a>
</span><span class=lnt id=hl-11-23><a class=lnlinks href=#hl-11-23>23</a>
</span><span class=lnt id=hl-11-24><a class=lnlinks href=#hl-11-24>24</a>
</span><span class=lnt id=hl-11-25><a class=lnlinks href=#hl-11-25>25</a>
</span><span class=lnt id=hl-11-26><a class=lnlinks href=#hl-11-26>26</a>
</span><span class=lnt id=hl-11-27><a class=lnlinks href=#hl-11-27>27</a>
</span><span class=lnt id=hl-11-28><a class=lnlinks href=#hl-11-28>28</a>
</span><span class=lnt id=hl-11-29><a class=lnlinks href=#hl-11-29>29</a>
</span><span class=lnt id=hl-11-30><a class=lnlinks href=#hl-11-30>30</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>import</span> <span class=nx>mysql</span> <span class=kr>from</span> <span class=s1>&#39;mysql2/promise&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 배타적 잠금 걸기 (SELECT … FOR UPDATE)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>lockAndUpdateRow</span> <span class=o>=</span> <span class=kr>async</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>connection</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>mysql</span><span class=p>.</span><span class=nx>createConnection</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>host</span><span class=o>:</span> <span class=s1>&#39;localhost&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>user</span><span class=o>:</span> <span class=s1>&#39;root&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>password</span><span class=o>:</span> <span class=s1>&#39;your_password&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>database</span><span class=o>:</span> <span class=s1>&#39;test_db&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>beginTransaction</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 트랜잭션 내 행 잠금
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=p>[</span><span class=nx>rows</span><span class=p>]</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=sb>`SELECT * FROM test_table WHERE id = 1 FOR UPDATE`</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 특정 행 수정
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=sb>`UPDATE test_table SET data = &#39;잠금 완료&#39; WHERE id = 1`</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>commit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>lockAndUpdateRow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;배타적 잠금 &amp; 데이터 수정 완료&#39;</span><span class=p>);</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>catch</span><span class=p>((</span><span class=nx>err</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;트랜잭션 오류:&#39;</span><span class=p>,</span> <span class=nx>err</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// 트랜잭션 실행 중 해당 행에 배타적 잠금이 걸려 외부 트랜잭션 접근 불가[6]
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>동시 실행한 다른 트랜잭션은 해당 행에 접근/수정 불가 (Blocking).</li><li>UPDATE 및 SELECT FOR UPDATE 에서 잠금 경쟁 발생 시 대기.</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>낙관적 락 (Version column 기반) 실습</li><li>테이블 락 명령 (lock tables … read/write) 과의 차이점 실험</li><li>SKIP LOCKED 옵션을 활용한 다중 워커 큐 구현</li></ul><h5 id=실습-예제-기본-락킹-시스템-구현>실습 예제: 기본 락킹 시스템 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-기본-락킹-시스템-구현>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>락킹의 핵심 개념인 호환성 검사와 대기 큐 관리를 직접 구현하여 동작 원리 이해</li><li>데드락 탐지 알고리즘의 실제 구현을 통한 시스템 설계 역량 강화</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>Python 3.8 이상</li><li>threading 모듈 (표준 라이브러리)</li><li>time 모듈 (표준 라이브러리)</li><li>기본적인 객체지향 프로그래밍 이해</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>1 단계: 락 유형 및 호환성 매트릭스 정의</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span><span class=lnt id=hl-12-28><a class=lnlinks href=#hl-12-28>28</a>
</span><span class=lnt id=hl-12-29><a class=lnlinks href=#hl-12-29>29</a>
</span><span class=lnt id=hl-12-30><a class=lnlinks href=#hl-12-30>30</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>threading</span> <span class=kn>import</span> <span class=n>Lock</span><span class=p>,</span> <span class=n>Condition</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>List</span><span class=p>,</span> <span class=n>Set</span><span class=p>,</span> <span class=n>Optional</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockType</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;락 유형 정의 - 공유락과 배타락의 기본 타입&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>SHARED</span> <span class=o>=</span> <span class=s2>&#34;S&#34;</span>      <span class=c1># 공유 락 (읽기용)</span>
</span></span><span class=line><span class=cl>    <span class=n>EXCLUSIVE</span> <span class=o>=</span> <span class=s2>&#34;X&#34;</span>   <span class=c1># 배타 락 (쓰기용)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockCompatibility</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;락 호환성 매트릭스 - 어떤 락들이 동시에 보유 가능한지 정의&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 호환성 테이블: True = 동시 보유 가능, False = 충돌</span>
</span></span><span class=line><span class=cl>    <span class=n>COMPATIBILITY_MATRIX</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>LockType</span><span class=o>.</span><span class=n>SHARED</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>SHARED</span><span class=p>):</span> <span class=kc>True</span><span class=p>,</span>      <span class=c1># S-S: 동시 읽기 허용</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>LockType</span><span class=o>.</span><span class=n>SHARED</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>):</span> <span class=kc>False</span><span class=p>,</span>   <span class=c1># S-X: 읽기-쓰기 충돌</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>SHARED</span><span class=p>):</span> <span class=kc>False</span><span class=p>,</span>   <span class=c1># X-S: 쓰기-읽기 충돌</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>):</span> <span class=kc>False</span> <span class=c1># X-X: 동시 쓰기 금지</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_compatible</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>existing_locks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>LockType</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                     <span class=n>requested_lock</span><span class=p>:</span> <span class=n>LockType</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;기존 락들과 요청된 락의 호환성 검사&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>existing_lock</span> <span class=ow>in</span> <span class=n>existing_locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=bp>cls</span><span class=o>.</span><span class=n>COMPATIBILITY_MATRIX</span><span class=o>.</span><span class=n>get</span><span class=p>((</span><span class=n>existing_lock</span><span class=p>,</span> <span class=n>requested_lock</span><span class=p>),</span> <span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 락 요청 및 대기 큐 관리</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span><span class=lnt id=hl-13-26><a class=lnlinks href=#hl-13-26>26</a>
</span><span class=lnt id=hl-13-27><a class=lnlinks href=#hl-13-27>27</a>
</span><span class=lnt id=hl-13-28><a class=lnlinks href=#hl-13-28>28</a>
</span><span class=lnt id=hl-13-29><a class=lnlinks href=#hl-13-29>29</a>
</span><span class=lnt id=hl-13-30><a class=lnlinks href=#hl-13-30>30</a>
</span><span class=lnt id=hl-13-31><a class=lnlinks href=#hl-13-31>31</a>
</span><span class=lnt id=hl-13-32><a class=lnlinks href=#hl-13-32>32</a>
</span><span class=lnt id=hl-13-33><a class=lnlinks href=#hl-13-33>33</a>
</span><span class=lnt id=hl-13-34><a class=lnlinks href=#hl-13-34>34</a>
</span><span class=lnt id=hl-13-35><a class=lnlinks href=#hl-13-35>35</a>
</span><span class=lnt id=hl-13-36><a class=lnlinks href=#hl-13-36>36</a>
</span><span class=lnt id=hl-13-37><a class=lnlinks href=#hl-13-37>37</a>
</span><span class=lnt id=hl-13-38><a class=lnlinks href=#hl-13-38>38</a>
</span><span class=lnt id=hl-13-39><a class=lnlinks href=#hl-13-39>39</a>
</span><span class=lnt id=hl-13-40><a class=lnlinks href=#hl-13-40>40</a>
</span><span class=lnt id=hl-13-41><a class=lnlinks href=#hl-13-41>41</a>
</span><span class=lnt id=hl-13-42><a class=lnlinks href=#hl-13-42>42</a>
</span><span class=lnt id=hl-13-43><a class=lnlinks href=#hl-13-43>43</a>
</span><span class=lnt id=hl-13-44><a class=lnlinks href=#hl-13-44>44</a>
</span><span class=lnt id=hl-13-45><a class=lnlinks href=#hl-13-45>45</a>
</span><span class=lnt id=hl-13-46><a class=lnlinks href=#hl-13-46>46</a>
</span><span class=lnt id=hl-13-47><a class=lnlinks href=#hl-13-47>47</a>
</span><span class=lnt id=hl-13-48><a class=lnlinks href=#hl-13-48>48</a>
</span><span class=lnt id=hl-13-49><a class=lnlinks href=#hl-13-49>49</a>
</span><span class=lnt id=hl-13-50><a class=lnlinks href=#hl-13-50>50</a>
</span><span class=lnt id=hl-13-51><a class=lnlinks href=#hl-13-51>51</a>
</span><span class=lnt id=hl-13-52><a class=lnlinks href=#hl-13-52>52</a>
</span><span class=lnt id=hl-13-53><a class=lnlinks href=#hl-13-53>53</a>
</span><span class=lnt id=hl-13-54><a class=lnlinks href=#hl-13-54>54</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockRequest</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;락 요청 정보를 담는 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                 <span class=n>lock_type</span><span class=p>:</span> <span class=n>LockType</span><span class=p>,</span> <span class=n>timestamp</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transaction_id</span> <span class=o>=</span> <span class=n>transaction_id</span>    <span class=c1># 트랜잭션 식별자</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>resource_id</span> <span class=o>=</span> <span class=n>resource_id</span>         <span class=c1># 자원 식별자  </span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_type</span> <span class=o>=</span> <span class=n>lock_type</span>             <span class=c1># 요청된 락 유형</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>timestamp</span> <span class=o>=</span> <span class=n>timestamp</span>             <span class=c1># 요청 시각 (데드락 탐지용)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>granted</span> <span class=o>=</span> <span class=kc>False</span>                   <span class=c1># 락 승인 여부</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>condition</span> <span class=o>=</span> <span class=n>Condition</span><span class=p>()</span>           <span class=c1># 대기 조건 변수</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;중앙 집중식 락 관리자 - 모든 락 요청을 처리하는 핵심 컴포넌트&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_lock_table</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=n>LockRequest</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 자원별 락 목록</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_wait_queue</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>List</span><span class=p>[</span><span class=n>LockRequest</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 자원별 대기 큐</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_transaction_locks</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>    <span class=c1># 트랜잭션별 보유 자원</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_manager_lock</span> <span class=o>=</span> <span class=n>Lock</span><span class=p>()</span>                          <span class=c1># 락 관리자 자체의 동기화</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>lock_type</span><span class=p>:</span> <span class=n>LockType</span><span class=p>,</span> <span class=n>timeout</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>30.0</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;락 획득 시도 - 락킹 시스템의 핵심 메서드&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>request</span> <span class=o>=</span> <span class=n>LockRequest</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>,</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>_manager_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 현재 보유된 락들과 호환성 검사</span>
</span></span><span class=line><span class=cl>            <span class=n>current_locks</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_current_locks</span><span class=p>(</span><span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>LockCompatibility</span><span class=o>.</span><span class=n>is_compatible</span><span class=p>(</span><span class=n>current_locks</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># 호환 가능: 즉시 락 승인</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_grant_lock</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 호환 불가능: 대기 큐에 추가</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_add_to_wait_queue</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 락이 승인될 때까지 대기 (타임아웃 포함)</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>request</span><span class=o>.</span><span class=n>condition</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>request</span><span class=o>.</span><span class=n>condition</span><span class=o>.</span><span class=n>wait_for</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=k>lambda</span><span class=p>:</span> <span class=n>request</span><span class=o>.</span><span class=n>granted</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=n>timeout</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;락 해제 및 대기 중인 요청들 처리&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>_manager_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 해당 트랜잭션의 락 제거</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_remove_lock</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 대기 큐에서 승인 가능한 요청들 처리</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_process_wait_queue</span><span class=p>(</span><span class=n>resource_id</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>3 단계: 데드락 탐지 및 해결</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span><span class=lnt id=hl-14-24><a class=lnlinks href=#hl-14-24>24</a>
</span><span class=lnt id=hl-14-25><a class=lnlinks href=#hl-14-25>25</a>
</span><span class=lnt id=hl-14-26><a class=lnlinks href=#hl-14-26>26</a>
</span><span class=lnt id=hl-14-27><a class=lnlinks href=#hl-14-27>27</a>
</span><span class=lnt id=hl-14-28><a class=lnlinks href=#hl-14-28>28</a>
</span><span class=lnt id=hl-14-29><a class=lnlinks href=#hl-14-29>29</a>
</span><span class=lnt id=hl-14-30><a class=lnlinks href=#hl-14-30>30</a>
</span><span class=lnt id=hl-14-31><a class=lnlinks href=#hl-14-31>31</a>
</span><span class=lnt id=hl-14-32><a class=lnlinks href=#hl-14-32>32</a>
</span><span class=lnt id=hl-14-33><a class=lnlinks href=#hl-14-33>33</a>
</span><span class=lnt id=hl-14-34><a class=lnlinks href=#hl-14-34>34</a>
</span><span class=lnt id=hl-14-35><a class=lnlinks href=#hl-14-35>35</a>
</span><span class=lnt id=hl-14-36><a class=lnlinks href=#hl-14-36>36</a>
</span><span class=lnt id=hl-14-37><a class=lnlinks href=#hl-14-37>37</a>
</span><span class=lnt id=hl-14-38><a class=lnlinks href=#hl-14-38>38</a>
</span><span class=lnt id=hl-14-39><a class=lnlinks href=#hl-14-39>39</a>
</span><span class=lnt id=hl-14-40><a class=lnlinks href=#hl-14-40>40</a>
</span><span class=lnt id=hl-14-41><a class=lnlinks href=#hl-14-41>41</a>
</span><span class=lnt id=hl-14-42><a class=lnlinks href=#hl-14-42>42</a>
</span><span class=lnt id=hl-14-43><a class=lnlinks href=#hl-14-43>43</a>
</span><span class=lnt id=hl-14-44><a class=lnlinks href=#hl-14-44>44</a>
</span><span class=lnt id=hl-14-45><a class=lnlinks href=#hl-14-45>45</a>
</span><span class=lnt id=hl-14-46><a class=lnlinks href=#hl-14-46>46</a>
</span><span class=lnt id=hl-14-47><a class=lnlinks href=#hl-14-47>47</a>
</span><span class=lnt id=hl-14-48><a class=lnlinks href=#hl-14-48>48</a>
</span><span class=lnt id=hl-14-49><a class=lnlinks href=#hl-14-49>49</a>
</span><span class=lnt id=hl-14-50><a class=lnlinks href=#hl-14-50>50</a>
</span><span class=lnt id=hl-14-51><a class=lnlinks href=#hl-14-51>51</a>
</span><span class=lnt id=hl-14-52><a class=lnlinks href=#hl-14-52>52</a>
</span><span class=lnt id=hl-14-53><a class=lnlinks href=#hl-14-53>53</a>
</span><span class=lnt id=hl-14-54><a class=lnlinks href=#hl-14-54>54</a>
</span><span class=lnt id=hl-14-55><a class=lnlinks href=#hl-14-55>55</a>
</span><span class=lnt id=hl-14-56><a class=lnlinks href=#hl-14-56>56</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DeadlockDetector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;데드락 탐지를 위한 대기 그래프 기반 알고리즘&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>lock_manager</span><span class=p>:</span> <span class=n>LockManager</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span> <span class=o>=</span> <span class=n>lock_manager</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>wait_graph</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 트랜잭션 간 대기 관계</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>detect_deadlock</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;대기 그래프에서 사이클 탐지를 통한 데드락 발견&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 1. 현재 대기 상황으로부터 대기 그래프 구성</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_build_wait_graph</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 2. DFS를 통한 사이클 탐지</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>rec_stack</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>transaction</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>wait_graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>transaction</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_has_cycle_dfs</span><span class=p>(</span><span class=n>transaction</span><span class=p>,</span> <span class=n>visited</span><span class=p>,</span> <span class=n>rec_stack</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 데드락 발견: 희생자 선택</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_select_victim</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>  <span class=c1># 데드락 없음</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_has_cycle_dfs</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>:</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                      <span class=n>rec_stack</span><span class=p>:</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;깊이 우선 탐색을 통한 사이클 탐지&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>rec_stack</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 인접 노드들 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>wait_graph</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=nb>set</span><span class=p>()):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_has_cycle_dfs</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>visited</span><span class=p>,</span> <span class=n>rec_stack</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>rec_stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>  <span class=c1># 사이클 발견!</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rec_stack</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_select_victim</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;데드락 해결을 위한 희생자 선택 - 최소 비용 기준&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 간단한 전략: 가장 적은 락을 보유한 트랜잭션 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>min_locks</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>victim</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>transaction_id</span><span class=p>,</span> <span class=n>resources</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span><span class=o>.</span><span class=n>_transaction_locks</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>resources</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>min_locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_locks</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>resources</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>victim</span> <span class=o>=</span> <span class=n>transaction_id</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>victim</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span><span class=lnt id=hl-15-20><a class=lnlinks href=#hl-15-20>20</a>
</span><span class=lnt id=hl-15-21><a class=lnlinks href=#hl-15-21>21</a>
</span><span class=lnt id=hl-15-22><a class=lnlinks href=#hl-15-22>22</a>
</span><span class=lnt id=hl-15-23><a class=lnlinks href=#hl-15-23>23</a>
</span><span class=lnt id=hl-15-24><a class=lnlinks href=#hl-15-24>24</a>
</span><span class=lnt id=hl-15-25><a class=lnlinks href=#hl-15-25>25</a>
</span><span class=lnt id=hl-15-26><a class=lnlinks href=#hl-15-26>26</a>
</span><span class=lnt id=hl-15-27><a class=lnlinks href=#hl-15-27>27</a>
</span><span class=lnt id=hl-15-28><a class=lnlinks href=#hl-15-28>28</a>
</span><span class=lnt id=hl-15-29><a class=lnlinks href=#hl-15-29>29</a>
</span><span class=lnt id=hl-15-30><a class=lnlinks href=#hl-15-30>30</a>
</span><span class=lnt id=hl-15-31><a class=lnlinks href=#hl-15-31>31</a>
</span><span class=lnt id=hl-15-32><a class=lnlinks href=#hl-15-32>32</a>
</span><span class=lnt id=hl-15-33><a class=lnlinks href=#hl-15-33>33</a>
</span><span class=lnt id=hl-15-34><a class=lnlinks href=#hl-15-34>34</a>
</span><span class=lnt id=hl-15-35><a class=lnlinks href=#hl-15-35>35</a>
</span><span class=lnt id=hl-15-36><a class=lnlinks href=#hl-15-36>36</a>
</span><span class=lnt id=hl-15-37><a class=lnlinks href=#hl-15-37>37</a>
</span><span class=lnt id=hl-15-38><a class=lnlinks href=#hl-15-38>38</a>
</span><span class=lnt id=hl-15-39><a class=lnlinks href=#hl-15-39>39</a>
</span><span class=lnt id=hl-15-40><a class=lnlinks href=#hl-15-40>40</a>
</span><span class=lnt id=hl-15-41><a class=lnlinks href=#hl-15-41>41</a>
</span><span class=lnt id=hl-15-42><a class=lnlinks href=#hl-15-42>42</a>
</span><span class=lnt id=hl-15-43><a class=lnlinks href=#hl-15-43>43</a>
</span><span class=lnt id=hl-15-44><a class=lnlinks href=#hl-15-44>44</a>
</span><span class=lnt id=hl-15-45><a class=lnlinks href=#hl-15-45>45</a>
</span><span class=lnt id=hl-15-46><a class=lnlinks href=#hl-15-46>46</a>
</span><span class=lnt id=hl-15-47><a class=lnlinks href=#hl-15-47>47</a>
</span><span class=lnt id=hl-15-48><a class=lnlinks href=#hl-15-48>48</a>
</span><span class=lnt id=hl-15-49><a class=lnlinks href=#hl-15-49>49</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 사용 예시 - 데드락 상황 시뮬레이션</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>simulate_deadlock</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;두 트랜잭션이 서로 다른 순서로 자원을 요청하는 데드락 시나리오&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>lock_manager</span> <span class=o>=</span> <span class=n>LockManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transaction_1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1: 자원 A에 배타 락 요청&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_manager</span><span class=o>.</span><span class=n>acquire_lock</span><span class=p>(</span><span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_A&#34;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 다른 트랜잭션이 시작할 시간 확보</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1: 자원 B에 배타 락 요청 (데드락 발생 가능)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>success</span> <span class=o>=</span> <span class=n>lock_manager</span><span class=o>.</span><span class=n>acquire_lock</span><span class=p>(</span><span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_B&#34;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mf>5.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1: 모든 작업 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_B&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1: 타임아웃으로 인한 중단&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transaction_2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.5</span><span class=p>)</span>  <span class=c1># T1이 먼저 시작하도록 보장</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T2: 자원 B에 배타 락 요청&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_manager</span><span class=o>.</span><span class=n>acquire_lock</span><span class=p>(</span><span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_B&#34;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T2: 자원 A에 배타 락 요청 (데드락 발생)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>success</span> <span class=o>=</span> <span class=n>lock_manager</span><span class=o>.</span><span class=n>acquire_lock</span><span class=p>(</span><span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_A&#34;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mf>5.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T2: 모든 작업 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;resource_B&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T2: 타임아웃으로 인한 중단&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 트랜잭션을 병렬로 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>t1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>transaction_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>transaction_2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl><span class=n>simulate_deadlock</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>예상 출력:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5>5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T1: 자원 A에 배타 락 요청
</span></span><span class=line><span class=cl>T2: 자원 B에 배타 락 요청
</span></span><span class=line><span class=cl>T1: 자원 B에 배타 락 요청 (데드락 발생 가능)
</span></span><span class=line><span class=cl>T2: 자원 A에 배타 락 요청 (데드락 발생)
</span></span><span class=line><span class=cl>T1: 타임아웃으로 인한 중단
</span></span><span class=line><span class=cl>T2: 타임아웃으로 인한 중단
</span></span></code></pre></td></tr></table></div></div><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>락 유형별 호환성 테스트 (S-S, S-X, X-X 조합)</li><li>대기 큐 순서 보장 테스트 (FIFO 확인)</li><li>성능 측정: 락 획득/해제 시간, 동시 트랜잭션 처리량</li><li>메모리 사용량 분석: 락 테이블 크기, 대기 큐 크기</li></ul><h5 id=실습-예제-작업-큐-work-queue-처리에-for-update-skip-locked-적용-postgresql>실습 예제: 작업 큐 (Work Queue) 처리에 FOR UPDATE SKIP LOCKED 적용 (PostgreSQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-작업-큐-work-queue-처리에-for-update-skip-locked-적용-postgresql>#</a></h5><h6 id=목적-2>목적<a hidden class=anchor aria-hidden=true href=#목적-2>#</a></h6><ul><li>경합 환경에서 <strong>작업 항목의 단일 소비</strong>와 <strong>지연 최소화</strong> 실습.</li></ul><h6 id=사전-요구사항-2>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-2>#</a></h6><ul><li>PostgreSQL, 파이썬 (psycopg2) 또는 Node.js(pg), 적절한 인덱스.</li></ul><h6 id=단계별-구현-2>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-2>#</a></h6><ol><li><p><strong>테이블 및 인덱스 준비</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7>7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 작업 큐 테이블
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>job_queue</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=n>BIGSERIAL</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>status</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=s1>&#39;pending&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>payload</span><span class=w> </span><span class=n>JSONB</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>locked_at</span><span class=w> </span><span class=n>TIMESTAMPTZ</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>job_queue</span><span class=w> </span><span class=p>(</span><span class=n>status</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>파이썬 워커 (간단 버전)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 목적: 동시 다중 워커가 각기 다른 작업을 집어가도록 보장</span>
</span></span><span class=line><span class=cl><span class=c1># 주제 연관: SELECT … FOR UPDATE SKIP LOCKED를 통한 락 기반 단일 소비</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span><span class=o>,</span> <span class=nn>json</span><span class=o>,</span> <span class=nn>psycopg2</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>psycopg2.extras</span> <span class=kn>import</span> <span class=n>RealDictCursor</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>conn</span> <span class=o>=</span> <span class=n>psycopg2</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s2>&#34;dbname=app user=app password=app host=localhost&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>conn</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># 트랜잭션 모드</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fetch_and_process_once</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>(</span><span class=n>cursor_factory</span><span class=o>=</span><span class=n>RealDictCursor</span><span class=p>)</span> <span class=k>as</span> <span class=n>cur</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 1) 후보 행을 잠금 획득하며 선택, 경합 시 잠긴 행은 건너뜀</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>            WITH picked AS (
</span></span></span><span class=line><span class=cl><span class=s2>              SELECT id FROM job_queue
</span></span></span><span class=line><span class=cl><span class=s2>              WHERE status = &#39;pending&#39;
</span></span></span><span class=line><span class=cl><span class=s2>              ORDER BY id
</span></span></span><span class=line><span class=cl><span class=s2>              FOR UPDATE SKIP LOCKED
</span></span></span><span class=line><span class=cl><span class=s2>              LIMIT 1
</span></span></span><span class=line><span class=cl><span class=s2>            )
</span></span></span><span class=line><span class=cl><span class=s2>            UPDATE job_queue j
</span></span></span><span class=line><span class=cl><span class=s2>            SET status = &#39;processing&#39;, locked_at = now()
</span></span></span><span class=line><span class=cl><span class=s2>            FROM picked p
</span></span></span><span class=line><span class=cl><span class=s2>            WHERE j.id = p.id
</span></span></span><span class=line><span class=cl><span class=s2>            RETURNING j.id, j.payload;
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>row</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>  <span class=c1># 아무 것도 없으면 롤백</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>job_id</span> <span class=o>=</span> <span class=n>row</span><span class=p>[</span><span class=s2>&#34;id&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>payload</span> <span class=o>=</span> <span class=n>row</span><span class=p>[</span><span class=s2>&#34;payload&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2) 실제 처리 (외부 호출은 가급적 트랜잭션 밖에서)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>  <span class=c1># 잠금 보유 최소화</span>
</span></span><span class=line><span class=cl>        <span class=c1># … 처리 로직 …</span>
</span></span><span class=line><span class=cl>        <span class=c1># 3) 완료 마킹</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>with</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>cur2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cur2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;UPDATE job_queue SET status=&#39;done&#39; WHERE id=</span><span class=si>%s</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>job_id</span><span class=p>,)</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>progressed</span> <span class=o>=</span> <span class=n>fetch_and_process_once</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>progressed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Node.js + Advisory Lock 로 싱글톤 잡 보장</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span><span class=lnt id=hl-19-17><a class=lnlinks href=#hl-19-17>17</a>
</span><span class=lnt id=hl-19-18><a class=lnlinks href=#hl-19-18>18</a>
</span><span class=lnt id=hl-19-19><a class=lnlinks href=#hl-19-19>19</a>
</span><span class=lnt id=hl-19-20><a class=lnlinks href=#hl-19-20>20</a>
</span><span class=lnt id=hl-19-21><a class=lnlinks href=#hl-19-21>21</a>
</span><span class=lnt id=hl-19-22><a class=lnlinks href=#hl-19-22>22</a>
</span><span class=lnt id=hl-19-23><a class=lnlinks href=#hl-19-23>23</a>
</span><span class=lnt id=hl-19-24><a class=lnlinks href=#hl-19-24>24</a>
</span><span class=lnt id=hl-19-25><a class=lnlinks href=#hl-19-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 목적: 분산 인스턴스 중 하나만 특정 잡 실행 (Advisory Lock)
</span></span></span><span class=line><span class=cl><span class=c1>// 주제 연관: 도메인 키 기반 락(예: job:rebuild-cache)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=p>{</span> <span class=nx>Client</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;pg&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>runSingletonJob</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>client</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Client</span><span class=p>({</span> <span class=nx>connectionString</span><span class=o>:</span> <span class=nx>process</span><span class=p>.</span><span class=nx>env</span><span class=p>.</span><span class=nx>DATABASE_URL</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>connect</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>query</span><span class=p>(</span><span class=s1>&#39;BEGIN&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 해시 키: 예시로 64-bit 키 두 개 사용 (namespace, key)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>res</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>query</span><span class=p>(</span><span class=s1>&#39;SELECT pg_try_advisory_lock($1, $2) AS ok&#39;</span><span class=p>,</span> <span class=p>[</span><span class=mi>42</span><span class=p>,</span> <span class=mi>9001</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>res</span><span class=p>.</span><span class=nx>rows</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>ok</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>query</span><span class=p>(</span><span class=s1>&#39;ROLLBACK&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Another instance holds the lock. Skip.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Lock acquired. Doing work…&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>query</span><span class=p>(</span><span class=s1>&#39;COMMIT&#39;</span><span class=p>);</span> <span class=c1>// 트랜잭션 경계 밖에서 실제 작업 수행 권장
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// … 실제 작업 (멱등/타임아웃/펜싱 고려)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>finally</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 세션 종료 시 advisory lock 해제
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>await</span> <span class=nx>client</span><span class=p>.</span><span class=nx>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>runSingletonJob</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-2>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-2>#</a></h6><ul><li>다중 워커 환경에서도 <strong>중복 처리 없이</strong> 작업이 분배. 경합 시 대기 대신 ** 건너뛰기 (SKIP LOCKED)** 로 지연 최소.</li></ul><h6 id=추가-실험-2>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-2>#</a></h6><ul><li><strong>NOWAIT</strong>로 즉시 실패 전략 비교.</li><li>인덱스 제거/추가 시 갭락/테이블락 영향 관찰.</li><li>긴 외부 I/O 를 트랜잭션 밖으로 이동하여 대기시간 비교.</li></ul><h5 id=실습-예제-mysql-인덱스-기반-레코드-락-네임드-락-실습>실습 예제: MySQL 인덱스 기반 레코드 락, 네임드 락 실습<a hidden class=anchor aria-hidden=true href=#실습-예제-mysql-인덱스-기반-레코드-락-네임드-락-실습>#</a></h5><h6 id=목적-3>목적<a hidden class=anchor aria-hidden=true href=#목적-3>#</a></h6><ul><li>인덱스 기반 레코드 잠금과 대표 분산 락 예제를 통해 실무 상황별 구현 방식을 체득</li></ul><h6 id=사전-요구사항-3>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-3>#</a></h6><ul><li>MySQL 8.0 이상 설치</li><li>employees 테이블, 적절한 인덱스 준비</li></ul><h6 id=단계별-구현-3>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-3>#</a></h6><ol><li><p><strong>1 단계: 인덱스 기반 레코드 락</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4>4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5>5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 인덱스가 걸려있는 &#39;first_name&#39; 컬럼을 기반으로 레코드 락 획득
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Georgi&#39;</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>hire_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>NOW</span><span class=p>()</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Georgi&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Klassen&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트랜잭션 내에서 SELECT FOR UPDATE로 읽은 모든 인덱스가 잠김[web:99]
</span></span></span></code></pre></td></tr></table></div></div><ul><li>인덱스가 없는 컬럼을 WHERE 조건에 사용하면, 테이블 풀스캔 시 전체 레코드가 잠금 상태가 됨 → 병행성 저하.[6]</li></ul></li><li><p><strong>2 단계: 네임드 락 활용 예제 (분산 락)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5>5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6>6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7>7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8>8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- mylock 문자열에 대해 2초간 잠금 획득 시도, 2초가 지나면 자동 해제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>GET_LOCK</span><span class=p>(</span><span class=s1>&#39;mylock&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 락을 해제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>RELEASE_LOCK</span><span class=p>(</span><span class=s1>&#39;mylock&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 락이 사용 중인지 확인
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>IS_FREE_LOCK</span><span class=p>(</span><span class=s1>&#39;mylock&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 웹 서버 여러 대가 DB 1대에 접속할 때 동기화 용도로 사용[web:61][web:99][web:104]
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-3>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-3>#</a></h6><ul><li>인덱스 기반 락은 해당 인덱스가 없는 경우 전체 레코드가 잠길 수 있으니 반드시 인덱스 설계를 잘 해야 함.</li><li>네임드 락은 정수 (1) 이면 성공, 0 또는 NULL 이면 실패. 서비스가 비동기·분산 환경 (여러 서버, 여러 프로세스) 에서 동기화가 필요한 작업 (예: 배치, 로그 이동, 동시 캐시 초기화 등) 에 유용.[3][5][6]</li></ul><h6 id=추가-실험-3>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-3>#</a></h6><ul><li>갭 락 (Gap Lock), 넥스트키 락 (Next-Key Lock) 실습</li><li>LOCK TABLES / UNLOCK TABLES 명령으로 전체 테이블 락 실험</li><li>innodb_trx, innodb_locks, innodb_lock_waits 로 락 대기 현황 조회, KILL 명령으로 경합 해소 [5][7]</li></ul><h4 id=실제-도입-사례-분석>실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-대형-은행의-계좌-이체-시스템>실제 도입 사례: 대형 은행의 계좌 이체 시스템<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-대형-은행의-계좌-이체-시스템>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><p><strong>비즈니스 상황:</strong></p><ul><li>일일 계좌 이체 건수: 500 만 건</li><li>동시 접속자 수: 최대 10 만 명</li><li>피크 시간 TPS (Transactions Per Second): 5,000</li><li>데이터 정확성 요구: 99.999% (금융 규제 준수)</li></ul><p><strong>기술적 과제:</strong></p><ul><li>동일 계좌에 대한 동시 이체 요청 처리</li><li>잔액 부족 검사의 정확성 보장</li><li>시스템 장애 시에도 데이터 일관성 유지</li><li>규제 요구사항: 모든 거래의 완전한 감사 추적</li></ul><p><strong>락킹 도입 결정 요인:</strong></p><ul><li><strong>정확성 우선</strong>: 잔액 불일치나 중복 출금 절대 불가</li><li><strong>규제 준수</strong>: 금융감독원의 전산 시스템 기준 만족</li><li><strong>성숙도</strong>: 30 년 이상 검증된 기술로 리스크 최소화</li><li><strong>표준화</strong>: 기존 은행 시스템과의 호환성</li></ul><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;클라이언트 계층&#34;
        WEB[웹 애플리케이션]
        MOBILE[모바일 앱]
        ATM[ATM]
    end
    
    subgraph &#34;애플리케이션 계층&#34;
        API[API 게이트웨이]
        TRANSFER[이체 서비스]
        BALANCE[잔액 조회 서비스]
    end
    
    subgraph &#34;트랜잭션 관리 계층&#34;
        TM[트랜잭션 매니저]
        LM[락 매니저]
        DL[데드락 탐지기]
    end
    
    subgraph &#34;데이터 계층&#34;
        ACCOUNT_DB[(계좌 DB)]
        TRANSACTION_DB[(거래 내역 DB)]
        AUDIT_DB[(감사 로그 DB)]
    end
    
    WEB --&gt; API
    MOBILE --&gt; API
    ATM --&gt; API
    
    API --&gt; TRANSFER
    API --&gt; BALANCE
    
    TRANSFER --&gt; TM
    BALANCE --&gt; TM
    
    TM --&gt; LM
    TM --&gt; DL
    
    TM --&gt; ACCOUNT_DB
    TM --&gt; TRANSACTION_DB
    TM --&gt; AUDIT_DB
</pre><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17>17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18>18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19>19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20>20</a>
</span><span class=lnt id=hl-23-21><a class=lnlinks href=#hl-23-21>21</a>
</span><span class=lnt id=hl-23-22><a class=lnlinks href=#hl-23-22>22</a>
</span><span class=lnt id=hl-23-23><a class=lnlinks href=#hl-23-23>23</a>
</span><span class=lnt id=hl-23-24><a class=lnlinks href=#hl-23-24>24</a>
</span><span class=lnt id=hl-23-25><a class=lnlinks href=#hl-23-25>25</a>
</span><span class=lnt id=hl-23-26><a class=lnlinks href=#hl-23-26>26</a>
</span><span class=lnt id=hl-23-27><a class=lnlinks href=#hl-23-27>27</a>
</span><span class=lnt id=hl-23-28><a class=lnlinks href=#hl-23-28>28</a>
</span><span class=lnt id=hl-23-29><a class=lnlinks href=#hl-23-29>29</a>
</span><span class=lnt id=hl-23-30><a class=lnlinks href=#hl-23-30>30</a>
</span><span class=lnt id=hl-23-31><a class=lnlinks href=#hl-23-31>31</a>
</span><span class=lnt id=hl-23-32><a class=lnlinks href=#hl-23-32>32</a>
</span><span class=lnt id=hl-23-33><a class=lnlinks href=#hl-23-33>33</a>
</span><span class=lnt id=hl-23-34><a class=lnlinks href=#hl-23-34>34</a>
</span><span class=lnt id=hl-23-35><a class=lnlinks href=#hl-23-35>35</a>
</span><span class=lnt id=hl-23-36><a class=lnlinks href=#hl-23-36>36</a>
</span><span class=lnt id=hl-23-37><a class=lnlinks href=#hl-23-37>37</a>
</span><span class=lnt id=hl-23-38><a class=lnlinks href=#hl-23-38>38</a>
</span><span class=lnt id=hl-23-39><a class=lnlinks href=#hl-23-39>39</a>
</span><span class=lnt id=hl-23-40><a class=lnlinks href=#hl-23-40>40</a>
</span><span class=lnt id=hl-23-41><a class=lnlinks href=#hl-23-41>41</a>
</span><span class=lnt id=hl-23-42><a class=lnlinks href=#hl-23-42>42</a>
</span><span class=lnt id=hl-23-43><a class=lnlinks href=#hl-23-43>43</a>
</span><span class=lnt id=hl-23-44><a class=lnlinks href=#hl-23-44>44</a>
</span><span class=lnt id=hl-23-45><a class=lnlinks href=#hl-23-45>45</a>
</span><span class=lnt id=hl-23-46><a class=lnlinks href=#hl-23-46>46</a>
</span><span class=lnt id=hl-23-47><a class=lnlinks href=#hl-23-47>47</a>
</span><span class=lnt id=hl-23-48><a class=lnlinks href=#hl-23-48>48</a>
</span><span class=lnt id=hl-23-49><a class=lnlinks href=#hl-23-49>49</a>
</span><span class=lnt id=hl-23-50><a class=lnlinks href=#hl-23-50>50</a>
</span><span class=lnt id=hl-23-51><a class=lnlinks href=#hl-23-51>51</a>
</span><span class=lnt id=hl-23-52><a class=lnlinks href=#hl-23-52>52</a>
</span><span class=lnt id=hl-23-53><a class=lnlinks href=#hl-23-53>53</a>
</span><span class=lnt id=hl-23-54><a class=lnlinks href=#hl-23-54>54</a>
</span><span class=lnt id=hl-23-55><a class=lnlinks href=#hl-23-55>55</a>
</span><span class=lnt id=hl-23-56><a class=lnlinks href=#hl-23-56>56</a>
</span><span class=lnt id=hl-23-57><a class=lnlinks href=#hl-23-57>57</a>
</span><span class=lnt id=hl-23-58><a class=lnlinks href=#hl-23-58>58</a>
</span><span class=lnt id=hl-23-59><a class=lnlinks href=#hl-23-59>59</a>
</span><span class=lnt id=hl-23-60><a class=lnlinks href=#hl-23-60>60</a>
</span><span class=lnt id=hl-23-61><a class=lnlinks href=#hl-23-61>61</a>
</span><span class=lnt id=hl-23-62><a class=lnlinks href=#hl-23-62>62</a>
</span><span class=lnt id=hl-23-63><a class=lnlinks href=#hl-23-63>63</a>
</span><span class=lnt id=hl-23-64><a class=lnlinks href=#hl-23-64>64</a>
</span><span class=lnt id=hl-23-65><a class=lnlinks href=#hl-23-65>65</a>
</span><span class=lnt id=hl-23-66><a class=lnlinks href=#hl-23-66>66</a>
</span><span class=lnt id=hl-23-67><a class=lnlinks href=#hl-23-67>67</a>
</span><span class=lnt id=hl-23-68><a class=lnlinks href=#hl-23-68>68</a>
</span><span class=lnt id=hl-23-69><a class=lnlinks href=#hl-23-69>69</a>
</span><span class=lnt id=hl-23-70><a class=lnlinks href=#hl-23-70>70</a>
</span><span class=lnt id=hl-23-71><a class=lnlinks href=#hl-23-71>71</a>
</span><span class=lnt id=hl-23-72><a class=lnlinks href=#hl-23-72>72</a>
</span><span class=lnt id=hl-23-73><a class=lnlinks href=#hl-23-73>73</a>
</span><span class=lnt id=hl-23-74><a class=lnlinks href=#hl-23-74>74</a>
</span><span class=lnt id=hl-23-75><a class=lnlinks href=#hl-23-75>75</a>
</span><span class=lnt id=hl-23-76><a class=lnlinks href=#hl-23-76>76</a>
</span><span class=lnt id=hl-23-77><a class=lnlinks href=#hl-23-77>77</a>
</span><span class=lnt id=hl-23-78><a class=lnlinks href=#hl-23-78>78</a>
</span><span class=lnt id=hl-23-79><a class=lnlinks href=#hl-23-79>79</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BankTransferService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;은행 이체 서비스 - 락킹을 활용한 안전한 계좌 이체&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>lock_manager</span><span class=p>:</span> <span class=n>LockManager</span><span class=p>,</span> <span class=n>db_connection</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span> <span class=o>=</span> <span class=n>lock_manager</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db</span> <span class=o>=</span> <span class=n>db_connection</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transaction_timeout</span> <span class=o>=</span> <span class=mf>30.0</span>  <span class=c1># 30초 트랜잭션 타임아웃</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transfer_money</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>from_account</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>to_account</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                      <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;계좌 이체 실행 - 2단계 락킹 프로토콜 적용&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1단계: 계좌 순서 정렬 (데드락 방지)</span>
</span></span><span class=line><span class=cl>            <span class=n>accounts</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>([</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 2단계: 순서대로 배타 락 획득 (성장 단계)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>account</span> <span class=ow>in</span> <span class=n>accounts</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>success</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span><span class=o>.</span><span class=n>acquire_lock</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=n>transaction_id</span><span class=p>,</span> <span class=n>account</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>timeout</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>transaction_timeout</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>_rollback_transaction</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;failed&#34;</span><span class=p>,</span> <span class=s2>&#34;reason&#34;</span><span class=p>:</span> <span class=s2>&#34;lock_timeout&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 3단계: 비즈니스 로직 실행</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_execute_transfer_logic</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span> <span class=n>transaction_id</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 4단계: 트랜잭션 커밋 및 락 해제 (축소 단계)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>result</span><span class=p>[</span><span class=s2>&#34;status&#34;</span><span class=p>]</span> <span class=o>==</span> <span class=s2>&#34;success&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_commit_transaction</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_rollback_transaction</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 예외 상황에서 자동 롤백</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_rollback_transaction</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;error&#34;</span><span class=p>,</span> <span class=s2>&#34;reason&#34;</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>e</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_execute_transfer_logic</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>from_account</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>to_account</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                               <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;실제 이체 로직 - 락 보호 하에서 안전하게 실행&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 1. 출금 계좌 잔액 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>from_balance</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>get_balance</span><span class=p>(</span><span class=n>from_account</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>from_balance</span> <span class=o>&lt;</span> <span class=n>amount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;failed&#34;</span><span class=p>,</span> <span class=s2>&#34;reason&#34;</span><span class=p>:</span> <span class=s2>&#34;insufficient_balance&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 2. 입금 계좌 존재 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>account_exists</span><span class=p>(</span><span class=n>to_account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;failed&#34;</span><span class=p>,</span> <span class=s2>&#34;reason&#34;</span><span class=p>:</span> <span class=s2>&#34;invalid_to_account&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 3. 잔액 업데이트 (원자적 연산)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>update_balance</span><span class=p>(</span><span class=n>from_account</span><span class=p>,</span> <span class=n>from_balance</span> <span class=o>-</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>to_balance</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>get_balance</span><span class=p>(</span><span class=n>to_account</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>update_balance</span><span class=p>(</span><span class=n>to_account</span><span class=p>,</span> <span class=n>to_balance</span> <span class=o>+</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 4. 거래 내역 기록</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>insert_transaction_log</span><span class=p>({</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;transaction_id&#34;</span><span class=p>:</span> <span class=n>transaction_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;from_account&#34;</span><span class=p>:</span> <span class=n>from_account</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;to_account&#34;</span><span class=p>:</span> <span class=n>to_account</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;amount&#34;</span><span class=p>:</span> <span class=n>amount</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;timestamp&#34;</span><span class=p>:</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;completed&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;success&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;transaction_id&#34;</span><span class=p>:</span> <span class=n>transaction_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;from_balance&#34;</span><span class=p>:</span> <span class=n>from_balance</span> <span class=o>-</span> <span class=n>amount</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;to_balance&#34;</span><span class=p>:</span> <span class=n>to_balance</span> <span class=o>+</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><p><strong>정량적 성과:</strong></p><ul><li><strong>데이터 일관성</strong>: 99.9999% 달성 (목표 99.999% 초과 달성)</li><li><strong>처리 성능</strong>: 평균 응답 시간 200ms (목표 500ms 대비 60% 향상)</li><li><strong>동시성</strong>: 피크 시간 5,000 TPS 안정적 처리</li><li><strong>가용성</strong>: 99.95% 달성 (연간 다운타임 4.38 시간 이내)</li></ul><p><strong>정성적 개선:</strong></p><ul><li><strong>운영 안정성</strong>: 데이터 불일치로 인한 장애 제로</li><li><strong>감사 대응</strong>: 완벽한 트랜잭션 추적으로 감사 통과</li><li><strong>개발자 생산성</strong>: 표준화된 락킹 패턴으로 개발 속도 향상</li><li><strong>고객 신뢰</strong>: 이체 오류 신고 건수 95% 감소</li></ul><p><strong>성능 지표 상세:</strong></p><table><thead><tr><th>지표</th><th>도입 전</th><th>도입 후</th><th>개선율</th></tr></thead><tbody><tr><td>평균 응답 시간</td><td>500ms</td><td>200ms</td><td>60% 향상</td></tr><tr><td>데이터 일관성 오류</td><td>월 50 건</td><td>월 0.5 건</td><td>99% 감소</td></tr><tr><td>시스템 가용성</td><td>99.9%</td><td>99.95%</td><td>0.05%p 향상</td></tr><tr><td>데드락 발생률</td><td>0.1%</td><td>0.001%</td><td>99% 감소</td></tr></tbody></table><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><p><strong>성공 요인:</strong></p><ol><li><strong>점진적 도입</strong>: 파일럿 프로젝트로 시작하여 단계적 확장</li><li><strong>모니터링 강화</strong>: 락 경합, 데드락, 성능 지표의 실시간 모니터링</li><li><strong>교육 투자</strong>: 개발팀 대상 락킹 이론 및 실무 교육 실시</li><li><strong>표준화</strong>: 락킹 패턴을 라이브러리화하여 재사용성 확보</li></ol><p><strong>주요 도전과 해결책:</strong></p><ul><li><strong>도전</strong>: 기존 시스템과의 호환성<ul><li><strong>해결</strong>: 어댑터 패턴을 통한 점진적 마이그레이션</li></ul></li><li><strong>도전</strong>: 성능 오버헤드 우려<ul><li><strong>해결</strong>: 세밀한 락 범위 조정과 락 풀링 기법 적용</li></ul></li><li><strong>도전</strong>: 개발팀의 학습 곡선<ul><li><strong>해결</strong>: 전용 락킹 라이브러리와 코딩 가이드라인 제공</li></ul></li></ul><p><strong>재현 시 고려사항:</strong></p><ol><li><strong>비즈니스 요구사항</strong>: 데이터 정확성 vs 성능의 우선순위 명확화</li><li><strong>기술 역량</strong>: 팀의 동시성 프로그래밍 경험 수준 평가</li><li><strong>시스템 규모</strong>: 트랜잭션 양과 동시 사용자 수에 따른 아키텍처 선택</li><li><strong>규제 환경</strong>: 업계별 컴플라이언스 요구사항 반영</li></ol><h5 id=실제-도입-사례-대형-쇼핑몰-트랜잭션-동시성-처리>실제 도입 사례: 대형 쇼핑몰 트랜잭션 동시성 처리<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-대형-쇼핑몰-트랜잭션-동시성-처리>#</a></h5><h6 id=배경-및-도입-이유-1>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유-1>#</a></h6><ul><li>결제, 재고, 주문 트랜잭션의 동시성 문제로 인한 재고 손실, 데이터 불일치, 장애 방지 필요</li></ul><h6 id=구현-아키텍처-1>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-1>#</a></h6><pre class=mermaid>graph TB
    A[Web 서버 그룹] --&gt; B[MySQL DB]
    B --&gt; C[Lock Manager]
    B --&gt; D[innodb_trx, innodb_locks]
    C --&gt; E[네임드 락 API]
    C --&gt; F[레코드 인덱스 기반 락]
</pre><ul><li>Web 서버에서 네임드 락 API 와 인덱스 기반 레코드 락을 혼합 사용하여 동시성 처리.[5][6]</li></ul><h6 id=핵심-구현-코드-1>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드-1>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4>4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5>5</a>
</span><span class=lnt id=hl-25-6><a class=lnlinks href=#hl-25-6>6</a>
</span><span class=lnt id=hl-25-7><a class=lnlinks href=#hl-25-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 상품 재고 감소 트랜잭션
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>GET_LOCK</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;stock_&#39;</span><span class=p>,</span><span class=w> </span><span class=n>product_id</span><span class=p>),</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>inventory</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock_qty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stock_qty</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>product_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10042</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>RELEASE_LOCK</span><span class=p>(</span><span class=n>CONCAT</span><span class=p>(</span><span class=s1>&#39;stock_&#39;</span><span class=p>,</span><span class=w> </span><span class=n>product_id</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 네임드 락으로 거래별 동기화. 인덱스 기반으로 레코드를 잠금하여 재고 손실 방지.
</span></span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과-1>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과-1>#</a></h6><ul><li>Deadlock, Lost Update, Phantom Read 가 줄어듦</li><li>동시 주문 시 재고 오류 방지, 운영 안정성 증가</li></ul><h6 id=교훈-및-시사점-1>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점-1>#</a></h6><ul><li>락 경합이 심한 구간은 분산 락보다 Lock-Free 구조·MVCC 병행제어를 병행해야 최적 결과</li><li>인덱스 없는 테이블, 과도한 테이블 락 남용은 운영성 저하, 성능 하락 유발</li></ul><h4 id=락-연계-시스템-아키텍처>락 연계 시스템 아키텍처<a hidden class=anchor aria-hidden=true href=#락-연계-시스템-아키텍처>#</a></h4><p>락 시스템은 데이터 무결성을 지켜주지만, 외부 메시지 시스템·분산 서비스·복구 시스템과 <strong>연계되지 않으면</strong> 분산 트랜잭션·비동기 작업에서 불일치가 발생한다. 실무에서는 <strong>Outbox</strong>로 DB 변경과 메시지 전송을 결합하고, <strong>Saga</strong>로 긴 트랜잭션을 분해하며, <strong>펜싱·리스</strong>로 분산 리더의 스테일 문제를 막는다. 이들 패턴을 조합하면 일관성, 신뢰성, 확장성 사이의 균형을 실무 수준에서 맞출 수 있다.</p><h5 id=락-통합연계-기술-개요>락 통합·연계 기술 개요<a hidden class=anchor aria-hidden=true href=#락-통합연계-기술-개요>#</a></h5><h6 id=왜-why>왜 (Why)<a hidden class=anchor aria-hidden=true href=#왜-why>#</a></h6><ul><li>락은 데이터 무결성을 보장하지만 단독으로는 분산·비동기 환경에서 전반적 일관성·가용성을 확보하지 못한다.</li><li>통합으로 <strong>DB 내부 상태 + 외부 메시징/워크플로우</strong> 간의 원자성·일관성을 확보하고, 장수 트랜잭션 문제·확장성 한계를 완화한다.</li></ul><h6 id=무엇-what통합-대상>무엇 (What)—통합 대상<a hidden class=anchor aria-hidden=true href=#무엇-what통합-대상>#</a></h6><ul><li>내부: Transaction Manager, Lock Manager, Buffer Manager, Log/Recovery.</li><li>외부: Message Queue (Kafka/RabbitMQ), Workflow Engine (Saga), Cache/Redis, Distributed Coordination (ZK/etcd/consensus).</li><li>보조: CDC, Outbox, 2PC/Saga, Fencing/Lease, Idempotency store, Observability.</li></ul><h6 id=어떻게-how핵심-통합-패턴기술>어떻게 (How)—핵심 통합 패턴·기술<a hidden class=anchor aria-hidden=true href=#어떻게-how핵심-통합-패턴기술>#</a></h6><ul><li><strong>Outbox 패턴</strong>: 트랜잭션 내에 &rsquo; 아웃박스 &rsquo; 레코드를 쓰고, 별도 프로세스가 이 레코드를 메시지로 전송 → 메시지 전송 실패로 인한 반응형 재시도가 안전.</li><li><strong>CDC(WAL 기반)</strong>: DB 변경을 로그에서 추출해 이벤트 스트림으로 내보냄 (비동기적 일관성).</li><li><strong>2PC (Two-Phase Commit)</strong>: 분산 트랜잭션의 원자성 보장 (단, 블로킹·가용성 비용 큼).</li><li><strong>Saga / Workflow</strong>: 긴 트랜잭션을 보상 트랜잭션 (Compensation) 시퀀스로 분해.</li><li><strong>Fencing / Lease</strong>: 리더 기반 접근 제어에서 stale client 의 작동을 방지.</li><li><strong>Kafka 트랜잭션</strong>: 프로듀서 트랜잭션과 아웃박스 결합으로 exactly-once 보장 범위 확장.</li><li><strong>Idempotency Keys</strong>: 재시도 시 중복 실행을 방지.</li></ul><h6 id=가치-value>가치 (Value)<a hidden class=anchor aria-hidden=true href=#가치-value>#</a></h6><ul><li><strong>완전성</strong>: ACID 보장 범위 확대 (적용 가능한 곳에서).</li><li><strong>효율성</strong>: 중복 작업 제거·비동기 전파로 처리량 향상.</li><li><strong>일관성</strong>: DB 내부·외부 간 상태 동기화 가능.</li><li><strong>확장성/신뢰성</strong>: 분산 환경에서도 일관성 모델 선택에 따라 안정적 동작.</li></ul><h5 id=락-통합-기술-카테고리>락 통합 기술 카테고리<a hidden class=anchor aria-hidden=true href=#락-통합-기술-카테고리>#</a></h5><h6 id=내부-연계-데이터베이스-내부>내부 연계 (데이터베이스 내부)<a hidden class=anchor aria-hidden=true href=#내부-연계-데이터베이스-내부>#</a></h6><p>데이터 일관성과 복구를 위해 Lock Manager, Transaction Manager, Buffer Manager, WAL/Recovery 를 긴밀하게 통합해야 한다.</p><ul><li>핵심 포인트: WAL(로그) → LSN(로그 시퀀스 번호) 기반으로 버퍼 플러시와 커밋 순서 보장. 커밋 전에 WAL 을 durable 하게 기록하고, Lock 소유권과 로그 타이밍을 맞춰야 회복 시 일관성 확보.</li><li>구현 예: 트랜잭션 커밋 시 log_manager.flush(lsn) → buffer_manager.flush(lsn) 에 의해 관련 페이지가 디스크로 밀려나고 그 후에 lock 해제·커밋 확정.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>Lock ↔ WAL</td><td>복구 일관성</td><td>LSN 기반 flush 순서</td><td>WAL latency, flush duration</td></tr><tr><td>TM ↔ Buffer</td><td>데이터 동기화</td><td>lazy write + lsn tagging</td><td>dirty page ratio, checkpoint gap</td></tr></tbody></table><ul><li>요약: DB 내부 통합은 장애 복구와 데이터 일관성의 기초이다.</li></ul><h6 id=메시징비동기-연계>메시징/비동기 연계<a hidden class=anchor aria-hidden=true href=#메시징비동기-연계>#</a></h6><p>DB 변경을 외부 시스템에 안전하게 전달하려면 Outbox/Transactional Messaging 패턴을 사용한다.</p><ul><li>핵심 포인트: 트랜잭션 내부에 메시지 (아웃박스) 를 기록 → 별도 배포 프로세스가 아웃박스를 읽어 MQ 에 전송 → 전송 성공 시 아웃박스 상태 업데이트. 카프카 트랜잭션을 이용하면 exactly-once 와 결합 가능.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>Outbox → MQ</td><td>원자적 메시징</td><td>DB-side outbox, relay</td><td>outbox lag, duplicate rate</td></tr><tr><td>Kafka Transactions</td><td>exactly-once</td><td>transactional producer</td><td>transaction commit latency</td></tr></tbody></table><ul><li>요약: Outbox 는 DB↔MQ 간 원자성 문제를 실무적으로 해결하는 핵심 패턴이다.</li></ul><h6 id=분산조정-연계>분산·조정 연계<a hidden class=anchor aria-hidden=true href=#분산조정-연계>#</a></h6><p>글로벌 자원에 대한 락은 Lease/펜싱/Consensus 로 보완해야 안전하다.</p><ul><li>핵심 포인트: 리더 선출 후 작업 시 펜싱 토큰을 사용해 이전 리더의 잔여 작업이 영향 주는 것을 차단. 분산 락은 네트워크·지연성 비용을 수반하므로 최소화 전략 필요.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>Lease / Fencing</td><td>스테일 리더 차단</td><td>lease renew, fencing token</td><td>lease TTL, renewal latency</td></tr><tr><td>Consensus-based lock</td><td>강제성 제공</td><td>Raft/Paxos</td><td>quorum availability, latency</td></tr></tbody></table><ul><li>요약: 분산 락은 신중히 설계해야 하며 펜싱과 TTL 정책이 핵심이다.</li></ul><h6 id=장수-트랜잭션--워크플로우>장수 트랜잭션 / 워크플로우<a hidden class=anchor aria-hidden=true href=#장수-트랜잭션--워크플로우>#</a></h6><p>긴 트랜잭션을 Saga/보상 트랜잭션으로 분해해 시스템 영향 최소화.</p><ul><li>핵심 포인트: 로컬 트랜잭션 단위로 커밋 가능한 조각으로 나누고, 실패 시 보상 트랜잭션을 실행. 명시적 상태 기계 (State Machine) 관리는 중요.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>Saga</td><td>긴 Tx 분해</td><td>choreography/orchestration</td><td>compensation success rate</td></tr><tr><td>Workflow Engine</td><td>상태 관리</td><td>durable workflow state</td><td>workflow stuck count</td></tr></tbody></table><ul><li>요약: Saga 는 2PC 의 대안으로 확장성과 가용성 측면에서 유리하다.</li></ul><h6 id=이벤트데이터-파이프라인>이벤트·데이터 파이프라인<a hidden class=anchor aria-hidden=true href=#이벤트데이터-파이프라인>#</a></h6><p>CDC 로 DB 변경을 스트림으로 전파해 비동기 복제·검색 인덱스 동기화에 활용.</p><ul><li>핵심 포인트: WAL 에서 안정적으로 이벤트를 뽑아내며, 소비자 측에서 재시도/아이덤포턴시를 처리해야 한다.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>CDC</td><td>이벤트 전파</td><td>WAL tailing, Debezium</td><td>cdc lag, schema evolution</td></tr><tr><td>Sink Connect</td><td>파이프라인</td><td>Kafka Connect</td><td>connector failures</td></tr></tbody></table><ul><li>요약: CDC 는 데이터 동기화·분석 파이프라인의 근간이다.</li></ul><h6 id=운영관측신뢰성>운영·관측·신뢰성<a hidden class=anchor aria-hidden=true href=#운영관측신뢰성>#</a></h6><p>재시도·중복방지·모니터링·Runbook 은 통합 시스템의 필수.</p><ul><li>핵심 포인트: idempotency key, end-to-end tracing, SLO 기반 알람, 복구 절차가 없으면 통합의 이점이 무의미.</li></ul><table><thead><tr><th>통합 요소</th><th>목적</th><th>패턴/기술</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>Idempotency</td><td>중복 처리 방지</td><td>idempotent keys, dedupe store</td><td>duplicate rate</td></tr><tr><td>Observability</td><td>문제탐지</td><td>tracing (OpenTelemetry)</td><td>trace latency, error rate</td></tr><tr><td>Runbook</td><td>복구 절차</td><td>playbooks</td><td>MTTR, manual steps</td></tr></tbody></table><ul><li>요약: 운영·관측 없이는 통합도 안전하게 운영 불가.</li></ul><h5 id=락-통합-기술-요약표>락 통합 기술 요약표<a hidden class=anchor aria-hidden=true href=#락-통합-기술-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 목적</th><th>대표 패턴/툴</th><th>핵심 운영 지표</th></tr></thead><tbody><tr><td>내부 연계</td><td>DB 일관성·복구</td><td>LSN flush, WAL sync</td><td>WAL latency, checkpoint gap</td></tr><tr><td>메시징/비동기</td><td>DB→외부 원자성</td><td>Outbox, Kafka Tx</td><td>outbox lag, duplicate rate</td></tr><tr><td>분산 조정</td><td>글로벌 리더/락</td><td>Lease, Fencing, Raft</td><td>lease TTL, quorum latency</td></tr><tr><td>워크플로우</td><td>긴 Tx 분해·보상</td><td>Saga, Workflow Engine</td><td>compensation success rate</td></tr><tr><td>이벤트파이프</td><td>변경 스트리밍</td><td>CDC, Kafka Connect</td><td>cdc lag, connector errors</td></tr><tr><td>운영/관측</td><td>신뢰성·복구</td><td>Idempotency, Tracing</td><td>deadletter, MTTR, SLO breach</td></tr></tbody></table><h3 id=phase-6-운영-및-최적화>Phase 6: 운영 및 최적화<a hidden class=anchor aria-hidden=true href=#phase-6-운영-및-최적화>#</a></h3><h4 id=락-관측성-지표진단대응-체계>락 관측성: 지표·진단·대응 체계<a hidden class=anchor aria-hidden=true href=#락-관측성-지표진단대응-체계>#</a></h4><p>락 시스템 관측성은 <strong>지표 (무엇)</strong>, <strong>목적 (왜)</strong>, <strong>수단 (어떻게)</strong> 의 삼박자로 접근한다.<br>핵심 지표는 락 대기 시간·경합률·데드락 발생·차단 세션·락 테이블 사용량 등이다.<br>이들을 DB 내부 뷰로부터 수집해 시계열 DB 로 적재하고 (예: Prometheus), 경보는 임계값 기반 + 트렌드 감지 (예측형) 로 구성한다.<br>세밀한 원인 분석을 위해 필요한 경우 개별 트랜잭션의 락 생애주기 (trace) 를 샘플링해 분산 트레이싱과 연계하면 문제 해결 속도가 크게 빨라진다.</p><h5 id=락-모니터링-핵심-지표>락 모니터링 핵심 지표<a hidden class=anchor aria-hidden=true href=#락-모니터링-핵심-지표>#</a></h5><ul><li><p><strong>락 대기 시간 (Lock Wait Time)</strong></p><ul><li>왜: 사용자가 체감하는 지연의 주요 원인.</li><li>어떻게: DB 내장 뷰에서 평균/95/99 퍼센타일 집계; Prometheus histogram 으로 수집.</li></ul></li><li><p><strong>락 경합률 (Contention Rate)</strong></p><ul><li>왜: 락 경쟁이 시스템 스루풋을 제한하는지 파악.</li><li>어떻게: 전체 락 요청 대비 대기 발생 비율, 시계열 추이.</li></ul></li><li><p><strong>데드락 발생 수 및 해결 시간</strong></p><ul><li>왜: 데드락은 직접적인 작업 롤백·지연을 유발하므로 빈번 발생 시 설계 변경 필요.</li><li>어떻게: DB deadlock log + 트레이스 (누가 누구를 블로킹 했는지), Alert on count/time window.</li></ul></li><li><p><strong>락 테이블 메모리 점유 / 대기 큐 길이</strong></p><ul><li>왜: 리소스 포화로 인해 신규 락 획득이 실패하거나 에스컬레이션 발생.</li><li>어떻게: OS/DB 메모리 모니터링, lock table size metric, 큐 길이 histogram.</li></ul></li><li><p><strong>락 에스컬레이션 빈도</strong></p><ul><li>왜: 에스컬레이션은 동시성 급감·대상 범위 확대를 유발.</li><li>어떻게: DB 에스컬레이션 이벤트 로그 수집, 테이블별/시간대별 집계.</li></ul></li><li><p><strong>blocked sessions / blocked by mapping</strong></p><ul><li>왜: 병목 식별 (어떤 트랜잭션/쿼리가 병목 유발).</li><li>어떻게: <code>pg_locks</code> 조인 쿼리 (또는 MySQL Performance Schema), 트랜잭션 ID→애플리케이션 span 매핑.</li></ul></li><li><p><strong>추가: 트렌드/예측 지표</strong></p><ul><li>왜: 사전 용량 증설·성능 완화 (스케일아웃) 판단.</li><li>어떻게: 이동평균·증가율 기반 알람, 시즌성 모델 반영.</li></ul></li></ul><h5 id=락-모니터링-핵심-지표-요약표>락 모니터링 핵심 지표 요약표<a hidden class=anchor aria-hidden=true href=#락-모니터링-핵심-지표-요약표>#</a></h5><table><thead><tr><th>항목</th><th>목적 (왜)</th><th style=text-align:right>수단 (어떻게)</th><th style=text-align:right>권장 출발 임계값 (예시)</th></tr></thead><tbody><tr><td>Lock Wait Time (P95/P99)</td><td>사용자 체감 지연 파악</td><td style=text-align:right>DB view → Prom histogram</td><td style=text-align:right>P95 > 500ms 경고, P99 > 2s 심각</td></tr><tr><td>Lock Contention Rate</td><td>동시성 저하 징후</td><td style=text-align:right>(wait_events / total_lock_requests)</td><td style=text-align:right>> 20% 경고, >50% 위험</td></tr><tr><td>Deadlock Count / 해결 시간</td><td>무결성·가용성 위험</td><td style=text-align:right>DB deadlock log + 트레이스</td><td style=text-align:right>deadlock/hr > 1 경고</td></tr><tr><td>Blocked Sessions</td><td>병목 유발 쿼리 식별</td><td style=text-align:right>pg_locks/INNODB_LOCK_WAITS 쿼리</td><td style=text-align:right>blocked > 10 동시 시 경고</td></tr><tr><td>Lock Table Memory Usage</td><td>리소스 포화 감시</td><td style=text-align:right>OS/DB 메트릭</td><td style=text-align:right>사용률 > 70% 경고</td></tr><tr><td>Lock Escalation Events</td><td>동시성 급락 조기경보</td><td style=text-align:right>DB 에스컬레이션 로그</td><td style=text-align:right>급증 시 즉시 조사</td></tr><tr><td>Lock Throughput</td><td>락 시스템의 처리량</td><td style=text-align:right>lock_acquires/sec</td><td style=text-align:right>추세 기반 설정</td></tr><tr><td>Traceable Lock Lifecycle</td><td>원인 분석 (복구)</td><td style=text-align:right>샘플링된 트랜잭션 추적</td><td style=text-align:right>Detail on-demand</td></tr></tbody></table><blockquote><p>주: 권장 임계값은 서비스 특성에 따라 조정 필요 (예: 실시간 금융 vs 배치형 ETL).</p></blockquote><h5 id=락-관측성-카테고리별-지표>락 관측성 카테고리별 지표<a hidden class=anchor aria-hidden=true href=#락-관측성-카테고리별-지표>#</a></h5><h6 id=실시간-운영-kpi-빠른-경보용>실시간 운영 KPI (빠른 경보용)<a hidden class=anchor aria-hidden=true href=#실시간-운영-kpi-빠른-경보용>#</a></h6><ul><li><strong>무엇</strong>: P95/P99 Lock Wait Time, Lock Contention Rate, Blocked Sessions 수.</li><li><strong>왜</strong>: 사용자 체감 성능 저하와 직결되므로 즉시 대응 필요.</li><li><strong>어떻게</strong>: Prometheus histogram + Alertmanager 룰 (예: P95>500ms), DB 뷰의 실시간 쿼리로 보강.</li><li><strong>운영 팁</strong>: 임계값 초과 시 자동적으로 해당 트랜잭션의 쿼리 텍스트와 실행 계획을 캡처해 컨텍스트 제공.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>즉시 대응</th></tr></thead><tbody><tr><td>P95 Lock Wait</td><td style=text-align:right>DB view → exporter → histogram</td><td>알람 → 캡처 쿼리/kill 후보</td></tr><tr><td>Lock Contention Rate</td><td style=text-align:right>집계 (metric)</td><td>경합 구간 스케일 아웃 검토</td></tr><tr><td>Blocked Sessions</td><td style=text-align:right>pg_locks 조인</td><td>블로킹 쿼리 우선 조사</td></tr></tbody></table><ul><li>요약: 사용자가 느끼는 문제를 빠르게 감지하고, 최소한의 정보로 원인 탐색을 시작하게 하는 지표들이다.</li></ul><h6 id=안정성무결성-지표-상태-추적용>안정성·무결성 지표 (상태 추적용)<a hidden class=anchor aria-hidden=true href=#안정성무결성-지표-상태-추적용>#</a></h6><ul><li><strong>무엇</strong>: Deadlock Count, Deadlock resolution time, Lock Escalation events.</li><li><strong>왜</strong>: 데이터 무결성/업무 연속성에 직접적인 위협을 주므로 루트 원인 분석 필요.</li><li><strong>어떻게</strong>: DB deadlock 로그 보존 (완전 stack trace), 자동 수집 및 장기 집계 (일/주 단위).</li><li><strong>운영 팁</strong>: deadlock 발생 시 자동으로 관련 트랜잭션들을 샘플링하여 쿼리/plan/parameter 를 기록.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>운영 대응</th></tr></thead><tbody><tr><td>Deadlock Count</td><td style=text-align:right>DB deadlock log</td><td>원인 분석 → 쿼리/인덱스/순서 수정</td></tr><tr><td>Deadlock Resolution Time</td><td style=text-align:right>로그 타임스탬프</td><td>SLA 위반 시 자동 리포트</td></tr><tr><td>Lock Escalation</td><td style=text-align:right>DB 이벤트</td><td>에스컬레이션 정책 재검토</td></tr></tbody></table><ul><li>요약: 안정성 지표는 재발 방지 (설계·쿼리 수정) 로 이어지는 근본 대책의 근거를 제공한다.</li></ul><h6 id=리소스용량-지표-용량-계획용>리소스·용량 지표 (용량 계획용)<a hidden class=anchor aria-hidden=true href=#리소스용량-지표-용량-계획용>#</a></h6><ul><li><strong>무엇</strong>: Lock Table Memory Usage, Queue Length, Lock Throughput.</li><li><strong>왜</strong>: 락 관리 자체가 리소스를 소모하므로 용량 초과 시 전체 서비스 영향 발생.</li><li><strong>어떻게</strong>: OS/DB 메트릭 + periodic snapshots(예: 5 분 간격 집계).</li><li><strong>운영 팁</strong>: 메모리 점유율 급증 시 에스컬레이션 임계값을 낮춰 선제 차단.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>권장 조치</th></tr></thead><tbody><tr><td>Lock Table Memory</td><td style=text-align:right>OS/DB metrics</td><td>메모리 증설 또는 샤딩</td></tr><tr><td>Queue Length</td><td style=text-align:right>DB view 집계</td><td>트랜잭션 분할/재조정</td></tr><tr><td>Lock Throughput</td><td style=text-align:right>metric rate</td><td>처리량 한계 파악</td></tr></tbody></table><ul><li>요약: 리소스 지표는 장기적 안정성을 위한 용량 계획과 직접 연결된다.</li></ul><h6 id=진단추적-지표-원인-분석용>진단·추적 지표 (원인 분석용)<a hidden class=anchor aria-hidden=true href=#진단추적-지표-원인-분석용>#</a></h6><ul><li><strong>무엇</strong>: Traceable Lock Lifecycle, per-transaction lock timeline, slow-lock traces.</li><li><strong>왜</strong>: 재현 어려운 문제의 근본 원인 (어떤 트랜잭션이 언제 어떤 락을 획득·해제했는지) 을 규명.</li><li><strong>어떻게</strong>: 샘플링 기반 상세 추적 (분산 트레이싱 연계), 특정 이벤트 발생 시 자동 온디멘드 캡처.</li><li><strong>운영 팁</strong>: 평상시에는 샘플링 (예: 1/1000) 유지, 알람/이상 탐지 시에만 상세 캡처 활성화.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>활용</th></tr></thead><tbody><tr><td>Lock lifecycle trace</td><td style=text-align:right>샘플링 trace</td><td>RCA(근본원인분석)</td></tr><tr><td>Slow-lock traces</td><td style=text-align:right>on-demand 캡처</td><td>QOE 개선</td></tr></tbody></table><ul><li>요약: 문제 해결에 쓰이는 포렌식 데이터로, 비용 대비 효과를 고려하여 수집해야 한다.</li></ul><h6 id=예측보고-지표-전략용>예측·보고 지표 (전략용)<a hidden class=anchor aria-hidden=true href=#예측보고-지표-전략용>#</a></h6><ul><li><strong>무엇</strong>: 트렌드 (일·주·월 단위), 시즌성 분석, 용량 도달 예측.</li><li><strong>왜</strong>: 용량·인프라 확장 시기 판단, 피크 대비 사전 대응.</li><li><strong>어떻게</strong>: 시계열 분석 (rolling avg, linear/exponential trend), 시즌성 분해, simple forecasting.</li><li><strong>운영 팁</strong>: 비즈니스 캘린더 (프로모션, 월말 처리 등) 를 메타데이터로 연계.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>활용</th></tr></thead><tbody><tr><td>Trend / Seasonality</td><td style=text-align:right>시계열 집계</td><td>용량 계획</td></tr><tr><td>Forecasted breach time</td><td style=text-align:right>모델 기반 예측</td><td>사전 스케일 아웃</td></tr></tbody></table><ul><li>요약: 단기 대응을 넘어 중장기 전략 (인프라·설계 개선) 을 결정하는 근거를 제공.</li></ul><h5 id=락-관측성-종합-지표>락 관측성 종합 지표<a hidden class=anchor aria-hidden=true href=#락-관측성-종합-지표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 지표 (예)</th><th style=text-align:right>수집 수단</th><th>즉시 대응/활용</th></tr></thead><tbody><tr><td>운영 KPI</td><td>P95/P99 Lock Wait, Contention Rate, Blocked Sessions</td><td style=text-align:right>DB view → exporter → Prometheus/Grafana</td><td>알람 → 캡처 쿼리 → 우선 조사</td></tr><tr><td>안정성</td><td>Deadlock count, resolution time, escalation events</td><td style=text-align:right>DB deadlock log, events</td><td>RCA → 쿼리/인덱스/정책 수정</td></tr><tr><td>자원/용량</td><td>Lock table memory, queue length, throughput</td><td style=text-align:right>OS/DB metrics, snapshots</td><td>용량 증설·샤딩·임계값 조정</td></tr><tr><td>진단/추적</td><td>Lock lifecycle traces, slow-lock traces</td><td style=text-align:right>샘플링 trace, distributed tracing</td><td>상세 RCA, 히트맵 분석</td></tr><tr><td>예측/보고</td><td>Trend, forecasted breach time</td><td style=text-align:right>시계열 분석, BI 리포트</td><td>장기 용량/스케줄 계획</td></tr></tbody></table><h4 id=62-보안-및-컴플라이언스>6.2 보안 및 컴플라이언스<a hidden class=anchor aria-hidden=true href=#62-보안-및-컴플라이언스>#</a></h4><p>락 보안·컴플라이언스는 <strong>누가</strong>, <strong>언제</strong>, <strong>왜</strong> 락을 얻는지 완전·불변하게 기록하고, 락 요청을 하는 주체의 신원을 엄격히 확인하며, 분산 환경에서 락 안전성을 보장하는 것이 핵심이다.<br>이를 위해 최소 권한 (RBAC), 인증·세션 검증, 암호화, 무결성 보장된 감사 로그 (WORM/서명), 펜싱 토큰 기반 분산 락, SIEM 연동과 규제별 보존·접근 정책을 결합해 운영하면 규제 요구와 보안 위협을 모두 충족할 수 있다.</p><h5 id=락-보안컴플라이언스-구현-가이드>락 보안·컴플라이언스 구현 가이드<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-구현-가이드>#</a></h5><table><thead><tr><th>항목</th><th>무엇을 (조치)</th><th>왜 (목적)</th><th>어떻게 (구현/충족 방식)</th></tr></thead><tbody><tr><td>권한 최소화 (RBAC)</td><td>최소 권한 원칙 적용</td><td>불법/오남용 최소화</td><td>객체 레벨 권한, 관리자 역할 분리, 세션 권한 제한</td></tr><tr><td>인증·세션 검증</td><td>모든 락 요청의 신원 확인</td><td>무허가 요청 차단</td><td>강한 인증 (MFA), 서비스 계정 키 관리, 토큰 만료/재검증</td></tr><tr><td>감사 로깅 (무결성)</td><td>모든 락/타임아웃/교착 이벤트 기록</td><td>포렌식·규제 준수</td><td>서명 (HMAC/署名), WORM 스토리지, 해시체인, 보존정책</td></tr><tr><td>로그 마스킹·접근통제</td><td>민감정보 노출 방지</td><td>개인정보법·규제 준수</td><td>로그 필터링/마스킹, 감사 로그 접근 권한 제한</td></tr><tr><td>분산 락 안전성</td><td>펜싱 토큰·lease 사용</td><td>리더 전환시 중복 작업 방지</td><td>lease+token 검증, quorum 기반 코디네이터 (etcd/ZK)</td></tr><tr><td>네트워크·인프라 보안</td><td>락 서비스 보호</td><td>MITM/재생공격 방지</td><td>TLS, mutual TLS, 네트워크 분리, 방화벽</td></tr><tr><td>모니터링·SIEM 연동</td><td>이상 징후 탐지/상관분석</td><td>신속 탐지·대응</td><td>Prometheus/Grafana + SIEM 연계, 알람/플레이북</td></tr><tr><td>규제별 매핑</td><td>PCI/HIPAA/GDPR/SOX 요구 충족</td><td>법적·계약적 요구 이행</td><td>보존기간·접근감사·암호화 정책 문서화·테스트</td></tr><tr><td>제로 트러스트 적용</td><td>지속적 권한 검증</td><td>내부 위협 최소화</td><td>요청 컨텍스트 (세션, IP, 시간) 기반 재검증</td></tr><tr><td>운영 플레이북</td><td>사고 시 대응 절차</td><td>RTO/RPO 보장</td><td>자동 롤백·락 클리어 스크립트, 복구 체크리스트</td></tr></tbody></table><h5 id=락-보안컴플라이언스-카테고리>락 보안·컴플라이언스 카테고리<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-카테고리>#</a></h5><h6 id=인증권한관리-authentication--authorization>인증·권한관리 (Authentication & Authorization)<a hidden class=anchor aria-hidden=true href=#인증권한관리-authentication--authorization>#</a></h6><ul><li><p>설명: 락 요청 주체 (유저/서비스) 의 신원 검증과 자원 접근 권한 통제.</p></li><li><p>문제: 무권한 락 요청 → 데이터 오남용/권한 상승 위험.</p></li><li><p>원인: 느슨한 인증, 광범위한 관리자 권한, 세션 재사용.</p></li><li><p>해결책:</p><ul><li>강한 인증 (MFA for admin, mutual-TLS for services)</li><li>RBAC/ABAC 로 객체 레벨 권한 부여</li><li>관리자 작업은 별도 승인·감사 워크플로우</li></ul></li><li><p>예시 (악례): 모든 앱이 DB 마스터 계정으로 락 요청</p></li><li><p>예시 (개선): 서비스별 최소 권한 DB 계정 + 역할 기반 권한, 세션 토큰 만료 (짧게)</p></li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>인증</td><td>공용 DB 계정 사용</td><td>서비스별 계정 + mutual-TLS</td></tr><tr><td>권한</td><td>관리자 권한 포괄 부여</td><td>객체 단위 RBAC, 최소권한</td></tr><tr><td>세션</td><td>긴 만료시간</td><td>짧은 TTL + 재인증</td></tr></tbody></table><ul><li>요약: 모든 락 요청은 <strong>인증·권한 검증</strong>을 통과해야 하며, 관리자 권한은 분리·감사 대상화 해야 한다.</li></ul><h6 id=감사로그-무결성-audit--log-integrity>감사·로그 무결성 (Audit & Log Integrity)<a hidden class=anchor aria-hidden=true href=#감사로그-무결성-audit--log-integrity>#</a></h6><ul><li><p>설명: 락 활동 (요청·승인·거절·타임아웃·해제) 을 변조 불가능하게 기록.</p></li><li><p>문제: 로그 변조 시 포렌식·증빙 무력화.</p></li><li><p>원인: 단순 파일 로그, 접근 제어 미흡, 보존 정책 부재.</p></li><li><p>해결책:</p><ul><li>로그 서명 (HMAC/디지털 서명) 또는 해시체인 저장</li><li>WORM/Append-only 스토리지 (장기 보존)</li><li>감사 로그 접근권한 분리, 정기 무결성 검사</li></ul></li><li><p>예시 (악례): 운영자가 로그를 직접 편집 가능</p></li><li><p>예시 (개선): 로그 ingest 시 HMAC 생성 → 원본은 WORM 에 보관, SIEM 으로 복사</p></li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>저장</td><td>일반 파일시스템</td><td>WORM / 오브젝트 스토리지 버전링</td></tr><tr><td>무결성</td><td>미검증 로그</td><td>HMAC/디지털 서명 + 정기검증</td></tr><tr><td>접근</td><td>운영자 직접 접근</td><td>로그 전용 읽기권한, 감사추적</td></tr></tbody></table><ul><li>요약: <strong>감사 로그는 증거</strong>다—무결성·접근통제·보존을 설계해야 한다.</li></ul><h6 id=데이터-보호-encryption--masking>데이터 보호 (Encryption & Masking)<a hidden class=anchor aria-hidden=true href=#데이터-보호-encryption--masking>#</a></h6><ul><li><p>설명: 락 관련 메타데이터·감사 로그·전송 데이터를 보호.</p></li><li><p>문제: 로그/메타데이터에 민감정보 노출, 전송 중 도청.</p></li><li><p>원인: 평문 로그, 미암호화 통신.</p></li><li><p>해결책:</p><ul><li>전송 TLS 적용 (서비스 간 mTLS)</li><li>저장 암호화 (디스크/오브젝트 암호화)</li><li>로그 마스킹·필터링으로 PII 제거</li></ul></li><li><p>예시 (악례): 감사로그에 사용자 전체 PAN 포함</p></li><li><p>예시 (개선): 감사 로그는 PAN 마스킹, 이벤트에는 페이로드 해시만 저장</p></li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>전송</td><td>평문 RPC/HTTP</td><td>TLS / mTLS</td></tr><tr><td>저장</td><td>평문 로그</td><td>at-rest 암호화</td></tr><tr><td>민감데이터</td><td>원문 로깅</td><td>마스킹/토큰화</td></tr></tbody></table><ul><li>요약: 감사 로그·메타데이터도 <strong>데이터</strong>다—암호화·마스킹 정책을 적용하라.</li></ul><h6 id=분산-락-안전성-distributed-lock-hardening>분산 락 안전성 (Distributed Lock Hardening)<a hidden class=anchor aria-hidden=true href=#분산-락-안전성-distributed-lock-hardening>#</a></h6><ul><li><p>설명: 분산 락을 안전하게 운영하기 위한 설계 (펜싱, lease, 합의).</p></li><li><p>문제: 리더 교체·파티션 상황에서 중복 실행 또는 잠긴 상태 장기화.</p></li><li><p>원인: 단일 노드 락, TTL 부정확, 클럭 의존성.</p></li><li><p>해결책:</p><ul><li>lease + token(펜싱 토큰) 방식: 락 보유자는 고유 토큰을 소유 → IO 연산 시 토큰 검증</li><li>quorum 기반 서비스 (etcd/ZK) 로 락 구현</li><li>클럭 문제에는 HLC/TrueTime 또는 펜싱으로 보완</li></ul></li><li><p>예시 (악례): Redis SETNX + 만료시간 없이 락 구현</p></li><li><p>예시 (개선): etcd lease with TTL + token, 작업 시 token 확인 후 수행</p></li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>코디네이터</td><td>단일 Redis 인스턴스</td><td>etcd/ZK quorum</td></tr><tr><td>안전성</td><td>TTL 미검증</td><td>lease + token + 검증</td></tr><tr><td>클럭</td><td>로컬 타임스탬프 의존</td><td>HLC/펜싱 토큰</td></tr></tbody></table><ul><li>요약: 분산 락은 <strong>합의·펜싱·멱등</strong>을 결합해야 안전하다.</li></ul><h6 id=운영탐지대응-monitoring-siem--playbooks>운영·탐지·대응 (Monitoring, SIEM & Playbooks)<a hidden class=anchor aria-hidden=true href=#운영탐지대응-monitoring-siem--playbooks>#</a></h6><ul><li><p>설명: 락 이상징후 (장수 락·에스컬레이션·deadlock 폭증) 을 실시간 탐지·대응.</p></li><li><p>문제: 징후 미포착 → 장애 확산·긴 복구시간.</p></li><li><p>원인: 지표 미수집, 알람 부재, 플레이북 미정비.</p></li><li><p>해결책:</p><ul><li>핵심 지표 수집: lock_wait_time, deadlock_count, long_lock_sessions, escalation_events</li><li>SIEM 연동으로 상관분석 (권한 변화 + 락 이벤트)</li><li>자동화된 플레이북 (예: 특정 임계치 시 자동 희생자 롤백/슬로우 쿼리 중단)</li></ul></li><li><p>예시 (악례): 문제 발생 시 사람 수동 개입만 의존</p></li><li><p>예시 (개선): Grafana 알람 → 자동 스크립트로 오래된 트랜잭션 정리 → 팀 알림</p></li></ul><table><thead><tr><th>항목</th><th>악례</th><th>개선</th></tr></thead><tbody><tr><td>지표</td><td>lock_waits 미수집</td><td>Prometheus 수집 + Grafana 알람</td></tr><tr><td>상관분석</td><td>로그 고립</td><td>SIEM 연계 (사용자·권한·락 이벤트)</td></tr><tr><td>대응</td><td>수동</td><td>자동 플레이북 + Runbook</td></tr></tbody></table><ul><li>요약: 관찰 가능성 (Observability) 과 자동화가 사고 시간 단축의 핵심이다.</li></ul><h6 id=규제-매핑보존-regulatory-mapping--retention>규제 매핑·보존 (Regulatory Mapping & Retention)<a hidden class=anchor aria-hidden=true href=#규제-매핑보존-regulatory-mapping--retention>#</a></h6><ul><li><p>설명: PCI/HIPAA/GDPR/SOX 등 규제 요구사항 충족 (보존기간·접근통제·감사 가능성).</p></li><li><p>문제: 규정 미충족 시 법적·금융적 제재.</p></li><li><p>원인: 로그 보존·암호화·접근통제 정책 부재.</p></li><li><p>해결책 (예시별):</p><ul><li><strong>PCI-DSS</strong>: 민감 카드 데이터 비로그/마스킹, 강한 접근 통제, 로그 무결성 보관</li><li><strong>HIPAA</strong>: 환자 데이터 접근 감사, 최소 권한, 로그 보존 및 접근 기록</li><li><strong>GDPR</strong>: 최소 데이터 저장, 개인정보 접근 요청·삭제 (권리) 프로세스 반영—감사로그에 PII 포함 시 정책 반영</li><li><strong>SOX</strong>: 재무 트랜잭션 감사로그·무결성 보관, 변경 통제 증빙</li></ul></li><li><p>예시 (개선): 규제별 보존 정책 문서화 → 자동 보존/삭제 파이프라인 및 감사 리포트</p></li></ul><table><thead><tr><th>규제</th><th>핵심 요구</th><th>구현 포인트</th></tr></thead><tbody><tr><td>PCI</td><td>PAN 보호·로그 무결성</td><td>마스킹, 서명된 로그, 접근 통제</td></tr><tr><td>HIPAA</td><td>환자 접근 기록</td><td>상세 감사, 최소권한</td></tr><tr><td>GDPR</td><td>데이터 주체 권리</td><td>PII 최소화, 접근·삭제 로그</td></tr><tr><td>SOX</td><td>재무 무결성</td><td>장기 보관·변경 이력</td></tr></tbody></table><ul><li>요약: 규제별 요구는 서로 다르므로 <strong>정책 문서화 → 자동화 → 검증 (감사)</strong> 순서로 구현하라.</li></ul><h5 id=락-보안컴플라이언스-통합표>락 보안·컴플라이언스 통합표<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 조치</th><th>왜 필요한가</th><th>주요 구현 기술/예시</th></tr></thead><tbody><tr><td>인증·권한관리</td><td>RBAC, mTLS, 세션 TTL</td><td>무권한 접근 차단</td><td>RBAC, OAuth2, mutual-TLS</td></tr><tr><td>감사·무결성</td><td>서명·WORM 보관</td><td>증거보존·포렌식</td><td>HMAC/디지털 서명, WORM</td></tr><tr><td>데이터 보호</td><td>TLS, at-rest 암호화, 마스킹</td><td>PII/민감정보 보호</td><td>TLS, KMS, 토큰화</td></tr><tr><td>분산 락</td><td>lease+token, quorum 코디네이터</td><td>리더 교체 안전성</td><td>etcd/ZK, Redlock(주의)</td></tr><tr><td>운영·탐지</td><td>지표·SIEM·플레이북</td><td>조기탐지·자동복구</td><td>Prometheus, SIEM, Playbooks</td></tr><tr><td>규제 매핑</td><td>보존·접근 정책</td><td>법적 요구 충족</td><td>정책 문서화 · 자동화 파이프라인</td></tr></tbody></table><h4 id=락-성능확장성-종합-최적화-전략>락 성능·확장성 종합 최적화 전략<a hidden class=anchor aria-hidden=true href=#락-성능확장성-종합-최적화-전략>#</a></h4><ul><li><p><strong>문제</strong>: 락 시스템은 동시성 제어의 심장인데, 락 자체가 병목이 되면 시스템 전체가 느려진다.</p></li><li><p><strong>해법 (큰 그림)</strong>:</p><ol><li><strong>락을 빨리 주고 빨리 반납</strong>—짧은 트랜잭션, 청크화</li><li><strong>락 관리 비용 줄이기</strong>—락 풀링, 효율적 자료구조</li><li><strong>핫스팟 분산</strong>—파티셔닝/샤딩으로 락을 분산</li><li><strong>우선순위로 중요한 일 먼저</strong>—SLA 지키기 위해 priority 적용</li><li><strong>측정→개선→검증 반복</strong>—프로파일링과 벤치마크 필수</li></ol></li></ul><h5 id=락-성능확장성-최적화-기법-비교>락 성능·확장성 최적화 기법 비교<a hidden class=anchor aria-hidden=true href=#락-성능확장성-최적화-기법-비교>#</a></h5><table><thead><tr><th>분류</th><th>기법(무엇)</th><th>목적(왜)</th><th>적용 방식(어떻게)</th><th>주요 지표</th></tr></thead><tbody><tr><td>락 관리</td><td>락 풀링</td><td>GC/할당 오버헤드 감소</td><td>스레드 로컬 + 중앙 풀, 재활용 정책</td><td>pool hit rate, alloc latency</td></tr><tr><td>락 관리</td><td>적응형 에스컬레이션</td><td>메모리 절감 vs 동시성 균형</td><td>시스템부하 기반 임계값 조정</td><td>escalation count, lock wait</td></tr><tr><td>알고리즘</td><td>해시 락 테이블</td><td>O(1) 평균 검색</td><td>버킷화, 부분 락, 리사이징 전략</td><td>lookup latency, collision rate</td></tr><tr><td>알고리즘</td><td>우선순위 스케줄링</td><td>SLA 보장, 기아 방지</td><td>priority + aging, SLA tagging</td><td>p99 latency by priority</td></tr><tr><td>확장성(수평)</td><td>락 파티셔닝</td><td>중앙 병목 분산</td><td>샤딩/키 파티셔닝, 가벼운 글로벌 coord</td><td>throughput per shard</td></tr><tr><td>확장성(수직)</td><td>NUMA/멀티코어 최적화</td><td>하드웨어 활용 극대화</td><td>로컬 락 테이블, 캐시친화 구조</td><td>CPU utilization, cache miss</td></tr></tbody></table><h5 id=락-최적화-관리알고리즘확장>락 최적화: 관리·알고리즘·확장<a hidden class=anchor aria-hidden=true href=#락-최적화-관리알고리즘확장>#</a></h5><h6 id=락-관리풀링에스컬레이션모니터링>락 관리(풀링·에스컬레이션·모니터링)<a hidden class=anchor aria-hidden=true href=#락-관리풀링에스컬레이션모니터링>#</a></h6><ul><li><strong>내용</strong>: 락 객체의 생성/파괴 비용을 줄이려면 락 풀링을 도입하고, 시스템 부하에 따라 락 승격 임계값을 동적으로 조정한다. 운영적으로는 pool hit rate, lock wait latency, escalation count 등을 모니터링해 피드백 루프를 돌린다. 실패 상황(풀 고갈, 오탐 상승) 에 대비한 안전 모드(수동 복귀) 필요.</li><li><strong>적용 팁</strong>: 스레드- 로컬 캐시 + 중앙 풀 조합, 풀 사이즈는 프로파일 기반 결정, GC 트레드 영향 모니터링.</li></ul><table><thead><tr><th>항목</th><th>조치</th><th>지표</th></tr></thead><tbody><tr><td>락 풀링</td><td>스레드 로컬 + 중앙 풀 적용</td><td>pool hit rate, alloc latency</td></tr><tr><td>에스컬레이션</td><td>동적 임계값, 부하 센서 연동</td><td>escalation count, lock wait</td></tr></tbody></table><ul><li>핵심 요약: 락 관리 최적화는 <strong>오버헤드 절감 → 응답성 개선</strong>에 직접 연결된다. 모니터링과 안전 장치가 필수다.</li></ul><h6 id=알고리즘자료구조해시-테이블우선순위-스케줄링>알고리즘·자료구조(해시 테이블·우선순위 스케줄링)<a hidden class=anchor aria-hidden=true href=#알고리즘자료구조해시-테이블우선순위-스케줄링>#</a></h6><ul><li><strong>내용</strong>: 락 검색/할당·해제 경로가 핵심 병목이면 해시 기반 락 테이블이나 캐시친화적 자료구조를 도입해 평균 조회 시간을 줄인다. 중요 트랜잭션을 위해 우선순위 스케줄링을 적용하되 aging 을 도입해 기아 방지.</li><li><strong>적용 팁</strong>: 버킷별 락(부분락) 으로 경쟁 완화, 리사이징은 비용이 크므로 점진적 리사이징 채택. priority 라벨링 정책은 SLA 연동.</li></ul><table><thead><tr><th>항목</th><th>조치</th><th>지표</th></tr></thead><tbody><tr><td>해시 락 테이블</td><td>버킷화 + 부분락 적용</td><td>lookup latency, collision rate</td></tr><tr><td>우선순위 스케줄링</td><td>SLA 기반 priority + aging</td><td>p99 latency by priority</td></tr></tbody></table><ul><li>핵심 요약: 올바른 자료구조와 스케줄링은 <strong>핫스팟 완화·SLA 보장</strong>에 결정적이다.</li></ul><h6 id=확장성-아키텍처수평수직파티셔닝>확장성 아키텍처(수평/수직·파티셔닝)<a hidden class=anchor aria-hidden=true href=#확장성-아키텍처수평수직파티셔닝>#</a></h6><ul><li><strong>내용</strong>: 중앙 락 관리자가 병목이면 락 파티셔닝·샤딩으로 수평 확장한다. 하드웨어 한계시 NUMA/멀티코어 최적화로 성능을 더 끌어낼 수 있다. 글로벌 락이 필요한 작업은 경량 조정 프로토콜(예: 펜싱 토큰) 으로 처리.</li><li><strong>적용 팁</strong>: 파티셔닝 키는 접근 패턴 기반으로 설계, 리밸런싱 전략 준비, 글로벌 락 작업은 흔치 않게 설계.</li></ul><table><thead><tr><th>항목</th><th>조치</th><th>지표</th></tr></thead><tbody><tr><td>락 파티셔닝</td><td>샤드별 락 관리자 분리</td><td>throughput per shard</td></tr><tr><td>NUMA 최적화</td><td>로컬 메모리 우선 배치</td><td>cache miss, memory latency</td></tr></tbody></table><ul><li>핵심 요약: 확장성 전략은 <strong>병목 제거</strong>가 목표지만 글로벌 일관성 요구 시 추가 비용이 발생하므로 설계상의 트레이드오프가 필요하다.<br>`</li></ul><h5 id=락-최적화-종합-체크리스트>락 최적화 종합 체크리스트<a hidden class=anchor aria-hidden=true href=#락-최적화-종합-체크리스트>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 기법</th><th>목적</th><th>적용 시 고려사항</th><th>우선 측정 지표</th></tr></thead><tbody><tr><td>락 관리</td><td>락 풀링, 적응형 에스컬레이션</td><td>오버헤드 감소, 빠른 응답</td><td>풀 고갈 안전모드, 임계값 오탐</td><td>pool hit, alloc latency</td></tr><tr><td>알고리즘</td><td>해시 테이블, 우선순위 스케줄링</td><td>lookup 속도↑, SLA 보장</td><td>리사이징 비용, 기아 방지</td><td>lookup latency, p99 by priority</td></tr><tr><td>확장성</td><td>파티셔닝, NUMA 최적화</td><td>병목 분산, 리소스 활용</td><td>리밸런싱 비용, 글로벌 락 비용</td><td>throughput/shard, cache miss</td></tr></tbody></table><h4 id=락-트러블슈팅-및-운영-전략>락 트러블슈팅 및 운영 전략<a hidden class=anchor aria-hidden=true href=#락-트러블슈팅-및-운영-전략>#</a></h4><p>락 관련 성능/가용성 문제가 나오면 먼저 <strong>증상 (예: TPS↓, latency↑, deadlock 늘어남)</strong> 을 수집하고, <strong>잠금 대기 현황 (pg_locks/INNODB_TRX)</strong> 과 <strong>실행계획 (EXPLAIN)</strong> 을 확인하라.<br>임시로는 <code>SKIP LOCKED</code>·타임아웃·강제 종료로 정상화를 시도하고, 근본적으로는 <strong>인덱스 최적화, 쿼리 리팩터링, 트랜잭션 짧게 유지, 데이터 파티셔닝, 일관된 락 순서</strong>를 적용해 재발을 막아라.<br>운영 자동화 (탐지→알람→자동 반응) 와 사후 원인분석이 중요하다.</p><h5 id=왜-문제가-발생하는가-근본-원인>왜 문제가 발생하는가 (근본 원인)<a hidden class=anchor aria-hidden=true href=#왜-문제가-발생하는가-근본-원인>#</a></h5><ul><li><strong>풀 스캔·범위 업데이트</strong>: 인덱스 미사용 → 많은 행 잠김.</li><li><strong>업데이트 순서 역전</strong>: 트랜잭션 A 가 R1→R2, B 가 R2→R1 접근 시 순환 대기.</li><li><strong>긴 트랜잭션</strong>: 락 유지 시간 증가 → 대기 누적·GC/리소스 문제.</li><li><strong>에스컬레이션 임계값 부적절</strong>: 행 락이 테이블 락으로 과도 전환.</li><li><strong>열악한 쿼리/인덱스 설계</strong>: 범위가 넓은 WHERE, ORDER BY 미최적화.</li></ul><h5 id=무엇으로-해결하는가-대응-카테고리>무엇으로 해결하는가 (대응 카테고리)<a hidden class=anchor aria-hidden=true href=#무엇으로-해결하는가-대응-카테고리>#</a></h5><ul><li><strong>긴급 완화 (Immediate)</strong>: SKIP LOCKED / NOWAIT / 타임아웃 재시도 / 강제 트랜잭션 종료</li><li><strong>근본 개선 (Root fix)</strong>: 인덱스 추가, 쿼리 리팩터링, 일관된 업데이트 순서, 파티셔닝, 배치 처리</li><li><strong>운영·자동화 (Policy)</strong>: deadlock 자동탐지 +victim 정책, 모니터링 알람, 재시도 백오프 전략</li><li><strong>설계 대안 (Architecture)</strong>: 낙관적 락/버전 필드, 큐잉 (메시지), Saga 로 긴 트랜잭션 분해</li></ul><blockquote><ul><li><code>NOWAIT</code>: 즉시 락을 획득하지 못하면 <strong>에러를 반환 (대기하지 않음)</strong>.></li><li><code>SKIP LOCKED</code>: 즉시 락을 획득하지 못하는 <strong>행은 건너뛰고</strong>(skip) 다음 행을 처리함—주로 <strong>멀티 - 컨슈머 작업 큐</strong>에 유용.</li></ul></blockquote><h5 id=어떻게-검증하는가-검증-절차>어떻게 검증하는가 (검증 절차)<a hidden class=anchor aria-hidden=true href=#어떻게-검증하는가-검증-절차>#</a></h5><ul><li>문제 발생 전/후 지표 비교 (TPS, avg latency, lock wait time)</li><li>재현 테스트 (부하 테스트 시나리오) 및 회귀검증</li><li>로그·deadlock trace 분석으로 희생자/원인 패턴 확인</li></ul><h5 id=락-트러블슈팅-핵심-매뉴얼>락 트러블슈팅 핵심 매뉴얼<a hidden class=anchor aria-hidden=true href=#락-트러블슈팅-핵심-매뉴얼>#</a></h5><table><thead><tr><th>증상</th><th>대표 원인</th><th style=text-align:right>즉시 조치</th><th>근본 해결</th><th>검증 방법</th></tr></thead><tbody><tr><td>TPS 급락 + 대기 급증</td><td>풀스캔 / 범위 업데이트 (광범위 락)</td><td style=text-align:right>인덱스 추가, SKIP LOCKED, 트래픽 셰이핑</td><td>쿼리 리팩터링, 파티셔닝, 배치 업데이트</td><td>EXPLAIN, TPS/latency 차트</td></tr><tr><td>데드락 빈발</td><td>업데이트 순서 역전, 교착 사이클</td><td style=text-align:right>자동 deadlock killer 또는 수동 롤백</td><td>일관된 컬럼 순서 적용, 재시도 로직</td><td>deadlock 로그, wait-for 그래프</td></tr><tr><td>락 에스컬레이션 빈번</td><td>많은 행 락 → 테이블 락</td><td style=text-align:right>에스컬레이션 임계값 증가, 메모리 임시 확장</td><td>트랜잭션 크기 축소, 임계값 재설정</td><td>escalation 빈도 변화 모니터링</td></tr><tr><td>긴 트랜잭션 지속</td><td>장시간 사용자 대기/배치</td><td style=text-align:right>타임아웃·알림, 강제 종료</td><td>트랜잭션 분해, 비동기 처리</td><td>long-running tx 수 감소 확인</td></tr><tr><td>반복 재시도 폭주</td><td>낙관적 충돌→재시도 루프</td><td style=text-align:right>재시도 백오프, 큐잉</td><td>핫키 분산, 서버 측 직렬화</td><td>재시도 횟수 / 성공률</td></tr></tbody></table><h5 id=락-문제-대응-카테고리>락 문제 대응 카테고리<a hidden class=anchor aria-hidden=true href=#락-문제-대응-카테고리>#</a></h5><h6 id=탐지모니터링-detect>탐지·모니터링 (Detect)<a hidden class=anchor aria-hidden=true href=#탐지모니터링-detect>#</a></h6><ul><li>핵심: 빠른 탐지 없이는 문제 확대. 핵심 지표를 실시간 수집.</li><li>모니터링 항목: lock wait time, active locks, deadlock count, long-running tx, avg wait queue length, escalation rate</li><li>진단 쿼리 (예시):<ul><li>Postgres: SELECT * FROM pg_locks JOIN pg_stat_activity …; SELECT pg_blocking_pids(pid);</li><li>MySQL: SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</li></ul></li><li>도구: Grafana(메트릭), ELK(로그), Deadlock 파서</li></ul><table><thead><tr><th>항목</th><th>목적</th><th>쿼리/지표</th><th>알람 임계값 예시</th></tr></thead><tbody><tr><td>lock wait time</td><td>대기 문제 감지</td><td>avg(lock_wait_ms)</td><td>>200ms (경고)</td></tr><tr><td>deadlock count</td><td>안정성 위협</td><td>deadlock/s</td><td>>1/day (경고)</td></tr><tr><td>long-running tx</td><td>원인 후보</td><td>tx runtime > X</td><td>>30s (경고)</td></tr></tbody></table><ul><li>요약: 탐지는 문제 해결의 시작점이며, 신속한 알람과 원인 추적 쿼리가 필수.</li></ul><h6 id=즉시-완화-immediate-mitigation>즉시 완화 (Immediate Mitigation)<a hidden class=anchor aria-hidden=true href=#즉시-완화-immediate-mitigation>#</a></h6><ul><li>핵심: 서비스 복구 우선, 근본 수정은 추후.</li><li>즉시 수단: SKIP LOCKED, NOWAIT, SET lock_timeout, 강제 트랜잭션 종료, 트래픽 차단 (셰이핑)</li><li>운영 체크: 임시 조치 후 반드시 원인분석 수행</li></ul><table><thead><tr><th>증상</th><th>즉시 조치</th><th>주의점</th></tr></thead><tbody><tr><td>TPS 급락</td><td>SKIP LOCKED, 트래픽 셰이핑</td><td>데이터 누락 가능성 점검</td></tr><tr><td>데드락 발생</td><td>자동 deadlock killer</td><td>희생자 영향 범위 확인</td></tr><tr><td>긴 트랜잭션</td><td>강제 종료 (관리자)</td><td>복구/보상 절차 필요</td></tr></tbody></table><ul><li>요약: 즉시 완화는 고객 영향 최소화 목적이며, 근본 해결과 로그 남기기가 필수.</li></ul><h6 id=근본-개선-root-cause-fixes>근본 개선 (Root-cause Fixes)<a hidden class=anchor aria-hidden=true href=#근본-개선-root-cause-fixes>#</a></h6><ul><li>핵심: 재발 방지용 구조/코드 수정</li><li>방법: 인덱스 추가, 쿼리 리팩토링, 일관된 업데이트 순서, 파티셔닝, 작업 배치화, 낙관적 락 도입</li><li>검증: 부하 테스트, A/B 배포</li></ul><table><thead><tr><th>원인</th><th>근본조치</th><th>기대효과</th></tr></thead><tbody><tr><td>풀스캔</td><td>적절한 인덱스 추가</td><td>lock 범위 축소, 응답속도 개선</td></tr><tr><td>업데이트 순서 불일치</td><td>코드 표준화 (순서)</td><td>데드락 감소</td></tr><tr><td>긴 트랜잭션</td><td>트랜잭션 분해</td><td>대기시간 감소</td></tr></tbody></table><ul><li>요약: 근본 개선은 리스크·비용이 크지만 가장 효과적인 장기 대책.</li></ul><h6 id=예방정책-preventive-measures>예방·정책 (Preventive Measures)<a hidden class=anchor aria-hidden=true href=#예방정책-preventive-measures>#</a></h6><ul><li>핵심: 설계·개발·테스트 단계에서 문제를 미리 막음</li><li>정책: 트랜잭션 짧게 유지, 일관된 락 순서, 테스트 케이스 (동시성), 코드 리뷰 체크리스트</li><li>자동화: deadlock 자동복구 정책, 재시도 백오프 등</li></ul><table><thead><tr><th>정책</th><th>목적</th><th>구현 팁</th></tr></thead><tbody><tr><td>일관된 락 순서</td><td>데드락 방지</td><td>DB 접근 순서 표준화</td></tr><tr><td>재시도 정책</td><td>transient 오류 완화</td><td>지수 백오프, 최대 재시도 횟수</td></tr><tr><td>동시성 테스트</td><td>회귀 방지</td><td>Chaos/가상 동시성 스크립트</td></tr></tbody></table><ul><li>요약: 예방은 운영 비용을 줄이는 최선의 방법.</li></ul><h6 id=운영검증-runbook--validation>운영·검증 (Runbook & Validation)<a hidden class=anchor aria-hidden=true href=#운영검증-runbook--validation>#</a></h6><ul><li>핵심: 사고 시 반복 가능한 대응 절차와 검증 루틴</li><li>포함 항목: 탐지 절차, 임시 조치 명령, 근본 조치 배포 절차, 사후분석 템플릿</li><li>예시: deadlock 발생시 Runbook 절차 (탐지→로그추출→롤백→원인분석→패치)</li></ul><table><thead><tr><th>절차 단계</th><th>작업</th><th>담당 역할</th></tr></thead><tbody><tr><td>탐지</td><td>알람 수신, 영향 범위 판정</td><td>SRE/DBA</td></tr><tr><td>완화</td><td>트랜잭션 강제 종료, 트래픽 제어</td><td>SRE</td></tr><tr><td>근본조치</td><td>코드/쿼리 패치</td><td>개발팀</td></tr><tr><td>검증</td><td>부하/회귀 테스트</td><td>QA</td></tr></tbody></table><ul><li>요약: Runbook 은 자동화와 숙련된 대응을 결합해 MTTR 단축.</li></ul><h5 id=락-문제-대응-요약표>락 문제 대응 요약표<a hidden class=anchor aria-hidden=true href=#락-문제-대응-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>목적</th><th>핵심 액션</th><th>대표 지표</th></tr></thead><tbody><tr><td>탐지·모니터링</td><td>문제 조기 포착</td><td>pg_locks, INNODB_TRX, deadlock log</td><td>lock wait time, deadlock rate</td></tr><tr><td>즉시 완화</td><td>서비스 복구</td><td>SKIP LOCKED, NOWAIT, 강제 종료</td><td>TPS 회복 시간</td></tr><tr><td>근본 개선</td><td>재발 방지</td><td>인덱스, 쿼리 리팩터, 파티셔닝</td><td>핫스팟 감소율</td></tr><tr><td>예방·정책</td><td>설계 단계 방지</td><td>표준화 (락 순서), 동시성 테스트</td><td>regression pass rate</td></tr><tr><td>운영·검증</td><td>절차·자동화</td><td>Runbook, 자동탐지·대응</td><td>MTTR, manual steps 수</td></tr></tbody></table><h3 id=고급-주제-및-미래-전망>고급 주제 및 미래 전망<a hidden class=anchor aria-hidden=true href=#고급-주제-및-미래-전망>#</a></h3><h4 id=락의-당면-과제-분산운영확장성>락의 당면 과제: 분산·운영·확장성<a hidden class=anchor aria-hidden=true href=#락의-당면-과제-분산운영확장성>#</a></h4><p>분산·클라우드 시대의 핵심 문제는 <strong>동시에 여러 노드가 같은 자원에 접근할 때</strong> 발생한다는 점이다.<br>네트워크가 불안정하거나 노드가 떨어져 나가면 락 소유권과 타임아웃을 안전하게 결정하기 어려워 데이터 일관성이나 가용성이 깨어질 수 있다. 또한 시스템이 커질수록 락을 관리하는 메모리·CPU 비용이 급증하고, MVCC 같은 대안도 오래된 버전 정리 때문에 운영 부담이 생긴다.<br>그래서 분산 락은 단순 구현이 아니라 fencing·lease·consensus 같은 안전장치와 관측·테스트 체계를 함께 설계해야 한다.</p><h5 id=락의-현재-도전-과제와-한계>락의 현재 도전 과제와 한계<a hidden class=anchor aria-hidden=true href=#락의-현재-도전-과제와-한계>#</a></h5><table><thead><tr><th>도전 과제</th><th style=text-align:right>원인 (무엇 때문에)</th><th>영향 (무슨 문제가 발생)</th><th>왜 도전인가 (핵심 난점)</th></tr></thead><tbody><tr><td>글로벌 락 관리 복잡성</td><td style=text-align:right>네트워크 파티션·노드 장애·시계 불일치</td><td>전역 일관성 보장 어려움, 높은 지연</td><td>분산 환경에서 안전성과 가용성 간의 근본적 트레이드오프 (CAP)</td></tr><tr><td>네트워크 지연·부분 실패</td><td style=text-align:right>지리적 분포·변동 네트워크</td><td>타임아웃·데드락 탐지 지연, 불안정한 응답성</td><td>타이밍 기반 정책이 불안정해 적응형 정책 필요</td></tr><tr><td>컨테이너·오케스트레이션 통합</td><td style=text-align:right>동적 스케일링·이동성</td><td>락 상태 휘발성, 서비스 디스커버리 문제</td><td>상태 유지 락 서비스 설계와 오케스트레이션 정책 연동 어려움</td></tr><tr><td>멀티 클라우드 동기화</td><td style=text-align:right>벤더별 서비스 차이·네트워크 제약</td><td>클라우드 간 락 동기화 복잡</td><td>표준 부재 및 네트워크 레이턴시·보안 규제 문제</td></tr><tr><td>메모리 확장성 한계</td><td style=text-align:right>락 테이블 선형 증가·메모리 대역폭 한계</td><td>락 관리 비용 급증, 처리량 저하</td><td>대규모 락 수요에서 단일 노드 메모리 한계</td></tr><tr><td>CPU 확장성 한계</td><td style=text-align:right>캐시 미스·순차 부분 (직렬 경로)</td><td>멀티코어 성능 비선형 증가</td><td>락 알고리즘의 병목 제거가 어려움</td></tr><tr><td>MVCC/Garbage Collection 부담</td><td style=text-align:right>버전 누적·장기 트랜잭션</td><td>저장소 증가·GC 로 인한 지연/정지</td><td>안전한 GC 타이밍과 장기 트랜잭션 조정의 어려움</td></tr><tr><td>초고경합에서의 공정성 문제</td><td style=text-align:right>빈번한 동일 자원 접근</td><td>특정 트랜잭션 기아·처리량 저하</td><td>페어니스와 최대 처리량 동시 달성 난이도</td></tr></tbody></table><h5 id=락-도전-과제의-분류-체계>락 도전 과제의 분류 체계<a hidden class=anchor aria-hidden=true href=#락-도전-과제의-분류-체계>#</a></h5><h6 id=분산글로벌-일관성-문제>분산·글로벌 일관성 문제<a hidden class=anchor aria-hidden=true href=#분산글로벌-일관성-문제>#</a></h6><p>분산 환경에서는 네트워크 파티션·노드 장애·클럭 불일치가 핵심 원인이다.<br>이로 인해 전역 락 소유권을 안전하게 결정하기 어렵고, 단순 분산 락은 stale client 나 split-brain 을 초래할 수 있다. 해결은 합의 기반 (raft/paxos) 또는 lease+fencing 하이브리드, 지역 우선 로컬 락 설계로 이루어진다.<br>설계 시 응답성 (레이턴시) 과 일관성 (CONSISTENCY) 사이의 트레이드오프를 명확히 정의해야 한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>글로벌 락 관리</td><td style=text-align:right>파티션·클럭 불일치</td><td>stale writes, inconsistency</td><td>consensus + fencing, region-local locks</td></tr><tr><td>네트워크 지연</td><td style=text-align:right>지리적 레이턴시</td><td>타임아웃·데드락 지연</td><td>적응형 타임아웃, 모니터링</td></tr></tbody></table><ul><li>요약: 분산 락은 단순 중앙화 락으로는 안전하지 않다. 합의·펜싱·지역화 전략을 결합해 위험을 줄여야 한다.</li></ul><h6 id=클라우드-네이티브-운영-문제>클라우드 네이티브 운영 문제<a hidden class=anchor aria-hidden=true href=#클라우드-네이티브-운영-문제>#</a></h6><p>쿠버네티스 등 오케스트레이션 환경에서는 컨테이너 이동·스케일링으로 락 상태가 휘발되거나 서비스 디스커버리와 연동이 필요하다.<br>멀티 클라우드 환경은 벤더 간 API·네트워킹 차이로 락 동기화 복잡도를 키운다.<br>상태유지 서비스 (StatefulSet, operator) 또는 외부 코디네이터 (etcd/ZK) 의 안정적 배치가 필수다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>컨테이너 오케스트</td><td style=text-align:right>동적 스케일링</td><td>락 휘발/소유권 혼란</td><td>StatefulSet 기반 락 서비스, leader election</td></tr><tr><td>멀티 클라우드</td><td style=text-align:right>벤더 종속성</td><td>동기화·규제 이슈</td><td>클라우드 중립 인터페이스, 연합 락 설계</td></tr></tbody></table><ul><li>요약: 클라우드 환경은 상태 유지와 서비스 통합을 전제로 한 락 설계가 필요하다. 단순 DB- 레벨 락만으론 취약할 수 있다.</li></ul><h6 id=성능확장성-한계-메모리cpu>성능·확장성 한계 (메모리·CPU)<a hidden class=anchor aria-hidden=true href=#성능확장성-한계-메모리cpu>#</a></h6><p>대규모 동시성에서 락 테이블과 관리 구조가 메모리·CPU 병목을 만든다.<br>락 수가 선형으로 늘어나면 메모리·캐시 효율이 급감하고, 캐시 미스·순차 경로로 인해 멀티코어 성능이 선형적으로 증가하지 않는다. 해결로는 락 파티셔닝, 계층적 구조, NUMA 친화 설계, 락 - 프리 자료구조 도입이 제시된다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>메모리 한계</td><td style=text-align:right>락 테이블 증가</td><td>메모리 부족·성능 저하</td><td>파티셔닝, 압축, 분산 메모리</td></tr><tr><td>CPU/캐시 한계</td><td style=text-align:right>순차 경로·캐시 미스</td><td>멀티코어 확장 한계</td><td>NUMA-aware 설계, lock-free 요소 도입</td></tr></tbody></table><ul><li>요약: 확장성은 알고리즘·아키텍처 수준에서 해결해야 한다. 단순 스케일업은 한계가 명확하다.</li></ul><h6 id=동시성-모델알고리즘-한계-mvcc락---프리gc>동시성 모델·알고리즘 한계 (MVCC·락 - 프리·GC)<a hidden class=anchor aria-hidden=true href=#동시성-모델알고리즘-한계-mvcc락---프리gc>#</a></h6><p>MVCC·락 - 프리 등은 동시성 향상에 기여하지만 버전 누적·ABA 문제·메모리 재클레임 등으로 새로운 운영·안정성 이슈를 만든다.<br>GC(버전 정리) 는 성능 저하 포인트이며, 장기 트랜잭션이 GC 의 안전 시점을 지연시켜 백로그를 만든다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>MVCC GC 부담</td><td style=text-align:right>버전 누적·장기 txn</td><td>저장소 증가·GC 지연</td><td>장기 txn 제한, adaptive GC</td></tr><tr><td>락 - 프리 한계</td><td style=text-align:right>ABA·reclamation</td><td>안전성·디버깅 문제</td><td>hazard pointers, epoch reclamation</td></tr></tbody></table><ul><li>요약: 고급 동시성 기법은 성능을 주지만 운영 복잡성·안전성 확보가 필수다.</li></ul><h6 id=운영관측테스트-observability--validation>운영·관측·테스트 (Observability & Validation)<a hidden class=anchor aria-hidden=true href=#운영관측테스트-observability--validation>#</a></h6><p>운영 관점의 부족은 문제를 악화시킨다.<br>핵심은 적절한 지표 수집 (hold time, contention rate, deadlock rate), 경보 (알람), 그리고 chaos testing 으로 실제 실패 시 행동을 검증하는 것이다.<br>운영 정책 (에스컬레이션·타임아웃·재시도) 도 문서화해야 한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>관측 부재</td><td style=text-align:right>지표 미수집</td><td>문제 탐지 지연</td><td>대시보드·알람 (hold/wait/deadlock)</td></tr><tr><td>테스트 부재</td><td style=text-align:right>장애 시나리오 미검증</td><td>운영 재난 위험</td><td>chaos testing, stress tests</td></tr></tbody></table><ul><li>요약: 관측·검증이 없는 설계는 실전에서 실패한다. 자동화된 테스트와 명확한 운영 룰이 필요하다.</li></ul><h6 id=연구미래-과제-하드웨어ai-보조>연구·미래 과제 (하드웨어·AI 보조)<a hidden class=anchor aria-hidden=true href=#연구미래-과제-하드웨어ai-보조>#</a></h6><p>하드웨어 가속 (특정 원자 명령, RDMA 기반 분산 락), AI 기반 적응형 타임아웃·GC 스케줄링 등은 유망하지만 아직 시범적 또는 부분 상용화 단계다.<br>도입 전 비용·리스크를 검증하는 파일럿이 필요하다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>하드웨어 가속</td><td style=text-align:right>특수 명령·RDMA</td><td>저지연·고성능 기대</td><td>파일럿, 호환성 검증</td></tr><tr><td>AI 보조 운영</td><td style=text-align:right>예측 모델 필요</td><td>자동화 가능성</td><td>소규모 파일럿으로 검증</td></tr></tbody></table><ul><li>요약: 신기술은 보조적 역할로 안전하게 도입하고, 실패 시 롤백 가능한 실험적 접근이 바람직하다.</li></ul><h5 id=락-도전-과제-통합-요약표>락 도전 과제 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-도전-과제-통합-요약표>#</a></h5><table><thead><tr><th>범주</th><th style=text-align:right>핵심 도전</th><th>주요 원인</th><th>즉각적 대응 (권장)</th></tr></thead><tbody><tr><td>분산 일관성</td><td style=text-align:right>stale writes, split-brain</td><td>파티션·클럭 불일치</td><td>consensus+fencing, region-local locks</td></tr><tr><td>클라우드 운영</td><td style=text-align:right>락 휘발성·호환성</td><td>컨테이너 이동·벤더 차이</td><td>Stateful operator, 중립적 인터페이스</td></tr><tr><td>확장성</td><td style=text-align:right>메모리·CPU 병목</td><td>락 수 증가·캐시 미스</td><td>파티셔닝, NUMA-aware 설계</td></tr><tr><td>동시성 모델</td><td style=text-align:right>GC·ABA 문제</td><td>버전 누적·메모리 reclaim</td><td>adaptive GC, hazard pointers</td></tr><tr><td>운영성</td><td style=text-align:right>탐지·복구 지연</td><td>지표 부족·테스트 미비</td><td>대시보드·chaos testing</td></tr><tr><td>미래 기술</td><td style=text-align:right>구현 복잡·비용</td><td>하드웨어·ML 도입 리스크</td><td>파일럿·점진 도입</td></tr></tbody></table><h4 id=동시성-제어-최신-동향-및-실무-적용>동시성 제어 최신 동향 및 실무 적용<a hidden class=anchor aria-hidden=true href=#동시성-제어-최신-동향-및-실무-적용>#</a></h4><p>요지는—<strong>동시성 제어는 단순히 &rsquo; 락을 많이 걸면 안전 &rsquo; 이 아니다.</strong><br>2025 년 현재는 DB·분산 환경·하드웨어의 발전을 이용해 **&rsquo; 어떤 워크로드에 어떤 도구를 결합할 것인가 &lsquo;**를 지능적으로 선택하는 쪽으로 진화하고 있다.<br>단일 서버라면 MVCC 와 일부 락 혼합으로 충분하고, 분산 시스템에서는 lease+fencing+consensus 를 설계해야 안전하며, AI·하드웨어는 특정 환경에서 운영 효율과 지연을 크게 개선해줄 수 있다.</p><h5 id=락-관련-최신-트렌드-요약>락 관련 최신 트렌드 요약<a hidden class=anchor aria-hidden=true href=#락-관련-최신-트렌드-요약>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 트렌드</th><th>실무 의미 (효용/리스크)</th><th>근거·대표 근거</th></tr></thead><tbody><tr><td>자율 운영 DB</td><td>AI 기반 자동 튜닝·자체 복구</td><td>운영 부담↓, 잘못된 자동화는 장애 리스크</td><td>Oracle Autonomous 등 사례.</td></tr><tr><td>하이브리드 동시성</td><td>MVCC + 락 + 낙관적 결합 (적응형)</td><td>워크로드별 최적 성능 가능/복잡도 증가</td><td>산업·연구 사례 (논문·제품)</td></tr><tr><td>분산 락 안전성</td><td>Lease + Fencing + Consensus 조합</td><td>분산 장애에서 단일 소유 보장</td><td>etcd docs(lease/lock) 권장.</td></tr><tr><td>경량 분산 락 현황</td><td>Redis(SE T N X)/Redlock 광범위 사용</td><td>저지연/간편하지만 TTL·skew 주의</td><td>전문가 비판·팁 다수.</td></tr><tr><td>예측적 락/스케줄링</td><td>ML 로 락 수요 예측/사전 배치</td><td>대기시간↓ 가능성, 모델 신뢰성 필요</td><td>최근 arXiv 연구 (예비).</td></tr><tr><td>하드웨어 가속</td><td>SmartNIC/FPGA 오프로딩 연구</td><td>극저지연 가능/비용·통합 난제</td><td>SmartNIC·FPGA 서베이·프로토타입.</td></tr></tbody></table><h5 id=동시성-트렌드-모델분산보조기술>동시성 트렌드: 모델·분산·보조기술<a hidden class=anchor aria-hidden=true href=#동시성-트렌드-모델분산보조기술>#</a></h5><h6 id=제어-모델>제어 모델<a hidden class=anchor aria-hidden=true href=#제어-모델>#</a></h6><ul><li><strong>하이브리드 제어</strong>: 워크로드 특성 (읽기 위주/쓰기 집중 등) 에 따라 MVCC·락·낙관적 제어를 적응적으로 선택. 장점은 성능 극대화, 단점은 시스템 복잡성·디버깅 어려움.</li><li><strong>SSI 보강</strong>: Snapshot 기반에서 쓰기 - 스큐 등 직렬화 위반을 탐지·차단하는 기법 (실무에서 널리 채택).</li><li><strong>락리스 (심화)</strong>: Lock-free 자료구조·CAS 기반 알고리즘 연구가 진행되어 노드 내부 병렬성 최적화에 사용.</li></ul><table><thead><tr><th>모델</th><th>장점</th><th style=text-align:right>단점</th><th>적용 예</th></tr></thead><tbody><tr><td>하이브리드</td><td>적응적 성능</td><td style=text-align:right>복잡성↑</td><td>Aurora/Spanner 유사 전략</td></tr><tr><td>SSI</td><td>직렬화 보장</td><td style=text-align:right>오류 탐지·오버헤드</td><td>Postgres(SSI 논의)</td></tr><tr><td>락리스</td><td>낮은 지연·스케일</td><td style=text-align:right>구현 난도</td><td>락 - 프리 큐/트리 연구</td></tr></tbody></table><ul><li>요약: 제어 모델 선택은 워크로드 특성과 디버깅·운영 역량에 따라 달라진다.</li></ul><h6 id=분산-안전성>분산 안전성<a hidden class=anchor aria-hidden=true href=#분산-안전성>#</a></h6><ul><li><strong>Lease(유효기간)</strong>: 소유권에 TTL 을 두어 자동 회수. 단점: clock skew·장기 GC 문제.</li><li><strong>Fencing token</strong>: 락 해제 후 이전 소유자가 더 이상 작업 못 하게 막음 (외부 시스템과 연계할 때 필수적).</li><li><strong>Consensus 기반 락 (etcd/ZK)</strong>: 강한 보장 (leader·quorum 기반) 제공, 레이턴시·운영 비용 존재.</li><li><strong>Redis/Redlock 실무주의</strong>: 간편하나 분산·장애 시 동시 소유 가능성 경고 다수.</li></ul><table><thead><tr><th>메커니즘</th><th>장점</th><th style=text-align:right>위험/주의</th><th>권장 상황</th></tr></thead><tbody><tr><td>Lease</td><td>단순·자동 회수</td><td style=text-align:right>clock skew 영향</td><td>경량 리더십</td></tr><tr><td>Fencing</td><td>외부 실행 안전</td><td style=text-align:right>추가 구현 복잡</td><td>DB/스토리지 연계시</td></tr><tr><td>Consensus</td><td>강한 일관성</td><td style=text-align:right>레이턴시·운영비용</td><td>미션 크리티컬</td></tr><tr><td>Redis/Redlock</td><td>저지연</td><td style=text-align:right>TTL·스 plit-brain 위험</td><td>빠른 경량 락 (보강권장)</td></tr></tbody></table><ul><li>요약: 분산 환경에서는 <strong>lease+fencing+consensus</strong> 조합을 고려하되 운영비용을 판단해 선택해야 한다.</li></ul><h6 id=보조-기술-자율mlhw>보조 기술 (자율·ML·HW)<a hidden class=anchor aria-hidden=true href=#보조-기술-자율mlhw>#</a></h6><ul><li><strong>자율 DB(AI 튜닝)</strong>: 인덱스·쿼리·리소스 자동 튜닝으로 운영 부담 감소, 다만 자동화 실패 시 롤백/관찰 필요.</li><li><strong>ML 기반 예측</strong>: 락 수요·콘텐션 예측로 락 전략 선점 가능성 (초기 연구·프로토타입 등장).</li><li><strong>하드웨어 오프로딩</strong>: SmartNIC/FPGA 로 KV 스토어·스토리지 경로 가속, 락 관련 연산 (예: ordered-ops) 오프로딩 연구 활발.</li></ul><table><thead><tr><th>기술</th><th>기대 효과</th><th style=text-align:right>리스크/제약</th><th>적용 권장</th></tr></thead><tbody><tr><td>자율 DB</td><td>운영 자동화</td><td style=text-align:right>자동화 실패 리스크</td><td>운영팀과 병행 도입</td></tr><tr><td>ML 예측</td><td>대기시간 감소 가능</td><td style=text-align:right>모델 신뢰성·데이터 필요</td><td>실험적 도입 단계</td></tr><tr><td>HW 오프로딩</td><td>극저지연</td><td style=text-align:right>비용·통합 난제</td><td>저지연 특화 도메인</td></tr></tbody></table><ul><li>요약: 보조 기술은 _ 효율·자동화 _ 를 제공하지만, 도입 전에 <strong>검증·롤백 플랜</strong>을 반드시 준비해야 한다.</li></ul><h5 id=동시성-트렌드-종합-요약표>동시성 트렌드 종합 요약표<a hidden class=anchor aria-hidden=true href=#동시성-트렌드-종합-요약표>#</a></h5><table><thead><tr><th>분류</th><th>핵심 기술/패턴</th><th>핵심 이득</th><th>주의점</th></tr></thead><tbody><tr><td>제어 모델</td><td>하이브리드·SSI·락리스</td><td>워크로드별 최적화</td><td>복잡성·디버깅 비용</td></tr><tr><td>분산 안전성</td><td>Lease/Fencing/Consensus</td><td>분산 장애 안전성</td><td>운영·레イ턴시 비용</td></tr><tr><td>보조 기술</td><td>Autonomous DB·ML·HW</td><td>운영 자동화·지연 최적화</td><td>검증·통합 비용</td></tr></tbody></table><h4 id=동시성-대안-기술>동시성 대안 기술<a hidden class=anchor aria-hidden=true href=#동시성-대안-기술>#</a></h4><ul><li><strong>왜 대안 기술을 봐야 하나?</strong><br>동시성 제어는 &rsquo; 정확성 vs 성능 &rsquo; 의 균형 문제다. 단일 락은 쉽지만 확장성·지연 문제를 만든다. 그래서 상황에 따라 MVCC, OCC, 락 - 프리, 트랜잭션 메모리, 분산 합의 같은 <strong>대체 접근</strong>이 등장했다.</li><li><strong>간단 비유</strong><ul><li><strong>락</strong>: 한 문에 열쇠 하나, 들어오려면 기다려야 함.</li><li><strong>MVCC</strong>: 같은 문을 여러 카피 (버전) 로 만들어 동시에 여러 사람이 볼 수 있게 함 (단, 오래된 카피 정리 필요).</li><li><strong>OCC</strong>: 아무나 들어와서 작업하다가 충돌이면 다시 시도.</li><li><strong>락 - 프리</strong>: 문을 잠그지 않고, 누가 먼저 바꿨는지 (원자 연산) 로 해결.</li><li><strong>HTM</strong>: CPU 가 트랜잭션을 임시로 &rsquo; 한번에 &rsquo; 처리해주지만, 실패하면 다시 돌아와야 함.</li><li><strong>분산 락 (합의)</strong>: 여러 노드가 투표로 &rsquo; 누가 열쇠를 가지는지 &rsquo; 결정.</li></ul></li></ul><h5 id=대안-동시성-기술-요약>대안 동시성 기술 요약<a hidden class=anchor aria-hidden=true href=#대안-동시성-기술-요약>#</a></h5><table><thead><tr><th>기술</th><th style=text-align:right>장점</th><th>단점</th><th>권장 사용처</th></tr></thead><tbody><tr><td>MVCC</td><td style=text-align:right>읽기 비차단·높은 읽기 동시성</td><td>버전 오버헤드·GC 필요</td><td>읽기 중심 DB/분석</td></tr><tr><td>OCC</td><td style=text-align:right>락 오버헤드 없음·단순</td><td>충돌 시 롤백 비용</td><td>저경합 웹/서비스</td></tr><tr><td>락 - 프리</td><td style=text-align:right>락 오버헤드 제거·높은 확장성</td><td>구현 복잡·ABA 문제</td><td>고동시성 자료구조</td></tr><tr><td>HTM/STM</td><td style=text-align:right>하드웨어 원자성 (HTM), 유연성 (STM)</td><td>HTM 용량/중단·STM 오버헤드</td><td>짧은 메모리 트랜잭션/연구</td></tr><tr><td>분산 락 (Redlock)</td><td style=text-align:right>가벼운 분산 락 구현 가능</td><td>안전성 논쟁·시간 의존</td><td>성능 우선 단순 락</td></tr><tr><td>합의 기반 (Chubby/Etcd/ZK)</td><td style=text-align:right>강한 안전성·명확한 semantics</td><td>구현/운영 복잡도</td><td>중요 리더선출·정합성 필요 시스템</td></tr></tbody></table><h5 id=동시성-대안-기술-분류체계>동시성 대안 기술 분류체계<a hidden class=anchor aria-hidden=true href=#동시성-대안-기술-분류체계>#</a></h5><h6 id=데이터베이스-레벨-mvcc--occ>데이터베이스 레벨: MVCC & OCC<a hidden class=anchor aria-hidden=true href=#데이터베이스-레벨-mvcc--occ>#</a></h6><p>MVCC:</p><ul><li>개념: 각 트랜잭션에 &rsquo; 읽기 가능한 스냅샷 &rsquo; 을 제공해 읽기와 쓰기를 분리.</li><li>장점: 읽기 작업이 락에 막히지 않음 → 높은 읽기 동시성.</li><li>단점/운영포인트: 버전/레코드가 누적되므로 GC(예: VACUUM) 필요, 스토리지·IO 영향. (참고).</li><li>실무 체크리스트: VACUUM/GC 주기·스토리지 모니터링, 쓰기 패턴의 버전 증가 관찰.</li></ul><p>OCC(타임스탬프 기반 포함):</p><ul><li>개념: 트랜잭션은 잠금 없이 진행 → 커밋 시 충돌 검사 (타임스탬프 기준).</li><li>장점: 락 오버헤드 제거, 데드락 없음.</li><li>단점: 충돌 잦은 환경에선 롤백·재시도 비용이 큼.</li><li>실무 체크리스트: 충돌률 모니터링, 지수 백오프 재시도 정책 설계.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>MVCC</th><th>OCC</th></tr></thead><tbody><tr><td>핵심 아이디어</td><td style=text-align:right>버전 스냅샷 읽기</td><td>충돌 시 검증 후 커밋</td></tr><tr><td>읽기 성능</td><td style=text-align:right>매우 높음</td><td>높음</td></tr><tr><td>쓰기 성능</td><td style=text-align:right>중간 (버전 오버헤드)</td><td>상황 의존 (충돌↑ → 저하)</td></tr><tr><td>운영 포인트</td><td style=text-align:right>GC/VACUUM 필요. 스토리지 감시</td><td>충돌률·재시도 정책 필요</td></tr><tr><td>추천처</td><td style=text-align:right>읽기 중심 DB</td><td>저경합 서비스/API</td></tr></tbody></table><ul><li>MVCC 는 읽기중심에 강하고 운영상 GC 를 관리해야 한다. OCC 는 간단하지만 충돌이 늘면 성능이 급락하므로 재시도 정책을 반드시 설계해야 한다.</li></ul><h6 id=메모리자료구조-레벨-락---프리-자료구조>메모리·자료구조 레벨: 락 - 프리 자료구조<a hidden class=anchor aria-hidden=true href=#메모리자료구조-레벨-락---프리-자료구조>#</a></h6><ul><li>개념: mutex 없이 원자적 연산 (CAS 등) 으로 동시성 보장. 일부 연산은 시스템 전체가 진행 중에도 적어도 한 스레드가 작업을 완료함 (Lock-free).</li><li>장점: 락 오버헤드 제거, 높은 스케일링 잠재력.</li><li>단점: 구현 난도 (ABA), 메모리 재사용·수명 관리 복잡. 디버깅·증명 비용 높음.</li><li>실무 체크리스트: ABA 방지 (태그/버저닝), 안정적 메모리 관리 (참조 카운트/스냅샷), 상세 벤치마크.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>락 - 프리</th></tr></thead><tbody><tr><td>핵심 아이디어</td><td style=text-align:right>CAS 기반 원자 연산으로 동시성 확보</td></tr><tr><td>읽기 성능</td><td style=text-align:right>매우 높음</td></tr><tr><td>쓰기 성능</td><td style=text-align:right>매우 높음 (적합한 워크로드에서)</td></tr><tr><td>복잡도</td><td style=text-align:right>매우 높음 (디버깅·증명 필요)</td></tr><tr><td>추천처</td><td style=text-align:right>고동시성 큐/스택/해시맵 등 핵심 인메모리 구조</td></tr></tbody></table><ul><li>락 - 프리는 성능 잠재력이 크지만 ABA·메모리 관리 난제가 있어 사용 범위를 엄격히 제한하고 프로파일링해야 한다.</li></ul><h6 id=하드웨어언어수준-트랜잭션-htm--stm>하드웨어·언어수준 트랜잭션: HTM / STM<a hidden class=anchor aria-hidden=true href=#하드웨어언어수준-트랜잭션-htm--stm>#</a></h6><ul><li>HTM(예: Intel TSX):<ul><li>개념: CPU 가 명령 단위로 트랜잭션을 원자적으로 처리 (캐시 기반).</li><li>장점: 잠금 코드를 제거해 높은 성능 가능.</li><li>단점/운영: capacity abort(캐시 용량 초과)·중단 조건이 잦아 항상 폴백 경로 필요. 실무에서는 중단률·abort 원인 분석 필수.</li></ul></li><li>STM:<ul><li>개념: 소프트웨어 수준에서 트랜잭션을 관리 (라이브러리/런타임).</li><li>장점: 플랫폼 독립성·유연성.</li><li>단점: 런타임 오버헤드·경합시 비용 발생.</li></ul></li><li>실무 체크리스트: HTM 사용 시 트랜잭션 크기·캐시 사용량 프로파일, 폴백 루트 (락 기반) 설계.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>HTM</th><th>STM</th></tr></thead><tbody><tr><td>핵심 아이디어</td><td style=text-align:right>CPU 캐시 기반 트랜잭션</td><td>소프트웨어 트랜잭션</td></tr><tr><td>장점</td><td style=text-align:right>코드 간결·잠금 제거 가능</td><td>플랫폼 독립·정책 유연</td></tr><tr><td>단점</td><td style=text-align:right>용량/abort 문제 → 폴백 필요</td><td>런타임 오버헤드</td></tr><tr><td>추천처</td><td style=text-align:right>짧은 메모리 트랜잭션 (인메모리)</td><td>연구/특정 언어 환경 (Haskell 등)</td></tr></tbody></table><ul><li>HTM 은 성능 가능성이 크나 운영상 abort·폴백 관리를 반드시 설계해야 하며, STM 은 안전하지만 오버헤드가 있다.</li></ul><h6 id=분산-동기화합의-기반-redlock-vs-chubbyzketcd>분산 동기화·합의 기반: Redlock Vs Chubby/ZK/Etcd<a hidden class=anchor aria-hidden=true href=#분산-동기화합의-기반-redlock-vs-chubbyzketcd>#</a></h6><ul><li>경량 (예: Redis Redlock):<ul><li>개념: 여러 Redis 인스턴스에 분산 키를 세워 과반수 획득으로 락 획득을 시도.</li><li>장점: 구현이 비교적 가볍고 빠름.</li><li>단점: 시스템 모델 (시간, 복제 지연) 에 민감해 안전성 비판 존재 (정확성이 중요하면 주의).</li></ul></li><li>합의 기반 (Chubby, ZooKeeper, Etcd):<ul><li>개념: Paxos/Raft 같은 합의로 상태를 복제해 강한 안전성 (선택적 일관성) 을 제공.</li><li>장점: 락의 안전성·명확한 semantics(리더 선출·이름 서비스 등).</li><li>단점: 운영·관리 복잡도, 높은 레이턴시 (고빈도 락에는 부적합).</li></ul></li><li>실무 체크리스트: 락의 &rsquo; 정확성 (정합성)&rsquo; 요구 여부에 따라 Redlock(성능 우선) vs 합의 (정확성 우선) 선택; 펜싱 토큰 패턴 권장.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>Redlock(경량)</th><th>합의 기반 (Chubby/ZK/Etcd)</th></tr></thead><tbody><tr><td>핵심 아이디어</td><td style=text-align:right>다중 인스턴스 SET NX 과반수</td><td>합의 프로토콜로 상태 복제</td></tr><tr><td>장점</td><td style=text-align:right>빠르고 간단</td><td>강한 안전성·명확한 semantics</td></tr><tr><td>단점</td><td style=text-align:right>시간/복제 지연에 민감 (안전 논쟁)</td><td>운영 복잡·비용</td></tr><tr><td>추천처</td><td style=text-align:right>성능 우선·비핵심 락</td><td>리더선출·중요한 동기화/정합성 필요 시스템</td></tr></tbody></table><ul><li>단순한 성능 목적의 분산 락과, 정확성 (안전) 이 요구되는 합의 기반 락은 목적이 다르다. 안전이 필요하면 합의 기반 + 펜싱을 선택하라.</li></ul><h5 id=동시성-대안-기술-통합표>동시성 대안 기술 통합표<a hidden class=anchor aria-hidden=true href=#동시성-대안-기술-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 아이디어</th><th style=text-align:right>읽기 성능</th><th style=text-align:right>쓰기 성능</th><th style=text-align:right>구현/운영 복잡도</th><th>추천 상황</th></tr></thead><tbody><tr><td>MVCC</td><td>버전 스냅샷으로 읽기 비차단</td><td style=text-align:right>매우 높음</td><td style=text-align:right>중간 (버전 오버헤드)</td><td style=text-align:right>중간 (운영 GC 필요)</td><td>읽기 중심 DB</td></tr><tr><td>OCC</td><td>커밋 시 충돌 검증</td><td style=text-align:right>높음</td><td style=text-align:right>상황 의존 (충돌↑ 저하)</td><td style=text-align:right>중간</td><td>저경합 서비스</td></tr><tr><td>락 - 프리</td><td>CAS 기반 원자 연산</td><td style=text-align:right>매우 높음</td><td style=text-align:right>매우 높음 (조건부)</td><td style=text-align:right>매우 높음 (디버깅·증명)</td><td>고동시성 자료구조</td></tr><tr><td>HTM/STM</td><td>CPU·소프트웨어 트랜잭션</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td><td style=text-align:right>중간~높음 (폴백 포함)</td><td>짧은 메모리 트랜잭션</td></tr><tr><td>분산 락 (경량)</td><td>다중 인스턴스 합의 (간단)</td><td style=text-align:right>보통</td><td style=text-align:right>보통</td><td style=text-align:right>낮음~중간</td><td>성능 우선 비핵심 락</td></tr><tr><td>합의 기반</td><td>Paxos/Raft 로 상태 복제</td><td style=text-align:right>보통</td><td style=text-align:right>보통</td><td style=text-align:right>높음 (운영 복잡)</td><td>정확성·정합성 필수 시스템</td></tr></tbody></table><hr><h2 id=종합-정리-및-학습-가이드>종합 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#종합-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>락 (Locking) 은 데이터베이스에서 동시 트랜잭션들이 같은 자원에 접근할 때 발생하는 충돌을 제어해 데이터 무결성을 보장하는 기본 도구다. 구현 관점에서는 저수준 primitives(스핀락·뮤텍스·세마포어), 고수준 패턴 (리더 - 라이터·적응형·락 - 프리), DBMS 특화 기법 (갭 락·넥스트 - 키·에스컬레이션·어드바이저리 락), 분산 조정 (lease·consensus·fencing) 으로 나뉜다.</p><p>선택 기준은 워크로드 특성 (읽기/쓰기 비율, 충돌 빈도), 시스템 범위 (단일 노드 vs 분산), 운영 제약 (CPU·지연·가용성 요구) 이다. 예컨대 읽기 중심·충돌 적은 시스템은 MVCC 또는 낙관적 검증이 유리하고, 금융·재고처럼 강한 정합성이 필요하면 비관적 락 (2PL) 을 선택한다. 분산 환경에서는 단순한 분산 락보다 합의 기반과 fencing 을 결합해 stale client 문제를 막는 것이 안전한 기본값이다.</p><p>운영적으로는 락 관련 메트릭 (대기 시간·홀드 시간·경합률·데드락 빈도) 을 상시 모니터링하고, 락 에스컬레이션 임계값·타임아웃·재시도 정책을 문서화·튜닝해야 한다. AI·적응형 기법은 보조적으로 유용하지만, 실패 리스크·추가 비용을 고려해 단계적으로 도입하는 것이 현실적이다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>단계</th><th style=text-align:right>권장 활동 (요약)</th><th>구체 체크리스트 / 패턴</th><th>예시·근거 (참고자료)</th></tr></thead><tbody><tr><td>설계</td><td style=text-align:right>일관성 vs 성능 우선순위 결정</td><td>데이터 분류 (재무/비규제 등), SLA 정의, 충돌 빈도 예측</td><td>MVCC/격리수준 트레이드오프.</td></tr><tr><td>설계</td><td style=text-align:right>트랜잭션 범위 최소화</td><td>트랜잭션 내 외부 I/O 제거, 짧은 트랜잭션 목표</td><td>PostgreSQL 권장사항 (짧게 유지).</td></tr><tr><td>구현</td><td style=text-align:right>잠금 전략 선택</td><td>비관적 vs 낙관적 문서화, 샘플 벤치마크</td><td>MVCC 장단점 분석.</td></tr><tr><td>구현</td><td style=text-align:right>잠금 순서 표준화</td><td>리소스 획득 전역 순서 문서화</td><td>데드락 예방 권장.</td></tr><tr><td>구현</td><td style=text-align:right>대기 정책</td><td>NOWAIT / SKIP LOCKED 활용 (큐/워커) + 복제 영향 검토</td><td>MySQL/Postgres 문서 (주의점).</td></tr><tr><td>구현</td><td style=text-align:right>분산 락 안전성</td><td>Consensus 기반 락 혹은 펜싱 토큰 + 조건부 쓰기 도입</td><td>Kleppmann·펜싱 토큰 참조.</td></tr><tr><td>구현</td><td style=text-align:right>예외/재시도 표준</td><td>명확한 재시도 (지수백오프), 모든 경로에서 잠금 해제 보장</td><td>DB 매뉴얼 권장 패턴.</td></tr><tr><td>운영</td><td style=text-align:right>모니터링</td><td>lock wait, deadlock rate, hot rows, longest tx 대시보드</td><td>SQL Server·엔진 모니터링 설명.</td></tr><tr><td>운영</td><td style=text-align:right>자동 복구·알림</td><td>데드락 탐지 → 로그·알림·애플리케이션 재시도</td><td>MySQL/SQL Server 가이드라인.</td></tr><tr><td>확장</td><td style=text-align:right>아키텍처 변경</td><td>샤딩, CQRS/이벤트 비동기화, 합의 스토어 도입</td><td>분산 락/합의 사례.</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th>단계</th><th style=text-align:right>권장 기간</th><th>핵심 학습 주제</th><th style=text-align:right>학습 목표</th><th style=text-align:right>실무 연관성</th><th>권장 실습 (예시)</th></tr></thead><tbody><tr><td>초급</td><td style=text-align:right>0–2 주 ~ 2 개월</td><td>락 기본 (모드/범위/수명), 2PL 개요</td><td style=text-align:right>용어·개념 숙지, 간단한 락 시나리오 이해</td><td style=text-align:right>모든 DB·트랜잭션 기초</td><td>Postgres: SELECT FOR UPDATE, NOWAIT 실험</td></tr><tr><td>중급</td><td style=text-align:right>2–6 개월</td><td>2PL 심화, Deadlock 탐지/해결, 의도락, 에스컬레이션</td><td style=text-align:right>직렬화 원리 이해·데드락 해결 능력 확보</td><td style=text-align:right>트랜잭션 설계·튜닝</td><td>데드락 시나리오 생성·로그 분석, 에스컬레이션 실험</td></tr><tr><td>중상급</td><td style=text-align:right>6–12 개월</td><td>MVCC/SSI 상호작용, 대기 정책 (SKIP LOCKED), 성능 측정</td><td style=text-align:right>MVCC 와 혼용 시 행동 예측, 응답성 최적화</td><td style=text-align:right>OLTP 운영·리포팅</td><td>Postgres MVCC 실험, SKIP LOCKED 기반 작업 큐 구현</td></tr><tr><td>고급</td><td style=text-align:right>12–24 개월</td><td>분산 락, Lease/Fencing, Consensus(etcd/ZK), 장애 모델</td><td style=text-align:right>분산 환경의 안전한 락 설계·구현 능력</td><td style=text-align:right>마이크로서비스·분산 스케줄링</td><td>etcd leader election + Redis SETNX 비교 실험</td></tr><tr><td>전문</td><td style=text-align:right>24 개월 +</td><td>하이브리드 설계, Lock-free, AI 운영 자동화</td><td style=text-align:right>대규모 시스템 아키텍처 설계·연구 역량</td><td style=text-align:right>대규모 서비스 운영·리서치</td><td>토이 MVCC+Lock 엔진 구현, GC 튜닝 자동화 모델링</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>항목</th><th>목표</th><th style=text-align:right>실무 연관성</th><th>설명</th><th>권장 실습·기간</th></tr></thead><tbody><tr><td style=text-align:right>초급</td><td>락 모드 (S/X/IS/IX/SIX/U)</td><td>모드별 동시 허용 규칙 이해</td><td style=text-align:right>쿼리 설계·락 테이블 설계</td><td>공유/배타/의도락의 의미와 호환성 매트릭스 학습</td><td>실습: 간단 SQL 로 모드별 동작 확인 (1–3 일)</td></tr><tr><td style=text-align:right>초급</td><td>그레뉼러리티 (Row/Page/Table)</td><td>범위 선택에 따른 트레이드오프 파악</td><td style=text-align:right>성능 설계, 인덱스 설계</td><td>작업 단위에 따른 동시성·오버헤드 균형</td><td>실습: 행락 vs 테이블락 비교 (1–2 일)</td></tr><tr><td style=text-align:right>초급</td><td>수명 (Statement/Tx/Session)</td><td>락 보유기간에 따른 영향 이해</td><td style=text-align:right>트랜잭션 설계</td><td>즉시 해제 vs 커밋 해제 시나리오 시연</td><td>실습: 트랜잭션 길이 변화에 따른 대기 관찰 (2–3 일)</td></tr><tr><td style=text-align:right>중급</td><td>2-Phase Locking (Strict/Rigorous)</td><td>직렬화 보장 메커니즘 심화</td><td style=text-align:right>데이터 무결성 보장</td><td>2PL 단계와 커밋 시점 락 해제 차이 학습</td><td>이론 + 실습 (1–2 주)</td></tr><tr><td style=text-align:right>중급</td><td>Deadlock 탐지·해제</td><td>교착 발생 원인 파악·해결</td><td style=text-align:right>운영 안정성</td><td>Wait-for 그래프·타임아웃·비용 기반 abort</td><td>실습: 데드락 시나리오 생성/로그 분석 (1 주)</td></tr><tr><td style=text-align:right>중급</td><td>의도락/에스컬레이션</td><td>멀티레벨 락 운영방법</td><td style=text-align:right>혼합 락 환경 최적화</td><td>IS/IX 역할, 자동 에스컬레이션 정책 이해</td><td>실습: 에스컬레이션 임계 실험 (1 주)</td></tr><tr><td style=text-align:right>중상급</td><td>MVCC 기본 & SSI 연동</td><td>MVCC 와 락의 차이·조합 이해</td><td style=text-align:right>현대 DB(OLTP) 설계</td><td>스냅샷 격리, 쓰기 스큐, SSI 충돌 탐지</td><td>실습: Postgres MVCC 시나리오 (2 주)</td></tr><tr><td style=text-align:right>중상급</td><td>대기 정책 (NOWAIT / SKIP LOCKED)</td><td>응답성/처리 방식 설계</td><td style=text-align:right>작업 큐·배치 처리</td><td>NOWAIT: 즉시 실패, SKIP LOCKED: 건너뛰기</td><td>실습: 작업 큐 구현 (1 주)</td></tr><tr><td style=text-align:right>중상급</td><td>성능 모니터링 지표</td><td>운영 지표 수립·해석</td><td style=text-align:right>SLA 유지·튜닝</td><td>lock wait time, contention ratio 등 정의·수집</td><td>실습: Prometheus 로 지표 수집 (2 주)</td></tr><tr><td style=text-align:right>고급</td><td>분산 락 (Lease/Fencing)</td><td>분산 실패 모델 대비 설계</td><td style=text-align:right>마이크로서비스·클러스터</td><td>lease TTL, fencing token, consensus 비교</td><td>실습: etcd vs Redis 락 실험 (2–4 주)</td></tr><tr><td style=text-align:right>고급</td><td>Consensus 연동 (Raft/Zab)</td><td>락의 강한 안전성 확보</td><td style=text-align:right>글로벌 락/리더 선출</td><td>etcd/zookeeper 내부 동작 이해</td><td>실습: etcd 클러스터 구성·실험 (2–4 주)</td></tr><tr><td style=text-align:right>고급</td><td>분산 트랜잭션 패턴</td><td>Sagas / 2PC 등 설계</td><td style=text-align:right>분산 비즈니스 로직</td><td>동기/비동기 보상 트랜잭션 모델</td><td>케이스 스터디·설계 실습 (2–4 주)</td></tr><tr><td style=text-align:right>전문</td><td>Lock-free 알고리즘</td><td>락 없이 동시성 확보 연구</td><td style=text-align:right>초고성능 시스템</td><td>원자 연산·CAS 기반 알고리즘 이해</td><td>이론·코드 구현 (월 단위)</td></tr><tr><td style=text-align:right>전문</td><td>AI 기반 운영 자동화</td><td>GC/튜닝 자동화 설계</td><td style=text-align:right>대규모 운영 자동화</td><td>메트릭 기반 학습 모델 설계·검증</td><td>데이터 수집·모델링 (수개월)</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th style=text-align:right>카테고리</th><th>용어 (한글 / (영어 풀네임, 약어))</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td style=text-align:right>핵심</td><td>잠금 (Lock / (Lock))</td><td>데이터 또는 자원에 대한 접근 권한을 제어하는 메커니즘</td><td>트랜잭션, 격리수준</td><td>동시성 제어의 기본 수단</td></tr><tr><td style=text-align:right>핵심</td><td>공유락 (공유 잠금 / Shared Lock, S-Lock)</td><td>다수 트랜잭션의 읽기 허용, 쓰기 불가</td><td>S-Lock, 읽기 병행성</td><td>조회 집중 워크로드에서 사용</td></tr><tr><td style=text-align:right>핵심</td><td>배타락 (배타적 잠금 / Exclusive Lock, X-Lock)</td><td>해당 자원에 대한 독점적 접근 보장</td><td>X-Lock, 쓰기 보호</td><td>UPDATE/DELETE 시 필수</td></tr><tr><td style=text-align:right>핵심</td><td>2 단계 락킹 (2-Phase Locking / 2PL)</td><td>성장 단계에서 락 획득, 축소 단계에서 해제해 직렬성 보장</td><td>Strict 2PL, 직렬성</td><td>강한 무결성 요구 시스템</td></tr><tr><td style=text-align:right>구현</td><td>의도락 (Intent Lock / IS, IX, SIX)</td><td>계층적 락으로 테이블 레벨과 행 레벨 락 조정</td><td>Lock Escalation, 행락</td><td>상위 - 하위 락 호환성 확보</td></tr><tr><td style=text-align:right>구현</td><td>행락 (Row Lock / (Row Lock))</td><td>특정 행 단위의 락</td><td>레코드 그레인 락</td><td>고동시성 환경에서 미세 락</td></tr><tr><td style=text-align:right>구현</td><td>프레디케이트 락 / Gap 락 (Predicate/Gap Lock)</td><td>범위 (간격) 를 잠가 팬텀 방지</td><td>팬텀 현상, 범위 락</td><td>팬텀 문제 민감한 트랜잭션 보호</td></tr><tr><td style=text-align:right>구현</td><td>어드바이저리 락 (Advisory/Named Lock)</td><td>애플리케이션 수준의 임의 키 락</td><td>앱 레벨 동기화, Redis Lock</td><td>잡 스케줄링·리더 선출 등에 활용</td></tr><tr><td style=text-align:right>구현</td><td>락 에스컬레이션 (Lock Escalation)</td><td>다수의 세밀 락을 상위 그레인 락으로 승격</td><td>메모리 최적화, 동시성 저하</td><td>다량 업데이트 시 성능 영향 모니터링</td></tr><tr><td style=text-align:right>운영</td><td>락 경합 (Lock Contention)</td><td>동일 자원에 대한 락 요청 간 경쟁</td><td>Wait Queue, 스로틀링</td><td>병목 발생 지점 탐지</td></tr><tr><td style=text-align:right>운영</td><td>데드락 (Deadlock)</td><td>트랜잭션들이 서로의 락 해제를 기다리는 순환 대기</td><td>Wait-for Graph, 탐지/해결</td><td>모니터링·자동해결 (희생자) 필요</td></tr><tr><td style=text-align:right>운영</td><td>락 대기 큐 (Wait Queue)</td><td>락 획득을 대기하는 트랜잭션 순서</td><td>FIFO, 우선순위</td><td>공정성·성능 정책에 영향</td></tr><tr><td style=text-align:right>운영</td><td>락 타임아웃 (Lock Timeout)</td><td>락 획득 대기 시간 제한</td><td>즉시 실패 (NOWAIT)</td><td>블로킹 방지 전략</td></tr><tr><td style=text-align:right>운영</td><td>모니터링 뷰 (예: pg_locks)</td><td>DB 내부 락 상태 관찰용 시스템 뷰</td><td>pg_stat_activity</td><td>운영·진단 필수 지표</td></tr><tr><td style=text-align:right>고급</td><td>MVCC (다중 버전 동시성 제어 / Multi-Version Concurrency Control, MVCC)</td><td>여러 버전을 유지해 읽기 락을 피하는 동시성 제어</td><td>Snapshot Isolation, Undo Log</td><td>읽기 중심·대규모 동시성 시스템</td></tr><tr><td style=text-align:right>고급</td><td>낙관적 잠금 (Optimistic Lock)</td><td>충돌 시점에 검증하고 재시도하는 전략</td><td>버전 비교, CAS</td><td>분산 API, 재시도 정책</td></tr><tr><td style=text-align:right>고급</td><td>비관적 잠금 (Pessimistic Lock)</td><td>미리 락 획득해 충돌 예방하는 전략</td><td>SELECT FOR UPDATE</td><td>재고·금융 트랜잭션</td></tr><tr><td style=text-align:right>분산</td><td>분산 락 (Distributed Lock)</td><td>여러 노드에 걸친 글로벌 락 관리</td><td>ZooKeeper, etcd, Redis</td><td>마이크로서비스 동기화</td></tr><tr><td style=text-align:right>분산</td><td>펜싱 토큰 (Fencing Token)</td><td>이전 리더의 IO 를 차단하는 안전 토큰</td><td>리더 선출, 스토리지 안전</td><td>리더 전환 시 안전성 보장</td></tr><tr><td style=text-align:right>SQL 문</td><td>FOR UPDATE / FOR SHARE</td><td>쿼리 수준에서 행을 잠그는 SQL 구문</td><td>SELECT FOR UPDATE, SKIP LOCKED</td><td>소비자 큐·동시 업데이트 제어</td></tr><tr><td style=text-align:right>SQL 문</td><td>SKIP LOCKED / NOWAIT</td><td>잠긴 행을 건너뛰거나 즉시 실패</td><td>컨슈머 패턴, 대기 회피</td><td>워크 큐 구현 시 활용</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html>MySQL InnoDB Locking 및 트랜잭션 모델</a></li><li><a href=https://www.postgresql.org/docs/current/explicit-locking.html>PostgreSQL 명시적 락(Explicit Locking)</a></li><li><a href=https://www.postgresql.org/docs/current/mvcc.html>PostgreSQL MVCC(동시성 제어) 문서</a></li><li><a href=https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html>Oracle 데이터 동시성 및 일관성(Oracle Database)</a></li><li><a href=https://zookeeper.apache.org/doc/current/recipes.html>Apache ZooKeeper 레시피(분산 조정)</a></li><li><a href=https://research.google/pubs/pub39966/>Google Spanner 논문 — Spanner: Google&rsquo;s Globally-Distributed Database</a></li><li><a href=https://www.iso.org/standard/16663.html>ISO/IEC 9075 (SQL 표준) 정보 페이지</a></li><li><a href=https://www.db-book.com/>Database System Concepts (DB-Book)</a></li><li><a href="https://learn.microsoft.com/ko-kr/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver17">SQL Server 트랜잭션 잠금 및 행 버전 관리 지침 (Microsoft Learn)</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Duration</h2></header><div class=entry-content><p>Lock Duration Lock Duration 은 트랜잭션이 락을 쥐고 있는 시간으로, 동시성과 일관성의 균형을 결정한다.
2PL 에서는 필요한 락을 모아 잡는 성장 단계와 해제만 하는 축소 단계가 있고, Strict 2PL 은 커밋 시 일괄 해제로 복구를 단순화하지만 대기가 길어질 수 있다.
MVCC 는 읽기에서 과도한 공유락을 줄여 동시성을 높이되, 갱신·메타데이터 작업·직렬화 격리에서는 여전히 락 (행·범위·테이블) 을 사용한다.
지속시간은 격리수준, 명시적 락 구문, 트랜잭션 경계 (오토커밋·프레임워크 전파), lock_timeout 같은 파라미터, 락 그라뉼러리티와 에스컬레이션에 좌우된다.
시간이 길면 경합·데드락·긴 꼬리 지연이, 너무 짧으면 재시도·롤백과 팬텀 위험이 커진다. 따라서 짧은 트랜잭션 설계, 일관된 락 순서, 적절한 타임아웃과 백오프, 인덱스와 쿼리 최적화로 범위락을 줄이고, DDL 은 업무와 시간대를 분리하는 방식이 실무적으로 효과적이다.
...</p></div><footer class=entry-footer><span title='2025-09-23 03:56:00 +0000 UTC'>September 23, 2025</span>&nbsp;·&nbsp;76 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock Duration" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-duration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Locking Protocols</h2></header><div class=entry-content><p>Locking Protocols 잠금 프로토콜은 다중 트랜잭션 환경에서 데이터 일관성과 격리성을 보장하기 위해 자원 접근 (획득·해제) 규칙을 정의한 기술이다.
핵심 개념은 공유 (S)/배타 (X) 같은 락 모드와 락 획득·해제 시점 (예: Two-Phase Locking, 2PL) 이며, Strict 2PL 은 쓰기 락을 커밋까지 유지해 복구를 단순화한다.
현대 시스템에서는 MVCC(스냅샷 읽기) 를 통해 읽기 성능을 높이고, 낙관적 동시성 (버전 비교) 을 충돌이 적은 워크로드에 적용한다.
구현 관점에서는 락 매니저·락 테이블, 의도락 (IS/IX)·갭/넥스트키 락 등 계층·범위 제어가 중요하다.
운영상 데드락은 Wait-for 그래프 탐지·타임아웃·victim 선정으로 처리하고, 락 승격은 대량 락 상황에서 성능 저하를 유발하므로 주의해야 한다.
분산 환경에서는 ZooKeeper/etcd/Redis 기반 분산 락 (리스/펜싱 토큰) 과 메시지 기반 (Saga/CQRS) 아키텍처를 조합해 장기 트랜잭션과 글로벌 일관성을 관리한다.
설계 시에는 격리 수준, 인덱스·쿼리 범위, 트랜잭션 길이, DBMS 별 구현 차이를 고려해 성능과 정합성 사이의 적절한 균형을 맞추는 것이 관건이다.
...</p></div><footer class=entry-footer><span title='2025-09-22 04:42:00 +0000 UTC'>September 22, 2025</span>&nbsp;·&nbsp;84 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Locking Protocols" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Modes</h2></header><div class=entry-content><p>Lock Modes 락 모드는 트랜잭션의 동시 접근을 제어해 일관성을 보장하는 핵심 수단이다.
기본적으로 S(공유) 와 X(배타) 를 시작으로 U(업데이트), Intent(IS/IX/SIX) 와 범위 락 (Range/Gap/Predicate), Schema 락 등으로 세분화된다. 범위 락은 인덱스의 빈 공간이나 조건 (프레디케이트) 에 대해 팬텀을 방지한다.
데이터베이스마다 구현이 다르다:
PostgreSQL 은 논리적 predicate lock 으로 범위를 표현하고, MySQL InnoDB 는 레코드 락과 gap 락을 결합한 next-key 로 phantom 을 제어하며, SQL Server 는 Range 락을 통해 유사한 목적을 달성한다. 락의 호환성 매트릭스 (예: S 끼리는 허용, S 와 X 는 충돌) 는 데드락과 성능에 직접 영향주며, 이를 완화하려면 적절한 인덱스 설계·짧은 트랜잭션·작업 분리·격리 수준 조정이 필요하다.
현대 시스템은 MVCC 나 SSI 같은 버전 기반 기법과 결합해 읽기 성능과 일관성 사이에서 균형을 맞춘다.
모니터링은 대기 그래프·블로킹 세션·데드락 로그를 확인해 병목과 정책을 개선하는 방향으로 진행한다.
...</p></div><footer class=entry-footer><span title='2025-08-27 06:21:00 +0000 UTC'>August 27, 2025</span>&nbsp;·&nbsp;63 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock Modes" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Granularity</h2></header><div class=entry-content><p>Lock Granularity Lock Granularity 는 " 어느 범위에 락을 걸 것인가 " 를 결정하는 설계 레버로, 세밀할수록 동시성은 커지지만 락 관리 오버헤드·데드락 위험도 증가한다.
해결책은 다층적 락 (의도락) 사용으로 상위 - 하위 충돌을 줄이고, 인덱스·쿼리로 범위 스캔을 피하며, 파티셔닝·샤딩·MVCC 병행으로 핫스팟을 완화하는 것이다.
실무 체크리스트:
읽기/쓰기 비율 측정 핫스팟 식별 인덱스·쿼리 튜닝 에스컬레이션 임계치·락 테이블 메모리 모니터링 스테이징에서 그레인별 성능 테스트. 최종 원칙: " 작게 시작해 계측하고, 워크로드에 맞춰 조정 " 이다.
...</p></div><footer class=entry-footer><span title='2025-08-12 09:59:00 +0000 UTC'>August 12, 2025</span>&nbsp;·&nbsp;99 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock Granularity" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/></a></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>