<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API Styles | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,API-Architecture-Styles"><meta name=description content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API Styles"><meta property="og:description" content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API Styles"><meta name=twitter:description content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"API Styles","item":"https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>API Styles</h1><div class=post-description>API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다.</div></header><div class=post-content><h2 id=api-styles>API Styles<a hidden class=anchor aria-hidden=true href=#api-styles>#</a></h2><p>API(애플리케이션 프로그래밍 인터페이스) 스타일은 시스템 간 통신 방식을 결정하는 중요한 설계 패턴으로, 다양한 시스템과 장치가 서로 디지털적으로 통신할 수 있도록 연결해주는 역할을 한다. API 스타일은 API가 외부 세계와 상호작용하는 방식을 결정하는 중요한 요소이다.</p><p>API 스타일은 크게 다섯 가지로 분류할 수 있다:</p><ol><li>리소스 스타일 (Resource Style)</li><li>하이퍼미디어 스타일 (Hypermedia Style)</li><li>쿼리 스타일 (Query Style)</li><li>터널 스타일 (Tunnel Style)</li><li>이벤트 기반 스타일 (Event-based Style)</li></ol><p>각 스타일은 고유한 강점과 약점을 가지고 있으며, 적절한 API 스타일 선택은 해결하려는 문제, API 소비자, 그리고 API가 사용되는 컨텍스트에 따라 달라진다.</p><h3 id=api-style의-간략-비교>API Style의 간략 비교<a hidden class=anchor aria-hidden=true href=#api-style의-간략-비교>#</a></h3><table><thead><tr><th>스타일</th><th>핵심 개념</th><th>목적</th><th>특징</th><th>주요 원리 및 작동 원리</th></tr></thead><tbody><tr><td><strong>리소스 스타일</strong></td><td>리소스 중심의 CRUD 작업</td><td>단순하고 직관적인 데이터 조작</td><td>HTTP 메서드 사용, URI 기반 리소스 식별</td><td>클라이언트가 URI를 통해 리소스에 접근하고, HTTP 메서드를 통해 조작</td></tr><tr><td><strong>하이퍼미디어 스타일</strong></td><td>리소스 간의 링크를 통한 상태 전이</td><td>클라이언트와 서버의 결합도 감소</td><td>HATEOAS 원칙 준수, 동적인 탐색 가능</td><td>응답에 포함된 링크를 통해 클라이언트가 다음 가능한 작업을 탐색</td></tr><tr><td><strong>쿼리 스타일</strong></td><td>클라이언트가 필요한 데이터만 요청</td><td>효율적인 데이터 전송</td><td>쿼리 언어 사용, 정밀한 데이터 요청 가능</td><td>클라이언트가 쿼리를 정의하여 서버에 요청, 서버는 해당 데이터만 응답</td></tr><tr><td><strong>터널 스타일</strong></td><td>원격 프로시저 호출(RPC)을 통한 기능 호출</td><td>고성능, 경량 통신</td><td>바이너리 포맷 사용, 스트리밍 지원</td><td>클라이언트가 함수를 호출하듯이 서버의 기능을 원격으로 실행</td></tr><tr><td><strong>이벤트 기반 스타일</strong></td><td>이벤트를 기반으로 비동기 통신</td><td>실시간 데이터 처리, 확장성 제공</td><td>메시지 브로커 사용, 낮은 결합도</td><td>이벤트 발생 시 이를 브로커에 발행, 구독자는 해당 이벤트를 처리</td></tr></tbody></table><h3 id=리소스-스타일-resource-style>리소스 스타일 (Resource Style)<a hidden class=anchor aria-hidden=true href=#리소스-스타일-resource-style>#</a></h3><p><strong>핵심 개념과 목적</strong>:</p><ul><li>리소스 중심의 접근 방식으로, 데이터와 기능을 리소스로 모델링</li><li>목적: 클라이언트가 리소스를 직접 조작할 수 있는 인터페이스 제공</li></ul><p><strong>특징</strong>:</p><ul><li><p>REST(Representational State Transfer) 아키텍처 기반</p></li><li><p>리소스를 URI로 식별하고 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 리소스 조작</p></li><li><p>상태 없는(Stateless) 통신 방식</p></li><li><p>균일한 인터페이스 제공</p></li></ul><p><strong>작동 원리</strong>:</p><ul><li><p>클라이언트가 리소스의 URI에 HTTP 요청을 보냄</p></li><li><p>서버는 요청된 리소스의 상태를 표현하는 응답(주로 JSON 형식)을 반환</p></li><li><p>클라이언트는 응답을 처리하고 필요에 따라 추가 요청을 수행</p></li></ul><p><strong>구성 요소</strong>:</p><ul><li><p>리소스(URI로 식별됨)</p></li><li><p>HTTP 메서드(동작 정의)</p></li><li><p>표현 형식(주로 JSON, 과거에는 XML)</p></li><li><p>상태 코드(응답 상태 표시)</p></li></ul><p><strong>리소스 스타일 (REST) 아키텍처</strong>:</p><ul><li>클라이언트가 서버의 리소스에 직접 접근하여 조작</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트                                      서버
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span><span class=line><span class=cl>|        |  GET /resources/{id}           |        |
</span></span><span class=line><span class=cl>|        | -----------------------------&gt; |        |
</span></span><span class=line><span class=cl>|        |                                |  REST  |
</span></span><span class=line><span class=cl>|        |  200 OK                        |  API   |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>|        | &lt;----------------------------- |        |
</span></span><span class=line><span class=cl>|        |  {resource data}               |        |
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span></code></pre></td></tr></table></div></div><p><strong>주요 기능</strong>:</p><ul><li>OpenAPI를 통한 API 문서화</li><li>캐싱 가능</li><li>자원 기반 접근법으로 직관적인 사용</li></ul><h3 id=하이퍼미디어-스타일-hypermedia-style>하이퍼미디어 스타일 (Hypermedia Style)<a hidden class=anchor aria-hidden=true href=#하이퍼미디어-스타일-hypermedia-style>#</a></h3><p><strong>핵심 개념과 목적</strong>:</p><ul><li><p>리소스 스타일의 확장으로, 리소스 간 탐색을 위한 링크 제공</p></li><li><p>목적: 클라이언트가 API를 동적으로 탐색할 수 있도록 하여 유연성 증가</p></li></ul><p><strong>특징</strong>:</p><ul><li><p>HATEOAS(Hypermedia As The Engine Of Application State) 원칙 적용</p></li><li><p>응답에 관련 리소스 링크 포함</p></li><li><p>클라이언트가 API 구조를 사전에 알 필요가 없음</p></li></ul><p><strong>작동 원리</strong>:</p><ul><li><p>클라이언트가 초기 진입점에 요청</p></li><li><p>서버는 리소스와 함께 관련 작업에 대한 링크 제공</p></li><li><p>클라이언트는 제공된 링크를 통해 다음 단계 리소스 접근</p></li></ul><p><strong>구성 요소</strong>:</p><ul><li>리소스(URI로 식별)</li><li>하이퍼링크(다음 가능한 작업 안내)</li><li>링크 관계(rel 속성)</li><li>표현 형식(주로 JSON 또는 HAL, JSON-LD 등)</li></ul><p><strong>하이퍼미디어 스타일 아키텍처</strong>:</p><ul><li>클라이언트가 응답에 포함된 링크를 따라 상태 전이</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트                                     서버
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span><span class=line><span class=cl>|        |  GET /api                      |        |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>|        | -----------------------------&gt; |        |
</span></span><span class=line><span class=cl>|        |                                |하이퍼미디어|
</span></span><span class=line><span class=cl>|        |  200 OK                        |  API   |
</span></span><span class=line><span class=cl>|        | &lt;----------------------------- |        |
</span></span><span class=line><span class=cl>|        |  {data, _links: {…}}         |        |
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span><span class=line><span class=cl>     |                                        ^
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     |       GET /api/resources/1             |
</span></span><span class=line><span class=cl>     +---------------------------------------&gt;+
</span></span></code></pre></td></tr></table></div></div><p><strong>주요 기능</strong>:</p><ul><li>API 발견 가능성(discoverability) 향상</li><li>클라이언트와 서버 간 결합도 감소</li><li>워크플로우 표현 가능</li></ul><h3 id=쿼리-스타일-query-style>쿼리 스타일 (Query Style)<a hidden class=anchor aria-hidden=true href=#쿼리-스타일-query-style>#</a></h3><p><strong>핵심 개념과 목적</strong>:</p><ul><li>단일 진입점을 통해 다양한 리소스에 접근</li><li>목적: 클라이언트가 필요한 데이터를 정확히 요청할 수 있도록 함</li></ul><p><strong>특징</strong>:</p><ul><li><p>구조화된 형태의 리소스 관리</p></li><li><p>데이터베이스 쿼리와 유사한 접근 방식</p></li><li><p>단일 요청으로 복합적인 데이터 검색 가능</p></li></ul><p><strong>작동 원리</strong>:</p><ul><li>클라이언트가 단일 엔드포인트에 쿼리 전송</li><li>서버는 쿼리를 해석하여 필요한 데이터 검색</li><li>응답으로 요청된 데이터 구조 반환</li></ul><p><strong>구성 요소</strong>:</p><ul><li>단일 엔드포인트</li><li>쿼리 언어(예: GraphQL)</li><li>스키마(가능한 쿼리 정의)</li><li>리졸버(데이터 검색 로직)</li></ul><p><strong>쿼리 스타일 (GraphQL) 아키텍처</strong>:</p><ul><li>클라이언트가 쿼리를 정의하여 서버에 요청, 서버는 해당 데이터만 응답</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트                                      서버
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>|        |  POST /graphql                 |        |
</span></span><span class=line><span class=cl>|        | -----------------------------&gt; |        |
</span></span><span class=line><span class=cl>|        |  {query: &#34;…&#34;}                |GraphQL |
</span></span><span class=line><span class=cl>|        |                                |  API   |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>|        |  200 OK                        |        |
</span></span><span class=line><span class=cl>|        | &lt;----------------------------- |        |
</span></span><span class=line><span class=cl>|        |  {data: {…}}                 |        |
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span></code></pre></td></tr></table></div></div><p><strong>주요 기능</strong>:</p><ul><li><p>오버페칭(over-fetching)과 언더페칭(under-fetching) 문제 해결</p></li><li><p>단일 요청으로 복잡한 데이터 구조 검색</p></li><li><p>클라이언트 맞춤형 응답 구조</p></li></ul><h3 id=터널-스타일-tunnel-style>터널 스타일 (Tunnel Style)<a hidden class=anchor aria-hidden=true href=#터널-스타일-tunnel-style>#</a></h3><p><strong>핵심 개념과 목적</strong>:</p><ul><li>원격 함수 호출을 통한 API 구현</li><li>목적: 로컬 프로그래밍의 확장으로서 간편한 API 생성</li></ul><p><strong>특징</strong>:</p><ul><li>RPC(Remote Procedure Call) 방식 사용</li><li>함수 중심적 접근</li><li>개발자 친화적</li></ul><p><strong>작동 원리</strong>:</p><ul><li>클라이언트가 서버의 특정 함수 호출 요청</li><li>서버는 요청된 함수 실행 후 결과 반환</li><li>프로시저 호출과 유사한 방식으로 작동</li></ul><p><strong>구성 요소</strong>:</p><ul><li>서비스 정의(함수 명세)</li><li>직렬화 메커니즘(예: Protocol Buffers)</li><li>전송 프로토콜(예: HTTP/2)</li><li>클라이언트/서버 스텁(stub) 코드</li></ul><p><strong>터널 스타일 아키텍처</strong></p><ul><li>클라이언트가 서버의 함수를 원격으로 호출</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>클라이언트                                      서버
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span><span class=line><span class=cl>|        |  gRPC 호출                      |        |
</span></span><span class=line><span class=cl>|        | -----------------------------&gt; |        |
</span></span><span class=line><span class=cl>|클라이언트|  (Protocol Buffers)           | gRPC   |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>| 스텁    |                                | 서비스  |
</span></span><span class=line><span class=cl>|        |  응답                           |        |
</span></span><span class=line><span class=cl>|        | &lt;----------------------------- |        |
</span></span><span class=line><span class=cl>|        |  (Protocol Buffers)            |        |
</span></span><span class=line><span class=cl>+--------+                                +--------+
</span></span></code></pre></td></tr></table></div></div><p><strong>주요 기능</strong>:</p><ul><li><p>효율적인 바이너리 전송</p></li><li><p>강력한 타입 시스템</p></li><li><p>양방향 스트리밍 지원</p></li></ul><h3 id=이벤트-기반-스타일-event-based-style>이벤트 기반 스타일 (Event-based Style)<a hidden class=anchor aria-hidden=true href=#이벤트-기반-스타일-event-based-style>#</a></h3><p><strong>핵심 개념과 목적</strong>:</p><ul><li>이벤트 생성 및 구독 기반 통신</li><li>목적: 비동기 통신을 통한 시스템 간 느슨한 결합</li></ul><p><strong>특징</strong>:</p><ul><li>푸시 기반 통신 모델</li><li>생산자/소비자 패턴</li><li>비동기적 작동</li></ul><p><strong>작동 원리</strong>:</p><ul><li>이벤트 생산자가 이벤트 발생 시 메시지 브로커에 이벤트 발행</li><li>메시지 브로커가 이벤트를 구독자에게 전달</li><li>구독자는 자신이 관심 있는 이벤트 유형만 처리</li></ul><p><strong>구성 요소</strong>:</p><ul><li>이벤트 생산자</li><li>이벤트 소비자</li><li>메시지 브로커(예: Apache Kafka)</li><li>이벤트 형식 및 스키마</li></ul><p><strong>이벤트 기반 스타일 아키텍처</strong>:</p><ul><li>이벤트 발행자가 이벤트를 브로커에 발행, 구독자는 해당 이벤트를 처리</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                 +----------------+
</span></span><span class=line><span class=cl>                 |  메시지 브로커   |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                 | (Kafka/RabbitMQ)|
</span></span><span class=line><span class=cl>                 +----------------+
</span></span><span class=line><span class=cl>                    ^          |
</span></span><span class=line><span class=cl>                    |          |
</span></span><span class=line><span class=cl>   이벤트 발행       |          | 이벤트 구독
</span></span><span class=line><span class=cl>                    |          |
</span></span><span class=line><span class=cl>                    |          v
</span></span><span class=line><span class=cl>+----------------+  |          +----------------+
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>|                |  |          |                |
</span></span><span class=line><span class=cl>| 이벤트 생산자   +--+          | 이벤트 소비자   |
</span></span><span class=line><span class=cl>|                |             |                |
</span></span><span class=line><span class=cl>+----------------+             +----------------+
</span></span></code></pre></td></tr></table></div></div><p><strong>주요 기능</strong>:</p><ul><li>실시간 데이터 처리</li><li>시스템 간 느슨한 결합</li><li>확장성 있는 아키텍처 구성</li></ul><h3 id=실무에서-고려사항-및-주의할-점>실무에서 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-고려사항-및-주의할-점>#</a></h3><h4 id=리소스-스타일-resource-style-1>리소스 스타일 (Resource Style)<a hidden class=anchor aria-hidden=true href=#리소스-스타일-resource-style-1>#</a></h4><p><strong>고려사항</strong>:</p><ul><li>리소스 모델링: 비즈니스 개체를 적절한 리소스로 정의하는 것이 중요</li><li>URI 설계: 명확하고 일관된 명명 규칙 필요</li><li>버전 관리: API 변경 시 하위 호환성 관리 필요</li><li>보안: 인증 및 권한 부여 메커니즘 구현 필요</li></ul><p><strong>주의할 점</strong>:</p><ul><li><p>과도한 요청: 복잡한 작업에 여러 요청이 필요할 수 있음</p></li><li><p>리소스 간 관계 표현의 어려움</p></li><li><p>비동기 작업 처리가 어려울 수 있음</p></li><li><p>클라이언트 요구에 맞는 응답 구조 제공의 한계</p></li></ul><h4 id=하이퍼미디어-스타일-hypermedia-style-1>하이퍼미디어 스타일 (Hypermedia Style)<a hidden class=anchor aria-hidden=true href=#하이퍼미디어-스타일-hypermedia-style-1>#</a></h4><p><strong>고려사항</strong>:</p><ul><li>링크 관계 설계: 명확한 링크 의미와 관계 정의 필요</li><li>미디어 타입 선택: 적절한 하이퍼미디어 형식 선택(HAL, JSON-LD 등)</li><li>클라이언트 구현 복잡성: 클라이언트가 링크 기반 탐색 처리 필요</li></ul><p><strong>주의할 점</strong>:</p><ul><li>과도한 정보: 너무 많은 링크가 응답 크기 증가 가능</li><li>&ldquo;챗티(chatty)&rdquo; API: 정보 획득을 위해 여러 요청 필요 가능</li><li>클라이언트 개발 복잡성 증가</li><li>캐싱 전략이 더 복잡해질 수 있음</li></ul><h4 id=쿼리-스타일-query-style-1>쿼리 스타일 (Query Style)<a hidden class=anchor aria-hidden=true href=#쿼리-스타일-query-style-1>#</a></h4><p><strong>고려사항</strong>:</p><ul><li>스키마 설계: 명확한 데이터 모델과 관계 정의 필요</li><li>성능 최적화: 복잡한 쿼리 처리를 위한 최적화 필요</li><li>권한 관리: 데이터 접근 제어 메커니즘 필요</li></ul><p><strong>주의할 점</strong>:</p><ul><li>쿼리 복잡성: 클라이언트가 데이터 모델을 이해해야 함</li><li>캐싱 어려움: 동적 쿼리로 인한 캐싱 전략 복잡성</li><li>속도 제한(rate limiting) 구현의 어려움</li><li>보안 위험: 과도하게 복잡한 쿼리가 서버 리소스 소모 가능</li></ul><h4 id=터널-스타일-tunnel-style-1>터널 스타일 (Tunnel Style)<a hidden class=anchor aria-hidden=true href=#터널-스타일-tunnel-style-1>#</a></h4><p><strong>고려사항</strong>:</p><ul><li>서비스 정의: 명확한 함수 인터페이스 설계 필요</li><li>직렬화 효율성: 효율적인 데이터 교환 형식 선택</li><li>언어 간 호환성: 다양한 클라이언트 언어 지원 고려</li></ul><p><strong>주의할 점</strong>:</p><ul><li>유지보수 어려움: REST API보다 업데이트와 유지관리가 어려움</li><li>브라우저 지원 제한: 특수 클라이언트 라이브러리 필요</li><li>디버깅 복잡성: 바이너리 형식으로 인한 디버깅 어려움</li><li>게이트웨이와 프록시 통합 문제 가능</li></ul><h4 id=이벤트-기반-스타일-event-based-style-1>이벤트 기반 스타일 (Event-based Style)<a hidden class=anchor aria-hidden=true href=#이벤트-기반-스타일-event-based-style-1>#</a></h4><p><strong>고려사항</strong>:</p><ul><li>이벤트 모델링: 명확한 이벤트 유형과 구조 정의 필요</li><li>메시지 브로커 선택: 적절한 메시징 시스템 선택(Kafka, RabbitMQ 등)</li><li>이벤트 순서 보장: 필요 시 이벤트 순서 보장 메커니즘 구현</li></ul><p><strong>주의할 점</strong>:</p><ul><li>구현 복잡성: 다른 스타일보다 구현 시간이 더 소요됨</li><li>중복 메시지: 잘못 설계 시 중복 메시지 발생 가능</li><li>오류 처리의 어려움: 비동기 특성으로 인한 오류 추적 복잡성</li><li>디버깅과 모니터링 어려움: 이벤트 흐름 추적이 어려울 수 있음</li></ul><h3 id=api-스타일-비교>API 스타일 비교<a hidden class=anchor aria-hidden=true href=#api-스타일-비교>#</a></h3><h4 id=기본-특성-비교>기본 특성 비교<a hidden class=anchor aria-hidden=true href=#기본-특성-비교>#</a></h4><table><thead><tr><th>특성</th><th>리소스 기반</th><th>하이퍼미디어 기반</th><th>쿼리 기반</th><th>터널 기반</th><th>이벤트 기반</th></tr></thead><tbody><tr><td>중심 개념</td><td>리소스(명사)</td><td>링크와 상태 전이</td><td>데이터 요청</td><td>프로시저/함수</td><td>이벤트와 알림</td></tr><tr><td>통신 패턴</td><td>요청-응답</td><td>요청-응답</td><td>요청-응답</td><td>요청-응답</td><td>발행-구독</td></tr><tr><td>상태 관리</td><td>무상태</td><td>하이퍼미디어 상태</td><td>무상태</td><td>무상태/상태 가능</td><td>이벤트 스트림</td></tr><tr><td>대표 구현</td><td>REST</td><td>HATEOAS, HAL</td><td>GraphQL, OData</td><td>SOAP, JSON-RPC, gRPC</td><td>WebSocket, MQTT, Kafka</td></tr><tr><td>주요 사용 사례</td><td>웹 API, 모바일 백엔드</td><td>워크플로우 기반 앱</td><td>데이터 집약적 앱</td><td>프로시저 중심 시스템</td><td>실시간 앱, IoT</td></tr></tbody></table><h4 id=기술적-특성-비교>기술적 특성 비교<a hidden class=anchor aria-hidden=true href=#기술적-특성-비교>#</a></h4><table><thead><tr><th>특성</th><th>리소스 기반</th><th>하이퍼미디어 기반</th><th>쿼리 기반</th><th>터널 기반</th><th>이벤트 기반</th></tr></thead><tbody><tr><td>데이터 형식</td><td>JSON, XML</td><td>HAL, JSON-LD, Collection+JSON</td><td>JSON, GraphQL 스키마</td><td>SOAP XML, Protocol Buffers</td><td>JSON, Avro, CloudEvents</td></tr><tr><td>통신 프로토콜</td><td>HTTP</td><td>HTTP</td><td>HTTP, WebSocket</td><td>HTTP, TCP/IP</td><td>WebSocket, MQTT, AMQP</td></tr><tr><td>캐싱 용이성</td><td>높음</td><td>높음</td><td>중간</td><td>낮음</td><td>낮음</td></tr><tr><td>계약 정의</td><td>OpenAPI, RAML</td><td>OpenAPI + 링크</td><td>GraphQL 스키마, OData 메타데이터</td><td>WSDL, Protobuf</td><td>AsyncAPI, CloudEvents</td></tr><tr><td>타입 안전성</td><td>선택적</td><td>선택적</td><td>높음</td><td>매우 높음</td><td>다양함</td></tr></tbody></table><h4 id=개발-및-사용-측면-비교>개발 및 사용 측면 비교<a hidden class=anchor aria-hidden=true href=#개발-및-사용-측면-비교>#</a></h4><table><thead><tr><th>측면</th><th>리소스 기반</th><th>하이퍼미디어 기반</th><th>쿼리 기반</th><th>터널 기반</th><th>이벤트 기반</th></tr></thead><tbody><tr><td>학습 곡선</td><td>낮음</td><td>중간</td><td>중간~높음</td><td>중간</td><td>중간~높음</td></tr><tr><td>개발자 친화성</td><td>높음</td><td>중간</td><td>높음</td><td>중간</td><td>중간</td></tr><tr><td>클라이언트 복잡성</td><td>낮음</td><td>중간</td><td>중간</td><td>중간~높음</td><td>높음</td></tr><tr><td>서버 복잡성</td><td>낮음</td><td>높음</td><td>높음</td><td>중간</td><td>높음</td></tr><tr><td>코드 생성 도구</td><td>많음</td><td>제한적</td><td>많음</td><td>풍부함</td><td>증가 중</td></tr></tbody></table><h4 id=성능-및-확장성-비교>성능 및 확장성 비교<a hidden class=anchor aria-hidden=true href=#성능-및-확장성-비교>#</a></h4><table><thead><tr><th>측면</th><th>리소스 기반</th><th>하이퍼미디어 기반</th><th>쿼리 기반</th><th>터널 기반</th><th>이벤트 기반</th></tr></thead><tbody><tr><td>오버페칭 문제</td><td>있음</td><td>있음</td><td>없음/적음</td><td>중간</td><td>해당 없음</td></tr><tr><td>언더페칭 문제</td><td>있음</td><td>있음</td><td>없음/적음</td><td>중간</td><td>해당 없음</td></tr><tr><td>네트워크 효율성</td><td>중간</td><td>낮음</td><td>높음</td><td>중간~높음</td><td>높음</td></tr><tr><td>실시간 능력</td><td>제한적</td><td>제한적</td><td>구독으로 가능</td><td>제한적</td><td>기본 지원</td></tr><tr><td>대규모 확장성</td><td>좋음</td><td>좋음</td><td>좋음</td><td>좋음</td><td>매우 좋음</td></tr></tbody></table><h4 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h4><table><thead><tr><th>API 스타일</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>리소스 기반</td><td>- 직관적이고 이해하기 쉬움<br>- HTTP 인프라와 완벽하게 통합<br>- 풍부한 도구 및 라이브러리<br>- 효과적인 캐싱</td><td>- 오버페칭/언더페칭 문제<br>- 여러 리소스 조회에 비효율적<br>- 버전 관리 복잡성</td></tr><tr><td>하이퍼미디어 기반</td><td>API 변경 시 클라이언트 영향 최소화<br>- 자연스러운 API 탐색 가능<br>- 워크플로우 중심 상호작용에 적합</td><td>- 구현 복잡성 증가<br>- 대역폭 사용량 증가<br>- 클라이언트 구현 어려움</td></tr><tr><td>쿼리 기반</td><td>- 클라이언트가 필요한 데이터만 요청<br>- 오버페칭/언더페칭 문제 해결<br>- 강력한 타입 시스템</td><td>- 서버 구현 복잡성<br>- 캐싱 전략 복잡<br>- 쿼리 복잡도 관리 필요</td></tr><tr><td>터널 기반</td><td>- 엄격한 계약과 타입 안전성<br>- 바이너리 직렬화로 높은 성능<br>- 양방향 스트리밍 지원</td><td>HTTP 기능 활용도 낮음<br>- 클라이언트-서버 결합도 증가<br>- 브라우저 지원 제한적</td></tr><tr><td>이벤트 기반</td><td>- 실시간 데이터 처리<br>- 시스템 간 느슨한 결합<br>- 비동기 처리로 확장성 향상</td><td>- 복잡한 설계 및 디버깅<br>- 이벤트 순서 및 일관성 관리<br>- 초기 설정 복잡성</td></tr></tbody></table><h4 id=산업-및-사용-사례-비교>산업 및 사용 사례 비교<a hidden class=anchor aria-hidden=true href=#산업-및-사용-사례-비교>#</a></h4><table><thead><tr><th>API 스타일</th><th>적합한 산업</th><th>주요 사용 사례</th><th>대표적 예시</th></tr></thead><tbody><tr><td>리소스 기반</td><td>웹 서비스, SaaS</td><td>CRUD 작업 중심 애플리케이션</td><td>GitHub API, Twitter API</td></tr><tr><td>하이퍼미디어 기반</td><td>금융, 워크플로우 중심 산업</td><td>복잡한 비즈니스 프로세스, 자기 발견형 API</td><td>PayPal API (HATEOAS 부분)</td></tr><tr><td>쿼리 기반</td><td>데이터 집약적 서비스, 모바일 앱</td><td>대시보드, 분석 도구, 커스텀 보고서</td><td>GitHub GraphQL API, Facebook GraphQL</td></tr><tr><td>터널 기반</td><td>엔터프라이즈, 금융, 통신</td><td>마이크로서비스 간 통신, 레거시 시스템 통합</td><td>Salesforce SOAP API, Google gRPC 서비스</td></tr><tr><td>이벤트 기반</td><td>IoT, 실시간 애플리케이션, 게임</td><td>채팅 앱, 알림 시스템, 실시간 대시보드</td><td>Slack의 실시간 메시징, IoT 장치 통신</td></tr></tbody></table><h3 id=api-스타일을-선택할-때-고려해야-할-주요-요소>API 스타일을 선택할 때 고려해야 할 주요 요소<a hidden class=anchor aria-hidden=true href=#api-스타일을-선택할-때-고려해야-할-주요-요소>#</a></h3><table><thead><tr><th>주요 요소</th><th>설명 및 고려사항</th></tr></thead><tbody><tr><td>비즈니스/기술 요구</td><td>프로젝트 목적, 주요 기능, 활용 사례, 확장성</td></tr><tr><td>호환성</td><td>언어/플랫폼, 프로토콜, 데이터 포맷</td></tr><tr><td>보안</td><td>인증/인가, 암호화, 입력 검증, 속도 제한, CORS</td></tr><tr><td>신뢰성/장애대응</td><td>장애 복구, 데이터 일관성, 중복 처리, DLQ</td></tr><tr><td>유지보수/미래대비</td><td>버전 관리, 하위 호환성, 문서화, 커뮤니티 지원, 자동화 도구</td></tr><tr><td>성능/확장성</td><td>응답 속도, 캐싱, 비동기 처리, 부하 분산</td></tr><tr><td>운영 난이도</td><td>학습 곡선, 도입/운영 복잡성, 디버깅/모니터링 용이성</td></tr><tr><td>비용/라이선스</td><td>도구/서비스 비용, 라이선스 정책</td></tr><tr><td>데이터 일관성</td><td>Strong/Eventually Consistency, 트랜잭션 관리</td></tr><tr><td>유연성</td><td>다양한 활용 사례 지원, 커스터마이징 가능성</td></tr></tbody></table><h3 id=api-스타일별-확장성-요소>API 스타일별 확장성 요소<a hidden class=anchor aria-hidden=true href=#api-스타일별-확장성-요소>#</a></h3><table><thead><tr><th>스타일</th><th>확장성 강점</th><th>확장성 도전 과제</th></tr></thead><tbody><tr><td><strong>리소스</strong></td><td>Stateless, 캐싱 용이</td><td>Over-fetching 문제</td></tr><tr><td><strong>쿼리</strong></td><td>정밀한 데이터 요청</td><td>복잡 쿼리 성능 저하</td></tr><tr><td><strong>터널</strong></td><td>고성능 이진 통신</td><td>서비스 디스커버리 복잡성</td></tr><tr><td><strong>이벤트 기반</strong></td><td>생산자/소비자 독립 확장</td><td>이벤트 순서 관리 복잡성</td></tr><tr><td><strong>하이퍼미디어</strong></td><td>클라이언트-서버 결합도 감소</td><td>&ldquo;Chatty&rdquo; API 위험</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>API (애플리케이션 프로그래밍 인터페이스)</td><td>소프트웨어 구성 요소가 서로 통신할 수 있도록 하는 메커니즘</td></tr><tr><td>REST (Representational State Transfer)</td><td>로이 필딩이 제안한 분산 하이퍼미디어 시스템을 위한 아키텍처 스타일</td></tr><tr><td>HATEOAS (Hypermedia as the Engine of Application State)</td><td>클라이언트가 하이퍼미디어 링크를 통해 동적으로 API를 탐색할 수 있게 하는 REST의 제약 조건</td></tr><tr><td>GraphQL</td><td>클라이언트가 필요한 데이터 구조를 정확히 요청할 수 있는 쿼리 언어</td></tr><tr><td>RPC (Remote Procedure Call)</td><td>원격 서버의 프로시저를 로컬 시스템에서 호출하는 것처럼 실행할 수 있게 하는 기술</td></tr><tr><td>gRPC</td><td>Google에서 개발한 오픈소스 RPC 프레임워크</td></tr><tr><td>Protocol Buffers</td><td>구조화된 데이터를 직렬화하기 위한 바이너리 형식 메커니즘</td></tr><tr><td>HTTP/2</td><td>HTTP 프로토콜의 두 번째 주요 버전으로, 성능 향상에 중점을 둠</td></tr><tr><td>WebSocket</td><td>클라이언트와 서버 간 지속적인 양방향 연결을 제공하는 통신 프로토콜</td></tr><tr><td>SSE (Server-Sent Events)</td><td>서버에서 클라이언트로 자동 업데이트를 보내는 기술</td></tr><tr><td>Webhook</td><td>특정 이벤트가 발생할 때 알림을 제공하는 HTTP 콜백</td></tr><tr><td>Apache Kafka</td><td>고성능 분산 스트리밍 플랫폼</td></tr><tr><td>Pub-Sub (Publish-Subscribe)</td><td>발행자가 메시지를 특정 수신자에게 직접 보내지 않고 채널에 게시하면, 구독자가 관심 있는 채널에서 메시지를 수신하는 메시징 패턴</td></tr><tr><td>JSON (JavaScript Object Notation)</td><td>데이터 교환을 위한 경량 텍스트 기반 형식</td></tr><tr><td>HAL (Hypertext Application Language)</td><td>JSON 또는 XML을 확장하여 하이퍼링크를 포함하는 형식</td></tr><tr><td>OpenAPI</td><td>RESTful API를 설계, 구축, 문서화하기 위한 사양</td></tr><tr><td>오버페칭 (Over-fetching)</td><td>필요한 것보다 더 많은 데이터를 가져오는 현상</td></tr><tr><td>언더페칭 (Under-fetching)</td><td>필요한 데이터를 가져오기 위해 여러 요청이 필요한 현상</td></tr><tr><td>직렬화 (Serialization)</td><td>데이터 구조를 전송이나 저장에 적합한 형식으로 변환하는 과정</td></tr><tr><td>API 게이트웨이</td><td>API 호출을 중개하고 라우팅, 변환, 모니터링 등의 추가 기능을 제공하는 서비스</td></tr><tr><td>마이크로서비스</td><td>작고 독립적인 서비스로 구성된 소프트웨어 아키텍처 접근 방식</td></tr><tr><td>AsyncAPI</td><td>비동기 API를 위한 명세로, 이벤트 기반 아키텍처를 문서화하는 데 사용됨</td></tr><tr><td>CQRS (Command Query Responsibility Segregation)</td><td>명령(데이터 변경)과 쿼리(데이터 조회)를 분리하는 아키텍처 패턴</td></tr><tr><td>Event Sourcing</td><td>상태 변경을 이벤트 시퀀스로 저장하는 방식으로, 특정 시점의 상태를 재구성할 수 있음</td></tr><tr><td>Rate Limiting</td><td>API 사용량 제한 기능</td></tr><tr><td>DLQ</td><td>Dead Letter Queue. 처리 실패 이벤트를 별도 저장해 재처리하는 큐</td></tr><tr><td>Eventual Consistency</td><td>분산 시스템에서 데이터가 결국에는 일관된 상태로 수렴하는 모델</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.redhat.com/architect/api-styles>How to choose the right API style and technology for your software architecture</a></li><li><a href=https://www.redhat.com/ko/technologies/jboss-middleware/api-management>Red Hat API 관리 솔루션</a></li><li><a href=https://restfulapi.net/>REST API 설계 가이드</a></li><li><a href=https://graphql.org/learn/>GraphQL 공식 문서</a></li><li><a href=https://grpc.io/docs/>gRPC 공식 문서</a></li><li><a href=https://kafka.apache.org/documentation/>Apache Kafka 문서</a></li><li><a href=https://microservices.io/patterns/apigateway.html>마이크로서비스 아키텍처에서의 API 설계</a></li><li><a href=https://en.wikipedia.org/wiki/HATEOAS>HATEOAS 원칙</a></li><li><a href=https://developers.redhat.com/blog/2019/12/16/5-api-gateway-pattern-s-you-should-know>Red Hat Developer - API 아키텍처의 5가지 유형</a></li><li><a href=https://restfulapi.net/hateoas/>REST API와 HATEOAS</a></li><li><a href=https://www.asyncapi.com/>AsyncAPI 이니셔티브</a></li><li><a href=https://aws.amazon.com/ko/event-driven-architecture/>이벤트 기반 아키텍처 소개</a></li><li><a href=https://stateless.group/hal_specification.html>HAL 명세</a></li><li><a href=https://martinfowler.com/eaaDev/EventSourcing.html>Martin Fowler - 이벤트 소싱</a></li><li><a href=https://www.jsonrpc.org/specification>JSON-RPC 2.0 명세</a></li><li><a href=http://dret.net/lectures/www-2019/2019-05-www-api-styles.pdf>dret.net - API 스타일 비교 PDF</a></li><li><a href=https://apisix.apache.org/blog/2022/12/06/choose-the-right-api-style-technology/>Apache APISIX - API 스타일 선택 방법</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GraphQL</h2></header><div class=entry-content><p>GraphQL GraphQL은 API를 위한 쿼리 언어이자 서버 측에서 데이터를 효율적으로 가져오기 위한 런타임 환경이다. 2012년 Facebook에서 내부적으로 개발되었고, 2015년에 공개적으로 출시되었다.
주요 특징:
클라이언트가 필요한 데이터만 정확히 요청할 수 있음 여러 리소스를 하나의 요청으로 가져올 수 있음 강력한 타입 시스템으로 API의 안정성 보장 자체 문서화(Self-documenting) 기능 제공 GraphQL Vs REST REST API와 비교했을 때 GraphQL의 주요 차이점:
특성 GraphQL REST 엔드포인트 단일 엔드포인트 다중 엔드포인트 데이터 가져오기 필요한 것만 정확히 요청 과도하거나 부족한 데이터 전송 가능 버전 관리 점진적 진화 가능 일반적으로 명시적 버전 필요 상태 코드 항상 200 OK (오류는 응답 내에) 다양한 HTTP 상태 코드 캐싱 복잡함 (별도 솔루션 필요) HTTP 캐싱 활용 GraphQL의 핵심 개념 스키마와 타입 시스템 GraphQL API는 스키마를 통해 정의된다. 스키마는 사용 가능한 모든 데이터 타입과 관계, 작업을 설명한다.
...</p></div><footer class=entry-footer><span title='2024-10-19 03:22:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/graphql/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>