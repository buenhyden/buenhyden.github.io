<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Development & Engineering | hyunyoun's Blog</title><meta name=keywords content="Software-Development-and-Engineering"><meta name=description content="Software Development & Engineering - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-development--engineering/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Development & Engineering"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Development & Engineering"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Development \u0026 Engineering","item":"https://buenhyden.github.io/posts/software-development--engineering/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Software Development & Engineering</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Design Principles</h2></header><div class=entry-content><p>소프트웨어 설계 원칙 (Design Principles) 소프트웨어 설계 원칙 (Design Principles) 은 소프트웨어 및 시스템 설계의 근간이 되는 원칙으로, 시스템의 구조와 품질을 결정하는 데 중요한 역할을 한다. 이러한 원칙들은 유지보수성, 확장성, 성능, 보안 등을 향상시키기 위해 설계 단계에서부터 고려되어야 하며, SOLID, DRY, KISS, YAGNI 등의 원칙들이 포함된다. 이러한 원칙들을 이해하고 적용함으로써 고품질의 소프트웨어를 개발할 수 있다.
핵심 개념 소프트웨어 설계 원칙은 소프트웨어 시스템을 설계할 때 따라야 하는 지침과 규칙의 집합으로, 시스템의 품질과 유지보수성을 향상시키는 데 목적이 있다.
...</p></div><footer class=entry-footer><span title='2025-05-29 03:25:00 +0000 UTC'>May 29, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Design Principles" href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Scenario Testing vs Use Case Testing</h2></header><div class=entry-content><p>Scenario Testing vs. Use Case Testing Scenario Testing과 Use Case Testing은 소프트웨어 테스팅 기법으로, 사용자 관점에서 시스템의 기능과 동작을 검증하는 데 사용된다.
두 기법은 유사한 점이 있지만, 접근 방식과 세부 사항에서 차이가 있다.
비교 항목 Scenario Testing Use Case Testing 정의 실제 사용자의 행동과 상황을 기반으로 한 현실적인 시나리오를 통해 시스템을 테스트하는 방법 사용자와 시스템 간의 상호작용을 구조화된 형식으로 정의하고 테스트하는 방법 테스트 관점 사용자 중심적이며, 실제 업무 상황과 맥락을 중요시함 시스템 중심적이며, 기능적 정확성과 완전성을 중요시함 목적 실제 사용 환경에서의 시스템 동작을 검증 시스템의 기능적 요구사항을 검증 구조화 정도 자유로운 형식으로, 스토리텔링 방식의 서술적 구조 체계적이고 형식적인 구조 (기본 흐름, 대체 흐름, 예외 흐름) 테스트 범위 여러 기능이나 프로세스를 걸쳐 있는 end-to-end 시나리오 주로 단일 기능이나 프로세스에 초점 테스트 설계 자유로운 형식으로 다양한 “가정” 상황을 포함 유스케이스 문서의 기본 흐름과 대체 흐름을 따름 테스트 케이스 도출 다양한 소스(사용자 피드백, 시장 조사 등)에서 시나리오 개발 유스케이스 문서에서 직접 테스트 케이스를 도출 상황 맥락 사용자의 동기, 감정, 환경 등 풍부한 맥락 정보 포함 객관적이고 기술적인 상호작용 위주의 맥락 문서화 방식 서술적이고 이야기 형식의 문서화 구조화되고 단계별로 정형화된 문서화 적합한 상황 사용자 경험이 중요한 애플리케이션, 복잡한 업무 프로세스 명확한 기능 요구사항이 있는 시스템, 트랜잭션 기반 애플리케이션 테스트 설계 난이도 실제 사용자 경험에 대한 이해가 필요하며, 창의적인 시나리오 도출이 중요 체계적인 분석과 문서화 능력이 필요하며, 기술적 이해가 중요 유지보수성 시나리오 수정이 비교적 자유롭고 유연함 구조화된 형식으로 인해 변경 관리가 체계적 재사용성 특정 상황에 특화된 시나리오로 재사용이 제한적 표준화된 형식으로 인해 재사용이 용이 커버리지 측정 시나리오 기반의 정성적 측정이 주로 이루어짐 흐름 기반의 정량적 측정이 가능 테스트 자동화 복잡한 시나리오로 인해 자동화가 어려울 수 있음 구조화된 형식으로 인해 자동화가 비교적 용이 장점 예상치 못한 오류 발견에 효과적, 사용자 경험 개선에 도움 요구사항 검증에 효과적, 체계적인 테스트 가능 단점 모든 가능한 시나리오를 고려하기 어려움 유스케이스 문서의 품질에 의존적 실제 프로젝트에서는 이 두 방법을 상호 보완적으로 사용하는 것이 효과적이다.
예를 들어, Use Case Testing으로 기본적인 기능 정확성을 검증하고, Scenario Testing으로 실제 사용 환경에서의 사용성과 통합성을 검증하는 방식으로 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-05 17:12:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scenario Testing vs Use Case Testing" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/test-cases-and-scenarios/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적테스트(Dynamic Test) vs 정적테스트(Static Test)</h2></header><div class=entry-content><p>동적테스트(Dynamic Test)와 정적테스트(Static Test) 동적테스트 (Dynamic Test)과 정적테스트(Static Test)
소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.
이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.
효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.
예를 들어:
개발 초기 단계: 정적 테스팅으로 기본적인 문제 해결 코드 리뷰로 설계 문제 조기 발견 개발 중기: 단위 테스트로 개별 기능 검증 통합 테스트로 모듈 간 상호작용 확인 개발 후기: 시스템 테스트로 전체 기능 검증 성능 테스트로 실제 환경 적합성 확인 동적 테스트 (Dynamic Test) 소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.
소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.
소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:35:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적테스트(Dynamic Test) vs 정적테스트(Static Test)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/static-vs-dynamic-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Editors</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-08-26 04:51:00 +0000 UTC'>August 26, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Editors" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/development-tools--environment/code-editors/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Requirements & Planning</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-08-23 02:11:00 +0000 UTC'>August 23, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Requirements & Planning" href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/requirements--planning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>POSA(Pattern-Oriented Software Architecture)</h2></header><div class=entry-content><p>POSA(Pattern-Oriented Software Architecture) POSA(Pattern-Oriented Software Architecture) 는 소프트웨어 아키텍처 설계를 위한 패턴 시스템으로, 재사용 가능한 솔루션을 제시하여 복잡한 시스템의 구조화를 돕는다. 1996 년 첫 출간된 POSA 시리즈는 아키텍처 패턴, 디자인 패턴, 이디엄 (Idiom) 을 체계적으로 분류하며, GoF 디자인 패턴보다 상위 수준의 구조적 접근을 강조한다.
POSA 시리즈는 5 권으로 구성되어 있으며, 각 권은 서로 다른 영역의 패턴에 초점을 맞추고 있다:
권 번호 제목 저자 출판 연도 주요 내용 POSA 1 패턴 지향 소프트웨어 아키텍처 - 아키텍처 패턴 시스템 Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, Michael Stal 1996 레이어드 (Layered), 파이프 - 필터 (Pipe-Filter), 블랙보드 (Blackboard), 브로커 (Broker) 등 기본적인 아키텍처 패턴 소개 및 시스템 활용법 제시 POSA 2 패턴 지향 소프트웨어 아키텍처 - 동시성 및 네트워킹 패턴 Douglas Schmidt, Michael Stal, Hans Rohnert, Frank Buschmann 2000 리액터 (Reactor), 프로액터 (Proactor), 액셉터 - 커넥터 (Acceptor-Connector) 등 동시성, 분산 시스템, 네트워킹 패턴 중심 POSA 3 패턴 지향 소프트웨어 아키텍처 - 리소스 관리 패턴 Michael Kircher, Prashant Jain 2004 룩업 (Lookup), 이진 객체 (Binary Object), 캐싱 (Caching), 레지스트리 (Registry) 등 리소스 관리 중심 패턴 소개 POSA 4 패턴 지향 소프트웨어 아키텍처 - 패턴 언어를 이용한 분산 컴퓨팅 Frank Buschmann, Kevin Henney, Douglas C. Schmidt 2007 분산 컴퓨팅 환경에서 패턴 언어를 활용한 설계 방법론 제시 POSA 5 패턴 지향 소프트웨어 아키텍처 - 패턴과 패턴 언어 Frank Buschmann, Kevin Henney, Douglas C. Schmidt 2007 패턴 작성, 평가, 적용의 메타 패턴적 접근법과 패턴 언어 구성 전략 제시 POSA 와 관련된 중요 컨셉 패턴 맵핑 (Pattern Mapping): 추상적 패턴을 구체적 구현으로 변환하는 과정 패턴의 일반적 구조를 특정 기술 스택에 적용하는 방법 패턴 시스템 진화 (Pattern System Evolution): 패턴 시스템이 시간에 따라 변화하고 발전하는 방식 새로운 기술과 패러다임에 따른 패턴 적응 및 확장 안티패턴 (Anti-patterns): 흔히 발생하지만 문제를 야기하는 잘못된 설계 사례 POSA 에서는 안티패턴을 식별하고 해결하는 방법 제시 패턴 발견 프로세스 (Pattern Mining Process): 실제 시스템 설계 경험에서 패턴을 추출하는 체계적 방법 패턴의 문서화, 검증, 개선 과정 핵심 개념 패턴 지향 설계 (Pattern-Oriented Design)
POSA 의 기본 철학은 검증된 디자인 패턴을 사용하여 소프트웨어 설계 문제를 해결하는 것이다. 패턴은 특정 컨텍스트에서 반복적으로 발생하는 문제에 대한 일반화된 해결책이다.
...</p></div><footer class=entry-footer><span title='2025-04-05 01:31:00 +0000 UTC'>April 5, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to POSA(Pattern-Oriented Software Architecture)" href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-patterns/posa/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HIPAA</h2></header><div class=entry-content><p>HIPAA (Health Insurance Portability and Accountability Act) HIPAA는 1996년 미국에서 제정된 법률로, 의료 정보의 보호와 의료보험의 이식성을 보장하기 위한 규정을 제공한다. 이는 의료 데이터의 프라이버시와 보안을 강화하고, 전자적 의료 데이터 관리의 표준화를 통해 효율성과 신뢰성을 높이는 데 중점을 둔다.
HIPAA의 주요 목적 의료보험 이식성 보장:
직장을 변경하거나 실직한 근로자가 기존의 의료보험 혜택을 유지할 수 있도록 지원. 기존 질환(pre-existing condition)을 이유로 보험 가입을 거부하거나 제한하지 못하도록 규정. 의료 데이터 보호:
전자적 방식으로 저장 및 전송되는 개인 건강 정보(PHI, Protected Health Information)의 프라이버시와 보안 보장. 무단 접근, 데이터 유출, 사기 및 남용 방지. 의료 시스템 효율화:
...</p></div><footer class=entry-footer><span title='2025-04-01 02:23:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HIPAA" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/quality--compliance/compliance--governance/compliance-governance/regulatory-standards/hipaa/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Documentation</h2></header><div class=entry-content><p>API Documentation API 문서화란 API의 기능, 사용 방법, 엔드포인트, 매개변수, 응답 형식 등을 설명하는 기술 문서를 말한다. 잘 작성된 API 문서는 개발자가 API를 빠르게 이해하고 효과적으로 구현할 수 있도록 도와준다.
API 문서화가 중요한 이유는 다음과 같다:
개발자 경험(DX) 향상: 명확한 문서는 API 사용 과정에서 마찰을 줄이고 개발자 만족도를 높인다. 채택률 증가: 이해하기 쉬운 문서는 새로운 사용자의 API 채택을 촉진한다. 지원 비용 감소: 좋은 문서는 기술 지원 요청과 관련 비용을 줄인다. 오류 감소: 명확한 사용 지침은 구현 오류를 줄여 준다. 버전 관리 지원: 문서는 API 진화 과정을 추적하고 버전 간 변경 사항을 명확히 한다. API 문서화의 구성 요소 효과적인 API 문서는 다음과 같은 핵심 구성 요소를 포함해야 한다:
...</p></div><footer class=entry-footer><span title='2025-02-12 01:58:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Documentation" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/documentation/code-documentation/api-docs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Personal Identifiable Information (PII)</h2></header><div class=entry-content><p>Personal Identifiable Information (PII) 개인 식별 정보(Personal Identifiable Information, PII)는 개인의 신원을 식별하거나 추적하는 데 사용될 수 있는 정보를 의미한다. 디지털 시대의 도래와 함께 PII의 중요성과 그에 대한 보호 필요성이 크게 증가했다.
PII의 개념 및 정의 정의 개인 식별 정보(PII)는 단독으로 또는 다른 정보와 결합하여 특정 개인을 식별, 연락, 위치 파악할 수 있게 하는 정보이다. 다양한 기관과 법률에 따라 PII의 정확한 정의는 다소 차이가 있을 수 있으나, 기본적인 개념은 동일하다.
...</p></div><footer class=entry-footer><span title='2025-02-02 03:32:00 +0000 UTC'>February 2, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Personal Identifiable Information (PII)" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/quality--compliance/compliance--governance/compliance-governance/regulatory-standards/pii/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Verification and Validation</h2></header><div class=entry-content><p>Validation and Verification 소프트웨어 테스팅에서 Validation과 Verification은 서로 다른 관점과 목적을 가지고 있다.
Verification은 “제품을 올바르게 만들고 있는가?“를 확인하는 과정이고, Validation은 “올바른 제품을 만들고 있는가?“를 확인하는 과정이다.
이러한 근본적인 차이는 테스트 방법과 접근 방식에 큰 영향을 미친다.
Verification Verification은 “우리가 제품을 올바르게 만들고 있는가?” 라는 질문에 답하는 프로세스로, 개발 과정 중에 제품이 명세된 요구사항과 설계 문서에 따라 정확하게 구현되고 있는지를 검증한다.
개발자와 테스터가 수행하며, 코드 레벨에서의 정확성과 기술적 완성도를 중요시한다.
예를 들어, 특정 함수가 입력값에 대해 정확한 출력값을 반환하는지, 데이터베이스 쿼리가 예상대로 작동하는지 등을 확인한다.
...</p></div><footer class=entry-footer><span title='2024-11-05 08:03:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Verification and Validation" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/verification-and-validation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>