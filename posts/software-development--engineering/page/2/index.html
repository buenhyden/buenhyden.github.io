<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Development & Engineering | hyunyoun's Blog</title><meta name=keywords content="Software-Development-and-Engineering"><meta name=description content="Software Development & Engineering - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-development--engineering/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Development & Engineering"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Development & Engineering"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Development \u0026 Engineering","item":"https://buenhyden.github.io/posts/software-development--engineering/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Software Development & Engineering</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>기본 테스팅 (Fundamental Testing)</h2></header><div class=entry-content><p>기본 테스팅 (Fundamental Testing) Fundamental testing은 소프트웨어 테스팅의 기본적인 프로세스와 원칙을 의미한다.
이는 소프트웨어의 품질을 보장하기 위한 체계적인 접근 방식을 제공한다.
Fundamental testing process는 다음과 같은 주요 단계로 구성된다:
계획 및 통제 (Planning and Control)
테스트의 범위, 목표, 위험을 결정한다. 필요한 리소스를 식별하고 일정을 수립한다. 분석 및 설계 (Analysis and Design)
테스트 조건을 식별한다. 테스트 케이스를 설계한다. 테스트 환경을 준비한다. 구현 및 실행 (Implementation and Execution)
테스트 케이스를 우선순위화하고 실행한다. 결과를 기록하고 결함을 보고한다. 종료 기준 평가 및 보고 (Evaluating Exit Criteria and Reporting)
...</p></div><footer class=entry-footer><span title='2024-11-04 04:05:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 기본 테스팅 (Fundamental Testing)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/fundamental-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>전문화된 테스팅 (Specialized Testing)</h2></header><div class=entry-content><p>전문화된 테스팅 (Specialized Testing) Specialized Testing은 소프트웨어 테스팅의 한 분야로, 특정 영역이나 기능에 초점을 맞춘 심층적인 테스트 방식이다.
이는 일반적인 테스팅 방법으로는 발견하기 어려운 문제점들을 식별하고 해결하는 데 중점을 둔다.
Specialized Testing의 주요 특징 특정 영역 집중: 성능, 보안, 호환성 등 특정 측면에 집중한다. 심층적 분석: 일반 테스트보다 더 깊이 있는 분석을 수행한다. 전문 지식 활용: 해당 분야의 전문가들이 테스트를 수행한다. Specialized Testing의 종류 성능 테스팅: 부하 테스트, 스트레스 테스트, 확장성 테스트 등을 포함한다. 보안 테스팅: 취약점 식별 및 보안 위협에 대한 대응을 테스트한다. 호환성 테스팅: 다양한 환경에서의 소프트웨어 작동을 확인한다. 모바일 앱 테스팅: 모바일 기기 특성을 고려한 테스트를 수행한다. AI/ML 테스팅: 인공지능과 머신러닝 알고리즘의 정확성을 검증한다. IoT 테스팅: 사물인터넷 기기와의 연동을 테스트한다. Specialized Testing의 중요성 품질 향상: 특정 영역에 대한 깊이 있는 테스트로 소프트웨어 품질을 크게 개선한다. 위험 감소: 초기에 문제를 발견하여 출시 후 발생할 수 있는 문제를 예방한다. 사용자 만족도 증가: 특정 기능의 완성도를 높여 사용자 경험을 개선한다. Specialized Testing을 효과적으로 수행하기 위한 주요 고려사항들 테스트 환경 구성
실제 환경과 유사한 테스트 환경을 구성하여 정확한 결과를 얻을 수 있도록 한다. 테스트 데이터 준비
다양한 시나리오를 커버할 수 있는 테스트 데이터를 준비한다. 모니터링 및 측정
테스트 중 시스템의 다양한 지표를 지속적으로 모니터링하고 측정한다. 결과 분석 및 개선
테스트 결과를 철저히 분석하고, 발견된 문제점에 대한 개선 방안을 도출한다. 전문화된 테스팅 (Specialized Testing)의 유형 테스트 유형 목적 수행 시점 핵심 지표 주요 도구 테스트 범위 검증 대상 자동화 수준 성능 테스팅 성능 병목 현상 식별 및 성능 요구사항 충족 확인 주요 릴리스 전 응답 시간, 처리량, 오류율 JMeter, LoadRunner 다양한 조건에서 애플리케이션의 속도, 응답성, 안정성 테스트 기능성, 성능, 확장성 도구에 따라 완전 또는 부분 자동화 가능 보안 테스팅 소프트웨어 애플리케이션의 취약점 및 보안 약점 발견 개발 중 및 소프트웨어 수명 주기 전반 취약점 수, 심각도, 오탐지율, 해결 시간 SAST, DAST, 침투 테스팅 도구 애플리케이션, 네트워크, 시스템의 취약점 평가 데이터의 기밀성, 무결성, 가용성 도구에 따라 완전 또는 부분 자동화 가능 호환성 테스팅 다양한 플랫폼에서 소프트웨어 정상 작동 확인 및 사용자 만족도 향상 애플리케이션이 안정화된 소프트웨어 테스팅 단계 다양한 기기에서의 성능 안정성, 기능성, 응답성 BrowserStack, LambdaTest 다양한 운영 체제, 브라우저, 하드웨어 구성, 네트워크 조건에서 테스트 다양한 환경에서의 기능성, 성능, 사용자 경험 요구사항에 따라 수동 및 자동화 가능 사용성 테스팅 사용성 문제 식별 및 제품의 효과성, 효율성, 만족도 평가 제품 수명 주기의 다양한 단계(초기 개발 및 출시 전 포함) 성공률, 작업 소요 시간, 오류율, 사용자 만족도 Maze, UserTesting UI 및 전반적인 사용자 경험 평가 기능성 및 사용자 만족도 상황에 따라 완전 자동화 또는 수동 가능 회귀 테스팅 의도치 않은 결함 탐지, 안정성 보장, 위험 감소, 지속적 테스팅 촉진 소프트웨어 개발 수명 주기 전반(특히 코드 변경 또는 버그 수정 후) 테스트 실행 시간, 테스트 커버리지, 결함 탐지율 Selenium, Katalon, Tricentis Testim 기존 기능 검증 및 새로운 기능 테스트 핵심 기능이 예상대로 작동하는지 확인 완전 자동화, 부분 자동화 또는 수동 가능 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-03 04:10:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 전문화된 테스팅 (Specialized Testing)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/testing-types/specialized-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI/CD Principles</h2></header><div class=entry-content><p>CI/CD Principles CI/CD 원칙은 지속적 통합 (CI) 과 지속적 배포 (CD) 를 기반으로 코드 변경 사항을 빠르게 통합, 테스트, 배포하는 자동화된 프로세스를 강조한다.
CI/CD 는 DevOps 문화의 중심에 있으며, 개발팀이 더 자주, 더 안정적으로 코드를 통합하고 배포할 수 있게 해준다.
핵심 개념 CI/CD 는 두 가지 연관된 개념의 조합이다:
지속적 통합 (Continuous Integration, CI): 개발자들이 코드 변경사항을 중앙 리포지토리에 자주 통합하는 개발 방식으로, 보통 하루에 여러 번 이루어진다. 각 통합은 자동화된 빌드와 테스트로 검증되어 통합 문제를 빠르게 식별한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:24:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD Principles" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/ci-cd-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI</h2></header><div class=entry-content><p>Gitlab CI .gitlab-ci.yml 구조 Stage/Job 구성 및 GitLab Pages 활용 Multi-Project 파이프라인 Auto DevOps 설정 Kubernetes 배포 자동화 GitLab에 내장된 지속적 통합/배포 도구로, .gitlab-ci.yml 파일을 통해 파이프라인을 정의하고 관리 특징 통합성: GitLab 저장소와 긴밀하게 통합되어 있어 별도의 도구 없이 CI/CD 파이프라인을 구축할 수 있습니다. 유연성: YAML 파일을 통해 파이프라인을 구성할 수 있어 다양한 프로젝트 요구사항에 맞춤 설정이 가능합니다. 확장성: 다양한 Runner 유형을 지원하여 다양한 환경에서 작업을 실행할 수 있습니다. 가시성: 파이프라인 실행 상태와 결과를 GitLab 인터페이스에서 쉽게 확인할 수 있습니다. 기능 자동 빌드 및 테스트: 코드 변경 시 자동으로 빌드 및 테스트를 실행합니다. 환경 배포: 다양한 환경(개발, 스테이징, 프로덕션 등)에 자동으로 배포할 수 있습니다. 아티팩트 관리: 빌드 결과물을 저장하고 관리할 수 있습니다. 병렬 실행: 여러 작업을 동시에 실행하여 파이프라인 속도를 향상시킵니다. 환경 변수 관리: 민감한 정보를 안전하게 저장하고 사용할 수 있습니다. 구성요소 .gitlab-ci.yml: 파이프라인 구성 파일 Runners: 작업을 실행하는 에이전트 Jobs: 실행할 개별 작업 Stages: 작업의 실행 순서를 정의하는 단계 Pipeline: 전체 CI/CD 프로세스 장점 GitLab과의 긴밀한 통합 쉬운 설정과 사용 확장성과 유연성 무료로 사용 가능한 기능이 많음 단점 GitLab에 종속적 복잡한 워크플로우의 경우 설정이 복잡해질 수 있음 일부 고급 기능은 유료 버전에서만 사용 가능 설정 방법 프로젝트 루트에.gitlab-ci.yml 파일 생성 YAML 형식으로 파이프라인 구성 작성 변경사항을 커밋하고 푸시 GitLab에서 파이프라인 실행 확인 .gitlab-ci.yml 파일의 기본 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 stages: - build - test - deploy job1: stage: build script: - echo "Building the project..." job2: stage: test script: - echo "Running tests..." job3: stage: deploy script: - echo "Deploying to production..." 주요 구성 요소 stages: 파이프라인의 실행 단계를 정의합니다. 각 단계는 순차적으로 실행됩니다. jobs: 각 작업을 정의합니다. 작업은 특정 단계에 속하며, 실행할 스크립트를 포함합니다. script: 작업에서 실행할 명령어들을 정의합니다. image: 작업을 실행할 Docker 이미지를 지정합니다. artifacts: 작업 결과물을 저장하고 다른 작업에서 사용할 수 있게 합니다. cache: 작업 간에 공유할 파일이나 디렉토리를 지정합니다. 고급 구성 옵션 only/except: 특정 브랜치나 태그에서만 작업을 실행하거나 제외할 수 있습니다. variables: 파이프라인 전체 또는 특정 작업에서 사용할 변수를 정의합니다. before_script/after_script: 작업 실행 전후에 실행할 스크립트를 정의합니다. environment: 배포 환경을 지정합니다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 파이프라인 단계 정의 stages: - build - test - deploy # 캐시 설정: node_modules 폴더를 캐시하여 빌드 속도 향상 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build image: node:14 # Node.js 14 버전 이미지 사용 script: - npm install # 의존성 설치 - npm run build # 프로젝트 빌드 artifacts: paths: - dist/ # 빌드 결과물 저장 # 테스트 작업 정의 test: stage: test image: node:14 script: - npm install # 의존성 설치 - npm test # 테스트 실행 # 배포 작업 정의 deploy: stage: deploy image: alpine:latest script: - apk add --no-cache rsync openssh # 배포에 필요한 도구 설치 - mkdir -p ~/.ssh - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_SERVER_IP:/path/to/deployment/ only: - master # master 브랜치에 푸시될 때만 실행 stages: 파이프라인의 단계를 정의합니다. 여기서는 build, test, deploy 세 단계로 구성됩니다. cache: node_modules 폴더를 캐시하여 빌드 속도를 향상시킵니다. build 작업: stage: build로 빌드 단계에 할당합니다. Node.js 14 버전 이미지를 사용합니다. npm install로 의존성을 설치하고, npm run build로 프로젝트를 빌드합니다. artifacts를 사용하여 빌드 결과물을 저장합니다. test 작업: stage: test로 테스트 단계에 할당합니다. npm test 명령으로 테스트를 실행합니다. deploy 작업: stage: deploy로 배포 단계에 할당합니다. Alpine Linux 이미지를 사용하여 가벼운 환경을 구성합니다. SSH 키를 설정하고 rsync를 사용하여 빌드 결과물을 서버에 배포합니다. only: - master로 master 브랜치에 푸시될 때만 실행되도록 설정합니다. 기본 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # GitLab CI의 기본 설정 예시 image: node:16 # 기본 Docker 이미지 지정 # 파이프라인 스테이지 정의 stages: - build - test - deploy # 캐시 설정 - node_modules 디렉토리를 캐시 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build # 속한 스테이지 지정 script: - npm install # 의존성 설치 - npm run build # 빌드 실행 artifacts: # 빌드 결과물 저장 paths: - dist/ # 테스트 작업 정의 test: stage: test script: - npm run test # 테스트 실행 dependencies: # build 작업의 결과물 사용 - build # 배포 작업 정의 deploy: stage: deploy script: - echo "Deploying application…" - npm run deploy only: # main 브랜치에서만 실행 - main 고급 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 환경변수와 조건부 실행이 포함된 고급 설정 예시 variables: DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG # Docker 이미지 태그 정의 # 커스텀 도커 이미지 빌드 build_image: image: docker:20.10.16 services: - docker:20.10.16-dind # Docker-in-Docker 서비스 stage: build script: # Docker 레지스트리 로그인 - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Docker 이미지 빌드 및 푸시 - docker build -t $DOCKER_IMAGE . - docker push $DOCKER_IMAGE rules: - if: $CI_COMMIT_BRANCH == "main" # main 브랜치에서만 실행 when: always - when: never # 그 외의 경우 실행하지 않음 # 보안 스캔 작업 security_scan: image: security-scanner stage: test script: - scan-dependencies # 의존성 취약점 검사 - scan-code # 코드 보안 검사 allow_failure: true # 실패해도 파이프라인 계속 진행 # 스테이징 환경 배포 deploy_staging: stage: deploy environment: name: staging script: - deploy-to-kubernetes.sh --env staging rules: - if: $CI_COMMIT_BRANCH == "develop" 환경별 배포 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 환경별 배포 구성 예시 .deploy_template: &amp;deploy_template # 재사용 가능한 배포 템플릿 정의 script: - echo "Deploying to $CI_ENVIRONMENT_NAME" - kubectl apply -f k8s/$CI_ENVIRONMENT_NAME/ deploy_dev: &lt;&lt;: *deploy_template # 템플릿 상속 environment: name: development rules: - if: $CI_COMMIT_BRANCH == "develop" deploy_prod: &lt;&lt;: *deploy_template environment: name: production rules: - if: $CI_COMMIT_BRANCH == "main" when: manual # 수동 승인 후 배포 병렬 작업 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 병렬 테스트 실행 예시 test: parallel: 3 # 3개의 병렬 작업 생성 script: - npm run test -- --split=$CI_NODE_INDEX/$CI_NODE_TOTAL # 매트릭스 작업 정의 test_matrix: parallel: matrix: - NODE_VERSION: ["14", "16", "18"] DB_TYPE: ["mysql", "postgres"] script: - docker-compose run --rm -e NODE_VERSION=$NODE_VERSION -e DB_TYPE=$DB_TYPE test 캐시와 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 캐시와 아티팩트 관리 예시 build: cache: key: ${CI_COMMIT_REF_SLUG} # 브랜치별 캐시 키 paths: - node_modules/ - .npm/ policy: pull-push # 캐시 정책 설정 artifacts: paths: - dist/ # 빌드 결과물 - coverage/ # 테스트 커버리지 리포트 reports: junit: test-results.xml # 테스트 결과 리포트 coverage: coverage/lcov.info # 커버리지 리포트 expire_in: 1 week # 아티팩트 유효 기간 이러한 설정들은 프로젝트의 요구사항과 규모에 따라 적절히 조정하여 사용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-10-02 03:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gitlab CI" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/platform-tools/gitlab-ci-cd/gitlab-ci/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI vs. CD vs. CD</h2></header><div class=entry-content><p>CI(지속적 통합) Vs. CD(지속적 전달) vs. CD(지속적 배포) CI/CD 는 현대 소프트웨어 개발 방법론의 핵심으로, 개발 과정을 자동화하고 신속하게 가치를 전달하는 데 중점을 둔다. 지속적 통합 (CI) 은 개발자가 코드 변경 사항을 자주 통합하고 검증하는 과정을 말하며, 지속적 전달 (CD) 은 검증된 코드를 자동으로 프로덕션 환경에 배포 가능한 상태로 준비하는 과정을, 지속적 배포 (CD) 는 검증된 코드를 자동으로 프로덕션 환경에 배포하는 과정을, 각각 자동화하는 방법론이다. 이 세 가지 접근 방식의 주요 차이점은 코드 변경 사항이 프로덕션 환경에 도달하는 자동화 수준과 사람의 개입 정도에 있다. CI/CD 파이프라인은 코드 품질 향상, 출시 주기 단축, 팀 협업 강화 등 다양한 이점을 제공하며, 최신 트렌드로는 GitOps, AIOps, 보안 통합 (DevSecOps) 등이 있다.
...</p></div><footer class=entry-footer><span title='2024-10-02 01:43:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI vs. CD vs. CD" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>History and Evolution of CI/CD</h2></header><div class=entry-content><p>History and Evolution of CI/CD CI/CD(지속적 통합/지속적 배포) 의 역사와 발전은 소프트웨어 개발 방법론의 진화를 보여주는 중요한 여정입니다. 1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념이 시작점이었으며, 이후 애자일 방법론의 부상과 함께 발전했다. 워터폴 모델의 한계를 극복하기 위해 등장한 CI/CD 는 개발자들이 코드 변경사항을 빈번하게 통합하고 자동화된 테스트를 수행하는 방식으로 진화했다. 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장은 CI/CD 도구의 대중화를 이끌었고, 이후 클라우드와 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 도구들이 등장했다. 현재 CI/CD 는 GitOps, AIOps, 보안 통합 (DevSecOps) 등의 최신 트렌드를 포함하며 계속 발전하고 있다. 이 발전 과정은 수동적이고 경직된 개발 프로세스에서 자동화되고 유연한 방식으로의 전환을 보여주며, 소프트웨어 산업의 혁신과 속도를 가속화하는 데 중요한 역할을 하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-02 00:51:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to History and Evolution of CI/CD" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Development Lifecycle</h2></header><div class=entry-content><p>소프트웨어 개발 수명주기 (Software Development Life Cycle, SDLC) 소프트웨어 개발 수명주기 (SDLC) 는 소프트웨어 시스템의 계획부터 폐기까지 전 과정을 체계적으로 관리하는 핵심 프레임워크이다.
SDLC 는 복잡한 프로젝트를 계획, 요구사항 분석, 설계, 구현, 테스트, 배포, 유지보수와 같은 명확한 단계로 구조화하여 프로젝트 리스크를 조기 식별하고, 품질을 보장하며, 예산과 일정을 효과적으로 관리하는 기반을 제공한다.
전통적인 워터폴 (Waterfall) 처럼 순차적인 모델부터 애자일 (Agile), 스크럼 (Scrum) 처럼 반복적인 모델까지 다양한 SDLC 실행 모델이 존재하며, 프로젝트의 특성과 요구사항에 따라 최적의 모델을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-20 05:12:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;73 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Development Lifecycle" href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/sdlc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI/CD Automation</h2></header><div class=entry-content><p>CI/CD Automation CI/CD 자동화는 소프트웨어 개발 프로세스에서 지속적 통합 (Continuous Integration), 지속적 전달 (Continuous Delivery), 지속적 배포 (Continuous Deployment) 를 자동화하는 방법론 및 기술이다. Continuous Integration(지속적 통합) 은 개발자가 코드 변경사항을 주기적으로 중앙 저장소에 통합하는 과정을 자동화하고, Continuous Delivery/Deployment(지속적 배포) 는 검증된 코드를 자동으로 프로덕션 환경에 배포하는 과정을 처리한다.
이 자동화 시스템은 개발 주기를 단축하고, 코드 품질을 향상시키며, 배포 위험을 감소시키는 핵심 도구이다. CI/CD 자동화는 DevOps 문화의 실천을 지원하며, 빌드, 테스트, 배포의 모든 단계를 효율적으로 연결하는 파이프라인을 구축한다.
이를 통해 개발 팀은 릴리스 주기를 단축하며, 품질을 유지하고 고객 피드백을 신속히 반영할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-02 08:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD Automation" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/automation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Version Control Systems</h2></header><div class=entry-content><p>Version Control Systems 버전 관리 시스템(Version Control System, VCS)은 소스 코드, 문서, 설정 파일 등 디지털 자산의 변경 이력을 시간순으로 기록하고, 특정 시점의 버전으로 복원하거나 변경 내역을 추적할 수 있게 해주는 시스템이다. 또한, 각 변경의 작성자, 시점, 변경 이유 등 메타데이터를 함께 저장하는 등의 기능을 통하여 여러 개발자가 동시에 협업할 수 있도록 지원하는 핵심 도구이다.
버전 관리 시스템은 크게 중앙집중식(CVCS), 분산식(DVCS), 로컬 방식으로 분류된다. 대표적인 도구로는 Git, Subversion(SVN), Mercurial 등이 있으며, 특히 Git은 현대 소프트웨어 개발에서 가장 널리 사용되는 버전 관리 시스템이다.
...</p></div><footer class=entry-footer><span title='2024-09-28 15:45:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Version Control Systems" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deployment Strategies</h2></header><div class=entry-content><p>배포 전략 (Deployment Strategies) 배포 전략(Deployment Strategies)은 소프트웨어를 안전하고 효율적으로 업데이트하거나 새로운 버전을 릴리스하는 방법을 말한다.
적절한 배포 전략을 선택하면 서비스 중단을 최소화하고, 새로운 기능을 안전하게 릴리스하며, 롤백을 신속하게 수행할 수 있다.
주요 배포 전략 롤링 업데이트 (Rolling Update): 롤링 업데이트는 서버를 하나씩 또는 작은 그룹으로 순차적으로 업데이트하는 방식.
장점:
무중단 배포 가능 리소스 효율적 사용 점진적인 업데이트로 리스크 감소
단점: 구버전과 신버전이 공존하는 시간 발생 롤백이 복잡할 수 있음 블루/그린 배포 (Blue/Green Deployment): 두 개의 동일한 프로덕션 환경(블루와 그린)을 유지하고, 트래픽을 한 번에 전환하는 방식.
장점:
...</p></div><footer class=entry-footer><span title='2024-09-23 02:13:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deployment Strategies" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/deployment-strategies/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>