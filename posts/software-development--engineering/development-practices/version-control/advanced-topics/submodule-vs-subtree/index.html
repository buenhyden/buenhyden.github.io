<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Submodule vs. Subtree | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,Version-Control-Systems,Git-Workflow"><meta name=description content="깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git Submodule vs. Subtree"><meta property="og:description" content="깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-28T10:10:00+00:00"><meta property="article:modified_time" content="2024-09-28T10:10:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="Version-Control-Systems"><meta property="article:tag" content="Git-Workflow"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git Submodule vs. Subtree"><meta name=twitter:description content="깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":6,"name":"Git Submodule vs. Subtree","item":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Submodule vs. Subtree","name":"Git Submodule vs. Subtree","description":"깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다.","keywords":["DevOps-and-Infrastructure","Version-Control-Systems","Git-Workflow"],"articleBody":"Git Submodule vs. Subtree 깃 (Git) 은 소프트웨어 개발에서 널리 사용되는 분산형 버전 관리 시스템으로, 복잡한 프로젝트를 효율적으로 관리할 수 있게 해준다. 대규모 프로젝트에서는 종종 여러 저장소 (repository) 에 분산된 코드를 하나의 프로젝트 내에서 통합해야 하는 필요성이 생긴다. 이러한 필요성을 해결하기 위해 깃은 두 가지 주요 접근 방식인 서브모듈 (Submodule) 과 서브트리 (Subtree) 를 제공한다.\nGit Submodule 과 Git Subtree 는 모두 하나의 Git 프로젝트 안에서 다른 Git 저장소를 하위 프로젝트처럼 관리하기 위한 방식이다. 하지만 방법은 다르다.\nSubmodule 은 다른 Git 저장소를 포인터로 연결하고 별도로 동기화해야 한다. Subtree 는 다른 Git 저장소의 특정 디렉터리 구조를 **직접 병합 (merge)**하여 포함시키는 방식으로 외부 프로젝트의 전체 히스토리를 메인 저장소에 병합한다. 이 두 접근 방식은 서로 다른 작동 원리, 사용 사례, 장단점을 가지고 있으며, 개발 팀의 워크플로우와 프로젝트 요구사항에 따라 적합한 선택이 달라질 수 있다.\nflowchart TD subgraph Submodule A1[Main Repo] --\u003e B1[.gitmodules file] B1 --\u003e C1[(Submodule Pointer)] end subgraph Subtree A2[Main Repo] --\u003e B2[Subtree Merged Repo with History] end style Submodule fill:#f0f8ff,stroke:#333,stroke-width:1px style Subtree fill:#f8fff0,stroke:#333,stroke-width:1px 기본 개념 Git Submodule은 한 Git 저장소 내에 다른 독립적인 Git 저장소를 포함할 수 있게 해주는 기능으로, 부모 저장소에서 자식 저장소의 특정 커밋을 참조하는 방식으로 작동한다. 이는 의존성 버전을 고정하여 안정성을 확보할 수 있게 한다.\nGit Subtree는 외부 저장소를 현재 프로젝트의 디렉토리로 직접 병합하여 관리하는 방식으로, 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹한다. 이를 통해 일반적인 Git 워크플로우로 모든 코드를 관리할 수 있다.\n항목 Git Submodule Git Subtree 버전 관리 방식 하위 저장소의 특정 커밋을 참조 (포인터) 하위 저장소의 전체 히스토리를 상위 저장소에 병합 독립적인 히스토리 유지됨 유지되지 않음 (상위 저장소에 합쳐짐) 외부 의존성 실제 외부 저장소를 포함 외부 저장소 내용을 복사하여 포함 업데이트 방식 수동 업데이트 (submodule update, pull) 필요 상위 저장소에서 pull --squash 또는 merge 가능 사용 복잡도 비교적 복잡 (추적, 동기화 필요) 단순 (일반 Git 명령으로 충분함) 사용 용도 공통 라이브러리 공유, 버전 고정이 필요한 서드파티 코드 포함 외부 저장소를 내부에서 관리하려는 경우, 일회성 통합 등에 적합 핵심 개념 및 목적 비교 구분 Submodule Subtree 핵심 개념 외부 저장소를 참조로 포함 (포인터 기반) 외부 저장소의 내용을 디렉터리로 병합 파일 관리 참조만 저장 (SHA 값) 파일을 직접 추가하고 트래킹 메타데이터 .gitmodules 파일 생성 별도 메타데이터 파일 없음 목적 서브 프로젝트 독립적 버전 관리 전체 프로젝트와의 구조 통합 및 일관성 저장소 크기 작음 (참조만 저장) 큼 (전체 코드 포함) 독립성 완전히 독립적인 저장소 상위 저장소와 통합됨 협업 외부 저장소 변경 시 수동 업데이트 필요 메인 저장소 내에서 직접 수정 가능 클론 방식 별도 초기화 필요 (init/update) 자동으로 포함됨 히스토리 관리 분리된 커밋 히스토리 통합된 커밋 히스토리 사용하는 명령어 git submodule git subtree 또는 git merge, git remote 등 통합 방식 commit ID 기준 참조 내용 기반 병합 (history 유지 가능) 적합 사례 컴포넌트 기반 개발 (CBD) 시스템 기반 개발 (SBD) 병합 전략 Fast-forward 불가능 일반 병합 가능 ▶ 시각적 비교 다이어그램\ngraph LR A[메인 저장소] --\u003e B[Submodule: 링크 관리] A --\u003e C[Subtree: 코드 복제] B --\u003e D[외부 저장소 커밋 고정] C --\u003e E[외부 코드 내재화] 구성 요소 및 원리 깃 서브모듈 (Git Submodule) 은 \" 참조 기반 \" 접근 방식을 사용한다. 메인 저장소는 서브모듈 저장소의 특정 커밋에 대한 참조 (포인터) 만 저장하고, 실제 코드는 서브모듈 저장소에서 관리된다. 이는 \" 느슨한 결합 (loose coupling)\" 원칙을 따르며, 각 모듈이 독립적으로 발전할 수 있게 한다. 메인 저장소에서 서브모듈을 추가하면, 메인 저장소는 서브모듈의 특정 커밋 해시를 참조한다. 이 참조 정보는 .gitmodules 파일과 깃 인덱스에 저장된다. 서브모듈의 내용이 변경되더라도, 메인 저장소의 참조는 명시적으로 업데이트하지 않는 한 변경되지 않는다.\n깃 서브트리 (Git Subtree) 는 \" 통합 기반 \" 접근 방식을 사용한다. 외부 저장소의 코드를 메인 저장소에 복사하여 통합함으로써, 모든 코드와 히스토리가 단일 저장소 내에서 관리된다. 이는 \" 강한 결합 (tight coupling)\" 원칙을 따르며, 코드 베이스의 일관성을 유지한다. 서브트리를 추가할 때, 깃은 외부 저장소의 히스토리를 메인 저장소의 히스토리에 병합한다. 이는 특별한 병합 전략을 사용하여, 외부 저장소의 커밋을 메인 저장소의 특정 서브디렉토리에 적용한다. 이 과정에서 원본 저장소의 커밋 정보를 보존하여, 나중에 변경사항을 양방향으로 동기화할 수 있다.\nSubmodule 아키텍처: 1 2 3 4 Main Repo ├── .gitmodules ├── lib/ │ └── [Submodule] → 다른 Git Repo 연결 (포인터) Subtree 아키텍처: 1 2 3 Main Repo ├── lib/ │ └── [Subtree 병합된 Repo] → Git history 포함됨 작동 원리 깃 서브모듈 (Git Submodule) 의 작동 원리 gitGraph commit id: \"메인 저장소 초기화\" branch submodule commit id: \"서브모듈 개발\" checkout main commit id: \"서브모듈 추가\" merge submodule tag: \"참조 커밋 업데이트\" 서브모듈 추가:\n1 git submodule add 이 명령은 지정된 저장소를 서브모듈로 추가하고, .gitmodules 파일을 생성/업데이트한다.\n저장소 클론 및 서브모듈 초기화:\n1 2 3 git clone git submodule init git submodule update 메인 저장소를 클론한 후, 서브모듈을 초기화하고 업데이트해야 서브모듈 코드를 가져온다.\n서브모듈 업데이트:\n1 2 3 4 5 cd git pull origin master cd .. git add git commit -m \"Update submodule\" 서브모듈 코드를 최신 버전으로 업데이트하려면, 서브모듈 디렉토리에서 깃 명령을 실행한 후, 메인 저장소에서 변경된 참조를 커밋해야 한다.\n깃 서브트리 (Git Subtree) 의 작동 원리 gitGraph commit id: \"메인 저장소 초기화\" commit id: \"서브트리 코드 통합\" commit id: \"서브트리 코드 수정\" commit id: \"변경사항 병합\" 서브트리 추가:\n1 git subtree add --prefix= --squash 이 명령은 지정된 저장소의 코드를 메인 저장소의 지정된 경로에 복사하고, 원본 저장소의 히스토리를 메인 저장소에 병합한다.\n저장소 클론:\n1 git clone 메인 저장소를 클론하면 서브트리 코드도 함께 포함되어 있어 추가 단계가 필요 없다.\n서브트리 업데이트:\n1 git subtree pull --prefix= --squash 서브트리 코드를 최신 버전으로 업데이트하려면, 이 명령을 사용하여 원본 저장소의 변경사항을 가져와 병합한다.\n변경사항 업스트림 푸시:\n1 git subtree push --prefix= 메인 저장소에서 서브트리 코드에 변경한 내용을 원본 저장소로 푸시할 수 있다.\n구조적 차이점 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 서브모듈 구조 main-repo/ ├── .git/ ├── .gitmodules # 서브모듈 참조 정보 ├── project-files/ └── submodule-dir/ # 외부 저장소 참조 └── .git # 포인터 파일 (실제 .git은 부모의 .git/modules에 있음) # 서브트리 구조 main-repo/ ├── .git/ ├── project-files/ └── subtree-dir/ # 일반 디렉토리로 취급 └── files # 모든 파일이 메인 저장소의 일부 장단점 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 장점 • 코드 재사용성 높음\n• 의존성 버전 고정으로 안정성 확보\n• 저장소 크기가 작게 유지됨\n• 접근 제어가 명확함\n• 모듈별 독립적인 히스토리 유지\n• 외부 저장소 변경에 영향 받지 않음 • 코드 공유 용이성\n• 직접 수정 가능성\n• 양방향 동기화 지원\n• 별도 초기화 없이 즉시 사용 가능\n• 기존 Git 명령어와 워크플로우 유지\n• 단일 저장소로 CI/CD 파이프라인 간소화 단점 • 복잡한 워크플로우\n• 추가 학습 필요\n• 초기화/업데이트 단계 필요\n• 실수로 하위 모듈 변경 시 문제 발생 가능\n• 원격 저장소 접근 불가 시 작업 제한\n• 브랜치 전환 시 서브모듈 상태 관리 복잡 • 명령어가 복잡하고 기억하기 어려움\n• 저장소 크기 증가\n• 접근 제어 제한적\n• 하위 저장소 위치를 기억해야 함\n• 히스토리 오염으로 가독성 저하\n• 원본 저장소 접근 권한 없을 때 업데이트 불가 3. 핵심 개념 및 비교 분석 주요 기능 및 역할 항목 Git Submodule Git Subtree 버전 고정 O (commit 단위) O (병합 시점 기준 snapshot) 코드 공유 O O 업데이트 동기화 수동 수동 혹은 자동 스크립트화 가능 분리 배포 가능성 높음 (완전 분리) 낮음 (일체화됨) 목적 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 주요 목적 외부 저장소에 대한 참조만 저장하여 프로젝트 관리 외부 저장소의 코드를 메인 저장소에 통합 코드 분리 코드 베이스를 분리된 상태로 유지 코드 베이스를 하나로 통합 저장소 간 관계 느슨한 결합 (Loose coupling) 유지 더 강한 결합 (Tight coupling) 형성 버전 관리 외부 저장소의 특정 버전 참조 외부 저장소의 코드와 히스토리 병합 필요성 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 외부 라이브러리 관리 외부 라이브러리의 업데이트 명시적 관리 가능 외부 라이브러리 코드를 직접 통합하여 관리 여러 프로젝트에서 코드 공유 코드를 여러 프로젝트에서 독립적으로 참조 코드 복제본을 각 프로젝트에 포함 모듈화 코드베이스 모듈화에 적합 단일 코드베이스 관리에 적합 코드 기여 외부 프로젝트에 직접 기여 용이 변경사항을 다시 업스트림에 푸시하기 복잡할 수 있음 주요 기능 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 코드 포함 방식 참조 링크만 포함 코드 전체 복사 및 통합 히스토리 관리 외부 저장소 히스토리와 분리 외부 저장소 히스토리 통합 변경 추적 메인 저장소와 서브모듈 변경 별도 추적 모든 변경이 메인 저장소에서 추적 업데이트 방식 명시적 업데이트 명령 필요 일반적인 깃 명령으로 관리 가능 저장소 접근 서브모듈에 접근하려면 별도 초기화 필요 클론 후 즉시 모든 코드 접근 가능 역할 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 프로젝트 구조화 독립적인 모듈로 구조화 통합된 단일 구조로 관리 팀 협업 팀 간 명확한 코드 소유권 분리 단일 팀이 전체 코드베이스 관리 의존성 관리 외부 의존성 명시적 관리 의존성을 내부화하여 관리 코드 재사용 여러 프로젝트 간 코드 재사용 촉진 프로젝트별 코드 사본 관리 특징 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 학습 곡선 비교적 가파른 학습 곡선 더 직관적인 사용법 설정 복잡성 초기 설정 복잡 더 간단한 설정 독립성 독립적인 저장소 유지 메인 저장소와 통합 크기 영향 메인 저장소 크기 작게 유지 메인 저장소 크기 증가 팀 이해도 팀원이 서브모듈 개념 이해 필요 일반적인 깃 지식만으로 접근 가능 협업 관리 어렵고 복잡 단순함 분류에 따른 종류 및 유형 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 코드 통합 유형 참조 기반 통합 복사 기반 통합 사용 시나리오 외부 의존성이 자주 변경되지 않는 경우 외부 코드를 내부화하려는 경우 복잡성 수준 복잡한 구성, 명시적 관리 단순한 구성, 묵시적 관리 적합한 프로젝트 크기 대규모 모듈화된 프로젝트 중소규모 프로젝트 적합한 사용 사례 Git Submodule Git Subtree 컴포넌트나 서브프로젝트가 빠르게 변경되어 API 를 손상시킬 수 있을 때 안전을 위해 코드를 특정 커밋에 고정 코드를 한 번만 외부 저장소에서 복사하거나 가끔씩만 가져오려는 경우 자주 업데이트되지 않는 의존성을 추적하고자 할 때 팀이 명시적인 의존성 관리의 복잡성 없이 단순성을 선호할 때 외부 코드의 커밋 이력과 메인 프로젝트의 이력을 명확히 분리해야 할 때 외부 코드를 프로젝트의 일부로 취급하고 관리하려 할 때 여러 프로젝트에서 공유하는 코드의 버전을 엄격하게 관리해야 할 때 외부 코드를 수정하고 원본 저장소로 변경사항을 다시 쉽게 전달할 필요가 없을 때 실무 적용 예시 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 프레임워크 통합 프레임워크를 서브모듈로 참조하여 업데이트 관리 프레임워크 코드를 직접 통합하여 맞춤화 라이브러리 관리 외부 라이브러리를 참조하여 버전 고정 라이브러리 코드를 직접 통합하여 내부 수정 용이 마이크로서비스 마이크로서비스 간 공통 코드 관리 서비스별 독립적 코드베이스 유지 플러그인 시스템 플러그인을 별도 저장소로 관리 플러그인 코드를 메인 코드베이스에 통합 오픈소스 기여 오픈소스 프로젝트를 서브모듈로 포함하여 기여 오픈소스 코드 일부를 가져와 내부 사용 독립된 프로젝트 종속성 Submodule 서로 분리된 독립 유지가 필요함 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 초기 설정 git submodule add 명령으로 추가 필요 git subtree add 명령으로 추가 필요 클론 후 작업 git submodule init 및 git submodule update 필요 별도 초기화 필요 없음 팀 교육 팀원들에게 서브모듈 워크플로우 교육 필요 일반적인 깃 워크플로우만 교육 필요 문서화 서브모듈 사용에 대한 명확한 문서화 필요 서브트리 명령어에 대한 문서화 필요 분리된 저장소 관리 서브모듈 저장소 접근 권한 관리 필요 중앙 저장소 접근 권한만 관리 외부 의존성 변경 의존성 변경 시 명시적 업데이트 필요 의존성 변경 시 병합 충돌 관리 필요 최적화하기 위한 고려사항 및 주의할 점 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 저장소 크기 참조만 저장하여 메인 저장소 크기 작게 유지 모든 코드를 복사하여 저장소 크기 증가 클론 시간 서브모듈 초기화로 인해 클론 시간 증가 초기 클론 시간 짧음 히스토리 검색 분리된 히스토리로 검색 성능 향상 통합된 히스토리로 검색 복잡성 증가 캐싱 효율성 모듈별 캐싱으로 효율적인 작업 가능 전체 저장소 변경으로 캐싱 효율 감소 병렬 작업 모듈별 독립적 작업 가능 단일 저장소 내 작업 의존성 증가 대규모 프로젝트 대규모 프로젝트에서 모듈화로 성능 향상 대규모 프로젝트에서 저장소 크기 문제 발생 가능 빌드 성능 불필요한 모듈은 체크아웃 안 해도 됨 전체 포함되므로 필요 시 디렉토리 분리 빌드 동기화 전략 fetch + checkout 조합 최적화 스크립트를 통한 업데이트 자동화 CI/CD 서브모듈 경로 인식 문제 대응 필요 일체형 관리로 구성 쉬움 개발자 경험 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 초기 설정 복잡성 높음 - .gitmodules 파일 및 여러 단계 필요 중간 - 단일 명령으로 시작 가능 일상적 사용 복잡함 - 특별한 명령어 지식 필요 단순함 - 일반 깃 워크플로우와 유사 학습 곡선 가파름 - 특정 개념과 명령어 학습 필요 완만함 - 기존 깃 지식으로 접근 가능 디버깅 용이성 어려움 - 서브모듈 상태 추적이 복잡 중간 - 일반 깃 디버깅 기술 적용 가능 팀 도입 난이도 높음 - 모든 팀원이 서브모듈 개념 이해 필요 낮음 - 일반 깃 지식으로 충분 성능 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 클론 속도 느림 - 서브모듈 초기화/업데이트 필요 빠름 - 모든 코드가 즉시 사용 가능 저장소 크기 작음 - 참조만 저장 큼 - 전체 코드 및 히스토리 저장 브랜치 전환 속도 느림 - 서브모듈 업데이트 필요 빠름 - 즉시 전환 가능 대규모 프로젝트 확장성 좋음 - 모듈화로 성능 유지 제한적 - 저장소 크기 증가로 성능 저하 가능 네트워크 요구사항 높음 - 서브모듈 저장소 접근 필요 낮음 - 클론 후 네트워크 접근 불필요 CI/CD 통합 비교 구분 깃 서브모듈 (Git Submodule) 깃 서브트리 (Git Subtree) 설정 복잡성 높음 - 서브모듈 초기화 단계 필요 낮음 - 추가 설정 불필요 빌드 안정성 낮음 - 외부 저장소 의존으로 불안정 가능 높음 - 모든 코드가 저장소 내에 있음 빌드 속도 느림 - 서브모듈 초기화 시간 필요 빠름 - 추가 초기화 불필요 의존성 추적 명시적 - 특정 커밋 참조 암시적 - 코드 통합으로 인한 추적 어려움 자동화 용이성 어려움 - 복잡한 스크립트 필요 쉬움 - 표준 깃 워크플로우 활용 최근근 동향 두 기술 모두 진화하고 있으며 다음과 같은 동향이 나타나고 있다:\n하이브리드 접근법: 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 방식이 인기를 얻고 있다. 자동화 도구: CI/CD 파이프라인과의 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다. 대안 솔루션: git-subrepo 와 같이 두 기술의 장점을 결합한 새로운 대안 도구들이 등장하고 있다. AI 기반 자동화: 병합 충돌 해결 및 의존성 관리를 위한 AI 기반 도구가 발전하고 있다. 보안 강화: 의존성 취약점 관리와 접근 제어를 강화하는 추가 기능들이 도입되고 있다. 결론적으로, Git Submodule 은 외부 의존성을 특정 버전으로 고정하고 독립적으로 관리하는 데 적합하며, Git Subtree 는 외부 코드를 프로젝트에 통합하고 단일 저장소처럼 관리하는 데 더 적합하다. 프로젝트의 특성과 팀의 워크플로우에 따라 적절한 도구를 선택하거나 하이브리드 접근법을 고려하는 것이 중요하다.\n추가 학습 내용 학습 주제 서브모듈 관련 내용 서브트리 관련 내용 고급 깃 명령어 git submodule foreach, git submodule sync, git submodule deinit git subtree split, git subtree merge, git subtree push 충돌 해결 서브모듈 참조 충돌 해결 방법 서브트리 병합 충돌 해결 전략 CI/CD 통합 서브모듈이 있는 프로젝트의 CI/CD 파이프라인 구성 서브트리 프로젝트의 CI/CD 자동화 모노레포 전략 서브모듈을 활용한 모노레포 관리 서브트리 기반 모노레포 아키텍처 마이그레이션 일반 저장소에서 서브모듈로 전환 방법 서브모듈에서 서브트리로 마이그레이션 보안 고려사항 서브모듈의 보안 취약점 관리 서브트리 코드의 보안 감사 분산 팀 협업 분산된 팀에서 서브모듈 관리 전략 서브트리 기반 협업 워크플로우 히스토리 관리 서브모듈 히스토리와 메인 저장소 히스토리 통합 서브트리 커밋 히스토리 관리 및 정리 성능 최적화 대규모 서브모듈 프로젝트 성능 향상 기법 서브트리 저장소 크기 및 성능 최적화 자동화 도구 서브모듈 관리 자동화 스크립트 개발 서브트리 워크플로우 자동화 도구 용어 정리 용어 설명 CBD 컴포넌트 단위 개발 (예: 라이브러리 분리) SBD 시스템 단위 개발 (예: 통합 코드베이스) 깃 서브모듈 (Git Submodule) 메인 저장소 내에 다른 저장소에 대한 참조를 포함하는 기능으로, 외부 저장소의 특정 커밋을 참조 깃 서브트리 (Git Subtree) 외부 저장소의 코드를 메인 저장소에 복사하여 통합하는 기능으로, 외부 코드의 전체 히스토리를 메인 저장소에 병합 .gitmodules 서브모듈 URL, 로컬 경로, 브랜치 정보 등 서브모듈 구성 정보를 저장하는 설정 파일 서브모듈 초기화 (Submodule Init) 서브모듈의 로컬 구성을 초기화하는 과정 (git submodule init) 서브모듈 업데이트 (Submodule Update) 서브모듈 코드를 지정된 커밋으로 업데이트하는 과정 (git submodule update) 서브트리 추가 (Subtree Add) 외부 저장소를 서브트리로 추가하는 과정 (git subtree add) 서브트리 병합 (Subtree Merge) 서브트리 변경사항을 메인 저장소에 병합하는 과정 (git subtree merge) 스쿼시 (Squash) 여러 커밋을 하나의 커밋으로 압축하는 것으로, 서브트리에서 히스토리 관리를 위해 자주 사용 (--squash) 업스트림 (Upstream) 원본 코드가 있는 저장소로, 서브모듈이나 서브트리에서 변경사항을 푸시하는 대상 모노레포 (Monorepo) 여러 프로젝트나 모듈을 단일 저장소에서 관리하는 방식 참고 및 출처 Atlassian Submodule 설명 문서 Atlassian Subtree 설명 문서 Git 공식 문서 - Submodule GitHub 블로그: Subtree 활용 사례 Medium: Git Submodule vs Subtree (2024 업데이트) Git - Submodules Git Subtree: Alternative to Git Submodule | Atlassian Git Tutorial Git Submodule vs Subtree: Which Is Right for Your Project? | Graph AI Git submodule | Atlassian Introducing the Space Git Subtree | The Space Blog Git – Subtree | GeeksforGeeks Working with submodules - The GitHub Blog Git Submodules basic explanation | GitHub Gist A real world usage for git subtrees | GitHub Gist ","wordCount":"2685","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-28T10:10:00Z","dateModified":"2024-09-28T10:10:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Git Submodule vs. Subtree</h1><div class=post-description>깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다.</div><div class=post-meta><span title='2024-09-28 10:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Development%20&%20Engineering/Development%20Practices/Version%20Control/Advanced%20Topics/submodule-vs-subtree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git-submodule-vs-subtree>Git Submodule vs. Subtree</a><ul><li><a href=#기본-개념>기본 개념</a></li><li><a href=#핵심-개념-및-목적-비교>핵심 개념 및 목적 비교</a></li><li><a href=#구성-요소-및-원리>구성 요소 및 원리</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#구조적-차이점>구조적 차이점</a></li><li><a href=#장단점-비교>장단점 비교</a></li><li><a href=#3-핵심-개념-및-비교-분석>3. 핵심 개념 및 비교 분석</a></li><li><a href=#최근근-동향>최근근 동향</a></li><li><a href=#추가-학습-내용>추가 학습 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=git-submodule-vs-subtree>Git Submodule vs. Subtree<a hidden class=anchor aria-hidden=true href=#git-submodule-vs-subtree>#</a></h2><p>깃 (Git) 은 소프트웨어 개발에서 널리 사용되는 분산형 버전 관리 시스템으로, 복잡한 프로젝트를 효율적으로 관리할 수 있게 해준다. 대규모 프로젝트에서는 종종 여러 저장소 (repository) 에 분산된 코드를 하나의 프로젝트 내에서 통합해야 하는 필요성이 생긴다. 이러한 필요성을 해결하기 위해 깃은 두 가지 주요 접근 방식인 서브모듈 (Submodule) 과 서브트리 (Subtree) 를 제공한다.</p><p><code>Git Submodule</code> 과 <code>Git Subtree</code> 는 모두 하나의 Git 프로젝트 안에서 다른 Git 저장소를 하위 프로젝트처럼 관리하기 위한 방식이다. 하지만 방법은 다르다.</p><ul><li><code>Submodule</code> 은 다른 Git 저장소를 <strong>포인터로 연결</strong>하고 별도로 동기화해야 한다.</li><li><code>Subtree</code> 는 다른 Git 저장소의 특정 디렉터리 구조를 **직접 병합 (merge)**하여 포함시키는 방식으로 외부 프로젝트의 전체 히스토리를 메인 저장소에 병합한다.</li></ul><p>이 두 접근 방식은 서로 다른 작동 원리, 사용 사례, 장단점을 가지고 있으며, 개발 팀의 워크플로우와 프로젝트 요구사항에 따라 적합한 선택이 달라질 수 있다.</p><pre class=mermaid>flowchart TD
    subgraph Submodule
        A1[Main Repo] --&gt; B1[.gitmodules file]
        B1 --&gt; C1[(Submodule Pointer)]
    end

    subgraph Subtree
        A2[Main Repo] --&gt; B2[Subtree Merged Repo with History]
    end

    style Submodule fill:#f0f8ff,stroke:#333,stroke-width:1px
    style Subtree fill:#f8fff0,stroke:#333,stroke-width:1px
</pre><h3 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h3><p><strong>Git Submodule</strong>은 한 Git 저장소 내에 다른 독립적인 Git 저장소를 포함할 수 있게 해주는 기능으로, 부모 저장소에서 자식 저장소의 특정 커밋을 참조하는 방식으로 작동한다. 이는 의존성 버전을 고정하여 안정성을 확보할 수 있게 한다.</p><p><strong>Git Subtree</strong>는 외부 저장소를 현재 프로젝트의 디렉토리로 직접 병합하여 관리하는 방식으로, 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹한다. 이를 통해 일반적인 Git 워크플로우로 모든 코드를 관리할 수 있다.</p><table><thead><tr><th>항목</th><th>Git Submodule</th><th>Git Subtree</th></tr></thead><tbody><tr><td>버전 관리 방식</td><td>하위 저장소의 특정 커밋을 참조 (포인터)</td><td>하위 저장소의 전체 히스토리를 상위 저장소에 병합</td></tr><tr><td>독립적인 히스토리</td><td>유지됨</td><td>유지되지 않음 (상위 저장소에 합쳐짐)</td></tr><tr><td>외부 의존성</td><td>실제 외부 저장소를 포함</td><td>외부 저장소 내용을 복사하여 포함</td></tr><tr><td>업데이트 방식</td><td>수동 업데이트 (<code>submodule update</code>, <code>pull</code>) 필요</td><td>상위 저장소에서 <code>pull --squash</code> 또는 <code>merge</code> 가능</td></tr><tr><td>사용 복잡도</td><td>비교적 복잡 (추적, 동기화 필요)</td><td>단순 (일반 Git 명령으로 충분함)</td></tr><tr><td>사용 용도</td><td>공통 라이브러리 공유, 버전 고정이 필요한 서드파티 코드 포함</td><td>외부 저장소를 내부에서 관리하려는 경우, 일회성 통합 등에 적합</td></tr></tbody></table><h3 id=핵심-개념-및-목적-비교>핵심 개념 및 목적 비교<a hidden class=anchor aria-hidden=true href=#핵심-개념-및-목적-비교>#</a></h3><table><thead><tr><th>구분</th><th>Submodule</th><th>Subtree</th><th></th></tr></thead><tbody><tr><td><strong>핵심 개념</strong></td><td>외부 저장소를 참조로 포함 (포인터 기반)</td><td>외부 저장소의 내용을 디렉터리로 병합</td><td></td></tr><tr><td>파일 관리</td><td>참조만 저장 (SHA 값)</td><td>파일을 직접 추가하고 트래킹</td><td></td></tr><tr><td>메타데이터</td><td>.gitmodules 파일 생성</td><td>별도 메타데이터 파일 없음</td><td></td></tr><tr><td>목적</td><td>서브 프로젝트 독립적 버전 관리</td><td>전체 프로젝트와의 구조 통합 및 일관성</td><td></td></tr><tr><td><strong>저장소 크기</strong></td><td>작음 (참조만 저장)</td><td>큼 (전체 코드 포함)</td><td></td></tr><tr><td>독립성</td><td>완전히 독립적인 저장소</td><td>상위 저장소와 통합됨</td><td></td></tr><tr><td><strong>협업</strong></td><td>외부 저장소 변경 시 수동 업데이트 필요</td><td>메인 저장소 내에서 직접 수정 가능</td><td></td></tr><tr><td>클론 방식</td><td>별도 초기화 필요 (init/update)</td><td>자동으로 포함됨</td><td></td></tr><tr><td><strong>히스토리 관리</strong></td><td>분리된 커밋 히스토리</td><td>통합된 커밋 히스토리</td><td></td></tr><tr><td>사용하는 명령어</td><td><code>git submodule</code></td><td><code>git subtree</code> 또는 <code>git merge</code>, <code>git remote</code> 등</td><td></td></tr><tr><td>통합 방식</td><td>commit ID 기준 참조</td><td>내용 기반 병합 (history 유지 가능)</td><td></td></tr><tr><td><strong>적합 사례</strong></td><td>컴포넌트 기반 개발 (CBD)</td><td>시스템 기반 개발 (SBD)</td><td></td></tr><tr><td><strong>병합 전략</strong></td><td>Fast-forward 불가능</td><td>일반 병합 가능</td><td></td></tr></tbody></table><p>▶ <strong>시각적 비교 다이어그램</strong></p><pre class=mermaid>graph LR
    A[메인 저장소] --&gt; B[Submodule: 링크 관리]
    A --&gt; C[Subtree: 코드 복제]
    B --&gt; D[외부 저장소 커밋 고정]
    C --&gt; E[외부 코드 내재화]
</pre><h3 id=구성-요소-및-원리>구성 요소 및 원리<a hidden class=anchor aria-hidden=true href=#구성-요소-및-원리>#</a></h3><p><figure><img alt="깃 서브모듈 (Git Submodule) 구성 요소 및 아키텍처 vs 깃 서브트리 (Git Subtree) 구성 요소 및 아키텍처" loading=lazy src=/img/ChatGPT_12_27_07.png></figure></p><p>깃 서브모듈 (Git Submodule) 은 " 참조 기반 " 접근 방식을 사용한다. 메인 저장소는 서브모듈 저장소의 특정 커밋에 대한 참조 (포인터) 만 저장하고, 실제 코드는 서브모듈 저장소에서 관리된다. 이는 " 느슨한 결합 (loose coupling)" 원칙을 따르며, 각 모듈이 독립적으로 발전할 수 있게 한다. 메인 저장소에서 서브모듈을 추가하면, 메인 저장소는 서브모듈의 특정 커밋 해시를 참조한다. 이 참조 정보는 <code>.gitmodules</code> 파일과 깃 인덱스에 저장된다. 서브모듈의 내용이 변경되더라도, 메인 저장소의 참조는 명시적으로 업데이트하지 않는 한 변경되지 않는다.</p><p>깃 서브트리 (Git Subtree) 는 " 통합 기반 " 접근 방식을 사용한다. 외부 저장소의 코드를 메인 저장소에 복사하여 통합함으로써, 모든 코드와 히스토리가 단일 저장소 내에서 관리된다. 이는 " 강한 결합 (tight coupling)" 원칙을 따르며, 코드 베이스의 일관성을 유지한다. 서브트리를 추가할 때, 깃은 외부 저장소의 히스토리를 메인 저장소의 히스토리에 병합한다. 이는 특별한 병합 전략을 사용하여, 외부 저장소의 커밋을 메인 저장소의 특정 서브디렉토리에 적용한다. 이 과정에서 원본 저장소의 커밋 정보를 보존하여, 나중에 변경사항을 양방향으로 동기화할 수 있다.</p><ul><li><strong>Submodule 아키텍처</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Main Repo
</span></span><span class=line><span class=cl>├── .gitmodules
</span></span><span class=line><span class=cl>├── lib/
</span></span><span class=line><span class=cl>│   └── [Submodule] → 다른 Git Repo 연결 (포인터)
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>Subtree 아키텍처</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Main Repo
</span></span><span class=line><span class=cl>├── lib/
</span></span><span class=line><span class=cl>│   └── [Subtree 병합된 Repo] → Git history 포함됨
</span></span></code></pre></td></tr></table></div></div><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><h4 id=깃-서브모듈-git-submodule-의-작동-원리>깃 서브모듈 (Git Submodule) 의 작동 원리<a hidden class=anchor aria-hidden=true href=#깃-서브모듈-git-submodule-의-작동-원리>#</a></h4><pre class=mermaid>gitGraph
    commit id: &#34;메인 저장소 초기화&#34;
    branch submodule
    commit id: &#34;서브모듈 개발&#34;
    checkout main
    commit id: &#34;서브모듈 추가&#34;
    merge submodule tag: &#34;참조 커밋 업데이트&#34;
</pre><ol><li><p><strong>서브모듈 추가</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git submodule add &lt;repository-url&gt; &lt;path&gt;
</span></span></code></pre></td></tr></table></div></div><p>이 명령은 지정된 저장소를 서브모듈로 추가하고, <code>.gitmodules</code> 파일을 생성/업데이트한다.</p></li><li><p><strong>저장소 클론 및 서브모듈 초기화</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone &lt;main-repository-url&gt;
</span></span><span class=line><span class=cl>git submodule init
</span></span><span class=line><span class=cl>git submodule update
</span></span></code></pre></td></tr></table></div></div><p>메인 저장소를 클론한 후, 서브모듈을 초기화하고 업데이트해야 서브모듈 코드를 가져온다.</p></li><li><p><strong>서브모듈 업데이트</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> &lt;submodule-path&gt;
</span></span><span class=line><span class=cl>git pull origin master
</span></span><span class=line><span class=cl><span class=nb>cd</span> ..
</span></span><span class=line><span class=cl>git add &lt;submodule-path&gt;
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;Update submodule&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>서브모듈 코드를 최신 버전으로 업데이트하려면, 서브모듈 디렉토리에서 깃 명령을 실행한 후, 메인 저장소에서 변경된 참조를 커밋해야 한다.</p></li></ol><h4 id=깃-서브트리-git-subtree-의-작동-원리>깃 서브트리 (Git Subtree) 의 작동 원리<a hidden class=anchor aria-hidden=true href=#깃-서브트리-git-subtree-의-작동-원리>#</a></h4><pre class=mermaid>gitGraph
    commit id: &#34;메인 저장소 초기화&#34;
    commit id: &#34;서브트리 코드 통합&#34;
    commit id: &#34;서브트리 코드 수정&#34;
    commit id: &#34;변경사항 병합&#34;
</pre><ol><li><p><strong>서브트리 추가</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree add --prefix<span class=o>=</span>&lt;path&gt; &lt;repository-url&gt; &lt;branch&gt; --squash
</span></span></code></pre></td></tr></table></div></div><p>이 명령은 지정된 저장소의 코드를 메인 저장소의 지정된 경로에 복사하고, 원본 저장소의 히스토리를 메인 저장소에 병합한다.</p></li><li><p><strong>저장소 클론</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone &lt;main-repository-url&gt;
</span></span></code></pre></td></tr></table></div></div><p>메인 저장소를 클론하면 서브트리 코드도 함께 포함되어 있어 추가 단계가 필요 없다.</p></li><li><p><strong>서브트리 업데이트</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree pull --prefix<span class=o>=</span>&lt;path&gt; &lt;repository-url&gt; &lt;branch&gt; --squash
</span></span></code></pre></td></tr></table></div></div><p>서브트리 코드를 최신 버전으로 업데이트하려면, 이 명령을 사용하여 원본 저장소의 변경사항을 가져와 병합한다.</p></li><li><p><strong>변경사항 업스트림 푸시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree push --prefix<span class=o>=</span>&lt;path&gt; &lt;repository-url&gt; &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>메인 저장소에서 서브트리 코드에 변경한 내용을 원본 저장소로 푸시할 수 있다.</p></li></ol><h3 id=구조적-차이점>구조적 차이점<a hidden class=anchor aria-hidden=true href=#구조적-차이점>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 서브모듈 구조
</span></span><span class=line><span class=cl>main-repo/
</span></span><span class=line><span class=cl>├── .git/
</span></span><span class=line><span class=cl>├── .gitmodules      # 서브모듈 참조 정보
</span></span><span class=line><span class=cl>├── project-files/
</span></span><span class=line><span class=cl>└── submodule-dir/   # 외부 저장소 참조
</span></span><span class=line><span class=cl>    └── .git         # 포인터 파일 (실제 .git은 부모의 .git/modules에 있음)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 서브트리 구조
</span></span><span class=line><span class=cl>main-repo/
</span></span><span class=line><span class=cl>├── .git/
</span></span><span class=line><span class=cl>├── project-files/
</span></span><span class=line><span class=cl>└── subtree-dir/     # 일반 디렉토리로 취급
</span></span><span class=line><span class=cl>    └── files        # 모든 파일이 메인 저장소의 일부
</span></span></code></pre></td></tr></table></div></div><h3 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h3><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>• 코드 재사용성 높음<br>• 의존성 버전 고정으로 안정성 확보<br>• 저장소 크기가 작게 유지됨<br>• 접근 제어가 명확함<br>• 모듈별 독립적인 히스토리 유지<br>• 외부 저장소 변경에 영향 받지 않음</td><td>• 코드 공유 용이성<br>• 직접 수정 가능성<br>• 양방향 동기화 지원<br>• 별도 초기화 없이 즉시 사용 가능<br>• 기존 Git 명령어와 워크플로우 유지<br>• 단일 저장소로 CI/CD 파이프라인 간소화</td></tr><tr><td><strong>단점</strong></td><td>• 복잡한 워크플로우<br>• 추가 학습 필요<br>• 초기화/업데이트 단계 필요<br>• 실수로 하위 모듈 변경 시 문제 발생 가능<br>• 원격 저장소 접근 불가 시 작업 제한<br>• 브랜치 전환 시 서브모듈 상태 관리 복잡</td><td>• 명령어가 복잡하고 기억하기 어려움<br>• 저장소 크기 증가<br>• 접근 제어 제한적<br>• 하위 저장소 위치를 기억해야 함<br>• 히스토리 오염으로 가독성 저하<br>• 원본 저장소 접근 권한 없을 때 업데이트 불가</td></tr></tbody></table><h3 id=3-핵심-개념-및-비교-분석>3. 핵심 개념 및 비교 분석<a hidden class=anchor aria-hidden=true href=#3-핵심-개념-및-비교-분석>#</a></h3><h4 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h4><table><thead><tr><th>항목</th><th>Git Submodule</th><th>Git Subtree</th></tr></thead><tbody><tr><td>버전 고정</td><td>O (commit 단위)</td><td>O (병합 시점 기준 snapshot)</td></tr><tr><td>코드 공유</td><td>O</td><td>O</td></tr><tr><td>업데이트 동기화</td><td>수동</td><td>수동 혹은 자동 스크립트화 가능</td></tr><tr><td>분리 배포 가능성</td><td>높음 (완전 분리)</td><td>낮음 (일체화됨)</td></tr></tbody></table><h4 id=목적-비교>목적 비교<a hidden class=anchor aria-hidden=true href=#목적-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>주요 목적</td><td>외부 저장소에 대한 참조만 저장하여 프로젝트 관리</td><td>외부 저장소의 코드를 메인 저장소에 통합</td></tr><tr><td>코드 분리</td><td>코드 베이스를 분리된 상태로 유지</td><td>코드 베이스를 하나로 통합</td></tr><tr><td>저장소 간 관계</td><td>느슨한 결합 (Loose coupling) 유지</td><td>더 강한 결합 (Tight coupling) 형성</td></tr><tr><td>버전 관리</td><td>외부 저장소의 특정 버전 참조</td><td>외부 저장소의 코드와 히스토리 병합</td></tr></tbody></table><h4 id=필요성-비교>필요성 비교<a hidden class=anchor aria-hidden=true href=#필요성-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>외부 라이브러리 관리</td><td>외부 라이브러리의 업데이트 명시적 관리 가능</td><td>외부 라이브러리 코드를 직접 통합하여 관리</td></tr><tr><td>여러 프로젝트에서 코드 공유</td><td>코드를 여러 프로젝트에서 독립적으로 참조</td><td>코드 복제본을 각 프로젝트에 포함</td></tr><tr><td>모듈화</td><td>코드베이스 모듈화에 적합</td><td>단일 코드베이스 관리에 적합</td></tr><tr><td>코드 기여</td><td>외부 프로젝트에 직접 기여 용이</td><td>변경사항을 다시 업스트림에 푸시하기 복잡할 수 있음</td></tr></tbody></table><h4 id=주요-기능-비교>주요 기능 비교<a hidden class=anchor aria-hidden=true href=#주요-기능-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>코드 포함 방식</td><td>참조 링크만 포함</td><td>코드 전체 복사 및 통합</td></tr><tr><td>히스토리 관리</td><td>외부 저장소 히스토리와 분리</td><td>외부 저장소 히스토리 통합</td></tr><tr><td>변경 추적</td><td>메인 저장소와 서브모듈 변경 별도 추적</td><td>모든 변경이 메인 저장소에서 추적</td></tr><tr><td>업데이트 방식</td><td>명시적 업데이트 명령 필요</td><td>일반적인 깃 명령으로 관리 가능</td></tr><tr><td>저장소 접근</td><td>서브모듈에 접근하려면 별도 초기화 필요</td><td>클론 후 즉시 모든 코드 접근 가능</td></tr></tbody></table><h4 id=역할-비교>역할 비교<a hidden class=anchor aria-hidden=true href=#역할-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>프로젝트 구조화</td><td>독립적인 모듈로 구조화</td><td>통합된 단일 구조로 관리</td></tr><tr><td>팀 협업</td><td>팀 간 명확한 코드 소유권 분리</td><td>단일 팀이 전체 코드베이스 관리</td></tr><tr><td>의존성 관리</td><td>외부 의존성 명시적 관리</td><td>의존성을 내부화하여 관리</td></tr><tr><td>코드 재사용</td><td>여러 프로젝트 간 코드 재사용 촉진</td><td>프로젝트별 코드 사본 관리</td></tr></tbody></table><h4 id=특징-비교>특징 비교<a hidden class=anchor aria-hidden=true href=#특징-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>학습 곡선</td><td>비교적 가파른 학습 곡선</td><td>더 직관적인 사용법</td></tr><tr><td>설정 복잡성</td><td>초기 설정 복잡</td><td>더 간단한 설정</td></tr><tr><td>독립성</td><td>독립적인 저장소 유지</td><td>메인 저장소와 통합</td></tr><tr><td>크기 영향</td><td>메인 저장소 크기 작게 유지</td><td>메인 저장소 크기 증가</td></tr><tr><td>팀 이해도</td><td>팀원이 서브모듈 개념 이해 필요</td><td>일반적인 깃 지식만으로 접근 가능</td></tr><tr><td>협업 관리</td><td>어렵고 복잡</td><td>단순함</td></tr></tbody></table><h4 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>코드 통합 유형</td><td>참조 기반 통합</td><td>복사 기반 통합</td></tr><tr><td>사용 시나리오</td><td>외부 의존성이 자주 변경되지 않는 경우</td><td>외부 코드를 내부화하려는 경우</td></tr><tr><td>복잡성 수준</td><td>복잡한 구성, 명시적 관리</td><td>단순한 구성, 묵시적 관리</td></tr><tr><td>적합한 프로젝트 크기</td><td>대규모 모듈화된 프로젝트</td><td>중소규모 프로젝트</td></tr></tbody></table><h4 id=적합한-사용-사례>적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#적합한-사용-사례>#</a></h4><table><thead><tr><th>Git Submodule</th><th>Git Subtree</th></tr></thead><tbody><tr><td>컴포넌트나 서브프로젝트가 빠르게 변경되어 API 를 손상시킬 수 있을 때 안전을 위해 코드를 특정 커밋에 고정</td><td>코드를 한 번만 외부 저장소에서 복사하거나 가끔씩만 가져오려는 경우</td></tr><tr><td>자주 업데이트되지 않는 의존성을 추적하고자 할 때</td><td>팀이 명시적인 의존성 관리의 복잡성 없이 단순성을 선호할 때</td></tr><tr><td>외부 코드의 커밋 이력과 메인 프로젝트의 이력을 명확히 분리해야 할 때</td><td>외부 코드를 프로젝트의 일부로 취급하고 관리하려 할 때</td></tr><tr><td>여러 프로젝트에서 공유하는 코드의 버전을 엄격하게 관리해야 할 때</td><td>외부 코드를 수정하고 원본 저장소로 변경사항을 다시 쉽게 전달할 필요가 없을 때</td></tr></tbody></table><h4 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>프레임워크 통합</td><td>프레임워크를 서브모듈로 참조하여 업데이트 관리</td><td>프레임워크 코드를 직접 통합하여 맞춤화</td></tr><tr><td>라이브러리 관리</td><td>외부 라이브러리를 참조하여 버전 고정</td><td>라이브러리 코드를 직접 통합하여 내부 수정 용이</td></tr><tr><td>마이크로서비스</td><td>마이크로서비스 간 공통 코드 관리</td><td>서비스별 독립적 코드베이스 유지</td></tr><tr><td>플러그인 시스템</td><td>플러그인을 별도 저장소로 관리</td><td>플러그인 코드를 메인 코드베이스에 통합</td></tr><tr><td>오픈소스 기여</td><td>오픈소스 프로젝트를 서브모듈로 포함하여 기여</td><td>오픈소스 코드 일부를 가져와 내부 사용</td></tr><tr><td>독립된 프로젝트 종속성</td><td>Submodule</td><td>서로 분리된 독립 유지가 필요함</td></tr></tbody></table><h4 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>초기 설정</td><td><code>git submodule add</code> 명령으로 추가 필요</td><td><code>git subtree add</code> 명령으로 추가 필요</td></tr><tr><td>클론 후 작업</td><td><code>git submodule init</code> 및 <code>git submodule update</code> 필요</td><td>별도 초기화 필요 없음</td></tr><tr><td>팀 교육</td><td>팀원들에게 서브모듈 워크플로우 교육 필요</td><td>일반적인 깃 워크플로우만 교육 필요</td></tr><tr><td>문서화</td><td>서브모듈 사용에 대한 명확한 문서화 필요</td><td>서브트리 명령어에 대한 문서화 필요</td></tr><tr><td>분리된 저장소 관리</td><td>서브모듈 저장소 접근 권한 관리 필요</td><td>중앙 저장소 접근 권한만 관리</td></tr><tr><td>외부 의존성 변경</td><td>의존성 변경 시 명시적 업데이트 필요</td><td>의존성 변경 시 병합 충돌 관리 필요</td></tr></tbody></table><h4 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>저장소 크기</td><td>참조만 저장하여 메인 저장소 크기 작게 유지</td><td>모든 코드를 복사하여 저장소 크기 증가</td></tr><tr><td>클론 시간</td><td>서브모듈 초기화로 인해 클론 시간 증가</td><td>초기 클론 시간 짧음</td></tr><tr><td>히스토리 검색</td><td>분리된 히스토리로 검색 성능 향상</td><td>통합된 히스토리로 검색 복잡성 증가</td></tr><tr><td>캐싱 효율성</td><td>모듈별 캐싱으로 효율적인 작업 가능</td><td>전체 저장소 변경으로 캐싱 효율 감소</td></tr><tr><td>병렬 작업</td><td>모듈별 독립적 작업 가능</td><td>단일 저장소 내 작업 의존성 증가</td></tr><tr><td>대규모 프로젝트</td><td>대규모 프로젝트에서 모듈화로 성능 향상</td><td>대규모 프로젝트에서 저장소 크기 문제 발생 가능</td></tr><tr><td>빌드 성능</td><td>불필요한 모듈은 체크아웃 안 해도 됨</td><td>전체 포함되므로 필요 시 디렉토리 분리 빌드</td></tr><tr><td>동기화 전략</td><td>fetch + checkout 조합 최적화</td><td>스크립트를 통한 업데이트 자동화</td></tr><tr><td>CI/CD</td><td>서브모듈 경로 인식 문제 대응 필요</td><td>일체형 관리로 구성 쉬움</td></tr></tbody></table><h4 id=개발자-경험-비교>개발자 경험 비교<a hidden class=anchor aria-hidden=true href=#개발자-경험-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>초기 설정 복잡성</td><td>높음 - <code>.gitmodules</code> 파일 및 여러 단계 필요</td><td>중간 - 단일 명령으로 시작 가능</td></tr><tr><td>일상적 사용</td><td>복잡함 - 특별한 명령어 지식 필요</td><td>단순함 - 일반 깃 워크플로우와 유사</td></tr><tr><td>학습 곡선</td><td>가파름 - 특정 개념과 명령어 학습 필요</td><td>완만함 - 기존 깃 지식으로 접근 가능</td></tr><tr><td>디버깅 용이성</td><td>어려움 - 서브모듈 상태 추적이 복잡</td><td>중간 - 일반 깃 디버깅 기술 적용 가능</td></tr><tr><td>팀 도입 난이도</td><td>높음 - 모든 팀원이 서브모듈 개념 이해 필요</td><td>낮음 - 일반 깃 지식으로 충분</td></tr></tbody></table><h4 id=성능-비교>성능 비교<a hidden class=anchor aria-hidden=true href=#성능-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>클론 속도</td><td>느림 - 서브모듈 초기화/업데이트 필요</td><td>빠름 - 모든 코드가 즉시 사용 가능</td></tr><tr><td>저장소 크기</td><td>작음 - 참조만 저장</td><td>큼 - 전체 코드 및 히스토리 저장</td></tr><tr><td>브랜치 전환 속도</td><td>느림 - 서브모듈 업데이트 필요</td><td>빠름 - 즉시 전환 가능</td></tr><tr><td>대규모 프로젝트 확장성</td><td>좋음 - 모듈화로 성능 유지</td><td>제한적 - 저장소 크기 증가로 성능 저하 가능</td></tr><tr><td>네트워크 요구사항</td><td>높음 - 서브모듈 저장소 접근 필요</td><td>낮음 - 클론 후 네트워크 접근 불필요</td></tr></tbody></table><h4 id=cicd-통합-비교>CI/CD 통합 비교<a hidden class=anchor aria-hidden=true href=#cicd-통합-비교>#</a></h4><table><thead><tr><th>구분</th><th>깃 서브모듈 (Git Submodule)</th><th>깃 서브트리 (Git Subtree)</th></tr></thead><tbody><tr><td>설정 복잡성</td><td>높음 - 서브모듈 초기화 단계 필요</td><td>낮음 - 추가 설정 불필요</td></tr><tr><td>빌드 안정성</td><td>낮음 - 외부 저장소 의존으로 불안정 가능</td><td>높음 - 모든 코드가 저장소 내에 있음</td></tr><tr><td>빌드 속도</td><td>느림 - 서브모듈 초기화 시간 필요</td><td>빠름 - 추가 초기화 불필요</td></tr><tr><td>의존성 추적</td><td>명시적 - 특정 커밋 참조</td><td>암시적 - 코드 통합으로 인한 추적 어려움</td></tr><tr><td>자동화 용이성</td><td>어려움 - 복잡한 스크립트 필요</td><td>쉬움 - 표준 깃 워크플로우 활용</td></tr></tbody></table><h3 id=최근근-동향>최근근 동향<a hidden class=anchor aria-hidden=true href=#최근근-동향>#</a></h3><p>두 기술 모두 진화하고 있으며 다음과 같은 동향이 나타나고 있다:</p><ul><li><strong>하이브리드 접근법</strong>: 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 방식이 인기를 얻고 있다.</li><li><strong>자동화 도구</strong>: CI/CD 파이프라인과의 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다.</li><li><strong>대안 솔루션</strong>: git-subrepo 와 같이 두 기술의 장점을 결합한 새로운 대안 도구들이 등장하고 있다.</li><li><strong>AI 기반 자동화</strong>: 병합 충돌 해결 및 의존성 관리를 위한 AI 기반 도구가 발전하고 있다.</li><li><strong>보안 강화</strong>: 의존성 취약점 관리와 접근 제어를 강화하는 추가 기능들이 도입되고 있다.</li></ul><p>결론적으로, Git Submodule 은 외부 의존성을 특정 버전으로 고정하고 독립적으로 관리하는 데 적합하며, Git Subtree 는 외부 코드를 프로젝트에 통합하고 단일 저장소처럼 관리하는 데 더 적합하다. 프로젝트의 특성과 팀의 워크플로우에 따라 적절한 도구를 선택하거나 하이브리드 접근법을 고려하는 것이 중요하다.</p><h3 id=추가-학습-내용>추가 학습 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-내용>#</a></h3><table><thead><tr><th>학습 주제</th><th>서브모듈 관련 내용</th><th>서브트리 관련 내용</th></tr></thead><tbody><tr><td>고급 깃 명령어</td><td><code>git submodule foreach</code>, <code>git submodule sync</code>, <code>git submodule deinit</code></td><td><code>git subtree split</code>, <code>git subtree merge</code>, <code>git subtree push</code></td></tr><tr><td>충돌 해결</td><td>서브모듈 참조 충돌 해결 방법</td><td>서브트리 병합 충돌 해결 전략</td></tr><tr><td>CI/CD 통합</td><td>서브모듈이 있는 프로젝트의 CI/CD 파이프라인 구성</td><td>서브트리 프로젝트의 CI/CD 자동화</td></tr><tr><td>모노레포 전략</td><td>서브모듈을 활용한 모노레포 관리</td><td>서브트리 기반 모노레포 아키텍처</td></tr><tr><td>마이그레이션</td><td>일반 저장소에서 서브모듈로 전환 방법</td><td>서브모듈에서 서브트리로 마이그레이션</td></tr><tr><td>보안 고려사항</td><td>서브모듈의 보안 취약점 관리</td><td>서브트리 코드의 보안 감사</td></tr><tr><td>분산 팀 협업</td><td>분산된 팀에서 서브모듈 관리 전략</td><td>서브트리 기반 협업 워크플로우</td></tr><tr><td>히스토리 관리</td><td>서브모듈 히스토리와 메인 저장소 히스토리 통합</td><td>서브트리 커밋 히스토리 관리 및 정리</td></tr><tr><td>성능 최적화</td><td>대규모 서브모듈 프로젝트 성능 향상 기법</td><td>서브트리 저장소 크기 및 성능 최적화</td></tr><tr><td>자동화 도구</td><td>서브모듈 관리 자동화 스크립트 개발</td><td>서브트리 워크플로우 자동화 도구</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>CBD</strong></td><td>컴포넌트 단위 개발 (예: 라이브러리 분리)</td></tr><tr><td><strong>SBD</strong></td><td>시스템 단위 개발 (예: 통합 코드베이스)</td></tr><tr><td>깃 서브모듈 (Git Submodule)</td><td>메인 저장소 내에 다른 저장소에 대한 참조를 포함하는 기능으로, 외부 저장소의 특정 커밋을 참조</td></tr><tr><td>깃 서브트리 (Git Subtree)</td><td>외부 저장소의 코드를 메인 저장소에 복사하여 통합하는 기능으로, 외부 코드의 전체 히스토리를 메인 저장소에 병합</td></tr><tr><td>.gitmodules</td><td>서브모듈 URL, 로컬 경로, 브랜치 정보 등 서브모듈 구성 정보를 저장하는 설정 파일</td></tr><tr><td>서브모듈 초기화 (Submodule Init)</td><td>서브모듈의 로컬 구성을 초기화하는 과정 (<code>git submodule init</code>)</td></tr><tr><td>서브모듈 업데이트 (Submodule Update)</td><td>서브모듈 코드를 지정된 커밋으로 업데이트하는 과정 (<code>git submodule update</code>)</td></tr><tr><td>서브트리 추가 (Subtree Add)</td><td>외부 저장소를 서브트리로 추가하는 과정 (<code>git subtree add</code>)</td></tr><tr><td>서브트리 병합 (Subtree Merge)</td><td>서브트리 변경사항을 메인 저장소에 병합하는 과정 (<code>git subtree merge</code>)</td></tr><tr><td>스쿼시 (Squash)</td><td>여러 커밋을 하나의 커밋으로 압축하는 것으로, 서브트리에서 히스토리 관리를 위해 자주 사용 (<code>--squash</code>)</td></tr><tr><td>업스트림 (Upstream)</td><td>원본 코드가 있는 저장소로, 서브모듈이나 서브트리에서 변경사항을 푸시하는 대상</td></tr><tr><td>모노레포 (Monorepo)</td><td>여러 프로젝트나 모듈을 단일 저장소에서 관리하는 방식</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.atlassian.com/git/tutorials/git-submodule>Atlassian Submodule 설명 문서</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Atlassian Subtree 설명 문서</a></li><li><a href=https://git-scm.com/book/en/v2/Git-Tools-Submodules>Git 공식 문서 - Submodule</a></li><li><a href=https://github.blog/2020-02-14-git-subtree-merge/>GitHub 블로그: Subtree 활용 사례</a></li><li><a href=https://medium.com/>Medium: Git Submodule vs Subtree (2024 업데이트)</a></li><li><a href=https://git-scm.com/book/en/v2/Git-Tools-Submodules>Git - Submodules</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Git Subtree: Alternative to Git Submodule | Atlassian Git Tutorial</a></li><li><a href=https://www.graphapp.ai/blog/git-submodule-vs-subtree-which-is-right-for-your-project>Git Submodule vs Subtree: Which Is Right for Your Project? | Graph AI</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-submodule>Git submodule | Atlassian</a></li><li><a href=https://blog.jetbrains.com/space/2023/11/21/space-git-subtree/>Introducing the Space Git Subtree | The Space Blog</a></li><li><a href=https://www.geeksforgeeks.org/git-subtree/>Git – Subtree | GeeksforGeeks</a></li><li><a href=https://github.blog/open-source/git/working-with-submodules/>Working with submodules - The GitHub Blog</a></li><li><a href=https://gist.github.com/gitaarik/8735255>Git Submodules basic explanation | GitHub Gist</a></li><li><a href=https://gist.github.com/kvnsmth/4688345>A real world usage for git subtrees | GitHub Gist</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/version-control-systems/>Version-Control-Systems</a></li><li><a href=https://buenhyden.github.io/tags/git-workflow/>Git-Workflow</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/><span class=title>« Prev</span><br><span>Primitive vs Non-Primitive structure</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/overview/devops/><span class=title>Next »</span><br><span>DevOps</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>