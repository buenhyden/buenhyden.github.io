<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MonoRepo vs. MultiRepo | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,Version-Control-Systems,Enterprise-Usage"><meta name=description content="모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MonoRepo vs. MultiRepo"><meta property="og:description" content="모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T06:18:00+00:00"><meta property="article:modified_time" content="2024-09-30T06:18:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="Version-Control-Systems"><meta property="article:tag" content="Enterprise-Usage"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MonoRepo vs. MultiRepo"><meta name=twitter:description content="모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"MonoRepo vs. MultiRepo","item":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MonoRepo vs. MultiRepo","name":"MonoRepo vs. MultiRepo","description":"모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다.","keywords":["DevOps-and-Infrastructure","Version-Control-Systems","Enterprise-Usage"],"articleBody":"MonoRepo vs. MultiRepo 모노레포 (Monorepo) 와 멀티레포 (Multirepo) 는 소프트웨어 개발에서 코드베이스를 관리하는 대표적인 두 가지 전략이다. MonoRepo는 여러 프로젝트를 하나의 저장소에서 관리하는 방식으로, 코드 공유와 일관된 개발 환경을 제공한다. 반면, MultiRepo는 각 프로젝트를 별도의 저장소에서 관리하여 독립성과 유연성을 강조한다.\n이 두 접근 방식은 코드 공유, 종속성 관리, 빌드 시스템, 팀 협업, 확장성 등의 측면에서 서로 다른 장단점을 가지고 있다. 프로젝트의 규모, 팀 구조, 회사 문화, 기술 스택 등 다양한 요소에 따라 적합한 방식이 달라질 수 있으며, 최근에는 두 방식의 장점을 결합한 하이브리드 접근법이나 각 방식의 단점을 보완하는 도구들도 등장하고 있다.\n정의 및 기능 구분 모노레포 (Monorepo) 멀티레포 (Multirepo) 정의 여러 프로젝트 (서비스, 라이브러리 등) 가 하나의 저장소 (리포지토리) 에서 관리되는 방식 각 프로젝트 (서비스, 라이브러리 등) 가 독립적인 저장소 (리포지토리) 에서 관리되는 방식 목적 코드 공유, 일관된 개발 환경, 중앙 집중식 관리 프로젝트 간 독립성, 유연한 관리, 보안 강화 개발 환경에서의 역할 통합된 개발 환경 제공 독립적인 개발 환경 제공 협업에서의 역할 팀 간 협업 및 코드 공유 촉진 팀 자율성 보장 및 독립적 의사결정 지원 아키텍처에서의 역할 일관된 아키텍처 적용 서비스별 최적 아키텍처 선택 배포에서의 역할 조정된 배포 및 통합 테스트 독립적 배포 및 테스트 코드 공유 공통 라이브러리 및 모듈의 재사용 용이 공통 코드의 공유가 어려워 중복 가능성 존재\n패키지 관리자를 통한 코드 공유 의존성 관리 내부 의존성 자동 추적 외부 패키지로 의존성 관리 리팩토링 전체 코드베이스에 대한 원자적 변경 용이 저장소별 독립적 리팩토링 (의존성 영향 관리 필요) 버전 관리 전체 프로젝트에 대한 일관된 버전 관리 각 프로젝트별 독립적인 버전 관리 CI/CD 통합 파이프라인 및 변경 영향 분석 기반 빌드 저장소별 독립적 파이프라인 권한 관리 세분화된 권한 관리 어려움 프로젝트별 세부적인 권한 설정 가능 코드 조직 프로젝트별 디렉토리 구조 또는 패키지 기반 구조 각 저장소는 자체적인 디렉토리 구조를 가짐 예시 프론트엔드, 백엔드, 공통 라이브러리 등이 한 저장소에 모여 있음 각 서비스별, 라이브러리별로 별도의 저장소를 사용함 특징 항목 MonoRepo MultiRepo 가시성 모든 코드가 투명하게 공개됨 팀별로 코드 접근 제한 가능 일관성 코드 스타일, 도구, 프로세스의 통일성 팀별 맞춤형 도구 및 프로세스 빌드 시스템 대규모 빌드 시스템 필요 (Bazel, Buck 등) 간단한 빌드 시스템으로 충분 변경 영향 변경 영향을 즉시 확인 가능 의존성 관계에 따라 영향 파악 어려움 저장소 크기 매우 큰 단일 저장소 여러 개의 작은 저장소 핵심 원칙 항목 MonoRepo MultiRepo 코드 공유 원칙 내부 직접 참조를 통한 코드 재사용 패키지 및 라이브러리를 통한 코드 공유 버전 관리 원칙 단일 버전 (항상 최신) 독립적 버전 관리 리뷰 프로세스 광범위한 코드 리뷰 및 표준 적용 팀별 맞춤형 리뷰 프로세스 테스트 전략 통합 테스트 우선 개별 서비스 테스트 우선 성능 관리 빌드 최적화 도구 및 캐싱 필수 기본 빌드 도구로 충분 목적 및 필요성 비교 항목 MonoRepo MultiRepo 목적 주요 목적 코드 재사용 및 통합 개발 환경 제공 독립적인 개발 및 배포 환경 제공 협업 목표 전사적 코드 표준화 및 일관성 유지 팀 자율성 및 독립적 개발 속도 보장 의존성 관리 내부 의존성 자동 해결 및 통합 관리 명시적 의존성 관리 및 버전 제어 빌드 최적화 전체 시스템의 일관된 빌드 및 통합 테스트 개별 시스템의 독립적 빌드 및 테스트 필요성 기술적 필요성 상호 의존적인 여러 프로젝트의 통합 관리 독립적 서비스의 분리된 관리 조직적 필요성 대규모 팀의 코드 공유 및 표준화 자율적 팀별 개발 속도와 결정권 부여 확장 관점 공통 코드베이스를 통한 일관된 확장 독립적 확장 및 기술 스택 다양화 배포 관점 통합 배포 전략 및 조정된 출시 개별 서비스 독립적 배포 주기 개발 워크플로우 비교 개발 활동 모노레포 워크플로우 멀티레포 워크플로우 새 기능 개발 단일 저장소에서 브랜치 생성, 필요한 모든 프로젝트 변경 관련 저장소 각각에서 브랜치 생성, 저장소별 변경 코드 리뷰 모든 변경에 대한 통합 리뷰, 영향 범위 명확 저장소별 독립적 리뷰, 크로스 리뷰 필요할 수 있음 테스트 변경 영향에 따른 통합 테스트 자동 실행 저장소별 독립 테스트, 통합 테스트는 별도 단계 버그 수정 모든 영향 코드에 원자적 수정 적용 저장소별 개별 수정, 릴리스 조정 필요 릴리스 조정된 릴리스 계획, 다중 프로젝트 동시 릴리스 독립적 릴리스 주기, 의존성 버전 관리 필요 롤백 관련된 모든 변경 동시 롤백 의존 관계에 따른 순차적 롤백 전략 필요 의존성 업데이트 내부 의존성 즉시 반영, 원자적 업데이트 의존성 패키지 릴리스 후 소비 저장소 업데이트 온보딩 초기 설정 복잡하지만 전체 시스템 이해 용이 초기 설정 간단하지만 전체 시스템 이해에 시간 소요 팀 구조 적합성 비교 팀 구조 모노레포 적합성 멀티레포 적합성 권장 접근법 단일 제품 소규모 팀 매우 높음 보통 간단한 모노레포 설정 다중 제품 대규모 팀 보통 (도구 투자 필요) 높음 제품별 멀티레포 또는 고급 모노레포 마이크로서비스 아키텍처 보통 높음 서비스별 멀티레포 또는 모듈식 모노레포 지리적으로 분산된 팀 낮음 (지연 시간 이슈) 높음 지역별 멀티레포 또는 하이브리드 접근법 독립적 비즈니스 유닛 낮음 매우 높음 유닛별 멀티레포 오픈소스 프로젝트 상황에 따라 다름 높음 핵심 - 플러그인 모델 또는 멀티레포 플랫폼 및 앱 구조 높음 보통 플랫폼 모노레포 + 앱 멀티레포 스타트업 빠른 실험 초기: 높음, 성장 후: 평가 필요 확장 단계에서 높음 성장에 따른 진화 전략 주요 원리 MonoRepo 주요 원리 MonoRepo 의 핵심 원리는 \" 단일 진실 소스 (Single Source of Truth)\" 와 \" 통합 개발 환경 (Unified Development Environment)\" 이다.\n이는 다음과 같은 원리로 구현된다:\n원자적 변경 (Atomic Changes): 여러 프로젝트에 걸친 변경사항을 단일 커밋으로 처리 모든 의존 프로젝트가 항상 동기화된 상태 유지 단일 버전 (Single Version): 모든 내부 의존성이 항상 최신 버전 사용 버전 불일치 문제 원천 차단 투명한 의존성 (Transparent Dependencies): 모든 프로젝트 간 의존성이 명확하게 가시화됨 의존성 그래프가 자동으로 빌드 시스템에 의해 관리 전역 리팩토링 (Global Refactoring): 전체 코드베이스에 걸친 변경을 안전하게 적용 가능 모든 의존 프로젝트에 대한 영향 즉시 확인 공유 리소스 (Shared Resources): 공통 코드, 설정, 도구를 모든 프로젝트가 공유 중복 없이 표준화된 개발 환경 제공 MultiRepo 주요 원리 MultiRepo 의 핵심 원리는 \" 분리된 관심사 (Separation of Concerns)\" 와 \" 독립적 진화 (Independent Evolution)\" 이다.\n이는 다음과 같은 원리로 구현된다:\n독립적 버전 관리 (Independent Versioning): 각 프로젝트가 자체 버전 관리 체계를 가짐 SemVer 등을 통한 명확한 버전 의존성 표현 느슨한 결합 (Loose Coupling): 프로젝트 간 의존성을 명시적 인터페이스로 제한 API 계약을 통한 상호작용 자율성 (Autonomy): 팀이 독립적인 기술 스택 및 도구 선택 가능 개별 프로젝트의 특성에 맞는 최적화 가능 분산 책임 (Distributed Responsibility): 각 팀이 자신의 코드에 대한 온전한 책임 부여 독립적인 품질 관리 및 배포 결정권 선택적 공유 (Selective Sharing): 재사용이 필요한 코드만 패키지로 추출하여 공유 명시적 의존성 선언을 통한 투명한 사용 MonoRepo vs. MultiRepo 아키텍처 다이어그램 MonoRepo 구성 예시 구성 요소:\n공통 라이브러리 여러 애플리케이션 통합된 CI/CD 파이프라인 중앙 집중식 버전 관리 특징:\n코드 공유와 재사용이 용이 일관된 개발 환경 유지 대규모 프로젝트 관리에 적합 1 2 3 4 5 6 7 8 9 10 11 12 13 /monorepo ├── apps │ ├── service-a │ └── service-b ├── libs │ ├── shared-ui │ └── auth-utils ├── tools │ └── custom-scripts ├── .gitignore ├── nx.json ├── workspace.json └── package.json apps/: 각 서비스 애플리케이션 libs/: 공통 라이브러리 (재사용 가능) tools/: 프로젝트 전체에 쓰이는 도구 모음 MultiRepo 구성 예시 구성 요소:\n프로젝트별 독립된 저장소 개별 CI/CD 파이프라인 독립적인 버전 관리 특징:\n프로젝트 간 독립성 확보 유연한 관리와 보안 강화 작은 규모의 팀이나 프로젝트에 적합 1 2 3 4 5 6 7 8 9 10 11 / ── service-a-repo ├── src/ └── package.json / ── service-b-repo ├── src/ └── package.json / ── shared-ui-repo ├── components/ └── package.json 저장소 분리로 인해 각 repo 별 CI/CD, 권한 설정이 별도 운영됨 의존성/버전 통합은 별도 자동화 필요 장단점 비교 모노레포 (Monorepo) 항목 모노레포 (Monorepo) 장점 모노레포 (Monorepo) 단점 코드 공유 여러 프로젝트 간 코드 공유와 재사용이 매우 용이함 무분별한 의존성 증가로 코드 복잡성이 커질 수 있음 의존성 관리 의존성 관리가 간단하며, 버전 충돌 위험이 적음 의존성 연결이 쉬워 과도한 의존 관계가 발생할 수 있음 통합 버전 관리 모든 프로젝트가 동일한 버전으로 관리되어 무결성 유지가 쉬움 단일 저장소의 크기가 커지면 빌드, CI 속도가 느려질 수 있음 아토믹 커밋 여러 프로젝트에 걸친 변경을 한 번에 (atomic 하게) 반영 가능 단일 저장소에서 다수의 개발자가 동시에 작업 시 충돌 가능성이 높아짐 협업 팀 간 협업이 용이, 전체 코드에 대한 가시성이 높음 접근 제어가 어렵고, 모든 개발자가 모든 코드에 접근하게 됨 멀티레포 (Multirepo) 항목 멀티레포 (Multirepo) 장점 멀티레포 (Multirepo) 단점 독립성 각 프로젝트가 독립적으로 개발/배포/버전 관리 가능 코드 재사용성이 떨어지고, 중복 코드가 증가할 수 있음 오너십 각 저장소 별로 오너십 명확, 접근 제어가 용이함 여러 저장소에 걸친 코드 리뷰 및 관리 포인트 증가 빠른 빌드/CI 속도 저장소 크기가 작아 빌드 및 CI 속도가 빠름 의존성 관리가 복잡해지고, 디펜던시 헬 (Dependency Hell) 발생 가능 자율성 팀이 자율적으로 기술 스택, 릴리즈 주기 선택 가능 공통 코드 변경 시 여러 저장소에 반영해야 해 번거로움 실무 적용 예시 조직 접근 방식 적용 사례 Google MonoRepo 모든 코드를 하나의 저장소에서 관리하며, 자체 개발한 Piper 와 Bazel 을 사용하여 대규모 프로젝트를 효율적으로 운영 Meta (Facebook) MonoRepo Mercurial 을 기반으로 한 대규모 MonoRepo 를 운영하며, 자체 개발한 도구로 성능을 최적화 Microsoft MonoRepo Windows 개발을 위한 MonoRepo 를 운영하며, Git 과 GVFS 를 활용하여 대규모 코드베이스를 관리 Netflix MultiRepo 서비스별로 독립된 저장소를 운영하여, 각 팀의 독립성과 유연성을 확보 Google, Meta 사례 기반 구조 선택 전략 Google 의 모노레포 전략 Google 은 세계에서 가장 큰 모노레포 중 하나를 운영하고 있으며, 다음과 같은 전략적 선택을 기반으로 한다:\n코드 가시성과 재사용: Google 은 모든 코드가 회사 내에서 투명하게 공유되어야 한다는 문화적 가치를 중요시한다. 내부 라이브러리의 광범위한 재사용을 통해 개발 효율성을 높인다. 통합 도구 체인: Bazel 빌드 시스템을 개발하여 대규모 코드베이스의 빌드 시간을 최적화했다. 코드 검색, 코드 리뷰, 테스트 도구 등이 모두 통합된 환경을 제공한다. 표준화된 개발 환경: 모든 개발자가 동일한 도구와 프로세스를 사용하도록 표준화하여 생산성을 향상시킨다. 새로운 직원이 빠르게 적응할 수 있는 일관된 환경을 제공한다. 증분 테스트 및 빌드: 변경된 코드와 그 영향을 받는 부분만 선택적으로 테스트하고 빌드하는 시스템을 구축했다. 자동화된 테스트와 의존성 분석을 통해 품질을 유지한다. Meta(Facebook) 의 모노레포 전략 Meta 는 Buck 빌드 시스템을 중심으로 대규모 모노레포를 구축했다:\n관련 코드 그룹화: 관련된 서비스와 프로젝트를 논리적으로 그룹화하여 코드 구조를 관리한다. 공통 인프라와 라이브러리를 공유하여 일관성을 유지한다. 지속적 통합과 검증: 모든 커밋이 전체 코드베이스의 안정성에 미치는 영향을 즉시 확인한다. 지속적인 테스트와 검증으로 품질 저하를 방지한다. 팀 경계 유연화: 팀 간 경계를 유연하게 하여 협업과 지식 공유를 촉진한다. 개발자가 다양한 영역의 코드에 기여할 수 있는 문화를 조성한다. 확장 가능한 인프라: 분산 빌드 시스템과 캐싱을 통해 빌드 성능을 최적화한다. 대규모 개발자 팀을 지원하기 위한 도구와 인프라를 지속적으로 개선한다. 구조 선택 전략 비교 요소 Google/Meta 모노레포 전략 Amazon/Netflix 멀티레포 전략 조직 구조 중앙화된 엔지니어링 문화, 유동적 팀 구조 자율적인 팀 구조, Two-Pizza 팀 모델 기술 표준화 전사적 표준 도구 및 프로세스 팀별 맞춤형 기술 스택 확장 접근법 도구 및 인프라 고도화를 통한 확장 독립적 서비스 및 저장소를 통한 확장 빌드 최적화 맞춤형 빌드 시스템 (Bazel, Buck) 개발 작은 코드베이스와 표준 빌드 도구 활용 리팩토링 철학 전체 코드베이스 원자적 변경 서비스 경계를 존중하는 점진적 변경 배포 전략 조정된 릴리스와 배포 독립적이고 지속적인 서비스별 배포 적합한 상황 모노레포 (Monorepo) 가 적합한 경우\n프로젝트 간 강한 의존성, 코드 공유가 많을 때 작은~중간 규모의 팀, 통합된 개발/배포 환경이 필요할 때 대규모 리팩터링, 통합 테스트가 빈번할 때 멀티레포 (Multirepo) 가 적합한 경우\n각 서비스/라이브러리별로 독립적인 개발/배포/버전 관리가 필요할 때 대규모 조직, 여러 팀이 자율적으로 작업할 때 접근 제어, 보안 이슈가 중요한 경우 활용 예시 시나리오: 대규모 조직에서 여러 팀이 다양한 서비스를 개발하는 경우\nMonoRepo 활용:\n공통 라이브러리와 모듈을 중앙에서 관리하여 코드 재사용을 극대화 일관된 개발 환경과 통합된 CI/CD 파이프라인을 통해 개발 효율성 향상 MultiRepo 활용:\n각 팀이 독립된 저장소를 운영하여 개발의 유연성과 독립성 확보 프로젝트별로 맞춤형 CI/CD 파이프라인을 구성하여 특화된 개발 환경 제공 모노레포 vs. 멀티레포 선택 기준 프로젝트 특성에 따른 선택 기준:\n기준 모노레포 적합 상황 멀티레포 적합 상황 팀 규모 단일 팀 또는 밀접하게 협업하는 소수 팀 독립적으로 운영되는 다수의 팀 코드베이스 특성 긴밀히 결합된 시스템, 공통 코드 다수 느슨하게 결합된 독립적 서비스 릴리스 주기 조정된 릴리스, 전체 시스템 일관성 중요 독립적인 서비스별 릴리스 주기 기술 스택 일관된 기술 스택 선호 서비스별 맞춤형 기술 선택 필요 조직 문화 투명성과 코드 공유 중시 팀 자율성과 독립성 중시 프로젝트 성숙도 안정적이고 성숙한 시스템 빠르게 진화하는 실험적 서비스 개발자 경험 통합된 개발 환경과 도구 선호 단순하고 특화된 환경 선호 운영 기준 및 고려사항 모노레포 효과적 운영을 위한 기준:\n빌드 시스템 투자: 증분 빌드 및 테스트를 지원하는 고급 빌드 시스템 도입 빌드 캐싱 및 분산 빌드 인프라 구축 코드 구조화: 명확한 모듈 경계와 의존성 관리 정책 수립 공유 코드와 서비스별 코드의 구분 명확화 접근 제어 메커니즘: 코드 소유권 및 리뷰 정책 확립 필요한 경우 디렉토리 수준의 접근 제어 구현 확장성 계획: 저장소 크기 증가에 따른 성능 최적화 전략 수립 Git 가상 파일 시스템 (VFS) 등 대규모 저장소 관리 도구 활용 멀티레포 효과적 운영을 위한 기준:\n의존성 관리: 강력한 내부 패키지 레지스트리 구축 의존성 버전 관리 및 호환성 테스트 자동화 코드 공유 전략: 공통 라이브러리 추출 및 패키지화 프로세스 확립 내부 오픈소스 문화 및 기여 절차 수립 통합 도구: 여러 저장소 검색 및 탐색 도구 구축 프로젝트 간 일관된 CI/CD 파이프라인 템플릿 제공 조정 메커니즘: 서비스 간 의존성 변경 알림 시스템 구축 다중 저장소 작업을 위한 메타 도구 활용 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 항목 MonoRepo MultiRepo 도구 선택 Bazel, Nx, Lerna 등 Git, GitHub, GitLab 등 CI/CD 구성 통합된 파이프라인 구성 필요 프로젝트별 개별 파이프라인 구성 권한 관리 세분화된 권한 설정 어려움 프로젝트별 세부적인 권한 설정 가능 버전 관리 전체 프로젝트에 대한 일관된 버전 관리 각 프로젝트별 독립적인 버전 관리 하이브리드 (Hybrid) 접근 필요에 따라 모노레포와 멀티레포를 혼합하는 하이브리드 구조도 가능하다.\n예를 들어, 공통 라이브러리/유틸리티는 모노레포로, 각각의 마이크로서비스는 멀티레포로 관리할 수 있다.\nBazel/Nx 모노레포 도구 Bazel 특징 및 기능 Bazel 은 Google 이 개발한 오픈소스 빌드 도구로, 대규모 모노레포를 효율적으로 관리하기 위해 설계되었다:\n핵심 기능: 언어 불가지론적 빌드 시스템: 다양한 언어와 프레임워크 지원 증분 빌드: 변경된 부분과 그 의존성만 빌드 재현 가능한 빌드: 동일한 입력에 대해 항상 동일한 출력 보장 분산 캐싱: 팀 간 빌드 결과 공유로 중복 작업 방지 사용 사례: 복잡한 다중 언어 프로젝트 엄격한 확정성과 재현성이 필요한 환경 대규모 엔터프라이즈 코드베이스 장단점: 장점: 뛰어난 성능과 확장성, 견고한 의존성 관리 단점: 가파른 학습 곡선, 복잡한 설정, 생태계 제한 Nx 특징 및 기능 Nx 는 Nrwl 에서 개발한 모노레포 도구로, 특히 JavaScript/TypeScript 생태계에 최적화되어 있다:\n핵심 기능: 영향 분석: 변경 영향을 받는 프로젝트만 빌드/테스트 코드 생성기: 일관된 코드 생성 및 구조 제공 스마트 빌드 캐싱: 로컬 및 분산 캐싱 지원 시각화 도구: 프로젝트 구조 및 의존성 시각화 사용 사례: Angular, React, Vue 등 프론트엔드 중심 프로젝트 풀스택 JavaScript/TypeScript 애플리케이션 중소규모 모노레포 관리 장단점: 장점: 쉬운 설정, 풍부한 생태계, 개발자 경험 중시 단점: JavaScript 생태계 중심, 대규모 모노레포에서 한계 도구 비교 특성 Bazel Nx Turborepo Rush 개발사 Google Nrwl Vercel Microsoft 주요 대상 다중 언어 대규모 코드베이스 JavaScript/TypeScript 모노레포 JavaScript/TypeScript 모노레포 TypeScript/JavaScript 모노레포 의존성 분석 명시적 선언 기반 정적 분석 기반 파일 경로 분석 패키지 매니페스트 기반 캐싱 전략 입력 해시 기반 분산 캐싱 로컬 및 분산 캐싱 클라우드 캐싱 로컬 캐싱 확장성 매우 높음 (Google 규모 지원) 중간 중간 높음 학습 곡선 가파름 완만함 매우 완만함 중간 맞춤 설정 매우 높음 중간 제한적 높음 생태계 통합 제한적 JavaScript 생태계와 긴밀 JavaScript 생태계와 긴밀 Microsoft 도구와 긴밀 Polyrepo 권한 관리 전략 멀티레포 (폴리레포) 환경에서의 효과적인 권한 관리 전략:\n계층적 접근 제어: 팀 기반 권한 모델: 팀 단위로 저장소 접근 권한 관리 역할 기반 접근 제어 (RBAC): 개발자, 리뷰어, 관리자 등 역할별 권한 할당 저장소별 세밀한 권한 설정: 읽기, 쓰기, 관리 권한 분리 중앙화된 ID 관리: 단일 ID 제공자 (IdP) 연동: SAML, OAuth 등을 통한 중앙 인증 자동화된 사용자 프로비저닝: HR 시스템과 연동한 자동 계정 관리 다중 인증 (MFA) 적용: 중요 저장소에 대한 추가 보안 계층 코드 소유권 관리: CODEOWNERS 파일 활용: 각 코드 영역별 책임자 명시 필수 리뷰어 설정: 특정 영역 변경 시 전문가 리뷰 필수화 자동화된 리뷰 할당: 코드 소유권에 기반한 자동 리뷰어 지정 효율적인 다중 저장소 관리: 저장소 템플릿 활용: 일관된 구조와 기본 권한 설정 적용 권한 변경 감사: 모든 접근 권한 변경 기록 및 검토 API 기반 권한 관리: 스크립트 및 자동화를 통한 대량 권한 관리 안전한 CI/CD 파이프라인: 파이프라인 별 최소 권한 원칙: 필요한 접근 권한만 부여 시크릿 및 자격 증명 안전한 관리: 중앙화된 시크릿 저장소 활용 빌드 환경 분리: 개발 환경과 빌드/배포 환경의 권한 분리 멀티레포 권한 관리 도구 및 플랫폼:\n도구/플랫폼 주요 기능 특징 GitHub Organizations 팀 기반 접근 관리, 저장소 템플릿, CODEOWNERS 팀 구조를 반영한 직관적 권한 관리 GitLab Groups 계층적 그룹 구조, 상속 가능한 권한, CI/CD 권한 복잡한 조직 구조에 적합한 계층적 모델 Bitbucket Workspaces 프로젝트별 접근 제어, JIRA 통합, IP 기반 제한 Atlassian 제품군과의 긴밀한 통합 Azure DevOps 상세한 권한 매트릭스, Active Directory 통합 엔터프라이즈 환경에 최적화된 권한 모델 Terraform 코드형 권한 관리, 일관된 권한 배포, 변경 이력 추적 인프라와 함께 권한을 코드로 관리 OPA (Open Policy Agent) 정책 기반 접근 제어, 다양한 시스템 통합 복잡한 권한 로직을 정책으로 구현 최신 동향 주제 항목 설명 모노레포 도구 클라우드 네이티브 빌드 도구 Bazel, Nx, Turborepo 등이 클라우드 네이티브 환경에 최적화된 기능을 강화하고 있으며, 분산 빌드와 원격 캐싱 기능이 표준화되고 있습니다 멀티레포 통합 AI 기반 코드 탐색 GitHub Copilot 와 같은 AI 도구가 멀티레포 환경에서 코드 검색과 탐색을 지원하여 여러 저장소에 걸친 코드 이해를 돕고 있습니다 하이브리드 접근법 Git Submodules 대안 Git Submodules 의 한계를 보완하는 새로운 도구들이 등장하여 모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법이 확산되고 있습니다 빌드 최적화 분산 컴퓨팅 활용 클라우드 기반 분산 빌드 시스템이 보편화되어 대규모 모노레포의 빌드 성능이 크게 향상되고 있습니다 DevOps 통합 통합 관측성 모노레포와 멀티레포 모두에서 코드 변경부터 프로덕션 영향까지 추적할 수 있는 통합 관측성 도구가 발전하고 있습니다 성능 개선 스파스 체크아웃 Git 의 스파스 체크아웃 기능이 개선되어 대규모 모노레포의 일부만 효율적으로 클론하고 작업할 수 있게 되었습니다 보안 강화 공급망 보안 저장소 구조와 관계없이 코드 공급망 보안을 강화하는 도구와 프랙티스가 중요해지고 있습니다 협업 개선 코드 공유 문화 멀티레포 환경에서도 내부 패키지 생태계와 문서화를 강화하여 코드 공유 문화를 촉진하는 추세가 강화되고 있습니다 인프라 관리 GitOps 적용 모노레포와 멀티레포 모두에서 GitOps 방식의 인프라 관리가 표준화되어 코드와 인프라의 일관성을 유지하는 추세입니다 개발자 경험 통합 개발 환경 VS Code 와 같은 IDE 가 여러 저장소에 걸친 작업을 더 잘 지원하도록 발전하여 멀티레포 환경에서의 개발자 경험이 개선되고 있습니다 주목해야 할 기술 주제 항목 설명 빌드 도구 Turborepo JavaScript/TypeScript 모노레포를 위한 고성능 빌드 시스템으로, 단순한 설정과 강력한 캐싱 기능으로 빠르게 채택되고 있습니다 패키지 관리 pnpm 효율적인 디스크 공간 활용과 빠른 설치 속도로 모노레포 환경에서 특히 유용한 패키지 관리자입니다 코드 조직 Module Federation 웹팩의 Module Federation 기능을 활용해 멀티레포 환경에서도 런타임 코드 공유를 가능하게 하는 기술입니다 개발 환경 Remote Containers VS Code 의 Remote Containers 와 같은 기술로 저장소 구조와 관계없이 일관된 개발 환경을 제공합니다 자동화 도구 GitHub Actions Matrix 여러 저장소에 걸친 CI/CD 작업을 효율적으로 관리할 수 있는 기능입니다 의존성 관리 Renovate Bot 멀티레포 환경에서도 일관된 의존성 업데이트를 자동화할 수 있는 도구입니다 모노레포 관리 Nx Cloud Nx 기반 모노레포의 분산 캐싱과 CI 최적화를 제공하는 클라우드 서비스입니다 코드 공유 Bit 컴포넌트 단위로 코드를 공유하고 협업할 수 있는 플랫폼으로, 모노레포와 멀티레포 간의 간극을 줄여줍니다 저장소 관리 Meta 여러 Git 저장소를 동시에 관리할 수 있는 메타 도구로, 멀티레포 환경에서의 작업을 단순화합니다 버전 관리 Changesets 모노레포 환경에서 패키지별 버전 관리와 변경 로그 생성을 자동화하는 도구입니다 앞으로의 전망 주제 항목 설명 접근 방식 융합 하이브리드 모델 성장 모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법이 더욱 보편화될 전망입니다 도구 생태계 범용 도구 발전 저장소 구조와 관계없이 효율적인 개발을 지원하는 범용 도구가 발전하여 저장소 구조 선택의 중요성이 감소할 것입니다 클라우드 통합 서버리스 빌드 시스템 완전 관리형 서버리스 빌드 시스템이 보편화되어 인프라 관리 부담 없이 대규모 코드베이스를 처리할 수 있게 될 것입니다 개발자 경험 코드 내비게이션 혁신 AI 기반 코드 탐색 및 이해 도구가 발전하여 대규모 코드베이스나 다중 저장소 환경에서의 개발자 생산성이 크게 향상될 것입니다 조직 변화 DevEx 팀 부상 저장소 구조와 관계없이 개발자 경험을 최적화하는 전담 DevEx 팀의 중요성이 더욱 커질 것입니다 배포 접근법 지속적 배포 표준화 모노레포와 멀티레포 모두에서 완전 자동화된 지속적 배포가 표준이 되어 릴리스 프로세스의 차이가 줄어들 것입니다 확장성 개선 분산 버전 관리 발전 Git 이후의 차세대 분산 버전 관리 시스템이 등장하여 초대형 코드베이스 관리의 제약이 줄어들 것입니다 자동화 증가 지능형 의존성 관리 AI 기반 의존성 분석 및 업데이트 시스템이 발전하여 복잡한 의존성 그래프 관리가 간소화될 것입니다 보안 강화 저장소 통합 보안 저장소 구조와 관계없이 일관된 보안 정책을 적용하고 모니터링하는 통합 도구가 표준화될 것입니다 코드베이스 이해 AI 코드 분석 대규모 코드베이스 이해를 돕는 AI 기반 코드 분석 및 문서화 도구가 개발되어 온보딩 및 지식 공유가 개선될 것입니다 패러다임 변화 서비스 추상화 저장소 구조보다 서비스 인터페이스와 계약에 초점을 맞춘 개발 패러다임이 강화될 것입니다 추가 학습 내용 카테고리 주제 설명 빌드 도구 Bazel 고급 구성 대규모 모노레포를 위한 Bazel 빌드 시스템의 고급 기능과 최적화 기법 Turborepo 파이프라인 JavaScript/TypeScript 모노레포를 위한 Turborepo 파이프라인 구성 및 최적화 Nx 워크스페이스 설계 Nx 를 활용한 효율적인 모노레포 워크스페이스 구조화 전략 버전 관리 모노레포 버전 관리 전략 Lerna, Changesets 등을 활용한 모노레포 내 패키지 버전 관리 방법 멀티레포 배포 조정 여러 저장소에 걸친 의존성 있는 서비스의 효과적인 배포 조정 방법 Git 서브모듈과 대안 Git 서브모듈의 활용과 한계, 그리고 더 나은 대안들 성능 최적화 대규모 저장소 Git 최적화 대규모 Git 저장소의 성능을 유지하기 위한 최적화 기법 모노레포 증분 빌드 변경된 코드만 선택적으로 빌드하는 증분 빌드 전략 분산 캐싱 솔루션 팀 간 빌드 결과를 공유하는 분산 캐싱 시스템 구축 협업 전략 모노레포 브랜칭 전략 모노레포 환경에 최적화된 Git 브랜칭 및 워크플로우 전략 멀티레포 코드 공유 멀티레포 환경에서 효과적인 코드 공유와 재사용 방법 코드 소유권 관리 대규모 저장소에서의 코드 소유권과 책임 관리 체계 도구 통합 CI/CD 파이프라인 설계 모노레포와 멀티레포에 최적화된 CI/CD 파이프라인 구성 코드 품질 도구 통합 일관된 코드 품질을 유지하기 위한 린트, 테스트 도구 통합 모니터링 및 관측성 저장소 구조와 관계없이 효과적인 모니터링 체계 구축 마이그레이션 모노레포 전환 전략 멀티레포에서 모노레포로 안전하게 전환하는 단계별 전략 멀티레포 분할 전략 대규모 모노레포를 효과적으로 분할하는 접근법 하이브리드 저장소 구조 모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법 용어 정리 용어 설명 모노레포 (MonoRepo) 여러 프로젝트와 관련 코드를 단일 버전 관리 저장소에서 관리하는 방식 멀티레포 (MultiRepo) 각 프로젝트나 서비스마다 독립된 버전 관리 저장소를 사용하는 방식 폴리레포 (PolyRepo) 멀티레포와 동일한 개념으로, 여러 저장소를 사용하는 접근법 증분 빌드 (Incremental Build) 변경된 부분과 그 의존성만 선택적으로 빌드하는 최적화 기법 원자적 변경 (Atomic Changes) 여러 프로젝트에 걸친 변경사항을 단일 커밋으로 처리하는 방식 의존성 그래프 (Dependency Graph) 프로젝트 간 의존 관계를 나타내는 방향성 그래프 구조 워크스페이스 (Workspace) 여러 패키지나 프로젝트를 포함하는 개발 환경 단위 Bazel Google 이 개발한 대규모 모노레포를 위한 언어 불가지론적 빌드 시스템 Nx JavaScript/TypeScript 생태계에 최적화된 모노레포 개발 플랫폼 Turborepo Vercel 에서 개발한 JavaScript/TypeScript 모노레포를 위한 고성능 빌드 시스템 pnpm 디스크 공간을 효율적으로 사용하는 Node.js 패키지 관리자로, 모노레포 지원이 강화됨 Lerna JavaScript 모노레포 관리를 위한 도구로, 멀티 패키지 저장소 관리를 단순화 Changesets 모노레포 환경에서 버전 관리와 변경 로그 생성을 자동화하는 도구 Git 서브모듈 (Git Submodules) 한 Git 저장소 안에 다른 Git 저장소를 포함시키는 메커니즘 모듈 연합 (Module Federation) 여러 독립적 빌드 간에 런타임 코드 공유를 가능하게 하는 웹팩 기능 참고 및 출처 Google 개발자 블로그 - Monorepo 관리 전략 Meta Engineering 블로그 - 대규모 코드베이스 운영 방식 Microsoft Engineering - One Engineering System Netflix 기술 블로그 - Microservices at Netflix Bazel 공식 사이트 Nx 공식 사이트 Lerna 공식 문서 GitHub Docs - Managing monorepos Atlassian 블로그 - Monorepo vs. Multi-repo NX Monorepo 소개 Turborepo 공식 문서 Google의 단일 저장소 분석 Microsoft의 대규모 Git 저장소 관리 Spotify의 저장소 전략 사례 연구 Bazel 빌드 시스템 문서 pnpm 워크스페이스 가이드 Meta/Facebook의 Buck 빌드 시스템 Yarn 워크스페이스 문서 Lerna 모노레포 관리 도구 GitHub의 저장소 최적화 가이드 Atlassian의 모노레포 vs 멀티레포 가이드 ","wordCount":"3737","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T06:18:00Z","dateModified":"2024-09-30T06:18:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">MonoRepo vs. MultiRepo</h1><div class=post-description>모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다.</div><div class=post-meta><span title='2024-09-30 06:18:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;<span>18 min</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Development%20&%20Engineering/Development%20Practices/Version%20Control/Advanced%20Topics/Enterprise%20Usage/monorepo-vs-multirepo.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#monorepo-vs-multirepo>MonoRepo vs. MultiRepo</a><ul><li><a href=#정의-및-기능>정의 및 기능</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#목적-및-필요성-비교>목적 및 필요성 비교</a></li><li><a href=#개발-워크플로우-비교>개발 워크플로우 비교</a></li><li><a href=#팀-구조-적합성-비교>팀 구조 적합성 비교</a></li><li><a href=#주요-원리>주요 원리</a></li><li><a href=#monorepo-vs-multirepo-아키텍처-다이어그램>MonoRepo vs. MultiRepo 아키텍처 다이어그램</a></li><li><a href=#장단점-비교>장단점 비교</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#적합한-상황>적합한 상황</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#주목해야-할-기술>주목해야 할 기술</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#추가-학습-내용>추가 학습 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=monorepo-vs-multirepo>MonoRepo vs. MultiRepo<a hidden class=anchor aria-hidden=true href=#monorepo-vs-multirepo>#</a></h2><p>모노레포 (Monorepo) 와 멀티레포 (Multirepo) 는 소프트웨어 개발에서 코드베이스를 관리하는 대표적인 두 가지 전략이다. <strong>MonoRepo</strong>는 여러 프로젝트를 하나의 저장소에서 관리하는 방식으로, 코드 공유와 일관된 개발 환경을 제공한다. 반면, <strong>MultiRepo</strong>는 각 프로젝트를 별도의 저장소에서 관리하여 독립성과 유연성을 강조한다.</p><p>이 두 접근 방식은 코드 공유, 종속성 관리, 빌드 시스템, 팀 협업, 확장성 등의 측면에서 서로 다른 장단점을 가지고 있다. 프로젝트의 규모, 팀 구조, 회사 문화, 기술 스택 등 다양한 요소에 따라 적합한 방식이 달라질 수 있으며, 최근에는 두 방식의 장점을 결합한 하이브리드 접근법이나 각 방식의 단점을 보완하는 도구들도 등장하고 있다.</p><p><a href=https://coderpad.io/blog/development/monorepos-with-juri-strumpflohner-of-nrwl/><img alt="Dev Discussions: Everything You Need to Know about Monorepos with Juri &mldr;" loading=lazy src="https://tse4.mm.bing.net/th?id=OIP.Mot9JMwVAROuPWcFc357hwHaIn&cb=iwc1&pid=Api"></a></p><h3 id=정의-및-기능>정의 및 기능<a hidden class=anchor aria-hidden=true href=#정의-및-기능>#</a></h3><table><thead><tr><th>구분</th><th>모노레포 (Monorepo)</th><th>멀티레포 (Multirepo)</th></tr></thead><tbody><tr><td>정의</td><td>여러 프로젝트 (서비스, 라이브러리 등) 가 하나의 저장소 (리포지토리) 에서 관리되는 방식</td><td>각 프로젝트 (서비스, 라이브러리 등) 가 독립적인 저장소 (리포지토리) 에서 관리되는 방식</td></tr><tr><td><strong>목적</strong></td><td>코드 공유, 일관된 개발 환경, 중앙 집중식 관리</td><td>프로젝트 간 독립성, 유연한 관리, 보안 강화</td></tr><tr><td>개발 환경에서의 역할</td><td>통합된 개발 환경 제공</td><td>독립적인 개발 환경 제공</td></tr><tr><td>협업에서의 역할</td><td>팀 간 협업 및 코드 공유 촉진</td><td>팀 자율성 보장 및 독립적 의사결정 지원</td></tr><tr><td>아키텍처에서의 역할</td><td>일관된 아키텍처 적용</td><td>서비스별 최적 아키텍처 선택</td></tr><tr><td>배포에서의 역할</td><td>조정된 배포 및 통합 테스트</td><td>독립적 배포 및 테스트</td></tr><tr><td><strong>코드 공유</strong></td><td>공통 라이브러리 및 모듈의 재사용 용이</td><td>공통 코드의 공유가 어려워 중복 가능성 존재<br>패키지 관리자를 통한 코드 공유</td></tr><tr><td>의존성 관리</td><td>내부 의존성 자동 추적</td><td>외부 패키지로 의존성 관리</td></tr><tr><td>리팩토링</td><td>전체 코드베이스에 대한 원자적 변경 용이</td><td>저장소별 독립적 리팩토링 (의존성 영향 관리 필요)</td></tr><tr><td><strong>버전 관리</strong></td><td>전체 프로젝트에 대한 일관된 버전 관리</td><td>각 프로젝트별 독립적인 버전 관리</td></tr><tr><td>CI/CD</td><td>통합 파이프라인 및 변경 영향 분석 기반 빌드</td><td>저장소별 독립적 파이프라인</td></tr><tr><td><strong>권한 관리</strong></td><td>세분화된 권한 관리 어려움</td><td>프로젝트별 세부적인 권한 설정 가능</td></tr><tr><td>코드 조직</td><td>프로젝트별 디렉토리 구조 또는 패키지 기반 구조</td><td>각 저장소는 자체적인 디렉토리 구조를 가짐</td></tr><tr><td>예시</td><td>프론트엔드, 백엔드, 공통 라이브러리 등이 한 저장소에 모여 있음</td><td>각 서비스별, 라이브러리별로 별도의 저장소를 사용함</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><table><thead><tr><th>항목</th><th>MonoRepo</th><th>MultiRepo</th></tr></thead><tbody><tr><td>가시성</td><td>모든 코드가 투명하게 공개됨</td><td>팀별로 코드 접근 제한 가능</td></tr><tr><td>일관성</td><td>코드 스타일, 도구, 프로세스의 통일성</td><td>팀별 맞춤형 도구 및 프로세스</td></tr><tr><td>빌드 시스템</td><td>대규모 빌드 시스템 필요 (Bazel, Buck 등)</td><td>간단한 빌드 시스템으로 충분</td></tr><tr><td>변경 영향</td><td>변경 영향을 즉시 확인 가능</td><td>의존성 관계에 따라 영향 파악 어려움</td></tr><tr><td>저장소 크기</td><td>매우 큰 단일 저장소</td><td>여러 개의 작은 저장소</td></tr></tbody></table><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><table><thead><tr><th>항목</th><th>MonoRepo</th><th>MultiRepo</th></tr></thead><tbody><tr><td>코드 공유 원칙</td><td>내부 직접 참조를 통한 코드 재사용</td><td>패키지 및 라이브러리를 통한 코드 공유</td></tr><tr><td>버전 관리 원칙</td><td>단일 버전 (항상 최신)</td><td>독립적 버전 관리</td></tr><tr><td>리뷰 프로세스</td><td>광범위한 코드 리뷰 및 표준 적용</td><td>팀별 맞춤형 리뷰 프로세스</td></tr><tr><td>테스트 전략</td><td>통합 테스트 우선</td><td>개별 서비스 테스트 우선</td></tr><tr><td>성능 관리</td><td>빌드 최적화 도구 및 캐싱 필수</td><td>기본 빌드 도구로 충분</td></tr></tbody></table><h3 id=목적-및-필요성-비교>목적 및 필요성 비교<a hidden class=anchor aria-hidden=true href=#목적-및-필요성-비교>#</a></h3><table><thead><tr><th></th><th>항목</th><th>MonoRepo</th><th>MultiRepo</th></tr></thead><tbody><tr><td>목적</td><td>주요 목적</td><td>코드 재사용 및 통합 개발 환경 제공</td><td>독립적인 개발 및 배포 환경 제공</td></tr><tr><td></td><td>협업 목표</td><td>전사적 코드 표준화 및 일관성 유지</td><td>팀 자율성 및 독립적 개발 속도 보장</td></tr><tr><td></td><td>의존성 관리</td><td>내부 의존성 자동 해결 및 통합 관리</td><td>명시적 의존성 관리 및 버전 제어</td></tr><tr><td></td><td>빌드 최적화</td><td>전체 시스템의 일관된 빌드 및 통합 테스트</td><td>개별 시스템의 독립적 빌드 및 테스트</td></tr><tr><td>필요성</td><td>기술적 필요성</td><td>상호 의존적인 여러 프로젝트의 통합 관리</td><td>독립적 서비스의 분리된 관리</td></tr><tr><td></td><td>조직적 필요성</td><td>대규모 팀의 코드 공유 및 표준화</td><td>자율적 팀별 개발 속도와 결정권 부여</td></tr><tr><td></td><td>확장 관점</td><td>공통 코드베이스를 통한 일관된 확장</td><td>독립적 확장 및 기술 스택 다양화</td></tr><tr><td></td><td>배포 관점</td><td>통합 배포 전략 및 조정된 출시</td><td>개별 서비스 독립적 배포 주기</td></tr></tbody></table><h3 id=개발-워크플로우-비교>개발 워크플로우 비교<a hidden class=anchor aria-hidden=true href=#개발-워크플로우-비교>#</a></h3><table><thead><tr><th>개발 활동</th><th>모노레포 워크플로우</th><th>멀티레포 워크플로우</th></tr></thead><tbody><tr><td>새 기능 개발</td><td>단일 저장소에서 브랜치 생성, 필요한 모든 프로젝트 변경</td><td>관련 저장소 각각에서 브랜치 생성, 저장소별 변경</td></tr><tr><td>코드 리뷰</td><td>모든 변경에 대한 통합 리뷰, 영향 범위 명확</td><td>저장소별 독립적 리뷰, 크로스 리뷰 필요할 수 있음</td></tr><tr><td>테스트</td><td>변경 영향에 따른 통합 테스트 자동 실행</td><td>저장소별 독립 테스트, 통합 테스트는 별도 단계</td></tr><tr><td>버그 수정</td><td>모든 영향 코드에 원자적 수정 적용</td><td>저장소별 개별 수정, 릴리스 조정 필요</td></tr><tr><td>릴리스</td><td>조정된 릴리스 계획, 다중 프로젝트 동시 릴리스</td><td>독립적 릴리스 주기, 의존성 버전 관리 필요</td></tr><tr><td>롤백</td><td>관련된 모든 변경 동시 롤백</td><td>의존 관계에 따른 순차적 롤백 전략 필요</td></tr><tr><td>의존성 업데이트</td><td>내부 의존성 즉시 반영, 원자적 업데이트</td><td>의존성 패키지 릴리스 후 소비 저장소 업데이트</td></tr><tr><td>온보딩</td><td>초기 설정 복잡하지만 전체 시스템 이해 용이</td><td>초기 설정 간단하지만 전체 시스템 이해에 시간 소요</td></tr></tbody></table><h3 id=팀-구조-적합성-비교>팀 구조 적합성 비교<a hidden class=anchor aria-hidden=true href=#팀-구조-적합성-비교>#</a></h3><table><thead><tr><th>팀 구조</th><th>모노레포 적합성</th><th>멀티레포 적합성</th><th>권장 접근법</th></tr></thead><tbody><tr><td>단일 제품 소규모 팀</td><td>매우 높음</td><td>보통</td><td>간단한 모노레포 설정</td></tr><tr><td>다중 제품 대규모 팀</td><td>보통 (도구 투자 필요)</td><td>높음</td><td>제품별 멀티레포 또는 고급 모노레포</td></tr><tr><td>마이크로서비스 아키텍처</td><td>보통</td><td>높음</td><td>서비스별 멀티레포 또는 모듈식 모노레포</td></tr><tr><td>지리적으로 분산된 팀</td><td>낮음 (지연 시간 이슈)</td><td>높음</td><td>지역별 멀티레포 또는 하이브리드 접근법</td></tr><tr><td>독립적 비즈니스 유닛</td><td>낮음</td><td>매우 높음</td><td>유닛별 멀티레포</td></tr><tr><td>오픈소스 프로젝트</td><td>상황에 따라 다름</td><td>높음</td><td>핵심 - 플러그인 모델 또는 멀티레포</td></tr><tr><td>플랫폼 및 앱 구조</td><td>높음</td><td>보통</td><td>플랫폼 모노레포 + 앱 멀티레포</td></tr><tr><td>스타트업 빠른 실험</td><td>초기: 높음, 성장 후: 평가 필요</td><td>확장 단계에서 높음</td><td>성장에 따른 진화 전략</td></tr></tbody></table><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><h4 id=monorepo-주요-원리>MonoRepo 주요 원리<a hidden class=anchor aria-hidden=true href=#monorepo-주요-원리>#</a></h4><p>MonoRepo 의 핵심 원리는 " 단일 진실 소스 (Single Source of Truth)" 와 " 통합 개발 환경 (Unified Development Environment)" 이다.</p><p>이는 다음과 같은 원리로 구현된다:</p><ol><li><strong>원자적 변경 (Atomic Changes)</strong>:<ul><li>여러 프로젝트에 걸친 변경사항을 단일 커밋으로 처리</li><li>모든 의존 프로젝트가 항상 동기화된 상태 유지</li></ul></li><li><strong>단일 버전 (Single Version)</strong>:<ul><li>모든 내부 의존성이 항상 최신 버전 사용</li><li>버전 불일치 문제 원천 차단</li></ul></li><li><strong>투명한 의존성 (Transparent Dependencies)</strong>:<ul><li>모든 프로젝트 간 의존성이 명확하게 가시화됨</li><li>의존성 그래프가 자동으로 빌드 시스템에 의해 관리</li></ul></li><li><strong>전역 리팩토링 (Global Refactoring)</strong>:<ul><li>전체 코드베이스에 걸친 변경을 안전하게 적용 가능</li><li>모든 의존 프로젝트에 대한 영향 즉시 확인</li></ul></li><li><strong>공유 리소스 (Shared Resources)</strong>:<ul><li>공통 코드, 설정, 도구를 모든 프로젝트가 공유</li><li>중복 없이 표준화된 개발 환경 제공</li></ul></li></ol><h4 id=multirepo-주요-원리>MultiRepo 주요 원리<a hidden class=anchor aria-hidden=true href=#multirepo-주요-원리>#</a></h4><p>MultiRepo 의 핵심 원리는 " 분리된 관심사 (Separation of Concerns)" 와 " 독립적 진화 (Independent Evolution)" 이다.</p><p>이는 다음과 같은 원리로 구현된다:</p><ol><li><strong>독립적 버전 관리 (Independent Versioning)</strong>:<ul><li>각 프로젝트가 자체 버전 관리 체계를 가짐</li><li>SemVer 등을 통한 명확한 버전 의존성 표현</li></ul></li><li><strong>느슨한 결합 (Loose Coupling)</strong>:<ul><li>프로젝트 간 의존성을 명시적 인터페이스로 제한</li><li>API 계약을 통한 상호작용</li></ul></li><li><strong>자율성 (Autonomy)</strong>:<ul><li>팀이 독립적인 기술 스택 및 도구 선택 가능</li><li>개별 프로젝트의 특성에 맞는 최적화 가능</li></ul></li><li><strong>분산 책임 (Distributed Responsibility)</strong>:<ul><li>각 팀이 자신의 코드에 대한 온전한 책임 부여</li><li>독립적인 품질 관리 및 배포 결정권</li></ul></li><li><strong>선택적 공유 (Selective Sharing)</strong>:<ul><li>재사용이 필요한 코드만 패키지로 추출하여 공유</li><li>명시적 의존성 선언을 통한 투명한 사용</li></ul></li></ol><h3 id=monorepo-vs-multirepo-아키텍처-다이어그램>MonoRepo vs. MultiRepo 아키텍처 다이어그램<a hidden class=anchor aria-hidden=true href=#monorepo-vs-multirepo-아키텍처-다이어그램>#</a></h3><h4 id=monorepo-구성-예시>MonoRepo 구성 예시<a hidden class=anchor aria-hidden=true href=#monorepo-구성-예시>#</a></h4><ul><li><p><strong>구성 요소</strong>:</p><ul><li>공통 라이브러리</li><li>여러 애플리케이션</li><li>통합된 CI/CD 파이프라인</li><li>중앙 집중식 버전 관리</li></ul></li><li><p><strong>특징</strong>:</p><ul><li>코드 공유와 재사용이 용이</li><li>일관된 개발 환경 유지</li><li>대규모 프로젝트 관리에 적합</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>/monorepo
</span></span><span class=line><span class=cl>├── apps
</span></span><span class=line><span class=cl>│   ├── service-a
</span></span><span class=line><span class=cl>│   └── service-b
</span></span><span class=line><span class=cl>├── libs
</span></span><span class=line><span class=cl>│   ├── shared-ui
</span></span><span class=line><span class=cl>│   └── auth-utils
</span></span><span class=line><span class=cl>├── tools
</span></span><span class=line><span class=cl>│   └── custom-scripts
</span></span><span class=line><span class=cl>├── .gitignore
</span></span><span class=line><span class=cl>├── nx.json
</span></span><span class=line><span class=cl>├── workspace.json
</span></span><span class=line><span class=cl>└── package.json
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>apps/</strong>: 각 서비스 애플리케이션</li><li><strong>libs/</strong>: 공통 라이브러리 (재사용 가능)</li><li><strong>tools/</strong>: 프로젝트 전체에 쓰이는 도구 모음</li></ul><h4 id=multirepo-구성-예시>MultiRepo 구성 예시<a hidden class=anchor aria-hidden=true href=#multirepo-구성-예시>#</a></h4><ul><li><p><strong>구성 요소</strong>:</p><ul><li>프로젝트별 독립된 저장소</li><li>개별 CI/CD 파이프라인</li><li>독립적인 버전 관리</li></ul></li><li><p><strong>특징</strong>:</p><ul><li>프로젝트 간 독립성 확보</li><li>유연한 관리와 보안 강화</li><li>작은 규모의 팀이나 프로젝트에 적합</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>/ ── service-a-repo
</span></span><span class=line><span class=cl>     ├── src/
</span></span><span class=line><span class=cl>     └── package.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/ ── service-b-repo
</span></span><span class=line><span class=cl>     ├── src/
</span></span><span class=line><span class=cl>     └── package.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/ ── shared-ui-repo
</span></span><span class=line><span class=cl>     ├── components/
</span></span><span class=line><span class=cl>     └── package.json
</span></span></code></pre></td></tr></table></div></div><ul><li>저장소 분리로 인해 각 repo 별 CI/CD, 권한 설정이 별도 운영됨</li><li>의존성/버전 통합은 별도 자동화 필요</li></ul><h3 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h3><h4 id=모노레포-monorepo>모노레포 (Monorepo)<a hidden class=anchor aria-hidden=true href=#모노레포-monorepo>#</a></h4><table><thead><tr><th>항목</th><th>모노레포 (Monorepo) 장점</th><th>모노레포 (Monorepo) 단점</th></tr></thead><tbody><tr><td>코드 공유</td><td>여러 프로젝트 간 코드 공유와 재사용이 매우 용이함</td><td>무분별한 의존성 증가로 코드 복잡성이 커질 수 있음</td></tr><tr><td>의존성 관리</td><td>의존성 관리가 간단하며, 버전 충돌 위험이 적음</td><td>의존성 연결이 쉬워 과도한 의존 관계가 발생할 수 있음</td></tr><tr><td>통합 버전 관리</td><td>모든 프로젝트가 동일한 버전으로 관리되어 무결성 유지가 쉬움</td><td>단일 저장소의 크기가 커지면 빌드, CI 속도가 느려질 수 있음</td></tr><tr><td>아토믹 커밋</td><td>여러 프로젝트에 걸친 변경을 한 번에 (atomic 하게) 반영 가능</td><td>단일 저장소에서 다수의 개발자가 동시에 작업 시 충돌 가능성이 높아짐</td></tr><tr><td>협업</td><td>팀 간 협업이 용이, 전체 코드에 대한 가시성이 높음</td><td>접근 제어가 어렵고, 모든 개발자가 모든 코드에 접근하게 됨</td></tr></tbody></table><h4 id=멀티레포-multirepo>멀티레포 (Multirepo)<a hidden class=anchor aria-hidden=true href=#멀티레포-multirepo>#</a></h4><table><thead><tr><th>항목</th><th>멀티레포 (Multirepo) 장점</th><th>멀티레포 (Multirepo) 단점</th></tr></thead><tbody><tr><td>독립성</td><td>각 프로젝트가 독립적으로 개발/배포/버전 관리 가능</td><td>코드 재사용성이 떨어지고, 중복 코드가 증가할 수 있음</td></tr><tr><td>오너십</td><td>각 저장소 별로 오너십 명확, 접근 제어가 용이함</td><td>여러 저장소에 걸친 코드 리뷰 및 관리 포인트 증가</td></tr><tr><td>빠른 빌드/CI 속도</td><td>저장소 크기가 작아 빌드 및 CI 속도가 빠름</td><td>의존성 관리가 복잡해지고, 디펜던시 헬 (Dependency Hell) 발생 가능</td></tr><tr><td>자율성</td><td>팀이 자율적으로 기술 스택, 릴리즈 주기 선택 가능</td><td>공통 코드 변경 시 여러 저장소에 반영해야 해 번거로움</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>조직</th><th>접근 방식</th><th>적용 사례</th></tr></thead><tbody><tr><td><strong>Google</strong></td><td>MonoRepo</td><td>모든 코드를 하나의 저장소에서 관리하며, 자체 개발한 Piper 와 Bazel 을 사용하여 대규모 프로젝트를 효율적으로 운영</td></tr><tr><td><strong>Meta (Facebook)</strong></td><td>MonoRepo</td><td>Mercurial 을 기반으로 한 대규모 MonoRepo 를 운영하며, 자체 개발한 도구로 성능을 최적화</td></tr><tr><td><strong>Microsoft</strong></td><td>MonoRepo</td><td>Windows 개발을 위한 MonoRepo 를 운영하며, Git 과 GVFS 를 활용하여 대규모 코드베이스를 관리</td></tr><tr><td><strong>Netflix</strong></td><td>MultiRepo</td><td>서비스별로 독립된 저장소를 운영하여, 각 팀의 독립성과 유연성을 확보</td></tr></tbody></table><h4 id=google-meta-사례-기반-구조-선택-전략>Google, Meta 사례 기반 구조 선택 전략<a hidden class=anchor aria-hidden=true href=#google-meta-사례-기반-구조-선택-전략>#</a></h4><h5 id=google-의-모노레포-전략>Google 의 모노레포 전략<a hidden class=anchor aria-hidden=true href=#google-의-모노레포-전략>#</a></h5><p>Google 은 세계에서 가장 큰 모노레포 중 하나를 운영하고 있으며, 다음과 같은 전략적 선택을 기반으로 한다:</p><ol><li><strong>코드 가시성과 재사용</strong>:<ul><li>Google 은 모든 코드가 회사 내에서 투명하게 공유되어야 한다는 문화적 가치를 중요시한다.</li><li>내부 라이브러리의 광범위한 재사용을 통해 개발 효율성을 높인다.</li></ul></li><li><strong>통합 도구 체인</strong>:<ul><li>Bazel 빌드 시스템을 개발하여 대규모 코드베이스의 빌드 시간을 최적화했다.</li><li>코드 검색, 코드 리뷰, 테스트 도구 등이 모두 통합된 환경을 제공한다.</li></ul></li><li><strong>표준화된 개발 환경</strong>:<ul><li>모든 개발자가 동일한 도구와 프로세스를 사용하도록 표준화하여 생산성을 향상시킨다.</li><li>새로운 직원이 빠르게 적응할 수 있는 일관된 환경을 제공한다.</li></ul></li><li><strong>증분 테스트 및 빌드</strong>:<ul><li>변경된 코드와 그 영향을 받는 부분만 선택적으로 테스트하고 빌드하는 시스템을 구축했다.</li><li>자동화된 테스트와 의존성 분석을 통해 품질을 유지한다.</li></ul></li></ol><h5 id=metafacebook-의-모노레포-전략>Meta(Facebook) 의 모노레포 전략<a hidden class=anchor aria-hidden=true href=#metafacebook-의-모노레포-전략>#</a></h5><p>Meta 는 Buck 빌드 시스템을 중심으로 대규모 모노레포를 구축했다:</p><ol><li><strong>관련 코드 그룹화</strong>:<ul><li>관련된 서비스와 프로젝트를 논리적으로 그룹화하여 코드 구조를 관리한다.</li><li>공통 인프라와 라이브러리를 공유하여 일관성을 유지한다.</li></ul></li><li><strong>지속적 통합과 검증</strong>:<ul><li>모든 커밋이 전체 코드베이스의 안정성에 미치는 영향을 즉시 확인한다.</li><li>지속적인 테스트와 검증으로 품질 저하를 방지한다.</li></ul></li><li><strong>팀 경계 유연화</strong>:<ul><li>팀 간 경계를 유연하게 하여 협업과 지식 공유를 촉진한다.</li><li>개발자가 다양한 영역의 코드에 기여할 수 있는 문화를 조성한다.</li></ul></li><li><strong>확장 가능한 인프라</strong>:<ul><li>분산 빌드 시스템과 캐싱을 통해 빌드 성능을 최적화한다.</li><li>대규모 개발자 팀을 지원하기 위한 도구와 인프라를 지속적으로 개선한다.</li></ul></li></ol><h5 id=구조-선택-전략-비교>구조 선택 전략 비교<a hidden class=anchor aria-hidden=true href=#구조-선택-전략-비교>#</a></h5><table><thead><tr><th>요소</th><th>Google/Meta 모노레포 전략</th><th>Amazon/Netflix 멀티레포 전략</th></tr></thead><tbody><tr><td>조직 구조</td><td>중앙화된 엔지니어링 문화, 유동적 팀 구조</td><td>자율적인 팀 구조, Two-Pizza 팀 모델</td></tr><tr><td>기술 표준화</td><td>전사적 표준 도구 및 프로세스</td><td>팀별 맞춤형 기술 스택</td></tr><tr><td>확장 접근법</td><td>도구 및 인프라 고도화를 통한 확장</td><td>독립적 서비스 및 저장소를 통한 확장</td></tr><tr><td>빌드 최적화</td><td>맞춤형 빌드 시스템 (Bazel, Buck) 개발</td><td>작은 코드베이스와 표준 빌드 도구 활용</td></tr><tr><td>리팩토링 철학</td><td>전체 코드베이스 원자적 변경</td><td>서비스 경계를 존중하는 점진적 변경</td></tr><tr><td>배포 전략</td><td>조정된 릴리스와 배포</td><td>독립적이고 지속적인 서비스별 배포</td></tr></tbody></table><h3 id=적합한-상황>적합한 상황<a hidden class=anchor aria-hidden=true href=#적합한-상황>#</a></h3><ul><li><p><strong>모노레포 (Monorepo) 가 적합한 경우</strong></p><ul><li>프로젝트 간 강한 의존성, 코드 공유가 많을 때</li><li>작은~중간 규모의 팀, 통합된 개발/배포 환경이 필요할 때</li><li>대규모 리팩터링, 통합 테스트가 빈번할 때</li></ul></li><li><p><strong>멀티레포 (Multirepo) 가 적합한 경우</strong></p><ul><li>각 서비스/라이브러리별로 독립적인 개발/배포/버전 관리가 필요할 때</li><li>대규모 조직, 여러 팀이 자율적으로 작업할 때</li><li>접근 제어, 보안 이슈가 중요한 경우</li></ul></li></ul><h4 id=활용-예시>활용 예시<a hidden class=anchor aria-hidden=true href=#활용-예시>#</a></h4><p><strong>시나리오</strong>: 대규모 조직에서 여러 팀이 다양한 서비스를 개발하는 경우</p><ul><li><p><strong>MonoRepo 활용</strong>:</p><ul><li>공통 라이브러리와 모듈을 중앙에서 관리하여 코드 재사용을 극대화</li><li>일관된 개발 환경과 통합된 CI/CD 파이프라인을 통해 개발 효율성 향상</li></ul></li><li><p><strong>MultiRepo 활용</strong>:</p><ul><li>각 팀이 독립된 저장소를 운영하여 개발의 유연성과 독립성 확보</li><li>프로젝트별로 맞춤형 CI/CD 파이프라인을 구성하여 특화된 개발 환경 제공</li></ul></li></ul><h4 id=모노레포-vs-멀티레포-선택-기준>모노레포 vs. 멀티레포 선택 기준<a hidden class=anchor aria-hidden=true href=#모노레포-vs-멀티레포-선택-기준>#</a></h4><p>프로젝트 특성에 따른 선택 기준:</p><table><thead><tr><th>기준</th><th>모노레포 적합 상황</th><th>멀티레포 적합 상황</th></tr></thead><tbody><tr><td>팀 규모</td><td>단일 팀 또는 밀접하게 협업하는 소수 팀</td><td>독립적으로 운영되는 다수의 팀</td></tr><tr><td>코드베이스 특성</td><td>긴밀히 결합된 시스템, 공통 코드 다수</td><td>느슨하게 결합된 독립적 서비스</td></tr><tr><td>릴리스 주기</td><td>조정된 릴리스, 전체 시스템 일관성 중요</td><td>독립적인 서비스별 릴리스 주기</td></tr><tr><td>기술 스택</td><td>일관된 기술 스택 선호</td><td>서비스별 맞춤형 기술 선택 필요</td></tr><tr><td>조직 문화</td><td>투명성과 코드 공유 중시</td><td>팀 자율성과 독립성 중시</td></tr><tr><td>프로젝트 성숙도</td><td>안정적이고 성숙한 시스템</td><td>빠르게 진화하는 실험적 서비스</td></tr><tr><td>개발자 경험</td><td>통합된 개발 환경과 도구 선호</td><td>단순하고 특화된 환경 선호</td></tr></tbody></table><h5 id=운영-기준-및-고려사항>운영 기준 및 고려사항<a hidden class=anchor aria-hidden=true href=#운영-기준-및-고려사항>#</a></h5><p>모노레포 효과적 운영을 위한 기준:</p><ol><li><strong>빌드 시스템 투자</strong>:<ul><li>증분 빌드 및 테스트를 지원하는 고급 빌드 시스템 도입</li><li>빌드 캐싱 및 분산 빌드 인프라 구축</li></ul></li><li><strong>코드 구조화</strong>:<ul><li>명확한 모듈 경계와 의존성 관리 정책 수립</li><li>공유 코드와 서비스별 코드의 구분 명확화</li></ul></li><li><strong>접근 제어 메커니즘</strong>:<ul><li>코드 소유권 및 리뷰 정책 확립</li><li>필요한 경우 디렉토리 수준의 접근 제어 구현</li></ul></li><li><strong>확장성 계획</strong>:<ul><li>저장소 크기 증가에 따른 성능 최적화 전략 수립</li><li>Git 가상 파일 시스템 (VFS) 등 대규모 저장소 관리 도구 활용</li></ul></li></ol><p>멀티레포 효과적 운영을 위한 기준:</p><ol><li><strong>의존성 관리</strong>:<ul><li>강력한 내부 패키지 레지스트리 구축</li><li>의존성 버전 관리 및 호환성 테스트 자동화</li></ul></li><li><strong>코드 공유 전략</strong>:<ul><li>공통 라이브러리 추출 및 패키지화 프로세스 확립</li><li>내부 오픈소스 문화 및 기여 절차 수립</li></ul></li><li><strong>통합 도구</strong>:<ul><li>여러 저장소 검색 및 탐색 도구 구축</li><li>프로젝트 간 일관된 CI/CD 파이프라인 템플릿 제공</li></ul></li><li><strong>조정 메커니즘</strong>:<ul><li>서비스 간 의존성 변경 알림 시스템 구축</li><li>다중 저장소 작업을 위한 메타 도구 활용</li></ul></li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>항목</th><th>MonoRepo</th><th>MultiRepo</th></tr></thead><tbody><tr><td><strong>도구 선택</strong></td><td>Bazel, Nx, Lerna 등</td><td>Git, GitHub, GitLab 등</td></tr><tr><td><strong>CI/CD 구성</strong></td><td>통합된 파이프라인 구성 필요</td><td>프로젝트별 개별 파이프라인 구성</td></tr><tr><td><strong>권한 관리</strong></td><td>세분화된 권한 설정 어려움</td><td>프로젝트별 세부적인 권한 설정 가능</td></tr><tr><td><strong>버전 관리</strong></td><td>전체 프로젝트에 대한 일관된 버전 관리</td><td>각 프로젝트별 독립적인 버전 관리</td></tr></tbody></table><h4 id=하이브리드-hybrid-접근>하이브리드 (Hybrid) 접근<a hidden class=anchor aria-hidden=true href=#하이브리드-hybrid-접근>#</a></h4><p>필요에 따라 모노레포와 멀티레포를 혼합하는 하이브리드 구조도 가능하다.<br>예를 들어, 공통 라이브러리/유틸리티는 모노레포로, 각각의 마이크로서비스는 멀티레포로 관리할 수 있다.</p><h4 id=bazelnx-모노레포-도구>Bazel/Nx 모노레포 도구<a hidden class=anchor aria-hidden=true href=#bazelnx-모노레포-도구>#</a></h4><h5 id=bazel-특징-및-기능>Bazel 특징 및 기능<a hidden class=anchor aria-hidden=true href=#bazel-특징-및-기능>#</a></h5><p>Bazel 은 Google 이 개발한 오픈소스 빌드 도구로, 대규모 모노레포를 효율적으로 관리하기 위해 설계되었다:</p><ol><li><strong>핵심 기능</strong>:<ul><li>언어 불가지론적 빌드 시스템: 다양한 언어와 프레임워크 지원</li><li>증분 빌드: 변경된 부분과 그 의존성만 빌드</li><li>재현 가능한 빌드: 동일한 입력에 대해 항상 동일한 출력 보장</li><li>분산 캐싱: 팀 간 빌드 결과 공유로 중복 작업 방지</li></ul></li><li><strong>사용 사례</strong>:<ul><li>복잡한 다중 언어 프로젝트</li><li>엄격한 확정성과 재현성이 필요한 환경</li><li>대규모 엔터프라이즈 코드베이스</li></ul></li><li><strong>장단점</strong>:<ul><li>장점: 뛰어난 성능과 확장성, 견고한 의존성 관리</li><li>단점: 가파른 학습 곡선, 복잡한 설정, 생태계 제한</li></ul></li></ol><h5 id=nx-특징-및-기능>Nx 특징 및 기능<a hidden class=anchor aria-hidden=true href=#nx-특징-및-기능>#</a></h5><p>Nx 는 Nrwl 에서 개발한 모노레포 도구로, 특히 JavaScript/TypeScript 생태계에 최적화되어 있다:</p><ol><li><strong>핵심 기능</strong>:<ul><li>영향 분석: 변경 영향을 받는 프로젝트만 빌드/테스트</li><li>코드 생성기: 일관된 코드 생성 및 구조 제공</li><li>스마트 빌드 캐싱: 로컬 및 분산 캐싱 지원</li><li>시각화 도구: 프로젝트 구조 및 의존성 시각화</li></ul></li><li><strong>사용 사례</strong>:<ul><li>Angular, React, Vue 등 프론트엔드 중심 프로젝트</li><li>풀스택 JavaScript/TypeScript 애플리케이션</li><li>중소규모 모노레포 관리</li></ul></li><li><strong>장단점</strong>:<ul><li>장점: 쉬운 설정, 풍부한 생태계, 개발자 경험 중시</li><li>단점: JavaScript 생태계 중심, 대규모 모노레포에서 한계</li></ul></li></ol><h5 id=도구-비교>도구 비교<a hidden class=anchor aria-hidden=true href=#도구-비교>#</a></h5><table><thead><tr><th>특성</th><th>Bazel</th><th>Nx</th><th>Turborepo</th><th>Rush</th></tr></thead><tbody><tr><td>개발사</td><td>Google</td><td>Nrwl</td><td>Vercel</td><td>Microsoft</td></tr><tr><td>주요 대상</td><td>다중 언어 대규모 코드베이스</td><td>JavaScript/TypeScript 모노레포</td><td>JavaScript/TypeScript 모노레포</td><td>TypeScript/JavaScript 모노레포</td></tr><tr><td>의존성 분석</td><td>명시적 선언 기반</td><td>정적 분석 기반</td><td>파일 경로 분석</td><td>패키지 매니페스트 기반</td></tr><tr><td>캐싱 전략</td><td>입력 해시 기반 분산 캐싱</td><td>로컬 및 분산 캐싱</td><td>클라우드 캐싱</td><td>로컬 캐싱</td></tr><tr><td>확장성</td><td>매우 높음 (Google 규모 지원)</td><td>중간</td><td>중간</td><td>높음</td></tr><tr><td>학습 곡선</td><td>가파름</td><td>완만함</td><td>매우 완만함</td><td>중간</td></tr><tr><td>맞춤 설정</td><td>매우 높음</td><td>중간</td><td>제한적</td><td>높음</td></tr><tr><td>생태계 통합</td><td>제한적</td><td>JavaScript 생태계와 긴밀</td><td>JavaScript 생태계와 긴밀</td><td>Microsoft 도구와 긴밀</td></tr></tbody></table><h4 id=polyrepo-권한-관리-전략>Polyrepo 권한 관리 전략<a hidden class=anchor aria-hidden=true href=#polyrepo-권한-관리-전략>#</a></h4><p>멀티레포 (폴리레포) 환경에서의 효과적인 권한 관리 전략:</p><ol><li><strong>계층적 접근 제어</strong>:<ul><li>팀 기반 권한 모델: 팀 단위로 저장소 접근 권한 관리</li><li>역할 기반 접근 제어 (RBAC): 개발자, 리뷰어, 관리자 등 역할별 권한 할당</li><li>저장소별 세밀한 권한 설정: 읽기, 쓰기, 관리 권한 분리</li></ul></li><li><strong>중앙화된 ID 관리</strong>:<ul><li>단일 ID 제공자 (IdP) 연동: SAML, OAuth 등을 통한 중앙 인증</li><li>자동화된 사용자 프로비저닝: HR 시스템과 연동한 자동 계정 관리</li><li>다중 인증 (MFA) 적용: 중요 저장소에 대한 추가 보안 계층</li></ul></li><li><strong>코드 소유권 관리</strong>:<ul><li>CODEOWNERS 파일 활용: 각 코드 영역별 책임자 명시</li><li>필수 리뷰어 설정: 특정 영역 변경 시 전문가 리뷰 필수화</li><li>자동화된 리뷰 할당: 코드 소유권에 기반한 자동 리뷰어 지정</li></ul></li><li><strong>효율적인 다중 저장소 관리</strong>:<ul><li>저장소 템플릿 활용: 일관된 구조와 기본 권한 설정 적용</li><li>권한 변경 감사: 모든 접근 권한 변경 기록 및 검토</li><li>API 기반 권한 관리: 스크립트 및 자동화를 통한 대량 권한 관리</li></ul></li><li><strong>안전한 CI/CD 파이프라인</strong>:<ul><li>파이프라인 별 최소 권한 원칙: 필요한 접근 권한만 부여</li><li>시크릿 및 자격 증명 안전한 관리: 중앙화된 시크릿 저장소 활용</li><li>빌드 환경 분리: 개발 환경과 빌드/배포 환경의 권한 분리</li></ul></li></ol><p>멀티레포 권한 관리 도구 및 플랫폼:</p><table><thead><tr><th>도구/플랫폼</th><th>주요 기능</th><th>특징</th></tr></thead><tbody><tr><td>GitHub Organizations</td><td>팀 기반 접근 관리, 저장소 템플릿, CODEOWNERS</td><td>팀 구조를 반영한 직관적 권한 관리</td></tr><tr><td>GitLab Groups</td><td>계층적 그룹 구조, 상속 가능한 권한, CI/CD 권한</td><td>복잡한 조직 구조에 적합한 계층적 모델</td></tr><tr><td>Bitbucket Workspaces</td><td>프로젝트별 접근 제어, JIRA 통합, IP 기반 제한</td><td>Atlassian 제품군과의 긴밀한 통합</td></tr><tr><td>Azure DevOps</td><td>상세한 권한 매트릭스, Active Directory 통합</td><td>엔터프라이즈 환경에 최적화된 권한 모델</td></tr><tr><td>Terraform</td><td>코드형 권한 관리, 일관된 권한 배포, 변경 이력 추적</td><td>인프라와 함께 권한을 코드로 관리</td></tr><tr><td>OPA (Open Policy Agent)</td><td>정책 기반 접근 제어, 다양한 시스템 통합</td><td>복잡한 권한 로직을 정책으로 구현</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>모노레포 도구</td><td>클라우드 네이티브 빌드 도구</td><td>Bazel, Nx, Turborepo 등이 클라우드 네이티브 환경에 최적화된 기능을 강화하고 있으며, 분산 빌드와 원격 캐싱 기능이 표준화되고 있습니다</td></tr><tr><td>멀티레포 통합</td><td>AI 기반 코드 탐색</td><td>GitHub Copilot 와 같은 AI 도구가 멀티레포 환경에서 코드 검색과 탐색을 지원하여 여러 저장소에 걸친 코드 이해를 돕고 있습니다</td></tr><tr><td>하이브리드 접근법</td><td>Git Submodules 대안</td><td>Git Submodules 의 한계를 보완하는 새로운 도구들이 등장하여 모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법이 확산되고 있습니다</td></tr><tr><td>빌드 최적화</td><td>분산 컴퓨팅 활용</td><td>클라우드 기반 분산 빌드 시스템이 보편화되어 대규모 모노레포의 빌드 성능이 크게 향상되고 있습니다</td></tr><tr><td>DevOps 통합</td><td>통합 관측성</td><td>모노레포와 멀티레포 모두에서 코드 변경부터 프로덕션 영향까지 추적할 수 있는 통합 관측성 도구가 발전하고 있습니다</td></tr><tr><td>성능 개선</td><td>스파스 체크아웃</td><td>Git 의 스파스 체크아웃 기능이 개선되어 대규모 모노레포의 일부만 효율적으로 클론하고 작업할 수 있게 되었습니다</td></tr><tr><td>보안 강화</td><td>공급망 보안</td><td>저장소 구조와 관계없이 코드 공급망 보안을 강화하는 도구와 프랙티스가 중요해지고 있습니다</td></tr><tr><td>협업 개선</td><td>코드 공유 문화</td><td>멀티레포 환경에서도 내부 패키지 생태계와 문서화를 강화하여 코드 공유 문화를 촉진하는 추세가 강화되고 있습니다</td></tr><tr><td>인프라 관리</td><td>GitOps 적용</td><td>모노레포와 멀티레포 모두에서 GitOps 방식의 인프라 관리가 표준화되어 코드와 인프라의 일관성을 유지하는 추세입니다</td></tr><tr><td>개발자 경험</td><td>통합 개발 환경</td><td>VS Code 와 같은 IDE 가 여러 저장소에 걸친 작업을 더 잘 지원하도록 발전하여 멀티레포 환경에서의 개발자 경험이 개선되고 있습니다</td></tr></tbody></table><h3 id=주목해야-할-기술>주목해야 할 기술<a hidden class=anchor aria-hidden=true href=#주목해야-할-기술>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>빌드 도구</td><td>Turborepo</td><td>JavaScript/TypeScript 모노레포를 위한 고성능 빌드 시스템으로, 단순한 설정과 강력한 캐싱 기능으로 빠르게 채택되고 있습니다</td></tr><tr><td>패키지 관리</td><td>pnpm</td><td>효율적인 디스크 공간 활용과 빠른 설치 속도로 모노레포 환경에서 특히 유용한 패키지 관리자입니다</td></tr><tr><td>코드 조직</td><td>Module Federation</td><td>웹팩의 Module Federation 기능을 활용해 멀티레포 환경에서도 런타임 코드 공유를 가능하게 하는 기술입니다</td></tr><tr><td>개발 환경</td><td>Remote Containers</td><td>VS Code 의 Remote Containers 와 같은 기술로 저장소 구조와 관계없이 일관된 개발 환경을 제공합니다</td></tr><tr><td>자동화 도구</td><td>GitHub Actions Matrix</td><td>여러 저장소에 걸친 CI/CD 작업을 효율적으로 관리할 수 있는 기능입니다</td></tr><tr><td>의존성 관리</td><td>Renovate Bot</td><td>멀티레포 환경에서도 일관된 의존성 업데이트를 자동화할 수 있는 도구입니다</td></tr><tr><td>모노레포 관리</td><td>Nx Cloud</td><td>Nx 기반 모노레포의 분산 캐싱과 CI 최적화를 제공하는 클라우드 서비스입니다</td></tr><tr><td>코드 공유</td><td>Bit</td><td>컴포넌트 단위로 코드를 공유하고 협업할 수 있는 플랫폼으로, 모노레포와 멀티레포 간의 간극을 줄여줍니다</td></tr><tr><td>저장소 관리</td><td>Meta</td><td>여러 Git 저장소를 동시에 관리할 수 있는 메타 도구로, 멀티레포 환경에서의 작업을 단순화합니다</td></tr><tr><td>버전 관리</td><td>Changesets</td><td>모노레포 환경에서 패키지별 버전 관리와 변경 로그 생성을 자동화하는 도구입니다</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>접근 방식 융합</td><td>하이브리드 모델 성장</td><td>모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법이 더욱 보편화될 전망입니다</td></tr><tr><td>도구 생태계</td><td>범용 도구 발전</td><td>저장소 구조와 관계없이 효율적인 개발을 지원하는 범용 도구가 발전하여 저장소 구조 선택의 중요성이 감소할 것입니다</td></tr><tr><td>클라우드 통합</td><td>서버리스 빌드 시스템</td><td>완전 관리형 서버리스 빌드 시스템이 보편화되어 인프라 관리 부담 없이 대규모 코드베이스를 처리할 수 있게 될 것입니다</td></tr><tr><td>개발자 경험</td><td>코드 내비게이션 혁신</td><td>AI 기반 코드 탐색 및 이해 도구가 발전하여 대규모 코드베이스나 다중 저장소 환경에서의 개발자 생산성이 크게 향상될 것입니다</td></tr><tr><td>조직 변화</td><td>DevEx 팀 부상</td><td>저장소 구조와 관계없이 개발자 경험을 최적화하는 전담 DevEx 팀의 중요성이 더욱 커질 것입니다</td></tr><tr><td>배포 접근법</td><td>지속적 배포 표준화</td><td>모노레포와 멀티레포 모두에서 완전 자동화된 지속적 배포가 표준이 되어 릴리스 프로세스의 차이가 줄어들 것입니다</td></tr><tr><td>확장성 개선</td><td>분산 버전 관리 발전</td><td>Git 이후의 차세대 분산 버전 관리 시스템이 등장하여 초대형 코드베이스 관리의 제약이 줄어들 것입니다</td></tr><tr><td>자동화 증가</td><td>지능형 의존성 관리</td><td>AI 기반 의존성 분석 및 업데이트 시스템이 발전하여 복잡한 의존성 그래프 관리가 간소화될 것입니다</td></tr><tr><td>보안 강화</td><td>저장소 통합 보안</td><td>저장소 구조와 관계없이 일관된 보안 정책을 적용하고 모니터링하는 통합 도구가 표준화될 것입니다</td></tr><tr><td>코드베이스 이해</td><td>AI 코드 분석</td><td>대규모 코드베이스 이해를 돕는 AI 기반 코드 분석 및 문서화 도구가 개발되어 온보딩 및 지식 공유가 개선될 것입니다</td></tr><tr><td>패러다임 변화</td><td>서비스 추상화</td><td>저장소 구조보다 서비스 인터페이스와 계약에 초점을 맞춘 개발 패러다임이 강화될 것입니다</td></tr></tbody></table><h3 id=추가-학습-내용>추가 학습 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>빌드 도구</td><td>Bazel 고급 구성</td><td>대규모 모노레포를 위한 Bazel 빌드 시스템의 고급 기능과 최적화 기법</td></tr><tr><td></td><td>Turborepo 파이프라인</td><td>JavaScript/TypeScript 모노레포를 위한 Turborepo 파이프라인 구성 및 최적화</td></tr><tr><td></td><td>Nx 워크스페이스 설계</td><td>Nx 를 활용한 효율적인 모노레포 워크스페이스 구조화 전략</td></tr><tr><td>버전 관리</td><td>모노레포 버전 관리 전략</td><td>Lerna, Changesets 등을 활용한 모노레포 내 패키지 버전 관리 방법</td></tr><tr><td></td><td>멀티레포 배포 조정</td><td>여러 저장소에 걸친 의존성 있는 서비스의 효과적인 배포 조정 방법</td></tr><tr><td></td><td>Git 서브모듈과 대안</td><td>Git 서브모듈의 활용과 한계, 그리고 더 나은 대안들</td></tr><tr><td>성능 최적화</td><td>대규모 저장소 Git 최적화</td><td>대규모 Git 저장소의 성능을 유지하기 위한 최적화 기법</td></tr><tr><td></td><td>모노레포 증분 빌드</td><td>변경된 코드만 선택적으로 빌드하는 증분 빌드 전략</td></tr><tr><td></td><td>분산 캐싱 솔루션</td><td>팀 간 빌드 결과를 공유하는 분산 캐싱 시스템 구축</td></tr><tr><td>협업 전략</td><td>모노레포 브랜칭 전략</td><td>모노레포 환경에 최적화된 Git 브랜칭 및 워크플로우 전략</td></tr><tr><td></td><td>멀티레포 코드 공유</td><td>멀티레포 환경에서 효과적인 코드 공유와 재사용 방법</td></tr><tr><td></td><td>코드 소유권 관리</td><td>대규모 저장소에서의 코드 소유권과 책임 관리 체계</td></tr><tr><td>도구 통합</td><td>CI/CD 파이프라인 설계</td><td>모노레포와 멀티레포에 최적화된 CI/CD 파이프라인 구성</td></tr><tr><td></td><td>코드 품질 도구 통합</td><td>일관된 코드 품질을 유지하기 위한 린트, 테스트 도구 통합</td></tr><tr><td></td><td>모니터링 및 관측성</td><td>저장소 구조와 관계없이 효과적인 모니터링 체계 구축</td></tr><tr><td>마이그레이션</td><td>모노레포 전환 전략</td><td>멀티레포에서 모노레포로 안전하게 전환하는 단계별 전략</td></tr><tr><td></td><td>멀티레포 분할 전략</td><td>대규모 모노레포를 효과적으로 분할하는 접근법</td></tr><tr><td></td><td>하이브리드 저장소 구조</td><td>모노레포와 멀티레포의 장점을 결합한 하이브리드 접근법</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>모노레포 (MonoRepo)</td><td>여러 프로젝트와 관련 코드를 단일 버전 관리 저장소에서 관리하는 방식</td></tr><tr><td>멀티레포 (MultiRepo)</td><td>각 프로젝트나 서비스마다 독립된 버전 관리 저장소를 사용하는 방식</td></tr><tr><td>폴리레포 (PolyRepo)</td><td>멀티레포와 동일한 개념으로, 여러 저장소를 사용하는 접근법</td></tr><tr><td>증분 빌드 (Incremental Build)</td><td>변경된 부분과 그 의존성만 선택적으로 빌드하는 최적화 기법</td></tr><tr><td>원자적 변경 (Atomic Changes)</td><td>여러 프로젝트에 걸친 변경사항을 단일 커밋으로 처리하는 방식</td></tr><tr><td>의존성 그래프 (Dependency Graph)</td><td>프로젝트 간 의존 관계를 나타내는 방향성 그래프 구조</td></tr><tr><td>워크스페이스 (Workspace)</td><td>여러 패키지나 프로젝트를 포함하는 개발 환경 단위</td></tr><tr><td>Bazel</td><td>Google 이 개발한 대규모 모노레포를 위한 언어 불가지론적 빌드 시스템</td></tr><tr><td>Nx</td><td>JavaScript/TypeScript 생태계에 최적화된 모노레포 개발 플랫폼</td></tr><tr><td>Turborepo</td><td>Vercel 에서 개발한 JavaScript/TypeScript 모노레포를 위한 고성능 빌드 시스템</td></tr><tr><td>pnpm</td><td>디스크 공간을 효율적으로 사용하는 Node.js 패키지 관리자로, 모노레포 지원이 강화됨</td></tr><tr><td>Lerna</td><td>JavaScript 모노레포 관리를 위한 도구로, 멀티 패키지 저장소 관리를 단순화</td></tr><tr><td>Changesets</td><td>모노레포 환경에서 버전 관리와 변경 로그 생성을 자동화하는 도구</td></tr><tr><td>Git 서브모듈 (Git Submodules)</td><td>한 Git 저장소 안에 다른 Git 저장소를 포함시키는 메커니즘</td></tr><tr><td>모듈 연합 (Module Federation)</td><td>여러 독립적 빌드 간에 런타임 코드 공유를 가능하게 하는 웹팩 기능</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://opensource.googleblog.com/2017/02/why-google-stores-build-system-monorepo.html>Google 개발자 블로그 - Monorepo 관리 전략</a></li><li><a href=https://engineering.fb.com/2019/05/06/web/meta-monorepo/>Meta Engineering 블로그 - 대규모 코드베이스 운영 방식</a></li><li><a href=https://devblogs.microsoft.com/devops/monorepo/>Microsoft Engineering - One Engineering System</a></li><li><a href=https://netflixtechblog.com/microservices-at-netflix-why-we-use-them-d3f3cdcd2b5f>Netflix 기술 블로그 - Microservices at Netflix</a></li><li><a href=https://bazel.build/>Bazel 공식 사이트</a></li><li><a href=https://nx.dev/>Nx 공식 사이트</a></li><li><a href=https://lerna.js.org/>Lerna 공식 문서</a></li><li><a href=https://docs.github.com/en/repositories/working-with-files/managing-large-repositories/working-with-monorepos>GitHub Docs - Managing monorepos</a></li><li><a href=https://www.atlassian.com/git/tutorials/monorepos>Atlassian 블로그 - Monorepo vs. Multi-repo</a></li><li><a href=https://nx.dev/concepts/more-concepts/why-monorepos>NX Monorepo 소개</a></li><li><a href=https://turborepo.org/docs>Turborepo 공식 문서</a></li><li><a href=https://research.google/pubs/pub45424/>Google의 단일 저장소 분석</a></li><li><a href=https://devblogs.microsoft.com/devops/semantic-versioning-monorepo-development/>Microsoft의 대규모 Git 저장소 관리</a></li><li><a href=https://engineering.atspotify.com/2020/04/when-should-i-use-a-monorepo/>Spotify의 저장소 전략 사례 연구</a></li><li><a href=https://bazel.build/concepts/monorepos>Bazel 빌드 시스템 문서</a></li><li><a href=https://pnpm.io/workspaces>pnpm 워크스페이스 가이드</a></li><li><a href=https://buck.build/>Meta/Facebook의 Buck 빌드 시스템</a></li><li><a href=https://yarnpkg.com/features/workspaces>Yarn 워크스페이스 문서</a></li><li><a href=https://lerna.js.org/>Lerna 모노레포 관리 도구</a></li><li><a href=https://github.blog/2021-04-29-scaling-monorepo-maintenance/>GitHub의 저장소 최적화 가이드</a></li><li><a href=https://www.atlassian.com/git/tutorials/monorepos>Atlassian의 모노레포 vs 멀티레포 가이드</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/version-control-systems/>Version-Control-Systems</a></li><li><a href=https://buenhyden.github.io/tags/enterprise-usage/>Enterprise-Usage</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/large-scale-management/><span class=title>« Prev</span><br><span>Large-scale Management</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/cache-types/caching-techniques/><span class=title>Next »</span><br><span>Caching Techniques</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>