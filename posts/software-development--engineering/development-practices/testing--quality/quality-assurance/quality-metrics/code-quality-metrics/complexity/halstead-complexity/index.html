<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Halstead Complexity | hyunyoun's Blog</title><meta name=keywords content="QA,Fundamentals,Quality-Metric,Halstead-Complexity"><meta name=description content="프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Halstead Complexity"><meta property="og:description" content="프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-28T09:43:00+00:00"><meta property="article:modified_time" content="2024-10-28T09:43:00+00:00"><meta property="article:tag" content="QA"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Quality-Metric"><meta property="article:tag" content="Halstead-Complexity"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Halstead Complexity"><meta name=twitter:description content="프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Halstead Complexity","item":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Halstead Complexity","name":"Halstead Complexity","description":"프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다","keywords":["QA","Fundamentals","Quality-Metric","Halstead-Complexity"],"articleBody":"Halstead Complexity Halstead 복잡도는 1977년 Maurice Howard Halstead가 제안한 소프트웨어 메트릭으로, 프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다.\n이는 프로그램의 구현 난이도와 이해도를 정량적으로 평가하는 방법을 제공한다.\n코드의 구현을 반영하지만 특정 플랫폼에서의 실행과는 독립적이다.\n기본 측정 요소:\n프로그램의 기본 요소는 다음과 같이 정의된다:\nn1: 고유 연산자의 수 n2: 고유 피연산자의 수 N1: 총 연산자의 출현 횟수 N2: 총 피연산자의 출현 횟수\n예를 들어, 다음 코드를 살펴보자. 1 sum = a + b * 2; 이 코드에서:\n연산자: =, +, * (n1 = 3) 피연산자: sum, a, b, 2 (n2 = 4) 총 연산자 출현: =, +, * (N1 = 3) 총 피연산자 출현: sum, a, b, 2 (N2 = 4) Halstead 메트릭의 주요 측정항목 프로그램 길이(Program Length):\nN = N1 + N2\n이는 프로그램에서 사용된 모든 연산자와 피연산자의 총 출현 횟수. 프로그램 어휘(Program Vocabulary):\nn = n1 + n2\n이는 프로그램에서 사용된 고유한 연산자와 피연산자의 총 개수. 프로그램 볼륨(Program Volume):\nV = N * log2(n)\n이는 프로그램의 정보 내용을 비트 단위로 표현한 것. 난이도(Difficulty):\nD = (n1/2) * (N2/n2)\n이는 프로그램을 이해하고 유지보수하는 난이도를 나타낸다. 노력(Effort):\nE = D * V\n프로그램을 구현하거나 이해하는 데 필요한 정신적 노력을 나타낸다. 구현 시간(Implementation Time):\nT = E / 18\n프로그램을 구현하는 데 필요한 시간을 초 단위로 추정한다. 실제 적용 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 원래 코드 public int calculateTotal(int[] numbers) { int sum = 0; for (int i = 0; i \u003c numbers.length; i++) { sum = sum + numbers[i]; } return sum; } // 개선된 코드 public int calculateTotal(int[] numbers) { return Arrays.stream(numbers).sum(); } 두 번째 버전은 첫 번째 버전보다 Halstead 복잡도가 낮다. 연산자와 피연산자의 수가 줄어들었기 때문이다.\n측정 도구 PMD: Java 코드의 Halstead 메트릭 측정 SonarQube: 다양한 언어의 코드 품질 분석 Understand: 상세한 코드 메트릭 분석 도구 CCCC: C++용 코드 복잡도 분석 도구 전략 및 권장사항 코드 로직 단순화: 복잡한 조건문을 간소화하고 명확한 로직 구조를 사용한다. 고유 연산자와 피연산자 사용 줄이기: 코드의 일관성을 높이고 복잡성을 낮춘다. 코드 리팩토링: 큰 함수를 작은 단위로 분할하여 복잡도를 낮춘다. 높은 수준의 추상화 사용: 디자인 패턴이나 프레임워크를 활용하여 복잡한 로직을 추상화한다. 주의사항 Halstead 복잡도만으로는 코드의 전체적인 품질을 평가하기 어려우므로, 다른 메트릭들과 함께 사용해야 한다. Halstead 메트릭은 프로그램의 구문적 특성만을 측정하며, 의미적 복잡성은 고려하지 않는다. 언어와 컨텍스트에 따라 “좋은” 점수의 기준이 다를 수 있으므로, 프로젝트 특성에 맞는 벤치마크를 설정해야 한다. 참고 및 출처 ","wordCount":"387","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-28T09:43:00Z","dateModified":"2024-10-28T09:43:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Halstead Complexity</h1><div class=post-description>프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다</div><div class=post-meta><span title='2024-10-28 09:43:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Development%20&%20Engineering/Development%20Practices/Testing%20&%20Quality/Quality%20Assurance/Quality%20Metrics/Code%20Quality%20Metrics/Complexity/Halstead-Complexity.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#halstead-complexity>Halstead Complexity</a><ul><li><a href=#halstead-메트릭의-주요-측정항목>Halstead 메트릭의 주요 측정항목</a></li><li><a href=#측정-도구>측정 도구</a></li><li><a href=#전략-및-권장사항>전략 및 권장사항</a></li><li><a href=#주의사항>주의사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=halstead-complexity>Halstead Complexity<a hidden class=anchor aria-hidden=true href=#halstead-complexity>#</a></h2><p>Halstead 복잡도는 1977년 Maurice Howard Halstead가 제안한 소프트웨어 메트릭으로, 프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다.<br>이는 프로그램의 구현 난이도와 이해도를 정량적으로 평가하는 방법을 제공한다.<br>코드의 구현을 반영하지만 특정 플랫폼에서의 실행과는 독립적이다.</p><p>기본 측정 요소:<br>프로그램의 기본 요소는 다음과 같이 정의된다:</p><ul><li>n1: 고유 연산자의 수</li><li>n2: 고유 피연산자의 수</li><li>N1: 총 연산자의 출현 횟수</li><li>N2: 총 피연산자의 출현 횟수<br>예를 들어, 다음 코드를 살펴보자.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>이 코드에서:</p><ul><li>연산자: =, +, * (n1 = 3)</li><li>피연산자: sum, a, b, 2 (n2 = 4)</li><li>총 연산자 출현: =, +, * (N1 = 3)</li><li>총 피연산자 출현: sum, a, b, 2 (N2 = 4)</li></ul><h3 id=halstead-메트릭의-주요-측정항목>Halstead 메트릭의 주요 측정항목<a hidden class=anchor aria-hidden=true href=#halstead-메트릭의-주요-측정항목>#</a></h3><ol><li>프로그램 길이(Program Length):<br><code>N = N1 + N2</code><br>이는 프로그램에서 사용된 모든 연산자와 피연산자의 총 출현 횟수.</li><li>프로그램 어휘(Program Vocabulary):<br><code>n = n1 + n2</code><br>이는 프로그램에서 사용된 고유한 연산자와 피연산자의 총 개수.</li><li>프로그램 볼륨(Program Volume):<br><code>V = N * log2(n)</code><br>이는 프로그램의 정보 내용을 비트 단위로 표현한 것.</li><li>난이도(Difficulty):<br><code>D = (n1/2) * (N2/n2)</code><br>이는 프로그램을 이해하고 유지보수하는 난이도를 나타낸다.</li><li>노력(Effort):<br><code>E = D * V</code><br>프로그램을 구현하거나 이해하는 데 필요한 정신적 노력을 나타낸다.</li><li>구현 시간(Implementation Time):<br><code>T = E / 18</code><br>프로그램을 구현하는 데 필요한 시간을 초 단위로 추정한다.</li></ol><p>실제 적용 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 원래 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>calculateTotal</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>numbers</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numbers</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>sum</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 개선된 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>calculateTotal</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>numbers</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>stream</span><span class=p>(</span><span class=n>numbers</span><span class=p>).</span><span class=na>sum</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>두 번째 버전은 첫 번째 버전보다 Halstead 복잡도가 낮다. 연산자와 피연산자의 수가 줄어들었기 때문이다.</p><h3 id=측정-도구>측정 도구<a hidden class=anchor aria-hidden=true href=#측정-도구>#</a></h3><ol><li>PMD: Java 코드의 Halstead 메트릭 측정</li><li>SonarQube: 다양한 언어의 코드 품질 분석</li><li>Understand: 상세한 코드 메트릭 분석 도구</li><li>CCCC: C++용 코드 복잡도 분석 도구</li></ol><h3 id=전략-및-권장사항>전략 및 권장사항<a hidden class=anchor aria-hidden=true href=#전략-및-권장사항>#</a></h3><ol><li>코드 로직 단순화: 복잡한 조건문을 간소화하고 명확한 로직 구조를 사용한다.</li><li>고유 연산자와 피연산자 사용 줄이기: 코드의 일관성을 높이고 복잡성을 낮춘다.</li><li>코드 리팩토링: 큰 함수를 작은 단위로 분할하여 복잡도를 낮춘다.</li><li>높은 수준의 추상화 사용: 디자인 패턴이나 프레임워크를 활용하여 복잡한 로직을 추상화한다.</li></ol><h3 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h3><ol><li>Halstead 복잡도만으로는 코드의 전체적인 품질을 평가하기 어려우므로, 다른 메트릭들과 함께 사용해야 한다.</li><li>Halstead 메트릭은 프로그램의 구문적 특성만을 측정하며, 의미적 복잡성은 고려하지 않는다.</li><li>언어와 컨텍스트에 따라 &ldquo;좋은&rdquo; 점수의 기준이 다를 수 있으므로, 프로젝트 특성에 맞는 벤치마크를 설정해야 한다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/qa/>QA</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/quality-metric/>Quality-Metric</a></li><li><a href=https://buenhyden.github.io/tags/halstead-complexity/>Halstead-Complexity</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/test-and-process-metrics/test-coverage/><span class=title>« Prev</span><br><span>테스트 커버리지 (Test Coverage)</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/cyclomatic-complexity/><span class=title>Next »</span><br><span>순환 복잡도 (Cyclomatic Complexity)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>