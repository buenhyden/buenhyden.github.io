<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>History and Evolution of CI/CD | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,CI-CD,CI-CD-Fundamentals"><meta name=description content="1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="History and Evolution of CI/CD"><meta property="og:description" content="1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T00:51:00+00:00"><meta property="article:modified_time" content="2024-10-02T00:51:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="CI-CD"><meta property="article:tag" content="CI-CD-Fundamentals"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="History and Evolution of CI/CD"><meta name=twitter:description content="1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"History and Evolution of CI/CD","item":"https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"History and Evolution of CI/CD","name":"History and Evolution of CI\/CD","description":"1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다.","keywords":["DevOps-and-Infrastructure","CI-CD","CI-CD-Fundamentals"],"articleBody":"History and Evolution of CI/CD CI/CD(지속적 통합/지속적 배포) 의 역사와 발전은 소프트웨어 개발 방법론의 진화를 보여주는 중요한 여정입니다. 1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념이 시작점이었으며, 이후 애자일 방법론의 부상과 함께 발전했다. 워터폴 모델의 한계를 극복하기 위해 등장한 CI/CD 는 개발자들이 코드 변경사항을 빈번하게 통합하고 자동화된 테스트를 수행하는 방식으로 진화했다. 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장은 CI/CD 도구의 대중화를 이끌었고, 이후 클라우드와 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 도구들이 등장했다. 현재 CI/CD 는 GitOps, AIOps, 보안 통합 (DevSecOps) 등의 최신 트렌드를 포함하며 계속 발전하고 있다. 이 발전 과정은 수동적이고 경직된 개발 프로세스에서 자동화되고 유연한 방식으로의 전환을 보여주며, 소프트웨어 산업의 혁신과 속도를 가속화하는 데 중요한 역할을 하고 있다.\nCI/CD 의 발전은 소프트웨어 개발 방법론의 진화와 밀접하게 연관되어 있다:\n1990 년대 이전: 워터폴 모델 소프트웨어 개발은 하드웨어 설계 프로세스를 모방한 단계적, 선형적 방식으로 진행되었다. 각 단계 (요구사항 분석, 설계, 구현, 테스트, 배포) 가 순차적으로 진행되었다. 통합은 개발 후반부에 한 번 이루어져 \" 통합 지옥 (Integration Hell)\" 이라는 문제가 자주 발생했다. 1990 년대 후반: 지속적 통합의 등장 1997 년, 켄트 백 (Kent Beck) 과 론 제프리스 (Ron Jeffries) 가 익스트림 프로그래밍 (XP) 을 개발하면서 지속적 통합 개념을 핵심 실천 방법으로 도입했다. 마틴 파울러 (Martin Fowler) 가 2000 년대 초반 ThoughtWorks 에서 CI 를 적극적으로 옹호하고 발전시켰다. CI 는 개발자들이 코드를 자주 통합하고 자동화된 테스트를 실행함으로써 통합 문제를 조기에 발견하고 해결하는 방식을 제안했다. 2000 년대 중반: CI 도구의 등장 2005 년 코이 버그스 (Kohsuke Kawaguchi) 가 Hudson(후에 Jenkins 로 명칭 변경) 을 개발하면서 CI 도구가 대중화되기 시작했다. CruiseControl, Bamboo 등 다양한 CI 도구가 등장했다. 이 시기에는 주로 빌드 자동화와 기본적인 테스트 자동화에 중점을 두었다. 2000 년대 후반: 애자일과 DevOps 의 영향 애자일 방법론의 확산으로 빠른 피드백과 반복적 개발의 중요성이 강조되었다. 2009 년 Flickr 의 \" 하루 10 번 배포 (10 deploys per day)\" 발표가 DevOps 움직임의 시작점이 되었다. 개발과 운영의 협업이 강조되면서 CD(지속적 전달) 의 개념이 형성되기 시작했다. 2010 년대 초반: 지속적 전달과 배포 2010 년 젠스 험블 (Jez Humble) 과 데이비드 팔리 (David Farley) 의 “Continuous Delivery” 책이 출판되어 CD 개념을 체계화했다. Netflix, Amazon, Etsy 등의 기업이 지속적 배포 사례를 공개하며 산업 전반에 영향을 미쳤다. 클라우드 컴퓨팅의 발전으로 인프라 프로비저닝과 배포 자동화가 더욱 용이해졌다. 2010 년대 중반: 클라우드 네이티브 CI/CD Docker(2013 년) 와 Kubernetes(2014 년) 의 등장으로 컨테이너 기반 CI/CD 가 대중화되었다. Travis CI, CircleCI 등 클라우드 기반 CI/CD 서비스가 확산되었다. 마이크로서비스 아키텍처의 채택으로 더 복잡한 CI/CD 파이프라인이 필요해졌다. 2010 년대 후반: GitOps 와 파이프라인 고도화 2017 년 WeaveWorks 에서 GitOps 개념을 소개하여 Git 을 통한 선언적 인프라와 애플리케이션 관리가 확산되었다. GitHub Actions(2018 년), GitLab CI/CD 의 발전으로 코드 저장소와 CI/CD 의 통합이 강화되었다. 보안 (DevSecOps), 품질, 규정 준수 요소가 파이프라인에 통합되었다. 2020 년대: AI/ML 통합과 플랫폼 엔지니어링 AI/ML 을 활용한 테스트 최적화, 배포 결정, 모니터링이 등장했다. 내부 개발자 플랫폼 (IDP) 과 셀프서비스 CI/CD 플랫폼이 발전했다. 멀티클라우드, 하이브리드 환경을 위한 CI/CD 전략이 확대되었다. 전통적 개발 vs. CI/CD 구분 전통적 개발 CI/CD 배포 주기 월간/분기별 시간/일 단위 테스트 시점 개발 완료 후 수동 테스트 코드 커밋 시 자동 테스트 장애 대응 수동 롤백 자동 롤백 협업 방식 개발/운영 팀 분리 DevOps 문화 기반 통합 팀 보안 배포 후 검증 파이프라인 내 보안 검사 (DevSecOps) 기존 수동 배포 Vs 자동화된 CI/CD 비교 항목 기존 수동 배포 자동화된 CI/CD 배포 소요 시간 수 시간 ~ 수 일 수 분 ~ 수 십 분 배포 빈도 주간/월간/분기별 일간/시간별/커밋별 오류 발생률 높음 (수동 단계로 인한 휴먼 에러) 낮음 (자동화로 일관성 유지) 롤백 시간 오래 걸림 (복잡한 수동 절차) 빠름 (자동화된 롤백 메커니즘) 운영 부담 릴리즈 기간 동안 높은 스트레스 지속적인 소규모 변경으로 부담 분산 지식 전파 특정 인원에 의존적 자동화된 파이프라인으로 지식 공유 작업 추적성 제한적 (수동 로그 및 문서) 높음 (자동화된 로그 및 감사 추적) 리소스 활용 비효율적 (배포 준비 및 대기 시간) 효율적 (자동화된 리소스 할당) 품질 보증 릴리즈 전 집중적 QA 지속적인 자동화된 테스트 사용자 피드백 늦은 피드백 (대규모 릴리즈 후) 빠른 피드백 (작은 변경에 대한 반응) 용어 정리 용어 설명 CI(Continuous Integration) 개발자들이 코드 변경사항을 중앙 저장소에 자주 통합하고 자동화된 빌드와 테스트를 실행하는 소프트웨어 개발 방식 CD(Continuous Delivery) 소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하도록 자동화하는 방법론 CD(Continuous Deployment) 코드 변경이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식 DevOps 개발 (Development) 과 운영 (Operations) 을 통합하여 소프트웨어 개발과 배포 과정을 개선하는 문화와 방법론 파이프라인 (Pipeline) 코드 변경부터 프로덕션 배포까지 일련의 자동화된 단계 IaC(Infrastructure as Code) 인프라스트럭처 구성을 코드로 관리하는 방식 GitOps Git 을 중심으로 인프라와 애플리케이션 배포를 관리하는 방식 테스트 자동화 (Test Automation) 소프트웨어 테스트 과정을 자동화하여 일관성과 효율성을 높이는 방식 카나리 배포 (Canary Deployment) 일부 사용자에게만 새 버전을 배포하여 위험을 최소화하는 전략 블루 - 그린 배포 (Blue-Green Deployment) 두 개의 동일한 프로덕션 환경을 번갈아 가며 배포하는 전략 피처 플래그 (Feature Flag) 코드 배포와 기능 활성화를 분리하여 위험을 관리하는 기술 DevSecOps 개발, 보안, 운영을 통합하여 보안을 소프트웨어 개발 초기 단계부터 고려하는 접근법 통합 지옥 (Integration Hell) 오래 분리된 코드 브랜치를 통합할 때 발생하는 복잡한 충돌과 문제 상황 워터폴 모델 (Waterfall Model) 순차적으로 진행되는 전통적인 소프트웨어 개발 방법론 익스트림 프로그래밍 (XP, Extreme Programming) 지속적 통합, 테스트 주도 개발 등을 포함하는 애자일 소프트웨어 개발 방법론 참고 및 출처 Red Hat CI/CD 설명 Testaify CI/CD 역사 2025 CI/CD 트렌드(Kairos Technologies) Atlassian: CI/CD의 역사 The New Stack: CI/CD 발전 과정 AWS CodePipeline 개념 문서 GitLab CI/CD 개요 Jenkins Pipeline 설명 마틴 파울러의 지속적 통합 설명 Atlassian의 CI, CD, 배포 비교 가이드 RedHat의 CI/CD 개요 GitHub의 CI/CD 리소스 CircleCI의 DevOps 역사 시리즈 DevOps.com의 워터폴과 애자일 분석 Cloud Native Now의 CI/CD 진화 Clearly Agile의 CI/CD 모범 사례 IBM의 CI/CD 파이프라인 설명 CrowdStrike의 CI/CD 구성요소 및 도구 ","wordCount":"910","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-02T00:51:00Z","dateModified":"2024-10-02T00:51:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">History and Evolution of CI/CD</h1><div class=post-description>1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다.</div><div class=post-meta><span title='2024-10-02 00:51:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Development%20&%20Engineering/Engineering%20Operations/DevOps%20&%20CI-CD/CI-CD%20Fundamentals/history-and-evolution-of-ci-cd.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#history-and-evolution-of-cicd>History and Evolution of CI/CD</a><ul><li><a href=#전통적-개발-vs-cicd>전통적 개발 vs. CI/CD</a></li><li><a href=#기존-수동-배포-vs-자동화된-cicd-비교>기존 수동 배포 Vs 자동화된 CI/CD 비교</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=history-and-evolution-of-cicd>History and Evolution of CI/CD<a hidden class=anchor aria-hidden=true href=#history-and-evolution-of-cicd>#</a></h2><p>CI/CD(지속적 통합/지속적 배포) 의 역사와 발전은 소프트웨어 개발 방법론의 진화를 보여주는 중요한 여정입니다. 1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념이 시작점이었으며, 이후 애자일 방법론의 부상과 함께 발전했다. 워터폴 모델의 한계를 극복하기 위해 등장한 CI/CD 는 개발자들이 코드 변경사항을 빈번하게 통합하고 자동화된 테스트를 수행하는 방식으로 진화했다. 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장은 CI/CD 도구의 대중화를 이끌었고, 이후 클라우드와 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 도구들이 등장했다. 현재 CI/CD 는 GitOps, AIOps, 보안 통합 (DevSecOps) 등의 최신 트렌드를 포함하며 계속 발전하고 있다. 이 발전 과정은 수동적이고 경직된 개발 프로세스에서 자동화되고 유연한 방식으로의 전환을 보여주며, 소프트웨어 산업의 혁신과 속도를 가속화하는 데 중요한 역할을 하고 있다.</p><p>CI/CD 의 발전은 소프트웨어 개발 방법론의 진화와 밀접하게 연관되어 있다:</p><ol><li><strong>1990 년대 이전: 워터폴 모델</strong><ul><li>소프트웨어 개발은 하드웨어 설계 프로세스를 모방한 단계적, 선형적 방식으로 진행되었다.</li><li>각 단계 (요구사항 분석, 설계, 구현, 테스트, 배포) 가 순차적으로 진행되었다.</li><li>통합은 개발 후반부에 한 번 이루어져 " 통합 지옥 (Integration Hell)" 이라는 문제가 자주 발생했다.</li></ul></li><li><strong>1990 년대 후반: 지속적 통합의 등장</strong><ul><li>1997 년, 켄트 백 (Kent Beck) 과 론 제프리스 (Ron Jeffries) 가 익스트림 프로그래밍 (XP) 을 개발하면서 지속적 통합 개념을 핵심 실천 방법으로 도입했다.</li><li>마틴 파울러 (Martin Fowler) 가 2000 년대 초반 ThoughtWorks 에서 CI 를 적극적으로 옹호하고 발전시켰다.</li><li>CI 는 개발자들이 코드를 자주 통합하고 자동화된 테스트를 실행함으로써 통합 문제를 조기에 발견하고 해결하는 방식을 제안했다.</li></ul></li><li><strong>2000 년대 중반: CI 도구의 등장</strong><ul><li>2005 년 코이 버그스 (Kohsuke Kawaguchi) 가 Hudson(후에 Jenkins 로 명칭 변경) 을 개발하면서 CI 도구가 대중화되기 시작했다.</li><li>CruiseControl, Bamboo 등 다양한 CI 도구가 등장했다.</li><li>이 시기에는 주로 빌드 자동화와 기본적인 테스트 자동화에 중점을 두었다.</li></ul></li><li><strong>2000 년대 후반: 애자일과 DevOps 의 영향</strong><ul><li>애자일 방법론의 확산으로 빠른 피드백과 반복적 개발의 중요성이 강조되었다.</li><li>2009 년 Flickr 의 " 하루 10 번 배포 (10 deploys per day)" 발표가 DevOps 움직임의 시작점이 되었다.</li><li>개발과 운영의 협업이 강조되면서 CD(지속적 전달) 의 개념이 형성되기 시작했다.</li></ul></li><li><strong>2010 년대 초반: 지속적 전달과 배포</strong><ul><li>2010 년 젠스 험블 (Jez Humble) 과 데이비드 팔리 (David Farley) 의 &ldquo;Continuous Delivery&rdquo; 책이 출판되어 CD 개념을 체계화했다.</li><li>Netflix, Amazon, Etsy 등의 기업이 지속적 배포 사례를 공개하며 산업 전반에 영향을 미쳤다.</li><li>클라우드 컴퓨팅의 발전으로 인프라 프로비저닝과 배포 자동화가 더욱 용이해졌다.</li></ul></li><li><strong>2010 년대 중반: 클라우드 네이티브 CI/CD</strong><ul><li>Docker(2013 년) 와 Kubernetes(2014 년) 의 등장으로 컨테이너 기반 CI/CD 가 대중화되었다.</li><li>Travis CI, CircleCI 등 클라우드 기반 CI/CD 서비스가 확산되었다.</li><li>마이크로서비스 아키텍처의 채택으로 더 복잡한 CI/CD 파이프라인이 필요해졌다.</li></ul></li><li><strong>2010 년대 후반: GitOps 와 파이프라인 고도화</strong><ul><li>2017 년 WeaveWorks 에서 GitOps 개념을 소개하여 Git 을 통한 선언적 인프라와 애플리케이션 관리가 확산되었다.</li><li>GitHub Actions(2018 년), GitLab CI/CD 의 발전으로 코드 저장소와 CI/CD 의 통합이 강화되었다.</li><li>보안 (DevSecOps), 품질, 규정 준수 요소가 파이프라인에 통합되었다.</li></ul></li><li><strong>2020 년대: AI/ML 통합과 플랫폼 엔지니어링</strong><ul><li>AI/ML 을 활용한 테스트 최적화, 배포 결정, 모니터링이 등장했다.</li><li>내부 개발자 플랫폼 (IDP) 과 셀프서비스 CI/CD 플랫폼이 발전했다.</li><li>멀티클라우드, 하이브리드 환경을 위한 CI/CD 전략이 확대되었다.</li></ul></li></ol><h3 id=전통적-개발-vs-cicd>전통적 개발 vs. CI/CD<a hidden class=anchor aria-hidden=true href=#전통적-개발-vs-cicd>#</a></h3><table><thead><tr><th>구분</th><th>전통적 개발</th><th>CI/CD</th></tr></thead><tbody><tr><td><strong>배포 주기</strong></td><td>월간/분기별</td><td>시간/일 단위</td></tr><tr><td><strong>테스트 시점</strong></td><td>개발 완료 후 수동 테스트</td><td>코드 커밋 시 자동 테스트</td></tr><tr><td><strong>장애 대응</strong></td><td>수동 롤백</td><td>자동 롤백</td></tr><tr><td><strong>협업 방식</strong></td><td>개발/운영 팀 분리</td><td>DevOps 문화 기반 통합 팀</td></tr><tr><td><strong>보안</strong></td><td>배포 후 검증</td><td>파이프라인 내 보안 검사 (DevSecOps)</td></tr></tbody></table><h3 id=기존-수동-배포-vs-자동화된-cicd-비교>기존 수동 배포 Vs 자동화된 CI/CD 비교<a hidden class=anchor aria-hidden=true href=#기존-수동-배포-vs-자동화된-cicd-비교>#</a></h3><table><thead><tr><th>항목</th><th>기존 수동 배포</th><th>자동화된 CI/CD</th></tr></thead><tbody><tr><td><strong>배포 소요 시간</strong></td><td>수 시간 ~ 수 일</td><td>수 분 ~ 수 십 분</td></tr><tr><td><strong>배포 빈도</strong></td><td>주간/월간/분기별</td><td>일간/시간별/커밋별</td></tr><tr><td><strong>오류 발생률</strong></td><td>높음 (수동 단계로 인한 휴먼 에러)</td><td>낮음 (자동화로 일관성 유지)</td></tr><tr><td><strong>롤백 시간</strong></td><td>오래 걸림 (복잡한 수동 절차)</td><td>빠름 (자동화된 롤백 메커니즘)</td></tr><tr><td><strong>운영 부담</strong></td><td>릴리즈 기간 동안 높은 스트레스</td><td>지속적인 소규모 변경으로 부담 분산</td></tr><tr><td><strong>지식 전파</strong></td><td>특정 인원에 의존적</td><td>자동화된 파이프라인으로 지식 공유</td></tr><tr><td><strong>작업 추적성</strong></td><td>제한적 (수동 로그 및 문서)</td><td>높음 (자동화된 로그 및 감사 추적)</td></tr><tr><td><strong>리소스 활용</strong></td><td>비효율적 (배포 준비 및 대기 시간)</td><td>효율적 (자동화된 리소스 할당)</td></tr><tr><td><strong>품질 보증</strong></td><td>릴리즈 전 집중적 QA</td><td>지속적인 자동화된 테스트</td></tr><tr><td><strong>사용자 피드백</strong></td><td>늦은 피드백 (대규모 릴리즈 후)</td><td>빠른 피드백 (작은 변경에 대한 반응)</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>CI(Continuous Integration)</td><td>개발자들이 코드 변경사항을 중앙 저장소에 자주 통합하고 자동화된 빌드와 테스트를 실행하는 소프트웨어 개발 방식</td></tr><tr><td>CD(Continuous Delivery)</td><td>소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하도록 자동화하는 방법론</td></tr><tr><td>CD(Continuous Deployment)</td><td>코드 변경이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식</td></tr><tr><td>DevOps</td><td>개발 (Development) 과 운영 (Operations) 을 통합하여 소프트웨어 개발과 배포 과정을 개선하는 문화와 방법론</td></tr><tr><td>파이프라인 (Pipeline)</td><td>코드 변경부터 프로덕션 배포까지 일련의 자동화된 단계</td></tr><tr><td>IaC(Infrastructure as Code)</td><td>인프라스트럭처 구성을 코드로 관리하는 방식</td></tr><tr><td>GitOps</td><td>Git 을 중심으로 인프라와 애플리케이션 배포를 관리하는 방식</td></tr><tr><td>테스트 자동화 (Test Automation)</td><td>소프트웨어 테스트 과정을 자동화하여 일관성과 효율성을 높이는 방식</td></tr><tr><td>카나리 배포 (Canary Deployment)</td><td>일부 사용자에게만 새 버전을 배포하여 위험을 최소화하는 전략</td></tr><tr><td>블루 - 그린 배포 (Blue-Green Deployment)</td><td>두 개의 동일한 프로덕션 환경을 번갈아 가며 배포하는 전략</td></tr><tr><td>피처 플래그 (Feature Flag)</td><td>코드 배포와 기능 활성화를 분리하여 위험을 관리하는 기술</td></tr><tr><td>DevSecOps</td><td>개발, 보안, 운영을 통합하여 보안을 소프트웨어 개발 초기 단계부터 고려하는 접근법</td></tr><tr><td>통합 지옥 (Integration Hell)</td><td>오래 분리된 코드 브랜치를 통합할 때 발생하는 복잡한 충돌과 문제 상황</td></tr><tr><td>워터폴 모델 (Waterfall Model)</td><td>순차적으로 진행되는 전통적인 소프트웨어 개발 방법론</td></tr><tr><td>익스트림 프로그래밍 (XP, Extreme Programming)</td><td>지속적 통합, 테스트 주도 개발 등을 포함하는 애자일 소프트웨어 개발 방법론</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.redhat.com/ko/topics/devops/what-is-ci-cd>Red Hat CI/CD 설명</a></li><li><a href=https://www.testaify.com/blog/a-comprehensive-history-of-cicd>Testaify CI/CD 역사</a></li><li><a href=https://www.linkedin.com/pulse/top-7-cicd-pipeline-trends-2025-kairos-technologies-inc-fcuuc>2025 CI/CD 트렌드(Kairos Technologies)</a></li><li><a href=https://www.atlassian.com/continuous-delivery/principles/history-of-ci-cd>Atlassian: CI/CD의 역사</a></li><li><a href=https://thenewstack.io/a-brief-history-of-ci-cd/>The New Stack: CI/CD 발전 과정</a></li><li><a href=https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html>AWS CodePipeline 개념 문서</a></li><li><a href=https://docs.gitlab.com/ee/ci/introduction/>GitLab CI/CD 개요</a></li><li><a href=https://www.jenkins.io/solutions/pipelines/>Jenkins Pipeline 설명</a></li><li><a href=https://martinfowler.com/articles/continuousIntegration.html>마틴 파울러의 지속적 통합 설명</a></li><li><a href=https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment>Atlassian의 CI, CD, 배포 비교 가이드</a></li><li><a href=https://www.redhat.com/en/topics/devops/what-is-ci-cd>RedHat의 CI/CD 개요</a></li><li><a href=https://github.com/resources/articles/devops/ci-cd>GitHub의 CI/CD 리소스</a></li><li><a href=https://circleci.com/blog/a-brief-history-of-devops-part-iii-automated-testing-and-continuous-integration/>CircleCI의 DevOps 역사 시리즈</a></li><li><a href=https://devops.com/waterfall-and-agile/>DevOps.com의 워터폴과 애자일 분석</a></li><li><a href=https://cloudnativenow.com/topics/continuous-evolution-the-ci-cd-story/>Cloud Native Now의 CI/CD 진화</a></li><li><a href=https://www.clearlyagile.com/agile-blog/continuous-integration-and-deployment-best-practices>Clearly Agile의 CI/CD 모범 사례</a></li><li><a href=https://www.ibm.com/think/topics/ci-cd-pipeline>IBM의 CI/CD 파이프라인 설명</a></li><li><a href=https://www.crowdstrike.com/en-us/cybersecurity-101/cloud-security/continuous-integration-continuous-delivery-ci-cd/>CrowdStrike의 CI/CD 구성요소 및 도구</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd/>CI-CD</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd-fundamentals/>CI-CD-Fundamentals</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/system-software/operating-systems/process-management/process-concepts/context-switch/context-switching/><span class=title>« Prev</span><br><span>Context Switching</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/system-software/operating-systems/memory-management/virtual-memory/paging-systems/paging/><span class=title>Next »</span><br><span>페이징 (Paging)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>