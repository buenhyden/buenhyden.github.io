<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YAGNI Principle | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,YAGNI-Principle"><meta name=description content='YAGNI 는 "You Ain&#39;t Gonna Need It" 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="YAGNI Principle"><meta property="og:description" content='YAGNI 는 "You Ain&#39;t Gonna Need It" 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="YAGNI Principle"><meta name=twitter:description content='YAGNI 는 "You Ain&#39;t Gonna Need It" 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":6,"name":"YAGNI Principle","item":"https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>YAGNI Principle</h1><div class=post-description>YAGNI 는 &ldquo;You Ain&rsquo;t Gonna Need It&rdquo; 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.</div></header><div class=post-content><h2 id=yagniyou-aint-gonna-need-it-principle>YAGNI(You Ain&rsquo;t Gonna Need It) Principle<a hidden class=anchor aria-hidden=true href=#yagniyou-aint-gonna-need-it-principle>#</a></h2><p>YAGNI(You Ain&rsquo;t Gonna Need It) 는 소프트웨어 개발에서 불필요한 기능을 미리 구현하지 말라는 원칙으로 과도한 엔지니어링을 방지하고 현재 요구사항에 집중하도록 가이드한다. 이 원칙은 개발자가 실제로 필요하지 않은 기능을 미리 만들지 않음으로써 복잡성을 줄이고, 유지보수성을 향상시키며, 개발 효율성을 높이는 데 중점을 둔다. YAGNI 는 애자일 개발 방법론과 밀접한 관련이 있으며, 최소한의 기능으로 빠른 피드백과 반복적 개선을 가능하게 한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>YAGNI(You Ain&rsquo;t Gonna Need It)</strong> 는 실제로 필요하지 않은 기능을 미리 구현하지 말라는 소프트웨어 개발 원칙이다. 실제 필요에 기반하여 기능을 구현하고 과도한 설계 및 기능 추가를 지양함으로써 개발 효율성을 높이고, 유지보수를 용이하게 하며, 코드의 간결성을 유지하는 것을 목적으로 한다.</p><p>1990 년대 후반 켄트 벡 (Kent Beck), 워드 커닝햄 (Ward Cunningham), 론 제프리스 (Ron Jeffries) 에 의해 개발된 익스트림 프로그래밍 (XP) 에서 탄생했다. 이 원칙은 C3 프로젝트에서 켄트 벡과 체트 헨드릭슨 간의 대화에서 유래되었으며, 당시 소프트웨어 엔지니어링에서 중시되던 세심한 사전 계획과는 대조적인 접근법이다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ul><li><strong>추정적 기능 (Presumptive Features)</strong>: 미래에 필요할 것으로 예상하여 미리 구현하는 기능</li><li><strong>Simple Design</strong>: 현재 요구사항을 만족하는 가장 단순한 설계</li><li><strong>Just-In-Time Development</strong>: 필요한 시점에 정확히 기능을 개발하는 접근법</li></ul><h4 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h4><ul><li><strong>기회비용 (Opportunity Cost)</strong>: 불필요한 기능 개발로 인해 포기하는 다른 가치 있는 작업</li><li><strong>기술적 부채 (Technical Debt)</strong>: 잘못 예측된 기능으로 인한 장기적 유지보수 비용</li><li><strong>진화적 설계 (Evolutionary Design)</strong>: 요구사항 변화에 따라 점진적으로 발전하는 설계 방식</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>YAGNI 원칙의 주요 목적:</p><ol><li><strong>개발 효율성 극대화</strong>: 불필요한 작업을 피함으로써 개발자 생산성과 제품 단순성을 향상시킨다.</li><li><strong>자원 최적화</strong>: 시간, 비용, 인력 등 제한된 자원을 현재 필요한 기능에 집중한다.</li><li><strong>복잡성 관리</strong>: 예측 기반의 과도한 엔지니어링을 방지하여 시스템 복잡성을 감소시킨다.</li><li><strong>애자일 가치 실현</strong>: 가치를 빠르게 전달하고 변화하는 요구사항에 대응한다.</li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p>YAGNI 가 수행하는 핵심 기능:</p><ul><li><strong>우선순위 가이드</strong>: 현재 필요한 기능과 미래 예상 기능 간의 명확한 구분</li><li><strong>의사결정 프레임워크</strong>: 기능 구현 여부 결정을 위한 체계적 접근법</li><li><strong>복잡성 제어</strong>: 불필요한 추상화와 일반화 방지</li><li><strong>품질 향상</strong>: 현재 요구사항에 집중함으로써 개발자가 더 작은 작업에 집중하여 코드 품질 향상</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><strong>예방적 성격</strong>: 과도한 엔지니어링을 사전에 방지</li><li><strong>점진적 접근</strong>: 요구사항 변화에 따른 단계적 기능 확장</li><li><strong>실용주의</strong>: 이론보다는 실제 필요성을 우선시</li><li><strong>애자일 철학</strong>: 변화에 대한 대응력과 적응력 강조</li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>YAGNI 는 다음과 같은 원칙을 기반으로 한다:</p><ul><li><strong>현재 필요성에 집중:</strong> 실제 요구사항에 기반한 기능만을 구현한다.</li><li><strong>과도한 설계 방지:</strong> 미래의 불확실한 요구사항에 대비한 과도한 설계를 지양한다.</li><li><strong>지속적인 리팩토링:</strong> 필요에 따라 코드를 지속적으로 개선한다.</li></ul><p>YAGNI 의 작동 메커니즘을 보여주는 워크플로우:</p><table><thead><tr><th></th><th>기능 및 역할</th></tr></thead><tbody><tr><td>요구사항 분석</td><td>현재 필요한 기능을 식별합니다.</td></tr><tr><td>기능 구현</td><td>식별된 기능만을 구현합니다.</td></tr><tr><td>테스트 및 배포</td><td>구현된 기능을 테스트하고 배포합니다.</td></tr><tr><td>피드백 수집</td><td>사용자로부터 피드백을 수집하여 개선합니다.</td></tr><tr><td>리팩토링</td><td>필요에 따라 코드를 개선합니다.</td></tr></tbody></table><pre class=mermaid>flowchart TD
    A[새로운 기능 요청/아이디어] --&gt; B{현재 필요한가?}
    B --&gt;|Yes| C[사용자 스토리 확인]
    B --&gt;|No| D[백로그에 추가하고 대기]
    
    C --&gt; E{구체적 요구사항 존재?}
    E --&gt;|Yes| F[기능 구현]
    E --&gt;|No| G[요구사항 명확화]
    
    F --&gt; H[테스트 및 배포]
    G --&gt; I[이해관계자와 협의]
    I --&gt; E
    
    D --&gt; J[정기적 백로그 검토]
    J --&gt; K{우선순위 변경?}
    K --&gt;|Yes| B
    K --&gt;|No| D
    
    H --&gt; L[사용자 피드백 수집]
    L --&gt; M[다음 기능 계획]
</pre><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>기법 분류</th><th>기법명</th><th>정의 및 구성</th><th>목적</th><th>실무 적용 예</th></tr></thead><tbody><tr><td><strong>요구사항 분류</strong></td><td>기능 분류 기법 (Feature Classification)</td><td>Must/Should/Could/Won&rsquo;t-Have 로 요구사항을 분류하여 현재 필요한 기능만 구현</td><td>우선순위 명확화 및 자원 집중</td><td>사용자 등록: Must-Have / 다국어 지원: Could-Have</td></tr><tr><td><strong>설계 전략</strong></td><td>점진적 설계 (Incremental Design)</td><td>단순 구조 → 기능 확장 → 리팩토링 → 최적화 순으로 설계 발전</td><td>변화 대응력 확보 및 초기 복잡도 최소화</td><td>기본 로그인 → 구글 로그인 → 2FA 단계적 추가</td></tr><tr><td><strong>코드 관리</strong></td><td>지속적 리팩토링 (Continuous Refactoring)</td><td>코드 품질 모니터링 → 리팩토링 타이밍 판단 → 안전하게 구조 개선</td><td>유지보수성 향상 및 기술 부채 방지</td><td>중복 코드 제거, 모듈화 진행</td></tr><tr><td><strong>개발 절차</strong></td><td>작은 단위 개발 (Small Incremental Development)</td><td>최소 기능 단위로 쪼개서 개발하고 검증 후 확장</td><td>빠른 피드백과 리스크 최소화</td><td>API 단위로 기능 구현 및 배포</td></tr><tr><td><strong>테스트 전략</strong></td><td>테스트 주도 개발 (TDD, Test-Driven Development)</td><td>테스트 → 구현 → 리팩토링 순으로 기능을 정제하며 개발</td><td>필요한 기능만 테스트하며 품질 확보</td><td>사용자 생성 API 테스트 코드 우선 작성</td></tr><tr><td><strong>배포 전략</strong></td><td>지속적 통합 (CI, Continuous Integration)</td><td>변경사항을 즉시 병합하고 테스트 자동화</td><td>불필요한 기능 추가 방지 및 통합 문제 최소화</td><td>GitHub Actions, Jenkins 등을 활용한 자동화</td></tr><tr><td><strong>개발 문화</strong></td><td>애자일 개발 프로세스</td><td>짧은 반복과 빠른 피드백 루프 중심의 협업 방식</td><td>실질적 가치 중심 개발, 요구 변화 수용</td><td>스프린트 단위의 계획 및 리뷰 운영</td></tr></tbody></table><h4 id=구현-가이드>구현 가이드<a hidden class=anchor aria-hidden=true href=#구현-가이드>#</a></h4><h5 id=기능-분류-기법-feature-classification>기능 분류 기법 (Feature Classification)<a hidden class=anchor aria-hidden=true href=#기능-분류-기법-feature-classification>#</a></h5><p><strong>정의</strong>: 요구사항을 현재 필요성에 따라 분류하는 방법<br><strong>구성</strong>:</p><ul><li>Must-Have (필수): 현재 반드시 필요한 기능</li><li>Should-Have (권장): 중요하지만 지연 가능한 기능</li><li>Could-Have (선택): 있으면 좋은 기능</li><li>Won&rsquo;t-Have (제외): 이번 릴리스에서 제외할 기능<br><strong>목적</strong>: 개발 우선순위 명확화 및 자원 최적 배분<br><strong>예시</strong>:</li><li>도구<ul><li>협업 도구: Jira, Notion, Trello</li><li>문서 포맷: MoSCoW 또는 RICE 방식 우선순위<br>스타트업 MVP 단계에서:</li></ul></li><li><code>Must</code>: 사용자 회원가입, 로그인</li><li><code>Should</code>: 이메일 인증</li><li><code>Could</code>: 다크모드, 다국어 지원</li><li><code>Won’t</code>: 추천 알고리즘, 관리자 통계</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-md data-lang=md><span class=line><span class=cl>🔹 기능 정리 (Notion 예시)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[Must-Have]
</span></span><span class=line><span class=cl><span class=k>-</span> 사용자 회원가입 / 로그인
</span></span><span class=line><span class=cl><span class=k>-</span> 상품 목록 조회
</span></span><span class=line><span class=cl><span class=k>-</span> 장바구니 담기
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[Should-Have]
</span></span><span class=line><span class=cl><span class=k>-</span> 이메일 인증
</span></span><span class=line><span class=cl><span class=k>-</span> 쿠폰 적용
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[Could-Have]
</span></span><span class=line><span class=cl><span class=k>-</span> 다국어 지원
</span></span><span class=line><span class=cl><span class=k>-</span> 어두운 테마 UI
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[Won’t-Have]
</span></span><span class=line><span class=cl><span class=k>-</span> 사용자 추천 알고리즘 (다음 릴리스로 이동)
</span></span></code></pre></td></tr></table></div></div><h5 id=점진적-설계-incremental-design>점진적 설계 (Incremental Design)<a hidden class=anchor aria-hidden=true href=#점진적-설계-incremental-design>#</a></h5><p><strong>정의</strong>: 요구사항 변화에 따라 단계적으로 설계를 발전시키는 방법<br><strong>구성</strong>: 기본 구조 → 기능 확장 → 리팩토링 → 최적화<br><strong>목적</strong>: 변화에 유연하게 대응하면서 복잡성 최소화<br><strong>예시</strong>:</p><ul><li>기술 스택<ul><li>Node.js, Express</li><li>MongoDB (Mongoose)</li></ul></li><li>코드 예시<ol><li><p>1 단계: 기본 로그인</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=c1>// services/authService.ts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>AuthService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=nx>login</span><span class=p>(</span><span class=nx>email</span>: <span class=kt>string</span><span class=p>,</span> <span class=nx>password</span>: <span class=kt>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Promise</span><span class=p>&lt;</span><span class=nt>string</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>UserModel</span><span class=p>.</span><span class=nx>findOne</span><span class=p>({</span> <span class=nx>email</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>user</span> <span class=o>||</span> <span class=o>!</span><span class=p>(</span><span class=k>await</span> <span class=nx>bcrypt</span><span class=p>.</span><span class=nx>compare</span><span class=p>(</span><span class=nx>password</span><span class=p>,</span> <span class=nx>user</span><span class=p>.</span><span class=nx>password</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Invalid credentials&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>generateToken</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=nx>generateToken</span><span class=p>(</span><span class=nx>user</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>jwt</span><span class=p>.</span><span class=nx>sign</span><span class=p>({</span> <span class=nx>id</span>: <span class=kt>user._id</span> <span class=p>},</span> <span class=nx>process</span><span class=p>.</span><span class=nx>env</span><span class=p>.</span><span class=nx>JWT_SECRET</span><span class=o>!</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>2 단계: 소셜 로그인 추가</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>async</span> <span class=nx>loginWithGoogle</span><span class=p>(</span><span class=nx>token</span>: <span class=kt>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Promise</span><span class=p>&lt;</span><span class=nt>string</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>googleUser</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>googleOAuth</span><span class=p>.</span><span class=nx>validate</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>user</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>UserModel</span><span class=p>.</span><span class=nx>findOne</span><span class=p>({</span> <span class=nx>email</span>: <span class=kt>googleUser.email</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>user</span><span class=p>)</span> <span class=nx>user</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>UserModel</span><span class=p>.</span><span class=nx>create</span><span class=p>({</span> <span class=nx>email</span>: <span class=kt>googleUser.email</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>generateToken</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>3 단계: 2FA 추가</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>async</span> <span class=nx>verify2FA</span><span class=p>(</span><span class=nx>userId</span>: <span class=kt>string</span><span class=p>,</span> <span class=nx>code</span>: <span class=kt>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Promise</span><span class=p>&lt;</span><span class=nt>boolean</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>twoFactorService</span><span class=p>.</span><span class=nx>verify</span><span class=p>(</span><span class=nx>userId</span><span class=p>,</span> <span class=nx>code</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol></li></ul><h5 id=지속적-리팩토링-continuous-refactoring>지속적 리팩토링 (Continuous Refactoring)<a hidden class=anchor aria-hidden=true href=#지속적-리팩토링-continuous-refactoring>#</a></h5><p><strong>정의</strong>: YAGNI 는 지속적 리팩토링과 함께 사용되어야 하며, 리팩토링 없이는 코드가 혼란스러워지고 대규모 재작업이 필요할 수 있다<br><strong>구성</strong>: 코드 품질 모니터링 → 리팩토링 시점 식별 → 안전한 리팩토링 실행<br><strong>목적</strong>: 코드베이스의 유연성과 유지보수성 확보<br><strong>예시</strong>:</p><ul><li><p>도구</p><ul><li>ESLint + Prettier</li><li>SonarQube / SonarCloud</li><li>GitHub Actions CI</li></ul></li><li><p>리팩토링 전 (before)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>class</span> <span class=nx>UserService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=nx>registerAndSendWelcome</span><span class=p>(</span><span class=nx>user</span>: <span class=kt>User</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// DB 저장, 이메일 전송, 알림 생성 모두 포함 (SRP 위반)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>리팩토링 후 (after)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>class</span> <span class=nx>UserService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=nx>register</span><span class=p>(</span><span class=nx>user</span>: <span class=kt>User</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>userRepo</span><span class=p>.</span><span class=nx>save</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>welcomeMailer</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>email</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>notifier</span><span class=p>.</span><span class=nx>notify</span><span class=p>(</span><span class=nx>user</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=s1>&#39;Welcome!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h5 id=작은-단위-개발-small-incremental-development>작은 단위 개발 (Small Incremental Development)<a hidden class=anchor aria-hidden=true href=#작은-단위-개발-small-incremental-development>#</a></h5><p><strong>정의</strong>: 기능을 <strong>작고 독립적인 단위</strong>로 나누어 순차적으로 개발하고 배포하는 방식. 전체 시스템을 한 번에 구축하는 것이 아니라, 핵심 기능부터 단계적으로 구현한다.<br><strong>구성</strong>:</p><ul><li>기능 단위로 업무 분할 (Feature slicing)</li><li>독립 가능한 기능별 개발 및 배포</li><li>반복적 개발 → 테스트 → 통합</li><li>Feature Toggle 또는 Branch 기반 개발 전략<br><strong>목적</strong>:</li><li>리스크 최소화: 전체 실패를 방지하고, 문제 발생 시 범위를 좁힘</li><li>빠른 피드백 확보: QA 및 사용자로부터 조기 반응 가능</li><li>고객 가치 중심 개발: 우선순위 높은 기능부터 제공</li><li>점진적 개선 및 확장 가능<br><strong>예시</strong>:</li><li>도구<ul><li>Git Flow</li><li>PR 기반 개발</li><li>Feature Flags (LaunchDarkly, 자체 구현)</li></ul></li><li>실무 시나리오<ul><li><code>/api/orders/create</code> → 완료 후 배포</li><li><code>/api/orders/list</code> → 이후 추가</li><li><code>/api/orders/pay</code> → 결제 시스템 준비되면 확장</li></ul></li></ul><h5 id=테스트-주도-개발-tdd>**테스트 주도 개발 (TDD)<a hidden class=anchor aria-hidden=true href=#테스트-주도-개발-tdd>#</a></h5><p><strong>정의</strong>: <strong>테스트를 먼저 작성하고</strong>, 그 테스트를 만족시키는 코드를 구현한 다음, 코드 품질을 개선 (리팩토링) 하는 개발 방식이다.</p><blockquote><p>순서: ✅ 실패하는 테스트 작성 → ✅ 최소한의 코드 작성 → ✅ 테스트 통과 → ✅ 리팩토링</p></blockquote><p><strong>구성</strong>:</p><ul><li><p>단위 테스트 (Unit Test) 프레임워크 (예: Jest, JUnit, Pytest)</p></li><li><p>Mocking/Stubbing 도구 (예: Sinon, Mockito)</p></li><li><p>코드 커버리지 측정 도구</p></li><li><p>리팩토링 및 코드 품질 분석 도구<br><strong>목적</strong>:</p></li><li><p>과잉 구현 방지 (YAGNI 실현)</p></li><li><p>코드의 신뢰성과 유지보수성 향상</p></li><li><p>명세 기반 개발 → 요구사항에 충실</p></li><li><p>빠른 회귀 테스트 및 오류 조기 발견<br><strong>예시</strong>:</p></li><li><p>도구</p><ul><li>Jest (유닛 테스트)</li><li>Supertest (API 테스트)</li><li>Coverage 도구: <code>jest --coverage</code></li></ul></li><li><p>테스트 먼저 작성</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=c1>// __tests__/auth.test.ts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>it</span><span class=p>(</span><span class=s1>&#39;should login with valid credentials&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>res</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>request</span><span class=p>(</span><span class=nx>app</span><span class=p>).</span><span class=nx>post</span><span class=p>(</span><span class=s1>&#39;/api/login&#39;</span><span class=p>).</span><span class=nx>send</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>email</span><span class=o>:</span> <span class=s1>&#39;test@example.com&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>password</span><span class=o>:</span> <span class=s1>&#39;password123&#39;</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>res</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>token</span><span class=p>).</span><span class=nx>toBeDefined</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>기능 구현</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>post</span><span class=p>(</span><span class=s1>&#39;/api/login&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>authService</span><span class=p>.</span><span class=nx>login</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>email</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>password</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>res</span><span class=p>.</span><span class=nx>json</span><span class=p>({</span> <span class=nx>token</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h5 id=지속적-통합-cicontinuous-integration>지속적 통합 (CI–Continuous Integration)<a hidden class=anchor aria-hidden=true href=#지속적-통합-cicontinuous-integration>#</a></h5><p><strong>정의</strong>: 개발자들이 변경한 코드를 <strong>공용 저장소에 자주 병합</strong>하고, 병합 시마다 <strong>자동 빌드 및 테스트</strong>를 수행하는 프로세스이다.<br><strong>구성</strong>:</p><ul><li><p>소스 코드 저장소 (Git, GitHub, GitLab 등)</p></li><li><p>자동화된 테스트 실행 (Jest, Mocha, Cypress 등)</p></li><li><p>CI 서버 및 파이프라인 (GitHub Actions, GitLab CI, Jenkins 등)</p></li><li><p>Lint, Code Quality, Coverage 측정 도구</p></li><li><p>알림 시스템 (Slack, Email 등)<br><strong>목적</strong>:</p></li><li><p>병합 충돌 및 통합 오류 조기 발견</p></li><li><p>테스트 자동화를 통한 품질 확보</p></li><li><p>배포 속도 향상</p></li><li><p>YAGNI 방지: 불필요한 기능이 CI 에서 검증되지 않으면 자동으로 걸러짐<br><strong>예시</strong>:</p></li><li><p>도구</p><ul><li>GitHub Actions (or GitLab CI, Jenkins)</li><li>ESLint, Test, Coverage 자동화</li></ul></li><li><p><code>.github/workflows/ci.yml</code> 예시</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>CI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install deps</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>npm install</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Lint</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>npm run lint</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>npm run test -- --coverage</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h5 id=애자일-개발-프로세스>애자일 개발 프로세스<a hidden class=anchor aria-hidden=true href=#애자일-개발-프로세스>#</a></h5><p><strong>정의</strong>: 계획보다 <strong>빠른 실행과 고객 피드백</strong>을 중심으로 한 소프트웨어 개발 프로세스. 작은 단위의 반복 (Iteration) 을 통해 <strong>지속적인 개선</strong>과 <strong>가치 중심 개발</strong>을 추구한다.<br><strong>구성</strong>:</p><ul><li>스프린트 (Sprint): 짧은 개발 반복 주기 (보통 1~2 주)</li><li>스크럼 미팅: 데일리 스탠드업, 스프린트 플래닝, 리뷰, 회고</li><li>백로그 관리: Product Backlog / Sprint Backlog</li><li>우선순위 기반 개발 (MoSCoW, RICE 등)</li><li>고객과의 긴밀한 협업<br><strong>목적</strong>:</li><li>빠른 요구사항 반영과 유연한 변경 대응</li><li>고객 중심의 제품 개발</li><li>팀 간 커뮤니케이션 강화</li><li>점진적인 기능 제공으로 가치 실현<br><strong>예시</strong>:</li><li>도구<ul><li>Jira, Linear, Trello</li><li>Slack + GitHub 알림</li><li>GitHub Projects</li></ul></li><li>실무 적용 (2 주 스프린트 기준)<ul><li><strong>1 일차</strong>: 요구사항 분석 + 우선순위 분류</li><li><strong>2~8 일차</strong>: 기능 개발 + 코드 리뷰 + 테스트</li><li><strong>9 일차</strong>: QA 테스트 및 피드백 반영</li><li><strong>10 일차</strong>: 배포 및 회고</li></ul></li></ul><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td><strong>개발 효율성 향상</strong></td><td>반드시 필요한 기능에만 집중하여 개발 속도와 집중도가 향상됨</td></tr><tr><td></td><td><strong>비용 절감</strong></td><td>설계, 개발, 유지보수 과정에서 과잉 구현으로 인한 리소스 낭비를 줄임</td></tr><tr><td></td><td><strong>코드 간결성</strong></td><td>단순하고 명확한 코드 구조를 유지하여 이해 및 협업이 쉬움</td></tr><tr><td></td><td><strong>유지보수 용이성</strong></td><td>코드가 작고 목적이 명확하여 리팩토링과 기능 확장이 쉬움</td></tr><tr><td></td><td><strong>빠른 제품 출시</strong></td><td>MVP(Minimum Viable Product) 중심 개발로 시장에 빠르게 진입 가능</td></tr><tr><td></td><td><strong>변화 적응성 향상</strong></td><td>기능이 경량화되어 새로운 요구사항에도 유연하게 대응 가능</td></tr><tr><td></td><td><strong>테스트 범위 최소화</strong></td><td>구현된 기능이 적으므로 테스트 범위도 축소되어 QA 비용 절감</td></tr><tr><td></td><td><strong>고객 피드백 중심 개발 유도</strong></td><td>실제 사용자 피드백을 기반으로 기능을 채택/배제하는 구조 촉진</td></tr><tr><td>⚠ 단점</td><td><strong>미래 요구 대응 부족</strong></td><td>장기적인 확장성이나 재사용성을 고려하지 않을 경우, 재설계 비용 증가 가능</td></tr><tr><td></td><td><strong>재작업 비용 발생</strong></td><td>기능이 새로 필요해졌을 때 처음부터 다시 구현해야 할 수 있음</td></tr><tr><td></td><td><strong>기술적 부채 누적</strong></td><td>리팩토링 없이 반복적으로 단기 코드만 쌓일 경우 구조가 쉽게 무너짐</td></tr><tr><td></td><td><strong>기능 누락 위험</strong></td><td>초기 정의가 부족할 경우, 사용자 입장에서 중요한 기능이 빠질 수 있음</td></tr><tr><td></td><td><strong>설계 난이도 증가</strong></td><td>&rsquo; 당장 필요한 것만 &rsquo; 설계하려다 전체 흐름을 파악하지 못할 수 있음</td></tr><tr><td></td><td><strong>오용 가능성</strong></td><td>&ldquo;YAGNI&rdquo; 라는 명분으로 품질, 보안, 유연성을 희생할 수 있음</td></tr><tr><td></td><td><strong>팀 간 협업 장애</strong></td><td>각자 기능 구현에만 집중하다보면, 시스템 통합 시 충돌이나 중복 발생 가능</td></tr><tr><td></td><td><strong>의사결정 부담 증가</strong></td><td>어떤 기능이 &rsquo; 필요한가 &rsquo; 아닌가에 대한 판단이 반복적으로 요구됨</td></tr></tbody></table><ul><li><strong>장점</strong>은 빠른 속도, 단순한 구조, 유지보수 용이성, 비용 절감 등 <strong>실행 효율성 중심</strong></li><li><strong>단점</strong>은 미래 변화 대응, 품질 관리, 설계 판단 등 <strong>장기적 안정성과 확장성 관련 위험</strong></li></ul><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>이해관계자 저항</strong></td><td>경영진, 기획자 등이 미래 기능을 미리 구현하길 원함</td><td>- 추측성 개발의 리스크와 비용을 수치로 설명<br>- 사용자 피드백 중심 개발의 장점 강조<br>- 프로토타입이나 A/B 테스트를 통한 우선 검증 제안</td></tr><tr><td><strong>규제 및 보안 요구사항</strong></td><td>금융, 의료 등 분야에서 YAGNI 보다 규제가 우선</td><td>- 규제 요구사항은 &rsquo; 현재 요구사항 &rsquo; 으로 간주하여 구현<br>- 나머지 일반 기능에는 YAGNI 원칙 적용<br>- 보안과 컴플라이언스는 예외 대상임을 명확히 구분</td></tr><tr><td><strong>잘못된 해석</strong></td><td>YAGNI 를 핑계로 아키텍처, 모듈화, 테스트를 무시</td><td>- YAGNI 는 내부 품질을 포기하는 개념이 아님을 교육<br>- SOLID, 클린 아키텍처 원칙과 함께 적용<br>- 최소한의 설계 원칙은 반드시 유지</td></tr><tr><td><strong>실제 필요 판단의 어려움</strong></td><td>어떤 기능이 &rsquo; 현재 필요한가 &rsquo; 를 명확히 정의하기 어려움</td><td>- 고객과의 협업, 요구사항 워크숍, 유저스토리 맵 활용<br>- 제품 목표와 핵심 지표 (KPI) 기반 우선순위 수립</td></tr><tr><td><strong>미래 요구사항 대응 부족</strong></td><td>변화 시 큰 리팩토링이나 재작업이 필요할 수 있음</td><td>- 변화가 잦은 모듈에 한해 확장 가능성 염두에 둔 설계<br>- 리팩토링 주기 관리 및 기술 부채 점검 자동화 도입</td></tr><tr><td><strong>팀 간 의사소통 문제</strong></td><td>기능 범위나 적용 여부에 대한 합의 부족</td><td>- 정의된 개발 원칙 문서화 (Coding Guideline + YAGNI 범위 포함)<br>- 피어 리뷰, 설계 리뷰를 통해 정기적으로 조율</td></tr><tr><td><strong>문화적 저항 및 책임 회피</strong></td><td>" 나중에 문제 생기면 책임은 누가?" 라는 태도</td><td>- 실험적 접근을 장려하는 조직 문화 조성<br>- 린 (Lean) 사고방식 기반 MVP 문화 도입<br>- 실패 가능한 구조와 회고 문화 내재화</td></tr><tr><td><strong>과도한 단순화 위험</strong></td><td>핵심 기능조차 누락되어 제품 가치 저하 가능</td><td>- 기능 단위로 고객 가치 기반 명확한 분류 수행<br>- 핵심 기능 정의 시 사용자 여정 (Journey) 기반 검토</td></tr><tr><td><strong>기술 스택 또는 도구의 제약</strong></td><td>CI/CD, 테스트 자동화 미흡 시 적용이 어려움</td><td>- CI/CD, 테스트 자동화는 YAGNI 실천 기반 도구로 도입<br>- Lint, 테스트, 커버리지 도구를 기본 개발 환경에 내장</td></tr><tr><td><strong>지속적인 판단 피로</strong></td><td>기능마다 " 이게 지금 필요한가?" 판단 부담이 누적</td><td>- 공통 판단 기준 문서화<br>- 의사결정 매트릭스 (예: RICE, MoSCoW) 도입<br>- 도메인 전문가 참여를 통한 판단 보조</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류 / 유형</th><th>설명</th><th>적용 사례</th><th>주의사항</th></tr></thead><tbody><tr><td><strong>적용 범위</strong></td><td>기능 수준 YAGNI</td><td>개별 기능 단위로 구현 여부를 판단</td><td>로그인 기능만 구현, 소셜 로그인은 추후</td><td>필수 기능까지 누락하지 않도록 요구분석 필요</td></tr><tr><td></td><td>아키텍처 수준 YAGNI</td><td>시스템 설계 시 확장성보다는 현재 요구 중심 구조</td><td>단일 인스턴스로 배포, 멀티 리전에 대한 고려는 나중</td><td>너무 단순하게 설계하면 확장 시 재작업 많아짐</td></tr><tr><td></td><td>프로젝트 수준 YAGNI</td><td>전체 프로젝트 로드맵 상 기능 우선순위 결정에 적용</td><td>MVP 에 필요한 기능만 개발</td><td>고객 기대 수준과의 괴리 발생 가능성 존재</td></tr><tr><td><strong>시간 기준</strong></td><td>단기 YAGNI</td><td>당장 이번 스프린트에 필요한 기능만 구현</td><td>스프린트 내 사용자 등록 기능만 우선 개발</td><td>매 이터레이션마다 판단 기준 정비 필요</td></tr><tr><td></td><td>중기 YAGNI</td><td>향후 1~3 개월 내 필요 기능만 고려</td><td>계정 관련 기능만 우선, 알림/통계는 다음 분기</td><td>일정 예측 정확도 부족 시 기능 누락 가능</td></tr><tr><td></td><td>장기 YAGNI</td><td>연간 로드맵 중 확정 기능에 한정 적용</td><td>백오피스 도구는 고객 유입 후에 구현</td><td>기술 부채가 누적되지 않도록 체크포인트 설정</td></tr><tr><td><strong>도메인</strong></td><td>비즈니스 YAGNI</td><td>사업 가치 없는 기능은 미구현</td><td>마케팅 자동화는 수익 구조 정착 후 개발</td><td>비즈니스 목표와 기능 우선순위 정렬 필요</td></tr><tr><td></td><td>기술 YAGNI</td><td>아직 필요하지 않은 기술 도입 보류</td><td>Redis, Kafka 등은 고도화 시점에 도입</td><td>성능 병목 예상 구간은 사전 대비 설계 필요</td></tr><tr><td></td><td>UI/UX YAGNI</td><td>시각적 요소와 보조 기능은 나중에 개발</td><td>다크모드, 접근성 보완 등은 2 차 릴리스로</td><td>사용자 경험을 해치지 않을 정도로만 단순화 필요</td></tr><tr><td><strong>실행 전략</strong></td><td>보수적 YAGNI</td><td>현재 확정된 기능 외에는 일절 구현하지 않음</td><td>스타트업 POC(Proof of Concept), 해커톤</td><td>미래 확장 대비 전혀 없는 구조는 기술 부채 유발</td></tr><tr><td></td><td>균형적 YAGNI</td><td>가까운 미래와 현재 기능을 균형 있게 적용</td><td>정식 제품 개발, SaaS 초기 버전</td><td>예외 사항에 대한 명확한 기준 필요</td></tr><tr><td></td><td>선택적 YAGNI</td><td>일부 도메인에만 원칙 적용</td><td>레거시 시스템에서 신규 모듈만 YAGNI 적용</td><td>시스템 일관성 유지가 어렵고 혼선 가능</td></tr></tbody></table><ul><li><strong>분류 기준</strong>은 총 4 가지: 적용 범위 / 시간 / 도메인 / 실행 전략</li><li>각 유형은 <strong>실행 효율성 vs 장기 확장성 사이의 균형</strong>을 어떻게 잡느냐에 따라 달라짐</li><li><strong>가장 추천되는 접근은 " 균형적 YAGNI"</strong>, 현실적인 개발 환경과 가장 잘 맞음</li></ul><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>시나리오 / 적용 분야</th><th>적용 방식</th><th>결과 및 효과</th><th>학습점</th></tr></thead><tbody><tr><td><strong>E- 커머스 플랫폼 초기 버전</strong></td><td>추천 알고리즘, AI 개인화 제거 → 핵심 기능 (상품, 장바구니, 결제) 만 구현</td><td>출시 기간 단축, 주요 트래픽 기능 안정 확보</td><td>사용자 데이터 확보 후 실제 사용 패턴 기반 개선이 효율적</td></tr><tr><td><strong>채팅 애플리케이션 MVP</strong></td><td>채팅 안정성 확보에 집중, 게임/테마/이모지 생략</td><td>단순하면서 빠른 UX 제공으로 이탈률 감소</td><td>핵심 사용자 경험에 집중하면 초기 만족도가 높아짐</td></tr><tr><td><strong>인증 시스템 단계적 확장</strong></td><td>이메일/비밀번호 방식으로 시작 → 이후 Google 로그인, 2FA 단계적 도입</td><td>초기 보안/속도 균형 확보, 점진적 신뢰성 확보</td><td>보안도 &rsquo; 기능 &rsquo; 처럼 단계적으로 설계할 수 있음</td></tr><tr><td><strong>스타트업 MVP 개발</strong></td><td>기능 목록 중 &rsquo; 시장 확인용 최소기능 &rsquo; 만 우선 개발 (예: 로그인 + 게시글 보기만)</td><td>고객 인터뷰 기반 다음 기능 결정 가능, 과잉 개발 방지</td><td>초기 고객과 기능 가설 검증을 빠르게 반복하는 것이 중요</td></tr><tr><td><strong>기능 개선 요청 대응</strong></td><td>피드백 받은 기능 중 실제 사용률 높은 것만 반영, 나머진 백로그로 이동</td><td>유지보수 부담 감소, 팀 리소스 최적화</td><td>기능 요청은 모두 구현하는 것이 아니라 &rsquo; 가치 &rsquo; 로 판단</td></tr><tr><td><strong>애자일 개발 프로세스</strong></td><td>스프린트마다 필요한 기능만 정의하여 짧은 개발 반복 수행</td><td>피드백 속도 향상, 릴리스 주기 안정화</td><td>YAGNI 는 애자일과 매우 궁합이 좋음 (Scope 관리 핵심)</td></tr><tr><td><strong>신규 웹 서비스 런칭</strong></td><td>관리자 기능, 통계 대시보드, 권한 관리 생략 → 사용자 중심 기능만 우선</td><td>빠른 런칭 및 운영 비용 절감</td><td>내부 기능은 유저 확보 후 개발해도 늦지 않음</td></tr><tr><td><strong>레거시 시스템 마이그레이션</strong></td><td>전면 재작성 대신 신규 모듈만 YAGNI 원칙 적용 (예: 결제 시스템만 리팩토링)</td><td>시스템 안정 유지하면서 점진적 전환 가능</td><td>선택적 적용 전략이 리스크 관리에 효과적</td></tr><tr><td><strong>B2B SaaS 솔루션 개발</strong></td><td>다중 고객 세분화 기능은 생략, 단일 고객 환경에 집중</td><td>단일 고객의 성공사례 확보 후 점진적 확장</td><td>고객 유치 전 기능 확장은 리스크가 큼</td></tr><tr><td><strong>모바일 앱 개발</strong></td><td>다크모드, 알림, 오프라인 캐시 등 부가기능은 후순위 처리</td><td>주요 흐름 (UI 플로우) 안정화와 출시 속도 향상</td><td>부가기능보다 플로우와 응답 속도가 사용자 만족의 핵심</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-스타트업에서-mvpminimum-viable-product-개발>사례 1: 스타트업에서 MVP(Minimum Viable Product) 개발<a hidden class=anchor aria-hidden=true href=#사례-1-스타트업에서-mvpminimum-viable-product-개발>#</a></h4><p><strong>시스템 구성</strong>:</p><ul><li>요구사항 관리 시스템</li><li>모듈화된 서비스 구조</li><li>CI/CD 파이프라인</li></ul><p><strong>시스템 구성 다이어그램</strong></p><pre class=mermaid>flowchart LR
  고객요구 --&gt; 요구관리
  요구관리 --&gt; 개발팀
  개발팀 --&gt; 최소기능구현
  최소기능구현 --&gt; 배포
  배포 --&gt; 피드백
  피드백 --&gt; 요구관리
</pre><p><strong>Workflow</strong>:</p><ol><li>고객 요구사항 접수</li><li>요구사항 관리자가 실제 필요한 기능만 선별</li><li>개발팀이 최소 기능만 구현</li><li>배포 후 피드백 수집 및 반복 개선</li></ol><p><strong>역할</strong>:</p><ul><li>요구사항 관리자: 기능 우선순위 결정</li><li>개발팀: 최소 기능 구현 및 반복 개선</li><li>고객: 피드백 제공</li></ul><h4 id=사례-2-온라인-쇼핑몰-개발>사례 2: 온라인 쇼핑몰 개발<a hidden class=anchor aria-hidden=true href=#사례-2-온라인-쇼핑몰-개발>#</a></h4><p><strong>시나리오</strong>: 온라인 쇼핑몰을 개발 중이며, 현재는 기본적인 상품 목록과 장바구니 기능만 필요하다.<br><strong>적용:</strong> YAGNI 원칙에 따라 회원 등급제, 추천 시스템 등의 부가 기능은 구현하지 않고, 기본 기능에 집중한다.<br><strong>결과:</strong> 빠른 시간 내에 기본 기능을 출시하여 사용자 피드백을 수집하고, 필요에 따라 추가 기능을 구현한다.</p><h4 id=사례-3-온라인-학습-플랫폼-개발>사례 3: 온라인 학습 플랫폼 개발<a hidden class=anchor aria-hidden=true href=#사례-3-온라인-학습-플랫폼-개발>#</a></h4><p><strong>시나리오</strong>: 한 스타트업이 온라인 학습 플랫폼을 개발한다. 초기 기획에서는 AI 기반 개인화 추천, VR 학습 환경, 블록체인 인증서 등 다양한 고급 기능을 고려했지만, YAGNI 원칙을 적용하여 단계적으로 접근했다.</p><p><strong>시스템 구성:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;1단계: MVP (최소 기능 제품)&#34;
        A[사용자 등록/로그인] --&gt; B[강의 목록 조회]
        B --&gt; C[동영상 재생]
        C --&gt; D[진도 추적]
        D --&gt; E[기본 결제]
    end
    
    subgraph &#34;2단계: 사용자 피드백 기반 확장&#34;
        F[퀴즈 기능] --&gt; G[토론 게시판]
        G --&gt; H[강사 도구]
        H --&gt; I[모바일 앱]
    end
    
    subgraph &#34;3단계: 데이터 기반 고도화&#34;
        J[학습 분석] --&gt; K[개인화 추천]
        K --&gt; L[라이브 스트리밍]
        L --&gt; M[인증서 발급]
    end
</pre><p><strong>활용 사례 Workflow:</strong></p><pre class=mermaid>sequenceDiagram
    participant PM as Product Manager
    participant Dev as Development Team
    participant User as Users
    participant Data as Analytics
    
    PM-&gt;&gt;Dev: 1단계 요구사항 정의 (핵심 기능만)
    Dev-&gt;&gt;Dev: MVP 개발 (4주)
    Dev-&gt;&gt;User: MVP 배포
    User-&gt;&gt;Data: 사용 패턴 데이터 생성
    Data-&gt;&gt;PM: 실사용 데이터 분석
    PM-&gt;&gt;Dev: 2단계 요구사항 (실제 필요성 기반)
    Dev-&gt;&gt;Dev: 기능 확장 개발
    Dev-&gt;&gt;User: 업데이트 배포
    
    Note over PM,Data: YAGNI 원칙: 실제 사용 데이터 기반 의사결정
</pre><p><strong>YAGNI 가 담당한 역할:</strong></p><ol><li><strong>우선순위 설정</strong>: 수많은 아이디어 중 핵심 학습 기능만 선별</li><li><strong>개발 가속화</strong>: 복잡한 AI 기능 대신 기본 기능으로 빠른 출시</li><li><strong>자원 최적화</strong>: 제한된 스타트업 자원을 가장 중요한 기능에 집중</li><li><strong>위험 감소</strong>: 시장 검증 없는 고급 기능 개발 위험 회피</li><li><strong>학습 촉진</strong>: 실제 사용자 데이터를 통한 진짜 필요 기능 발견</li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>분류</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>팀 문화</strong></td><td>팀 내 원칙의 공감대 형성</td><td>YAGNI 를 개발 철학으로 받아들이기 위해 팀 차원의 이해와 합의 필요</td><td>온보딩 시 개발 원칙 교육, 정기 회고에서 원칙 점검</td></tr><tr><td><strong>요구사항 관리</strong></td><td>구현 대상 기능의 명확한 정의</td><td>무엇이 " 지금 필요한 기능 " 인지 기준을 합의해야 함</td><td>유저 스토리 맵, MoSCoW, RICE 우선순위 모델 활용</td></tr><tr><td><strong>의사소통 구조</strong></td><td>이해관계자와의 합의 기반 개발</td><td>PM, 기획자, 고객과 YAGNI 적용 범위에 대한 소통 필수</td><td>제품 결정 회의에서 구현 기준 문서화</td></tr><tr><td><strong>기능 우선순위</strong></td><td>기능의 가치 중심 판단</td><td>구현 비용 대비 사용자 가치가 낮은 기능은 보류</td><td>린 (Lean) MVP 사고방식 기반 기능 기획 운영</td></tr><tr><td><strong>피드백 수집 및 반영</strong></td><td>실시간 사용자 의견 수집 → 개선 반복</td><td>기능 생존 여부를 사용자 데이터로 판단</td><td>로그 수집, 세션 분석, 피드백 폼 도입</td></tr><tr><td><strong>리팩토링 체계</strong></td><td>코드 품질을 해치지 않도록 유지보수 가능성 확보</td><td>단순화된 코드라도 품질 유지가 전제되어야 함</td><td>정기 리팩토링 스프린트 운영, 기술부채 트래킹</td></tr><tr><td><strong>문서화 및 의사결정 기록</strong></td><td>기능 생략 또는 연기 결정의 근거 기록</td><td>개발자 간 불확실성 제거 및 향후 의사결정 회고 가능</td><td>GitHub PR 템플릿에 결정 사유 포함, 결정 로그 운영</td></tr><tr><td><strong>성과 측정 및 효과 분석</strong></td><td>YAGNI 가 실제 효율 향상에 기여했는지 확인</td><td>정성적/정량적 성과 지표 설정</td><td>개발 속도, 배포 주기, 코드 라인 수, 이슈 발생률 추적</td></tr><tr><td><strong>원칙 간 균형 유지</strong></td><td>YAGNI 와 SOLID, DRY 등 원칙 간 균형 유지</td><td>YAGNI 를 명분으로 품질/확장성 희생 금지</td><td>아키텍처 리뷰 및 코드 리뷰를 통한 원칙 검증</td></tr><tr><td><strong>도입 단계 설정</strong></td><td>전면 적용이 아닌 점진적 도입 전략 필요</td><td>팀의 성숙도와 프로젝트 특성에 따라 선택적으로 적용</td><td>신규 모듈부터 적용 → 전체 시스템 확대 방식 추천</td></tr></tbody></table><ul><li>YAGNI 는 기술이 아니라 문화 + 전략: 도구나 언어만으로 실현되지 않음</li><li>" 지금 필요한가?" 라는 질문을 체계화하는 것이 핵심</li><li>품질, 커뮤니케이션, 리팩토링을 희생하지 말 것</li><li>Lean + Agile + DevOps 와 함께 적용할 때 가장 효과적</li></ul><h2 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>분류</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>기능 범위</strong></td><td>기능 최소화</td><td>시스템 성능에 불필요한 영향을 주는 기능을 사전에 차단</td><td>기능 설계 시 Value vs Cost 분석 활용</td></tr><tr><td><strong>코드 품질</strong></td><td>코드 간결성 유지</td><td>간단한 로직일수록 실행 성능과 유지보수 효율 모두 향상</td><td>코드 표준 정의 및 ESLint, Prettier 도입</td></tr><tr><td><strong>복잡도 관리</strong></td><td>코드 복잡성 제한</td><td>과도한 일반화, 미사용 로직 제거로 성능 저하 방지</td><td>정기 코드 리뷰 및 Dead Code 제거 프로세스 운영</td></tr><tr><td><strong>테스트 전략</strong></td><td>테스트 자동화</td><td>최소 기능에 대한 안정성 확보가 성능 최적화의 전제 조건</td><td>핵심 흐름 테스트 우선 구현 + 코드 커버리지 모니터링</td></tr><tr><td><strong>CI/CD 파이프라인</strong></td><td>빠른 피드백 기반 최적화</td><td>배포 후 빠른 문제 감지로 성능 저하를 신속하게 대응</td><td>GitHub Actions, GitLab CI 등 도입하여 자동화 체계 구축</td></tr><tr><td><strong>아키텍처</strong></td><td>확장 고려한 설계</td><td>YAGNI 를 적용하되 아키텍처는 지나치게 단순화하지 않음</td><td>모듈화, 느슨한 결합, 의존성 분리 (예: DI 패턴 등) 적용</td></tr><tr><td><strong>리팩토링 주기</strong></td><td>시점 기반 리팩토링</td><td>사전이 아닌 사후 리팩토링으로 코드 성능과 구조 최적화</td><td>리팩토링 우선순위 태스크 정리 및 기술 부채 대장 운영</td></tr><tr><td><strong>기술적 부채 관리</strong></td><td>부채 최소화 및 투명 관리</td><td>필요 최소화에 집중할수록 누락된 고려사항으로 부채 발생 가능</td><td>정기 기술 부채 회고 + SonarQube 등으로 가시화</td></tr><tr><td><strong>성능 모니터링</strong></td><td>데이터 기반 판단</td><td>불필요한 조기 최적화 방지 및 성능 저하 요소 선별</td><td>APM 도구 (New Relic, Datadog) 와 로그 기반 성능 분석 도입</td></tr><tr><td><strong>운영 환경 배려</strong></td><td>실제 사용자 기준 성능 대응</td><td>개발 환경이 아닌 실제 배포 환경 기준으로 최적화 판단</td><td>부하 테스트 도구 (k6, Artillery) 사용해 사전 검증</td></tr></tbody></table><ul><li>YAGNI 는 " 불필요한 구현 방지 " 이지, " 최적화 무시 " 가 아님</li><li>최소 기능 구현 이후에도 <strong>품질, 성능, 유지보수성은 지속적으로 관리</strong></li><li>성능 최적화는 사전 설계보다 피드백 기반 사후 개선이 더 효과적</li><li>모니터링 도구와 테스트 체계의 자동화가 성능 확보의 핵심</li></ul><h3 id=주목할-내용>주목할 내용<a hidden class=anchor aria-hidden=true href=#주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>핵심 원칙</strong></td><td>최소 기능 구현 (Minimalism)</td><td>현재 필요한 기능만 구현하여 리소스 낭비 방지 및 변경 대응력을 높임</td></tr><tr><td></td><td>단순성 원칙 (Simplicity Principle)</td><td>복잡성을 최소화하여 개발 속도와 유지보수성을 향상</td></tr><tr><td></td><td>YAGNI (XP 원칙)</td><td>애자일 실천 방법 중 하나로, 필요 없는 기능은 만들지 않음을 강조</td></tr><tr><td><strong>개발 방법론</strong></td><td>애자일 개발</td><td>반복적인 피드백 사이클을 통해 변화에 유연하게 대응하는 개발 방식</td></tr><tr><td></td><td>익스트림 프로그래밍 (XP)</td><td>YAGNI, TDD, 지속적 통합 등 실천 중심 개발 방식의 기반 제공</td></tr><tr><td></td><td>스크럼</td><td>스프린트 계획과 백로그 관리를 통해 YAGNI 적용 최적화</td></tr><tr><td></td><td>칸반 (Kanban)</td><td>WIP(Work In Progress) 제한을 통해 과잉 작업을 방지</td></tr><tr><td><strong>구현 전략</strong></td><td>테스트 주도 개발 (TDD)</td><td>기능 구현 전 테스트부터 작성하여 필요한 기능에 집중하게 함</td></tr><tr><td></td><td>지속적 리팩토링</td><td>반복적으로 구조를 개선하여 기술 부채를 줄이고 유지보수성을 확보</td></tr><tr><td></td><td>기능 우선순위 기반 개발</td><td>스토리맵, 백로그 등을 활용해 구현 순서를 체계적으로 관리</td></tr><tr><td><strong>소프트웨어 품질</strong></td><td>코드 복잡성 관리</td><td>순환 복잡도, 중첩 구조 등을 줄여서 가독성과 성능 향상</td></tr><tr><td></td><td>유지보수성 확보</td><td>코드 간결성과 테스트 커버리지를 통해 장기적인 안정성 확보</td></tr><tr><td></td><td>기술 부채 관리</td><td>필요한 기능만 구현하되, 리팩토링 주기를 통해 구조적 부채 방지</td></tr><tr><td><strong>제품 전략</strong></td><td>MVP (최소 기능 제품)</td><td>시장 검증을 위해 최소한의 기능만 먼저 출시</td></tr><tr><td></td><td>린 스타트업 방법론</td><td>빠른 실험과 피드백 중심으로 기능 구현 여부 판단</td></tr><tr><td></td><td>사용자 중심 설계 (UCD)</td><td>사용자 니즈와 행동을 기반으로 기능 요구사항을 정제</td></tr><tr><td><strong>아키텍처 설계</strong></td><td>마이크로서비스 아키텍처</td><td>각 서비스마다 YAGNI 적용 여부를 개별적으로 판단 필요</td></tr><tr><td></td><td>모듈러 모놀리스</td><td>초기에는 단일 구조, 이후 확장 가능한 아키텍처로 진화 가능</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>느슨한 결합과 비동기 처리를 통해 확장성과 유연성 확보</td></tr></tbody></table><ul><li><strong>YAGNI 는 철저한 우선순위와 단순성 중심 사고를 요구</strong>합니다.</li><li>테스트 주도 개발, 린 전략, 단순한 아키텍처와의 결합이 핵심입니다.</li><li>단기 구현을 최적화하는 대신, <strong>리팩토링·피드백 루프·아키텍처 균형</strong>을 통해 장기 품질을 유지해야 합니다.</li></ul><h3 id=추가적으로-학습해야할-내용들>추가적으로 학습해야할 내용들<a hidden class=anchor aria-hidden=true href=#추가적으로-학습해야할-내용들>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>개발 방법론</strong></td><td>테스트 주도 개발 (TDD)</td><td>테스트부터 작성함으로써 필수 기능 중심 개발을 유도</td></tr><tr><td></td><td>행위 주도 개발 (BDD)</td><td>사용자 행동 시나리오를 기반으로 기능 구현 필요성 검증</td></tr><tr><td></td><td>반복적 개발 (Iterative Development)</td><td>기능을 반복적으로 개선하며 피드백 기반 개발을 실현</td></tr><tr><td></td><td>애자일 개발</td><td>빠른 피드백과 변화 수용 중심의 민첩한 개발 프로세스</td></tr><tr><td><strong>DevOps</strong></td><td>지속적 통합 / 배포 (CI/CD)</td><td>코드 변경 사항을 빠르게 통합하고 배포하는 자동화 체계</td></tr><tr><td></td><td>배포 자동화 도구</td><td>GitHub Actions, Jenkins 등 도구를 통한 운영 효율화</td></tr><tr><td><strong>설계 원칙</strong></td><td>SOLID 원칙</td><td>객체지향 설계 5 원칙으로 YAGNI 와의 균형을 위한 필수 개념</td></tr><tr><td></td><td>KISS 원칙</td><td>과도한 설계나 구현을 피하고 단순한 구조를 유지</td></tr><tr><td></td><td>DRY 원칙</td><td>중복 제거를 통해 코드 유지보수성과 확장성 향상</td></tr><tr><td></td><td>Just-In-Time Design</td><td>필요한 시점에 필요한 설계를 적용하는 유연한 설계 철학</td></tr><tr><td><strong>아키텍처 설계</strong></td><td>클린 아키텍처</td><td>계층화된 구조와 의존성 관리로 확장성과 테스트 용이성 확보</td></tr><tr><td></td><td>도메인 주도 설계 (DDD)</td><td>도메인 중심으로 복잡한 비즈니스 로직을 정리하고 단순화</td></tr><tr><td><strong>제품 전략</strong></td><td>MVP (최소 기능 제품)</td><td>시장 검증을 위한 최소 기능만 포함한 제품을 먼저 출시</td></tr><tr><td></td><td>린 스타트업</td><td>빠른 실험과 반복을 통해 실제 가치가 있는 기능만 구현</td></tr><tr><td><strong>분석 및 측정</strong></td><td>소프트웨어 메트릭스</td><td>코드 품질, 복잡도, 커버리지 등을 수치로 분석해 최적화 유도</td></tr><tr><td></td><td>A/B 테스트</td><td>기능 추가 여부를 데이터 기반으로 실험적으로 결정</td></tr><tr><td></td><td>사용자 행동 분석</td><td>실제 사용 데이터를 통해 기능의 필요성 여부를 판단</td></tr><tr><td><strong>프로젝트 관리</strong></td><td>요구사항 우선순위화</td><td>MoSCoW, RICE 등으로 구현 여부를 논리적으로 결정</td></tr><tr><td></td><td>협업 도구 활용</td><td>Jira, Notion, Trello 등으로 명확한 커뮤니케이션 체계 확립</td></tr><tr><td><strong>코드 품질 관리</strong></td><td>리팩토링 전략</td><td>주기적인 구조 개선을 통해 기술적 부채 누적 방지</td></tr><tr><td></td><td>코드 복잡도 관리</td><td>순환 복잡도, 인지 복잡도 등을 측정하고 최적화</td></tr><tr><td></td><td>문서화 및 코드 표준화</td><td>유지보수성을 높이기 위한 공통 규약 수립</td></tr></tbody></table><h3 id=관련-분야와-함께-학습해야할-내용들>관련 분야와 함께 학습해야할 내용들<a hidden class=anchor aria-hidden=true href=#관련-분야와-함께-학습해야할-내용들>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>개발 방법론</strong></td><td>Agile Principles</td><td>" 변화에 대응하는 것 " 을 중시하는 애자일 핵심 원칙, YAGNI 의 철학적 기반</td></tr><tr><td></td><td>Evolutionary Design</td><td>필요한 기능과 구조를 진화적으로 점진 확장하는 설계 전략</td></tr><tr><td><strong>제품 전략</strong></td><td>A/B Testing</td><td>두 가지 기능/버전을 테스트하여 사용자 반응을 데이터 기반으로 측정</td></tr><tr><td></td><td>Lean Startup</td><td>검증된 학습을 바탕으로 기능을 빠르게 실험하고 개선</td></tr><tr><td></td><td>MVP (Minimum Viable Product)</td><td>최소 기능만으로 제품을 출시해 시장 반응을 검증하는 접근</td></tr><tr><td><strong>설계 및 아키텍처</strong></td><td>모듈화 (Modularization)</td><td>YAGNI 기반 구조 구현 시 필요한 확장성과 변경 용이성 확보 방식</td></tr><tr><td></td><td>Interface Segregation</td><td>불필요한 인터페이스 의존 제거 → YAGNI 와의 설계 궁합 우수</td></tr><tr><td></td><td>Technical Debt Management</td><td>미루거나 생략된 기능이 남긴 부채를 지속적으로 관리하는 기법</td></tr><tr><td><strong>프로젝트 관리</strong></td><td>Feature Creep</td><td>사용자의 기능 요청이 끝없이 늘어나는 현상, YAGNI 의 반대 사례</td></tr><tr><td></td><td>Agile Project Management</td><td>스크럼, 칸반 기반으로 점진적 우선순위 구현을 진행</td></tr><tr><td></td><td>리스크 관리</td><td>기능 생략으로 발생할 수 있는 기술/비즈니스 리스크 분석과 완화 전략</td></tr><tr><td><strong>비즈니스 분석</strong></td><td>요구사항 공학 (Requirements Engineering)</td><td>실제 필요한 기능과 그렇지 않은 기능을 구분하고 명세하는 분석 기법</td></tr><tr><td></td><td>가치 스트림 매핑</td><td>고객에게 전달되는 가치 흐름을 시각화하여 핵심 기능 식별</td></tr><tr><td><strong>사용자 경험</strong></td><td>사용자 연구 (User Research)</td><td>실제 사용자 행동과 니즈 파악 → YAGNI 적용 시 핵심 근거 제공</td></tr><tr><td></td><td>인터랙션 디자인</td><td>기능 설계 시 사용자 우선 흐름을 기반으로 기능 구성</td></tr><tr><td></td><td>사용성 테스트</td><td>생략되거나 축소된 기능이 사용자 경험에 미치는 영향 평가</td></tr><tr><td><strong>데이터 분석</strong></td><td>제품 분석 (Product Analytics)</td><td>기능 사용률, 이탈률 등 사용자 데이터를 기반으로 기능 필요성 판단</td></tr><tr><td></td><td>실험 설계 (Design of Experiments)</td><td>A/B 테스트나 피처 실험에서 통계적 유의성 확보 방법</td></tr><tr><td></td><td>행동 기반 세분화 (Behavioral Segmentation)</td><td>기능별 사용자 유형 분석으로 필요한 기능 우선순위 결정</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=개발-방법론-및-원칙>개발 방법론 및 원칙<a hidden class=anchor aria-hidden=true href=#개발-방법론-및-원칙>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>애자일 개발 (Agile Development)</strong></td><td>반복적이고 점진적인 개발 사이클을 기반으로 변화에 민첩하게 대응하는 개발 방법론</td></tr><tr><td><strong>익스트림 프로그래밍 (Extreme Programming, XP)</strong></td><td>애자일 하위 방법론 중 하나로, YAGNI, TDD, 지속적 통합 등을 실천</td></tr><tr><td><strong>YAGNI (You Ain&rsquo;t Gonna Need It)</strong></td><td>지금 필요하지 않은 기능은 구현하지 않는다는 극단적 개발 원칙</td></tr><tr><td><strong>Simple Design</strong></td><td>현재 요구만을 충족시키는 가장 단순한 설계를 지향하는 XP 실천 항목</td></tr><tr><td><strong>Just-In-Time (JIT) Development</strong></td><td>기능을 실제 필요한 시점에 정확히 개발하는 접근 방식</td></tr></tbody></table><h3 id=구현-및-테스트-전략>구현 및 테스트 전략<a hidden class=anchor aria-hidden=true href=#구현-및-테스트-전략>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>테스트 주도 개발 (TDD)</strong></td><td>테스트를 먼저 작성하고 해당 테스트를 통과하도록 코드를 구현하는 개발 기법</td></tr><tr><td><strong>지속적 통합 (CI, Continuous Integration)</strong></td><td>코드 변경 사항을 자주 통합하고 자동화된 빌드 및 테스트를 수행하는 절차</td></tr><tr><td><strong>지속적 리팩토링 (Continuous Refactoring)</strong></td><td>기능은 그대로 두되 내부 코드를 지속적으로 개선해 나가는 활동</td></tr></tbody></table><h3 id=제품-및-기능-전략>제품 및 기능 전략<a hidden class=anchor aria-hidden=true href=#제품-및-기능-전략>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>MVP (Minimum Viable Product)</strong></td><td>사용자 피드백을 얻기 위한 최소한의 기능만 갖춘 제품</td></tr><tr><td><strong>추정적 기능 (Presumptive Features)</strong></td><td>미래에 필요할 것을 예상하여 미리 구현한 기능 (YAGNI 가 경계하는 대상)</td></tr><tr><td><strong>Feature Creep</strong></td><td>초기 계획에 없던 기능이 지속적으로 추가되어 프로젝트 범위가 확대되는 현상</td></tr><tr><td><strong>Cost of Carry</strong></td><td>구현한 기능을 유지함으로써 발생하는 지속적인 비용과 복잡성</td></tr></tbody></table><h3 id=설계-원칙-및-소프트웨어-구조>설계 원칙 및 소프트웨어 구조<a hidden class=anchor aria-hidden=true href=#설계-원칙-및-소프트웨어-구조>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>KISS 원칙 (Keep It Simple, Stupid)</strong></td><td>가능한 단순하게 설계하라는 소프트웨어 설계 원칙</td></tr><tr><td><strong>기술적 부채 (Technical Debt)</strong></td><td>빠른 구현이나 품질 타협으로 인해 발생하는 미래의 개발 부담 비용</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=yagni-개념-및-철학>YAGNI 개념 및 철학<a hidden class=anchor aria-hidden=true href=#yagni-개념-및-철학>#</a></h3><ul><li><a href=https://martinfowler.com/bliki/Yagni.html>Martin Fowler - YAGNI 원칙 설명</a></li><li><a href="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it">Wikipedia - YAGNI</a></li><li><a href=https://www.agilealliance.org/glossary/yagni/>Agile Alliance - YAGNI</a></li><li><a href=https://deviq.com/principles/yagni/>DevIQ - YAGNI Principle</a></li><li><a href=https://www.techtarget.com/whatis/definition/You-arent-gonna-need-it>TechTarget - YAGNI 정의</a></li></ul><h3 id=실무-적용-및-사례-분석>실무 적용 및 사례 분석<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례-분석>#</a></h3><ul><li><a href=https://hackernoon.com/why-yagni-matters-in-software-development-and-architecture>HackerNoon - Why YAGNI matters</a></li><li><a href=https://www.vtlabs.org/blog/programming-principle-yagni>VT Labs - How to practice YAGNI principle</a></li><li><a href=https://codibly.com/news-insights/yagni-how-to-do-things-when-you-actually-need-them-to-be-done/>Codibly - YAGNI Implementation Guide</a></li><li><a href=https://www.linkedin.com/pulse/power-simplicity-understanding-yagni-software-varghese-chacko>LinkedIn - Understanding YAGNI in Software Development</a></li></ul><h3 id=관련-설계-원칙-및-비교>관련 설계 원칙 및 비교<a hidden class=anchor aria-hidden=true href=#관련-설계-원칙-및-비교>#</a></h3><ul><li><a href=https://www.boldare.com/blog/kiss-yagni-dry-principles/>Boldare - DRY, KISS & YAGNI 비교 가이드</a></li><li><a href=https://www.thoughtworks.com/radar/techniques/yagni>ThoughtWorks Technology Radar - YAGNI</a></li></ul><h3 id=애자일-및-개발-원칙-일반>애자일 및 개발 원칙 일반<a hidden class=anchor aria-hidden=true href=#애자일-및-개발-원칙-일반>#</a></h3><ul><li><a href=http://www.extremeprogramming.org/rules/simple.html>Extreme Programming 공식 설명 - Simple Design</a></li><li><a href=https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C>애자일 개발 방법론 개요 (위키백과)</a></li><li><a href=https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C>테스트 주도 개발(TDD) 설명 (위키백과)</a></li><li><a href=https://ko.wikipedia.org/wiki/%EC%A7%80%EC%86%8D%EC%A0%81_%ED%86%B5%ED%95%A9>지속적 통합(CI) 설명 (위키백과)</a></li><li><a href=https://roadmap.sh/software-design-architecture/software-design-principles/yagni>roadmap.sh - YAGNI 설명</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>