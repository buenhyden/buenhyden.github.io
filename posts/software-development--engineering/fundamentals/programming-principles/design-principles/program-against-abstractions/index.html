<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Program Against Abstractions | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles"><meta name=description content="Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Program Against Abstractions"><meta property="og:description" content="Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Program Against Abstractions"><meta name=twitter:description content="Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":6,"name":"Program Against Abstractions","item":"https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Program Against Abstractions</h1><div class=post-description>Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다.</div></header><div class=post-content><h2 id=program-against-abstractions>Program Against Abstractions<a hidden class=anchor aria-hidden=true href=#program-against-abstractions>#</a></h2><p>Program Against Abstractions(추상화에 대하여 프로그래밍하라) 는 소프트웨어 아키텍처 및 설계에서 핵심 원칙 중 하나로, 구체적인 구현체가 아닌 추상화 계층 (인터페이스, 추상 클래스 등) 에 의존해 코드를 작성하는 것을 의미한다. 이 원칙은 시스템의 결합도를 낮추고, 변화에 유연하게 대응할 수 있도록 하며, 유지보수와 테스트, 확장성을 크게 향상시킨다. 객체지향 설계의 DIP(의존성 역전 원칙) 와도 밀접하게 연관되어 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>Program Against Abstractions</strong>란 코드를 작성할 때 구체적인 구현체가 아니라, 인터페이스나 추상 클래스 등 추상화 계층에 의존하도록 설계하는 것이다.</p><p><strong>Program Against Abstractions</strong>의 핵심 개념들:</p><ol><li><strong>추상화 (Abstraction)</strong>: 구현 세부사항을 숨기고 본질적인 특성만을 노출하는 개념</li><li><strong>구체화 (Concretion)</strong>: 실제 구현을 포함한 구체적인 클래스나 모듈</li><li><strong>의존성 역전 (Dependency Inversion)</strong>: 고수준 모듈이 저수준 모듈에 의존하지 않고 추상화에 의존하는 원칙</li><li><strong>인터페이스 (Interface)</strong>: 구현을 강제하는 계약을 정의하는 추상화 도구</li><li><strong>느슨한 결합 (Loose Coupling)</strong>: 컴포넌트 간의 의존성을 최소화하는 설계 방식</li></ol><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p><strong>역사적 배경</strong>:</p><ul><li>1990 년대 객체지향 프로그래밍의 발전과 함께 등장</li><li>Robert C. Martin(Uncle Bob) 이 SOLID 원칙의 일부로 체계화</li><li>소프트웨어 복잡성 증가에 따른 유지보수성 문제 해결을 위해 발달</li></ul><p><strong>등장 배경</strong>:</p><ul><li>전통적인 하향식 설계에서 발생하는 강한 결합 문제</li><li>코드 변경 시 연쇄적인 수정이 필요한 상황</li><li>테스트 가능성과 재사용성의 필요성 증대</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p><strong>주요 목적</strong>:</p><ol><li><strong>유연성 확보</strong>: 구현체 변경 시 클라이언트 코드 수정 최소화</li><li><strong>확장성 향상</strong>: 새로운 구현체 추가 시 기존 코드 영향 최소화</li><li><strong>테스트 용이성</strong>: Mock 객체를 활용한 단위 테스트 가능</li><li><strong>재사용성 증대</strong>: 다양한 구현체와 함께 사용 가능한 코드 작성</li></ol><p><strong>필요성</strong>:</p><ul><li>대규모 소프트웨어 시스템의 복잡성 관리</li><li>지속적인 요구사항 변경에 대응</li><li>팀 개발 환경에서의 모듈 독립성 확보</li><li>소프트웨어 품질 및 유지보수성 향상</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ol><li><strong>의존성 관리</strong>: 컴포넌트 간 의존성을 추상화 계층으로 관리</li><li><strong>변경 격리</strong>: 구현 변경이 다른 컴포넌트에 미치는 영향 차단</li><li><strong>인터페이스 정의</strong>: 명확한 계약을 통한 컴포넌트 간 상호작용 정의</li><li><strong>확장성 제공</strong>: 새로운 기능 추가 시 기존 코드 변경 최소화</li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><strong>추상화 의존 원칙</strong>: 구체적인 클래스가 아닌 추상화에 의존</li><li><strong>인터페이스 분리 원칙</strong>: 클라이언트가 사용하지 않는 메서드에 의존하지 않음</li><li><strong>대체 가능성 원칙</strong>: 추상화를 구현한 모든 객체는 상호 교체 가능</li><li><strong>단일 책임 원칙</strong>: 각 인터페이스는 하나의 명확한 책임만 가짐</li></ol><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><pre class=mermaid>graph TD
    A[클라이언트 코드] --&gt; B[추상화 계층]
    B --&gt; C[구현체 A]
    B --&gt; D[구현체 B]
    B --&gt; E[구현체 C]
    
    F[고수준 모듈] --&gt; G[인터페이스]
    H[저수준 모듈] --&gt; G
    
    style B fill:#e1f5fe
    style G fill:#e1f5fe
</pre><p><strong>핵심 원리</strong>:</p><ol><li><strong>의존성 역전</strong>: 고수준과 저수준 모듈 모두 추상화에 의존</li><li><strong>추상화 안정성</strong>: 추상화는 구체화보다 안정적</li><li><strong>계약 우선</strong>: 구현보다 인터페이스 계약을 우선시</li><li><strong>느슨한 결합</strong>: 컴포넌트 간 직접적인 의존성 제거</li></ol><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><pre class=mermaid>sequenceDiagram
    participant Client as 클라이언트
    participant Interface as 인터페이스
    participant Implementation as 구현체
    
    Client-&gt;&gt;Interface: 메서드 호출
    Interface-&gt;&gt;Implementation: 실제 구현 실행
    Implementation--&gt;&gt;Interface: 결과 반환
    Interface--&gt;&gt;Client: 결과 전달
</pre><p><strong>작동 메커니즘</strong>:</p><ol><li><strong>인터페이스 정의</strong>: 필요한 기능을 추상 메서드로 정의</li><li><strong>구현체 작성</strong>: 인터페이스를 구현하는 구체적인 클래스 작성</li><li><strong>의존성 주입</strong>: 클라이언트에 인터페이스 타입으로 구현체 제공</li><li><strong>런타임 바인딩</strong>: 실행 시점에 실제 구현체 메서드 호출</li></ol><h3 id=작동-원리-및-구조>작동 원리 및 구조<a hidden class=anchor aria-hidden=true href=#작동-원리-및-구조>#</a></h3><ul><li>클라이언트 (사용자) 는 인터페이스 (추상화) 에 의존.</li><li>실제 구현체는 인터페이스를 구현 (implements) 하여 제공.</li><li>클라이언트는 구현체의 세부사항을 몰라도 인터페이스를 통해 기능 사용.</li></ul><pre class=mermaid>classDiagram
    class IService {
        &lt;&lt;interface&gt;&gt;
        +execute() : Result
        +validate() : boolean
    }
    
    class ServiceA {
        +execute() : Result
        +validate() : boolean
    }
    
    class ServiceB {
        +execute() : Result
        +validate() : boolean
    }
    
    class Client {
        -service : IService
        +Client(service: IService)
        +performAction() : void
    }
    
    IService &lt;|-- ServiceA
    IService &lt;|-- ServiceB
    Client --&gt; IService
</pre><table><thead><tr><th>구분</th><th>구성요소</th><th>기능</th><th>역할</th><th>특징</th></tr></thead><tbody><tr><td>필수</td><td><strong>추상화 계층 (Interface/Abstract Class)</strong></td><td>계약 정의</td><td>구현체와 클라이언트 간 중개</td><td>안정적, 변경 빈도 낮음</td></tr><tr><td></td><td><strong>구현체 (Concrete Implementation)</strong></td><td>실제 로직 구현</td><td>비즈니스 로직 처리</td><td>변경 가능, 교체 가능</td></tr><tr><td></td><td><strong>클라이언트 (Client)</strong></td><td>서비스 사용</td><td>추상화를 통한 기능 호출</td><td>구현체에 독립적</td></tr><tr><td>선택</td><td><strong>의존성 주입 컨테이너 (DI Container)</strong></td><td>객체 생성 및 주입</td><td>의존성 관리 자동화</td><td>설정 기반, 런타임 관리</td></tr><tr><td></td><td><strong>팩토리 패턴 (Factory Pattern)</strong></td><td>객체 생성 추상화</td><td>구체적인 생성 로직 캡슐화</td><td>생성 복잡성 숨김</td></tr><tr><td></td><td><strong>어댑터 패턴 (Adapter Pattern)</strong></td><td>인터페이스 변환</td><td>기존 코드와 새 인터페이스 연결</td><td>레거시 코드 통합</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><h4 id=인터페이스-기반-설계>인터페이스 기반 설계<a hidden class=anchor aria-hidden=true href=#인터페이스-기반-설계>#</a></h4><p><strong>정의</strong>: 모든 의존성을 인터페이스로 정의하는 기법<br><strong>구성</strong>: 인터페이스 + 구현체 + 클라이언트<br><strong>목적</strong>: 강한 결합 제거 및 유연성 확보</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 인터페이스 정의</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>abc</span> <span class=kn>import</span> <span class=n>ABC</span><span class=p>,</span> <span class=n>abstractmethod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IPaymentProcessor</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_payment</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>payment_info</span><span class=p>:</span> <span class=nb>dict</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 구현체들</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CreditCardProcessor</span><span class=p>(</span><span class=n>IPaymentProcessor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_payment</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>payment_info</span><span class=p>:</span> <span class=nb>dict</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 신용카드 결제 로직</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PayPalProcessor</span><span class=p>(</span><span class=n>IPaymentProcessor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_payment</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>payment_info</span><span class=p>:</span> <span class=nb>dict</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># PayPal 결제 로직</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 클라이언트</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OrderService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>payment_processor</span><span class=p>:</span> <span class=n>IPaymentProcessor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_payment_processor</span> <span class=o>=</span> <span class=n>payment_processor</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>complete_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>order_amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>payment_info</span><span class=p>:</span> <span class=nb>dict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_payment_processor</span><span class=o>.</span><span class=n>process_payment</span><span class=p>(</span><span class=n>order_amount</span><span class=p>,</span> <span class=n>payment_info</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=의존성-주입-dependency-injection>의존성 주입 (Dependency Injection)<a hidden class=anchor aria-hidden=true href=#의존성-주입-dependency-injection>#</a></h4><p><strong>정의</strong>: 외부에서 의존성을 주입하는 기법<br><strong>구성</strong>: 생성자 주입, 세터 주입, 인터페이스 주입<br><strong>목적</strong>: 객체 생성과 사용의 분리</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph LR
    A[DI Container] --&gt; B[Service Registration]
    A --&gt; C[Dependency Resolution]
    A --&gt; D[Lifecycle Management]
    
    E[Constructor Injection] --&gt; F[Client Object]
    G[Interface] --&gt; F
    H[Implementation] --&gt; G
</pre><h4 id=전략-패턴-strategy-pattern>전략 패턴 (Strategy Pattern)<a hidden class=anchor aria-hidden=true href=#전략-패턴-strategy-pattern>#</a></h4><p><strong>정의</strong>: 알고리즘을 캡슐화하고 교체 가능하게 만드는 패턴<br><strong>구성</strong>: Context + Strategy Interface + Concrete Strategies<br><strong>목적</strong>: 런타임에 알고리즘 변경 가능</p><p><strong>시나리오</strong>: 다양한 할인 정책을 적용하는 쇼핑몰 시스템</p><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ <strong>장점</strong></td><td><strong>유연성</strong></td><td>구현체 변경 시 클라이언트 코드 수정 불필요</td></tr><tr><td></td><td><strong>확장성</strong></td><td>새로운 구현체 추가가 용이함</td></tr><tr><td></td><td><strong>테스트 용이성</strong></td><td>Mock 객체를 활용한 단위 테스트 가능</td></tr><tr><td></td><td><strong>재사용성</strong></td><td>동일한 인터페이스로 다양한 구현체 사용</td></tr><tr><td></td><td><strong>유지보수성</strong></td><td>변경 영향 범위 최소화</td></tr><tr><td>⚠ <strong>단점</strong></td><td><strong>복잡성 증가</strong></td><td>추가적인 추상화 계층으로 인한 복잡성</td></tr><tr><td></td><td><strong>성능 오버헤드</strong></td><td>간접 호출로 인한 미미한 성능 저하</td></tr><tr><td></td><td><strong>과도한 추상화</strong></td><td>불필요한 인터페이스 생성 가능성</td></tr><tr><td></td><td><strong>학습 비용</strong></td><td>초기 설계 시 높은 이해도 요구</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>기존 코드베이스 적용 어려움</td><td>레거시 코드에 추상화 적용이 어렵고, 직접 의존이 많음</td><td>점진적 리팩토링, 추상화된 인터페이스 도입으로 결합도 감소</td></tr><tr><td>과도한 추상화</td><td>단순 기능에도 불필요한 인터페이스를 생성하여 오히려 복잡도 증가</td><td>YAGNI 원칙 적용, 실제 사용 시점 기준으로 추상화 적용 결정</td></tr><tr><td>인터페이스 설계의 어려움</td><td>적절한 책임 분리와 추상화 수준 정의가 어려움</td><td>도메인 전문가와 협업, 반복적 설계 검토 및 리팩토링</td></tr><tr><td>런타임 성능 영향</td><td>추상화 계층 증가로 호출 성능 저하 발생 가능</td><td>프로파일링 기반 성능 측정, 성능 중요 구간은 직접 구현 고려</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>분류/유형</th><th>설명</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td><strong>추상화 수준</strong></td><td>고수준 추상화</td><td>비즈니스 로직 중심 인터페이스</td><td>변경에 유연, 테스트 용이</td><td>구현과 거리감 있음</td></tr><tr><td></td><td>저수준 추상화</td><td>기술적 세부사항 캡슐화</td><td>모듈 교체 용이, 유지보수 편리</td><td>과도시 설계 복잡도 증가</td></tr><tr><td><strong>구현 범위</strong></td><td>단일 책임 인터페이스</td><td>하나의 역할만 수행</td><td>SRP(단일 책임 원칙) 준수</td><td>인터페이스 수 증가</td></tr><tr><td></td><td>복합 인터페이스</td><td>관련된 여러 기능 통합</td><td>관련 기능 일괄 관리</td><td>응집도 낮으면 결합도 증가</td></tr><tr><td><strong>생명 주기</strong></td><td>정적 인터페이스</td><td>컴파일 시점에 타입 결정</td><td>타입 안정성 보장, IDE 지원</td><td>유연성 낮음</td></tr><tr><td></td><td>동적 인터페이스</td><td>런타임 시점에 구조 해석</td><td>높은 유연성, 빠른 프로토타이핑</td><td>런타임 오류 위험</td></tr><tr><td><strong>타입 정의</strong></td><td>명시적 인터페이스</td><td>명확한 계약 정의</td><td>문서화 및 검증 용이</td><td>구현 코드 많아짐</td></tr><tr><td></td><td>제네릭 인터페이스</td><td>타입 매개변수로 동작 추상화</td><td>재사용성, 타입 안전성</td><td>설계 복잡도 증가</td></tr><tr><td><strong>타입 시스템</strong></td><td>덕 타이핑</td><td>이름이 아닌 구조에 기반한 인터페이스</td><td>유연한 의존성, 빠른 개발 가능</td><td>일관성 부족, 추적 어려움</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>분야</th><th>적용 사례</th><th>추상화</th><th>구현체</th><th>효과</th></tr></thead><tbody><tr><td><strong>데이터 액세스</strong></td><td>Repository Pattern</td><td>IUserRepository</td><td>MySQLUserRepository, MongoUserRepository</td><td>DB 변경 시 비즈니스 로직 보호</td></tr><tr><td><strong>외부 서비스 연동</strong></td><td>Gateway Pattern</td><td>IPaymentGateway</td><td>StripeGateway, PayPalGateway</td><td>결제 서비스 변경 용이</td></tr><tr><td><strong>알림 시스템</strong></td><td>알림 서비스</td><td>INotificationService</td><td>EmailNotifier, SMSNotifier, PushNotifier</td><td>다중 알림 채널 지원</td></tr><tr><td><strong>로깅 시스템</strong></td><td>로깅 추상화</td><td>ILogger</td><td>FileLogger, DatabaseLogger, CloudLogger</td><td>로깅 전략 변경 자유도</td></tr><tr><td><strong>캐싱 시스템</strong></td><td>캐시 추상화</td><td>ICacheService</td><td>MemoryCache, RedisCache, DistributedCache</td><td>캐싱 전략 최적화</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-플랫폼의-주문-처리-시스템>사례 1: 전자상거래 플랫폼의 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-플랫폼의-주문-처리-시스템>#</a></h4><p><strong>시나리오</strong>: 대형 온라인 쇼핑몰에서 다양한 결제 방식 (신용카드, PayPal, 가상계좌, 암호화폐) 과 배송 방식 (일반배송, 택배, 드론배송) 을 지원하는 주문 처리 시스템을 구축</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    subgraph &#34;클라이언트 계층&#34;
        A[OrderController]
    end
    
    subgraph &#34;서비스 계층&#34;
        B[OrderService]
    end
    
    subgraph &#34;추상화 계층&#34;
        C[IPaymentProcessor]
        D[IShippingService]
        E[IInventoryService]
    end
    
    subgraph &#34;구현 계층&#34;
        F[CreditCardProcessor]
        G[PayPalProcessor]
        H[StandardShipping]
        I[ExpressShipping]
        J[DatabaseInventory]
        K[CacheInventory]
    end
    
    A --&gt; B
    B --&gt; C
    B --&gt; D
    B --&gt; E
    C --&gt; F
    C --&gt; G
    D --&gt; H
    D --&gt; I
    E --&gt; J
    E --&gt; K
</pre><p><strong>Workflow</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Customer as 고객
    participant OrderController as 주문컨트롤러
    participant OrderService as 주문서비스
    participant PaymentProcessor as 결제처리기
    participant ShippingService as 배송서비스
    participant InventoryService as 재고서비스
    
    Customer-&gt;&gt;OrderController: 주문 요청
    OrderController-&gt;&gt;OrderService: processOrder()
    OrderService-&gt;&gt;InventoryService: checkAvailability()
    InventoryService--&gt;&gt;OrderService: 재고 확인 결과
    OrderService-&gt;&gt;PaymentProcessor: processPayment()
    PaymentProcessor--&gt;&gt;OrderService: 결제 결과
    OrderService-&gt;&gt;ShippingService: arrangeShipping()
    ShippingService--&gt;&gt;OrderService: 배송 안내
    OrderService--&gt;&gt;OrderController: 주문 완료 결과
    OrderController--&gt;&gt;Customer: 주문 확인
</pre><p><strong>역할 및 책임</strong>:</p><ol><li><strong>OrderService</strong>: 주문 비즈니스 로직 조율, 추상화된 인터페이스만 사용</li><li><strong>IPaymentProcessor</strong>: 결제 처리 추상화, 다양한 결제 방식 지원</li><li><strong>IShippingService</strong>: 배송 서비스 추상화, 배송 방식 선택 유연성</li><li><strong>IInventoryService</strong>: 재고 관리 추상화, 다양한 데이터 소스 지원</li></ol><p><strong>구현 코드 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>OrderService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                 <span class=n>payment_processor</span><span class=p>:</span> <span class=n>IPaymentProcessor</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>shipping_service</span><span class=p>:</span> <span class=n>IShippingService</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>inventory_service</span><span class=p>:</span> <span class=n>IInventoryService</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_payment_processor</span> <span class=o>=</span> <span class=n>payment_processor</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_shipping_service</span> <span class=o>=</span> <span class=n>shipping_service</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_inventory_service</span> <span class=o>=</span> <span class=n>inventory_service</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>order</span><span class=p>:</span> <span class=n>Order</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>OrderResult</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 재고 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_inventory_service</span><span class=o>.</span><span class=n>check_availability</span><span class=p>(</span><span class=n>order</span><span class=o>.</span><span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>OrderResult</span><span class=o>.</span><span class=n>insufficient_inventory</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 결제 처리</span>
</span></span><span class=line><span class=cl>        <span class=n>payment_result</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_payment_processor</span><span class=o>.</span><span class=n>process_payment</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>order</span><span class=o>.</span><span class=n>total_amount</span><span class=p>,</span> <span class=n>order</span><span class=o>.</span><span class=n>payment_info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>payment_result</span><span class=o>.</span><span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>OrderResult</span><span class=o>.</span><span class=n>payment_failed</span><span class=p>(</span><span class=n>payment_result</span><span class=o>.</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 배송 준비</span>
</span></span><span class=line><span class=cl>        <span class=n>shipping_result</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_shipping_service</span><span class=o>.</span><span class=n>arrange_shipping</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>order</span><span class=o>.</span><span class=n>shipping_address</span><span class=p>,</span> <span class=n>order</span><span class=o>.</span><span class=n>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>OrderResult</span><span class=o>.</span><span class=n>success</span><span class=p>(</span><span class=n>payment_result</span><span class=p>,</span> <span class=n>shipping_result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 단계</strong></td><td>책임 분리</td><td>각 모듈이 고유한 책임을 가지도록 설계</td><td>단일 책임 원칙 (SRP) 및 인터페이스 분리 원칙 (ISP) 적용</td></tr><tr><td></td><td>적절한 추상화 수준</td><td>과도하거나 부족한 추상화는 설계 복잡성을 증가시킴</td><td>실제 변경 가능성이 높은 부분에만 추상화 도입</td></tr><tr><td></td><td>인터페이스 명확성</td><td>추상화된 메서드는 구체성과 일반성의 균형이 필요</td><td>도메인 용어 기반의 직관적인 인터페이스 정의</td></tr><tr><td></td><td>인터페이스 안정성</td><td>인터페이스 변경 시 영향 범위가 커질 수 있음</td><td>충분한 도메인 분석 및 의존성 최소화 전략 수립</td></tr><tr><td><strong>구현 단계</strong></td><td>의존성 주입 전략</td><td>추상 타입에 의존하도록 구성하며, 주입 방식에 따라 유연성이 달라짐</td><td>생성자 주입을 기본으로 하며, 필요 시 세터/인터페이스 주입 활용</td></tr><tr><td></td><td>구현체 수 증가 관리</td><td>다양한 구현체로 인해 관리 포인트 증가 가능</td><td>DI(Dependency Injection) 컨테이너 및 설정 기반 주입 활용</td></tr><tr><td></td><td>생명주기 및 스코프 관리</td><td>인터페이스에 주입된 객체의 생명주기 고려 필요</td><td>싱글톤, 프로토타입 등 컨테이너 스코프 활용</td></tr><tr><td></td><td>예외 처리 전략</td><td>추상화 계층에서 발생하는 예외의 처리 일관성 유지</td><td>도메인별 커스텀 예외 정의 및 매핑</td></tr><tr><td><strong>테스트 단계</strong></td><td>테스트 용이성 확보</td><td>추상화는 테스트 대상 분리를 용이하게 함</td><td>Mock, Stub, Spy 등 테스트 더블 패턴 활용</td></tr><tr><td></td><td>통합 테스트 전략</td><td>추상화된 계층을 실제 구현체와 검증 필요</td><td>TestContainers, Spring Profile 등으로 통합 테스트 구성</td></tr><tr><td><strong>운영 단계</strong></td><td>성능 영향 모니터링</td><td>추상화로 인한 간접 호출이 성능에 미치는 영향</td><td>APM(Application Performance Monitoring) 도구로 병목 식별</td></tr><tr><td></td><td>설정 기반 유연성 확보</td><td>런타임에 구현체 교체 등 유연한 구성 필요</td><td>외부 설정 파일, 환경 변수 활용</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>메모리 최적화</strong></td><td>객체 생성 비용</td><td>인터페이스 구현체 생성 및 의존성 주입 시 메모리 사용량 증가</td><td>객체 풀링, 싱글턴 패턴, Lazy Initialization 적용</td></tr><tr><td></td><td>가비지 컬렉션 영향</td><td>불필요한 객체가 과도하게 생성되어 GC(Garbage Collection) 압박 유발</td><td>불변 객체 (Immutable Object), 재사용 전략 도입</td></tr><tr><td><strong>실행 성능</strong></td><td>다형성 및 간접 호출 비용</td><td>인터페이스/추상 클래스 기반 호출은 직접 호출보다 성능 저하 발생</td><td>핫스팟 분석 후 성능 민감한 경로에 직접 구현체 사용</td></tr><tr><td></td><td>인라인 최적화 제한</td><td>컴파일러 최적화 (인라이닝) 가 추상화로 인해 제한될 수 있음</td><td>JIT 프로파일 기반 최적화 (PGO: Profile-Guided Optimization) 활용</td></tr><tr><td><strong>추상화 구조</strong></td><td>과도한 추상화</td><td>불필요한 추상화 계층은 복잡성과 호출 비용 증가</td><td>KISS 원칙 적용, 필요한 경우에만 추상화 도입</td></tr><tr><td></td><td>디버깅/추적 어려움</td><td>추상화가 깊어질수록 문제 원인 분석이 어려움</td><td>명확한 계층 구조 문서화 및 책임 구분</td></tr><tr><td><strong>의존성 관리</strong></td><td>DI 프레임워크 초기화 비용</td><td>의존성 주입 (DI: Dependency Injection) 시 생성 및 주입 비용 발생</td><td>싱글턴 활용, 필요한 경우 Lazy 주입 적용</td></tr><tr><td><strong>캐싱 전략</strong></td><td>구현체별 캐싱</td><td>각기 다른 구현체가 다른 방식으로 캐싱 처리</td><td>데코레이터 패턴 활용, 캐싱 로직 분리</td></tr><tr><td></td><td>리플렉션/메타데이터 캐싱</td><td>런타임에 발생하는 리플렉션 비용 증가</td><td>타입 정보 캐싱 등 메타데이터 최적화 적용</td></tr><tr><td><strong>네트워크 최적화</strong></td><td>원격 호출/직렬화 비용</td><td>분산 시스템 내 인터페이스 호출은 네트워크 오버헤드 발생</td><td>배치 처리, 비동기 패턴, 효율적 직렬화 (예: Protocol Buffers 등) 적용</td></tr></tbody></table><h3 id=주목할-내용-정리>주목할 내용 정리<a hidden class=anchor aria-hidden=true href=#주목할-내용-정리>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>추상화</strong></td><td>인터페이스 / 추상 클래스</td><td>구현을 분리하고 유연한 구조를 제공하며, 변경에 강한 설계를 가능하게 함</td></tr><tr><td><strong>설계 원칙</strong></td><td>DIP (Dependency Inversion Principle)</td><td>고수준 모듈과 저수준 모듈 모두가 추상화에 의존하도록 설계하는 SOLID 원칙</td></tr><tr><td></td><td>ISP (Interface Segregation Principle)</td><td>클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 분리하는 원칙</td></tr><tr><td></td><td>OCP (Open-Closed Principle)</td><td>시스템은 확장에는 열려 있고 수정에는 닫혀 있어야 함</td></tr><tr><td><strong>디자인 패턴</strong></td><td>전략 패턴 (Strategy)</td><td>알고리즘을 캡슐화하여 런타임에 교체 가능하게 만드는 패턴</td></tr><tr><td></td><td>팩토리 패턴 (Factory)</td><td>객체 생성 로직을 추상화하여 캡슐화</td></tr><tr><td></td><td>어댑터 패턴 (Adapter)</td><td>서로 다른 인터페이스 간의 호환성을 제공하는 연결 패턴</td></tr><tr><td></td><td>데코레이터 패턴 (Decorator)</td><td>객체에 기능을 동적으로 추가 가능</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>계층형 아키텍처</td><td>계층 간 추상화를 통한 모듈 간 결합도 감소</td></tr><tr><td></td><td>헥사고날 아키텍처 (Hexagonal)</td><td>포트와 어댑터를 통해 외부 의존성과 내부 도메인을 분리</td></tr><tr><td></td><td>클린 아키텍처 (Clean Architecture)</td><td>의존성의 방향을 내부 비즈니스 로직으로만 향하도록 설계</td></tr><tr><td><strong>기술적 구현</strong></td><td>DI (Dependency Injection)</td><td>런타임에 외부에서 객체를 주입하여 결합도를 낮추는 기법</td></tr><tr><td></td><td>IoC (Inversion of Control)</td><td>객체 생성 및 제어 책임을 프레임워크 또는 컨테이너로 위임</td></tr><tr><td></td><td>AOP (Aspect-Oriented Programming)</td><td>로깅, 트랜잭션 등 횡단 관심사를 모듈화</td></tr><tr><td><strong>코드 유지보수</strong></td><td>인프라 분리</td><td>구현 클래스 교체가 쉬워 테스트 및 유지보수 용이</td></tr><tr><td><strong>객체 캡슐화</strong></td><td>인터페이스 중심 설계</td><td>클라이언트는 구체 구현이 아닌 추상에 의존하여 시스템의 유연성과 확장성이 증가</td></tr><tr><td><strong>적용 분야</strong></td><td>결제, 로깅, 데이터 접근</td><td>외부 변화에 강한 시스템 구현에 활용 가능</td></tr></tbody></table><h3 id=하위-주제로-분류한-추가-학습-내용>하위 주제로 분류한 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류한-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>Dependency Inversion Principle</td><td>고수준 모듈이 저수준 모듈에 의존하지 않도록 추상화 중심으로 설계</td></tr><tr><td></td><td>GRASP 원칙</td><td>객체지향 설계를 위한 9 가지 핵심 원칙 (Information Expert, Creator 등)</td></tr><tr><td></td><td>Law of Demeter</td><td>최소 지식 원칙으로 객체 간 직접적인 결합 최소화</td></tr><tr><td></td><td>Hollywood Principle</td><td>" 우리가 당신을 호출하겠다 " 는 제어 흐름의 역전 원칙</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Factory Pattern</td><td>객체 생성 책임을 추상화하여 구체 클래스를 감춤</td></tr><tr><td></td><td>Service Locator Pattern</td><td>런타임 시점에 서비스 인스턴스를 찾아주는 중앙 레지스트리 패턴</td></tr><tr><td></td><td>Strategy Pattern</td><td>알고리즘을 캡슐화하여 런타임에 교체 가능하게 만드는 행동 패턴</td></tr><tr><td></td><td>Abstract Factory Pattern</td><td>관련된 객체군을 일관성 있게 생성할 수 있도록 하는 생성 패턴</td></tr><tr><td></td><td>Proxy Pattern</td><td>객체 접근을 제어하는 대리자 제공 패턴</td></tr><tr><td><strong>구현 기법</strong></td><td>Dependency Injection (DI)</td><td>객체 간 의존성을 외부에서 주입받아 결합도를 낮추는 구현 기법</td></tr><tr><td></td><td>DI 컨테이너</td><td>Spring IoC, Unity, Autofac 등의 의존성 주입 프레임워크</td></tr><tr><td><strong>테스팅</strong></td><td>테스트 더블 (Test Double)</td><td>Mock, Stub, Spy, Fake 등을 이용한 테스트 전략</td></tr><tr><td></td><td>계약 테스트 (Contract Testing)</td><td>소비자 - 제공자 간 API 계약을 자동 검증하는 테스트 기법</td></tr><tr><td></td><td>통합 테스트 전략</td><td>실제 구현체와 외부 시스템을 함께 테스트하는 방법론</td></tr><tr><td><strong>성능 최적화</strong></td><td>객체 풀링 (Object Pooling)</td><td>객체 생성을 최소화하고 재사용하여 성능을 향상</td></tr><tr><td></td><td>지연 로딩 (Lazy Loading)</td><td>실제 필요 시점까지 객체 생성을 지연시켜 리소스 절약</td></tr></tbody></table><h3 id=관련-분야별-추가-학습-내용>관련 분야별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야별-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>마이크로서비스</td><td>서비스 간 인터페이스 설계</td><td>API Gateway, 서비스 메시 등을 통한 추상화</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>이벤트 인터페이스 설계</td><td>이벤트 스키마와 계약 정의</td></tr><tr><td></td><td>도메인 주도 설계 (DDD)</td><td>바운디드 컨텍스트</td><td>도메인별 인터페이스 경계 정의</td></tr><tr><td><strong>데이터베이스</strong></td><td>Repository 패턴</td><td>데이터 액세스 추상화</td><td>ORM 과 데이터베이스 독립성</td></tr><tr><td></td><td>Unit of Work 패턴</td><td>트랜잭션 추상화</td><td>비즈니스 트랜잭션과 기술적 트랜잭션 분리</td></tr><tr><td><strong>웹 개발</strong></td><td>MVC 패턴</td><td>계층 간 인터페이스</td><td>컨트롤러, 서비스, 레포지토리 계층 분리</td></tr><tr><td></td><td>RESTful API 설계</td><td>HTTP 인터페이스 설계</td><td>리소스 중심의 인터페이스 설계 원칙</td></tr><tr><td><strong>클라우드 네이티브</strong></td><td>서비스 메시</td><td>서비스 간 통신 추상화</td><td>Istio, Linkerd 등을 통한 네트워크 추상화</td></tr><tr><td></td><td>컨테이너 오케스트레이션</td><td>인프라 추상화</td><td>Kubernetes API 를 통한 인프라 추상화</td></tr></tbody></table><h3 id=주제와-관련하여-추가로-알아야-하거나-학습해야-할-내용들>주제와 관련하여 추가로 알아야 하거나 학습해야 할 내용들<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-추가로-알아야-하거나-학습해야-할-내용들>#</a></h3><table><thead><tr><th>관련 분야</th><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>마이크로서비스</td><td>서비스 간 인터페이스 설계</td><td>API Gateway, 서비스 메시, 컨트랙트 기반 통신 등</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>이벤트 인터페이스 설계</td><td>이벤트 스키마 정의와 발행/구독 구조 설계</td></tr><tr><td></td><td>도메인 주도 설계 (DDD)</td><td>바운디드 컨텍스트</td><td>도메인별 인터페이스 및 책임 경계 정의</td></tr><tr><td></td><td>Onion Architecture</td><td>계층 간 의존성 방향의 제한</td><td>핵심 도메인을 중심으로 한 계층 분리</td></tr><tr><td></td><td>Clean Architecture</td><td>핵심 로직과 인프라 분리</td><td>의존성 방향을 내부 도메인으로 향하게 함</td></tr><tr><td></td><td>Microkernel Architecture</td><td>플러그인 기반 설계</td><td>유연한 기능 확장을 위한 핵심 - 확장 구조</td></tr><tr><td><strong>데이터베이스</strong></td><td>Repository 패턴</td><td>데이터 액세스 추상화</td><td>DB 기술과 비즈니스 로직의 분리</td></tr><tr><td></td><td>Unit of Work 패턴</td><td>트랜잭션 추상화</td><td>여러 DB 연산의 원자성 보장을 위한 단위 처리</td></tr><tr><td><strong>웹 개발</strong></td><td>MVC 패턴</td><td>계층 간 인터페이스 분리</td><td>Controller-Service-Repository 계층 구조</td></tr><tr><td></td><td>RESTful API 설계</td><td>HTTP 기반 인터페이스 설계</td><td>리소스 지향 설계, URI, 상태 코드, 메서드 표준화</td></tr><tr><td><strong>클라우드 네이티브</strong></td><td>서비스 메시</td><td>서비스 간 통신 추상화</td><td>Istio, Linkerd 등으로 관찰 가능성 및 보안 제어</td></tr><tr><td></td><td>컨테이너 오케스트레이션</td><td>인프라 추상화</td><td>Kubernetes API 및 배포 전략 중심 설계</td></tr><tr><td><strong>프레임워크/도구</strong></td><td>Spring DI</td><td>의존성 주입 프레임워크</td><td>IoC 컨테이너를 통한 구성 및 주입 자동화</td></tr><tr><td></td><td>IoC Container</td><td>제어의 역전 구현 도구</td><td>런타임 객체 생성 및 의존성 주입 관리</td></tr><tr><td><strong>객체지향 설계</strong></td><td>Interface-based Design</td><td>인터페이스 중심 설계</td><td>객체 간 결합도 최소화 및 테스트 용이성 확보</td></tr><tr><td></td><td>SOLID 원칙</td><td>객체지향 설계 원칙</td><td>단일 책임, 개방 - 폐쇄, 리스코프 치환, 인터페이스 분리, 의존성 역전</td></tr><tr><td><strong>테스트/품질보증</strong></td><td>테스트 더블</td><td>Mock, Stub, Spy, Fake 등</td><td>단위 테스트 및 계약 테스트 용 객체</td></tr><tr><td></td><td>계약 테스트</td><td>Interface 기반 상호작용 검증</td><td>생산자 - 소비자 간 API 계약 자동화 테스트</td></tr><tr><td><strong>유지보수/리팩토링</strong></td><td>코드 리팩토링</td><td>추상화 적용 및 코드 구조 개선</td><td>SRP 및 DIP 원칙 기반 구조화</td></tr><tr><td><strong>성능 최적화</strong></td><td>추상화 계층 최적화</td><td>불필요한 계층 제거</td><td>호출 오버헤드 분석 및 성능 병목 제거</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>추상화 (Abstraction)</strong></td><td>복잡한 구현 세부사항을 감추고, 필요한 기능만 외부에 노출하는 설계 원칙</td></tr><tr><td><strong>구체화 (Concretion)</strong></td><td>실제 동작을 구현한 클래스나 객체</td></tr><tr><td><strong>인터페이스 (Interface)</strong></td><td>구현과 무관하게 동작의 명세만 정의하는 추상 계층</td></tr><tr><td><strong>추상 클래스 (Abstract Class)</strong></td><td>일부 구현을 포함할 수 있는 추상화 계층, 상속 기반 구조에 주로 사용</td></tr><tr><td><strong>계약 (Contract)</strong></td><td>인터페이스가 제공해야 하는 메서드와 그에 대한 동작 규약</td></tr><tr><td><strong>DIP (Dependency Inversion Principle)</strong></td><td>고수준과 저수준 모듈 모두 추상화에 의존해야 한다는 설계 원칙</td></tr><tr><td><strong>DI (Dependency Injection)</strong></td><td>객체의 의존성을 외부에서 주입하여 결합도를 낮추는 설계 기법</td></tr><tr><td><strong>IoC (Inversion of Control)</strong></td><td>객체 생성과 제어 책임을 외부 (컨테이너 등) 로 위임하는 설계 원칙</td></tr><tr><td><strong>팩토리 패턴 (Factory Pattern)</strong></td><td>객체 생성 책임을 팩토리 클래스로 위임해, 클라이언트가 구체 클래스에 의존하지 않도록 하는 패턴</td></tr><tr><td><strong>서비스 로케이터 패턴 (Service Locator Pattern)</strong></td><td>클라이언트가 서비스의 구체 구현을 알지 않고도 접근할 수 있도록 레지스트리 역할 수행</td></tr><tr><td><strong>Low Coupling (낮은 결합도)</strong></td><td>구성 요소 간 상호 의존성이 낮은 상태로, 변경 영향 최소화에 유리</td></tr><tr><td><strong>High Cohesion (높은 응집도)</strong></td><td>구성 요소 내 책임이 밀접하게 연관된 상태로, 책임 명확화 및 유지보수 용이</td></tr><tr><td><strong>결합도 (Coupling)</strong></td><td>모듈 간의 연결 정도를 나타내며, 낮을수록 유연한 구조</td></tr><tr><td><strong>응집도 (Cohesion)</strong></td><td>모듈 내부 구성 요소들이 얼마나 관련성 있게 응집되어 있는지를 나타내는 지표</td></tr><tr><td><strong>다형성 (Polymorphism)</strong></td><td>동일한 인터페이스를 통해 여러 다른 구현을 사용할 수 있는 객체지향 특성</td></tr><tr><td><strong>런타임 바인딩 (Runtime Binding)</strong></td><td>실행 시점에 어떤 구체 구현이 호출될지 결정되는 메커니즘</td></tr><tr><td><strong>제어 역전 (Inversion of Control)</strong></td><td>애플리케이션이 아닌 프레임워크가 객체의 흐름을 제어하는 설계 패턴</td></tr><tr><td><strong>서비스 로케이터 (Service Locator)</strong></td><td>런타임에 서비스 인스턴스를 찾아 제공하는 레지스트리</td></tr><tr><td><strong>테스트 더블 (Test Double)</strong></td><td>테스트 용으로 실제 객체를 대신하는 객체 (Mock, Stub, Spy, Fake 등)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=원칙-및-개념>원칙 및 개념<a hidden class=anchor aria-hidden=true href=#원칙-및-개념>#</a></h3><ul><li><a href=https://roadmap.sh/software-design-architecture/software-design-principles/program-against-abstractions>Program Against Abstractions - Roadmap.sh</a></li><li><a href=https://en.wikipedia.org/wiki/Abstraction_principle_%28computer_programming%29>Abstraction principle (Wikipedia)</a></li><li><a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>Dependency inversion principle - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Interface_segregation_principle>Interface segregation principle - Wikipedia</a></li><li><a href=https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design>SOLID: The First 5 Principles of Object Oriented Design - DigitalOcean</a></li><li><a href=https://softengbook.org/chapter5>Chapter 5: Design Principles – Software Engineering: A Modern Approach</a></li><li><a href=https://thevaluable.dev/abstraction-type-software-example/>What Are Abstractions in Software Engineering with Examples - The Valuable Dev</a></li><li><a href=https://swimm.io/learn/system-design/6-software-design-principles-used-by-successful-engineers>6 Software Design Principles Used by Successful Engineers - Swimm</a></li></ul><h3 id=dip-및-인터페이스-설계>DIP 및 인터페이스 설계<a hidden class=anchor aria-hidden=true href=#dip-및-인터페이스-설계>#</a></h3><ul><li><a href=https://embeddedartistry.com/fieldmanual-terms/dependency-inversion-principle/>Dependency Inversion Principle - Embedded Artistry</a></li><li><a href=https://goforgoldman.com/posts/interfaces/>Understanding Interfaces and Dependency Inversion - GoForGoldman</a></li><li><a href=https://www.baeldung.com/java-interface-segregation>Interface Segregation Principle in Java - Baeldung</a></li><li><a href=https://stackify.com/dependency-inversion-principle/>Dependency Inversion Principle Explained - Stackify</a></li><li><a href=https://stackify.com/interface-segregation-principle/>Interface Segregation with Code Examples - Stackify</a></li></ul><h3 id=아키텍처-및-프레임워크>아키텍처 및 프레임워크<a hidden class=anchor aria-hidden=true href=#아키텍처-및-프레임워크>#</a></h3><ul><li><a href=https://martinfowler.com/articles/injection.html>Martin Fowler - Inversion of Control Containers</a></li><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans>Spring Framework - Dependency Injection (공식 문서)</a></li><li><a href=https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>Clean Architecture 설명서 - Uncle Bob</a></li><li><a href=https://www.simform.com/blog/software-architecture-patterns/>10 Software Architecture Patterns You Must Know About - Simform</a></li><li><a href=https://www.redhat.com/en/blog/14-software-architecture-patterns>14 Software Architecture Design Patterns to Know - Red Hat</a></li></ul><h3 id=기타-참고-블로그>기타 참고 블로그<a hidden class=anchor aria-hidden=true href=#기타-참고-블로그>#</a></h3><ul><li><a href=https://javien.tistory.com/10>의존성 역전 원칙과 포트-어댑터 아키텍처 - Javien 블로그</a></li><li><a href=https://jtm0609.tistory.com/186>객체지향 설계 원칙(SOLID) - JTM 블로그</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>