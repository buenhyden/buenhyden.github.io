<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Architecture & Design | hyunyoun's Blog</title><meta name=keywords content="System-Architecture-and-Design"><meta name=description content="System Architecture & Design - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System Architecture & Design"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System Architecture & Design"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Architecture \u0026 Design","item":"https://buenhyden.github.io/posts/system-architecture--design/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>System Architecture & Design</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Design Methodology</h2></header><div class=entry-content><p>Design Methodology Design Methodology 는 " 무엇을 " 만드는지를 " 어떻게 " 구현 가능한 설계 산출물로 구체화하는 체계다. 프로세스 (분석→아키텍처→세부 설계), 표기 (UML·DFD 등), 원칙 (SOLID·단계적 세분화), 지원 도구 (CASE, CI/CD) 로 구성된다. 구조적·객체지향·도메인·모델 구동형 등 다양한 유형이 있으며, 각 방법론은 목표 품질, 팀 규모, 도메인 복잡도, 변경 빈도에 따라 선택·혼합된다. 올바른 선택과 지속적 피드백이 생산성과 유지보수성을 크게 좌우한다.
핵심 개념 설계 방법론 (Design Methodology) 은 문제 해결을 위한 체계적인 절차와 원칙, 도구의 집합이다. 이는 단순히 도구나 기법이 아니라, 문제 정의, 해결책 탐색, 평가, 반복을 포함하는 일련의 프로세스와 철학을 의미한다.
주요 관점은 사용자 중심 (User-centric), 반복 (Iterative), 협업 (Collaborative), 실험 (Experimental) 이다.
...</p></div><footer class=entry-footer><span title='2025-06-06 16:29:00 +0000 UTC'>June 6, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Design Methodology" href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-methodology/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting vs. Throttling</h2></header><div class=entry-content><p>Rate Limiting vs. Throttling Rate Limiting과 Throttling은 API 설계와 관리에서 핵심적인 요소로, 시스템의 안정성과 보안을 유지하는 데 중요한 역할을 한다.
Rate Limiting과 Throttling은 모두 시스템 보호와 최적화를 위한 중요한 기술이지만, 그 목적과 구현 방식에는 명확한 차이가 있다. Rate Limiting은 특정 시간 내 허용되는 요청 수를 제한하여 남용을 방지하는 데 중점을 두는 반면, Throttling은 요청 처리 속도를 조절하여 시스템 리소스를 효율적으로 사용하는 데 중점을 둔다.
실제 애플리케이션에서는 두 기술을 함께 사용하여 더욱 견고하고 효율적인 시스템을 구축하는 것이 일반적입니다. Rate Limiting을 통해 과도한 요청을 차단하고, Throttling을 통해 허용된 요청을 적절한 속도로 처리함으로써 시스템의 안정성과 성능을 모두 확보할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-25 13:08:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting vs. Throttling" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting-vs-throttling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service per VM</h2></header><div class=entry-content><p>Service per VM “Service per-VM” (VM당 서비스) 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식이다. 이 패턴의 주요 특징과 장단점을 자세히 살펴보겠습니다.
“Service per-VM” 패턴은 강력한 격리와 리소스 관리를 제공하지만, 리소스 오버헤드와 관리 복잡성 증가라는 대가가 따른다. 이 패턴은 높은 수준의 격리가 필요하거나 서비스 간 리소스 경쟁을 최소화해야 하는 경우에 적합하다.
그러나 리소스 효율성과 빠른 배포가 중요한 경우에는 다른 배포 패턴을 고려해볼 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:36:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per VM" href=https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-vm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multiple Services per Host</h2></header><div class=entry-content><p>Multiple Services per Host “Multiple Services per Host” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다.
이 패턴에서는 하나 이상의 물리적 또는 가상 호스트를 준비하고, 각 호스트에 여러 개의 서비스 인스턴스를 실행한다. 이는 전통적인 애플리케이션 배포 방식을 반영한 것이다.
이 패턴은 리소스 효율성과 배포 용이성이라는 장점이 있지만, 복잡성 증가와 서비스 간 격리 부족이라는 단점도 있다. 따라서 프로젝트의 요구사항과 규모에 따라 신중하게 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multiple Services per Host" href=https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/multiple-services-per-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service per Container</h2></header><div class=entry-content><p>Service per-Container “Service per-Container” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.
주요 특징 독립성: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다. 경량화: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다. 이식성: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 “한 번 빌드하고 어디서나 실행"이라는 원칙을 실현한다. 버전 관리: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다. 장점 확장성: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다. 장애 격리: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다. 기술 스택 다양성: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다. 배포 유연성: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다. 단점 복잡성 증가: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다. 리소스 오버헤드: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다. 통신 오버헤드: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다. 구현 시 고려사항 컨테이너 오케스트레이션: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다. 서비스 디스커버리: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다. 로깅 및 모니터링: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다. 보안: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다. 컨테이너 이미지 최적화 기반 이미지 최소화 멀티 스테이지 빌드 적용 캐시 레이어 최적화 불필요한 파일 제거 네트워킹 서비스간 통신 설정 네트워크 보안 정책 로드 밸런싱 구현 방법 컨테이너 이미지 생성: 각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다. Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다. 컨테이너 오케스트레이션: Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다. 서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다. 모니터링 및 로깅 설정: Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다. 예시 예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per Container" href=https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-container/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Single Service per Host</h2></header><div class=entry-content><p>Single Service per Host “Single Service per Host” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.
Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.
Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Single Service per Host" href=https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/single-service-per-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Serverless deployment</h2></header><div class=entry-content><p>Serverless Deployment Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 접근 방식이다.
Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.
결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:34:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless deployment" href=https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/serverless-deployment/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Architecture Principles</h2></header><div class=entry-content><p>Architecture Principles 아키텍처 원칙 (Architectural Principles) 은 소프트웨어 시스템 설계와 구현에 있어 기본이 되는 지침과 규칙들의 집합이다. 이러한 원칙들은 시스템의 품질, 유지보수성, 확장성, 성능 등을 향상시키기 위한 근본적인 접근 방식을 제공한다. 아키텍처 원칙은 소프트웨어 개발 라이프사이클 전반에 걸쳐 적용되며, 설계 결정에 일관성을 부여하고 개발팀이 공통된 방향성을 유지할 수 있도록 돕는다. 이는 단순한 코딩 규칙이나 패턴을 넘어서 시스템의 구조적 무결성을 보장하고, 비즈니스 요구사항과 기술적 제약 사이의 균형을 맞추는 데 기여한다.
핵심 개념 아키텍처 원칙 (Architecture Principles) 은 시스템 또는 소프트웨어 아키텍처 설계와 구현, 운영에서 일관성 있고 예측 가능한 품질을 확보하기 위한 고수준의 지침이다. 이 원칙은 조직의 비즈니스 목표와 IT 전략, 기술적 요구사항을 효과적으로 연결한다. 아키텍처 원칙은 보통 명확한 목적, 근거, 기대 효과, 적용 범위, 예외 상황 등을 포함하여 정의된다. 대표적인 아키텍처 원칙에는 모듈화 (Modularity), 느슨한 결합 (Loose Coupling), 높은 응집도 (High Cohesion), 단일 책임 원칙 (Single Responsibility Principle), 확장성 (Scalability), 보안 (Security), 표준화 (Standardization), 재사용성 (Reusability) 등이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-21 05:25:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Architecture Principles" href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles SOLID 원칙은 2000 년 Robert C. Martin 에 의해 체계화된 객체 지향 설계의 5 대 핵심 원칙이다. 단일 책임 (SRP), 개방/폐쇄 (OCP), 리스코프 치환 (LSP), 인터페이스 분리 (ISP), 의존성 역전 (DIP) 원칙으로 구성되어 있다. 이 원칙들은 코드의 결합도를 낮추고, 변경에 유연하며, 테스트와 유지보수를 쉽게 만들어준다. SOLID 는 현대 소프트웨어 개발에서 품질 높은 시스템 구축의 표준이자 필수 지침으로 널리 사용된다
핵심 개념 SOLID 원칙의 정의 SRP (Single Responsibility Principle): 클래스는 하나의 책임만 가져야 하며, 변경되는 이유도 하나여야 함 OCP (Open/Closed Principle): 소프트웨어 개체는 확장에는 열려있고 수정에는 닫혀있어야 함 LSP (Liskov Substitution Principle): 하위 타입은 상위 타입으로 대체 가능해야 함 ISP (Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함 DIP (Dependency Inversion Principle): 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 함 핵심 목표 코드의 유지보수성 (Maintainability) 향상 시스템 확장성 (Extensibility) 보장 코드 재사용성 (Reusability) 증대 테스트 용이성 (Testability) 확보 결합도 (Coupling) 감소 및 응집도 (Cohesion) 증가 배경 SOLID 원칙은 2000 년 Robert C. Martin(Uncle Bob) 이 “Design Principles and Design Patterns” 논문에서 처음 제시했다. 이후 Michael Feathers 가 SOLID 라는 약어를 도입했다. 이 원칙들은 수십 년간의 객체 지향 프로그래밍 경험과 모범 사례를 바탕으로 체계화되었으며, 애자일 소프트웨어 개발과 클린 코드 철학의 기초가 되었다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Design Patterns</h2></header><div class=entry-content><p>Software Design Patterns 디자인 패턴과 원칙은 현대 소프트웨어 개발의 근간을 이루는 개념으로, 1994 년 Gang of Four 가 정리한 23 가지 클래식 패턴을 중심으로 생성, 구조, 행위 패턴으로 분류되며, SOLID 등의 설계 원칙과 함께 적용되어 객체지향 소프트웨어의 품질과 유지보수성을 크게 향상시킨다. 이들은 개발자 간의 공통 언어 역할을 하며, 검증된 모범 사례를 제공하여 소프트웨어 개발의 효율성과 품질을 동시에 보장한다.
핵심 개념 소프트웨어 디자인 패턴 (Software Design Pattern) 은 객체 지향 설계에서 자주 발생하는 문제를 해결하기 위해 정립된 일반화된 설계 해법이다. 이는 특정 언어나 구현에 종속되지 않으며, 구조적 설계를 위한 반복 가능한 설계 템플릿 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-12-21 05:23:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Design Patterns" href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/system-architecture--design/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>