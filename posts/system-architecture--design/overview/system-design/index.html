<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Design Overview | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,System-Design,Scalable-Systems,Distributed-Systems"><meta name=description content="System Design 은 사용자의 요구사항을 바탕으로 시스템의 전반적인 아키텍처를 설계하는 작업으로, 컴포넌트 간의 인터페이스, 데이터 흐름, 확장성, 성능, 가용성, 유지보수를 고려한 설계이다. 이 과정은 견고한 시스템 구축 및 운영 효율성 확보에 필수적이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System Design Overview"><meta property="og:description" content="System Design 은 사용자의 요구사항을 바탕으로 시스템의 전반적인 아키텍처를 설계하는 작업으로, 컴포넌트 간의 인터페이스, 데이터 흐름, 확장성, 성능, 가용성, 유지보수를 고려한 설계이다. 이 과정은 견고한 시스템 구축 및 운영 효율성 확보에 필수적이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-27T08:37:00+00:00"><meta property="article:modified_time" content="2025-05-27T08:37:00+00:00"><meta property="article:tag" content="Software-Engineering"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="Scalable-Systems"><meta property="article:tag" content="Distributed-Systems"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System Design Overview"><meta name=twitter:description content="System Design 은 사용자의 요구사항을 바탕으로 시스템의 전반적인 아키텍처를 설계하는 작업으로, 컴포넌트 간의 인터페이스, 데이터 흐름, 확장성, 성능, 가용성, 유지보수를 고려한 설계이다. 이 과정은 견고한 시스템 구축 및 운영 효율성 확보에 필수적이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":4,"name":"System Design Overview","item":"https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"System Design Overview","name":"System Design Overview","description":"System Design 은 사용자의 요구사항을 바탕으로 시스템의 전반적인 아키텍처를 설계하는 작업으로, 컴포넌트 간의 인터페이스, 데이터 흐름, 확장성, 성능, 가용성, 유지보수를 고려한 설계이다. 이 과정은 견고한 시스템 구축 및 운영 효율성 확보에 필수적이다.","keywords":["Software-Engineering","System-Design","Scalable-Systems","Distributed-Systems"],"articleBody":"System Design System Design 은 요구사항을 충족하는 대규모 시스템을 설계하고 구성하는 과정으로, 기능적/비기능적 요구사항을 고려해 컴포넌트 간 관계, 데이터 흐름, 장애 대응, 확장 구조를 정의한다. 이는 클라우드 환경, 분산 시스템, 고가용성 아키텍처 설계 등과 밀접하며, 효율적인 아키텍처 설계를 통해 성능, 확장성, 유지보수성을 극대화하는 것이 목적이다. 실무에서는 설계 원칙과 패턴, 트레이드오프 분석 등이 핵심이다.\n등장 배경 및 발전 과정 시스템 디자인은 인터넷과 클라우드 컴퓨팅의 발전과 함께 등장했다.\n초기 단일 서버 아키텍처에서 시작하여 웹 2.0 시대의 대용량 트래픽 처리 필요성, 클라우드 컴퓨팅의 보편화, 마이크로서비스 아키텍처의 등장으로 발전해왔다.\n1960 년대 -1980 년대: 메인프레임 시대\n중앙 집중식 컴퓨팅 단일 장애점 (Single Point of Failure) 문제 1990 년대 -2000 년대: 클라이언트 - 서버 아키텍처\n네트워크 컴퓨팅의 확산 3 계층 아키텍처의 등장 2000 년대 중반: 웹 2.0 과 대용량 트래픽\nGoogle, Amazon, Facebook 등의 급성장 기존 아키텍처의 한계 노출 2010 년대: 클라우드와 마이크로서비스\nAWS, Azure 등 클라우드 플랫폼 보편화 Netflix, Uber 등의 마이크로서비스 사례 2020 년대: 클라우드 네이티브와 서버리스\n컨테이너 기반 배포 서버리스 컴퓨팅의 확산 목적 및 필요성 목적 비즈니스 연속성 보장\n서비스 중단 시간 최소화 사용자 경험 일관성 유지 비용 효율성 달성\n리소스 사용량 최적화 운영 비용 절감 확장성 확보\n사용자 증가에 대한 대응 데이터 증가에 대한 처리 필요성 디지털 전환 가속화\n모든 산업의 디지털화 온라인 서비스 의존도 증가 글로벌 서비스 요구\n24/7 서비스 제공 필요 지역별 특성 고려 데이터 폭증 대응\n빅데이터 처리 요구 실시간 분석 필요 핵심 개념 System Design은 요구사항 (기능적/비기능적) 을 충족시키는 시스템을 구성하는 아키텍처적 방법론으로, 복잡한 시스템을 모듈화 (Modularization), 인터페이스 정의, 통신 설계, 데이터 저장소 구조화 등을 통해 안정적이고 확장 가능하게 구축하는 데 중점을 둔다.\n기본 개념 확장성 (Scalability)\n시스템이 증가하는 부하를 처리할 수 있는 능력 수직 확장 (Scale Up): 더 강력한 하드웨어 사용 수평 확장 (Scale Out): 더 많은 서버 추가 신뢰성 (Reliability)\n시스템이 예상대로 지속적으로 작동하는 능력 장애 허용성 (Fault Tolerance) 포함 평균 고장 간격 시간 (MTBF: Mean Time Between Failures) 가용성 (Availability)\n시스템이 운영 가능한 상태를 유지하는 시간의 비율 99.9% (8.76 시간/년), 99.99% (52.56 분/년) 등으로 측정 일관성 (Consistency)\n모든 노드가 동일한 시점에 동일한 데이터를 보는 것 강한 일관성, 약한 일관성, 결과적 일관성으로 분류 분할 허용성 (Partition Tolerance)\n네트워크 분할이 발생해도 시스템이 계속 동작하는 능력 CAP 정리의 핵심 요소 심화 개념 로드 밸런싱 (Load Balancing)\n들어오는 요청을 여러 서버에 분산 Round Robin, Weighted Round Robin, Least Connections 등 캐싱 (Caching)\n자주 접근하는 데이터를 빠르게 접근할 수 있는 저장소에 보관 CPU 캐시, 메모리 캐시, 디스크 캐시, 분산 캐시 데이터베이스 설계\nRDBMS vs NoSQL 선택 데이터 모델링, 인덱싱, 쿼리 최적화 마이크로서비스 아키텍처\n작고 독립적인 서비스들로 애플리케이션을 구성 서비스 간 통신, 데이터 일관성, 배포 복잡성 관리 실무 구현과의 연관성 실무 요소 관련 핵심 개념 설명 트래픽 급증 대응 수평 확장성 (Horizontal Scalability) 다수의 서버 인스턴스를 통한 처리 능력 확장 장애 허용 설계 장애 분리 (Fault Isolation), 복제 (Replication) 시스템 구성요소의 독립성과 데이터 중복으로 장애 확산 방지 지연 시간 최소화 캐싱 (Caching), CDNs 자주 접근하는 데이터 또는 정적 파일을 메모리 또는 에지 서버에 저장 비동기 처리 메시지 큐 (Message Queue) 요청과 처리의 비동기화를 통한 시스템 유연성 확보 시스템 유지보수 모듈화 (Modularization) 책임이 명확한 컴포넌트로 분리하여 유지보수 용이 주요 기능 및 역할 주요 기능 아키텍처 설계\n시스템 구조 정의 컴포넌트 간 상호작용 설계 성능 최적화\n응답 시간 개선 처리량 (Throughput) 향상 보안 설계\n인증 및 인가 체계 데이터 암호화 모니터링 및 관찰성\n시스템 상태 추적 장애 예측 및 대응 주요 역할 비즈니스 요구사항 기술 구현\n기능적 요구사항을 기술적으로 해결 비기능적 요구사항 (성능, 보안 등) 충족 기술 스택 선택 및 통합\n적절한 기술 조합 결정 기술 간 호환성 보장 위험 관리\n기술적 위험 식별 및 완화 장애 복구 계획 수립 기능과 역할의 관계 시스템 설계의 기능들은 계층적 관계를 형성한다:\n아키텍처 설계가 기반을 제공 성능 최적화가 품질을 보장 보안 설계가 신뢰성을 확보 모니터링이 지속적 개선을 지원 특징 복잡성 관리 계층화와 모듈화를 통한 복잡성 분해 관심사 분리 (Separation of Concerns) 원칙 적용 트레이드오프 인식 CAP 정리에 따른 선택과 집중 성능 vs 비용, 일관성 vs 가용성 등의 균형 진화 가능성 요구사항 변화에 대한 적응성 점진적 개선 (Incremental Improvement) 지원 측정 가능성 정량적 지표를 통한 성능 평가 SLA (Service Level Agreement) 기반 운영 모듈화된 아키텍처를 통해 복잡성을 관리하고, 명확한 인터페이스 정의로 컴포넌트 간 결합도를 낮춘다. 설계 패턴 적용으로 일관성을 유지하며, 지속적인 모니터링으로 측정 가능성을 확보한다.\n핵심 원칙 시스템 설계는 사용자 요구를 분석하고, 이를 바탕으로 시스템 구조와 구성 요소, 데이터 흐름, 상호작용 등을 설계한다. 설계된 시스템은 확장성, 신뢰성, 성능, 보안 등 품질 속성을 보장하며, 실제 구현, 테스트, 배포를 거쳐 운영된다.\n설계 원칙 단일 책임 원칙 (Single Responsibility Principle)\n각 컴포넌트는 하나의 책임만 가져야 함 변경 이유가 하나여야 함 느슨한 결합 (Loose Coupling)\n컴포넌트 간 의존성 최소화 인터페이스를 통한 상호작용 높은 응집성 (High Cohesion)\n관련된 기능을 하나의 모듈로 그룹화 내부 요소들 간 강한 연관성 확장성 우선 설계\n미래 확장을 고려한 구조 수평 확장이 용이한 아키텍처 운영 원칙 장애 격리 (Fault Isolation)\n하나의 장애가 전체 시스템에 미치는 영향 제한 서킷 브레이커 패턴 적용 점진적 배포 (Gradual Deployment)\n카나리 배포, 블루 - 그린 배포 등 위험 최소화 자동화 우선\n반복적 작업의 자동화 인적 오류 감소 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 카테고리 고려사항 주의사항 권장사항 설계 전략 요구사항 정의 및 정제 비기능 요구사항 (NFR) 누락 성능, 가용성, 확장성, 장애 복구 등을 포함한 NFR 명세 작성 도메인 분리 과도한 마이크로서비스 분할 DDD 기반 서비스 책임 경계 정의 시스템 목표 설정 모든 요구사항에 동일 우선순위 부여 우선순위 기반의 기능/비기능 분류 및 문서화 기술 아키텍처 기술 스택 선정 최신 기술만 도입하거나, 기술 다양성으로 복잡도 증가 조직 역량, 유지보수성, 커뮤니티 성숙도 고려한 선택 데이터 일관성 전략 분산 트랜잭션 단순화 혹은 과소평가 Event Sourcing, CQRS, SAGA 등 활용 API 및 인터페이스 설계 버전 관리 없이 공용 인터페이스 변경 명확한 계약 기반 API 설계, 버전 관리 (V1/V2…) 도입 배포 전략 배포 자동화 수동 배포로 인한 휴먼 에러 CI/CD 파이프라인 구축, 자동화 테스트/롤백 적용 점진적 배포 전체 서비스 동시 배포로 위험 증가 카나리 배포, 블루 - 그린, 피쳐 플래그 적용 장애 시나리오 플랜 단일 장애 지점 (SPOF) 존재 구성요소 이중화, 시뮬레이션 기반 복구 전략 수립 운영/관찰성 모니터링 및 관찰성 확보 분산 환경에서 로그/추적 누락 구조화된 로깅, 메트릭 표준화, OpenTelemetry 기반 분산 추적 성능 관리 캐시 설계 없이 확장성만 고려 다층 캐시 구조, TTL, 캐시 무효화 정책 명확화 장애 대응 및 복원력 서킷브레이커/리트라이 정책 미비 Circuit Breaker, Timeout, 백업 시스템 적용 보안 설계 인증 및 인가 체계 접근 제어 없이 내부 서비스 노출 OAuth2, JWT, mTLS, API Gateway 기반 인증/인가 네트워크 보안 내부 통신 암호화 미적용 제로 트러스트 모델, 서비스 간 통신 암호화 적용 문서화 및 리뷰 시스템/아키텍처 문서화 설계 문서 누락, 트레이드오프 설명 부재 ADR(Architecture Decision Record), 설계 흐름도, API 명세 작성 및 지속적 유지 아키텍처 리뷰와 피드백 일부 개발자 중심 의사결정 Cross-functional Review, Peer Review 포함 최적화하기 위한 고려사항 및 주의할 점 카테고리 최적화 대상 핵심 설명 주의할 점 권장 사항 및 전략 1. 성능 최적화 응답 시간, 처리량, I/O SLA 기반 응답 속도, Throughput 확보 조기 최적화, 복잡도 증가 병목 구간 프로파일링, 80/20 법칙 적용, 인덱싱/배치/비동기 처리 캐시 전략 읽기 성능 향상 및 부하 분산 캐시 일관성, Stale Data TTL 설정, Write-through/Write-back, LRU/LFU 적용 데이터 접근 최적화 필요 시점에 최소한의 데이터 로드 Lazy Load 시 의도치 않은 지연 Index, Batching, Lazy Loading, Prefetch 적용 GC 및 메모리 관리 응답 지연 방지, GC Pause 최소화 힙 사이즈 과소/과대 설정 GC 튜닝 (G1GC 등), 메모리 프로파일링, 힙 크기 조절 2. 확장성 최적화 수평 확장, 분산 처리 스케일아웃 전략에 따른 부하 분산 상태 관리 복잡성 (세션, 상태 저장소 등) Stateless 설계, 분산 세션 저장소 (Redis 등), Service Discovery 적용 오토스케일링 트래픽 증가/감소 대응 스케일 인/아웃 지연, 잘못된 임계치 설정 예측 기반 스케일링, 최소 예비 인스턴스 확보 데이터 분산 데이터 파티셔닝/복제 일관성 모델 선택 (CAP) 문제 Sharding, Consistent Hashing, Read/Write 분리, Eventual Consistency 적용 3. 신뢰성/복원력 장애 허용, 복제 전략 장애 발생 시 자동 복구 및 서비스 지속 보장 복잡도 증가, 동기화 비용 Health check, Failover 설계, Circuit Breaker, Retry with Jitter 재시도/타임아웃/백오프 네트워크 장애, 일시적 실패 대응 무한 루프, 리소스 고갈 지수 백오프, Retry 제한, Timeout 설정, Circuit Breaker 패턴 적용 4. 비용 최적화 리소스 할당, 스케일 정책 성능 유지하면서 비용 효율 확보 과도한 절감으로 성능 저하 예약 인스턴스/스팟 인스턴스 활용, Auto-scaling + 모니터링 기반 비용 관리 저장소 및 아카이빙 장기 보관/비정기 조회 데이터 저장 비용 최소화 압축률 vs CPU 사용량 Trade-off Hot-Cold 데이터 분리, Glacier/S3 IA 같은 계층형 스토리지 사용 5. 네트워크 최적화 CDN, 지연 최소화, 메시지 크기 최적화 요청 지연 및 대역폭 사용 최적화 캐시 미스, 메시지 직렬화 오버헤드 CDN 정책 설정, 캐시 히트율 모니터링, 메시지 압축 (Protobuf, Avro), Gzip 전송 적용 6. 관측 가능성 (Observability) 트레이싱, 로깅, 모니터링 시스템 상태, 병목, 장애 추적 과도한 로깅, 개인정보 유출 가능성 OpenTelemetry, Prometheus + Grafana, Jaeger/Zipkin 도입 7. 데이터베이스 최적화 쿼리 성능, 인덱스 관리 DB 부하 분산 및 빠른 검색 과도한 인덱스 → 쓰기 성능 저하 쿼리 플랜 분석, 인덱스 리밸런싱, 파티셔닝/Read Replica 활용 8. 아키텍처 구조 동기/비동기 흐름 설계 성능, 복원력, 확장성에 직접적 영향 적절하지 않은 모델 선택 시 오히려 병목 발생 Queue/Event 기반 비동기 처리, Saga/CQRS 등 설계 적용 9. 운영/테스트 최적화 부하 테스트, 트래픽 예측 실제 상황 미반영 가능성 테스트 커버리지 부족, 불완전한 모의 데이터 부하 시뮬레이션 (Apache JMeter, k6 등), 트래픽 기반 테스트 자동화 System Design 실무 설계 예제 실시간 채팅 시스템 설계 요구사항:\n기능적: 사용자 간 1:1 채팅 지원 메시지 읽음/안 읽음 표시 메시지 저장 및 조회 오프라인 메시지 푸시 알림 확장 가능한 구조 비기능적: 수십만 동시 사용자 처리 99.99% 가용성 메시지 지연 ≤ 200ms 저장 데이터의 내구성 확보 1 단계: 핵심 기능 정의 실시간 송수신 → WebSocket 메시지 중계 및 유실 방지 → 메시지 큐 (Kafka) 메시지 영속 저장 → NoSQL (MongoDB) 또는 Cassandra 빠른 채팅방 목록 조회 → Redis 캐시 푸시 알림 → Firebase 또는 SNS 2 단계: 시스템 아키텍처 구성 graph TD U[User Device] --\u003e WS[WebSocket Gateway] WS --\u003e LB1[Chat Load Balancer] LB1 --\u003e CS[Chat Server] CS --\u003e MQ[Kafka Topic] CS --\u003e C[Redis Cache] MQ --\u003e P[Message Processor] P --\u003e DB[\"NoSQL DB (Mongo/Cassandra)\"] P --\u003e PN[Push Notification Server] 3 단계: 주요 설계 결정 컴포넌트 선택 기술 설계 이유 WebSocket Gateway Nginx + WS 통신 실시간 양방향 통신 지원 메시지 브로커 Kafka 메시지 유실 방지, 확장성 데이터 저장소 MongoDB 또는 Cassandra 빠른 쓰기, 수평 확장 캐시 Redis 채팅방 리스트/메시지 캐싱 알림 시스템 Firebase / SNS 모바일 푸시 연동 각 구성 요소는 상황에 따라 기술 선택이 달라지며, 단순 비교가 아닌 요구사항 기반의 선택과 트레이드오프 판단이 중요하다.\n4 단계: 고려한 트레이드오프 선택 트레이드오프 Kafka 사용 고가용성과 메시지 유실 방지 → 시스템 복잡도 증가 WebSocket 실시간성 확보 → 커넥션 유지 비용 증가 NoSQL 사용 확장성 확보 → 트랜잭션 약화 가능 5 단계: 실시간 메시지 흐름 워크플로우 sequenceDiagram participant U as User participant G as WebSocket Gateway participant C as Chat Server participant K as Kafka participant P as Processor participant D as DB U-\u003e\u003eG: WebSocket 메시지 전송 G-\u003e\u003eC: 메시지 전달 C-\u003e\u003eK: Kafka Topic에 메시지 Push K-\u003e\u003eP: 메시지 Consume P-\u003e\u003eD: DB에 메시지 저장 P-\u003e\u003eG: ACK 또는 푸시 알림 전송 6 단계: 최적화 포인트 대상 전략 메시지 큐 처리 멀티 Consumer, 파티셔닝 메시지 저장 비동기 저장, 배치 쓰기 채팅방 리스트 Redis 기반 TTL 캐시 장애 대응 Kafka + Retry, Circuit Breaker 서버 스케일링 Horizontal Scaling + AutoScaling Group 주제와 관련하여 주목할 내용 카테고리 주제 핵심 항목 설명 아키텍처 설계 계층형 아키텍처 Presentation, Logic, Data Layer 명확한 책임 분리로 유지보수 및 확장성 확보 마이크로서비스 패턴 Service Mesh, CQRS, Event Sourcing 서비스 간 통신 및 상태 변경을 패턴 기반으로 분리/최적화 서버리스 아키텍처 AWS Lambda, Azure Functions 이벤트 기반 확장성과 운영 간소화를 제공하는 컴퓨팅 모델 Trade-offs Latency vs. Throughput, CAP Theorem 설계 시 성능, 일관성, 확장성 간의 균형을 고려한 의사결정 필수 성능 최적화 캐싱 Redis, Memcached, CDN, 브라우저 캐시 응답 속도 향상과 백엔드 부하 감소를 위한 다층 캐시 전략 적용 수평 확장 Auto Scaling Group, Kubernetes HPA 사용자 증가 및 트래픽 변화에 따른 유연한 확장 구조 설계 샤딩/복제 DB Sharding, Read Replicas 대용량 데이터 처리를 위한 수평적 확장 전략 통신 구조 클라이언트 - 서버 HTTP, REST, gRPC 등 전통적 1:1 통신 구조 기반, API 중심 구조 구현 비동기 메시징 Kafka, RabbitMQ, 메시지 큐 느슨한 결합 및 대규모 이벤트 기반 아키텍처에 적합 API 게이트웨이 인증/인가, 로깅, 라우팅 통합 진입점에서 다양한 기능을 담당하며 마이크로서비스의 핵심 구성 요소 데이터 동기화 CDC (Change Data Capture) 데이터 변경 사항 실시간 반영으로 시스템 간 정합성 유지 보안 설계 인증/인가 OAuth 2.0, JWT, RBAC 사용자 접근 제어 및 API 보호 표준 네트워크 보안 Zero Trust, mTLS 서비스 간 보안을 보장하는 네트워크 보안 모델 적용 장애 대응 내결함성 및 복구 전략 Circuit Breaker, Retry, Failover 장애 격리, 자동 회복, 중단 최소화를 위한 보호 패턴 이중화 Active-Active, Active-Passive 구성 단일 장애 지점 (SPOF) 제거를 위한 고가용성 전략 데이터 아키텍처 일관성 모델 Strong, Eventual, Causal Consistency 요구 사항에 따라 선택적으로 적용되는 일관성 보장 전략 데이터 저장 전략 데이터 레이크, 데이터 메시, 분산 DB 대규모·비정형·분산 데이터 처리를 위한 저장소 설계 전략 적용 관찰성과 운영 모니터링 Prometheus, Grafana 메트릭 기반의 실시간 상태 추적 및 대시보드 제공 분산 추적 OpenTelemetry, Jaeger, Zipkin 마이크로서비스 간 호출 관계 추적 및 성능 병목 파악 가능 로그 관리 중앙 집중형 로깅, 구조화 로그 장애 분석 및 실시간 감사를 위한 핵심 요소 배포 전략 CI/CD 자동화 GitOps, ArgoCD, Jenkins 인프라 및 코드의 안정적 릴리즈를 위한 자동화된 파이프라인 점진적 배포 블루 - 그린, 카나리, 피처 플래그 무중단 배포 및 사용자 영향 최소화를 위한 배포 전략 설계 문서화 의사결정 기록 ADR (Architecture Decision Record) 아키텍처 설계 및 기술 선택의 역사와 근거를 기록하여 지속 가능성 확보 시스템 흐름 문서화 API 스펙, 시퀀스/플로우 다이어그램 개발 및 협업 시 시스템 구조 파악과 온보딩에 중요한 문서 반드시 학습해야할 내용 카테고리 주제 핵심 항목 설명 및 핵심 개념 1. 분산 시스템 이론 일관성/가용성 이론 CAP, BASE, PACELC 분산 시스템의 근본 제약: 일관성 vs 가용성 vs 파티션 내성, 지연 - 일관성 트레이드오프 분석 트랜잭션 처리 ACID, 격리 수준, 동시성 제어 분산 트랜잭션 특성과 DB 일관성 보장 기법 (2PC, SAGA 포함) 분산 합의 알고리즘 Raft, Paxos, PBFT 분산 시스템에서의 일관된 상태 합의, 리더 선출, 블록체인 등에도 활용 2. 네트워크 및 통신 프로토콜 및 통신 구조 TCP/IP, HTTP/2·3, gRPC, WebSocket 효율적 데이터 전송을 위한 최신 통신 기술, 실시간 처리 및 바이너리 전송 최적화 API 설계 REST, RESTful, GraphQL, gRPC API 디자인 원칙 및 내부/외부 API 아키텍처 구분 (페이로드 최적화, 보안 포함) 3. 보안 및 인증/인가 인증/인가 모델 OAuth2, JWT, RBAC, ABAC API 보안 및 마이크로서비스 간 인증 방안 암호화/서명/해시 대칭/비대칭 암호화, 해시 함수, 디지털 서명 데이터 무결성과 기밀성 확보, 인증 및 무결성 검증 기술 적용 4. 설계 원칙/패턴 객체지향 및 구조적 설계 원칙 SOLID, KISS, DRY, YAGNI 유지보수성과 확장성을 높이는 기본 설계 원칙 디자인 패턴 싱글톤, 팩토리, 옵저버, 전략, 어댑터 등 구조적 설계 재사용을 위한 핵심 패턴들 아키텍처 스타일/패턴 Layered, Hexagonal, Clean Architecture, MSA 시스템 구성의 큰 틀, 의존성 관리, 도메인 중심 설계 적용 방식 고급 설계 패턴 CQRS, Event Sourcing, Saga, Circuit Breaker 이벤트 기반 구조와 회복탄력성 있는 시스템 설계 5. 데이터 설계 데이터 저장소 및 분산 처리 SQL vs NoSQL, Sharding, Replication, Partitioning 데이터 특성과 트래픽에 따른 적절한 저장소 선택 및 분산 전략 데이터 모델링 정규화/반정규화, 인덱싱, 파티셔닝 전략 읽기/쓰기 최적화를 위한 DB 구조 설계 전략 6. 성능 최적화 캐싱/로딩 전략 In-memory Cache, Distributed Cache, TTL, LRU 응답 지연 감소 및 트래픽 감소를 위한 캐시 설계 로드 밸런싱 라운드 로빈, Least Conn., IP Hash, Sticky Session 수평 확장을 위한 트래픽 분산 기법 비동기 처리 및 큐잉 Kafka, RabbitMQ, SQS, Celery, Message Patterns 병렬 처리, 이벤트 기반 설계의 핵심 컴포넌트 7. 운영 및 인프라 컨테이너 및 오케스트레이션 Docker, Kubernetes 마이크로서비스 배포 및 확장성을 위한 표준 플랫폼 CI/CD 지속적 통합/배포 파이프라인 구성 빠른 롤아웃/롤백을 위한 DevOps 핵심 전략 서비스 메시 및 트래픽 제어 Istio, Linkerd, Envoy 마이크로서비스 간 네트워크 제어 및 트래픽 정책 적용 8. 가용성 및 복원력 이중화/장애 허용 Failover, Health Check, Auto-healing 시스템 장애에 대응할 수 있는 복원력 설계 복원력 패턴 Circuit Breaker, Timeout, Retry, Bulkhead 장애 격리 및 전파 방지를 위한 핵심 제어 구조 9. 관측 가능성 모니터링 및 로깅 Prometheus, Grafana, ELK, Fluent Bit 시스템 상태 시각화 및 운영 이슈 사전 대응 분산 트레이싱 OpenTelemetry, Jaeger, Zipkin 마이크로서비스 트랜잭션 추적 및 병목 탐지 10. 시스템 구조 이해 모듈화 계층 구조, Bounded Context, 의존성 분리 확장 가능한 구조 및 책임 분리를 위한 모듈 설계 Client-Server 구조 Frontend-Backend 분리, API Gateway 요청 흐름/통신 모델에 대한 이해 (MVC → API Gateway 구조까지) 마이크로서비스 아키텍처 독립 배포, 각 서비스 간 느슨한 결합 대규모 시스템 확장을 위한 핵심 구조 용어 정리 카테고리 용어 설명 아키텍처 스타일 Monolith (모놀리식) 모든 기능이 하나의 애플리케이션에 통합된 구조로, 초기 개발은 단순하지만 확장성과 유지보수가 어려움 Microservices (마이크로서비스) 기능별로 분리된 작은 서비스들로 구성되어 독립 배포와 확장이 용이한 분산 아키텍처 Client-Server 클라이언트가 요청을 보내고 서버가 응답을 반환하는 전통적인 구조 Service Mesh 마이크로서비스 간 통신을 추상화하고 제어하는 인프라 계층 (ex: Istio) API Gateway 클라이언트 요청을 백엔드 서비스로 라우팅하고 인증, 로깅, 제한 등을 처리하는 진입점 Load Balancer 클라이언트 요청을 여러 서버에 균등하게 분산시켜 트래픽을 조절하는 장치 Event Sourcing 상태 변경을 이벤트로 기록하고, 이 이벤트들을 통해 현재 상태를 재구성하는 패턴 CQRS 명령 (Command) 과 조회 (Query) 를 분리하여 성능, 확장성, 보안성을 개선하는 아키텍처 패턴 Saga Pattern 분산 시스템에서 트랜잭션을 순차적 보상 작업으로 나누어 처리하는 패턴 데이터 처리 Sharding 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 방식 (스케일 아웃) Replication 데이터 복제를 통해 가용성과 내결함성 (Fault Tolerance) 확보 ACID 트랜잭션의 4 가지 속성: 원자성, 일관성, 격리성, 지속성 BASE NoSQL 기반 원칙: 기본적 가용성, 소프트 상태, 결과적 일관성 CQRS 조회와 명령을 분리하여 확장성과 성능을 높이는 설계 방식 Consistency 모든 노드에서 동일한 데이터 상태를 유지하는 성질 Partition Tolerance 네트워크 분할 상황에서도 시스템이 계속 동작하는 능력 확장성/성능 Horizontal Scaling 서버의 수를 늘려 트래픽과 데이터를 분산하여 처리 능력을 향상 Vertical Scaling 서버의 하드웨어 성능 (CPU, RAM 등) 을 높여 처리 능력을 강화 Caching 자주 접근하는 데이터를 메모리 등 빠른 저장소에 저장하여 응답 속도 향상 CDN 전 세계에 분산된 노드를 통해 콘텐츠를 가까운 위치에서 빠르게 전달 Load Balancing 요청을 여러 서버에 분산시켜 병목 현상을 방지하고 안정성을 확보 Throttling 클라이언트의 요청 속도를 제한하여 시스템을 보호 신뢰성/장애 대응 Circuit Breaker 외부 서비스 오류가 반복될 경우 빠르게 실패 처리하여 시스템 전체 장애 방지 Failover 장애 발생 시 자동으로 대기 시스템으로 전환하여 가용성 유지 Redundancy (이중화) 장애에 대비하여 동일 기능을 하는 시스템을 중복 구성 Availability 시스템이 정상적으로 작동할 수 있는 시간의 비율 (Uptime) 통신/메시징 REST API HTTP 기반의 동기 통신 인터페이스 메시지 브로커 비동기 메시지 전달을 위한 시스템 (Kafka, RabbitMQ 등) 메시지 큐 (Queue) 생산자가 보낸 메시지를 소비자가 순차적으로 처리하는 FIFO 구조 Pub/Sub 하나의 발행자가 다수의 구독자에게 메시지를 전달하는 방식 보안 OAuth 2.0 외부 애플리케이션이 제한된 접근 권한을 갖도록 하는 인증 프레임워크 JWT JSON 기반의 인증 토큰으로, 무상태 (stateless) 인증 방식 RBAC 역할 기반 접근 제어 방식으로 권한을 역할 단위로 관리 mTLS 클라이언트와 서버가 서로 인증하는 TLS 방식 운영/배포 CI/CD 지속적 통합 (Continuous Integration) 과 지속적 배포 (Continuous Deployment) GitOps Git 을 단일 진실의 소스로 사용하여 운영을 자동화하는 방식 Container 애플리케이션과 그 의존성을 패키징하여 격리된 환경에서 실행 Orchestration 여러 컨테이너의 배포, 확장, 관리를 자동화 (ex: Kubernetes) Immutable Deployment 서버를 수정하지 않고 새 인스턴스를 통해 배포하는 방식 Strangler Pattern 레거시 시스템을 점진적으로 새로운 시스템으로 교체하는 전략 모니터링/가시성 APM 애플리케이션의 성능을 모니터링하고 병목을 진단하는 도구 Distributed Tracing 여러 마이크로서비스에 걸친 요청 흐름 추적 SLA/SLO/SLI 서비스 수준 계약/목표/지표로 서비스 품질을 측정하고 약속하는 기준 참고 및 출처 Scalability, Availability, and Reliability Scalability, Availability, and Reliability: Core Principles for Building a Robust System Designing for scalability: Principles every engineer should know Scalable Software System Design: Key Principles, Best Practices Grokking Scalability in System Design: How I Learned the Techniques, Principles, and Best Practices System Design 총론 What is System Design? A Comprehensive Guide to System Architecture and Design Principles System Design Fundamentals – Design Gurus System Design Complete Guide – Swimm Systems Design – CIO Wiki System Architecture – InterviewBit Design Principles \u0026 Patterns Design Principles in System Design – GeeksforGeeks Design Patterns vs. Principles – Medium Software Design Pattern – Wikipedia Nonfunctional Requirements – Martin Fowler Caching \u0026 Load Balancing Caching – System Design Concept – GeeksforGeeks Load Balancer – System Design Interview Question – GeeksforGeeks Microservices Vs Monolith Microservices Pattern: Monolithic Architecture Microservices vs. Monolithic Architecture – Atlassian 실전 아키텍처 자료 AWS Well‑Architected Framework Google Cloud Architecture Center Microsoft Azure Architecture Center The Twelve‑Factor App Netflix Technology Blog High Scalability Martin Fowler’s Blog Kubernetes Documentation Cloud Native Computing Foundation (CNCF) 추가 학습 및 참고 리소스 System Design Cheatsheet – GitHub Gist (vasanthk) Top 20 System Design Concepts You Should Know – ByteByteGo 15 System Design Core Concepts – Medium / Interviewing.io System Design Tutorial – GeeksforGeeks A Comprehensive Guide to Fundamental Concepts of System Design – datmt Fundamentals of System Design – dev.to ","wordCount":"3313","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-05-27T08:37:00Z","dateModified":"2025-05-27T08:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">System Design Overview</h1><div class=post-description>System Design 은 사용자의 요구사항을 바탕으로 시스템의 전반적인 아키텍처를 설계하는 작업으로, 컴포넌트 간의 인터페이스, 데이터 흐름, 확장성, 성능, 가용성, 유지보수를 고려한 설계이다. 이 과정은 견고한 시스템 구축 및 운영 효율성 확보에 필수적이다.</div><div class=post-meta><span title='2025-05-27 08:37:00 +0000 UTC'>May 27, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20Architecture%20&%20Design/Overview/System-Design.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#system-design>System Design</a><ul><li><a href=#등장-배경-및-발전-과정>등장 배경 및 발전 과정</a></li><li><a href=#목적-및-필요성>목적 및 필요성</a></li><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#주요-기능-및-역할>주요 기능 및 역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#system-design-실무-설계-예제>System Design 실무 설계 예제</a></li><li><a href=#주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용</a></li><li><a href=#반드시-학습해야할-내용>반드시 학습해야할 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#scalability-availability-and-reliability>Scalability, Availability, and Reliability</a></li><li><a href=#system-design-총론>System Design 총론</a></li><li><a href=#design-principles--patterns>Design Principles & Patterns</a></li><li><a href=#caching--load-balancing>Caching & Load Balancing</a></li><li><a href=#microservices-vs-monolith>Microservices Vs Monolith</a></li><li><a href=#실전-아키텍처-자료>실전 아키텍처 자료</a></li><li><a href=#추가-학습-및-참고-리소스>추가 학습 및 참고 리소스</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=system-design>System Design<a hidden class=anchor aria-hidden=true href=#system-design>#</a></h2><p>System Design 은 요구사항을 충족하는 대규모 시스템을 설계하고 구성하는 과정으로, 기능적/비기능적 요구사항을 고려해 컴포넌트 간 관계, 데이터 흐름, 장애 대응, 확장 구조를 정의한다. 이는 클라우드 환경, 분산 시스템, 고가용성 아키텍처 설계 등과 밀접하며, 효율적인 아키텍처 설계를 통해 성능, 확장성, 유지보수성을 극대화하는 것이 목적이다. 실무에서는 설계 원칙과 패턴, 트레이드오프 분석 등이 핵심이다.</p><h3 id=등장-배경-및-발전-과정>등장 배경 및 발전 과정<a hidden class=anchor aria-hidden=true href=#등장-배경-및-발전-과정>#</a></h3><p>시스템 디자인은 인터넷과 클라우드 컴퓨팅의 발전과 함께 등장했다.<br>초기 단일 서버 아키텍처에서 시작하여 웹 2.0 시대의 대용량 트래픽 처리 필요성, 클라우드 컴퓨팅의 보편화, 마이크로서비스 아키텍처의 등장으로 발전해왔다.</p><p><strong>1960 년대 -1980 년대: 메인프레임 시대</strong></p><ul><li>중앙 집중식 컴퓨팅</li><li>단일 장애점 (Single Point of Failure) 문제</li></ul><p><strong>1990 년대 -2000 년대: 클라이언트 - 서버 아키텍처</strong></p><ul><li>네트워크 컴퓨팅의 확산</li><li>3 계층 아키텍처의 등장</li></ul><p><strong>2000 년대 중반: 웹 2.0 과 대용량 트래픽</strong></p><ul><li>Google, Amazon, Facebook 등의 급성장</li><li>기존 아키텍처의 한계 노출</li></ul><p><strong>2010 년대: 클라우드와 마이크로서비스</strong></p><ul><li>AWS, Azure 등 클라우드 플랫폼 보편화</li><li>Netflix, Uber 등의 마이크로서비스 사례</li></ul><p><strong>2020 년대: 클라우드 네이티브와 서버리스</strong></p><ul><li>컨테이너 기반 배포</li><li>서버리스 컴퓨팅의 확산</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><h4 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h4><p><strong>비즈니스 연속성 보장</strong></p><ul><li>서비스 중단 시간 최소화</li><li>사용자 경험 일관성 유지</li></ul><p><strong>비용 효율성 달성</strong></p><ul><li>리소스 사용량 최적화</li><li>운영 비용 절감</li></ul><p><strong>확장성 확보</strong></p><ul><li>사용자 증가에 대한 대응</li><li>데이터 증가에 대한 처리</li></ul><h4 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h4><p><strong>디지털 전환 가속화</strong></p><ul><li>모든 산업의 디지털화</li><li>온라인 서비스 의존도 증가</li></ul><p><strong>글로벌 서비스 요구</strong></p><ul><li>24/7 서비스 제공 필요</li><li>지역별 특성 고려</li></ul><p><strong>데이터 폭증 대응</strong></p><ul><li>빅데이터 처리 요구</li><li>실시간 분석 필요</li></ul><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>System Design</strong>은 요구사항 (기능적/비기능적) 을 충족시키는 시스템을 구성하는 아키텍처적 방법론으로, 복잡한 시스템을 <strong>모듈화 (Modularization)</strong>, <strong>인터페이스 정의</strong>, <strong>통신 설계</strong>, <strong>데이터 저장소 구조화</strong> 등을 통해 안정적이고 확장 가능하게 구축하는 데 중점을 둔다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><p><strong>확장성 (Scalability)</strong></p><ul><li>시스템이 증가하는 부하를 처리할 수 있는 능력</li><li>수직 확장 (Scale Up): 더 강력한 하드웨어 사용</li><li>수평 확장 (Scale Out): 더 많은 서버 추가</li></ul><p><strong>신뢰성 (Reliability)</strong></p><ul><li>시스템이 예상대로 지속적으로 작동하는 능력</li><li>장애 허용성 (Fault Tolerance) 포함</li><li>평균 고장 간격 시간 (MTBF: Mean Time Between Failures)</li></ul><p><strong>가용성 (Availability)</strong></p><ul><li>시스템이 운영 가능한 상태를 유지하는 시간의 비율</li><li>99.9% (8.76 시간/년), 99.99% (52.56 분/년) 등으로 측정</li></ul><p><strong>일관성 (Consistency)</strong></p><ul><li>모든 노드가 동일한 시점에 동일한 데이터를 보는 것</li><li>강한 일관성, 약한 일관성, 결과적 일관성으로 분류</li></ul><p><strong>분할 허용성 (Partition Tolerance)</strong></p><ul><li>네트워크 분할이 발생해도 시스템이 계속 동작하는 능력</li><li>CAP 정리의 핵심 요소</li></ul><h4 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h4><p><strong>로드 밸런싱 (Load Balancing)</strong></p><ul><li>들어오는 요청을 여러 서버에 분산</li><li>Round Robin, Weighted Round Robin, Least Connections 등</li></ul><p><strong>캐싱 (Caching)</strong></p><ul><li>자주 접근하는 데이터를 빠르게 접근할 수 있는 저장소에 보관</li><li>CPU 캐시, 메모리 캐시, 디스크 캐시, 분산 캐시</li></ul><p><strong>데이터베이스 설계</strong></p><ul><li>RDBMS vs NoSQL 선택</li><li>데이터 모델링, 인덱싱, 쿼리 최적화</li></ul><p><strong>마이크로서비스 아키텍처</strong></p><ul><li>작고 독립적인 서비스들로 애플리케이션을 구성</li><li>서비스 간 통신, 데이터 일관성, 배포 복잡성 관리</li></ul><h4 id=실무-구현과의-연관성>실무 구현과의 연관성<a hidden class=anchor aria-hidden=true href=#실무-구현과의-연관성>#</a></h4><table><thead><tr><th>실무 요소</th><th>관련 핵심 개념</th><th>설명</th></tr></thead><tbody><tr><td>트래픽 급증 대응</td><td>수평 확장성 (Horizontal Scalability)</td><td>다수의 서버 인스턴스를 통한 처리 능력 확장</td></tr><tr><td>장애 허용 설계</td><td>장애 분리 (Fault Isolation), 복제 (Replication)</td><td>시스템 구성요소의 독립성과 데이터 중복으로 장애 확산 방지</td></tr><tr><td>지연 시간 최소화</td><td>캐싱 (Caching), CDNs</td><td>자주 접근하는 데이터 또는 정적 파일을 메모리 또는 에지 서버에 저장</td></tr><tr><td>비동기 처리</td><td>메시지 큐 (Message Queue)</td><td>요청과 처리의 비동기화를 통한 시스템 유연성 확보</td></tr><tr><td>시스템 유지보수</td><td>모듈화 (Modularization)</td><td>책임이 명확한 컴포넌트로 분리하여 유지보수 용이</td></tr></tbody></table><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><h4 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h4><p><strong>아키텍처 설계</strong></p><ul><li>시스템 구조 정의</li><li>컴포넌트 간 상호작용 설계</li></ul><p><strong>성능 최적화</strong></p><ul><li>응답 시간 개선</li><li>처리량 (Throughput) 향상</li></ul><p><strong>보안 설계</strong></p><ul><li>인증 및 인가 체계</li><li>데이터 암호화</li></ul><p><strong>모니터링 및 관찰성</strong></p><ul><li>시스템 상태 추적</li><li>장애 예측 및 대응</li></ul><h4 id=주요-역할>주요 역할<a hidden class=anchor aria-hidden=true href=#주요-역할>#</a></h4><p><strong>비즈니스 요구사항 기술 구현</strong></p><ul><li>기능적 요구사항을 기술적으로 해결</li><li>비기능적 요구사항 (성능, 보안 등) 충족</li></ul><p><strong>기술 스택 선택 및 통합</strong></p><ul><li>적절한 기술 조합 결정</li><li>기술 간 호환성 보장</li></ul><p><strong>위험 관리</strong></p><ul><li>기술적 위험 식별 및 완화</li><li>장애 복구 계획 수립</li></ul><h4 id=기능과-역할의-관계>기능과 역할의 관계<a hidden class=anchor aria-hidden=true href=#기능과-역할의-관계>#</a></h4><p>시스템 설계의 기능들은 <strong>계층적 관계</strong>를 형성한다:</p><ul><li>아키텍처 설계가 기반을 제공</li><li>성능 최적화가 품질을 보장</li><li>보안 설계가 신뢰성을 확보</li><li>모니터링이 지속적 개선을 지원</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>복잡성 관리</strong><ul><li>계층화와 모듈화를 통한 복잡성 분해</li><li>관심사 분리 (Separation of Concerns) 원칙 적용</li></ul></li><li><strong>트레이드오프 인식</strong><ul><li>CAP 정리에 따른 선택과 집중</li><li>성능 vs 비용, 일관성 vs 가용성 등의 균형</li></ul></li><li><strong>진화 가능성</strong><ul><li>요구사항 변화에 대한 적응성</li><li>점진적 개선 (Incremental Improvement) 지원</li></ul></li><li><strong>측정 가능성</strong><ul><li>정량적 지표를 통한 성능 평가</li><li>SLA (Service Level Agreement) 기반 운영</li></ul></li></ul><blockquote><p><strong>모듈화된 아키텍처</strong>를 통해 복잡성을 관리하고, <strong>명확한 인터페이스 정의</strong>로 컴포넌트 간 결합도를 낮춘다. <strong>설계 패턴 적용</strong>으로 일관성을 유지하며, <strong>지속적인 모니터링</strong>으로 측정 가능성을 확보한다.</p></blockquote><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>시스템 설계는 사용자 요구를 분석하고, 이를 바탕으로 시스템 구조와 구성 요소, 데이터 흐름, 상호작용 등을 설계한다. 설계된 시스템은 확장성, 신뢰성, 성능, 보안 등 품질 속성을 보장하며, 실제 구현, 테스트, 배포를 거쳐 운영된다.</p><h4 id=설계-원칙>설계 원칙<a hidden class=anchor aria-hidden=true href=#설계-원칙>#</a></h4><p><strong>단일 책임 원칙 (Single Responsibility Principle)</strong></p><ul><li>각 컴포넌트는 하나의 책임만 가져야 함</li><li>변경 이유가 하나여야 함</li></ul><p><strong>느슨한 결합 (Loose Coupling)</strong></p><ul><li>컴포넌트 간 의존성 최소화</li><li>인터페이스를 통한 상호작용</li></ul><p><strong>높은 응집성 (High Cohesion)</strong></p><ul><li>관련된 기능을 하나의 모듈로 그룹화</li><li>내부 요소들 간 강한 연관성</li></ul><p><strong>확장성 우선 설계</strong></p><ul><li>미래 확장을 고려한 구조</li><li>수평 확장이 용이한 아키텍처</li></ul><h4 id=운영-원칙>운영 원칙<a hidden class=anchor aria-hidden=true href=#운영-원칙>#</a></h4><p><strong>장애 격리 (Fault Isolation)</strong></p><ul><li>하나의 장애가 전체 시스템에 미치는 영향 제한</li><li>서킷 브레이커 패턴 적용</li></ul><p><strong>점진적 배포 (Gradual Deployment)</strong></p><ul><li>카나리 배포, 블루 - 그린 배포 등</li><li>위험 최소화</li></ul><p><strong>자동화 우선</strong></p><ul><li>반복적 작업의 자동화</li><li>인적 오류 감소</li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>고려사항</strong></th><th><strong>주의사항</strong></th><th><strong>권장사항</strong></th></tr></thead><tbody><tr><td>설계 전략</td><td>요구사항 정의 및 정제</td><td>비기능 요구사항 (NFR) 누락</td><td>성능, 가용성, 확장성, 장애 복구 등을 포함한 NFR 명세 작성</td></tr><tr><td></td><td>도메인 분리</td><td>과도한 마이크로서비스 분할</td><td>DDD 기반 서비스 책임 경계 정의</td></tr><tr><td></td><td>시스템 목표 설정</td><td>모든 요구사항에 동일 우선순위 부여</td><td>우선순위 기반의 기능/비기능 분류 및 문서화</td></tr><tr><td>기술 아키텍처</td><td>기술 스택 선정</td><td>최신 기술만 도입하거나, 기술 다양성으로 복잡도 증가</td><td>조직 역량, 유지보수성, 커뮤니티 성숙도 고려한 선택</td></tr><tr><td></td><td>데이터 일관성 전략</td><td>분산 트랜잭션 단순화 혹은 과소평가</td><td>Event Sourcing, CQRS, SAGA 등 활용</td></tr><tr><td></td><td>API 및 인터페이스 설계</td><td>버전 관리 없이 공용 인터페이스 변경</td><td>명확한 계약 기반 API 설계, 버전 관리 (V1/V2…) 도입</td></tr><tr><td>배포 전략</td><td>배포 자동화</td><td>수동 배포로 인한 휴먼 에러</td><td>CI/CD 파이프라인 구축, 자동화 테스트/롤백 적용</td></tr><tr><td></td><td>점진적 배포</td><td>전체 서비스 동시 배포로 위험 증가</td><td>카나리 배포, 블루 - 그린, 피쳐 플래그 적용</td></tr><tr><td></td><td>장애 시나리오 플랜</td><td>단일 장애 지점 (SPOF) 존재</td><td>구성요소 이중화, 시뮬레이션 기반 복구 전략 수립</td></tr><tr><td>운영/관찰성</td><td>모니터링 및 관찰성 확보</td><td>분산 환경에서 로그/추적 누락</td><td>구조화된 로깅, 메트릭 표준화, OpenTelemetry 기반 분산 추적</td></tr><tr><td></td><td>성능 관리</td><td>캐시 설계 없이 확장성만 고려</td><td>다층 캐시 구조, TTL, 캐시 무효화 정책 명확화</td></tr><tr><td></td><td>장애 대응 및 복원력</td><td>서킷브레이커/리트라이 정책 미비</td><td>Circuit Breaker, Timeout, 백업 시스템 적용</td></tr><tr><td>보안 설계</td><td>인증 및 인가 체계</td><td>접근 제어 없이 내부 서비스 노출</td><td>OAuth2, JWT, mTLS, API Gateway 기반 인증/인가</td></tr><tr><td></td><td>네트워크 보안</td><td>내부 통신 암호화 미적용</td><td>제로 트러스트 모델, 서비스 간 통신 암호화 적용</td></tr><tr><td>문서화 및 리뷰</td><td>시스템/아키텍처 문서화</td><td>설계 문서 누락, 트레이드오프 설명 부재</td><td>ADR(Architecture Decision Record), 설계 흐름도, API 명세 작성 및 지속적 유지</td></tr><tr><td></td><td>아키텍처 리뷰와 피드백</td><td>일부 개발자 중심 의사결정</td><td>Cross-functional Review, Peer Review 포함</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>최적화 대상</strong></th><th><strong>핵심 설명</strong></th><th><strong>주의할 점</strong></th><th><strong>권장 사항 및 전략</strong></th></tr></thead><tbody><tr><td><strong>1. 성능 최적화</strong></td><td>응답 시간, 처리량, I/O</td><td>SLA 기반 응답 속도, Throughput 확보</td><td>조기 최적화, 복잡도 증가</td><td>병목 구간 프로파일링, 80/20 법칙 적용, 인덱싱/배치/비동기 처리</td></tr><tr><td></td><td>캐시 전략</td><td>읽기 성능 향상 및 부하 분산</td><td>캐시 일관성, Stale Data</td><td>TTL 설정, Write-through/Write-back, LRU/LFU 적용</td></tr><tr><td></td><td>데이터 접근 최적화</td><td>필요 시점에 최소한의 데이터 로드</td><td>Lazy Load 시 의도치 않은 지연</td><td>Index, Batching, Lazy Loading, Prefetch 적용</td></tr><tr><td></td><td>GC 및 메모리 관리</td><td>응답 지연 방지, GC Pause 최소화</td><td>힙 사이즈 과소/과대 설정</td><td>GC 튜닝 (G1GC 등), 메모리 프로파일링, 힙 크기 조절</td></tr><tr><td><strong>2. 확장성 최적화</strong></td><td>수평 확장, 분산 처리</td><td>스케일아웃 전략에 따른 부하 분산</td><td>상태 관리 복잡성 (세션, 상태 저장소 등)</td><td>Stateless 설계, 분산 세션 저장소 (Redis 등), Service Discovery 적용</td></tr><tr><td></td><td>오토스케일링</td><td>트래픽 증가/감소 대응</td><td>스케일 인/아웃 지연, 잘못된 임계치 설정</td><td>예측 기반 스케일링, 최소 예비 인스턴스 확보</td></tr><tr><td></td><td>데이터 분산</td><td>데이터 파티셔닝/복제</td><td>일관성 모델 선택 (CAP) 문제</td><td>Sharding, Consistent Hashing, Read/Write 분리, Eventual Consistency 적용</td></tr><tr><td><strong>3. 신뢰성/복원력</strong></td><td>장애 허용, 복제 전략</td><td>장애 발생 시 자동 복구 및 서비스 지속 보장</td><td>복잡도 증가, 동기화 비용</td><td>Health check, Failover 설계, Circuit Breaker, Retry with Jitter</td></tr><tr><td></td><td>재시도/타임아웃/백오프</td><td>네트워크 장애, 일시적 실패 대응</td><td>무한 루프, 리소스 고갈</td><td>지수 백오프, Retry 제한, Timeout 설정, Circuit Breaker 패턴 적용</td></tr><tr><td><strong>4. 비용 최적화</strong></td><td>리소스 할당, 스케일 정책</td><td>성능 유지하면서 비용 효율 확보</td><td>과도한 절감으로 성능 저하</td><td>예약 인스턴스/스팟 인스턴스 활용, Auto-scaling + 모니터링 기반 비용 관리</td></tr><tr><td></td><td>저장소 및 아카이빙</td><td>장기 보관/비정기 조회 데이터 저장 비용 최소화</td><td>압축률 vs CPU 사용량 Trade-off</td><td>Hot-Cold 데이터 분리, Glacier/S3 IA 같은 계층형 스토리지 사용</td></tr><tr><td><strong>5. 네트워크 최적화</strong></td><td>CDN, 지연 최소화, 메시지 크기 최적화</td><td>요청 지연 및 대역폭 사용 최적화</td><td>캐시 미스, 메시지 직렬화 오버헤드</td><td>CDN 정책 설정, 캐시 히트율 모니터링, 메시지 압축 (Protobuf, Avro), Gzip 전송 적용</td></tr><tr><td><strong>6. 관측 가능성 (Observability)</strong></td><td>트레이싱, 로깅, 모니터링</td><td>시스템 상태, 병목, 장애 추적</td><td>과도한 로깅, 개인정보 유출 가능성</td><td>OpenTelemetry, Prometheus + Grafana, Jaeger/Zipkin 도입</td></tr><tr><td><strong>7. 데이터베이스 최적화</strong></td><td>쿼리 성능, 인덱스 관리</td><td>DB 부하 분산 및 빠른 검색</td><td>과도한 인덱스 → 쓰기 성능 저하</td><td>쿼리 플랜 분석, 인덱스 리밸런싱, 파티셔닝/Read Replica 활용</td></tr><tr><td><strong>8. 아키텍처 구조</strong></td><td>동기/비동기 흐름 설계</td><td>성능, 복원력, 확장성에 직접적 영향</td><td>적절하지 않은 모델 선택 시 오히려 병목 발생</td><td>Queue/Event 기반 비동기 처리, Saga/CQRS 등 설계 적용</td></tr><tr><td><strong>9. 운영/테스트 최적화</strong></td><td>부하 테스트, 트래픽 예측</td><td>실제 상황 미반영 가능성</td><td>테스트 커버리지 부족, 불완전한 모의 데이터</td><td>부하 시뮬레이션 (Apache JMeter, k6 등), 트래픽 기반 테스트 자동화</td></tr></tbody></table><h3 id=system-design-실무-설계-예제>System Design 실무 설계 예제<a hidden class=anchor aria-hidden=true href=#system-design-실무-설계-예제>#</a></h3><h4 id=실시간-채팅-시스템-설계>실시간 채팅 시스템 설계<a hidden class=anchor aria-hidden=true href=#실시간-채팅-시스템-설계>#</a></h4><p><strong>요구사항</strong>:</p><ul><li><strong>기능적</strong>:<ul><li>사용자 간 1:1 채팅 지원</li><li>메시지 읽음/안 읽음 표시</li><li>메시지 저장 및 조회</li><li>오프라인 메시지 푸시 알림</li><li>확장 가능한 구조</li></ul></li><li><strong>비기능적</strong>:<ul><li>수십만 동시 사용자 처리</li><li>99.99% 가용성</li><li>메시지 지연 ≤ 200ms</li><li>저장 데이터의 내구성 확보</li></ul></li></ul><h5 id=1-단계-핵심-기능-정의>1 단계: 핵심 기능 정의<a hidden class=anchor aria-hidden=true href=#1-단계-핵심-기능-정의>#</a></h5><ul><li>실시간 송수신 → WebSocket</li><li>메시지 중계 및 유실 방지 → 메시지 큐 (Kafka)</li><li>메시지 영속 저장 → NoSQL (MongoDB) 또는 Cassandra</li><li>빠른 채팅방 목록 조회 → Redis 캐시</li><li>푸시 알림 → Firebase 또는 SNS</li></ul><h5 id=2-단계-시스템-아키텍처-구성>2 단계: 시스템 아키텍처 구성<a hidden class=anchor aria-hidden=true href=#2-단계-시스템-아키텍처-구성>#</a></h5><pre class=mermaid>graph TD
    U[User Device] --&gt; WS[WebSocket Gateway]
    WS --&gt; LB1[Chat Load Balancer]
    LB1 --&gt; CS[Chat Server]
    CS --&gt; MQ[Kafka Topic]
    CS --&gt; C[Redis Cache]
    MQ --&gt; P[Message Processor]
    P --&gt; DB[&#34;NoSQL DB (Mongo/Cassandra)&#34;]
    P --&gt; PN[Push Notification Server]
</pre><h5 id=3-단계-주요-설계-결정>3 단계: 주요 설계 결정<a hidden class=anchor aria-hidden=true href=#3-단계-주요-설계-결정>#</a></h5><table><thead><tr><th>컴포넌트</th><th>선택 기술</th><th>설계 이유</th></tr></thead><tbody><tr><td>WebSocket Gateway</td><td>Nginx + WS 통신</td><td>실시간 양방향 통신 지원</td></tr><tr><td>메시지 브로커</td><td>Kafka</td><td>메시지 유실 방지, 확장성</td></tr><tr><td>데이터 저장소</td><td>MongoDB 또는 Cassandra</td><td>빠른 쓰기, 수평 확장</td></tr><tr><td>캐시</td><td>Redis</td><td>채팅방 리스트/메시지 캐싱</td></tr><tr><td>알림 시스템</td><td>Firebase / SNS</td><td>모바일 푸시 연동</td></tr></tbody></table><p>각 구성 요소는 상황에 따라 기술 선택이 달라지며, 단순 비교가 아닌 <strong>요구사항 기반의 선택과 트레이드오프 판단</strong>이 중요하다.</p><h5 id=4-단계-고려한-트레이드오프>4 단계: 고려한 트레이드오프<a hidden class=anchor aria-hidden=true href=#4-단계-고려한-트레이드오프>#</a></h5><table><thead><tr><th>선택</th><th>트레이드오프</th></tr></thead><tbody><tr><td>Kafka 사용</td><td>고가용성과 메시지 유실 방지 → 시스템 복잡도 증가</td></tr><tr><td>WebSocket</td><td>실시간성 확보 → 커넥션 유지 비용 증가</td></tr><tr><td>NoSQL 사용</td><td>확장성 확보 → 트랜잭션 약화 가능</td></tr></tbody></table><h5 id=5-단계-실시간-메시지-흐름-워크플로우>5 단계: 실시간 메시지 흐름 워크플로우<a hidden class=anchor aria-hidden=true href=#5-단계-실시간-메시지-흐름-워크플로우>#</a></h5><pre class=mermaid>sequenceDiagram
    participant U as User
    participant G as WebSocket Gateway
    participant C as Chat Server
    participant K as Kafka
    participant P as Processor
    participant D as DB

    U-&gt;&gt;G: WebSocket 메시지 전송
    G-&gt;&gt;C: 메시지 전달
    C-&gt;&gt;K: Kafka Topic에 메시지 Push
    K-&gt;&gt;P: 메시지 Consume
    P-&gt;&gt;D: DB에 메시지 저장
    P-&gt;&gt;G: ACK 또는 푸시 알림 전송
</pre><h5 id=6-단계-최적화-포인트>6 단계: 최적화 포인트<a hidden class=anchor aria-hidden=true href=#6-단계-최적화-포인트>#</a></h5><table><thead><tr><th>대상</th><th>전략</th></tr></thead><tbody><tr><td>메시지 큐 처리</td><td>멀티 Consumer, 파티셔닝</td></tr><tr><td>메시지 저장</td><td>비동기 저장, 배치 쓰기</td></tr><tr><td>채팅방 리스트</td><td>Redis 기반 TTL 캐시</td></tr><tr><td>장애 대응</td><td>Kafka + Retry, Circuit Breaker</td></tr><tr><td>서버 스케일링</td><td>Horizontal Scaling + AutoScaling Group</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>핵심 항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>아키텍처 설계</strong></td><td>계층형 아키텍처</td><td>Presentation, Logic, Data Layer</td><td>명확한 책임 분리로 유지보수 및 확장성 확보</td></tr><tr><td></td><td>마이크로서비스 패턴</td><td>Service Mesh, CQRS, Event Sourcing</td><td>서비스 간 통신 및 상태 변경을 패턴 기반으로 분리/최적화</td></tr><tr><td></td><td>서버리스 아키텍처</td><td>AWS Lambda, Azure Functions</td><td>이벤트 기반 확장성과 운영 간소화를 제공하는 컴퓨팅 모델</td></tr><tr><td></td><td>Trade-offs</td><td>Latency vs. Throughput, CAP Theorem</td><td>설계 시 성능, 일관성, 확장성 간의 균형을 고려한 의사결정 필수</td></tr><tr><td><strong>성능 최적화</strong></td><td>캐싱</td><td>Redis, Memcached, CDN, 브라우저 캐시</td><td>응답 속도 향상과 백엔드 부하 감소를 위한 다층 캐시 전략 적용</td></tr><tr><td></td><td>수평 확장</td><td>Auto Scaling Group, Kubernetes HPA</td><td>사용자 증가 및 트래픽 변화에 따른 유연한 확장 구조 설계</td></tr><tr><td></td><td>샤딩/복제</td><td>DB Sharding, Read Replicas</td><td>대용량 데이터 처리를 위한 수평적 확장 전략</td></tr><tr><td><strong>통신 구조</strong></td><td>클라이언트 - 서버</td><td>HTTP, REST, gRPC 등</td><td>전통적 1:1 통신 구조 기반, API 중심 구조 구현</td></tr><tr><td></td><td>비동기 메시징</td><td>Kafka, RabbitMQ, 메시지 큐</td><td>느슨한 결합 및 대규모 이벤트 기반 아키텍처에 적합</td></tr><tr><td></td><td>API 게이트웨이</td><td>인증/인가, 로깅, 라우팅</td><td>통합 진입점에서 다양한 기능을 담당하며 마이크로서비스의 핵심 구성 요소</td></tr><tr><td></td><td>데이터 동기화</td><td>CDC (Change Data Capture)</td><td>데이터 변경 사항 실시간 반영으로 시스템 간 정합성 유지</td></tr><tr><td><strong>보안 설계</strong></td><td>인증/인가</td><td>OAuth 2.0, JWT, RBAC</td><td>사용자 접근 제어 및 API 보호 표준</td></tr><tr><td></td><td>네트워크 보안</td><td>Zero Trust, mTLS</td><td>서비스 간 보안을 보장하는 네트워크 보안 모델 적용</td></tr><tr><td><strong>장애 대응</strong></td><td>내결함성 및 복구 전략</td><td>Circuit Breaker, Retry, Failover</td><td>장애 격리, 자동 회복, 중단 최소화를 위한 보호 패턴</td></tr><tr><td></td><td>이중화</td><td>Active-Active, Active-Passive 구성</td><td>단일 장애 지점 (SPOF) 제거를 위한 고가용성 전략</td></tr><tr><td><strong>데이터 아키텍처</strong></td><td>일관성 모델</td><td>Strong, Eventual, Causal Consistency</td><td>요구 사항에 따라 선택적으로 적용되는 일관성 보장 전략</td></tr><tr><td></td><td>데이터 저장 전략</td><td>데이터 레이크, 데이터 메시, 분산 DB</td><td>대규모·비정형·분산 데이터 처리를 위한 저장소 설계 전략 적용</td></tr><tr><td><strong>관찰성과 운영</strong></td><td>모니터링</td><td>Prometheus, Grafana</td><td>메트릭 기반의 실시간 상태 추적 및 대시보드 제공</td></tr><tr><td></td><td>분산 추적</td><td>OpenTelemetry, Jaeger, Zipkin</td><td>마이크로서비스 간 호출 관계 추적 및 성능 병목 파악 가능</td></tr><tr><td></td><td>로그 관리</td><td>중앙 집중형 로깅, 구조화 로그</td><td>장애 분석 및 실시간 감사를 위한 핵심 요소</td></tr><tr><td><strong>배포 전략</strong></td><td>CI/CD 자동화</td><td>GitOps, ArgoCD, Jenkins</td><td>인프라 및 코드의 안정적 릴리즈를 위한 자동화된 파이프라인</td></tr><tr><td></td><td>점진적 배포</td><td>블루 - 그린, 카나리, 피처 플래그</td><td>무중단 배포 및 사용자 영향 최소화를 위한 배포 전략</td></tr><tr><td><strong>설계 문서화</strong></td><td>의사결정 기록</td><td>ADR (Architecture Decision Record)</td><td>아키텍처 설계 및 기술 선택의 역사와 근거를 기록하여 지속 가능성 확보</td></tr><tr><td></td><td>시스템 흐름 문서화</td><td>API 스펙, 시퀀스/플로우 다이어그램</td><td>개발 및 협업 시 시스템 구조 파악과 온보딩에 중요한 문서</td></tr></tbody></table><h3 id=반드시-학습해야할-내용>반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#반드시-학습해야할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>핵심 항목</strong></th><th><strong>설명 및 핵심 개념</strong></th></tr></thead><tbody><tr><td><strong>1. 분산 시스템 이론</strong></td><td>일관성/가용성 이론</td><td>CAP, BASE, PACELC</td><td>분산 시스템의 근본 제약: 일관성 vs 가용성 vs 파티션 내성, 지연 - 일관성 트레이드오프 분석</td></tr><tr><td></td><td>트랜잭션 처리</td><td>ACID, 격리 수준, 동시성 제어</td><td>분산 트랜잭션 특성과 DB 일관성 보장 기법 (2PC, SAGA 포함)</td></tr><tr><td></td><td>분산 합의 알고리즘</td><td>Raft, Paxos, PBFT</td><td>분산 시스템에서의 일관된 상태 합의, 리더 선출, 블록체인 등에도 활용</td></tr><tr><td><strong>2. 네트워크 및 통신</strong></td><td>프로토콜 및 통신 구조</td><td>TCP/IP, HTTP/2·3, gRPC, WebSocket</td><td>효율적 데이터 전송을 위한 최신 통신 기술, 실시간 처리 및 바이너리 전송 최적화</td></tr><tr><td></td><td>API 설계</td><td>REST, RESTful, GraphQL, gRPC</td><td>API 디자인 원칙 및 내부/외부 API 아키텍처 구분 (페이로드 최적화, 보안 포함)</td></tr><tr><td><strong>3. 보안 및 인증/인가</strong></td><td>인증/인가 모델</td><td>OAuth2, JWT, RBAC, ABAC</td><td>API 보안 및 마이크로서비스 간 인증 방안</td></tr><tr><td></td><td>암호화/서명/해시</td><td>대칭/비대칭 암호화, 해시 함수, 디지털 서명</td><td>데이터 무결성과 기밀성 확보, 인증 및 무결성 검증 기술 적용</td></tr><tr><td><strong>4. 설계 원칙/패턴</strong></td><td>객체지향 및 구조적 설계 원칙</td><td>SOLID, KISS, DRY, YAGNI</td><td>유지보수성과 확장성을 높이는 기본 설계 원칙</td></tr><tr><td></td><td>디자인 패턴</td><td>싱글톤, 팩토리, 옵저버, 전략, 어댑터 등</td><td>구조적 설계 재사용을 위한 핵심 패턴들</td></tr><tr><td></td><td>아키텍처 스타일/패턴</td><td>Layered, Hexagonal, Clean Architecture, MSA</td><td>시스템 구성의 큰 틀, 의존성 관리, 도메인 중심 설계 적용 방식</td></tr><tr><td></td><td>고급 설계 패턴</td><td>CQRS, Event Sourcing, Saga, Circuit Breaker</td><td>이벤트 기반 구조와 회복탄력성 있는 시스템 설계</td></tr><tr><td><strong>5. 데이터 설계</strong></td><td>데이터 저장소 및 분산 처리</td><td>SQL vs NoSQL, Sharding, Replication, Partitioning</td><td>데이터 특성과 트래픽에 따른 적절한 저장소 선택 및 분산 전략</td></tr><tr><td></td><td>데이터 모델링</td><td>정규화/반정규화, 인덱싱, 파티셔닝 전략</td><td>읽기/쓰기 최적화를 위한 DB 구조 설계 전략</td></tr><tr><td><strong>6. 성능 최적화</strong></td><td>캐싱/로딩 전략</td><td>In-memory Cache, Distributed Cache, TTL, LRU</td><td>응답 지연 감소 및 트래픽 감소를 위한 캐시 설계</td></tr><tr><td></td><td>로드 밸런싱</td><td>라운드 로빈, Least Conn., IP Hash, Sticky Session</td><td>수평 확장을 위한 트래픽 분산 기법</td></tr><tr><td></td><td>비동기 처리 및 큐잉</td><td>Kafka, RabbitMQ, SQS, Celery, Message Patterns</td><td>병렬 처리, 이벤트 기반 설계의 핵심 컴포넌트</td></tr><tr><td><strong>7. 운영 및 인프라</strong></td><td>컨테이너 및 오케스트레이션</td><td>Docker, Kubernetes</td><td>마이크로서비스 배포 및 확장성을 위한 표준 플랫폼</td></tr><tr><td></td><td>CI/CD</td><td>지속적 통합/배포 파이프라인 구성</td><td>빠른 롤아웃/롤백을 위한 DevOps 핵심 전략</td></tr><tr><td></td><td>서비스 메시 및 트래픽 제어</td><td>Istio, Linkerd, Envoy</td><td>마이크로서비스 간 네트워크 제어 및 트래픽 정책 적용</td></tr><tr><td><strong>8. 가용성 및 복원력</strong></td><td>이중화/장애 허용</td><td>Failover, Health Check, Auto-healing</td><td>시스템 장애에 대응할 수 있는 복원력 설계</td></tr><tr><td></td><td>복원력 패턴</td><td>Circuit Breaker, Timeout, Retry, Bulkhead</td><td>장애 격리 및 전파 방지를 위한 핵심 제어 구조</td></tr><tr><td><strong>9. 관측 가능성</strong></td><td>모니터링 및 로깅</td><td>Prometheus, Grafana, ELK, Fluent Bit</td><td>시스템 상태 시각화 및 운영 이슈 사전 대응</td></tr><tr><td></td><td>분산 트레이싱</td><td>OpenTelemetry, Jaeger, Zipkin</td><td>마이크로서비스 트랜잭션 추적 및 병목 탐지</td></tr><tr><td><strong>10. 시스템 구조 이해</strong></td><td>모듈화</td><td>계층 구조, Bounded Context, 의존성 분리</td><td>확장 가능한 구조 및 책임 분리를 위한 모듈 설계</td></tr><tr><td></td><td>Client-Server 구조</td><td>Frontend-Backend 분리, API Gateway</td><td>요청 흐름/통신 모델에 대한 이해 (MVC → API Gateway 구조까지)</td></tr><tr><td></td><td>마이크로서비스 아키텍처</td><td>독립 배포, 각 서비스 간 느슨한 결합</td><td>대규모 시스템 확장을 위한 핵심 구조</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th><th></th></tr></thead><tbody><tr><td><strong>아키텍처 스타일</strong></td><td>Monolith (모놀리식)</td><td>모든 기능이 하나의 애플리케이션에 통합된 구조로, 초기 개발은 단순하지만 확장성과 유지보수가 어려움</td><td></td></tr><tr><td></td><td>Microservices (마이크로서비스)</td><td>기능별로 분리된 작은 서비스들로 구성되어 독립 배포와 확장이 용이한 분산 아키텍처</td><td></td></tr><tr><td></td><td>Client-Server</td><td>클라이언트가 요청을 보내고 서버가 응답을 반환하는 전통적인 구조</td><td></td></tr><tr><td></td><td>Service Mesh</td><td>마이크로서비스 간 통신을 추상화하고 제어하는 인프라 계층 (ex: Istio)</td><td></td></tr><tr><td></td><td>API Gateway</td><td>클라이언트 요청을 백엔드 서비스로 라우팅하고 인증, 로깅, 제한 등을 처리하는 진입점</td><td></td></tr><tr><td></td><td>Load Balancer</td><td>클라이언트 요청을 여러 서버에 균등하게 분산시켜 트래픽을 조절하는 장치</td><td></td></tr><tr><td></td><td>Event Sourcing</td><td>상태 변경을 이벤트로 기록하고, 이 이벤트들을 통해 현재 상태를 재구성하는 패턴</td><td></td></tr><tr><td></td><td>CQRS</td><td>명령 (Command) 과 조회 (Query) 를 분리하여 성능, 확장성, 보안성을 개선하는 아키텍처 패턴</td><td></td></tr><tr><td></td><td>Saga Pattern</td><td>분산 시스템에서 트랜잭션을 순차적 보상 작업으로 나누어 처리하는 패턴</td><td></td></tr><tr><td><strong>데이터 처리</strong></td><td>Sharding</td><td>데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 방식 (스케일 아웃)</td><td></td></tr><tr><td></td><td>Replication</td><td>데이터 복제를 통해 가용성과 내결함성 (Fault Tolerance) 확보</td><td></td></tr><tr><td></td><td>ACID</td><td>트랜잭션의 4 가지 속성: 원자성, 일관성, 격리성, 지속성</td><td></td></tr><tr><td></td><td>BASE</td><td>NoSQL 기반 원칙: 기본적 가용성, 소프트 상태, 결과적 일관성</td><td></td></tr><tr><td></td><td>CQRS</td><td>조회와 명령을 분리하여 확장성과 성능을 높이는 설계 방식</td><td></td></tr><tr><td></td><td>Consistency</td><td>모든 노드에서 동일한 데이터 상태를 유지하는 성질</td><td></td></tr><tr><td></td><td>Partition Tolerance</td><td>네트워크 분할 상황에서도 시스템이 계속 동작하는 능력</td><td></td></tr><tr><td><strong>확장성/성능</strong></td><td>Horizontal Scaling</td><td>서버의 수를 늘려 트래픽과 데이터를 분산하여 처리 능력을 향상</td><td></td></tr><tr><td></td><td>Vertical Scaling</td><td>서버의 하드웨어 성능 (CPU, RAM 등) 을 높여 처리 능력을 강화</td><td></td></tr><tr><td></td><td>Caching</td><td>자주 접근하는 데이터를 메모리 등 빠른 저장소에 저장하여 응답 속도 향상</td><td></td></tr><tr><td></td><td>CDN</td><td>전 세계에 분산된 노드를 통해 콘텐츠를 가까운 위치에서 빠르게 전달</td><td></td></tr><tr><td></td><td>Load Balancing</td><td>요청을 여러 서버에 분산시켜 병목 현상을 방지하고 안정성을 확보</td><td></td></tr><tr><td></td><td>Throttling</td><td>클라이언트의 요청 속도를 제한하여 시스템을 보호</td><td></td></tr><tr><td><strong>신뢰성/장애 대응</strong></td><td>Circuit Breaker</td><td>외부 서비스 오류가 반복될 경우 빠르게 실패 처리하여 시스템 전체 장애 방지</td><td></td></tr><tr><td></td><td>Failover</td><td>장애 발생 시 자동으로 대기 시스템으로 전환하여 가용성 유지</td><td></td></tr><tr><td></td><td>Redundancy (이중화)</td><td>장애에 대비하여 동일 기능을 하는 시스템을 중복 구성</td><td></td></tr><tr><td></td><td>Availability</td><td>시스템이 정상적으로 작동할 수 있는 시간의 비율 (Uptime)</td><td></td></tr><tr><td><strong>통신/메시징</strong></td><td>REST API</td><td>HTTP 기반의 동기 통신 인터페이스</td><td></td></tr><tr><td></td><td>메시지 브로커</td><td>비동기 메시지 전달을 위한 시스템 (Kafka, RabbitMQ 등)</td><td></td></tr><tr><td></td><td>메시지 큐 (Queue)</td><td>생산자가 보낸 메시지를 소비자가 순차적으로 처리하는 FIFO 구조</td><td></td></tr><tr><td></td><td>Pub/Sub</td><td>하나의 발행자가 다수의 구독자에게 메시지를 전달하는 방식</td><td></td></tr><tr><td><strong>보안</strong></td><td>OAuth 2.0</td><td>외부 애플리케이션이 제한된 접근 권한을 갖도록 하는 인증 프레임워크</td><td></td></tr><tr><td></td><td>JWT</td><td>JSON 기반의 인증 토큰으로, 무상태 (stateless) 인증 방식</td><td></td></tr><tr><td></td><td>RBAC</td><td>역할 기반 접근 제어 방식으로 권한을 역할 단위로 관리</td><td></td></tr><tr><td></td><td>mTLS</td><td>클라이언트와 서버가 서로 인증하는 TLS 방식</td><td></td></tr><tr><td><strong>운영/배포</strong></td><td>CI/CD</td><td>지속적 통합 (Continuous Integration) 과 지속적 배포 (Continuous Deployment)</td><td></td></tr><tr><td></td><td>GitOps</td><td>Git 을 단일 진실의 소스로 사용하여 운영을 자동화하는 방식</td><td></td></tr><tr><td></td><td>Container</td><td>애플리케이션과 그 의존성을 패키징하여 격리된 환경에서 실행</td><td></td></tr><tr><td></td><td>Orchestration</td><td>여러 컨테이너의 배포, 확장, 관리를 자동화 (ex: Kubernetes)</td><td></td></tr><tr><td></td><td>Immutable Deployment</td><td>서버를 수정하지 않고 새 인스턴스를 통해 배포하는 방식</td><td></td></tr><tr><td></td><td>Strangler Pattern</td><td>레거시 시스템을 점진적으로 새로운 시스템으로 교체하는 전략</td><td></td></tr><tr><td><strong>모니터링/가시성</strong></td><td>APM</td><td>애플리케이션의 성능을 모니터링하고 병목을 진단하는 도구</td><td></td></tr><tr><td></td><td>Distributed Tracing</td><td>여러 마이크로서비스에 걸친 요청 흐름 추적</td><td></td></tr><tr><td></td><td>SLA/SLO/SLI</td><td>서비스 수준 계약/목표/지표로 서비스 품질을 측정하고 약속하는 기준</td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=scalability-availability-and-reliability>Scalability, Availability, and Reliability<a hidden class=anchor aria-hidden=true href=#scalability-availability-and-reliability>#</a></h3><ul><li><a href=https://getsdeready.com/scalability-availability-and-reliability-core-principles-for-building-a-robust-system/>Scalability, Availability, and Reliability: Core Principles for Building a Robust System</a></li><li><a href=https://www.statsig.com/perspectives/designing-for-scalability-principles>Designing for scalability: Principles every engineer should know</a></li><li><a href=https://www.dhiwise.com/blog/requirement-builder/scalable-software-system-design>Scalable Software System Design: Key Principles, Best Practices</a></li><li><a href=https://www.designgurus.io/blog/grokking-system-design-scalability>Grokking Scalability in System Design: How I Learned the Techniques, Principles, and Best Practices</a></li></ul><h3 id=system-design-총론>System Design 총론<a hidden class=anchor aria-hidden=true href=#system-design-총론>#</a></h3><ul><li><a href=https://www.geeksforgeeks.org/what-is-system-design-learn-system-design/>What is System Design? A Comprehensive Guide to System Architecture and Design Principles</a></li><li><a href=https://www.designgurus.io/blog/system-design-interview-fundamentals>System Design Fundamentals – Design Gurus</a></li><li><a href=https://swimm.io/learn/system-design/system-design-complete-guide-with-patterns-examples-and-techniques>System Design Complete Guide – Swimm</a></li><li><a href=https://cio-wiki.org/wiki/Systems_Design>Systems Design – CIO Wiki</a></li><li><a href=https://www.interviewbit.com/blog/system-architecture/>System Architecture – InterviewBit</a></li></ul><h3 id=design-principles--patterns>Design Principles & Patterns<a hidden class=anchor aria-hidden=true href=#design-principles--patterns>#</a></h3><ul><li><a href=https://www.geeksforgeeks.org/system-design/design-principles-in-system-design/>Design Principles in System Design – GeeksforGeeks</a></li><li><a href=https://medium.com/@dugguRK/undertsanding-design-pattern-and-principle-1d308edb54d7>Design Patterns vs. Principles – Medium</a></li><li><a href=https://en.wikipedia.org/wiki/Software_design_pattern>Software Design Pattern – Wikipedia</a></li><li><a href=https://martinfowler.com/articles/nonfunctional-requirements.html>Nonfunctional Requirements – Martin Fowler</a></li></ul><h3 id=caching--load-balancing>Caching & Load Balancing<a hidden class=anchor aria-hidden=true href=#caching--load-balancing>#</a></h3><ul><li><a href=https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/>Caching – System Design Concept – GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/load-balancer-system-design-interview-question/>Load Balancer – System Design Interview Question – GeeksforGeeks</a></li></ul><h3 id=microservices-vs-monolith>Microservices Vs Monolith<a hidden class=anchor aria-hidden=true href=#microservices-vs-monolith>#</a></h3><ul><li><a href=https://microservices.io/patterns/monolithic.html>Microservices Pattern: Monolithic Architecture</a></li><li><a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith>Microservices vs. Monolithic Architecture – Atlassian</a></li></ul><h3 id=실전-아키텍처-자료>실전 아키텍처 자료<a hidden class=anchor aria-hidden=true href=#실전-아키텍처-자료>#</a></h3><ul><li><a href=https://aws.amazon.com/architecture/well-architected/>AWS Well‑Architected Framework</a></li><li><a href=https://cloud.google.com/architecture>Google Cloud Architecture Center</a></li><li><a href=https://docs.microsoft.com/azure/architecture/>Microsoft Azure Architecture Center</a></li><li><a href=https://12factor.net/>The Twelve‑Factor App</a></li><li><a href=https://netflixtechblog.com/>Netflix Technology Blog</a></li><li><a href=http://highscalability.com/>High Scalability</a></li><li><a href=https://martinfowler.com/>Martin Fowler’s Blog</a></li><li><a href=https://kubernetes.io/docs/>Kubernetes Documentation</a></li><li><a href=https://www.cncf.io/>Cloud Native Computing Foundation (CNCF)</a></li></ul><h3 id=추가-학습-및-참고-리소스>추가 학습 및 참고 리소스<a hidden class=anchor aria-hidden=true href=#추가-학습-및-참고-리소스>#</a></h3><ul><li><a href=https://gist.github.com/vasanthk/485d1c25737e8e72759f>System Design Cheatsheet – GitHub Gist (vasanthk)</a></li><li><a href=https://blog.bytebytego.com/p/ep160-top-20-system-design-concepts>Top 20 System Design Concepts You Should Know – ByteByteGo</a></li><li><a href=https://medium.com/@chenwingu/system-design-core-concepts-architecture-and-strategies-a636680f71ef>15 System Design Core Concepts – Medium / Interviewing.io</a></li><li><a href=https://www.geeksforgeeks.org/system-design/system-design-tutorial/>System Design Tutorial – GeeksforGeeks</a></li><li><a href=https://datmt.com/architecture/a-comprehensive-guide-to-fundamental-concepts-of-system-design/>A Comprehensive Guide to Fundamental Concepts of System Design – datmt</a></li><li><a href=https://dev.to/godofgeeks/fundamentals-of-system-design-4b6m>Fundamentals of System Design – dev.to</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-engineering/>Software-Engineering</a></li><li><a href=https://buenhyden.github.io/tags/system-design/>System-Design</a></li><li><a href=https://buenhyden.github.io/tags/scalable-systems/>Scalable-Systems</a></li><li><a href=https://buenhyden.github.io/tags/distributed-systems/>Distributed-Systems</a></li></ul><nav class=paginav><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/><span class=title>Next »</span><br><span>꼬리 재귀(Tail Recursion)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>