<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Containerization | hyunyoun's Blog</title><meta name=keywords content="System-Architecture-and-Design,System-Components,Platform-and-Execution-Infrastructure,Containerization,Orchestration,Platform-Infrastructure,DevOps-Platform,Application-Packaging"><meta name=description content="컨테이너화는 애플리케이션과 의존성을 경량 이미지로 패키징해 운영체제 커널을 공유하며 격리 실행하는 기술이다. 네임스페이스·cgroups로 격리·자원제어를 수행하고, OCI 규격의 이미지·런타임·레지스트리와 Kubernetes 등 오케스트레이션, CI/CD가 결합되어 이식성·일관성·자동화된 확장성을 제공한다. 커널 공유에 따른 보안·격리 한계는 설계 시 고려해야 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/system-components/platform--execution-infrastructure/containerization/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/system-components/platform--execution-infrastructure/containerization/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/system-components/platform--execution-infrastructure/containerization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/system-components/platform--execution-infrastructure/containerization/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Containerization"><meta property="og:description" content="컨테이너화는 애플리케이션과 의존성을 경량 이미지로 패키징해 운영체제 커널을 공유하며 격리 실행하는 기술이다. 네임스페이스·cgroups로 격리·자원제어를 수행하고, OCI 규격의 이미지·런타임·레지스트리와 Kubernetes 등 오케스트레이션, CI/CD가 결합되어 이식성·일관성·자동화된 확장성을 제공한다. 커널 공유에 따른 보안·격리 한계는 설계 시 고려해야 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Containerization"><meta name=twitter:description content="컨테이너화는 애플리케이션과 의존성을 경량 이미지로 패키징해 운영체제 커널을 공유하며 격리 실행하는 기술이다. 네임스페이스·cgroups로 격리·자원제어를 수행하고, OCI 규격의 이미지·런타임·레지스트리와 Kubernetes 등 오케스트레이션, CI/CD가 결합되어 이식성·일관성·자동화된 확장성을 제공한다. 커널 공유에 따른 보안·격리 한계는 설계 시 고려해야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Containerization","item":"https://buenhyden.github.io/posts/system-architecture--design/system-components/platform--execution-infrastructure/containerization/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Containerization</h1><div class=post-description>컨테이너화는 애플리케이션과 의존성을 경량 이미지로 패키징해 운영체제 커널을 공유하며 격리 실행하는 기술이다. 네임스페이스·cgroups로 격리·자원제어를 수행하고, OCI 규격의 이미지·런타임·레지스트리와 Kubernetes 등 오케스트레이션, CI/CD가 결합되어 이식성·일관성·자동화된 확장성을 제공한다. 커널 공유에 따른 보안·격리 한계는 설계 시 고려해야 한다.</div></header><div class=post-content><h2 id=containerization>Containerization<a hidden class=anchor aria-hidden=true href=#containerization>#</a></h2><p>컨테이너는 운영체제 커널을 공유하면서 네임스페이스로 프로세스·네트워크·파일시스템을 분리하고 cgroups 로 리소스를 제한해 경량화된 격리를 제공한다.<br>이미지는 레이어 기반 불변 아티팩트로 빌드·배포·롤백을 단순화하고 레지스트리로 배포된다.<br>Kubernetes 같은 오케스트레이터는 스케줄링, 서비스 디스커버리, 자동 복구, 수평 확장과 롤링 업데이트를 책임진다.</p><p>실무에서는 런타임 (containerd/runc 또는 VM 격리인 Kata), CNI/CSI 설계, 이미지 서명·SBOM·seccomp/SELinux 등 최소 권한 적용, 적절한 liveness/readiness 프로브·리소스 제한, 중앙화된 로깅·모니터링·CI/CD 파이프라인을 갖추는 것이 안정적·확장 가능한 운영의 핵심이다.</p><h3 id=컨테이너-핵심-개념과-실무-연동>컨테이너 핵심 개념과 실무 연동<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-개념과-실무-연동>#</a></h3><p>컨테이너는 애플리케이션과 그 환경을 묶어 어디서나 동일하게 실행되도록 하는 경량 가상화 기술이다.</p><p>이미지는 배포 가능한 불변 파일이고, 런타임 (예: containerd/runc) 이 이미지를 풀어 컨테이너를 생성한다.<br>네임스페이스와 cgroup 은 프로세스·네트워크·리소스 격리를 제공해 멀티테넌시와 자원 제어를 가능하게 한다.<br>대규모 운영은 Kubernetes 같은 오케스트레이션 플랫폼이 담당하며, 네트워크 (CNI), 스토리지 (CSI), 런타임 (CRI) 같은 표준 인터페이스로 플러그인을 연결한다.<br>안전한 운영을 위해 이미지 서명·취약점 스캔·SBOM, 정책 엔진, 관측 시스템을 CI/CD 파이프라인과 통합해야 실무에서 신뢰 가능한 서비스 운영이 가능하다.</p><h4 id=컨테이너-핵심-개념-요약표>컨테이너 핵심 개념 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-개념-요약표>#</a></h4><table><thead><tr><th>핵심 개념 (한글, 약어)</th><th>정의 (간략)</th><th>왜 중요한가</th></tr></thead><tbody><tr><td>컨테이너 (Container)</td><td>앱 + 종속성 실행 단위</td><td>이식성·경량배포 확보</td></tr><tr><td>컨테이너 이미지 (Image)</td><td>불변 배포 템플릿</td><td>버전관리·롤백 용이</td></tr><tr><td>컨테이너 런타임 (Runtime, CRI)</td><td>이미지 → 컨테이너 실행</td><td>실행 호환성·보안 영향</td></tr><tr><td>네임스페이스 (Namespace)</td><td>커널 격리 단위</td><td>프로세스·네트워크 격리</td></tr><tr><td>제어 그룹 (Cgroup)</td><td>자원 제어·제한</td><td>QoS·리소스 예측성</td></tr><tr><td>오케스트레이션 (Orchestration)</td><td>스케줄링·확장 플랫폼</td><td>운영 자동화·가용성</td></tr><tr><td>컨테이너 네트워크 인터페이스 (CNI)</td><td>네트워크 플러그인 표준</td><td>네트워크 연결·정책</td></tr><tr><td>컨테이너 스토리지 인터페이스 (CSI)</td><td>스토리지 플러그인 표준</td><td>동적볼륨·PV/PVC 지원</td></tr><tr><td>이미지 서명·SBOM (SBOM)</td><td>공급망 신뢰성 메타데이터</td><td>보안·규제 대응 필수</td></tr><tr><td>관측성 (Observability)</td><td>메트릭/로그/트레이스</td><td>장애탐지·성능개선 근간</td></tr></tbody></table><p>컨테이너 플랫폼은 <strong>이미지→런타임→컨테이너</strong>의 실행 흐름을 중심으로 네트워크 (CNI), 스토리지 (CSI), 오케스트레이션으로 확장된다.<br>보안 (이미지 서명·SBOM) 과 관측성은 운영 신뢰성 확보의 필수 요소다.</p><h4 id=컨테이너-구성요소-상호관계표>컨테이너 구성요소 상호관계표<a hidden class=anchor aria-hidden=true href=#컨테이너-구성요소-상호관계표>#</a></h4><table><thead><tr><th>출발 → 도착 (방향)</th><th>관계 목적 (무엇을 위해)</th><th>실무적 고려사항</th></tr></thead><tbody><tr><td>CI/CD → 이미지</td><td>빌드/서명 → 불변 아티팩트 생성</td><td>이미지 스캔·태깅 전략</td></tr><tr><td>이미지 → 레지스트리</td><td>저장·배포 허브</td><td>접근제어·레플리카 전략</td></tr><tr><td>오케스트레이터 → CRI(런타임)</td><td>컨테이너 생성/관리 명령</td><td>런타임 호환성/보안 (rootless)</td></tr><tr><td>오케스트레이터 → CNI</td><td>Pod 네트워크 생성·정책 적용</td><td>네트워크 플러그인 선택 (eBPF 등)</td></tr><tr><td>오케스트레이터 → CSI</td><td>PV/PVC 프로비저닝</td><td>스토리지 클래스 성능·리텐션</td></tr><tr><td>컨테이너 → 관측 시스템</td><td>메트릭/로그/트레이스 전송</td><td>레이블·메타데이터 표준화</td></tr><tr><td>레지스트리 → 보안 툴</td><td>이미지 스캔·SBOM 생성</td><td>자동화된 보안 파이프라인</td></tr></tbody></table><p>각 구성요소는 CI/CD 에서 시작해 오케스트레이터와 런타임·플러그인으로 이어지며, 보안·관측 파이프라인이 전체 흐름을 감싸는 형태다.<br>실무에선 이 흐름의 자동화·정책화가 핵심이다.</p><h4 id=개념별-실무-연관성>개념별 실무 연관성<a hidden class=anchor aria-hidden=true href=#개념별-실무-연관성>#</a></h4><table><thead><tr><th>개념</th><th>실무에서 무엇 (무엇을)</th><th>어떻게 (적용/연결)</th><th>왜 (목적/효용)</th></tr></thead><tbody><tr><td>이미지</td><td>배포 아티팩트</td><td>CI 가 빌드 → 레지스트리 푸시</td><td>일관성·롤백 보장</td></tr><tr><td>런타임</td><td>실행 환경</td><td>오케스트레이터가 CRI 호출</td><td>실행·보안·성능 제어</td></tr><tr><td>네임스페이스</td><td>격리 경계</td><td>각 Pod/컨테이너에 네임스페이스 부여</td><td>프로세스·네트워크 분리</td></tr><tr><td>Cgroup</td><td>자원 제한</td><td>QoS/Limit 설정 (쿠버네티스 리소스)</td><td>자원 고갈 방지·예측성</td></tr><tr><td>CNI</td><td>네트워크 연결</td><td>플러그인 설치·정책 적용</td><td>서비스 디스커버리·보안</td></tr><tr><td>CSI</td><td>스토리지 제공</td><td>PV/PVC 바인딩 및 스토리지 클래스</td><td>상태 ful 서비스 지원</td></tr><tr><td>오케스트레이터</td><td>운영 자동화</td><td>스케줄링·리스케쥴링·셀프힐</td><td>운영 비용 절감·가용성 향상</td></tr><tr><td>보안체인</td><td>공급망·런타임 보호</td><td>서명·스캔·정책·탐지 통합</td><td>규정준수·리스크 저감</td></tr><tr><td>관측성</td><td>성능·문제 진단</td><td>메트릭·로그·트레이스 수집</td><td>SLO 충족·문제해결 가속화</td></tr></tbody></table><p>실무에서는 <strong>이미지→레지스트리→오케스트레이터→런타임→플러그인 (CNI/CSI)</strong> 흐름을 자동화하고, 보안·관측 체인을 전 구간에 적용해 안정적 서비스를 운영한다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=컨테이너-본질구조운영-핵심>컨테이너: 본질·구조·운영 핵심<a hidden class=anchor aria-hidden=true href=#컨테이너-본질구조운영-핵심>#</a></h4><p>컨테이너는 애플리케이션과 필요한 라이브러리를 한 패키지 (이미지) 로 묶어, 운영체제의 커널 기능을 써서 <strong>프로세스 단위로 빠르고 가볍게 격리</strong>해 주는 기술이다.<br>VM 처럼 전체 OS 를 복제하지 않기 때문에 시작이 빠르고 같은 하드웨어에서 더 많은 인스턴스를 띄울 수 있다.<br>다만 컨테이너는 호스트 커널을 공유하므로 보안·데이터 지속성·네트워크 구성 같은 운영 이슈를 별도로 설계해야 한다.</p><p>대규모 운영은 Kubernetes 같은 오케스트레이션이 필요하다.</p><h5 id=컨테이너-핵심-구조와-운영-포인트>컨테이너 핵심 구조와 운영 포인트<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-구조와-운영-포인트>#</a></h5><p><strong>컨테이너화의 구성요소와 작동 원리</strong></p><ul><li><p><strong>Namespacing (격리)</strong></p><ul><li>PID, NET, MNT, UTS, IPC, USER 네임스페이스를 통해 프로세스·네트워크·파일시스템·사용자 정보를 격리.</li></ul></li><li><p><strong>cgroups (자원제어)</strong></p><ul><li>CPU, 메모리, 블록 IO, 네트워크 대역폭 등을 컨트롤·회계해 노이즈 (needy tenant) 제어.</li></ul></li><li><p><strong>이미지와 레이어</strong></p><ul><li>이미지 = 여러 읽기전용 레이어 + 쓰기 계층.</li><li>레이어는 캐시·공유로 효율적 배포.</li></ul></li><li><p><strong>파일시스템 (OverlayFS 등)</strong></p><ul><li>이미지 레이어 위에 쓰기 가능한 계층을 올려 컨테이너 런타임 동작.</li></ul></li><li><p><strong>런타임·OCI 표준</strong></p><ul><li>containerd, runc 등 런타임이 컨테이너를 생성·관리. OCI 규격은 호환성 보장.</li></ul></li><li><p><strong>네트워크와 스토리지</strong></p><ul><li>네트워크: 브리지/호스트/overlay, CNI 플러그인으로 확장성·정책 적용</li><li>스토리지: 볼륨 (영속성), 바인드 마운트, CSI 로 외부 스토리지 연계</li></ul></li><li><p><strong>보안 기법</strong></p><ul><li>최소권한 (Least privilege), rootless 컨테이너, seccomp 프로필, AppArmor/SELinux, 이미지 서명·스캔</li></ul></li><li><p><strong>운영 도구</strong></p><ul><li>오케스트레이션 (Kubernetes), CI/CD(이미지 빌드/스캔/배포 파이프라인), 모니터링 (로그/메트릭/트레이스)</li></ul></li></ul><h5 id=컨테이너-vs-vm가상머신-비교>컨테이너 vs. VM(가상머신) 비교<a hidden class=anchor aria-hidden=true href=#컨테이너-vs-vm가상머신-비교>#</a></h5><ul><li><p><strong>VM(가상머신)</strong>: 하이퍼바이저 위에 <strong>게스트 OS 전체</strong>를 실행하는 가상화. 하드웨어 수준을 가상화해 완전한 시스템을 에뮬레이트함.</p></li><li><p><strong>컨테이너</strong>: 호스트 <strong>OS 커널을 공유</strong>하면서 프로세스 단위로 격리하는 경량 가상화. 이미지 (라이브러리 + 앱) 단위로 이식성이 높음.</p></li></ul><h6 id=아키텍처-차이>아키텍처 차이<a hidden class=anchor aria-hidden=true href=#아키텍처-차이>#</a></h6><ul><li>VM: Hardware → Hypervisor (KVM/ESXi/Hyper-V) → Guest OS → Applications</li><li>Container: Host OS Kernel → Container Runtime (containerd/runc) → Containers(프로세스) → Applications</li></ul><p>핵심: VM 은 <strong>커널 포함</strong>(무거움), 컨테이너는 <strong>커널 공유</strong>(가벼움).</p><h6 id=비교표>비교표<a hidden class=anchor aria-hidden=true href=#비교표>#</a></h6><table><thead><tr><th>항목</th><th style=text-align:right>VM (가상머신)</th><th>컨테이너</th></tr></thead><tbody><tr><td>격리 단위</td><td style=text-align:right>전체 게스트 OS (완전 가상화)</td><td>프로세스 네임스페이스 + cgroups</td></tr><tr><td>오버헤드</td><td style=text-align:right>높음 (OS + 가상화 오버헤드)</td><td>낮음 (커널 공유)</td></tr><tr><td>시작 시간</td><td style=text-align:right>수십 초 ~ 수 분</td><td>수십 밀리초 ~ 수 초</td></tr><tr><td>밀도<br>(한 호스트에 가능한 인스턴스 수)</td><td style=text-align:right>낮음</td><td>높음</td></tr><tr><td>이식성</td><td style=text-align:right>이미지 + 하드웨어/드라이버 제약</td><td>이미지 (컨테이너) 중심<br>—" 한 번 빌드, 어디서나 실행 "</td></tr><tr><td>운영 복잡도</td><td style=text-align:right>VM 관리 (이미지·OS 패치) 필요</td><td>이미지·런타임 관리, 오케스트레이션 필요</td></tr><tr><td>보안 경계</td><td style=text-align:right>강함 (하드 분리 수준)</td><td>약할 수 있음 (커널 공유)<br>—보안 추가 필요</td></tr><tr><td>자원 제어</td><td style=text-align:right>가상화된 자원 (가상 CPU/RAM)</td><td>cgroups 로 세밀 제어 가능</td></tr><tr><td>사용 사례</td><td style=text-align:right>완전한 OS 격리, 레거시 앱, 다른 커널 필요 시</td><td>마이크로서비스, 빠른 배포, CI/CD, 스케일아웃</td></tr></tbody></table><h6 id=장단점-요약>장단점 요약<a hidden class=anchor aria-hidden=true href=#장단점-요약>#</a></h6><table><thead><tr><th>항목</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td><strong>VM (가상머신)</strong></td><td>- 강력한 격리 (보안·권한 분리) 가능<br>- 서로 다른 커널/OS 배포판 동시 운영 가능<br>- 전통적 인프라 (하이퍼바이저) 와 호환성 우수</td><td>- 무겁고 부팅/오버헤드 큼<br>- 자원 효율 낮음 (밀도 제한)<br>- OS 패치·이미지 관리 등 운영 비용 증가</td></tr><tr><td><strong>컨테이너</strong></td><td>- 경량·빠른 시작으로 배포 민첩성 우수<br>- 동일 이미지로 개발→테스트→운영 일관성 보장<br>- 높은 인스턴스 밀도 (리소스 효율적)</td><td>- 호스트 커널 공유로 커널 취약점 전파 위험<br>- 영속성·네트워크·보안 별도 설계 필요<br>- 대규모 운영 시 오케스트레이터 필요</td></tr></tbody></table><h6 id=실무에서-어느-걸-선택할까>실무에서 어느 걸 선택할까?<a hidden class=anchor aria-hidden=true href=#실무에서-어느-걸-선택할까>#</a></h6><ul><li><strong>레거시 어플리케이션 / 커널 의존성 있는 서비스 / 강력한 보안 분리 필요</strong> → <strong>VM</strong></li><li><strong>마이크로서비스, CI/CD, 빠른 스케일, 경량화가 중요</strong> → <strong>컨테이너</strong></li><li><strong>혼합 환경 (현실적 선택)</strong>: 핵심 보안 경계나 특정 레거시 워크로드는 VM, 신규 마이크로서비스는 컨테이너로 운영하는 하이브리드가 일반적.</li></ul><h5 id=네임스페이스-namespace-과-cgroups>네임스페이스 (namespace) 과 Cgroups<a hidden class=anchor aria-hidden=true href=#네임스페이스-namespace-과-cgroups>#</a></h5><ul><li><strong>네임스페이스</strong>: 프로세스가 보는 시스템 객체 (프로세스 ID, 네트워크 인터페이스, 마운트, 사용자 등) 를 <strong>격리</strong>해 " 각각의 작은 OS" 처럼 보이게 한다.</li><li><strong>cgroups (control groups)</strong>: 프로세스 집합에 대해 <strong>CPU/메모리/IO/PID 등 자원 사용량을 제한·계측·관리</strong>한다.</li><li>컨테이너 = 네임스페이스 (격리) + cgroups(자원제어) + 이미지 (파일시스템) 조합으로 만들어진 경량 가상화 단위다.</li></ul><h6 id=어떻게-네임스페이스와-cgroups-가-컨테이너를-만들까>어떻게 네임스페이스와 Cgroups 가 컨테이너를 만들까?<a hidden class=anchor aria-hidden=true href=#어떻게-네임스페이스와-cgroups-가-컨테이너를-만들까>#</a></h6><ol><li>이미지 준비 → OCI 런타임에게 실행 요청</li><li>런타임 (<code>runc</code>) 이 새 프로세스 생성 시 <code>clone()</code> 으로 네임스페이스별 분리 (PID/NET/…)</li><li>런타임이 cgroup 을 생성하고 해당 프로세스를 그 그룹에 넣어 자원 제한 적용</li><li>프로세스는 호스트 커널을 사용하지만, 네임스페이스로 보이는 환경은 격리됨</li></ol><p>이 과정은 OCI 런타임 사양에 정의되어 있으며 <code>containerd</code>/<code>runc</code>/<code>crun</code> 같은 구현체가 담당한다.</p><h6 id=네임스페이스-namespace>네임스페이스 (namespace)<a hidden class=anchor aria-hidden=true href=#네임스페이스-namespace>#</a></h6><p>Linux 네임스페이스는 프로세스 집단이 <strong>어떤 시스템 리소스를 별도로 보느냐</strong>를 결정한다.</p><p><strong>주요 네임스페이스 타입</strong>:</p><ul><li><strong>PID namespace</strong>: 프로세스 ID 공간 분리—내부에서 가장 먼저 실행된 프로세스가 PID 1 이 된다 (프로세스 계층 분리).</li><li><strong>NET (network) namespace</strong>: 네트워크 인터페이스·라우팅 테이블 분리—같은 호스트에서 서로 완전히 독립된 네트워크 스택을 가질 수 있음.</li><li><strong>MNT (mount) namespace</strong>: 마운트 포인트 분리—서로 다른 루트 (overlay) 보이게 함.</li><li><strong>UTS namespace</strong>: 호스트네임과 도메인네임 분리.</li><li><strong>IPC namespace</strong>: System V IPC, POSIX message queue 분리.</li><li><strong>USER namespace</strong>: 사용자 (UID)/그룹 ID(GID) 맵핑—비특권 사용자로도 루트 권한을 네임스페이스 내부에 매핑할 수 있게 해줌 (보안적 이점).</li><li><strong>CGROUP namespace</strong>: cgroup 계층을 분리 (커널 4.6+ 에서 선택적).</li></ul><p><strong>원리</strong>:</p><ul><li>커널이 각 네임스페이스 타입에 대해 별도의 " 뷰 (view)" 를 유지하고, 그 네임스페이스에 속한 프로세스는 해당 뷰만 보게 된다.</li><li>네임스페이스는 <code>clone()</code>/<code>unshare()</code>/<code>setns()</code> 시스템콜로 생성·조작 가능하다.</li></ul><blockquote><p>런타임 (예: <code>runc</code>) 은 이 namespace 들을 생성하고 프로세스를 이 namespace 들 안에서 실행시켜 " 격리 " 를 만든다.</p></blockquote><p><strong>네임스페이스 확인 방법 (호스트에서)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 실행 중 컨테이너의 PID 확인</span>
</span></span><span class=line><span class=cl><span class=nv>CID</span><span class=o>=</span>myapp
</span></span><span class=line><span class=cl><span class=nv>PID</span><span class=o>=</span><span class=k>$(</span>docker inspect --format <span class=s1>&#39;{{.State.Pid}}&#39;</span> <span class=nv>$CID</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$PID</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 해당 PID의 네임스페이스들 확인</span>
</span></span><span class=line><span class=cl>ls -l /proc/<span class=nv>$PID</span>/ns
</span></span><span class=line><span class=cl><span class=c1># 또는 각 네임스페이스의 심볼릭 링크 확인</span>
</span></span><span class=line><span class=cl>readlink /proc/<span class=nv>$PID</span>/ns/net
</span></span></code></pre></td></tr></table></div></div><h6 id=cgroups>Cgroups<a hidden class=anchor aria-hidden=true href=#cgroups>#</a></h6><ul><li><strong>cgroups(control groups)</strong> 는 프로세스 그룹에 대해 CPU/메모리/IO/PIDs 등 자원 사용을 제한·측정·관리한다.</li><li><strong>컨테이너 = 네임스페이스 (격리) + cgroups(제어)</strong> 조합으로 안전하게 다중 워크로드를 돌린다.</li></ul><p><strong>두 가지 버전</strong>:</p><ul><li><strong>cgroup v1</strong>: 각 리소스 (controller) 가 별도 계층을 가짐 (<code>/sys/fs/cgroup/cpu</code>, <code>/sys/fs/cgroup/memory</code> 등).</li><li><strong>cgroup v2</strong>: 통합 계층 모델—단일 계층에서 여러 리소스 제어 (최근 권장). (<code>/sys/fs/cgroup/</code> 하위)</li></ul><table><thead><tr><th>항목</th><th>cgroups v1</th><th>cgroups v2</th><th>비고 / 권장</th></tr></thead><tbody><tr><td>계층 구조 (hierarchy)</td><td>컨트롤러별로 여러 계층 (multiple hierarchies) 가능</td><td>단일 통합 계층 (unified hierarchy)</td><td>v2 는 운영 단순성↑.</td></tr><tr><td>컨트롤러 동작</td><td>컨트롤러별 동작·정책이 서로 다름</td><td>통합된 동작 모델로 일관성 제공</td><td>v1 은 유연하지만 예측성·자동화에 불리.</td></tr><tr><td>프로세스/스레드 배치</td><td>스레드가 서로 다른 cgroup 에 속할 수 있음</td><td>프로세스의 모든 스레드가 같은 cgroup(스레드 분리 금지)</td><td>v2 가 구현 단순화·정확한 계측 지원.</td></tr><tr><td>프로세스 첨부 규칙</td><td>내부 노드에 프로세스 첨부 가능 (유연)</td><td>일반적으로 리프 (leaf) 에만 프로세스 첨부 허용</td><td>리프 규칙은 자원 경쟁 문제 완화.</td></tr><tr><td>계측 (특히 메모리)</td><td>일부 계측에 불일치·누락 가능</td><td>통합된 메모리 계측 등 정확성 향상</td><td>메모리·swap 회계 개선.</td></tr><tr><td>API/파일시스템 인터페이스</td><td>컨트롤러별 인터페이스 (/sys/fs/cgroup//…)</td><td>통일된 API(/sys/fs/cgroup/…)</td><td>사용자 공간 도구 수정 필요할 수 있음.</td></tr><tr><td>운영 도구 호환성</td><td>레거시 툴과 폭넓은 호환성</td><td>systemd·최신 런타임에서 우선 지원</td><td>Kubernetes·containerd 등은 v2 지원 권장.</td></tr><tr><td>전환 난이도</td><td>-</td><td>커널·런타임·도구 호환성 확인 필요</td><td>일부 배포판은 기본 v1·수동 전환 필요.</td></tr><tr><td>장점 요약</td><td>유연성, 레거시 호환</td><td>일관성·단순성·정확한 계측</td><td>운영 자동화·안정성 관점에서 v2 우세.</td></tr><tr><td>단점 요약</td><td>관리 복잡성, 예측성 부족</td><td>일부 레거시 컨트롤러/도구 미지원 가능</td><td>전환계획·테스트 필요.</td></tr></tbody></table><p><strong>주요 제어/계수 항목</strong>:</p><ul><li><strong>cpu / cpu.max (v2)</strong>: CPU 사용 비율 (쿼타/period) 설정 → 특정 그룹에 CPU 할당량 제한.</li><li><strong>memory / memory.max</strong>: 메모리 (및 swap) 사용 상한. 초과 시 OOM 동작.</li><li><strong>pids.max</strong>: 그룹당 생성 가능한 프로세스 수 제한 (포크 폭주 방지).</li><li><strong>io</strong>: 블록 디바이스 IO 대역폭 제어.</li><li><strong>cpu.stat, memory.current</strong> 등으로 현재 사용량 모니터링 가능.</li></ul><p><strong>동작 원리</strong>:</p><ul><li>프로세스가 생성 (혹은 기존 프로세스를 그룹에 추가) 되면 그 프로세스의 PID 를 해당 cgroup 의 <code>cgroup.procs</code>(v1 은 tasks) 파일에 넣어준다.</li><li>커널 스케줄러/메모리 서브시스템/블록 IO 서브시스템이 이 정보를 보고 할당·계측·제한을 적용한다.</li></ul><p><strong>Docker 에서의 cgroups 사용</strong>:</p><ul><li><p><code>--memory=256m</code>: 메모리 상한 설정</p></li><li><p><code>--cpus="0.5"</code>: CPU 사용 제한 (0.5 vCPU)</p></li><li><p><code>--cpu-shares</code>: 우선순위 (상대치)</p></li><li><p><code>--pids-limit=100</code>: 프로세스 수 제한<br>예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d --name limited <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --memory<span class=o>=</span>256m --cpus<span class=o>=</span><span class=s2>&#34;0.5&#34;</span> --pids-limit<span class=o>=</span><span class=m>100</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  myapp:1.0
</span></span></code></pre></td></tr></table></div></div><p>컨테이너 런타임은 내부적으로 cgroups 에 관련 설정을 생성한다. 운영자는 <code>docker stats</code> 로 실시간 사용량을 확인할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker stats myapp --no-stream
</span></span></code></pre></td></tr></table></div></div><p>또는 호스트에서 (컨테이너의 PID 로) cgroup 경로 확인:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>PID</span><span class=o>=</span><span class=k>$(</span>docker inspect --format <span class=s1>&#39;{{.State.Pid}}&#39;</span> myapp<span class=k>)</span>
</span></span><span class=line><span class=cl>cat /proc/<span class=nv>$PID</span>/cgroup
</span></span><span class=line><span class=cl><span class=c1># cgroup v2의 경우:</span>
</span></span><span class=line><span class=cl>cat /proc/<span class=nv>$PID</span>/mounts <span class=p>|</span> grep cgroup
</span></span></code></pre></td></tr></table></div></div></li></ul><h6 id=실습-예제>실습 예제<a hidden class=anchor aria-hidden=true href=#실습-예제>#</a></h6><blockquote><p>대부분 명령은 <strong>root 권한</strong>이 필요하다. 환경에 따라 <code>ip</code>/<code>unshare</code>/<code>systemd-run</code> 등이 없을 수 있음.</p></blockquote><ol><li><p>간단한 PID 네임스페이스 생성 (unshare)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 새로운 PID 네임스페이스에서 bash 실행 (내부에서 ps를 보면 PID 1이 보인다)</span>
</span></span><span class=line><span class=cl>sudo unshare --fork --pid --mount-proc bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 내부에서 확인</span>
</span></span><span class=line><span class=cl>ps -eo pid,cmd
</span></span><span class=line><span class=cl><span class=c1># 밖(다른 터미널)에서 확인하면 내부 프로세스는 다른 PID 공간으로 보임</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>효과: 내부 bash 는 별도의 PID 네임스페이스에 속하고, 내부에서 실행되는 프로세스들은 외부 PID 와 다르게 보인다.</li></ul></li><li><p>네트워크 네임스페이스와 veth 페어 예시</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 네임스페이스 생성</span>
</span></span><span class=line><span class=cl>sudo ip netns add ns1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># veth 페어 생성 (veth0 &lt;-&gt; veth1)</span>
</span></span><span class=line><span class=cl>sudo ip link add veth0 <span class=nb>type</span> veth peer name veth1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 한쪽을 네임스페이스로 이동</span>
</span></span><span class=line><span class=cl>sudo ip link <span class=nb>set</span> veth1 netns ns1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 호스트 쪽 설정</span>
</span></span><span class=line><span class=cl>sudo ip addr add 10.200.1.1/24 dev veth0
</span></span><span class=line><span class=cl>sudo ip link <span class=nb>set</span> veth0 up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 네임스페이스 안 설정</span>
</span></span><span class=line><span class=cl>sudo ip netns <span class=nb>exec</span> ns1 ip addr add 10.200.1.2/24 dev veth1
</span></span><span class=line><span class=cl>sudo ip netns <span class=nb>exec</span> ns1 ip link <span class=nb>set</span> veth1 up
</span></span><span class=line><span class=cl>sudo ip netns <span class=nb>exec</span> ns1 ip link <span class=nb>set</span> lo up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 테스트: 네임스페이스 내부에서 호스트로 ping</span>
</span></span><span class=line><span class=cl>sudo ip netns <span class=nb>exec</span> ns1 ping -c <span class=m>2</span> 10.200.1.1
</span></span></code></pre></td></tr></table></div></div><ul><li>효과: <code>ns1</code> 은 호스트와 독립된 네트워크 스택을 가진다 (라우팅·interfaces 분리).</li></ul></li><li><p>cgroup v2 로 자원 제한 해보기 (직접 조작)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># cgroup v2가 마운트되어 있는지 확인</span>
</span></span><span class=line><span class=cl>mount <span class=p>|</span> grep cgroup2
</span></span><span class=line><span class=cl><span class=c1># 보통 /sys/fs/cgroup 에 마운트됨</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># demo 그룹 생성</span>
</span></span><span class=line><span class=cl>sudo mkdir /sys/fs/cgroup/demo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 현재 쉘의 PID를 그룹에 넣음 -&gt; 이 쉘과 그 자식에 제한 적용</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$$</span> <span class=p>|</span> sudo tee /sys/fs/cgroup/demo/cgroup.procs
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># CPU 제한: cpu.max -&gt; &#34;&lt;quota&gt; &lt;period&gt;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># 예: 50% 제한 -&gt; quota=50000, period=100000 (마이크로초)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;50000 100000&#34;</span> <span class=p>|</span> sudo tee /sys/fs/cgroup/demo/cpu.max
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 메모리 제한: memory.max (바이트 또는 접미사 허용)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;100M&#34;</span> <span class=p>|</span> sudo tee /sys/fs/cgroup/demo/memory.max
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 확인: 현재 사용량</span>
</span></span><span class=line><span class=cl>cat /sys/fs/cgroup/demo/cpu.stat
</span></span><span class=line><span class=cl>cat /sys/fs/cgroup/demo/memory.current
</span></span></code></pre></td></tr></table></div></div><ul><li>효과: 이 쉘에서 실행한 프로세스들은 demo cgroup 의 CPU/메모리 한도를 받는다.</li></ul></li><li><p>systemd 를 이용한 간단한 방법 (권장: 안전하고 편리)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># systemd-run으로 메모리 제한 적용된 scope 생성 (예: 50M)</span>
</span></span><span class=line><span class=cl>sudo systemd-run --unit<span class=o>=</span>testscope --scope -p <span class=nv>MemoryMax</span><span class=o>=</span>50M sleep <span class=m>300</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 프로세스 확인</span>
</span></span><span class=line><span class=cl>systemctl status testscope
</span></span></code></pre></td></tr></table></div></div><ul><li>장점: systemd 가 cgroup 을 관리하므로 수작업보다 안전.</li></ul></li><li><p>Docker 에서의 cgroup 옵션 (사용 예)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 메모리, CPU 제한을 주고 컨테이너 실행</span>
</span></span><span class=line><span class=cl>docker run --rm -it --cpus<span class=o>=</span><span class=s2>&#34;&#34;</span> --memory<span class=o>=</span><span class=s2>&#34;128m&#34;</span> busybox sh
</span></span></code></pre></td></tr></table></div></div><ul><li>컨테이너 런타임이 내부적으로 네임스페이스 + cgroup 을 조합해 적용한다.</li></ul></li></ol><h5 id=이미지-vs-컨테이너>이미지 vs. 컨테이너<a hidden class=anchor aria-hidden=true href=#이미지-vs-컨테이너>#</a></h5><ul><li><p><strong>이미지 (Image)</strong> 는 <em>불변 (immutable) 한 패키지 (설정·바이너리·레이어)</em>.</p></li><li><p><strong>컨테이너 (Container)</strong> 는 그 이미지를 사용해 실행된 <em>런타임 인스턴스 (프로세스 + 쓰기 레이어 + 네임스페이스·cgroups)</em>.</p></li><li><p><strong>왜 이미지/컨테이너가 유리한가</strong></p><ul><li>재현성: 동일 이미지 → 동일 동작.</li><li>경량성: VM 보다 오버헤드 작음 (커널 공유).</li><li>자동화: CI/CD 로 빌드→테스트→배포 파이프라인 구성 용이.</li></ul></li></ul><h6 id=이미지-image>이미지 (Image)<a hidden class=anchor aria-hidden=true href=#이미지-image>#</a></h6><ul><li><p><strong>정의</strong>: 애플리케이션 실행에 필요한 파일, 라이브러리, 설정, 메타데이터를 레이어로 묶은 불변 패키지. (예: <code>myrepo/app:1.0</code>)</p></li><li><p><strong>특징</strong></p><ul><li>불변 (immutable): 빌드 후 태그된 이미지는 변경되지 않음 (새 버전은 새로운 태그).</li><li>레이어 기반: 각 Dockerfile 단계가 레이어로 쌓여 캐시·공유 가능.</li><li>저장/배포: 레지스트리 (Docker Hub, ECR, GCR 등) 에 저장·풀/푸시로 배포.</li></ul></li><li><p><strong>실무적 역할</strong></p><ul><li>CI 에서 빌드 → 테스트 → 레지스트리에 프로모션 (Dev→Staging→Prod).</li><li>재현성 (reproducibility) 확보: 동일 이미지로 어디서나 동일하게 동작.</li></ul></li><li><p><strong>보안·운영 포인트</strong></p><ul><li>취약점 스캔 (Trivy 등), 이미지 서명 (Cosign), 최소 권한 베이스 이미지 권장.</li><li>이미지 크기·레이어 수는 배포·네트워크 비용에 영향.</li></ul></li></ul><h6 id=컨테이너-container>컨테이너 (Container)<a hidden class=anchor aria-hidden=true href=#컨테이너-container>#</a></h6><ul><li><p><strong>정의</strong>: 이미지를 기반으로 생성된 실행 단위 (프로세스) 로, 읽기전용 이미지 레이어 위에 쓰기 가능한 상위 레이어가 더해진 상태. 네임스페이스와 cgroups 로 호스트에서 격리되어 실행됨.</p></li><li><p><strong>특징</strong></p><ul><li>가변 (stateful/ephemeral): 실행 중 상태 (파일시스템 변화·메모리 등) 가 존재. 일반적으로 휘발성 (ephemeral) 이며, 상태는 볼륨에 보존.</li><li>런타임 속성: 네트워크 네임스페이스, 프로세스 PID 네임스페이스, 리소스 제약 (cgroups) 적용.</li><li>생성/소멸: <code>docker run</code> 등으로 즉시 생성·중지·삭제 가능.</li></ul></li><li><p><strong>실무적 역할</strong></p><ul><li>실제 트래픽을 처리하는 인스턴스. 헬스체크·로그·메트릭·오토스케일 대상.</li><li>상태 저장은 외부 볼륨 (예: PVC) 또는 외부 서비스를 통해 관리.</li></ul></li><li><p><strong>보안·운영 포인트</strong></p><ul><li>리소스 제한 (메모리/CPU/pids) 설정 필요, 네트워크 정책·권한 최소화 적용, 컨테이너 런타임의 취약점 (커널 공유) 에 주의.</li></ul></li></ul><h6 id=핵심-차이점>핵심 차이점<a hidden class=anchor aria-hidden=true href=#핵심-차이점>#</a></h6><table><thead><tr><th>항목</th><th style=text-align:right>이미지 (Image)</th><th style=text-align:right>컨테이너 (Container)</th><th>비고</th></tr></thead><tbody><tr><td>정의</td><td style=text-align:right>불변 패키지 (파일·라이브러리·설정)</td><td style=text-align:right>이미지 기반의 실행 인스턴스 (프로세스 + 쓰기 레이어)</td><td>이미지 = 배포 단위, 컨테이너 = 실행 단위</td></tr><tr><td>상태성</td><td style=text-align:right>불변 (immutable)</td><td style=text-align:right>가변 (ephemeral)—실행 중 변경 발생</td><td>변경은 컨테이너 상위 레이어나 볼륨에 저장</td></tr><tr><td>파일시스템 구조</td><td style=text-align:right>다중 레이어 (읽기 전용)</td><td style=text-align:right>읽기 전용 이미지 레이어 + 쓰기 상위 레이어</td><td>레이어 캐시로 빌드 성능 최적화</td></tr><tr><td>생성/소멸</td><td style=text-align:right>빌드 (<code>docker build</code>) → 레지스트리 저장</td><td style=text-align:right><code>docker run</code> 으로 생성, <code>docker rm</code> 으로 삭제</td><td>컨테이너는 빠르게 생성·파괴 가능</td></tr><tr><td>저장 위치</td><td style=text-align:right>레지스트리 (원격) / 로컬 이미지 캐시</td><td style=text-align:right>호스트의 런타임 (도커 엔진) / 상태는 볼륨에 저장</td><td>이미지는 푸시/풀; 컨테이너는 로컬 실행</td></tr><tr><td>네트워크</td><td style=text-align:right>없음 (설정 값만)</td><td style=text-align:right>네임스페이스 기반 네트워크 스택 보유</td><td>포트 매핑·브리지/호스트/CNI 적용</td></tr><tr><td>리소스 제어</td><td style=text-align:right>N/A(정책은 이미지에는 없음)</td><td style=text-align:right>cgroups 로 CPU/메모리/IO 제한 가능</td><td>운영에서 반드시 설정 권장</td></tr><tr><td>보안</td><td style=text-align:right>이미지 서명·스캔 적용 대상</td><td style=text-align:right>런타임 권한·네트워크 정책·격리 적용 대상</td><td>둘 다 보안 관점에서 중요</td></tr><tr><td>변경·업그레이드</td><td style=text-align:right>새로운 이미지 태그 생성 → 프로모션</td><td style=text-align:right>재배포 (새 이미지로 컨테이너 교체)</td><td>배포 전략: 롤링/카나리/블루그린</td></tr><tr><td>용도</td><td style=text-align:right>CI 빌드·배포 단위, 아티팩트</td><td style=text-align:right>실행 중인 서비스·워크로드</td><td>이미지 먼저, 컨테이너로 실행</td></tr><tr><td>관리 툴</td><td style=text-align:right>빌드 도구 (Dockerfile, BuildKit) · 레지스트리</td><td style=text-align:right>런타임 (docker, containerd) · 오케스트레이터 (K8s)</td><td>운영 스택이 달라짐</td></tr></tbody></table><h4 id=컨테이너-등장-배경과-발전-과정>컨테이너 등장 배경과 발전 과정<a hidden class=anchor aria-hidden=true href=#컨테이너-등장-배경과-발전-과정>#</a></h4><p>컨테이너 기술은 <strong>환경 차이로 인한 배포 실패</strong>와 <strong>VM 의 무거운 오버헤드</strong>라는 문제로 시작됐다.<br>리눅스 커널의 네임스페이스와 cgroups 가 경량 격리를 가능하게 했고, LXC 로 시스템 컨테이너가 현실화됐다.<br>Docker 는 이미지·런타리·레지스트리 개념으로 개발자 생산성을 폭발적으로 높였고, Kubernetes 는 대규모 컨테이너 운영을 자동화해 클라우드 네이티브 시대를 열었다.<br>이후 표준 (OCI) 과 런타임 분리 (CRI), 서비스 메쉬·GitOps 등 생태계가 성숙했다.</p><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><ul><li><strong>환경 불일치</strong>: 개발 환경과 운영 환경의 차이로 발생하는 실행 오류·디버깅 비용.</li><li><strong>배포·의존성 복잡성</strong>: 라이브러리·런타임 버전이 다른 여러 환경에서의 관리 부담.</li><li><strong>자원 효율성 요구</strong>: VM 보다 더 가볍게 여러 애플리케이션을 같은 물리자원에서 운용하고자 하는 수요.</li><li><strong>아키텍처 변화</strong>: 마이크로서비스·CI/CD 의 확산으로 빠른 빌드·배포·롤백이 필수화.</li><li><strong>운영 자동화 필요</strong>: 수동 배포·스케줄링으로는 대규모 서비스 운영이 불가능.</li></ul><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>연도</th><th>기술/이벤트</th><th>등장 이유 (문제)</th><th>개선된 점 / 기여</th></tr></thead><tbody><tr><td style=text-align:right>2000 년대 초</td><td>리눅스 네임스페이스, cgroups 출현</td><td>경량 격리·자원제어의 커널 수준 지원 요구</td><td>프로세스 격리·리소스 제한으로 컨테이너 기초 제공</td></tr><tr><td style=text-align:right>2008</td><td>LXC (Linux Containers)</td><td>커널 기능을 사용한 시스템 컨테이너 필요</td><td>루트 파일시스템·네임스페이스를 묶은 컨테이너 구현</td></tr><tr><td style=text-align:right>2013</td><td>Docker 출시</td><td>개발자 친화적 빌드·이미지·배포 간소화 요구</td><td>이미지 레이어·Dockerfile·레지스트리로 일관 배포 해결</td></tr><tr><td style=text-align:right>2014</td><td>Kubernetes 발표</td><td>대규모 컨테이너 운영·오케스트레이션 필요</td><td>스케줄링·서비스·자동화·셀프 힐 제공</td></tr><tr><td style=text-align:right>2015~</td><td>클라우드 네이티브 확산, OCI 표준화</td><td>벤더 종속·호환성 문제 해결 필요</td><td>OCI/CRI 표준, 컨테이너 런타임 분리, 풍부한 CNCF 생태계</td></tr></tbody></table><pre class=mermaid>gantt
    title 컨테이너 발전 타임라인
    dateFormat  YYYY
    axisFormat  %Y

    section 커널 기초
    namespaces &amp; cgroups      :a1, 2002, 2008

    section 시스템 컨테이너
    LXC 출시                  :a2, 2008, 1

    section 개발자 친화화
    Docker 출시               :a3, 2013, 1

    section 오케스트레이션
    Kubernetes 발표           :a4, 2014, 1

    section 표준화·생태계
    OCI/CRI/CNCF 확산         :a5, 2015, 2019
</pre><p>컨테이너는 커널 수준의 격리 (네임스페이스 +cgroups) 를 출발점으로, LXC 가 시스템 컨테이너를 실현했고 Docker 가 개발자 경험 (이미지·빌드·공유) 을 혁신했다. Kubernetes 는 운영·오케스트레이션을 해결하며 컨테이너 기술을 대규모 서비스 운영의 표준으로 만들었다. 이후 OCI/CRI 같은 표준과 containerd/runc 등 런타임 분리, 서비스메시·GitOps 같은 운영 패턴이 생겨 생태계가 성숙했다.</p><h4 id=컨테이너화가-해결하는-과제와-목적>컨테이너화가 해결하는 과제와 목적<a hidden class=anchor aria-hidden=true href=#컨테이너화가-해결하는-과제와-목적>#</a></h4><p>컨테이너화는 애플리케이션과 그 실행환경 (라이브러리·설정) 을 <strong>이미지라는 단위로 묶어</strong> 어디서나 동일하게 실행하도록 만드는 기술이다.<br>이로써 개발·테스트·운영 환경차이가 사라지고 (일관성), 가볍게 여러 인스턴스를 띄워 자원을 효율적으로 쓰며 (자원 효율성), 자동화된 파이프라인으로 빠르게 배포·롤백한다 (신속한 롤아웃).<br>네임스페이스·cgroup 을 통한 경계로 서로 영향을 주지 않게 격리해 안정성과 보안을 향상시키는 것이 핵심 목적이다.</p><h5 id=컨테이너화가-해결하는-주요-문제>컨테이너화가 해결하는 주요 문제<a hidden class=anchor aria-hidden=true href=#컨테이너화가-해결하는-주요-문제>#</a></h5><table><thead><tr><th>문제 영역</th><th>기존 문제</th><th>컨테이너화가 제공하는 개선 방식</th><th>기대 효과</th></tr></thead><tbody><tr><td>환경 불일치</td><td>개발·운영 환경 차이로 버그 발생</td><td>이미지로 런타임·종속성 캡슐화</td><td>배포 재현성, 디버깅 비용 감소</td></tr><tr><td>의존성 충돌</td><td>라이브러리·버전 충돌</td><td>격리된 런타임 환경 제공</td><td>안정적 실행, 버전 관리 용이</td></tr><tr><td>배포 복잡성</td><td>환경별 수작업 설정</td><td>이미지 + 매니페스트 (선언적) 배포</td><td>배포 표준화·자동화</td></tr><tr><td>자원 비효율</td><td>VM 오버헤드</td><td>커널 공유, 경량 프로세스 실행</td><td>인프라 비용 절감, 높은 밀도</td></tr><tr><td>확장성 한계</td><td>수동 확장·복구</td><td>오케스트레이션 (오토스케일)</td><td>트래픽 탄력 대응</td></tr><tr><td>격리 부족</td><td>프로세스간 간섭·보안위험</td><td>네임스페이스·cgroup 격리</td><td>안정성·보안 향상</td></tr></tbody></table><p>컨테이너화는 <em>환경 재현성 (이미지)</em>, <em>의존성 격리</em>, <em>선언적 배포</em>를 통해 개발·배포의 반복 가능성과 속도를 높인다.<br>하드웨어·소프트웨어 자원을 더 효율적으로 사용해 비용을 줄이며, 오케스트레이션으로 자동 확장·회복을 구현한다.<br>네임스페이스·cgroup 은 서비스 간 간섭을 줄여 안정성과 보안을 강화한다.</p><h5 id=컨테이너화의-핵심-목적>컨테이너화의 핵심 목적<a hidden class=anchor aria-hidden=true href=#컨테이너화의-핵심-목적>#</a></h5><table><thead><tr><th>핵심 목적</th><th>설명</th><th>실무적 구현요소</th></tr></thead><tbody><tr><td>환경 일관성</td><td>동일 이미지로 어디서나 동일 동작 보장</td><td>Docker/OCI 이미지, 레지스트리, 이미지 프로모션</td></tr><tr><td>신속한 배포</td><td>CI/CD 와 연계한 빈번한 배포·안전한 롤백</td><td>GitOps, ArgoCD, Jenkins, 블루/카나리 배포</td></tr><tr><td>자원 효율성</td><td>VM 대비 경량, 높은 밀도</td><td>컨테이너 런타임, 오토스케일, 서버리스 연계</td></tr><tr><td>격리·안정성</td><td>프로세스·네트워크·리소스 분리</td><td>Namespaces, cgroups, 네트워크 정책, gVisor</td></tr></tbody></table><p>컨테이너화는 운영 효율성과 개발 민첩성을 동시에 달성하는 기술적 기반이다.<br>이미지·레지스트리·오케스트레이터 조합으로 빠른 배포 파이프라인을 만들고, 런타임·네트워크·리소스 격리로 안정적 운영을 지원한다.</p><h5 id=문제와-목적의-연계-맵>문제와 목적의 연계 맵<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연계-맵>#</a></h5><table><thead><tr><th>문제 영역</th><th>관련 핵심 목적 (우선순위)</th></tr></thead><tbody><tr><td>환경 불일치</td><td>환경 일관성 (우선)</td></tr><tr><td>의존성 충돌</td><td>환경 일관성, 격리</td></tr><tr><td>배포 복잡성</td><td>신속한 배포</td></tr><tr><td>자원 비효율</td><td>자원 효율성</td></tr><tr><td>확장성 한계</td><td>신속한 배포, 자원 효율성</td></tr><tr><td>격리 부족</td><td>격리·안정성</td></tr></tbody></table><p>각 문제는 하나 이상의 핵심 목적로 해결된다.<br>예컨대 <em>환경 불일치</em>는 <strong>환경 일관성</strong>으로 직접 해결되고, <em>의존성 충돌</em>은 <strong>환경 일관성</strong>과 <strong>격리</strong>의 조합으로 완화된다.<br>배포·확장 문제는 CI/CD 와 오케스트레이션 (신속한 배포 + 자원 효율성) 으로 실현된다.</p><h4 id=컨테이너-전제조건운영요건>컨테이너 전제조건·운영요건<a hidden class=anchor aria-hidden=true href=#컨테이너-전제조건운영요건>#</a></h4><p>컨테이너를 안전·효과적으로 운영하려면 기술적·조직적 준비가 모두 필요하다.</p><p>기술적으로는 리눅스 커널의 네임스페이스와 cgroups 가 반드시 활성화된 호스트, OCI 규격 이미지와 이를 구동하는 런타임 (containerd/runc 등), 오버레이 파일시스템과 CNI/CSI 같은 플러그인 지원이 필요하다.</p><p>운영적으로는 CI/CD 로 이미지를 빌드·테스트·배포하고, 레지스트리·이미지 서명·스캐닝으로 공급망을 보호하며, Prometheus/Grafana·로그 집적으로 관측성을 확보해야 한다.</p><p>마지막으로 seccomp·SELinux·rootless 등 런타임 보안 조치로 커널 공유로 인한 리스크를 낮춰야 한다.</p><h5 id=컨테이너-전제조건-요약표>컨테이너 전제조건 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-전제조건-요약표>#</a></h5><table><thead><tr><th>구분</th><th>필수 항목</th><th style=text-align:right>구체 내용 / 예시</th><th>왜 필요한가 (근거)</th></tr></thead><tbody><tr><td>호스트커널</td><td>네임스페이스, cgroups(v2), capabilities</td><td style=text-align:right>PID/NET/MNT/USER 등 네임스페이스, cgroups 로 CPU/MEM/IO 제어</td><td>프로세스·네트워크·파일 시스템 격리 및 자원 제어를 위한 기술적 기반</td></tr><tr><td>런타임·이미지</td><td>containerd, runc, CRI-O, OCI 이미지, 레지스트리</td><td style=text-align:right>이미지 레이어, 이미지 서명·스캔, 프라이빗 레지스트리</td><td>이식성·불변성·공급망 보안을 위해 표준화된 이미지·런타임 필요</td></tr><tr><td>파일시스템</td><td>OverlayFS, 스토리지 드라이버, CSI</td><td style=text-align:right>읽기전용 레이어 공유, 동적 볼륨 프로비저닝</td><td>저장 효율성·빠른 배포·영구 스토리지 연동 보장</td></tr><tr><td>네트워킹</td><td>CNI 플러그인, 네트워크 정책, 서비스 디스커버리</td><td style=text-align:right>Calico/Flannel/Weave, 네트워크 폴리시, Ingress/LB</td><td>동적 컨테이너 네트워크 구성 및 보안 정책 적용 가능</td></tr><tr><td>운영·관측</td><td>CI/CD, 모니터링, 로깅, 레지스트리 관리</td><td style=text-align:right>Jenkins/GitHub Actions, Prometheus, ELK/Fluentd, 이미지 스캔</td><td>빠른 배포·회복·문제탐지·컴플라이언스 확보</td></tr><tr><td>보안·정책</td><td>seccomp, SELinux/AppArmor, rootless, 이미지 검증</td><td style=text-align:right>권한 최소화, syscall 제한, 서명·취약점 스캔</td><td>커널 공유로 인한 공격 표면 완화, 규정 준수 및 감사 대응</td></tr></tbody></table><p>컨테이너 운영의 전제조건은 크게 세 축으로 생각하면 쉽다.</p><ol><li><strong>기술적 기반</strong>(호스트 커널의 네임스페이스·cgroups, 런타임·이미지·오버레이 파일시스템, CNI/CSI 와 같은 플러그인) 은 컨테이너가 동작하고 자원을 통제하는 핵심이다.</li><li><strong>운영 체계</strong>(CI/CD, 모니터링·로깅, 레지스트리 관리) 는 빠른 배포와 문제 대응을 가능하게 한다.</li><li><strong>보안·정책</strong>(이미지 서명·스캔, seccomp/SELinux, 네트워크 폴리시) 은 커널 공유라는 구조적 한계를 보완하는 필수 요소다.</li></ol><p>이 세 축이 함께 준비되어야 컨테이너의 장점을 안전하게 활용할 수 있다.</p><h4 id=컨테이너-핵심-특징-기술-근거와-차별성>컨테이너 핵심 특징: 기술 근거와 차별성<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-특징-기술-근거와-차별성>#</a></h4><p>컨테이너는 운영체제 커널을 공유하면서도 네임스페이스로 프로세스·네트워크·파일시스템을 분리하고 cgroups 로 CPU·메모리 같은 자원을 제한해 빠르고 가벼운 격리를 제공한다.</p><p>애플리케이션은 레이어형 불변 이미지를 통해 어디서나 동일하게 실행되며, Kubernetes 같은 오케스트레이터는 선언적 설정으로 자동 복구·확장·롤링 배포를 수행한다.</p><p>표준화 (OCI/CRI/CNI/CSI) 덕분에 런타임·네트워크·스토리지 구현을 바꾸기 쉬우며, 실무에서는 이미지 서명·SBOM·런타임 보안·관측성을 결합해 안전하고 안정적인 운영을 달성한다.</p><h5 id=컨테이너-특징별-기술-근거와-차별점>컨테이너 특징별 기술 근거와 차별점<a hidden class=anchor aria-hidden=true href=#컨테이너-특징별-기술-근거와-차별점>#</a></h5><h6 id=경량-격리네임스페이스와-cgroups>경량 격리—네임스페이스와 Cgroups<a hidden class=anchor aria-hidden=true href=#경량-격리네임스페이스와-cgroups>#</a></h6><p>네임스페이스 (PID/NET/MNT/UTS/IPC 등) 가 프로세스의 뷰를 분리하고 cgroups 가 리소스 할당·제어를 수행. 이 조합으로 프로세스 수준 격리가 가능.</p><ul><li><p>차별점: VM 의 하드웨어 수준 격리 (하이퍼바이저·게스트커널) 와 달리 컨테이너는 커널을 공유해 훨씬 가볍고 즉시 실행 가능하지만, 커널 취약점은 노드 전체에 영향.</p></li><li><p>적용팁: 민감 워크로드는 추가 격리 (Kata, VM) 고려.</p></li></ul><h6 id=불변-이미지레이어-캐시>불변 이미지·레이어 캐시<a hidden class=anchor aria-hidden=true href=#불변-이미지레이어-캐시>#</a></h6><p>OCI 이미지 스펙 기반으로 각 빌드 단계가 레이어로 저장되어 레지스트리 캐시·전송 최적화가 가능. 이미지는 불변으로 태그/해시로 식별.</p><ul><li><p>차별점: 전통적 패키지/스크립트 배포와 달리 환경 차이에 덜 민감하고 롤백·재현성이 뛰어남.</p></li><li><p>적용팁: 레이어 최소화 (빌드 최적화) 로 이미지 크기·스타트업 속도 개선.</p></li></ul><h6 id=선언적-운영오케스트레이션>선언적 운영·오케스트레이션<a hidden class=anchor aria-hidden=true href=#선언적-운영오케스트레이션>#</a></h6><p>Kubernetes 의 컨트롤 루프 (Desired/Current 상태 비교), 스케줄러, 헬스체크, HPA 등으로 자동화 실현.</p><ul><li><p>차별점: 수동·절차적 운영보다 자동화·관찰·복구가 용이해 대규모 운영에 적합.</p></li><li><p>적용팁: liveness/readiness 설계로 안정적 롤링 업데이트 보장.</p></li></ul><h6 id=표준화된-인터페이스와-에코시스템>표준화된 인터페이스와 에코시스템<a hidden class=anchor aria-hidden=true href=#표준화된-인터페이스와-에코시스템>#</a></h6><p>OCI 이미지·runtime spec, CRI(쿠버네티스와 런타임 연동), CNI(네트워크 플러그인), CSI(스토리지 플러그인) 로 상호운용성 확보.</p><ul><li><p>차별점: 특정 벤더 락인 줄이는 대신 플러그인 선택에 따른 성능·보안 차이는 존재.</p></li><li><p>적용팁: CNI/CSI 선택 시 기능 (네트워크 정책, eBPF 지원)·운영 편의·호환성 점검.</p></li></ul><h6 id=보안관측성컴플라이언스-통합>보안·관측성·컴플라이언스 통합<a hidden class=anchor aria-hidden=true href=#보안관측성컴플라이언스-통합>#</a></h6><p>빌드 단계의 SBOM·이미지서명, 런타임 seccomp/SELinux, 네트워크 정책 (CNI 기반), 중앙 로깅·메트릭·트레이스 통합 (Observability) 으로 전체 수명주기 보호.</p><ul><li><p>차별점: VM 중심 보안은 호스트 격리에 의존하지만 컨테이너는 빌드→배포→런타임 전주기 통합 정책이 필요.</p></li><li><p>적용팁: CI 파이프라인에 스캔·정책 시행을 자동화하고 키 관리는 KMS/HSM 사용.</p></li></ul><h5 id=컨테이너-핵심-특징-비교표>컨테이너 핵심 특징 비교표<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-특징-비교표>#</a></h5><table><thead><tr><th>핵심 특징</th><th>설명</th><th>기술적 근거</th><th>다른 기술 (예: VM) 과의 차별점</th></tr></thead><tbody><tr><td>경량 격리</td><td>프로세스·네트워크·파일시스템 분리</td><td>Linux 네임스페이스, cgroups</td><td>VM: 게스트커널 격리 (무겁고 느림)</td></tr><tr><td>불변 이미지</td><td>레이어 기반 불변 아티팩트</td><td>OCI 이미지 스펙, 레지스트리 캐시</td><td>전통 패키지: 환경 의존성 큼</td></tr><tr><td>선언적 운영</td><td>자동 복구·스케일·롤링 배포</td><td>Kubernetes 컨트롤 루프·스케줄러</td><td>절차적 스크립트 운영보다 자동화 우위</td></tr><tr><td>표준 인터페이스</td><td>런타임·네트워크·스토리지 호환</td><td>OCI/CRI/CNI/CSI</td><td>플랫폼 종속성 감소</td></tr><tr><td>보안·관측성</td><td>SBOM·이미지서명·seccomp·모니터링</td><td>cosign, seccomp, Prometheus, eBPF</td><td>보안은 전주기 통합 필요 (기존 보안과 차별)</td></tr></tbody></table><p>컨테이너는 커널 재사용으로 빠르고 효율적인 격리를 제공하고, 이미지 불변성과 선언적 오케스트레이션으로 일관된 배포·운영을 가능하게 한다. 표준 인터페이스는 에코시스템 호환성을 보장하나 운영·보안 관점에서 런타임 선택과 보완적 격리 (예: VM 대안) 고려가 필요하다.</p><h4 id=컨테이너-운영을-위한-시스템-요건>컨테이너 운영을 위한 시스템 요건<a hidden class=anchor aria-hidden=true href=#컨테이너-운영을-위한-시스템-요건>#</a></h4><p>컨테이너를 안정적으로 운영하려면 단순한 CPU·메모리 숫자 외에 <strong>운영체제 커널 기능</strong>, <strong>스토리지 성능</strong>, <strong>네트워크 기능</strong>, <strong>가속기 드라이버</strong> 같은 세부 조건을 반드시 확인해야 한다.</p><p>최소 환경은 x86_64/ARM64 CPU, 1GB 메모리, 20GB 디스크, Linux 커널 (3.10+) 이지만, 실무에서는 커널 기능 (Namespaces, cgroups v2, OverlayFS), SSD 저장소, 1Gbps 이상 네트워크, 적절한 메모리 (노드당 8–32GB 권장), 그리고 etcd·시간 동기화 같은 클러스터 인프라 의존성을 충족해야 안정적으로 서비스할 수 있다.</p><p>GPU 같은 가속기를 쓰려면 추가 드라이버·툴킷과 커널 모듈 의존성도 확인해야 한다.</p><h5 id=시스템하드웨어-요구-상세-설명>시스템·하드웨어 요구 상세 설명<a hidden class=anchor aria-hidden=true href=#시스템하드웨어-요구-상세-설명>#</a></h5><h6 id=시스템-요구사항>시스템 요구사항<a hidden class=anchor aria-hidden=true href=#시스템-요구사항>#</a></h6><ul><li><p><strong>CPU (x86_64 / ARM64)</strong></p><ul><li>컨테이너 바이너리·이미지 아키텍처 일치 필요.</li><li>ARM64 기반 서비스 (예: 엣지) 사용 시 아키텍처 빌드·이미지 대비 필요.</li></ul></li><li><p><strong>메모리</strong></p><ul><li>컨테이너 런타임, kubelet, 로그·캐시, 애플리케이션 프로세스가 메모리를 소비.</li><li>낮은 메모리는 OOM·스케줄링 실패 유발.</li></ul></li><li><p><strong>스토리지 (용량 + 성능)</strong></p><ul><li>이미지 레이어 저장, 로그, DB, PV 에 대한 I/O 가 서비스 응답성에 직접 영향.</li><li>느린 스토리지는 컨테이너 시작 지연·디스크 I/O 병목 초래.</li></ul></li><li><p><strong>OS/커널 버전 및 기능</strong></p><ul><li>Namespaces·cgroups·OverlayFS·seccomp 등 런타임·보안 기능은 커널에서 제공.</li><li>오래된 커널은 기능·성능·보안에서 제약.</li></ul></li><li><p><strong>네트워크 (대역폭·기능)</strong></p><ul><li>서비스 간 통신, CNI 동작, 데이터 플레인 성능은 NIC·스위치·MTU 에 의해 결정.</li><li>고속 NIC 과 기능은 latency·throughput 확보에 중요.</li></ul></li><li><p><strong>클러스터 인프라 (시간 동기·etcd 등)</strong></p><ul><li>etcd 는 컨트롤플레인 상태 저장소로 low-latency·stable storage 필요</li><li>시간 동기 없으면 인증·로그·분산 트랜잭션 문제 발생.</li></ul></li></ul><h6 id=하드웨어-의존성>하드웨어 의존성<a hidden class=anchor aria-hidden=true href=#하드웨어-의존성>#</a></h6><ul><li><p><strong>SSD 권장</strong></p><ul><li>이미지 풀, 레이어 압축/해제, 컨테이너 쓰기 I/O 가 많은 환경에서 HDD 로는 성능 한계.</li></ul></li><li><p><strong>가상화 (하이퍼바이저) 영향</strong><br>VM 위에서 구동 시 호스트·하이퍼바이저 오버헤드가 발생.<br>베어메탈이 성능 우위지만 운영 편의성은 VM 이 유리.</p></li><li><p><strong>GPU/가속기</strong></p><ul><li>AI/연산 집약 워크로드는 GPU 드라이버·container toolkit 의존.</li><li>GPU 드라이버는 커널 모듈과 밀접.</li></ul></li><li><p><strong>NUMA/메모리 토폴로지</strong><br>높은 성능 (특히 I/O/메모리 집약 워크로드) 은 NUMA 고려한 배치 필요.<br>잘못 배치하면 메모리 대역폭 병목.</p></li><li><p><strong>네트워크 하드웨어 기능</strong></p><ul><li>SR-IOV, SmartNIC, RDMA 등은 고성능 네트워크 통신을 위해 드라이버·펌웨어 의존성이 있음.</li></ul></li></ul><h5 id=컨테이너-시스템하드웨어-요약표>컨테이너 시스템·하드웨어 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-시스템하드웨어-요약표>#</a></h5><table><thead><tr><th style=text-align:right>분류</th><th>항목</th><th style=text-align:right>최소/권장</th><th>왜 필요한가 (핵심)</th></tr></thead><tbody><tr><td style=text-align:right>시스템</td><td>CPU 아키텍처</td><td style=text-align:right>x86_64 / ARM64</td><td>이미지·바이너리 아키텍처 일치</td></tr><tr><td style=text-align:right>시스템</td><td>메모리</td><td style=text-align:right>최소 1GB / 권장 노드당 8–32GB</td><td>런타임·앱·캐시 안정성</td></tr><tr><td style=text-align:right>시스템</td><td>스토리지 용량</td><td style=text-align:right>20GB 이상 (기본) / 워크로드별 수백 GB 권장</td><td>이미지·로그·데이터 저장</td></tr><tr><td style=text-align:right>시스템</td><td>스토리지 성능</td><td style=text-align:right>SSD 권장, IOPS 목표 설정</td><td>빠른 컨테이너 시작·IO 처리</td></tr><tr><td style=text-align:right>시스템</td><td>OS / 커널</td><td style=text-align:right>최소 3.10 / 권장 4.14+</td><td>Namespaces/cgroups/overlay 지원</td></tr><tr><td style=text-align:right>시스템</td><td>네트워크 대역폭</td><td style=text-align:right>1Gbps 이상 / DC 10Gbps 권장</td><td>서비스 통신·데이터 전송</td></tr><tr><td style=text-align:right>시스템</td><td>시간 동기</td><td style=text-align:right>NTP/chrony</td><td>인증·분산 시스템 일관성</td></tr><tr><td style=text-align:right>하드웨어</td><td>가상화 환경</td><td style=text-align:right>베어메탈/VM 모두 가능</td><td>성능 vs 운영 편의성 트레이드오프</td></tr><tr><td style=text-align:right>하드웨어</td><td>GPU/가속기</td><td style=text-align:right>드라이버 + container toolkit 필요</td><td>AI·연산 워크로드 가속</td></tr><tr><td style=text-align:right>하드웨어</td><td>NIC 기능</td><td style=text-align:right>SR-IOV, RSS, offload 지원</td><td>고성능 네트워킹</td></tr><tr><td style=text-align:right>하드웨어</td><td>NUMA 고려</td><td style=text-align:right>NUMA-aware 배치 권장</td><td>메모리 대역폭 최적화</td></tr><tr><td style=text-align:right>운영</td><td>컨트롤플레인</td><td style=text-align:right>etcd SSD, HA 권장</td><td>안정적 스케줄링·상태 저장</td></tr><tr><td style=text-align:right>보안</td><td>서명·SBOM</td><td style=text-align:right>Cosign / Sigstore 권장</td><td>공급망 신뢰성 확보</td></tr></tbody></table><p>컨테이너 플랫폼 운영에는 단순 사양 (메모리·디스크) 외에 <strong>커널 기능, 스토리지 I/O 목표, 네트워크 기능, 가속기 드라이버, 컨트롤플레인 요구 (etcd·시간 동기)</strong> 같은 세부 요소가 핵심이다.</p><p>프로덕션 환경에서는 권장값 (노드당 8–32GB, SSD, 10Gbps 등) 기준으로 용량·성능 계획과 검증 (테스트·벤치마크) 을 반드시 수행하라.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=컨테이너-설계-원칙과-운영-철학>컨테이너 설계 원칙과 운영 철학<a hidden class=anchor aria-hidden=true href=#컨테이너-설계-원칙과-운영-철학>#</a></h4><p>컨테이너 설계의 핵심은 <strong>작게, 일관되게, 자동으로</strong> 운영하는 것이다.</p><p>컨테이너는 경량 격리를 통해 빠르게 실행되고 동일한 이미지를 어디서나 돌릴 수 있기 때문에 마이크로서비스와 잘 어울린다.<br>설계 시에는 서비스가 <strong>상태를 외부에 두는지 (무상태)</strong>, <strong>어떤 리소스 한계가 필요한지 (cgroups)</strong>, <strong>보안 경계는 어떻게 확보할지 (seccomp, rootless)</strong>, 그리고 <strong>배포·롤백을 어떻게 자동화할지 (선언적 구성)</strong> 를 먼저 정해야 한다.</p><p>이 원칙들이 잘 지켜지면 확장성·운영 신뢰성·개발 생산성이 크게 향상된다.</p><h5 id=컨테이너-핵심-원칙-표>컨테이너 핵심 원칙 표<a hidden class=anchor aria-hidden=true href=#컨테이너-핵심-원칙-표>#</a></h5><table><thead><tr><th>원칙</th><th>설명</th><th>목적</th><th>왜 필요한가</th></tr></thead><tbody><tr><td>격리 (Isolation)</td><td>네임스페이스로 프로세스·네트워크 분리</td><td>간섭 차단·안정성 확보</td><td>오류·보안 사고 전파 방지</td></tr><tr><td>이식성 (Portability)</td><td>이미지 기반 어디서나 동일 실행</td><td>배포 일관성</td><td>환경차이로 인한 장애 제거</td></tr><tr><td>경량성 (Lightweight)</td><td>커널 공유로 오버헤드 최소화</td><td>빠른 기동·고밀도 배치</td><td>자원 효율적 확장 지원</td></tr><tr><td>불변성 (Immutability)</td><td>이미지는 변경하지 않음</td><td>배포 신뢰성·재현성</td><td>디버깅·롤백 단순화</td></tr><tr><td>선언적 구성 (Declarative)</td><td>원하는 상태를 코드로 선언</td><td>자동화·버전관리</td><td>수동오류 감소·재현성 확보</td></tr></tbody></table><p>컨테이너 설계는 위 원칙들이 상호보완적으로 작동해야 효과적이다.<br>예를 들어 <strong>불변성</strong>은 배포 안정성을 주지만, 자동화 (선언적 구성) 가 뒤따라야 실무에서 이득을 본다. 또한 <strong>격리</strong>와 <strong>경량성</strong> 사이의 트레이드오프 (보안 경계 수준 vs 성능) 를 명확히 해 설계 결정에 반영해야 한다.</p><h5 id=컨테이너-설계-철학-표>컨테이너 설계 철학 표<a hidden class=anchor aria-hidden=true href=#컨테이너-설계-철학-표>#</a></h5><table><thead><tr><th>철학</th><th>설명</th><th>목적</th><th>왜 필요한가</th></tr></thead><tbody><tr><td>마이크로서비스</td><td>단일 책임의 작은 서비스 분해</td><td>독립 배포·스케일</td><td>변경 범위 축소·개발 속도↑</td></tr><tr><td>무상태 (Stateless)</td><td>상태는 외부 저장소에 두기</td><td>복구·스케일 용이</td><td>인스턴스 교체 시 일관성 유지</td></tr><tr><td>확장성 우선</td><td>수평 확장 전제 설계</td><td>트래픽 탄력 대응</td><td>비용 효율적 운영·가용성 확보</td></tr><tr><td>장애 허용</td><td>국소 실패가 전체에 영향 적게</td><td>자동복구·재시도 설계</td><td>분산환경의 불확실성 대비</td></tr><tr><td>자동화 우선</td><td>IaC·CI/CD·오케스트레이션 사용</td><td>배포·운영 일관화</td><td>사람 오류 감소·속도 향상</td></tr></tbody></table><p>설계 철학은 운영·개발 방식 전반에 영향을 준다. 마이크로서비스·무상태 원칙을 따르면 확장성과 자동화 효과가 커지지만, 그만큼 운용·관측 (로그·트레이스·메트릭)·데이터 아키텍처 설계가 중요해진다.</p><h4 id=컨테이너-실행-원리와-운영-메커니즘>컨테이너 실행 원리와 운영 메커니즘<a hidden class=anchor aria-hidden=true href=#컨테이너-실행-원리와-운영-메커니즘>#</a></h4><p>컨테이너는 <strong>이미지 (불변의 빌드 산출물)</strong> 를 기반으로 호스트의 커널을 공유하면서도 <strong>네임스페이스와 cgroups</strong>로 프로세스·네트워크·파일시스템·자원을 격리해 가볍게 실행한다.</p><p>오케스트레이터 (Kubernetes) 는 이미지를 풀 (pull) 해 런타임 (containerd/runc) 에 컨테이너 생성 요청을 보내고, 런타임은 네임스페이스·cgroups·볼륨·네트워크를 설정한 뒤 애플리케이션 프로세스를 시작한다.<br>이미지 레이어와 union filesystem 덕분에 디스크·네트워크 비용을 줄일 수 있다.</p><h5 id=핵심-구성요소와-역할>핵심 구성요소와 역할<a hidden class=anchor aria-hidden=true href=#핵심-구성요소와-역할>#</a></h5><ul><li><strong>개발자/빌더 (BuildKit/CNB)</strong>: Dockerfile/Buildpacks 로 이미지 생성 (레이어화, 캐시).</li><li><strong>레지스트리 (Registry)</strong>: 이미지 저장소 (보안: 서명·인증, 접근 제어).</li><li><strong>오케스트레이터 (Kubernetes)</strong>: 스케줄링·스케일·헬스체크·서비스 추상화.</li><li><strong>런타임 (containerd/cri-o + runc)</strong>: 컨테이너 생성·관리—runc 가 실제 프로세스 fork/exec(OCI 규격 수행).</li><li><strong>리눅스 커널</strong>: 네임스페이스·cgroups·VFS·네트워크 스택 제공.</li></ul><h5 id=실행-시퀀스>실행 시퀀스<a hidden class=anchor aria-hidden=true href=#실행-시퀀스>#</a></h5><ol><li>개발자가 Dockerfile 로 이미지 빌드 → 이미지가 레지스트리에 푸시.</li><li>오케스트레이터가 노드에 이미지 풀 명령 → 런타임에서 이미지 풀 및 레이어 병합 (overlayfs).</li><li>런타임이 네임스페이스 (PID/NET/MNT/IPC/User) 생성, cgroups 로 리소스 제한 설정.</li><li>파일시스템 마운트 (overlay) 및 볼륨 연결 (CSI) → 네트워크 인터페이스 연결 (CNI).</li><li>프로세스 시작 → K8s 에 상태 보고, 헬스체크·로그·메트릭 수집 시작.</li></ol><h5 id=컨테이너-동작-구성요소-요약표>컨테이너 동작 구성요소 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-동작-구성요소-요약표>#</a></h5><table><thead><tr><th>구성요소/영역</th><th>목적 (무엇을 해결)</th><th>주요 메커니즘</th><th>실무 체크포인트</th></tr></thead><tbody><tr><td>이미지 빌드</td><td>재현 가능한 배포</td><td>Dockerfile/BuildKit, 레이어, 캐시</td><td>이미지 크기, 레이어 수, 빌드 캐시</td></tr><tr><td>레지스트리</td><td>이미지 저장·배포</td><td>푸시/풀, 인증, 서명</td><td>접근제어, 스캔, 서명</td></tr><tr><td>런타임</td><td>컨테이너 생성·관리</td><td>containerd/cri-o → runc(OCI)</td><td>crictl/ctr 사용법, 로그</td></tr><tr><td>격리</td><td>프로세스/네트워크/FS 분리</td><td>네임스페이스 (PID/NET/MNT/IPC/User)</td><td>ip netns, nsenter 확인</td></tr><tr><td>자원 제어</td><td>안정적 자원 분배</td><td>cgroups v1/v2 (CPU,mem,io)</td><td>cgroup 설정, OOM 이벤트</td></tr><tr><td>파일시스템</td><td>효율적 이미지 공유</td><td>overlayfs / union FS (COW)</td><td>드라이버 유형, 성능 특성</td></tr><tr><td>네트워크</td><td>컨테이너 간/외부 통신</td><td>CNI 플러그인 (bridge/overlay)</td><td>서비스 접근성, DNS, 네트워크 정책</td></tr><tr><td>스토리지</td><td>데이터 영속성</td><td>볼륨, CSI 드라이버</td><td>백업·복구, 퍼포먼스</td></tr><tr><td>보안</td><td>호스트 보호</td><td>seccomp, AppArmor, NS, 서명</td><td>취약점 스캔, 권한 최소화</td></tr></tbody></table><ul><li><strong>이미지</strong>: 빌드 시 레이어·캐시를 최적화하면 배포·업데이트 비용이 줄어든다.</li><li><strong>런타임</strong>: containerd/cri-o 가 오케스트레이터 명령을 받아 runc 로 컨테이너를 실제 생성한다 (OCI 표준 준수).</li><li><strong>격리·자원</strong>: 네임스페이스로 각종 네임스페이스를 분리하고 cgroups 로 자원 제한을 걸어 다중 애플리케이션 공존을 안정화한다.</li><li><strong>파일시스템</strong>: overlay 같은 union FS 로 이미지 레이어를 합쳐서 변경분만 저장하고 디스크·전송 비용을 줄인다.</li><li><strong>네트워크·스토리지</strong>: CNI 와 CSI 로 네트워크·스토리지 추상화를 제공, 클러스터 전반의 일관된 인터페이스를 유지한다.</li><li><strong>보안·운영</strong>: 이미지 서명·스캔, 런타임 보안 프로파일, 모니터링·로깅이 안전한 운영의 핵심이다.</li></ul><h5 id=컨테이너-생성과-실행-라이프사이클>컨테이너 생성과 실행 라이프사이클<a hidden class=anchor aria-hidden=true href=#컨테이너-생성과-실행-라이프사이클>#</a></h5><pre class=mermaid>flowchart TD
  dev[Developer]
  build[&#34;Builder (BuildKit / CNB)&#34;]
  reg[&#34;Registry (OCI)&#34;]
  k8s[Kubernetes / Orchestrator]
  runtime[&#34;Runtime (containerd / cri-o)&#34;]
  runc[&#34;runc (OCI runtime)&#34;]
  kernel[Linux Kernel]
  node[Node Host]

  dev --&gt;|Dockerfile / Buildpacks| build
  build --&gt;|이미지 푸시| reg
  k8s --&gt;|이미지 Pull| reg
  k8s --&gt;|CRI: CreatePod| runtime
  runtime --&gt;|pull image &amp; mount overlay| node
  runtime --&gt;|create namespaces / cgroups| runc
  runc --&gt;|invoke kernel primitives| kernel
  kernel --&gt;|namespaces,cgroups,fs,net| node
  runc --&gt;|start process| node
  node --&gt;|status| k8s
  k8s --&gt;|liveness/readiness| runtime
</pre><hr><ul><li><p><strong>개발자 → 빌드 → 레지스트리</strong>: 개발자는 이미지를 정의 (Dockerfile/Buildpacks) 하고 빌드하여 레지스트리에 푸시한다. 빌드 파이프라인에서 이미지 스캔·서명 과정을 반드시 거쳐야 한다.</p></li><li><p><strong>오케스트레이터 → 런타임</strong>: Kubernetes 는 이미지가 필요하면 레지스트리에서 풀하고 CRI 로 런타임에게 컨테이너 생성 요청을 보낸다.</p></li><li><p><strong>런타임 → runc → 커널</strong>: containerd 같은 런타임은 runc 를 호출해 네임스페이스·cgroup 설정과 파일시스템 마운트를 수행하게 하고, runc 는 커널의 네임스페이스·cgroup API 를 통해 실제 격리된 프로세스를 시작한다.</p></li><li><p><strong>네트워크·스토리지</strong>: CNI 로 네트워크 인터페이스를 구성하고 CSI 로 볼륨을 바인딩한다.</p></li><li><p><strong>상태 보고 및 운영</strong>: 컨테이너 상태 (헬스체크) 를 오케스트레이터가 모니터링하고, 이상시 재시작·스케일·롤백을 수행한다.</p></li></ul><h4 id=컨테이너-데이터제어-흐름과-생명주기>컨테이너 데이터·제어 흐름과 생명주기<a hidden class=anchor aria-hidden=true href=#컨테이너-데이터제어-흐름과-생명주기>#</a></h4><p>컨테이너 시스템은 <strong>이미지 (불변 파일 묶음)</strong> 와 <strong>컨테이너 (이미지로 실행되는 가벼운 프로세스)</strong> 로 나뉜다.<br>개발자는 이미지를 빌드해 레지스트리에 올리고, 오케스트레이터 (Kubernetes) 가 이 이미지를 노드에 내려받아 (=pull) 컨테이너를 실행한니다.<br>오케스트레이터는 컨테이너의 상태를 검사 (probe) 하고 필요하면 재시작·스케일·롤아웃을 수행한다.<br>데이터는 일시적이면 컨테이너 내부에, 영속적이면 볼륨 (외부 스토리지) 에 저장된다.<br>모니터링이 핵심이며 보안 (이미지 스캔·서명) 과 저장 정책이 운영의 기초이다.</p><h5 id=컨테이너-데이터와-제어-흐름>컨테이너 데이터와 제어 흐름<a hidden class=anchor aria-hidden=true href=#컨테이너-데이터와-제어-흐름>#</a></h5><ul><li><p><strong>빌드·이미지 단계</strong>:<br>코드 → Dockerfile/BuildKit → 빌드 → 이미지 레이어 생성 → 취약점 스캔 → SBOM·서명 → 레지스트리 푸시</p></li><li><p><strong>배포·제어 단계</strong>:<br>오케스트레이터에 매니페스트 등록 → 스케줄러가 노드 선택 → kubelet/CRI 가 이미지 pull → 컨테이너 생성 및 네트워크·볼륨 연결 → readiness/liveness 검사 → 서비스 등록</p></li><li><p><strong>운영·관측 단계</strong>:<br>메트릭/로그/트레이스 수집 → 알림/SLO 평가 → 자동 스케일·헬스 기반 교체/롤백 → 이미지/컨테이너 가비지 컬렉션</p></li><li><p><strong>영속성·스토리지</strong>:<br>PV/PVC/StorageClass(CSI) → 백업/복구/데이터 마이그레이션 전략 필요</p></li><li><p><strong>보안·정책</strong>:<br>네트워크 정책, PodSecurityPolicy/PSP 대체 기법, seccomp, 이미지 서명·레지스트리 접근 제어</p></li></ul><h5 id=컨테이너-데이터제어-흐름-구성표>컨테이너 데이터·제어 흐름 구성표<a hidden class=anchor aria-hidden=true href=#컨테이너-데이터제어-흐름-구성표>#</a></h5><table><thead><tr><th>단계</th><th>주체 (Actor)</th><th style=text-align:right>주요 데이터 (Artifacts)</th><th>제어/액션</th><th>운영 고려사항</th></tr></thead><tbody><tr><td>빌드</td><td>CI (BuildKit)</td><td style=text-align:right>이미지 (레이어), SBOM</td><td>빌드·테스트·스캔·태깅</td><td>캐시 전략, 멀티스테이지, 취약점 스캔</td></tr><tr><td>레지스트리</td><td>Registry</td><td style=text-align:right>이미지 저장소, 태그, 서명</td><td>푸시/풀, replication</td><td>접근 제어, 레플리케이션, 캐시</td></tr><tr><td>스케줄링</td><td>Orchestrator (API Server → Scheduler)</td><td style=text-align:right>Pod 매니페스트, 이미지 참조</td><td>노드 선정, 정책 적용</td><td>노드 셀렉터·테인트/톨러레이션</td></tr><tr><td>런타임</td><td>Kubelet / containerd / runc</td><td style=text-align:right>컨테이너 프로세스, 쓰기 레이어</td><td>pull → create → start</td><td>이미지 PullPolicy, storage driver</td></tr><tr><td>네트워크</td><td>CNI</td><td style=text-align:right>네트워크 인터페이스, IP</td><td>attach, routing, service</td><td>CNI 종류, 네트워크 정책</td></tr><tr><td>스토리지</td><td>CSI / Volume</td><td style=text-align:right>PV, PVC, Volume 데이터</td><td>mount/unmount</td><td>성능, 백업, 스냅샷</td></tr><tr><td>헬스·프로브</td><td>Orchestrator / kubelet</td><td style=text-align:right>readiness/liveness 상태</td><td>probe → restart/evict</td><td>probe 설계, 재시작 정책</td></tr><tr><td>관측</td><td>Prometheus/ELK/OpenTelemetry</td><td style=text-align:right>메트릭·로그·트레이스</td><td>수집·알림·분석</td><td>SLO, 알림 임계값</td></tr><tr><td>운영·정비</td><td>Operator / Admin</td><td style=text-align:right>로그, 이벤트, 이미지 GC</td><td>롤아웃·롤백·GC</td><td>가비지 컬렉션, 정책 실현</td></tr><tr><td>보안</td><td>PSP/Cilium/OPA</td><td style=text-align:right>이미지 서명, 정책</td><td>정책 검증·강제</td><td>이미지 스캔, 네트워크 정책</td></tr></tbody></table><p>이미지 빌드부터 컨테이너 런타임, 네트워크·스토리지 연결, 헬스 체크, 관측까지가 데이터·제어의 흐름이다. 각 단계는 명확한 책임자 (주체) 와 산출물 (이미지, 매니페스트, PV 등) 을 가지며, 운영 시에는 보안·캐시·가비지 컬렉션·백업 같은 비기능 요구가 필수다.</p><h5 id=컨테이너-배포제어-흐름도>컨테이너 배포·제어 흐름도<a hidden class=anchor aria-hidden=true href=#컨테이너-배포제어-흐름도>#</a></h5><pre class=mermaid>flowchart LR
  subgraph CI
    A[코드] --&gt; B[&#34;빌드(BuildKit)&#34;]
    B --&gt; C{스캔/테스트}
    C --&gt;|통과| D[&#34;이미지(태그) 생성&#34;]
    C --&gt;|실패| X[빌드 실패 알림]
    D --&gt; E[&#34;이미지 서명(SBOM, Cosign)&#34;]
    E --&gt; R[레지스트리 푸시]
  end

  R --&gt;|pull 요청| S[오케스트레이터 매니페스트]
  S --&gt; Scheduler[스케줄러]
  Scheduler --&gt; Node[node 선택]
  Node --&gt; Kubelet[kubelet / CRI]
  Kubelet --&gt;|pull image| Registry[&#34;레지스트리 (캐시)&#34;]
  Registry --&gt; Container[컨테이너 생성]
  Container --&gt; Net[CNI 네트워크 연결]
  Container --&gt; Vol[&#34;볼륨 마운트 (CSI)&#34;]
  Container --&gt; Probe[readiness/liveness probe]
  Probe --&gt;|성공| Service[서비스 등록]
  Probe --&gt;|실패| Restart[재시작 / Evict]
  
  Container --&gt; Metrics[메트릭/로그/트레이스 수집]
  Metrics --&gt; Observability[Alert / Dashboard / SLO]
  Observability --&gt;|이상| Autoscaler[오토스케일 / 롤백]
  Autoscaler --&gt; Scheduler

  Admin[운영자] --&gt;|정책| S
  Admin --&gt;|GC/정비| GC[이미지/컨테이너 GC]

  style CI fill:#f9f,stroke:#333,stroke-width:1px
</pre><p>컨테이너 파이프라인은 " 이미지 신뢰성 확보 (스캔·서명) → 안정적 배포 (오케스트레이터) → 런타임 연속성 (노드 캐시·프로브) → 관측 기반 운영 (알림·스케일·롤백)" 의 루프로 이해하면 된다. 각 단계의 실패경로 (빌드 실패·이미지 pull 실패·프로브 실패 등) 에 정책 (차단/재시도/폴백) 을 설계해야 가용성과 보안이 확보된다.</p><h5 id=컨테이너-실행정지-생명주기>컨테이너 실행·정지 생명주기<a hidden class=anchor aria-hidden=true href=#컨테이너-실행정지-생명주기>#</a></h5><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Created
    Created --&gt; PullImage: kubelet pulls image
    PullImage --&gt; CreatedContainer: create container
    CreatedContainer --&gt; Started: start container
    Started --&gt; Ready: readiness probe ok
    Ready --&gt; Serving: mapped to Service
    Started --&gt; Unready: readiness fail
    Unready --&gt; Restarting: restartPolicy
    Restarting --&gt; Started
    Started --&gt; Paused: pause (optional)
    Paused --&gt; Started: unpause
    Started --&gt; Terminating: preStop hook / SIGTERM
    Terminating --&gt; Stopped: container stopped
    Stopped --&gt; [*]: deleted / garbage collected
    Started --&gt; OOMKilled: OOM / cgroup memory limit
    OOMKilled --&gt; Restarting
</pre><p>컨테이너는 <strong>생성 → 이미지풀 → 시작 → 프로브 (ready) 통과 → 서비스 제공</strong>의 단계로 운영된다.<br>문제가 발생하면 자동으로 재시작하거나 스케줄러가 다른 노드로 재배치한다. 종료 시에는 graceful 종료 (후크 실행) → 삭제 → 가비지 컬렉션 순으로 마무리된다. Startup 프로브·PDB·Eviction 정책은 서비스 가용성에 큰 영향을 미치므로 설계 시 신중히 설정해야 한다.</p><h4 id=컨테이너-아키텍처-종합-개관>컨테이너 아키텍처 종합 개관<a hidden class=anchor aria-hidden=true href=#컨테이너-아키텍처-종합-개관>#</a></h4><p>컨테이너 플랫폼은 여러 층으로 구성된다.<br>물리적/가상 인프라 위에 리눅스 커널이 있고, 커널의 네임스페이스와 cgroups 가 컨테이너 격리와 자원 제어의 기반이다.<br>런타임 (예: containerd) 이 이미지를 풀링하고, runc 가 실제로 컨테이너 프로세스를 띄운다.<br>오케스트레이터 (예: Kubernetes) 는 컨트롤플레인을 통해 어떤 노드에 어떤 컨테이너를 띄울지 결정하고, CNI 가 네트워크를, CSI 가 스토리지를 연결한다.<br>이미지 빌드는 빌더 (BuildKit) 로 만들고 레지스트리에 저장해 배포된다.<br>관측/보안 계층은 전체에 걸쳐 로그·메트릭·정책을 제공한다.</p><h5 id=컨테이너-플랫폼-구조-개요>컨테이너 플랫폼 구조 개요<a hidden class=anchor aria-hidden=true href=#컨테이너-플랫폼-구조-개요>#</a></h5><ul><li><strong>인프라</strong>: 실제 자원 제공 (서버/클라우드).</li><li><strong>호스트 OS / 커널</strong>: 컨테이너 격리·자원 제어 기본.</li><li><strong>런타임</strong>: 이미지 관리 (containerd) → 컨테이너 실행 (runc).</li><li><strong>오케스트레이터</strong>: 클러스터 레벨 스케줄·상태 관리.</li><li><strong>서비스/앱</strong>: 컨테이너로 패키징된 애플리케이션.</li></ul><h6 id=컨테이너-구조-핵심-속성표>컨테이너 구조 핵심 속성표<a hidden class=anchor aria-hidden=true href=#컨테이너-구조-핵심-속성표>#</a></h6><table><thead><tr><th>계층</th><th>역할 / 핵심 기능</th><th>특징</th><th>상호관계</th></tr></thead><tbody><tr><td>인프라</td><td>물리·가상 자원 제공</td><td>성능/유연성 차이 (Bare/VM/Cloud)</td><td>OS·네트워크 HW 특성에 영향</td></tr><tr><td>OS/커널</td><td>네임스페이스·cgroups 제공</td><td>커널 버전·기능 의존</td><td>Low-level runtime 이 직접 호출</td></tr><tr><td>High-level runtime</td><td>이미지 풀/관리, snapshot</td><td>registry 통합, 캐싱</td><td>kubelet/CRI 와 연동</td></tr><tr><td>Low-level runtime</td><td>컨테이너 프로세스 생성</td><td>OCI 규격 구현</td><td>kernel API 통해 격리 적용</td></tr><tr><td>오케스트레이터</td><td>스케줄·상태 관리·서비스</td><td>컨트롤플레인/워커 분리</td><td>kubelet → runtime → kernel 루프</td></tr><tr><td>네트워크 (CNI)</td><td>Pod 네트워크·정책 제공</td><td>플러그인 다양성</td><td>kubelet 호출로 네임스페이스 구성</td></tr><tr><td>스토리지 (CSI)</td><td>동적 볼륨 제공</td><td>Controller/Node 플러그인</td><td>오케스트레이터 PVC → CSI 요청</td></tr><tr><td>보안/관측</td><td>이미지검증·모니터·로그</td><td>횡단 관심사</td><td>모든 계층과 데이터 교환</td></tr></tbody></table><p>이 표는 컨테이너 플랫폼의 각 계층이 어떤 책임을 지니고 있는지, 어떤 특징이 있으며 다른 계층과 어떻게 연결되는지를 보여준다.<br>요약하면 커널은 격리·자원 제어의 핵심, 런타임은 이미지와 실행의 중간자, 오케스트레이터는 클러스터 단위의 의사결정자 역할을 한다. CNI/CSI 는 데이터면의 확장 모듈이며 보안·관측은 전체에 걸친 필수 요소다.</p><h6 id=컨테이너-플랫폼-계층도>컨테이너 플랫폼 계층도<a hidden class=anchor aria-hidden=true href=#컨테이너-플랫폼-계층도>#</a></h6><pre class=mermaid>flowchart TB
  subgraph Infra[&#34;인프라 (Bare/VM/Cloud)&#34;]
    InfraHW[CPU/Memory/Storage/Network]
  end

  subgraph OS[&#34;호스트 OS / Kernel&#34;]
    NS[Namespaces]
    CG[cgroups]
    LSM[SELinux/AppArmor]
    SEC[seccomp/capabilities]
  end

  subgraph RuntimeHigh[&#34;High-level Runtime&#34;]
    Containerd[containerd / CRI-O]
    Snapshot[Snapshotter]
    Content[Content Store]
  end

  subgraph RuntimeLow[&#34;Low-level Runtime&#34;]
    Runc[runc / kata-runtime]
  end

  subgraph Engine[&#34;컨테이너 엔진 / 빌더&#34;]
    Docker[Docker / Podman]
    Builder[BuildKit]
    Registry[&#34;Registry (Harbor / Docker Hub)&#34;]
  end

  subgraph Orchestrator[&#34;오케스트레이터 (K8s 등)&#34;]
    APIServer[API Server]
    Etcd[etcd]
    Scheduler[Scheduler]
    Controller[Controller Manager]
    Kubelet[&#34;Kubelet (on node)&#34;]
  end

  subgraph DataPlane[&#34;CNI / CSI / Node&#34;]
    CNI[&#34; CNI Plugin (Calico/Flannel) &#34;]
    CSI[ CSI Driver ]
  end

  subgraph Observability[&#34;보안·관측·로깅&#34;]
    Prom[Prometheus]
    Fluentd[Fluentd / ELK]
    Policy[RBAC / NetworkPolicy]
  end

  InfraHW --&gt; OS
  OS --&gt; RuntimeLow
  RuntimeHigh --&gt; RuntimeLow
  Engine --&gt; RuntimeHigh
  Orchestrator --&gt; Kubelet
  Kubelet --&gt; RuntimeHigh
  Kubelet --&gt; CNI
  CNI --&gt; OS
  CSI --&gt; OS
  Registry --&gt; RuntimeHigh
  Builder --&gt; Registry
  APIServer --&gt; Etcd
  APIServer --&gt; Scheduler
  APIServer --&gt; Controller
  Observability --&gt; APIServer
  Observability --&gt; RuntimeHigh
  Observability --&gt; CNI
</pre><h5 id=컨테이너-구성요소-해설>컨테이너 구성요소 해설<a hidden class=anchor aria-hidden=true href=#컨테이너-구성요소-해설>#</a></h5><p>구성요소는 실제 시스템의 " 움직이는 부품 " 이다.</p><p>간단히 말하면:</p><ul><li><strong>Builder(이미지 빌드)</strong>: 애플리케이션 코드를 이미지로 만든다 (예: BuildKit).</li><li><strong>Registry</strong>: 이미지를 저장·배포한다 (Harbor, Docker Hub).</li><li><strong>High-level Runtime</strong>: 이미지 풀·캐시·snapshot 관리 (containerd).</li><li><strong>Low-level Runtime</strong>: 컨테이너 프로세스를 실제로 생성 (runc).</li><li><strong>CNI</strong>: 파드 네트워크를 설정하고 정책을 적용 (예: Calico).</li><li><strong>CSI</strong>: 블록·파일 스토리지를 동적으로 연결.</li><li><strong>Orchestrator</strong>: 여러 노드에 파드를 스케줄하고 상태를 유지 (Kubernetes).</li><li><strong>Observability</strong>: 모니터링·로깅·정책으로 운영을 돕는다.</li></ul><h6 id=컨테이너-구성요소-총괄표>컨테이너 구성요소 총괄표<a hidden class=anchor aria-hidden=true href=#컨테이너-구성요소-총괄표>#</a></h6><table><thead><tr><th>구성요소</th><th>역할</th><th>기능</th><th>특징</th><th style=text-align:right>상호관계</th><th style=text-align:right>필수/선택</th><th>소속 구조</th></tr></thead><tbody><tr><td>Builder (BuildKit)</td><td>이미지 빌드</td><td>multi-stage, 캐시, 시크릿</td><td>빌드 최적화</td><td style=text-align:right>빌드 → Registry</td><td style=text-align:right>선택 (필수 아님)</td><td>이미지/빌드</td></tr><tr><td>Registry (Harbor)</td><td>이미지 저장/배포</td><td>접근제어, 레플리케이션</td><td>이미지 서명·스캔 연계</td><td style=text-align:right>Runtime pulls image</td><td style=text-align:right>필수 (프로덕션)</td><td>이미지/배포</td></tr><tr><td>containerd / CRI-O</td><td>이미지 관리·CRI</td><td>snapshot, content store, registry client</td><td>경량, k8s 친화</td><td style=text-align:right>kubelet ↔ containerd</td><td style=text-align:right>필수</td><td>런타임</td></tr><tr><td>runc / kata</td><td>컨테이너 실행</td><td>OCI 규격 프로세스 생성</td><td>kata 는 VM 격리</td><td style=text-align:right>containerd → runc → kernel</td><td style=text-align:right>필수</td><td>런타임</td></tr><tr><td>Docker/Podman</td><td>엔진/CLI</td><td>빌드, 실행, 데몬</td><td>사용자 편의</td><td style=text-align:right>사용자가 직접 호출</td><td style=text-align:right>선택 (운영환경은 대체 가능)</td><td>엔진</td></tr><tr><td>CNI (Calico etc.)</td><td>네트워크 연결/정책</td><td>IPAM, 플로우 제어</td><td>다양한 모드</td><td style=text-align:right>kubelet → CNI</td><td style=text-align:right>필수</td><td>데이터면</td></tr><tr><td>CSI Driver</td><td>스토리지 공급</td><td>동적 프로비저닝</td><td>Controller/Node 분리</td><td style=text-align:right>PVC → CSI 컨트롤러</td><td style=text-align:right>필수 (영구볼륨 필요시)</td><td>데이터면</td></tr><tr><td>Kubernetes (APIServer etc.)</td><td>오케스트레이션</td><td>스케줄, 컨트롤러, etcd</td><td>분산 컨트롤플레인</td><td style=text-align:right>API → kubelet → runtime</td><td style=text-align:right>필수 (클러스터)</td><td>오케스트레이터</td></tr><tr><td>Prometheus</td><td>메트릭 수집</td><td>시계열 DB, 경보</td><td>exporter 필요</td><td style=text-align:right>모든 계층에서 메트릭 수집</td><td style=text-align:right>필수 (운영권장)</td><td>관측</td></tr><tr><td>Fluentd / ELK</td><td>로그 집적</td><td>parsing, 전송, 저장</td><td>로그 처리 파이프라인</td><td style=text-align:right>노드/앱 로그 수집</td><td style=text-align:right>필수 (운영권장)</td><td>관측</td></tr><tr><td>Service Mesh</td><td>트래픽 관리</td><td>mTLS, 라우팅, 관측</td><td>사이드카 패턴</td><td style=text-align:right>애플리케이션 트래픽</td><td style=text-align:right>선택</td><td>서비스 계층</td></tr></tbody></table><p>이 표는 각 구성요소가 어떤 역할을 수행하고 어떤 특성을 가지며 다른 구성요소와 어떻게 연결되는지를 한눈에 보여준다.<br>실무에서는 모든 항목을 다 갖출 필요는 없지만 (예: 단순 dev 환경에서 Registry/Builder 만으로 충분) 운영 환경에서는 런타임, 오케스트레이터, CNI/CSI, 관측 요소는 필수적이다.<br>Service Mesh 나 빌드 최적화는 사용 사례에 따라 선택된다.</p><h6 id=컨테이너-구성요소-상호관계도>컨테이너 구성요소 상호관계도<a hidden class=anchor aria-hidden=true href=#컨테이너-구성요소-상호관계도>#</a></h6><pre class=mermaid>graph LR
  subgraph BuildPush[&#34;이미지 빌드/배포&#34;]
    BK[BuildKit]
    REG[&#34;Registry (Harbor/Docker Hub)&#34;]
    BK --&gt; REG
  end

  subgraph ControlPlane[&#34;오케스트레이터 (Control Plane)&#34;]
    APIS[API Server]
    ETCD[etcd]
    SCHED[Scheduler]
    CTRL[Controller Manager]
    APIS --&gt; ETCD
    APIS --&gt; SCHED
    APIS --&gt; CTRL
  end

  subgraph Node[&#34;Worker Node&#34;]
    KUBE[Kubelet]
    CRI[containerd / CRI-O]
    RUNC[runc / kata]
    CNI[CNI Plugin]
    CSI[CSI Driver]
    KUBE --&gt; CRI
    CRI --&gt; RUNC
    KUBE --&gt; CNI
    KUBE --&gt; CSI
    CRI --&gt; REG
  end

  subgraph Observ[&#34;관측/보안&#34;]
    PROM[Prometheus]
    FLU[Fluentd/ELK]
    POLICY[RBAC/NetworkPolicy]
  end

  REG --&gt; Node
  APIS --&gt; KUBE
  PROM --&gt; APIS
  PROM --&gt; KUBE
  FLU --&gt; REG
  POLICY --&gt; APIS
  POLICY --&gt; KUBE
</pre><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=컨테이너-장점의-실무적-검증-프레임>컨테이너 장점의 실무적 검증 프레임<a hidden class=anchor aria-hidden=true href=#컨테이너-장점의-실무적-검증-프레임>#</a></h4><p>컨테이너는 애플리케이션을 <strong>이미지</strong>라는 단일 패키지로 묶어 <strong>어디서나 동일하게 실행</strong>하도록 해준다.<br>이 덕분에 배포가 빨라지고 (컨테이너 기동이 매우 빠름), 동일 하드웨어에서 더 많은 인스턴스를 돌릴 수 있어 비용이 절감된다. 또한 이미지가 버전화되므로 CI/CD 파이프라인에 자연스럽게 연결되어 자동화와 롤백이 쉬워진다.<br>다만 성능·보안·데이터 영속성 등 항목은 워크로드 특성에 맞춰 검증이 필요하다.</p><h5 id=컨테이너-주요-장점과-실무-지표>컨테이너 주요 장점과 실무 지표<a hidden class=anchor aria-hidden=true href=#컨테이너-주요-장점과-실무-지표>#</a></h5><table><thead><tr><th>장점</th><th>기술적 근거</th><th>실무적 효과</th><th>적용 상황</th><th>검증 지표 (실무 측정값 예시)</th></tr></thead><tbody><tr><td>이식성 (Portability)</td><td>OCI 이미지 표준, 이미지 레이어</td><td>환경 불일치 감소, 배포 단순화</td><td>멀티클라우드, 하이브리드</td><td>배포 실패율, 환경별 버그 재현율</td></tr><tr><td>경량성·밀도</td><td>네임스페이스·cgroups, 커널 공유</td><td>높은 인스턴스 밀도, 비용 절감</td><td>마이크로서비스 대규모 운영</td><td>인스턴스당 CPU/메모리 사용률, 호스트 밀도</td></tr><tr><td>신속 배포·롤백</td><td>불변 이미지·빠른 기동</td><td>긴급 패치·빠른 롤백 가능</td><td>빈번한 릴리스, CI/CD</td><td>배포 시간 (P95), 롤백 시간, 배포 성공률</td></tr><tr><td>자동화 적합성</td><td>이미지 아티팩트 + CI/CD 연계</td><td>반복 가능한 배포 파이프라인</td><td>DevOps·GitOps 환경</td><td>파이프라인 통과율, 배포 빈도 (주당)</td></tr><tr><td>관측·정책화 용이</td><td>CRI/CNI/CSI 표준, 정책 엔진 (OPA)</td><td>감사·정책 일관성, 모니터링 통합</td><td>규제 산업, 대규모 운영</td><td>메트릭 수집률, 정책 위반 건수</td></tr><tr><td>개발 생산성</td><td>로컬 동일 환경, 이미지 불변성</td><td>온보딩·디버깅 시간 단축</td><td>신규 개발 온보딩</td><td>온보딩 시간, 버그 발견 - 수정 시간</td></tr></tbody></table><p>이점들은 기술적 근거 (네임스페이스, 이미지 불변성, 표준 인터페이스) 와 직접 연결된다. 그러나 <strong>정량적 효과</strong>(비용 절감 비율, 밀도 향상 등) 는 환경·워크로드에 따라 달라지므로 <strong>PoC 와 메트릭 수집</strong>을 통해 실제 가치를 검증해야 한다.</p><h4 id=컨테이너-한계와-실무-완화-전략>컨테이너 한계와 실무 완화 전략<a hidden class=anchor aria-hidden=true href=#컨테이너-한계와-실무-완화-전략>#</a></h4><p>컨테이너는 가볍고 빠른 배포·확장의 강점을 제공하지만, 네트워크·스토리지 설정과 런타임 보안, 이미지 공급망 관리 같은 <strong>운영 난점</strong>을 필연적으로 동반한다. 또한 리눅스 커널에 의존하거나 GPU·규제 같은 환경에서는 적용에 제약이 있다. 실무에서는 <strong>표준화·자동화·관측성 확보·보안 (이미지 스캔·런타임 보호)</strong> 을 통해 위험을 낮추고, 필요 시 VM·베어메탈·서버리스 같은 대안을 혼합 (혼합 인프라) 하여 트레이드오프를 관리한다.</p><h5 id=컨테이너-단점>컨테이너 단점<a hidden class=anchor aria-hidden=true href=#컨테이너-단점>#</a></h5><blockquote><p>컨테이너 기술 자체 또는 그 운영 패턴에서 본질적으로 발생하거나 빈번히 맞닥뜨리게 되는 약점들.</p></blockquote><table><thead><tr><th>단점</th><th>설명</th><th>원인</th><th>실무 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>복잡한 네트워크/스토리지 설정</td><td>네트워크 오버레이, CNI·CSI 구성 복잡</td><td>분산 네트워크·다양한 플러그인</td><td>설정 실수 → 성능 저하·접근 장애</td><td>표준화 (CNI/CSI 정책), 인프라 코드 (Ansible/Terraform), 자동화 테스트</td><td>VM+SDN, 베어메탈</td></tr><tr><td>런타임·호스트 보안 리스크</td><td>커널을 호스트와 공유하므로 탈출 위험 존재</td><td>커널·네임스페이스 공유, 권한 설정 부주의</td><td>컨테이너 탈출 → 호스트/클러스터 침해</td><td>최소 권한, seccomp/AppArmor/SELinux, 사용자 네임스페이스, 런타임 모니터링 (Falco)</td><td>VM 격리, Kata Containers</td></tr><tr><td>이미지·공급망 취약점</td><td>이미지 의존성·취약점 누적, 레지스트리 관리 필요</td><td>이미지 불변성·빈번한 버전·서플라이체인</td><td>취약 이미지 배포 → 보안 사고, 릴리스 중단</td><td>SBOM, 자동 스캔 (Trivy), 이미지 서명 (cosign), 취약 버전 자동 차단</td><td>관리형 이미지 서비스, Immutable infra</td></tr><tr><td>운영 복잡성·관측성 한계</td><td>동적 스케줄링으로 추적 어려움</td><td>마이크로서비스·짧은 컨테이너 수명</td><td>장애 원인 파악 지연</td><td>중앙 로깅/분산 트레이싱 (OpenTelemetry), APM</td><td>모놀리식 (단순화)</td></tr><tr><td>상태 저장의 어려움</td><td>상태 유지 설계 복잡, 데이터 일관성 문제</td><td>기본 컨테이너는 휘발성 파일시스템</td><td>스테이트풀 서비스 운영/복구 난도 증가</td><td>CSI, StatefulSet, 데이터 백업·복구 전략</td><td>DBaaS, 전용 VM 스토리지</td></tr></tbody></table><p>단점들은 대부분 &rsquo; 컨테이너의 경량·불변성 &rsquo; 이라는 강점에서 파생되는 트레이드오프다. 완화책은 보안·관측·자동화·외부 스토리지로 보완하는 방향이 유효하다.</p><h5 id=컨테이너-제약사항>컨테이너 제약사항<a hidden class=anchor aria-hidden=true href=#컨테이너-제약사항>#</a></h5><blockquote><p>특정 환경 (운영체제, 하드웨어, 규제 등) 이나 요구사항 때문에 컨테이너 적용이 제한되는 조건들.</p></blockquote><table><thead><tr><th>제약사항</th><th>설명</th><th>원인</th><th>영향</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>리눅스/커널 의존성</td><td>컨테이너 모델은 리눅스 커널 기능에 기반</td><td>네임스페이스·cgroups 가 리눅스 중심</td><td>Windows/특수 OS 에서 제한</td><td>Windows 컨테이너, WSL2, 멀티플랫폼 테스트</td><td>VM(다중 OS)</td></tr><tr><td>특수 하드웨어 제약</td><td>GPU/FPGA 드라이버·성능 요구</td><td>하드웨어 드라이버·PCI 패스스루 필요</td><td>배치·스케줄링 복잡, 성능 저하</td><td>전용 노드풀·SR-IOV·device plugin</td><td>베어메탈, 전용 인스턴스</td></tr><tr><td>규제·감사 요구</td><td>이미지·런타임 추적·보존 필요</td><td>법적·컴플라이언스 요구</td><td>배포 지연·추적 비용 증가</td><td>이미지 서명·SBOM·감사 로그·정책 자동화</td><td>규제 특화 환경 (전용 클라우드)</td></tr><tr><td>자원 QoS 한계</td><td>cgroup 설정으로도 복잡한 우선순위 관리 한계</td><td>고밀도 배치, IO/네트워크 경쟁</td><td>성능 변동·장애 가능성</td><td>리소스 격리 (노드풀), QoS 클래스, 모니터링</td><td>베어메탈, 전용 VM</td></tr><tr><td>운영 초기비용</td><td>기존 infra 와 구조 차이로 초기 투자</td><td>조직·도구·교육 필요</td><td>도입 비용·전환 리스크</td><td>점진 마이그레이션, 관리형 서비스 이용</td><td>기존 인프라 유지</td></tr></tbody></table><p>제약사항은 기술 자체의 결함이 아니라 <strong>적용 환경의 특성</strong> 때문에 발생한다. 해결은 설계 레벨 (노드풀, 정책·CI/CD) 과 조직적 선택 (Managed 서비스, 단계적 전환) 으로 접근해야 한다.</p><h4 id=컨테이너-트레이드오프-및-하이브리드-전략>컨테이너 트레이드오프 및 하이브리드 전략<a hidden class=anchor aria-hidden=true href=#컨테이너-트레이드오프-및-하이브리드-전략>#</a></h4><p>컨테이너 도입에서 맞닥뜨리는 핵심 선택 (트레이드오프) 은 " 빠르고 밀도 높은 배포 " 와 " 강력한 격리·보안 " 사이의 균형이다.</p><p>컨테이너는 빠르고 비용 효율적이지만 커널을 공유하므로 민감한 워크로드엔 VM 이 더 안전하다.<br>무상태 설계는 확장을 단순하게 하지만 상태는 외부로 빼야 한다.<br>운영 복잡도를 줄이려면 오케스트레이션을 도입해야 하지만 초기 비용과 학습곡선이 존재한다.</p><p>실무에선 VM+ 컨테이너 혼합, 무상태 + 외부 상태, 고성능 컴포넌트만 호스트 네트워크 적용 같은 하이브리드 전략으로 균형을 맞춘다.</p><h5 id=컨테이너-주요-트레이드오프-비교표>컨테이너 주요 트레이드오프 비교표<a hidden class=anchor aria-hidden=true href=#컨테이너-주요-트레이드오프-비교표>#</a></h5><table><thead><tr><th>영역</th><th style=text-align:right>선택 A</th><th>장점</th><th>단점</th><th style=text-align:right>선택 B</th><th>장점</th><th>단점</th><th>고려 기준</th></tr></thead><tbody><tr><td>격리 수준</td><td style=text-align:right>컨테이너</td><td>빠른 시작, 높은 밀도, 비용 절감</td><td>커널 취약점 시 노드 영향</td><td style=text-align:right>VM</td><td>강력 격리, 규제 적합</td><td>리소스 오버헤드, 시작 지연</td><td>보안 요구·규제·SLA</td></tr><tr><td>상태관리</td><td style=text-align:right>무상태</td><td>수평 확장 용이, 단순 배포</td><td>상태 외부화 필요</td><td style=text-align:right>상태 저장</td><td>단순 모델 (로컬 상태 편리)</td><td>스케일·복구 복잡</td><td>세션 중요도·데이터 일관성</td></tr><tr><td>운영 복잡성</td><td style=text-align:right>단순 배포</td><td>낮은 초기 비용</td><td>수동 운영·스케일 제한</td><td style=text-align:right>오케스트레이션</td><td>자동화·복구·스케일</td><td>학습곡선·설정·운영비용</td><td>서비스 규모·팀역량</td></tr><tr><td>네트워킹</td><td style=text-align:right>호스트 네트워크</td><td>최소 오버헤드, 저지연</td><td>격리 어려움</td><td style=text-align:right>가상 네트워크</td><td>정책·멀티테넌시 우수</td><td>패킷 오버헤드·지연 증대</td><td>성능 요구·보안 필요</td></tr></tbody></table><p>각 선택은 명확한 장단점이 있다.<br>민감한 데이터·강한 규제가 있으면 VM(격리) 을, 빠른 스케일·비용효율을 원하면 컨테이너 (무상태) 를 우선 고려하라.<br>운영 역량과 서비스 규모가 커지면 오케스트레이션 도입이 투자 대비 이득을 준다.<br>네트워크는 성능·격리 요구를 보고 호스트 vs 가상 네트워크를 선택하되, 하이브리드 적용 (핵심 컴포넌트만 호스트 네트워크) 도 효과적이다.</p><h5 id=하이브리드-운영-패턴-요약표>하이브리드 운영 패턴 요약표<a hidden class=anchor aria-hidden=true href=#하이브리드-운영-패턴-요약표>#</a></h5><table><thead><tr><th>패턴</th><th>구성 요소</th><th style=text-align:right>적용 목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>VM + 컨테이너</td><td>하드 격리 VM + 컨테이너 클러스터</td><td style=text-align:right>규제·민감 워크로드 분리</td><td>보안·유연성 동시 확보</td><td>네트워크·로그 통합 비용</td></tr><tr><td>무상태 + 외부 상태</td><td>Stateless 서비스 + DB/Cache</td><td style=text-align:right>확장성 & 간편 배포</td><td>간편한 스케일·롤링 업데이트</td><td>외부 스토리지 성능 의존</td></tr><tr><td>부분적 호스트 네트워크</td><td>핵심 서비스만 hostNet</td><td style=text-align:right>성능 극대화</td><td>저지연·네트워크 오버헤드 최소</td><td>격리 정책·보안 강화 필요</td></tr><tr><td>단계적 오케스트레이션</td><td>단순배포 → 점진적 K8s</td><td style=text-align:right>운영 위험 최소화</td><td>초기 비용 절감·점진적 학습</td><td>마이그레이션 계획 필요</td></tr></tbody></table><p>하이브리드 패턴은 단일 선택의 약점을 보완한다. 예컨대 금융시스템은 VM 으로 민감부분 격리, 나머지 트래픽은 컨테이너로 운영해 비용과 보안을 동시에 맞춘다. 도입 전 통합 (네트워크, 로그, 인증), 자동화·관측성 계획이 필수다.</p><h4 id=컨테이너-채택-타당성-및-운영-고려사항>컨테이너 채택 타당성 및 운영 고려사항<a hidden class=anchor aria-hidden=true href=#컨테이너-채택-타당성-및-운영-고려사항>#</a></h4><p>컨테이너는 <strong>빠른 배포·수평 확장·MSA 도입·CI/CD 파이프라인</strong>에 적합해 웹 서비스와 마이크로서비스에 아주 잘 맞는다.<br>반면, <strong>초저지연·하드웨어 직접 접근·높은 규제</strong>가 요구되는 워크로드는 추가 설계 (예: SR-IOV, kata-runtime, 베어메탈) 와 운영·보안 보강이 필요하다.<br>즉, " 컨테이너는 대부분의 현대 애플리케이션엔 강력한 선택이지만, 모든 워크로드를 무조건 대체하는 만능 솔루션은 아니다 " 라는 점을 염두에 두고 워크로드 특성·팀 역량·규제 요건을 기준으로 채택 여부를 결정해야 한다.</p><h5 id=컨테이너-적용-적합성-요약표>컨테이너 적용 적합성 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-적용-적합성-요약표>#</a></h5><table><thead><tr><th>사용 사례</th><th style=text-align:right>적합성 (5)</th><th>이유 (간단)</th><th>설계 관점 고려사항</th><th>운영 관점 주의점</th></tr></thead><tbody><tr><td>웹 애플리케이션</td><td style=text-align:right>★★★★★</td><td>무상태·수평확장 용이</td><td>세션 외부화, 무상태 설계</td><td>CI/CD·모니터링 필수</td></tr><tr><td>마이크로서비스</td><td style=text-align:right>★★★★★</td><td>독립 배포·기술 다양성 허용</td><td>API 게이트·서비스 메시 고려</td><td>복잡성·관측성 확보 필요</td></tr><tr><td>CI/CD 파이프라인</td><td style=text-align:right>★★★★★</td><td>격리된 빌드·병렬 테스트</td><td>이미지 캐시 전략</td><td>레지스트리 관리 필요</td></tr><tr><td>배치 처리</td><td style=text-align:right>★★★★☆</td><td>병렬성·자원 격리 가능</td><td>리소스 요청·노드 유형 매핑</td><td>장기 작업 신뢰성 대비</td></tr><tr><td>레거시 시스템</td><td style=text-align:right>★★☆☆☆</td><td>아키텍처 재설계 필요</td><td>단계적 리팩토링 필요</td><td>마이그레이션 리스크 관리</td></tr><tr><td>실시간 시스템</td><td style=text-align:right>★☆☆☆☆</td><td>네트워크/커널 제약</td><td>SR-IOV/TSN/베어메탈 대안 필요</td><td>엄격한 SLO·모니터링 필요</td></tr></tbody></table><p>컨테이너는 무상태·마이크로서비스형 워크로드에서 최고 효율을 발휘한다.<br>CI/CD 와 결합하면 배포 속도와 일관성을 크게 높일 수 있다.<br>반면 상태성·레거시·실시간 요구가 강한 워크로드는 컨테이너 단독으로 적합하지 않을 수 있으며, 이러한 경우 추가 설계 (스토리지 복제, 특수 네트워크, 하드웨어 패스스루) 와 운영 보강이 필요하다.</p><h4 id=컨테이너-확장성비용-최적화-전략>컨테이너 확장성·비용 최적화 전략<a hidden class=anchor aria-hidden=true href=#컨테이너-확장성비용-최적화-전략>#</a></h4><p>확장성 (스케일 아웃) 은 서비스 가용성과 탄력적 비용을 제공하지만, 자동화·모니터링·네트워크·데이터 일관성 등 운영 복잡성을 증가시켜 총비용에 영향한다.<br>비용 절감은 단순 인프라 비용 비교만으로 판단하면 오판한다.<br>실제로는 초기 마이그레이션 비용·관측 스택 비용·운영 인력 변화·레지스트리 egress 등을 모두 포함한 TCO 모델을 세우고, 자동화·관리형 서비스·스팟 혼합·캐싱·샘플링 같은 완화 전략을 적용해야 진정한 비용/성능 개선을 달성한다.</p><h5 id=확장성복잡성비용-비교표>확장성·복잡성·비용 비교표<a hidden class=anchor aria-hidden=true href=#확장성복잡성비용-비교표>#</a></h5><table><thead><tr><th>항목</th><th style=text-align:right>확장성의 이득</th><th>복잡성/비용 요인</th><th>완화 전략 (실무 권장)</th><th>모니터링 지표</th></tr></thead><tbody><tr><td>인프라 비용</td><td style=text-align:right>수요에 따라 비용 최적화 (스케일 인/아웃)</td><td>노드 종류별 비용, 레지스트리 egress</td><td>Spot+Reserved 혼합, 이미지 캐시, 지역 레지스트리</td><td>비용/시간, 노드 가동률</td></tr><tr><td>운영 인력</td><td style=text-align:right>자동화로 운영 부담 감소 (장기)</td><td>초기 자동화·툴 도입 인력·교육 비용</td><td>관리형 서비스, IaC, Runbook 자동화</td><td>MTTR, 운영인원 FTE</td></tr><tr><td>개발 생산성</td><td style=text-align:right>배포 빈도↑, 릴리즈 속도 개선</td><td>서비스 분해로 테스트·관측 증가</td><td>GitOps·CI/CD·자동 테스트</td><td>배포 빈도, 배포 실패율</td></tr><tr><td>관측 (Observability)</td><td style=text-align:right>문제 인지·SLO 유지 가능</td><td>로그·메트릭 저장·쿼리 비용 급증</td><td>샘플링, 집계, 로그 보관층화</td><td>로그 저장량, P95/P99, 쿼리 비용</td></tr><tr><td>복구·가용성</td><td style=text-align:right>빠른 복구·탄력적 가용성</td><td>재해복구 설계·데이터 복제 비용</td><td>멀티 AZ, DR playbook, 자동 failover</td><td>RTO, RPO, 가용성 (%)</td></tr><tr><td>마이그레이션 리스크</td><td style=text-align:right>레거시 탈피 후 장기 효율</td><td>데이터 이관, 호환성, 테스트 비용</td><td>점진적/퍼센트 트래픽 롤아웃</td><td>마이그레이션 성공률</td></tr><tr><td>총 TCO(예시 포인트)</td><td style=text-align:right>비용 감소 가능</td><td>초기 CapEx/OpEx + 관측·교육 비용 포함</td><td>단계적 투자·비용가시화 (태깅)</td><td>월별 TCO 변화, ROI</td></tr></tbody></table><p>확장성은 장기적으로 비용·가용성 이득을 주지만, 초기 도입과 운영 단계에서 복잡성·관측 비용이 증가한다.<br>핵심은 <strong>정량적 TCO 모델</strong>(인프라·운영·개발·관측·마이그레이션 비용 포함) 을 세워, Spot/Reserved 혼합, 이미지 캐싱, 관측 샘플링, 관리형 서비스 등으로 복잡성 비용을 낮추며 단계적으로 전환하는 것이다.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=컨테이너-구현기법-빌드부터-운영까지>컨테이너 구현기법: 빌드부터 운영까지<a hidden class=anchor aria-hidden=true href=#컨테이너-구현기법-빌드부터-운영까지>#</a></h4><p>컨테이너 구현은 크게 <strong>이미지 빌드 → 레지스트리 → 런타임 → 오케스트레이션 → 관측/운영</strong> 흐름으로 이해하면 쉽다.<br>개발자는 Dockerfile 또는 Buildpacks 로 이미지를 만들고, 레지스트리에 올린 뒤 오케스트레이터 (예: Kubernetes) 가 이를 풀어 배포한다.<br>실무에서는 <strong>이미지 최적화·보안 (서명·스캔)·네트워크 (CNI)·영속성 (CSI)</strong> 같은 요소를 미리 설계해야 서비스 안정성을 확보할 수 있다.</p><h5 id=컨테이너-구현-기법-카테고리>컨테이너 구현 기법 카테고리<a hidden class=anchor aria-hidden=true href=#컨테이너-구현-기법-카테고리>#</a></h5><h6 id=이미지-빌드공급망>이미지 빌드·공급망<a hidden class=anchor aria-hidden=true href=#이미지-빌드공급망>#</a></h6><p>이미지 빌드는 Dockerfile(멀티스테이지), Buildpacks, 언어별 빌더 (Jib) 등으로 수행한다.<br>레지스트리는 이미지를 저장·배포하며, 공급망 보안 (이미지 서명, SBOM, 취약점 스캔) 을 필수로 적용해야 한다.<br>빌드 재현성과 레지스트리 정책 (태그·GC·레플리케이션) 이 실무 안정성에 결정적 영향을 준다.</p><table><thead><tr><th>항목</th><th style=text-align:right>정의</th><th>장점</th><th>사용 예시</th></tr></thead><tbody><tr><td>Dockerfile</td><td style=text-align:right>선언적 이미지 빌드</td><td>재현성·캐시</td><td>커스텀 런타임 이미지</td></tr><tr><td>멀티스테이지</td><td style=text-align:right>빌드/런타임 분리</td><td>이미지 경량화</td><td>Go/Java 빌드 후 복사</td></tr><tr><td>Buildpacks</td><td style=text-align:right>소스→이미지 자동화</td><td>개발자 편의</td><td>PaaS 스타일 배포</td></tr><tr><td>이미지서명·스캔</td><td style=text-align:right>무결성·취약점 점검</td><td>공급망 보안</td><td>cosign + Trivy</td></tr></tbody></table><p>이미지 빌드는 재현성·보안·크기 최적화 관점에서 설계해야 하며, 레지스트리 정책과 취약점 관리가 필수다.</p><h6 id=런타임oci-표준>런타임·OCI 표준<a hidden class=anchor aria-hidden=true href=#런타임oci-표준>#</a></h6><p>컨테이너 런타임 (containerd, runc 등) 은 OCI 규약을 따르며 컨테이너 생성·실행을 담당한다. 런타임 선택은 성능·호환성·보안 요구에 따라 달라진다.</p><table><thead><tr><th>항목</th><th style=text-align:right>정의</th><th>고려사항</th><th>예시</th></tr></thead><tbody><tr><td>containerd/runc</td><td style=text-align:right>컨테이너 실행 엔진</td><td>성능·CRI 호환성</td><td>Kubernetes + containerd</td></tr><tr><td>OCI</td><td style=text-align:right>이미지/런타임 표준</td><td>호환성 보장</td><td>모든 주요 툴 지원</td></tr></tbody></table><p>런타임·OCI 표준은 벤더 중립적 이식성을 보장하므로, 표준 준수 여부를 점검하라.</p><h6 id=오케스트레이션배포-모델>오케스트레이션·배포 모델<a hidden class=anchor aria-hidden=true href=#오케스트레이션배포-모델>#</a></h6><p>단일호스트는 개발에서 유용하고, Kubernetes 는 프로덕션용 표준 플랫폼이다. 서버리스와 엣지 옵션은 운영 부담·지연 요구에 따라 선택.</p><table><thead><tr><th>모델</th><th style=text-align:right>특징</th><th>장점</th><th>사용상황</th></tr></thead><tbody><tr><td>단일호스트</td><td style=text-align:right>간단·빠름</td><td>개발·테스트 용이</td><td>로컬 개발</td></tr><tr><td>Kubernetes</td><td style=text-align:right>자동복구·스케일</td><td>프로덕션 안정성</td><td>마이크로서비스</td></tr><tr><td>서버리스 (Fargate)</td><td style=text-align:right>인프라 추상화</td><td>운영부담 감소</td><td>이벤트 기반</td></tr><tr><td>엣지 (K3s)</td><td style=text-align:right>경량·분산</td><td>저지연 엣지</td><td>IoT, CDN</td></tr></tbody></table><p>오케스트레이션 선택은 운영 역량과 가용성 요구·지연 특성에 기반해 결정한다.</p><h6 id=네트워크스토리지>네트워크·스토리지<a hidden class=anchor aria-hidden=true href=#네트워크스토리지>#</a></h6><p>CNI 플러그인과 CSI 스펙을 통해 네트워크·스토리지를 구성한다. 네트워크폴리시·영속성 전략 (볼륨, StatefulSet) 이 중요.</p><table><thead><tr><th>항목</th><th style=text-align:right>기능</th><th>고려사항</th><th>예시</th></tr></thead><tbody><tr><td>CNI (Calico/Cilium)</td><td style=text-align:right>Pod 네트워크·정책</td><td>성능·정책 기능</td><td>Calico: 네트워크폴리시</td></tr><tr><td>CSI</td><td style=text-align:right>외부 스토리지 연동</td><td>스토리지 클래스 설계</td><td>AWS EBS CSI 드라이버</td></tr><tr><td>StatefulSet</td><td style=text-align:right>Stateful 워크로드</td><td>복제·정합성 관리</td><td>DB, Kafka</td></tr></tbody></table><p>영속성·네트워크 정책은 애플리케이션 아키텍처와 동일선상에서 설계해야 한다.</p><h6 id=구성비밀-관리>구성·비밀 관리<a hidden class=anchor aria-hidden=true href=#구성비밀-관리>#</a></h6><p>Helm/Kustomize 와 GitOps 로 구성 관리를 자동화하고, Sealed Secrets/External Secrets 로 시크릿을 안전하게 배포한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>도구</th><th>예시</th></tr></thead><tbody><tr><td>Helm/Kustomize</td><td style=text-align:right>템플릿화·파라미터화</td><td>Helm Chart</td><td>재사용 가능한 배포</td></tr><tr><td>GitOps</td><td style=text-align:right>선언적 배포 자동화</td><td>ArgoCD / Flux</td><td>Git → 클러스터 동기화</td></tr><tr><td>Secret 관리</td><td style=text-align:right>민감정보 보호</td><td>SealedSecrets</td><td>KMS 연동된 시크릿 배포</td></tr></tbody></table><p>구성과 시크릿 관리는 자동화·암호화·버전 관리를 전제로 설계하라.</p><h6 id=보안정책>보안·정책<a hidden class=anchor aria-hidden=true href=#보안정책>#</a></h6><p>rootless 컨테이너, seccomp, AppArmor/SELinux, 네트워크 폴리시, 이미지 스캔 등으로 보안층을 쌓는다.</p><table><thead><tr><th>항목</th><th style=text-align:right>기능</th><th>적용 시기</th><th>예시</th></tr></thead><tbody><tr><td>rootless</td><td style=text-align:right>권한 축소</td><td>보안 민감 환경</td><td>비루트 실행</td></tr><tr><td>seccomp</td><td style=text-align:right>syscalls 제한</td><td>런타임 보호</td><td>기본 프로필 적용</td></tr><tr><td>이미지 스캔</td><td style=text-align:right>취약점 탐지</td><td>CI 단계</td><td>Trivy/Clair</td></tr></tbody></table><p>컨테이너 보안은 빌드·배포·런타임 전 단계에서 연속적으로 적용해야 효과적이다.</p><h6 id=배포-전략검증>배포 전략·검증<a hidden class=anchor aria-hidden=true href=#배포-전략검증>#</a></h6><p>롤링/카나리/블루그린과 헬스체크·리트라이 정책으로 안전한 배포를 설계한다.</p><table><thead><tr><th>전략</th><th style=text-align:right>장점</th><th>단점</th><th>사용 예</th></tr></thead><tbody><tr><td>롤링</td><td style=text-align:right>무중단 업데이트</td><td>점진적 실패 영향</td><td>일반 배포</td></tr><tr><td>카나리</td><td style=text-align:right>실사용 검증</td><td>트래픽 라우팅 필요</td><td>신규 기능 검증</td></tr><tr><td>블루그린</td><td style=text-align:right>즉시 롤백</td><td>인프라 중복 필요</td><td>대규모 버전 교체</td></tr></tbody></table><p>배포 전략은 SLO 와 롤백 RTO 목표에 맞춰 선택·자동화하라.</p><h6 id=운영관측>운영·관측<a hidden class=anchor aria-hidden=true href=#운영관측>#</a></h6><p>로그·메트릭·트레이스 수집 (ELK, Prometheus, OpenTelemetry) 과 알람·대시보드로 운영 가시성을 확보한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>도구</th><th>지표 예시</th></tr></thead><tbody><tr><td>메트릭</td><td style=text-align:right>성능·리소스 관찰</td><td>Prometheus/Grafana</td><td>CPU, 메모리, P95 응답시간</td></tr><tr><td>로그</td><td style=text-align:right>요청/에러 분석</td><td>ELK/Fluentd</td><td>에러 rate, stacktrace</td></tr><tr><td>트레이스</td><td style=text-align:right>분산 호출 추적</td><td>OpenTelemetry</td><td>지연 병목 분석</td></tr></tbody></table><p>관측성은 문제 탐지·근본원인 분석·SLO 검증의 핵심이다.</p><h5 id=컨테이너-구현-전체-요약표>컨테이너 구현 전체 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-구현-전체-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 기법</th><th>대표 도구/기술</th><th>실무 핵심 포인트</th></tr></thead><tbody><tr><td>이미지 빌드·공급망</td><td>Dockerfile, 멀티스테이지, Buildpacks, 서명·스캔</td><td>Docker, BuildKit, cosign, Trivy</td><td>재현성·보안·크기 최적화</td></tr><tr><td>런타임·OCI</td><td>containerd, runc, OCI</td><td>containerd, crun</td><td>표준·성능·호환성 검토</td></tr><tr><td>오케스트레이션</td><td>Kubernetes, Compose, Fargate</td><td>k8s, docker-compose</td><td>운영 역량·확장성 고려</td></tr><tr><td>네트워크·스토리지</td><td>CNI, CSI, StatefulSet</td><td>Calico, Cilium, CSI 드라이버</td><td>네트워크폴리시·영속성 설계</td></tr><tr><td>구성·시크릿</td><td>Helm, GitOps, SealedSecrets</td><td>Helm, ArgoCD, External Secrets</td><td>선언적 구성·비밀보호</td></tr><tr><td>보안·정책</td><td>rootless, seccomp, 이미지 스캔</td><td>seccomp, AppArmor, Trivy</td><td>공급망 + 런타임 보안 연계</td></tr><tr><td>배포 전략</td><td>롤링·카나리·블루그린</td><td>Istio/Ingress, Argo Rollouts</td><td>자동화된 검증·빠른 롤백</td></tr><tr><td>운영·관측</td><td>Prometheus, ELK, OpenTelemetry</td><td>Grafana, Loki, OTel</td><td>SLO 기반 모니터링·알람</td></tr></tbody></table><h4 id=컨테이너-유형-및-구성층-분류-가이드>컨테이너 유형 및 구성층 분류 가이드<a hidden class=anchor aria-hidden=true href=#컨테이너-유형-및-구성층-분류-가이드>#</a></h4><p>컨테이너 생태계는 여러 기능 레이어로 나눌 수 있다.<br>먼저 <strong>빌드</strong>(이미지 생성), 그 이미지의 <strong>저장/공급망</strong>(레지스트리·서명), <strong>런타임</strong>(containerd/runc 등으로 네임스페이스·cgroups 설정), 그리고 <strong>네트워크 (CNI)</strong> 와 <strong>스토리지 (CSI)</strong> 가 컨테이너를 실행 가능한 상태로 만든다.<br>그 위에서 <strong>오케스트레이터 (Kubernetes 등)</strong> 가 스케줄링·헬스체크·스케일을 담당하고, **운영 (모니터링·보안)**이 안정적 서비스를 보장한다.<br>각 레이어마다 여러 구현체·특성 (경량 vs 강력한 격리, 개발 친화 vs 운영 친화) 이 있어 선택 기준을 명확히 해야 한다.</p><h5 id=컨테이너-구성층별-유형-분류>컨테이너 구성층별 유형 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-구성층별-유형-분류>#</a></h5><h6 id=빌드이미지-생성>빌드·이미지 생성<a hidden class=anchor aria-hidden=true href=#빌드이미지-생성>#</a></h6><p><strong>설명</strong>: 소스→이미지로 변환하는 과정. Dockerfile/BuildKit, Buildpacks, Kaniko, Jib 같은 도구가 여기에 해당. 멀티스테이지 빌드, 캐시 활용, 이미지 경량화 전략이 중요.<br><strong>언제 선택</strong>: 로컬 개발·CI 파이프라인에서 reproducible build 가 필요할 때.<br><strong>주의점</strong>: 레이어 수·이미지 크기·캐시 히트율이 배포 성능에 영향.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>권장 사용</th></tr></thead><tbody><tr><td>Dockerfile 기반</td><td>명시적 단계 정의</td><td style=text-align:right>Docker, BuildKit</td><td>모든 프로젝트의 기본</td></tr><tr><td>Buildpacks</td><td>빌드 규칙 자동화</td><td style=text-align:right>Paketo, Google CNB</td><td>언어별 표준 빌드 원할 때</td></tr><tr><td>레이어리스/원격 빌드</td><td>노드리스 환경 빌드</td><td style=text-align:right>Kaniko, Jib</td><td>클러스터 내 비루트 빌드 필요시</td></tr></tbody></table><p><strong>요약</strong>: 이미지 품질 (크기·보안) 과 빌드파이프라인 자동화가 핵심. CI 에 스캔·서명 단계 추가 권장.</p><h6 id=이미지-저장공급망>이미지 저장·공급망<a hidden class=anchor aria-hidden=true href=#이미지-저장공급망>#</a></h6><p><strong>설명</strong>: 레지스트리 (프라이빗/퍼블릭), 이미지 서명, 스캔, SBOM 관리. 공급망 보안과 전파 (레플리케이션/캐싱) 도 포함.<br><strong>주의점</strong>: 취약 이미지 배포 위험, 레지스트리 접근 제어 필요.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>권장 사용</th></tr></thead><tbody><tr><td>퍼블릭 레지스트리</td><td>오픈 이미지 공유</td><td style=text-align:right>Docker Hub, gcr</td><td>OSS/빠른 프로토타이핑</td></tr><tr><td>프라이빗 레지스트리</td><td>조직용 이미지 저장</td><td style=text-align:right>Harbor, Artifactory</td><td>프로덕션 이미지 관리</td></tr><tr><td>보안·SBOM</td><td>서명·스캔·SBOM 생성</td><td style=text-align:right>cosign, Trivy, Syft</td><td>생산 환경 필수</td></tr></tbody></table><p><strong>요약</strong>: 이미지는 코드와 마찬가지로 공급망 관리 대상. 서명·스캔·SBOM 을 CI 파이프라인에 넣어야 안전.</p><h6 id=런타임-및-격리-모델>런타임 및 격리 모델<a hidden class=anchor aria-hidden=true href=#런타임-및-격리-모델>#</a></h6><p><strong>설명</strong>: 컨테이너 실행 엔진과 격리 모델 (runc: process, gVisor/Kata: sandbox/VM). containerd/cri-o 가 오케스트레이터와 연결.<br><strong>선택 기준</strong>: 보안 민감도, 성능 요구, 오버헤드 허용 여부.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>프로세스 격리 (경량)</td><td>네임스페이스 +cgroups</td><td style=text-align:right>runc, docker</td><td>낮은 오버헤드, 높은 성능</td></tr><tr><td>샌드박스 런타임</td><td>사용자 공간 격리</td><td style=text-align:right>gVisor</td><td>추가 보안, 중간 오버헤드</td></tr><tr><td>VM 기반 격리</td><td>가상머신 수준</td><td style=text-align:right>Kata, Firecracker</td><td>강력 보안, 높은 오버헤드</td></tr></tbody></table><p><strong>요약</strong>: 보안 우선이면 Kata/gVisor, 레이턴시·성능 우선이면 runc 선택. 혼합 전략 추천.</p><h6 id=네트워크-cni>네트워크 (CNI)<a hidden class=anchor aria-hidden=true href=#네트워크-cni>#</a></h6><p><strong>설명</strong>: 컨테이너 네트워크를 구성하는 플러그인. 브리지, overlay, macvlan, eBPF 기반 솔루션 등. 정책·보안·퍼포먼스가 관건.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>브리지/기본</td><td>간단한 L2 브리지</td><td style=text-align:right>kube-bridge</td><td>쉬운 구성, 한계 존재</td></tr><tr><td>오버레이</td><td>여러 노드 간 가상 네트워크</td><td style=text-align:right>Flannel, Weave</td><td>단순하지만 오버헤드 존재</td></tr><tr><td>정책·eBPF</td><td>고성능·정교 정책</td><td style=text-align:right>Cilium, Calico</td><td>고성능·정교한 보안</td></tr></tbody></table><p><strong>요약</strong>: 단일 클러스터 내면 브리지/Flannel, 고성능·세분화 정책 필요시 Cilium/Calico 권장.</p><h6 id=스토리지-csi--영속성>스토리지 (CSI / 영속성)<a hidden class=anchor aria-hidden=true href=#스토리지-csi--영속성>#</a></h6><p><strong>설명</strong>: 컨테이너와 스토리지 연결 표준 (CSI). PV/PVC, StatefulSet 패턴과 백업/복구 정책 중요.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>블록 스토리지</td><td>퍼포먼스 중시</td><td style=text-align:right>AWS EBS, GCE PD</td><td>빠른 I/O 필요시</td></tr><tr><td>분산 파일시스템</td><td>공유 스토리지</td><td style=text-align:right>Ceph(Rook), Gluster</td><td>다중 리더/공유 시 사용</td></tr><tr><td>파일 기반</td><td>간단한 PV</td><td style=text-align:right>NFS</td><td>간단하지만 성능 한계</td></tr></tbody></table><p><strong>요약</strong>: 상태 저장이 필요하면 CSI/StatefulSet 과 백업 정책을 설계. DB 는 관리형 DB 권장.</p><h6 id=오케스트레이션배포>오케스트레이션·배포<a hidden class=anchor aria-hidden=true href=#오케스트레이션배포>#</a></h6><p><strong>설명</strong>: 컨테이너 배치·스케줄링·서비스 추상화 담당. Kubernetes 가 사실상 표준. Nomad/ECS 대안 존재.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>풀 기능 오케스트레이터</td><td>스케줄링·서비스·컨트롤 플레인</td><td style=text-align:right>Kubernetes</td><td>성숙·복잡</td></tr><tr><td>경량 오케스트레이터</td><td>단순 스케줄링</td><td style=text-align:right>Nomad</td><td>단순·운영 용이</td></tr><tr><td>클라우드 매니지드</td><td>관리형 서비스</td><td style=text-align:right>EKS/GKE/AKS</td><td>운영 부담 경감</td></tr></tbody></table><p><strong>요약</strong>: 복잡한 마이크로서비스엔 K8s, 단순 환경엔 Nomad, 운영 부담 줄이려면 매니지드 선택.</p><h6 id=플랫폼환경>플랫폼·환경<a hidden class=anchor aria-hidden=true href=#플랫폼환경>#</a></h6><p><strong>설명</strong>: 배포 대상 환경 (온프레/클라우드/엣지/IoT/Windows/ARM).</p><table><thead><tr><th>유형</th><th>설명</th><th>대표 적용</th></tr></thead><tbody><tr><td>온프레</td><td>내부 데이터센터</td><td>규제·레거시 연동</td></tr><tr><td>클라우드</td><td>퍼블릭 IaaS/PaaS</td><td>유연성·관리형 서비스</td></tr><tr><td>엣지/IoT</td><td>자원 제한 환경</td><td>경량 런타임 필요</td></tr></tbody></table><p><strong>요약</strong>: 환경에 따라 런타임·네트워크·스토리지 선택이 달라짐—미리 환경 고려 필요.</p><h6 id=보안공급망-보호>보안·공급망 보호<a hidden class=anchor aria-hidden=true href=#보안공급망-보호>#</a></h6><p><strong>설명</strong>: 이미지 서명·취약점 스캔·런타임 탐지·정책 (OPA/Gatekeeper) 등.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>정적 검사</td><td>이미지 스캔</td><td style=text-align:right>Trivy, Clair</td><td>CI 에 통합</td></tr><tr><td>서명·SBOM</td><td>무결성 증명</td><td style=text-align:right>cosign, Syft</td><td>규제·감사에 필수</td></tr><tr><td>런타임 보호</td><td>이상행동 탐지</td><td style=text-align:right>Falco, Sysdig</td><td>실시간 탐지</td></tr></tbody></table><p><strong>요약</strong>: 공급망 보안 + 런타임 보호 병행 구축이 필수.</p><h6 id=관측운영-모니터링로깅>관측·운영 (모니터링·로깅)<a hidden class=anchor aria-hidden=true href=#관측운영-모니터링로깅>#</a></h6><p><strong>설명</strong>: Prometheus/Grafana, ELK/Fluentd, OpenTelemetry/Jaeger 같은 스택으로 관측·추적·로깅을 통합해야 장애 대응 속도가 빨라짐.</p><table><thead><tr><th>유형</th><th>설명</th><th style=text-align:right>대표 기술</th><th>특징</th></tr></thead><tbody><tr><td>메트릭</td><td>성능·리소스 지표</td><td style=text-align:right>Prometheus</td><td>SLO 기반 알람</td></tr><tr><td>로깅</td><td>중앙집중 로그</td><td style=text-align:right>Fluentd, ELK</td><td>포렌식·감사</td></tr><tr><td>추적</td><td>분산 트레이스</td><td style=text-align:right>OpenTelemetry, Jaeger</td><td>마이크로서비스 원인 추적</td></tr></tbody></table><p><strong>요약</strong>: 관측 스택은 배포 초반부터 설계해야 문제 해결시간 단축.</p><h5 id=컨테이너-구성층별-기술-매핑표>컨테이너 구성층별 기술 매핑표<a hidden class=anchor aria-hidden=true href=#컨테이너-구성층별-기술-매핑표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 역할</th><th>대표 기술 (예)</th><th>선택 시 고려사항</th></tr></thead><tbody><tr><td>빌드·이미지</td><td>이미지 생성·최적화</td><td>BuildKit, Kaniko, Buildpacks</td><td>재현성·크기·캐시</td></tr><tr><td>이미지 공급망</td><td>저장·서명·스캔</td><td>Harbor, cosign, Trivy</td><td>보안·접근 제어</td></tr><tr><td>런타임·격리</td><td>컨테이너 생성·격리</td><td>containerd, runc, gVisor, Kata</td><td>성능 vs 보안</td></tr><tr><td>네트워크 (CNI)</td><td>파드 네트워크·정책</td><td>Calico, Cilium, Flannel</td><td>정책·성능·운영 난이도</td></tr><tr><td>스토리지 (CSI)</td><td>영속성 제공</td><td>EBS, Ceph(Rook), NFS</td><td>일관성·백업</td></tr><tr><td>오케스트레이션</td><td>배치·확장·서비스</td><td>Kubernetes, Nomad, ECS</td><td>복잡도·운영 리소스</td></tr><tr><td>플랫폼</td><td>배포 대상 환경</td><td>온프레/클라우드/엣지</td><td>규제·HW 제약</td></tr><tr><td>보안</td><td>공급망·런타임 보호</td><td>SBOM, Falco, OPA</td><td>규정 준수·탐지</td></tr><tr><td>관측·운영</td><td>모니터링·로깅</td><td>Prometheus, ELK, OTel</td><td>SLO·문제탐지 속도</td></tr></tbody></table><h4 id=컨테이너-도구프레임워크-기능-분류>컨테이너 도구·프레임워크 기능 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-도구프레임워크-기능-분류>#</a></h4><p>컨테이너 생태계는</p><ol><li>이미지와 런타임 (실행)</li><li>오케스트레이션 (운영 자동화)</li><li>빌드·레지스트리 (배포 파이프라인)</li><li>보안·네트워크·관측 (운영 신뢰성)<br>로 나뉜다.</li></ol><p>각 계층마다 전용 도구가 있으며, 실무에서는 이들을 조합해 CI→이미지→레지스트리→클러스터→관측의 파이프라인을 만든다.</p><h5 id=컨테이너-도구프레임워크-기능-분류-1>컨테이너 도구·프레임워크 기능 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-도구프레임워크-기능-분류-1>#</a></h5><h6 id=런타임이미지-엔진>런타임·이미지 엔진<a hidden class=anchor aria-hidden=true href=#런타임이미지-엔진>#</a></h6><ul><li><strong>주요 도구</strong>: Docker Engine, containerd, CRI-O, Podman, runc, LXD(시스템 컨테이너)</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Docker: 개발자 친화적 CLI + 데몬 기반 런타임. 이미지 빌드 (legacy)·로컬 개발용 표준.</li><li>containerd: 경량 컨테이너 런타임 (OCI), Kubernetes CRI 로 널리 사용. 컨테이너 생성/관리 핵심.</li><li>CRI-O: Kubernetes 전용 경량 런타임, OCI 호환, 보안성 최적화.</li><li>Podman: 데몬리스, rootless 지원으로 보안성 높음 (개발/CI/서버)</li><li>runc: 표준 OCI 런타임 (프로세스 생성)</li><li>LXD: 전체 시스템 컨테이너 (경량 VM 대체)</li></ul></li><li><strong>강점</strong>:<ul><li>Docker: 생태계·개발자 UX 우수, 커뮤니티·도구 풍부.</li><li>containerd/CRI-O: Kubernetes 친화적·경량·보안 우수.</li><li>Podman: Rootless 로 보안적 이점, CI 환경에서 유용.</li></ul></li><li><strong>약점</strong>:<ul><li>Docker: 데몬 기반으로 일부 보안/운영 이슈 (엔터프라이즈 배포에서는 containerd 선호).</li><li>Podman/LXD: 일부 툴 호환성 (전통적 Docker 스크립트) 에서 조정 필요.</li></ul></li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Docker</td><td>통합 엔진 + CLI</td><td style=text-align:right>개발/로컬/작업환경</td><td>UX·에코시스템</td><td>데몬·보안 이슈</td></tr><tr><td>containerd</td><td>경량 런타임</td><td style=text-align:right>K8s CRI 연동</td><td>안정·경량</td><td>직접 사용성 낮음</td></tr><tr><td>CRI-O</td><td>K8s 전용 런타임</td><td style=text-align:right>K8s 클러스터</td><td>보안·최적화</td><td>일반 개발 환경 적합성 낮음</td></tr><tr><td>Podman</td><td>데몬리스, rootless</td><td style=text-align:right>보안중심 실행</td><td>rootless 보안</td><td>기존 스크립트 호환성</td></tr><tr><td>LXD</td><td>시스템 컨테이너</td><td style=text-align:right>전체 OS 가상화</td><td>VM 대체</td><td>이미지 생태계 제한</td></tr></tbody></table><p>런타임 선택은 <strong>운영 환경 (K8s vs 단독) 과 보안 요구</strong>에 따라 달라진다. Kubernetes 운영은 containerd/CRI-O, 개발·로컬은 Docker/Podman 이 일반적이다.</p><h6 id=이미지-빌드레지스트리>이미지 빌드·레지스트리<a hidden class=anchor aria-hidden=true href=#이미지-빌드레지스트리>#</a></h6><ul><li><strong>주요 도구</strong>: BuildKit, Buildah, Kaniko, Buildpacks, Harbor, Docker Hub, GHCR, ECR/GCR/ACR</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>BuildKit: 고성능 병렬 빌드·캐시·비밀관리, 로컬/CI 빌드 가속.</li><li>Buildah: 데몬리스 이미지 빌드 (스크립트화·보안성).</li><li>Kaniko: 클러스터 (컨테이너 내부) 에서 안전하게 이미지 빌드 (권한 분리).</li><li>Buildpacks: 소스에서 자동으로 베스트 프랙티스 기반 이미지 생성 (언어 중심).</li><li>Harbor/DockerHub/GHCR/ECR: 레지스트리 (이미지 저장·검색·정책·스캔). Harbor 는 엔터프라이즈 기능 (레플리케이션·정책·스크닝).</li></ul></li><li><strong>강점</strong>: 빌드 혁신 (캐시·병렬), 레지스트리 보안·정책 적용 가능.</li><li><strong>약점</strong>: 레지스트리 운영 (HA·백업·레플리케이션) 및 빌드 캐시 일관성 유지의 운영 비용.</li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>BuildKit</td><td>고성능 빌드</td><td style=text-align:right>로컬/CI 빌드 가속</td><td>캐시·병렬·비밀관리</td><td>설정 복잡</td></tr><tr><td>Kaniko</td><td>클러스터 내 빌드</td><td style=text-align:right>CI 에서 안전 빌드</td><td>권한 분리</td><td>성능 제한 가능</td></tr><tr><td>Buildah</td><td>데몬리스 빌드</td><td style=text-align:right>스크립트화 빌드</td><td>보안성·유연성</td><td>학습곡선</td></tr><tr><td>Harbor</td><td>엔터프라이즈 레지스트리</td><td style=text-align:right>이미지 저장·정책</td><td>스캔·레플리케이션</td><td>운영 복잡</td></tr><tr><td>ECR/GCR/ACR</td><td>클라우드 레지스트리</td><td style=text-align:right>클라우드 통합</td><td>매니지드 서비스</td><td>클라우드 종속</td></tr></tbody></table><p><strong>빌드</strong>는 보안·캐시·자동화 관점에서 도구를 선택하고, <strong>레지스트리</strong>는 운영 (가용성·정책) 요구로 선택한다.</p><h6 id=오케스트레이션스케줄러>오케스트레이션·스케줄러<a hidden class=anchor aria-hidden=true href=#오케스트레이션스케줄러>#</a></h6><ul><li><strong>주요 도구</strong>: Kubernetes, Nomad, Docker Swarm, Apache Mesos</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Kubernetes: 포드 스케줄링, 서비스 디스커버리, 오토스케일, 헬스체크, 선언적 인프라의 표준.</li><li>Nomad: HashiCorp 경량 스케줄러 (멀티워크로드·간단한 운영).</li><li>Docker Swarm: Docker 내장형 간단 오케스트레이션 (소규모).</li><li>Mesos: 대규모 자원 추상화 (복잡한 데이터센터 환경).</li></ul></li><li><strong>강점/약점</strong>:<ul><li>Kubernetes: 기능 풍부·커뮤니티·에코시스템 강력 / 학습곡선·운영 복잡.</li><li>Nomad: 단순·운영비 낮음 / 에코시스템은 K8s 보다 좁음.</li><li>Swarm: 쉬운 진입 / 확장성·기능 한계.</li></ul></li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Kubernetes</td><td>컨테이너 오케스트레이션</td><td style=text-align:right>대규모 클러스터</td><td>풍부한 기능·에코시스템</td><td>복잡·운영비</td></tr><tr><td>Nomad</td><td>경량 스케줄러</td><td style=text-align:right>멀티워크로드</td><td>단순·유연</td><td>에코시스템 한정</td></tr><tr><td>Docker Swarm</td><td>내장 스케줄러</td><td style=text-align:right>소규모 클러스터</td><td>쉬운 설정</td><td>기능·확장성 제한</td></tr><tr><td>Mesos</td><td>자원 추상화</td><td style=text-align:right>대규모 데이터센터</td><td>고성능·유연</td><td>높은 복잡성</td></tr></tbody></table><p><strong>Kubernetes 가 표준</strong>이며, 단순성·운영비 우선이면 Nomad 또는 Swarm 선택 가능.</p><h6 id=배포패키지gitops>배포·패키지·GitOps<a hidden class=anchor aria-hidden=true href=#배포패키지gitops>#</a></h6><ul><li><strong>주요 도구</strong>: Helm, Kustomize, ArgoCD, Flux, Helmfile</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Helm: 패키지 매니저 (템플릿 기반 차트)—앱 배포 표준.</li><li>Kustomize: 패치 기반 환경별 커스터마이즈 (무템플릿).</li><li>ArgoCD/Flux: GitOps 기반 배포 자동화 (레포를 소스 오브 트루스).</li></ul></li><li><strong>강점</strong>: 재현 가능한 배포 파이프라인, 환경 별 구분 용이.</li><li><strong>약점</strong>: Helm 템플릿 복잡도, GitOps 는 초기 구성·정책 설정 필요.</li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Helm</td><td>패키지 매니저</td><td style=text-align:right>앱 배포</td><td>재사용성</td><td>템플릿 복잡</td></tr><tr><td>Kustomize</td><td>패치 기반 구성</td><td style=text-align:right>환경별 설정</td><td>단순·명시적</td><td>복잡한 변형 제한</td></tr><tr><td>ArgoCD</td><td>GitOps CD</td><td style=text-align:right>자동 동기화</td><td>선언적·감사성</td><td>초기설정·정책 필요</td></tr><tr><td>Flux</td><td>GitOps 구현체</td><td style=text-align:right>CD 자동화</td><td>경량·유연</td><td>일부 기능 차이</td></tr></tbody></table><p>배포 자동화는 Helm+GitOps(ArgoCD/Flux) 조합이 현재 실무 표준이다.</p><h6 id=네트워크서비스-메시>네트워크·서비스 메시<a hidden class=anchor aria-hidden=true href=#네트워크서비스-메시>#</a></h6><ul><li><strong>주요 도구</strong>: Cilium(eBPF), Calico, Flannel, Istio, Linkerd</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Cilium: eBPF 기반 네트워크·보안 (고성능 네트워크 정책, L7 분석).</li><li>Calico: BGP 기반 네트워크·정책 솔루션 (스케일·단순성 균형).</li><li>Istio/Linkerd: 서비스 메시 (트래픽 제어, mTLS, 관측)—Istio 는 기능 풍부, Linkerd 는 경량·성능 우수.</li></ul></li><li><strong>강점/약점</strong>:<ul><li>eBPF(Cilium): 성능·관측성 뛰어남 / 커널 의존성·학습곡선 존재.</li><li>Istio: 강력한 기능 / 운영 복잡·리소스 비용.</li><li>Linkerd: 설정·성능 우수 / 일부 고급 기능 부족.</li></ul></li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Cilium</td><td>eBPF 네트워크/보안</td><td style=text-align:right>네트워크 정책·L7</td><td>고성능·심층 관측</td><td>커널 의존성</td></tr><tr><td>Calico</td><td>네트워크·정책</td><td style=text-align:right>대규모 네트워크</td><td>단순·확장성</td><td>제한된 L7 기능</td></tr><tr><td>Istio</td><td>서비스 메시</td><td style=text-align:right>트래픽 제어·보안</td><td>풍부한 기능</td><td>복잡·리소스비</td></tr><tr><td>Linkerd</td><td>경량 서비스 메시</td><td style=text-align:right>보안·관측</td><td>성능·간단성</td><td>일부 기능 제한</td></tr></tbody></table><p>네트워크는 <strong>성능 vs 기능 vs 운영 복잡성</strong> 트레이드오프로 도구를 선택.</p><h6 id=보안정책취약점-스캐너>보안·정책·취약점 스캐너<a hidden class=anchor aria-hidden=true href=#보안정책취약점-스캐너>#</a></h6><ul><li><strong>주요 도구</strong>: Trivy, Grype, Falco, OPA Gatekeeper, Kyverno, Clair, Cosign</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Trivy/Grype/Clair: 이미지 취약점 스캐닝 (슬로우·빠름 차이).</li><li>Cosign/Notary: 이미지 서명·무결성 검증.</li><li>Falco: 런타임 보안 (비정상 행위 탐지).</li><li>OPA Gatekeeper / Kyverno: 정책 시행 (Admission control, 정책 as code).</li></ul></li><li><strong>강점/약점</strong>:<ul><li>스캐너: CI 통합 쉬움 / 오탐·스캔 속도/데이터베이스 갱신 필요.</li><li>정책 엔진: 강력한 거버넌스 / 정책 복잡도·관리비용.</li><li>런타임 탐지: 이상행위 탐지 가능 / 노이즈 (알람) 관리 필요.</li></ul></li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Trivy/Grype</td><td>이미지 스캔</td><td style=text-align:right>CI/Registry 스캔</td><td>빠름·간단</td><td>데이터베이스 의존</td></tr><tr><td>Cosign</td><td>이미지 서명</td><td style=text-align:right>무결성 검증</td><td>서명·검증 표준</td><td>운영 통합 필요</td></tr><tr><td>Falco</td><td>런타임 탐지</td><td style=text-align:right>이상행위 탐지</td><td>실시간 탐지</td><td>노이즈 관리 필요</td></tr><tr><td>OPA Gatekeeper</td><td>정책 엔진</td><td style=text-align:right>Admission control</td><td>정책 as code</td><td>정책 복잡성</td></tr></tbody></table><p>이미지는 <strong>빌드 단계에서 스캔·서명</strong>, 클러스터는 <strong>정책 엔진으로 입장 차단</strong>, 런타임 탐지는 <strong>Falco</strong>로 보완하는 패턴이 권장된다.</p><h6 id=관측성-메트릭로그트레이스>관측성 (메트릭·로그·트레이스)<a hidden class=anchor aria-hidden=true href=#관측성-메트릭로그트레이스>#</a></h6><ul><li><strong>주요 도구</strong>: Prometheus, Grafana, OpenTelemetry, Jaeger/Tempo, Loki, Fluentd/Fluent Bit</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>Prometheus: 시계열 메트릭 수집·알림 (SLO/Alertmanager).</li><li>Grafana: 시각화 대시보드.</li><li>OpenTelemetry: 분산 트레이스·메트릭 표준화 수집기.</li><li>Jaeger/Tempo: 분산 트레이스 저장·조회.</li><li>Loki/Fluentd: 로그 수집·저장 (로그 라벨링).</li></ul></li><li><strong>강점/약점</strong>:<ul><li>Prometheus: K8s 친화적 / 장기 보관·고해상도 비용 고려.</li><li>OpenTelemetry: 표준화 장점 / 수집 파이프 정교화 필요.</li></ul></li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Prometheus</td><td>시계열 메트릭</td><td style=text-align:right>모니터링·알람</td><td>K8s 친화</td><td>장기 보관 비용</td></tr><tr><td>Grafana</td><td>시각화</td><td style=text-align:right>대시보드</td><td>유연·플러그인</td><td>설정 복잡</td></tr><tr><td>OpenTelemetry</td><td>트레이스/메트릭 표준</td><td style=text-align:right>분산관측</td><td>표준화</td><td>설정·수집 파이프 복잡</td></tr><tr><td>Jaeger/Tempo</td><td>분산 트레이스</td><td style=text-align:right>성능 분석</td><td>트레이스 심층분석</td><td>스토리지 비용</td></tr></tbody></table><p>메트릭·로그·트레이스의 통합 (옵저버빌리티) 설계가 운영 신뢰성의 핵심이다.</p><h6 id=스토리지데이터-클러스터-스토리지>스토리지·데이터 (클러스터 스토리지)<a hidden class=anchor aria-hidden=true href=#스토리지데이터-클러스터-스토리지>#</a></h6><ul><li><strong>주요 도구</strong>: CSI(플러그인 표준), Rook, Longhorn, NFS/GlusterFS, Portworx</li><li><strong>정확한 기능/역할/용도</strong>:<ul><li>CSI: K8s 스토리지 플러그인 표준 (API).</li><li>Rook: Ceph 기반 스토리지 오퍼레이터 (블록·오브젝트·파일).</li><li>Longhorn: 경량 블록 스토리지 (손쉬운 배포).</li></ul></li><li><strong>강점/약점</strong>: 스토리지는 성능·데이터 보호·백업·스냅샷 요구로 운영 복잡도가 높음.</li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>CSI</td><td>스토리지 표준</td><td style=text-align:right>볼륨 프로비저닝</td><td>표준화</td><td>드라이버 품질 차이</td></tr><tr><td>Rook (Ceph)</td><td>분산 스토리지</td><td style=text-align:right>대용량·HA</td><td>유연성·기능</td><td>운영 복잡</td></tr><tr><td>Longhorn</td><td>블록 스토리지</td><td style=text-align:right>간단한 PV 제공</td><td>쉬운 설치</td><td>성능 한계</td></tr></tbody></table><p>스토리지 선택은 데이터 특성 (성능·일관성·백업) 에 기반해야 한다.</p><h6 id=cicd자동화>CI/CD·자동화<a hidden class=anchor aria-hidden=true href=#cicd자동화>#</a></h6><ul><li><strong>주요 도구</strong>: GitHub Actions, GitLab CI, Jenkins, Tekton, Argo Workflows</li><li><strong>정확한 기능/역할/용도</strong>: 코드 → 빌드 → 테스트 → 이미지 생성/스캔 → 레지스트리 → GitOps/CD 의 파이프라인 자동화.</li><li><strong>강점/약점</strong>: SaaS CI 는 빠름·간편 / 자체 호스팅은 보안·비용 장점.</li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>GitHub Actions</td><td>CI/CD as code</td><td style=text-align:right>파이프라인</td><td>통합·마켓플레이스</td><td>런 타임 비용</td></tr><tr><td>GitLab CI</td><td>통합 CI/CD</td><td style=text-align:right>내부·외부</td><td>내장·유연</td><td>설정 복잡</td></tr><tr><td>Jenkins</td><td>플러그인 풍부</td><td style=text-align:right>대규모 파이프라인</td><td>유연성</td><td>유지보수 부담</td></tr><tr><td>Tekton/ArgoW</td><td>클라우드네이티브 파이프라인</td><td style=text-align:right>K8s 네이티브</td><td>K8s 통합</td><td>학습곡선</td></tr></tbody></table><p>CI/CD 는 빌드·스캔·서명·프로모션을 자동화해 배포 신뢰도를 확보한다.</p><h6 id=보조-격리-런타임-런타임-하드닝>보조 격리 런타임 (런타임 하드닝)<a hidden class=anchor aria-hidden=true href=#보조-격리-런타임-런타임-하드닝>#</a></h6><ul><li><strong>주요 도구</strong>: gVisor, Kata Containers, Firecracker</li><li><strong>기능/용도</strong>: 컨테이너와 호스트 커널 사이에 추가 가상화 레이어를 두어 보안 격리 강화 (멀티테넌시 환경에서 중요).</li><li><strong>장점/단점</strong>: 보안 향상 / 성능·운영 복잡성 증가.</li></ul><table><thead><tr><th>도구</th><th>기능 (요약)</th><th style=text-align:right>용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>gVisor</td><td>유저스페이스 커널 레이어</td><td style=text-align:right>런타임 격리</td><td>보안 강화</td><td>호환성·성능 영향</td></tr><tr><td>Kata</td><td>경량 VM 런타임</td><td style=text-align:right>멀티테넌시</td><td>강력한 격리</td><td>부트오버헤드</td></tr><tr><td>Firecracker</td><td>MicroVM</td><td style=text-align:right>서버리스·파밀리어</td><td>성능·격리 균형</td><td>관리 복잡</td></tr></tbody></table><p>멀티테넌시·보안 요구가 높은 환경에서 고려.</p><h5 id=컨테이너-도구프레임워크-통합표>컨테이너 도구·프레임워크 통합표<a hidden class=anchor aria-hidden=true href=#컨테이너-도구프레임워크-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 도구 (예)</th><th>핵심 역할</th><th>실무 선택 기준</th></tr></thead><tbody><tr><td>런타임·이미지 엔진</td><td>Docker, containerd, CRI-O, Podman</td><td>컨테이너 실행·관리</td><td>K8s 연동 여부·보안 요구</td></tr><tr><td>이미지 빌드·레지스트리</td><td>BuildKit, Kaniko, Harbor, ECR</td><td>이미지 빌드·저장·정책</td><td>보안·레플리케이션·성능</td></tr><tr><td>오케스트레이션</td><td>Kubernetes, Nomad</td><td>스케줄링·오토스케일</td><td>기능·운영 인력</td></tr><tr><td>배포·GitOps</td><td>Helm, ArgoCD, Flux</td><td>배포 패키징·자동화</td><td>배포 방식·정책 필요성</td></tr><tr><td>네트워크·메시</td><td>Cilium, Calico, Istio</td><td>네트워크·보안·트래픽 제어</td><td>성능 vs 기능</td></tr><tr><td>보안·정책</td><td>Trivy, Cosign, OPA</td><td>이미지·런타임 정책</td><td>정책 복잡도</td></tr><tr><td>관측성</td><td>Prometheus, Grafana, OTEL</td><td>메트릭·로그·트레이스</td><td>스토리지·비용</td></tr><tr><td>스토리지</td><td>CSI, Rook, Longhorn</td><td>PV·데이터 관리</td><td>성능·데이터보호</td></tr><tr><td>CI/CD</td><td>GitHub Actions, Tekton</td><td>빌드·배포 파이프라인</td><td>통합·비용</td></tr><tr><td>런타임 격리</td><td>gVisor, Kata</td><td>보안 격리</td><td>보안 요구·성능</td></tr></tbody></table><h5 id=실습용-파이프라인>실습용 파이프라인<a hidden class=anchor aria-hidden=true href=#실습용-파이프라인>#</a></h5><h6 id=목표>목표<a hidden class=anchor aria-hidden=true href=#목표>#</a></h6><p><strong>GitHub Actions → 이미지 빌드 → SBOM 생성 → 취약점 스캔 (Trivy) → 레지스트리 푸시 → Cosign 서명 → k8s 매니페스트 태그 업데이트 → ArgoCD 가 자동으로 배포</strong>까지의 전체 흐름을 보여주는 예제.</p><h6 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h6><ul><li>애플리케이션: 간단한 Python Flask 앱</li><li>이미지 빌드: Docker Buildx (multi-stage)</li><li>SBOM 생성: Syft (anchore/syft)</li><li>취약점 스캔: Trivy (Aqua)</li><li>이미지 서명: Cosign (sigstore, keyless 권장)</li><li>레지스트리: Docker Hub / GHCR / ECR 등 (예시: Docker Hub)</li><li>GitOps 배포: ArgoCD 가 <code>k8s/</code> 디렉터리를 모니터링하여 자동 동기화</li><li>CI: GitHub Actions (workflow 포함)</li></ul><h6 id=저장소-구조-예시>저장소 구조 (예시)<a hidden class=anchor aria-hidden=true href=#저장소-구조-예시>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>my-app-repo/
</span></span><span class=line><span class=cl>├─ app/
</span></span><span class=line><span class=cl>│  ├─ app.py
</span></span><span class=line><span class=cl>│  └─ requirements.txt
</span></span><span class=line><span class=cl>├─ Dockerfile
</span></span><span class=line><span class=cl>├─ k8s/
</span></span><span class=line><span class=cl>│  ├─ deployment.yaml
</span></span><span class=line><span class=cl>│  └─ service.yaml
</span></span><span class=line><span class=cl>└─ .github/
</span></span><span class=line><span class=cl>   └─ workflows/
</span></span><span class=line><span class=cl>      └─ ci-cd-argocd.yaml
</span></span></code></pre></td></tr></table></div></div><h6 id=샘플-애플리케이션appapppy>샘플 애플리케이션—<code>app/app.py</code><a hidden class=anchor aria-hidden=true href=#샘플-애플리케이션appapppy>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 간단한 Flask 앱 (실습용)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span><span class=p>,</span> <span class=n>jsonify</span>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s2>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>hello</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>jsonify</span><span class=p>({</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;hello from container!&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 컨테이너 내부에서 실행시 외부 바인딩을 위해 0.0.0.0 사용</span>
</span></span><span class=line><span class=cl>    <span class=n>app</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>5000</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>app/requirements.txt</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Flask==2.2.5
</span></span></code></pre></td></tr></table></div></div><h6 id=dockerfile-멀티스테이지-sbom-생성에-적합>Dockerfile (멀티스테이지, SBOM 생성에 적합)<a hidden class=anchor aria-hidden=true href=#dockerfile-멀티스테이지-sbom-생성에-적합>#</a></h6><p><code>Dockerfile</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># ---- build stage ----</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>python:3.11-slim</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s>builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 의존성만 먼저 복사 -&gt; 캐시 이점</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app/requirements.txt .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install --no-cache-dir -r requirements.txt<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 앱 복사</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app/ /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># ---- runtime stage ----</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>python:3.11-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 런타임에 필요한 파일만 복사 (이미지 최소화)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /app /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 비루트 유저 생성 권장</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> useradd --no-create-home --shell /bin/false appuser <span class=o>&amp;&amp;</span> chown -R appuser /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=w> </span><span class=s>appuser</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=w> </span><span class=s>5000</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;python&#34;</span><span class=p>,</span> <span class=s2>&#34;app.py&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>팁: 실제 서비스라면 <code>slim</code> 대신 <code>distroless</code> 형태 혹은 멀티스테이지로 더 줄이는 방법 고려.</p></blockquote><h6 id=kubernetes-매니페스트-k8sdeploymentyaml-k8sserviceyaml>Kubernetes 매니페스트 (k8s/deployment.yaml, k8s/service.yaml)<a hidden class=anchor aria-hidden=true href=#kubernetes-매니페스트-k8sdeploymentyaml-k8sserviceyaml>#</a></h6><p><code>k8s/deployment.yaml</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span><span class=lnt id=hl-19-17><a class=lnlinks href=#hl-19-17>17</a>
</span><span class=lnt id=hl-19-18><a class=lnlinks href=#hl-19-18>18</a>
</span><span class=lnt id=hl-19-19><a class=lnlinks href=#hl-19-19>19</a>
</span><span class=lnt id=hl-19-20><a class=lnlinks href=#hl-19-20>20</a>
</span><span class=lnt id=hl-19-21><a class=lnlinks href=#hl-19-21>21</a>
</span><span class=lnt id=hl-19-22><a class=lnlinks href=#hl-19-22>22</a>
</span><span class=lnt id=hl-19-23><a class=lnlinks href=#hl-19-23>23</a>
</span><span class=lnt id=hl-19-24><a class=lnlinks href=#hl-19-24>24</a>
</span><span class=lnt id=hl-19-25><a class=lnlinks href=#hl-19-25>25</a>
</span><span class=lnt id=hl-19-26><a class=lnlinks href=#hl-19-26>26</a>
</span><span class=lnt id=hl-19-27><a class=lnlinks href=#hl-19-27>27</a>
</span><span class=lnt id=hl-19-28><a class=lnlinks href=#hl-19-28>28</a>
</span><span class=lnt id=hl-19-29><a class=lnlinks href=#hl-19-29>29</a>
</span><span class=lnt id=hl-19-30><a class=lnlinks href=#hl-19-30>30</a>
</span><span class=lnt id=hl-19-31><a class=lnlinks href=#hl-19-31>31</a>
</span><span class=lnt id=hl-19-32><a class=lnlinks href=#hl-19-32>32</a>
</span><span class=lnt id=hl-19-33><a class=lnlinks href=#hl-19-33>33</a>
</span><span class=lnt id=hl-19-34><a class=lnlinks href=#hl-19-34>34</a>
</span><span class=lnt id=hl-19-35><a class=lnlinks href=#hl-19-35>35</a>
</span><span class=lnt id=hl-19-36><a class=lnlinks href=#hl-19-36>36</a>
</span><span class=lnt id=hl-19-37><a class=lnlinks href=#hl-19-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c># 이미지 태그는 CI에서 치환(patch)될 예정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/your-org/your-repo:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>15</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>20</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># private registry 사용 시 imagePullSecrets를 설정하세요</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># imagePullSecrets:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c>#   - name: regcred</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>k8s/service.yaml</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>5000</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>CI 가 새 이미지 태그 (예: SHA) 를 만들면 <code>k8s/deployment.yaml</code> 의 image 값을 자동으로 교체 (patch) 하고 해당 변경을 커밋 → ArgoCD 가 자동 동기화하도록 구성한다.</p></blockquote><h6 id=github-actions-워크플로우-githubworkflowsci-cd-argocdyaml>GitHub Actions 워크플로우 (<code>.github/workflows/ci-cd-argocd.yaml</code>)<a hidden class=anchor aria-hidden=true href=#github-actions-워크플로우-githubworkflowsci-cd-argocdyaml>#</a></h6><p>아래 워크플로우는 다음을 수행:</p><ol><li>checkout</li><li>setup buildx</li><li>login to registry</li><li>build (multi-arch optional), push image with tag <code>${{ github.sha }}</code></li><li>generate SBOM (syft)</li><li>scan image with trivy (fail on HIGH/CRITICAL)</li><li>sign image with cosign (keyless 권장)</li><li>update <code>k8s/deployment.yaml</code> 의 image 태그로 치환하고 커밋 → push (GitOps)</li></ol><p><code>.github/workflows/ci-cd-argocd.yaml</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>  1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>  2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>  3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>  4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5>  5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6>  6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7>  7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8>  8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9>  9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10> 10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11> 11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12> 12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13> 13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14> 14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15> 15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16> 16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17> 17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18> 18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19> 19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20> 20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21> 21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22> 22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23> 23</a>
</span><span class=lnt id=hl-21-24><a class=lnlinks href=#hl-21-24> 24</a>
</span><span class=lnt id=hl-21-25><a class=lnlinks href=#hl-21-25> 25</a>
</span><span class=lnt id=hl-21-26><a class=lnlinks href=#hl-21-26> 26</a>
</span><span class=lnt id=hl-21-27><a class=lnlinks href=#hl-21-27> 27</a>
</span><span class=lnt id=hl-21-28><a class=lnlinks href=#hl-21-28> 28</a>
</span><span class=lnt id=hl-21-29><a class=lnlinks href=#hl-21-29> 29</a>
</span><span class=lnt id=hl-21-30><a class=lnlinks href=#hl-21-30> 30</a>
</span><span class=lnt id=hl-21-31><a class=lnlinks href=#hl-21-31> 31</a>
</span><span class=lnt id=hl-21-32><a class=lnlinks href=#hl-21-32> 32</a>
</span><span class=lnt id=hl-21-33><a class=lnlinks href=#hl-21-33> 33</a>
</span><span class=lnt id=hl-21-34><a class=lnlinks href=#hl-21-34> 34</a>
</span><span class=lnt id=hl-21-35><a class=lnlinks href=#hl-21-35> 35</a>
</span><span class=lnt id=hl-21-36><a class=lnlinks href=#hl-21-36> 36</a>
</span><span class=lnt id=hl-21-37><a class=lnlinks href=#hl-21-37> 37</a>
</span><span class=lnt id=hl-21-38><a class=lnlinks href=#hl-21-38> 38</a>
</span><span class=lnt id=hl-21-39><a class=lnlinks href=#hl-21-39> 39</a>
</span><span class=lnt id=hl-21-40><a class=lnlinks href=#hl-21-40> 40</a>
</span><span class=lnt id=hl-21-41><a class=lnlinks href=#hl-21-41> 41</a>
</span><span class=lnt id=hl-21-42><a class=lnlinks href=#hl-21-42> 42</a>
</span><span class=lnt id=hl-21-43><a class=lnlinks href=#hl-21-43> 43</a>
</span><span class=lnt id=hl-21-44><a class=lnlinks href=#hl-21-44> 44</a>
</span><span class=lnt id=hl-21-45><a class=lnlinks href=#hl-21-45> 45</a>
</span><span class=lnt id=hl-21-46><a class=lnlinks href=#hl-21-46> 46</a>
</span><span class=lnt id=hl-21-47><a class=lnlinks href=#hl-21-47> 47</a>
</span><span class=lnt id=hl-21-48><a class=lnlinks href=#hl-21-48> 48</a>
</span><span class=lnt id=hl-21-49><a class=lnlinks href=#hl-21-49> 49</a>
</span><span class=lnt id=hl-21-50><a class=lnlinks href=#hl-21-50> 50</a>
</span><span class=lnt id=hl-21-51><a class=lnlinks href=#hl-21-51> 51</a>
</span><span class=lnt id=hl-21-52><a class=lnlinks href=#hl-21-52> 52</a>
</span><span class=lnt id=hl-21-53><a class=lnlinks href=#hl-21-53> 53</a>
</span><span class=lnt id=hl-21-54><a class=lnlinks href=#hl-21-54> 54</a>
</span><span class=lnt id=hl-21-55><a class=lnlinks href=#hl-21-55> 55</a>
</span><span class=lnt id=hl-21-56><a class=lnlinks href=#hl-21-56> 56</a>
</span><span class=lnt id=hl-21-57><a class=lnlinks href=#hl-21-57> 57</a>
</span><span class=lnt id=hl-21-58><a class=lnlinks href=#hl-21-58> 58</a>
</span><span class=lnt id=hl-21-59><a class=lnlinks href=#hl-21-59> 59</a>
</span><span class=lnt id=hl-21-60><a class=lnlinks href=#hl-21-60> 60</a>
</span><span class=lnt id=hl-21-61><a class=lnlinks href=#hl-21-61> 61</a>
</span><span class=lnt id=hl-21-62><a class=lnlinks href=#hl-21-62> 62</a>
</span><span class=lnt id=hl-21-63><a class=lnlinks href=#hl-21-63> 63</a>
</span><span class=lnt id=hl-21-64><a class=lnlinks href=#hl-21-64> 64</a>
</span><span class=lnt id=hl-21-65><a class=lnlinks href=#hl-21-65> 65</a>
</span><span class=lnt id=hl-21-66><a class=lnlinks href=#hl-21-66> 66</a>
</span><span class=lnt id=hl-21-67><a class=lnlinks href=#hl-21-67> 67</a>
</span><span class=lnt id=hl-21-68><a class=lnlinks href=#hl-21-68> 68</a>
</span><span class=lnt id=hl-21-69><a class=lnlinks href=#hl-21-69> 69</a>
</span><span class=lnt id=hl-21-70><a class=lnlinks href=#hl-21-70> 70</a>
</span><span class=lnt id=hl-21-71><a class=lnlinks href=#hl-21-71> 71</a>
</span><span class=lnt id=hl-21-72><a class=lnlinks href=#hl-21-72> 72</a>
</span><span class=lnt id=hl-21-73><a class=lnlinks href=#hl-21-73> 73</a>
</span><span class=lnt id=hl-21-74><a class=lnlinks href=#hl-21-74> 74</a>
</span><span class=lnt id=hl-21-75><a class=lnlinks href=#hl-21-75> 75</a>
</span><span class=lnt id=hl-21-76><a class=lnlinks href=#hl-21-76> 76</a>
</span><span class=lnt id=hl-21-77><a class=lnlinks href=#hl-21-77> 77</a>
</span><span class=lnt id=hl-21-78><a class=lnlinks href=#hl-21-78> 78</a>
</span><span class=lnt id=hl-21-79><a class=lnlinks href=#hl-21-79> 79</a>
</span><span class=lnt id=hl-21-80><a class=lnlinks href=#hl-21-80> 80</a>
</span><span class=lnt id=hl-21-81><a class=lnlinks href=#hl-21-81> 81</a>
</span><span class=lnt id=hl-21-82><a class=lnlinks href=#hl-21-82> 82</a>
</span><span class=lnt id=hl-21-83><a class=lnlinks href=#hl-21-83> 83</a>
</span><span class=lnt id=hl-21-84><a class=lnlinks href=#hl-21-84> 84</a>
</span><span class=lnt id=hl-21-85><a class=lnlinks href=#hl-21-85> 85</a>
</span><span class=lnt id=hl-21-86><a class=lnlinks href=#hl-21-86> 86</a>
</span><span class=lnt id=hl-21-87><a class=lnlinks href=#hl-21-87> 87</a>
</span><span class=lnt id=hl-21-88><a class=lnlinks href=#hl-21-88> 88</a>
</span><span class=lnt id=hl-21-89><a class=lnlinks href=#hl-21-89> 89</a>
</span><span class=lnt id=hl-21-90><a class=lnlinks href=#hl-21-90> 90</a>
</span><span class=lnt id=hl-21-91><a class=lnlinks href=#hl-21-91> 91</a>
</span><span class=lnt id=hl-21-92><a class=lnlinks href=#hl-21-92> 92</a>
</span><span class=lnt id=hl-21-93><a class=lnlinks href=#hl-21-93> 93</a>
</span><span class=lnt id=hl-21-94><a class=lnlinks href=#hl-21-94> 94</a>
</span><span class=lnt id=hl-21-95><a class=lnlinks href=#hl-21-95> 95</a>
</span><span class=lnt id=hl-21-96><a class=lnlinks href=#hl-21-96> 96</a>
</span><span class=lnt id=hl-21-97><a class=lnlinks href=#hl-21-97> 97</a>
</span><span class=lnt id=hl-21-98><a class=lnlinks href=#hl-21-98> 98</a>
</span><span class=lnt id=hl-21-99><a class=lnlinks href=#hl-21-99> 99</a>
</span><span class=lnt id=hl-21-100><a class=lnlinks href=#hl-21-100>100</a>
</span><span class=lnt id=hl-21-101><a class=lnlinks href=#hl-21-101>101</a>
</span><span class=lnt id=hl-21-102><a class=lnlinks href=#hl-21-102>102</a>
</span><span class=lnt id=hl-21-103><a class=lnlinks href=#hl-21-103>103</a>
</span><span class=lnt id=hl-21-104><a class=lnlinks href=#hl-21-104>104</a>
</span><span class=lnt id=hl-21-105><a class=lnlinks href=#hl-21-105>105</a>
</span><span class=lnt id=hl-21-106><a class=lnlinks href=#hl-21-106>106</a>
</span><span class=lnt id=hl-21-107><a class=lnlinks href=#hl-21-107>107</a>
</span><span class=lnt id=hl-21-108><a class=lnlinks href=#hl-21-108>108</a>
</span><span class=lnt id=hl-21-109><a class=lnlinks href=#hl-21-109>109</a>
</span><span class=lnt id=hl-21-110><a class=lnlinks href=#hl-21-110>110</a>
</span><span class=lnt id=hl-21-111><a class=lnlinks href=#hl-21-111>111</a>
</span><span class=lnt id=hl-21-112><a class=lnlinks href=#hl-21-112>112</a>
</span><span class=lnt id=hl-21-113><a class=lnlinks href=#hl-21-113>113</a>
</span><span class=lnt id=hl-21-114><a class=lnlinks href=#hl-21-114>114</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>CI - Build / Scan / Sign / GitOps</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>permissions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>contents</span><span class=p>:</span><span class=w> </span><span class=l>write      </span><span class=w> </span><span class=c># manifest 파일 업데이트를 위해 필요</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>id-token</span><span class=p>:</span><span class=w> </span><span class=l>write      </span><span class=w> </span><span class=c># cosign keyless 서명을 위해 필요 (OIDC)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>IMAGE_NAME</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/${{ github.repository_owner }}/myapp  </span><span class=w> </span><span class=c># 예: GHCR 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>K8S_MANIFEST_PATH</span><span class=p>:</span><span class=w> </span><span class=l>k8s/deployment.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build-and-deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout repository</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>fetch-depth</span><span class=p>:</span><span class=w> </span><span class=m>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up QEMU (for multi-arch build optional)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/setup-qemu-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up Docker Buildx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/setup-buildx-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Log in to container registry</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># 예: GHCR 사용 시 username는 ${{ github.actor }}, token은 GHCR_PAT (or GITHUB_TOKEN for GHCR)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/login-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>username</span><span class=p>:</span><span class=w> </span><span class=l>${{ github.actor }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>password</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build and push image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>build-push</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/build-push-action@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>context</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>file</span><span class=p>:</span><span class=w> </span><span class=l>./Dockerfile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>push</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>tags</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          ${{ env.IMAGE_NAME }}:${{ github.sha }}
</span></span></span><span class=line><span class=cl><span class=sd>          ${{ env.IMAGE_NAME }}:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>build-args</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          # 필요한 경우 빌드 아규먼트 설정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cache-from</span><span class=p>:</span><span class=w> </span><span class=l>type=gha</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cache-to</span><span class=p>:</span><span class=w> </span><span class=l>type=gha,mode=max</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install syft (SBOM)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Generate SBOM (Syft)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        IMAGE=${{ env.IMAGE_NAME }}:${{ github.sha }}
</span></span></span><span class=line><span class=cl><span class=sd>        syft $IMAGE -o cyclonedx-json &gt; sbom-${{ github.sha }}.json</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Upload SBOM as artifact</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/upload-artifact@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sbom-${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>sbom-${{ github.sha }}.json</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Trivy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Scan image with Trivy (fail on HIGH/CRITICAL)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>trivy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        IMAGE=${{ env.IMAGE_NAME }}:${{ github.sha }}
</span></span></span><span class=line><span class=cl><span class=sd>        trivy image --exit-code 1 --severity HIGH,CRITICAL $IMAGE || (echo &#34;VULNERABILITIES_FOUND&#34; &amp;&amp; exit 1)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Cosign</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        COSIGN_VERSION=2.8.0
</span></span></span><span class=line><span class=cl><span class=sd>        curl -sSL -o /tmp/cosign.tar.gz https://github.com/sigstore/cosign/releases/download/v${COSIGN_VERSION}/cosign-linux-amd64.tar.gz
</span></span></span><span class=line><span class=cl><span class=sd>        sudo tar xzf /tmp/cosign.tar.gz -C /usr/local/bin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Sign image with cosign (keyless)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>COSIGN_EXPERIMENTAL</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        IMAGE=${{ env.IMAGE_NAME }}:${{ github.sha }}
</span></span></span><span class=line><span class=cl><span class=sd>        # keyless sign using GitHub Actions OIDC (recommended)
</span></span></span><span class=line><span class=cl><span class=sd>        cosign sign --keyless $IMAGE
</span></span></span><span class=line><span class=cl><span class=sd>        # verify (optional)
</span></span></span><span class=line><span class=cl><span class=sd>        cosign verify --keyless $IMAGE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Update k8s manifest image tag and commit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>NEW_IMAGE</span><span class=p>:</span><span class=w> </span><span class=l>${{ env.IMAGE_NAME }}:${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        git config user.name &#34;github-actions[bot]&#34;
</span></span></span><span class=line><span class=cl><span class=sd>        git config user.email &#34;github-actions[bot]@users.noreply.github.com&#34;
</span></span></span><span class=line><span class=cl><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        # manifest 파일에 이미지 태그 치환 (간단 sed 방식)
</span></span></span><span class=line><span class=cl><span class=sd>        # 주의: 실제로는 yq로 안전하게 처리 권장
</span></span></span><span class=line><span class=cl><span class=sd>        sed -i &#34;s|image: .*|image: ${NEW_IMAGE}|&#34; ${{ env.K8S_MANIFEST_PATH }}
</span></span></span><span class=line><span class=cl><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        git add ${{ env.K8S_MANIFEST_PATH }}
</span></span></span><span class=line><span class=cl><span class=sd>        git commit -m &#34;ci: deploy image ${{ github.sha }}&#34; || echo &#34;no changes to commit&#34;
</span></span></span><span class=line><span class=cl><span class=sd>        git push origin HEAD:main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Create GitHub Actions artifact with image info</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/upload-artifact@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>image-info</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          &lt;(echo &#34;${{ env.IMAGE_NAME }}:${{ github.sha }}&#34;)  # pseudo, or you can write to file</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>주요 포인트:></p><ul><li><code>permissions.id-token: write</code> 와 <code>actions/checkout</code> + <code>cosign sign --keyless</code> 조합으로 keyless 서명이 가능 (추가 설정: 조직/리포지토리에서 OIDC 허용 필요).</li><li>사설 레지스트리 (Docker Hub, ECR 등) 사용 시 <code>docker/login-action</code> 설정과 <code>secrets</code> 값을 맞추면 됨.</li><li><code>sed</code> 대신 <code>yq</code> 를 쓰면 YAML 구조를 안전히 변경할 수 있음 (권장).</li></ul></blockquote><h6 id=argocd-설정-예시>ArgoCD 설정 (예시)<a hidden class=anchor aria-hidden=true href=#argocd-설정-예시>#</a></h6><p>ArgoCD 는 이 저장소의 <code>k8s/</code> 경로를 모니터링하도록 설정한다.<br>아래 <code>Application</code> 을 ArgoCD 에 적용하면 GitOps 배포가 자동화된다.</p><p><code>argo/application.yaml</code> (ArgoCD 에 적용)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span><span class=lnt id=hl-22-18><a class=lnlinks href=#hl-22-18>18</a>
</span><span class=lnt id=hl-22-19><a class=lnlinks href=#hl-22-19>19</a>
</span><span class=lnt id=hl-22-20><a class=lnlinks href=#hl-22-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>argoproj.io/v1alpha1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Application</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>argocd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>project</span><span class=p>:</span><span class=w> </span><span class=l>default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>source</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>repoURL</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;https://github.com/&lt;YOUR_ORG&gt;/&lt;YOUR_REPO&gt;&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetRevision</span><span class=p>:</span><span class=w> </span><span class=l>HEAD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>k8s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>destination</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>server</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;https://kubernetes.default.svc&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>syncPolicy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>automated</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>prune</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>selfHeal</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>syncOptions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>CreateNamespace=true</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>ArgoCD 적용 명령 (클러스터에 ArgoCD 설치되어 있다고 가정):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f argo/application.yaml
</span></span></code></pre></td></tr></table></div></div><p>ArgoCD 는 repo 의 <code>k8s/deployment.yaml</code> 변경 (이미지 태그 변경) 을 감지하고 자동으로 동기화한다.</p><h6 id=필수-github-시크릿-및-권한-정리>필수 GitHub 시크릿 및 권한 정리<a hidden class=anchor aria-hidden=true href=#필수-github-시크릿-및-권한-정리>#</a></h6><ul><li><p><code>GITHUB_TOKEN</code>—기본 제공 (레포지토리에 커밋·푸시 권한 부여 필요)</p><ul><li>Settings → Actions → Workflow permissions: &ldquo;Read and write permissions&rdquo; 로 설정해야 <code>git push</code> 가능</li></ul></li><li><p>레지스트리 인증 (레지스트리 종류에 따라 다름):</p><ul><li><strong>GHCR</strong>: GITHUB_TOKEN 사용 가능 (특정 설정 필요) 또는 PAT</li><li><strong>Docker Hub</strong>: <code>DOCKER_USERNAME</code>, <code>DOCKER_PASSWORD</code></li><li><strong>ECR</strong>: AWS 액세스 키 <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> (또는 GitHub OIDC + aws-actions/configure-aws-credentials)</li></ul></li><li><p>(선택) Cosign keypair 방식 사용 시: <code>COSIGN_KEY</code>(비공개키), <code>COSIGN_PASSWORD</code>—다만 예시에서는 <strong>keyless</strong> 서명을 권장 (더 안전하고 관리 편함).</p></li><li><p>(권장) <code>SBOM</code>/아티팩트 저장을 위한 아티팩트 스토리지 권한 (옵션)</p></li></ul><h6 id=레지스트리-프라이빗일-경우-k8s-에-imagepullsecret-만들기>레지스트리 프라이빗일 경우 K8s 에 imagePullSecret 만들기<a hidden class=anchor aria-hidden=true href=#레지스트리-프라이빗일-경우-k8s-에-imagepullsecret-만들기>#</a></h6><p>Docker Hub 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl create secret docker-registry regcred <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-server<span class=o>=</span>https://index.docker.io/v1/ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-username<span class=o>=</span><span class=nv>$DOCKER_USERNAME</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-password<span class=o>=</span><span class=nv>$DOCKER_PASSWORD</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-email<span class=o>=</span>you@example.com
</span></span></code></pre></td></tr></table></div></div><p>그 후 <code>k8s/deployment.yaml</code> 의 <code>spec.template.spec.imagePullSecrets</code> 항목에 <code>regcred</code> 추가.</p><h6 id=로컬테스트-단계빠른-실행-가이드>로컬/테스트 단계—빠른 실행 가이드<a hidden class=anchor aria-hidden=true href=#로컬테스트-단계빠른-실행-가이드>#</a></h6><ol><li><p>리포지토리에 위 파일들을 올리고 <code>main</code> 브랜치에 푸시.</p></li><li><p>GitHub Actions 가 트리거되어 워크플로우를 실행 (빌드→스캔→서명→매니페스트 업데이트).</p></li><li><p>ArgoCD 가 repo 를 감시하고 변경을 감지하면 자동 동기화로 배포.</p></li><li><p>K8s 에서 상태 확인:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get pods -l <span class=nv>app</span><span class=o>=</span>myapp
</span></span><span class=line><span class=cl>kubectl describe pod &lt;pod-name&gt;
</span></span><span class=line><span class=cl>kubectl logs &lt;pod-name&gt;
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=컨테이너-표준보안-준수-체크포인트>컨테이너 표준·보안 준수 체크포인트<a hidden class=anchor aria-hidden=true href=#컨테이너-표준보안-준수-체크포인트>#</a></h4><p>컨테이너 표준 준수의 핵심은 <strong>이미지와 런타임 포맷 (OCI)</strong>, <strong>오케스트레이터 연동 인터페이스 (CRI/CNI/CSI)</strong>, 그리고 <strong>공급망 신뢰성 (SBOM·이미지 서명·attestation)</strong> 이다.</p><p>실무에서는 CI/CD 에서 SBOM 생성과 이미지 서명을 자동화하고, 레지스트리에서 스캔·검증을 거친 뒤 Kubernetes admission controller 로 정책을 강제한다.</p><p>런타임에서는 seccomp/SELinux 나 루트리스·VM 기반 격리로 커널 공유 위험을 보완하고, 로그·투명성 기록으로 감사·증적을 확보한다.</p><h5 id=컨테이너-표준보안-준수-핵심-분류>컨테이너 표준·보안 준수 핵심 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-표준보안-준수-핵심-분류>#</a></h5><h6 id=이미지배포-표준-oci-image--runtime--distribution>이미지·배포 표준 (OCI Image / Runtime / Distribution)<a hidden class=anchor aria-hidden=true href=#이미지배포-표준-oci-image--runtime--distribution>#</a></h6><p>OCI 스펙은 이미지 포맷, 런타임 실행 인터페이스, 레지스트리 배포 규약을 정의해 서로 다른 툴·레지스트리·런타임 간 호환을 보장한다. 실무에서는 OCI 이미지 해시를 기반으로 불변 태그 전략을 사용하고, Distribution API(레지스트리) 에서 서명·스캔·접근 제어를 연계한다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>Image Spec</td><td>이미지 구조·메타데이터 표준</td><td>불변 태그 (해시), 레이어 최적화</td></tr><tr><td>Runtime Spec</td><td>컨테이너 실행 규약</td><td>runc/containerd 호환성 검증</td></tr><tr><td>Distribution Spec</td><td>레지스트리 API</td><td>접근제어·캐시·서명 통합</td></tr></tbody></table><ul><li>OCI 준수는 툴·플랫폼 교체 시 호환성 리스크를 낮추며, 레지스트리·이미지 관리 정책 (서명·불변태그) 이 안전한 배포의 기초다.</li></ul><h6 id=오케스트레이터-인터페이스-cri--cni--csi>오케스트레이터 인터페이스 (CRI / CNI / CSI)<a hidden class=anchor aria-hidden=true href=#오케스트레이터-인터페이스-cri--cni--csi>#</a></h6><p>Kubernetes 와 같은 오케스트레이터는 CRI 로 런타임과 결합, CNI 로 네트워크 플러그인과 결합, CSI 로 스토리지 플러그인과 결합한다. 플러그인 선택에 따라 네트워크 정책·보안·성능 특성이 달라진다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>CRI</td><td>K8s ↔ 런타임 표준</td><td>containerd/CRI-O 호환성</td></tr><tr><td>CNI</td><td>네트워크 플러그인 표준</td><td>네트워크 정책, eBPF 지원</td></tr><tr><td>CSI</td><td>스토리지 플러그인 표준</td><td>퍼시스턴트 볼륨 관리</td></tr></tbody></table><ul><li><pre><code>CRI/CNI/CSI 준수는 오케스트레이터와 서드파티 플러그인의 상호운용성을 보장하므로 설계 시 플러그인별 기능과 한계를 검토해야 한다.
</code></pre></li></ul><h6 id=공급망-보호서명-sbom--sigstore-slsa--attestation>공급망 보호·서명 (SBOM / Sigstore /SLSA / Attestation)<a hidden class=anchor aria-hidden=true href=#공급망-보호서명-sbom--sigstore-slsa--attestation>#</a></h6><p>빌드 시점의 SBOM 생성, 이미지 서명, 투명성 로그, attestation 을 조합하면 소스→빌드→배포 전체의 신뢰를 확보할 수 있다. SLSA 는 빌드·공급망 신뢰 수준을 정의한다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>SBOM (SPDX/CycloneDX)</td><td>구성요소 목록</td><td>CI 에서 자동 생성·저장</td></tr><tr><td>이미지 서명 (cosign)</td><td>무결성·출처 검증</td><td>레지스트리 배포 전 검증</td></tr><tr><td>Attestation / Rekor</td><td>빌드 증명·투명성 로그</td><td>투명성 로그 보관·검색</td></tr></tbody></table><ul><li><pre><code>공급망 증빙은 규제·보안 요구를 만족시키는 핵심 매커니즘이며 CI/CD에 자연스럽게 통합되어야 한다.
</code></pre></li></ul><h6 id=런타임-보안격리-seccompselinuxrootlesskata>런타임 보안·격리 (seccomp/SELinux/rootless/Kata)<a hidden class=anchor aria-hidden=true href=#런타임-보안격리-seccompselinuxrootlesskata>#</a></h6><p>커널 공유 특성 때문에 런타임 보안 (시스템 콜 제한, LSM 정책, 비특권 실행) 과 더 강력한 격리가 필요하면 gVisor/Kata 같은 경량 VM 대안 사용을 고려한다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>seccomp</td><td>시스템 콜 필터링</td><td>프로파일 관리·테스트</td></tr><tr><td>SELinux/AppArmor</td><td>LSM 기반 접근제어</td><td>정책 템플릿 관리</td></tr><tr><td>rootless / Kata</td><td>추가 격리 옵션</td><td>성능·운영 영향 검토</td></tr></tbody></table><ul><li><pre><code>런타임 보안은 다층 방어(빌드·배포·런타임)로 설계하며, 민감 워크로드는 VM 대안을 고려한다.
</code></pre></li></ul><h6 id=레지스트리배포-파이프라인-보안-스캔검증admission>레지스트리·배포 파이프라인 보안 (스캔·검증·admission)<a hidden class=anchor aria-hidden=true href=#레지스트리배포-파이프라인-보안-스캔검증admission>#</a></h6><p>이미지 스캔 (취약점·구성 문제), 서명 검증, admission controller(OPA/Gatekeeper) 로 배포 전 정책을 강제한다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>이미지 스캔</td><td>취약점·설정 검사</td><td>정책 기준·스캔 주기</td></tr><tr><td>서명 검증</td><td>출처·무결성</td><td>레지스트리 검증 자동화</td></tr><tr><td>Admission policy</td><td>배포 전 규칙 강제</td><td>OPA/Gatekeeper 규칙</td></tr></tbody></table><ul><li><pre><code>배포 파이프라인에서 자동화된 검증과 정책 강제는 ‘사전 예방적 보안’의 핵심이다.
</code></pre></li></ul><h6 id=감사컴플라이언스로그-투명성-로그감사증적>감사·컴플라이언스·로그 (투명성 로그·감사증적)<a hidden class=anchor aria-hidden=true href=#감사컴플라이언스로그-투명성-로그감사증적>#</a></h6><p>투명성 로그, 감사 로그의 무결성 보관, SBOM·이미지서명·빌드관계의 증적 보관은 규제 대응과 사고 조사에 필수다.</p><table><thead><tr><th>항목</th><th>기능/목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td>투명성 로그</td><td>빌드·서명 기록 보관</td><td>Rekor 연동 등</td></tr><tr><td>감사 로그</td><td>배포·접근·정책 위반 기록</td><td>보존기간·무결성</td></tr><tr><td>규제 매핑</td><td>규제 요구 충족</td><td>증적·보고 자동화</td></tr></tbody></table><ul><li><pre><code>감사·증적은 단순 로그 수집을 넘어서 규제요구를 충족시키는 증빙 체계로 설계돼야 한다.
</code></pre></li></ul><h5 id=컨테이너-표준보안-핵심요약표>컨테이너 표준·보안 핵심요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-표준보안-핵심요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 표준/도구</th><th>주요 역할</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>이미지·배포</td><td>OCI Image/Runtime/Distribution</td><td>이미지 포맷·배포 호환성</td><td>불변 태그·레지스트리 보안</td></tr><tr><td>오케스트레이터 인터페이스</td><td>CRI / CNI / CSI</td><td>런타임·네트워크·스토리지 연동</td><td>플러그인 호환성·정책 기능</td></tr><tr><td>공급망 보호</td><td>SBOM(SPDX/CycloneDX), cosign, SLSA</td><td>출처·무결성·빌드신뢰</td><td>CI 자동화·투명성 로그</td></tr><tr><td>런타임 보안</td><td>seccomp, SELinux, rootless, Kata</td><td>런타임 권한·격리</td><td>프로파일·격리 옵션 적용</td></tr><tr><td>배포 파이프라인 보안</td><td>스캐너, admission(OPA)</td><td>배포 전 차단·검증</td><td>정책·스캔 기준 일치</td></tr><tr><td>감사·컴플라이언스</td><td>Rekor, 감사 로그, SBOM 보존</td><td>증적·규제 대응</td><td>로그 보존·무결성 보장</td></tr></tbody></table><h4 id=컨테이너-배포설정-관리-체계>컨테이너 배포·설정 관리 체계<a hidden class=anchor aria-hidden=true href=#컨테이너-배포설정-관리-체계>#</a></h4><p>컨테이너 배포와 설정 관리는 <strong>배포 전략 (롤링/블루 - 그린/카나리/A-B)</strong>, <strong>설정 분리 (ConfigMap/Secret)</strong>, 그리고 <strong>배포 자동화 도구 (Helm/Kustomize + GitOps: ArgoCD/Flux)</strong> 의 조합으로 설계한다.<br>배포할 때는 readiness/liveness probe 와 롤아웃 파라미터 (maxSurge, maxUnavailable) 를 반드시 설정해 무중단 배포와 빠른 롤백을 보장하고, Secret 은 암호화·권한 제어로 보호한다.<br>도구는 팀·서비스 복잡도에 맞춰 선택하라.</p><h5 id=배포설정-관리-핵심-카테고리>배포·설정 관리 핵심 카테고리<a hidden class=anchor aria-hidden=true href=#배포설정-관리-핵심-카테고리>#</a></h5><h6 id=배포-전략-deployment-strategies>배포 전략 (Deployment Strategies)<a hidden class=anchor aria-hidden=true href=#배포-전략-deployment-strategies>#</a></h6><p>배포 방식 (롤링, 블루 - 그린, 카나리, A/B) 의 정의·장단점·적용 상황과 구현 포인트를 정리한다.</p><table><thead><tr><th>전략</th><th>설명</th><th>장점</th><th>단점</th><th>구현 포인트</th></tr></thead><tbody><tr><td>롤링</td><td>점진적 교체 (기본)</td><td>리소스 효율, 무중단 가능</td><td>업그레이드 혼재 기간</td><td>Deployment maxSurge/maxUnavailable, probe 설정.</td></tr><tr><td>블루 - 그린</td><td>완전한 새 환경 전환</td><td>빠른 롤백, 확실한 격리</td><td>2 배 리소스 필요</td><td>DNS/LoadBalancer 교체, 데이터 동기 고려</td></tr><tr><td>카나리</td><td>일부 사용자로 새버전 테스트</td><td>위험 최소화, 점진적 검증</td><td>라우팅·관측 복잡</td><td>트래픽 분배·메트릭 기반 승격 (서비스 메시/Ingress)</td></tr><tr><td>A/B 실험</td><td>기능별 트래픽 분할</td><td>실험적 데이터 수집</td><td>복잡한 실험플랫폼 필요</td><td>실험 플랫폼 + 데이터 수집 (분석)</td></tr></tbody></table><ul><li>서비스 위험도·트래픽 특성·리소스 가용성에 따라 전략을 선택하라. 롤링은 범용, 카나리는 안전한 신기능 롤아웃에 적합하다.</li></ul><h6 id=설정-관리-config-management>설정 관리 (Config Management)<a hidden class=anchor aria-hidden=true href=#설정-관리-config-management>#</a></h6><p>ConfigMap/Secret 기반 구성 분리, 환경 오버라이드, 런타임 주입 방법 (환경변수/볼륨), 외부 설정 (Consul 등) 을 정리한다.</p><table><thead><tr><th>항목</th><th>용도</th><th>구현 방식</th><th>주의사항</th></tr></thead><tbody><tr><td>ConfigMap</td><td>비밀 아닌 설정</td><td>env/volume/mount</td><td>대용량 설정은 비효율</td></tr><tr><td>Secret</td><td>민감정보</td><td>Kubernetes Secret, SealedSecrets/KMS</td><td>기본은 base64, 암호화 필요.</td></tr><tr><td>환경 오버라이드</td><td>env 별 설정 분기</td><td>Kustomize overlays / Helm values</td><td>충돌·우선순위 관리 필요</td></tr><tr><td>외부 설정</td><td>중앙설정 서비스</td><td>Vault/Consul/Cloud Config</td><td>네트워크 의존성 고려</td></tr></tbody></table><ul><li>설정은 코드와 분리해 버전관리하고, Secret 은 별도 암호화·접근제어로 보호하라.</li></ul><h6 id=배포-자동화-도구-packaging--gitops>배포 자동화 도구 (Packaging & GitOps)<a hidden class=anchor aria-hidden=true href=#배포-자동화-도구-packaging--gitops>#</a></h6><p>Helm / Kustomize / ArgoCD / Flux 등 도구별 특징·사용 지침을 정리한다.</p><table><thead><tr><th>도구</th><th>역할</th><th>장점</th><th>단점</th><th>사용처</th></tr></thead><tbody><tr><td>Helm</td><td>패키지·템플릿</td><td>강력한 템플릿·차트 생태계</td><td>템플릿 복잡도</td><td>복잡한 앱 배포.</td></tr><tr><td>Kustomize</td><td>오버레이 패치</td><td>선언적·템플릿 없음</td><td>복잡한 논리 표현 제한</td><td>환경별 변형 (간단)</td></tr><tr><td>ArgoCD</td><td>GitOps CD</td><td>Git 소스오브트루스, UI</td><td>러닝커브</td><td>지속적 배포·멀티앱 관리.</td></tr><tr><td>Flux</td><td>GitOps 오퍼레이터</td><td>자동 동기화</td><td>K8s 전용</td><td>자동화 파이프라인</td></tr></tbody></table><ul><li>Helm 은 패키징·배포 중심, Kustomize 는 깔끔한 환경 오버레이, ArgoCD/Flux 는 GitOps 자동화에 특화.</li></ul><h6 id=실전-운영-보강-safety--observability>실전 운영 보강 (Safety & Observability)<a hidden class=anchor aria-hidden=true href=#실전-운영-보강-safety--observability>#</a></h6><p>무중단 배포·롤백을 위한 모니터링·알람·자동 중단·보안 구성 요소.</p><table><thead><tr><th>항목</th><th>역할</th><th>권장 구성</th></tr></thead><tbody><tr><td>프로브</td><td>헬스 체크</td><td>readiness/liveness + 초기 지연 설정.</td></tr><tr><td>모니터링</td><td>배포 시 영향 판단</td><td>메트릭 (트래픽, 오류율), 분산 트레이싱</td></tr><tr><td>자동 중단/롤백</td><td>오류 시 중단</td><td>Argo Rollouts / custom controller</td></tr><tr><td>비밀관리</td><td>배포 중 민감정보</td><td>KMS/SealedSecrets, RBAC</td></tr></tbody></table><ul><li>배포는 관측과 결합되어야 안전하다—지표 기반 승격/중단 룰을 정의하라.</li></ul><h6 id=멀티클러스터네임스페이스정책>멀티클러스터·네임스페이스·정책<a hidden class=anchor aria-hidden=true href=#멀티클러스터네임스페이스정책>#</a></h6><p>멀티클러스터, 네임스페이스 격리, 리소스 쿼터, 거버넌스 요소 정리.</p><table><thead><tr><th>항목</th><th>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>네임스페이스</td><td>논리적 격리</td><td>리소스쿼터·네트워크 폴리시</td></tr><tr><td>멀티클러스터</td><td>지리적·격리 운영</td><td>GitOps + cluster bootstrap</td></tr><tr><td>거버넌스</td><td>정책·준수</td><td>OPA/Gatekeeper, RBAC</td></tr></tbody></table><ul><li>대규모 조직은 네임스페이스·멀티클러스터 전략과 정책 엔진을 조합해 거버넌스를 확보하라.</li></ul><h5 id=배포설정-관리-총괄표>배포·설정 관리 총괄표<a hidden class=anchor aria-hidden=true href=#배포설정-관리-총괄표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 포인트</th><th>대표 도구</th><th>적용 우선순위</th></tr></thead><tbody><tr><td>배포 전략</td><td>리스크 vs 리소스 균형 선택</td><td>Kubernetes Deployment, Argo Rollouts</td><td>서비스 중요도 기반</td></tr><tr><td>설정 관리</td><td>설정 분리·비밀 암호화</td><td>ConfigMap/Secret, SealedSecrets</td><td>보안 필수</td></tr><tr><td>자동화 (GitOps)</td><td>Git 기반 선언형 배포</td><td>ArgoCD, Flux, Helm, Kustomize</td><td>개발팀 워크플로우 우선화</td></tr><tr><td>운영 보강</td><td>프로브·모니터링·롤백</td><td>Prometheus, Grafana, Alertmanager</td><td>SLO 기반 알람</td></tr><tr><td>멀티클러스터·거버넌스</td><td>격리·정책·규모화</td><td>OPA/Gatekeeper, Cluster API</td><td>조직·규제 요건 대응</td></tr></tbody></table><ul><li>배포 전략은 서비스 특성에, 설정 관리는 보안·환경 분리에, 자동화는 팀 프로세스에 맞춰 선택·조합하라.</li></ul><h4 id=컨테이너-안티패턴과-실무-해법-요약>컨테이너 안티패턴과 실무 해법 요약<a hidden class=anchor aria-hidden=true href=#컨테이너-안티패턴과-실무-해법-요약>#</a></h4><p>컨테이너 환경에서 자주 발생하는 안티패턴은</p><ol><li><strong>보안 (루트·시크릿)</strong></li><li><strong>이미지 관리 (태그·거대 이미지·레이어 관리)</strong></li><li><strong>운영 (리소스·프로브 부재)</strong></li><li><strong>빌드/배포 (컨테이너 내 빌드·환경별 이미지)</strong><br>로 압축된다.<br>해결은 <strong>정책화 (태깅/이미지 스캐닝/서명)</strong>, <strong>CI/CD 자동화 (멀티스테이지 빌드, 아티팩트 기반 배포)</strong>, <strong>런타임 보호 (non-root, securityContext)</strong>, <strong>운영 템플릿 (리소스·프로브)</strong> 을 조직 표준으로 정해 자동으로 강제하는 것이다.</li></ol><h5 id=컨테이너-운영-안티패턴-분류>컨테이너 운영 안티패턴 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-운영-안티패턴-분류>#</a></h5><h6 id=이미지빌드-관련>이미지·빌드 관련<a hidden class=anchor aria-hidden=true href=#이미지빌드-관련>#</a></h6><p><strong>설명</strong>: 이미지 크기·레이어·태깅·빌드 방식에서 발생하는 문제.<br><strong>주요 안티패턴</strong>: <code>latest</code> 태그, 거대 이미지, 컨테이너 내 빌드, 이미지 계층 과다.<br><strong>문제/결과</strong>: 배포 불투명·롤백 불가, 네트워크 비용·시작 지연 증가, 취약면 증가, 빌드 비효율.<br><strong>원인</strong>: 규칙 없음, 속도 우선 개발, CI 미구현.<br><strong>해결책</strong>:</p><ul><li>태깅 규칙 (semver + commit SHA) 강제.</li><li>멀티스테이지 빌드 사용.</li><li><code>.dockerignore</code> 활용, 레이어 합치기.</li><li>CI 에서 빌드·아티팩트 관리.</li></ul><p><strong>예시 (안티 → 수정)</strong>:</p><p><strong><code>latest</code> 태그 사용 (이미지 태깅 안티패턴)</strong><br><strong>안티패턴 예 (K8s Pod)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6>6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7>7</a>
</span><span class=lnt id=hl-26-8><a class=lnlinks href=#hl-26-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># BAD: latest 태그 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w> </span>{<span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>myrepo/myapp:latest</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>수정 예</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4>4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5>5</a>
</span><span class=lnt id=hl-27-6><a class=lnlinks href=#hl-27-6>6</a>
</span><span class=lnt id=hl-27-7><a class=lnlinks href=#hl-27-7>7</a>
</span><span class=lnt id=hl-27-8><a class=lnlinks href=#hl-27-8>8</a>
</span><span class=lnt id=hl-27-9><a class=lnlinks href=#hl-27-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># GOOD: 명확한 버전 + 이미지 서명/태그 규칙 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w> </span>{<span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>myrepo/myapp:1.4.2-20250901-ab12cd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>imagePullPolicy</span><span class=p>:</span><span class=w> </span><span class=l>IfNotPresent</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>거대 이미지 (불필요한 빌드 툴 포함)</strong><br><strong>안티패턴 Dockerfile</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3>3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4>4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5>5</a>
</span><span class=lnt id=hl-28-6><a class=lnlinks href=#hl-28-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># BAD: 빌드 도구가 포함된 단일 스테이지</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>node:18</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y build-essential python<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> npm install <span class=o>&amp;&amp;</span> npm run build<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;node&#34;</span><span class=p>,</span> <span class=s2>&#34;dist/index.js&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>수정 (멀티스테이지)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1> 1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2> 2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3> 3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4> 4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5> 5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6> 6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7> 7</a>
</span><span class=lnt id=hl-29-8><a class=lnlinks href=#hl-29-8> 8</a>
</span><span class=lnt id=hl-29-9><a class=lnlinks href=#hl-29-9> 9</a>
</span><span class=lnt id=hl-29-10><a class=lnlinks href=#hl-29-10>10</a>
</span><span class=lnt id=hl-29-11><a class=lnlinks href=#hl-29-11>11</a>
</span><span class=lnt id=hl-29-12><a class=lnlinks href=#hl-29-12>12</a>
</span><span class=lnt id=hl-29-13><a class=lnlinks href=#hl-29-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># GOOD: 멀티스테이지로 런타임 최적화</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>node:18</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s>builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> package*.json ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> npm ci<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> npm run build<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>node:18-slim</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s>runtime</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /app/dist ./dist<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /app/node_modules ./node_modules<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;node&#34;</span><span class=p>,</span> <span class=s2>&#34;dist/index.js&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>이미지·빌드 요약</strong></p><table><thead><tr><th>항목</th><th>문제</th><th>해결</th></tr></thead><tbody><tr><td>latest 태그</td><td>재현 불가·롤백 불가</td><td>Immutable 태그 사용</td></tr><tr><td>거대 이미지</td><td>네트워크·보안 문제</td><td>멀티스테이지 빌드</td></tr><tr><td>컨테이너 내 빌드</td><td>CI 부재·비일관성</td><td>CI 에서 빌드, 멀티스테이지</td></tr><tr><td>레이어 과다</td><td>빌드 속도 저하</td><td>RUN 합치기,.dockerignore</td></tr></tbody></table><ul><li>이미지는 <strong>작고 불변</strong>하게 유지하라. 빌드는 CI 에서, 런타임 이미지는 경량화.</li></ul><h6 id=보안-관련>보안 관련<a hidden class=anchor aria-hidden=true href=#보안-관련>#</a></h6><p><strong>설명</strong>: 실행 권한·시크릿·컨테이너 권한 범위 문제.<br><strong>주요 안티패턴</strong>: 루트 실행, 시크릿 이미지 포함, 호스트 권한 남발.<br><strong>문제/결과</strong>: 호스트 침해 위험, 민감정보 유출, 전체 클러스터 위협.<br><strong>원인</strong>: 편의성, 보안 정책 미비.<br><strong>해결책</strong>:</p><ul><li><p>Non-root 원칙, <code>readOnlyRootFilesystem</code>, <code>capabilities</code> 최소화.</p></li><li><p>시크릿은 런타임 주입 (Vault/K8s Secret) 및 이미지에 절대 포함 금지.</p></li><li><p>PodSecurityPolicy/OPA 로 강제.</p></li></ul><p><strong>안티 → 수정 예시</strong>:</p><p><strong>루트 사용자로 컨테이너 실행</strong><br><strong>안티패턴 Dockerfile</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># BAD</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>ubuntu:22.04</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y some-tool<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./start.sh&#34;</span><span class=p>]</span>  <span class=c1># runs as root</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>수정 Dockerfile</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4>4</a>
</span><span class=lnt id=hl-31-5><a class=lnlinks href=#hl-31-5>5</a>
</span><span class=lnt id=hl-31-6><a class=lnlinks href=#hl-31-6>6</a>
</span><span class=lnt id=hl-31-7><a class=lnlinks href=#hl-31-7>7</a>
</span><span class=lnt id=hl-31-8><a class=lnlinks href=#hl-31-8>8</a>
</span><span class=lnt id=hl-31-9><a class=lnlinks href=#hl-31-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># GOOD: non-root 사용자 생성 및 전환</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>ubuntu:22.04</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> useradd -m appuser <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    apt-get update <span class=o>&amp;&amp;</span> apt-get install -y some-tool <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    chown -R appuser:appuser /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=w> </span><span class=s>appuser</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --chown<span class=o>=</span>appuser:appuser . /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./start.sh&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>Kubernetes 쪽 보완:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2>2</a>
</span><span class=lnt id=hl-32-3><a class=lnlinks href=#hl-32-3>3</a>
</span><span class=lnt id=hl-32-4><a class=lnlinks href=#hl-32-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>runAsNonRoot</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>runAsUser</span><span class=p>:</span><span class=w> </span><span class=m>1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>readOnlyRootFilesystem</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>시크릿을 이미지에 포함</strong>:</p><p><strong>안티패턴 Dockerfile</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span><span class=lnt id=hl-33-3><a class=lnlinks href=#hl-33-3>3</a>
</span><span class=lnt id=hl-33-4><a class=lnlinks href=#hl-33-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># BAD: 키를 이미지에 넣음</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>node:18</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>DB_PASSWORD</span><span class=o>=</span><span class=s2>&#34;SuperSecret123&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /app<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>수정 (런타임 시크릿 주입)</strong></p><ul><li><p>Dockerfile: 시크릿 없음</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span><span class=lnt id=hl-34-4><a class=lnlinks href=#hl-34-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=s>node:18</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;node&#34;</span><span class=p>,</span> <span class=s2>&#34;server.js&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Kubernetes: Secret 마운트 예</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1> 1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2> 2</a>
</span><span class=lnt id=hl-35-3><a class=lnlinks href=#hl-35-3> 3</a>
</span><span class=lnt id=hl-35-4><a class=lnlinks href=#hl-35-4> 4</a>
</span><span class=lnt id=hl-35-5><a class=lnlinks href=#hl-35-5> 5</a>
</span><span class=lnt id=hl-35-6><a class=lnlinks href=#hl-35-6> 6</a>
</span><span class=lnt id=hl-35-7><a class=lnlinks href=#hl-35-7> 7</a>
</span><span class=lnt id=hl-35-8><a class=lnlinks href=#hl-35-8> 8</a>
</span><span class=lnt id=hl-35-9><a class=lnlinks href=#hl-35-9> 9</a>
</span><span class=lnt id=hl-35-10><a class=lnlinks href=#hl-35-10>10</a>
</span><span class=lnt id=hl-35-11><a class=lnlinks href=#hl-35-11>11</a>
</span><span class=lnt id=hl-35-12><a class=lnlinks href=#hl-35-12>12</a>
</span><span class=lnt id=hl-35-13><a class=lnlinks href=#hl-35-13>13</a>
</span><span class=lnt id=hl-35-14><a class=lnlinks href=#hl-35-14>14</a>
</span><span class=lnt id=hl-35-15><a class=lnlinks href=#hl-35-15>15</a>
</span><span class=lnt id=hl-35-16><a class=lnlinks href=#hl-35-16>16</a>
</span><span class=lnt id=hl-35-17><a class=lnlinks href=#hl-35-17>17</a>
</span><span class=lnt id=hl-35-18><a class=lnlinks href=#hl-35-18>18</a>
</span><span class=lnt id=hl-35-19><a class=lnlinks href=#hl-35-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w> </span>{<span class=w> </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>db-secret }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Opaque</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>stringData</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>DB_PASSWORD</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;SuperSecret123&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>myrepo/myapp:1.0.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>DB_PASSWORD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>secretKeyRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>db-secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>DB_PASSWORD</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>보안 요약</strong></p><table><thead><tr><th>항목</th><th>문제</th><th>해결</th></tr></thead><tbody><tr><td>root 실행</td><td>권한 상승·심각한 보안 리스크</td><td>runAsNonRoot, 최소 권한</td></tr><tr><td>시크릿 이미지 포함</td><td>시크릿 유출</td><td>Vault/K8s Secret 로 런타임 주입</td></tr><tr><td>과도한 권한 (hostPath 등)</td><td>호스트 손상 위험</td><td>권한 최소화, PSO/OPA 정책 적용</td></tr></tbody></table><ul><li>권한은 <strong>최소화</strong>, 시크릿은 <strong>런타임 주입</strong>, 정책은 <strong>자동화로 강제</strong>.</li></ul><h6 id=런타임리소스-관련>런타임·리소스 관련<a hidden class=anchor aria-hidden=true href=#런타임리소스-관련>#</a></h6><p><strong>설명</strong>: 리소스 요청/한계, health probe, 로그/모니터링 부족.<br><strong>주요 안티패턴</strong>: 리소스 미설정, liveness/readiness 미설정, 로그 표준 없음.<br><strong>문제/결과</strong>: OOM, 스케줄러 혼란, 무응답 서비스 장시간 유지, 문제원인 추적 불가.<br><strong>원인</strong>: 초깃값 생략, 모니터링 미구축.<br><strong>해결책</strong>:</p><ul><li>리소스 템플릿과 SLO 기반 request/limit 설정.</li><li>readiness/liveness probe 표준 템플릿.</li><li>구조화된 로그 (JSON) 및 샘플링 정책.</li></ul><p><strong>런타임 요약</strong></p><table><thead><tr><th>항목</th><th>문제</th><th>해결</th></tr></thead><tbody><tr><td>resources 없음</td><td>OOM/스케줄 혼잡</td><td>요청/한계 설정 템플릿</td></tr><tr><td>probe 없음</td><td>장애 미검출/배포 실패</td><td>liveness/readiness 필수화</td></tr><tr><td>로그 비구조화</td><td>디버깅 곤란</td><td>Structured 로그 + 중앙집중화</td></tr></tbody></table><ul><li>안정성은 <strong>리소스·프로브·관측</strong>에서 시작한다.</li></ul><h6 id=운영배포-관련>운영·배포 관련<a hidden class=anchor aria-hidden=true href=#운영배포-관련>#</a></h6><p><strong>설명</strong>: 환경 분리·태깅·네임스페이스·거버넌스 문제.<br><strong>주요 안티패턴</strong>: 환경별 이미지, 모호한 네임스페이스, 정책 부재.<br><strong>문제/결과</strong>: 이미지 폭발, 배포 실수, 권한·비용 추적 불가.<br><strong>원인</strong>: config 와 코드 분리 미흡, 거버넌스 미비.<br><strong>해결책</strong>:</p><ul><li>하나의 이미지 + 환경별 설정 (ConfigMap/Secrets) 사용.</li><li>명확한 네임스페이스/태그 정책, 비용 태깅 강제.</li><li>GitOps + 정책 엔진 (OPA) 통합.</li></ul><p><strong>운영 요약</strong></p><table><thead><tr><th>항목</th><th>문제</th><th>해결</th></tr></thead><tbody><tr><td>환경별 이미지</td><td>관리 비용 폭증</td><td>하나의 이미지 + Config</td></tr><tr><td>네임스페이스 모호</td><td>권한·리소스 충돌</td><td>표준 네임스페이스 전략</td></tr><tr><td>정책 부재</td><td>보안/비용 통제 불가</td><td>OPA/Gatekeeper 로 강제화</td></tr></tbody></table><ul><li>운영은 <strong>표준화 + 자동화 + 정책강제</strong>로 해결한다.</li></ul><h5 id=안티패턴-통합-요약표>안티패턴 통합 요약표<a hidden class=anchor aria-hidden=true href=#안티패턴-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 안티패턴</th><th>핵심 리스크</th><th>권장 해결책 (한줄)</th></tr></thead><tbody><tr><td>이미지·빌드</td><td>latest, 거대 이미지, 레이어 과다</td><td>배포·비용·보안 문제</td><td>멀티스테이지, immutable tag,.dockerignore</td></tr><tr><td>보안</td><td>root, 시크릿 in image, host 권한</td><td>시스템 침해·데이터 유출</td><td>non-root, Vault/Secret, 최소 권한</td></tr><tr><td>런타임</td><td>리소스 없음, 프로브 없음</td><td>OOM·무응답 서비스</td><td>request/limit, readiness/liveness</td></tr><tr><td>운영</td><td>환경별 이미지, 네임스페이스 무질서</td><td>관리비·실수·컴플라이언스 문제</td><td>Config 로 환경 분리, GitOps, OPA</td></tr></tbody></table><h4 id=단계별-컨테이너-마이그레이션-로드맵>단계별 컨테이너 마이그레이션 로드맵<a hidden class=anchor aria-hidden=true href=#단계별-컨테이너-마이그레이션-로드맵>#</a></h4><p>컨테이너로 이전할 때 한 번에 모든 것을 옮기지 말고 단계별로 진행한다.<br>먼저 현재 시스템을 평가해 어떤 서비스를 컨테이너화할지 우선순위를 정한다.<br>그다음 이미지 표준 (멀티스테이지 Dockerfile), 레지스트리, CI/CD 파이프라인을 만들고 스테이징에서 충분히 검증한다.<br>트래픽 전환은 블루 - 그린이나 카나리아로 소수 트래픽부터 늘려가며 모니터링한다.<br>데이터가 연결된 (상태 ful) 서비스는 CDC 나 dual-write 같은 방법으로 데이터 일관성을 유지한 뒤 최종 커트오버한다. 모든 단계에서 모니터링과 롤백 (또는 패치) 절차를 준비하는 것이 핵심이다.</p><h5 id=컨테이너-마이그레이션-단계별-체크표>컨테이너 마이그레이션 단계별 체크표<a hidden class=anchor aria-hidden=true href=#컨테이너-마이그레이션-단계별-체크표>#</a></h5><table><thead><tr><th>단계</th><th style=text-align:right>목적</th><th>핵심 활동</th><th>도구/기법 예시</th><th>검증 지표 (예시)</th></tr></thead><tbody><tr><td>1. 평가 (Assessment)</td><td style=text-align:right>대상·리스크 파악</td><td>앱 인벤토리, 의존성·상태 분류</td><td>애플리케이션 매핑, 팀 인터뷰</td><td>이전 우선순위 목록, 리스크 점수</td></tr><tr><td>2. PoC(Proof of Concept)</td><td style=text-align:right>기술 적합성 검증</td><td>소규모 컨테이너화·배포 시험</td><td>Dockerfile, k8s small cluster</td><td>기동시간, 오류율, 리소스 사용</td></tr><tr><td>3. 컨테이너화 (Build)</td><td style=text-align:right>이미지 표준화</td><td>멀티스테이지 Dockerfile, 이미지 스캔</td><td>BuildKit, cosign, Trivy</td><td>이미지 빌드 성공률, 취약점 수</td></tr><tr><td>4. 파이프라인 자동화</td><td style=text-align:right>반복 배포 확보</td><td>CI/CD → 레지스트리 → CD</td><td>GitHub Actions, Jenkins, ArgoCD</td><td>배포 성공률, 파이프라인 시간</td></tr><tr><td>5. 스테이징·검증</td><td style=text-align:right>실전 전 검증</td><td>통합테스트·부하·회복력 테스트</td><td>e2e, loadtest, chaos</td><td>실패율, 응답시간, SLO 위반</td></tr><tr><td>6. 트래픽 전환 (카나리아)</td><td style=text-align:right>점진 이전·리스크 완화</td><td>트래픽 분할→모니터→확대</td><td>Istio/Envoy, ALB weight, Feature flags</td><td>에러율·지연·사용자 영향 (주간)</td></tr><tr><td>7. 데이터 전환</td><td style=text-align:right>상태 일관성 확보</td><td>Dual-write/CDC/Outbox/Backfill</td><td>Debezium, Kafka, gh-ost</td><td>데이터 정합성 검사, lag</td></tr><tr><td>8. 롤백/안정화</td><td style=text-align:right>장애 시 복구</td><td>자동 롤백 정책, 핫픽스 절차</td><td>Argo Rollouts, Feature flags</td><td>MTTR, 롤백 횟수</td></tr><tr><td>9. 운영·업그레이드</td><td style=text-align:right>장기 운영·보안 유지</td><td>k8s 업그레이드, 이미지 갱신, DR drill</td><td>kubeadm, CI, backup tools</td><td>패치 적용률, DR RTO/RPO</td></tr></tbody></table><p>각 단계는 순차적이지만 반복 (iterative) 해야 안전하다. 특히 <strong>PoC→파이프라인→스테이징→카나리아→데이터 전환</strong> 순서를 엄격히 지키고, 자동화된 검증 지표 (SLO 기반) 를 통해 다음 단계로 넘어갈지 판단해야 한다. 데이터 전환은 별도의 전담 팀·검증 절차가 필요하고, DB 롤백 불가능성 때문에 리스크를 가장 낮게 설계해야 한다.</p><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-fastapi-마이크로서비스-컨테이너화--kubernetes-배포>실습 예제: FastAPI 마이크로서비스 컨테이너화 → Kubernetes 배포<a hidden class=anchor aria-hidden=true href=#실습-예제-fastapi-마이크로서비스-컨테이너화--kubernetes-배포>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>멀티스테이지 빌드, 로컬 검증 (docker-compose), Kubernetes 배포/스케일을 한 흐름으로 익힌다.</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>Docker/BuildKit, kubectl, Kubernetes 클러스터 (로컬 kind 또는 managed), Helm(Optional)</li><li>레지스트리 계정 (GHCR/ECR 등)</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>애플리케이션 코드 작성</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1> 1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2> 2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3> 3</a>
</span><span class=lnt id=hl-36-4><a class=lnlinks href=#hl-36-4> 4</a>
</span><span class=lnt id=hl-36-5><a class=lnlinks href=#hl-36-5> 5</a>
</span><span class=lnt id=hl-36-6><a class=lnlinks href=#hl-36-6> 6</a>
</span><span class=lnt id=hl-36-7><a class=lnlinks href=#hl-36-7> 7</a>
</span><span class=lnt id=hl-36-8><a class=lnlinks href=#hl-36-8> 8</a>
</span><span class=lnt id=hl-36-9><a class=lnlinks href=#hl-36-9> 9</a>
</span><span class=lnt id=hl-36-10><a class=lnlinks href=#hl-36-10>10</a>
</span><span class=lnt id=hl-36-11><a class=lnlinks href=#hl-36-11>11</a>
</span><span class=lnt id=hl-36-12><a class=lnlinks href=#hl-36-12>12</a>
</span><span class=lnt id=hl-36-13><a class=lnlinks href=#hl-36-13>13</a>
</span><span class=lnt id=hl-36-14><a class=lnlinks href=#hl-36-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># app/main.py — FastAPI 예제 (컨테이너 건강 체크/메트릭 포인트 포함)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.get</span><span class=p>(</span><span class=s2>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>root</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 컨테이너 환경변수에서 버전/환경 노출</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;service&#34;</span><span class=p>:</span> <span class=s2>&#34;hello-api&#34;</span><span class=p>,</span> <span class=s2>&#34;version&#34;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>getenv</span><span class=p>(</span><span class=s2>&#34;APP_VERSION&#34;</span><span class=p>,</span> <span class=s2>&#34;dev&#34;</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.get</span><span class=p>(</span><span class=s2>&#34;/healthz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>health</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;ok&#34;</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>멀티스테이지 Dockerfile</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1> 1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2> 2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3> 3</a>
</span><span class=lnt id=hl-37-4><a class=lnlinks href=#hl-37-4> 4</a>
</span><span class=lnt id=hl-37-5><a class=lnlinks href=#hl-37-5> 5</a>
</span><span class=lnt id=hl-37-6><a class=lnlinks href=#hl-37-6> 6</a>
</span><span class=lnt id=hl-37-7><a class=lnlinks href=#hl-37-7> 7</a>
</span><span class=lnt id=hl-37-8><a class=lnlinks href=#hl-37-8> 8</a>
</span><span class=lnt id=hl-37-9><a class=lnlinks href=#hl-37-9> 9</a>
</span><span class=lnt id=hl-37-10><a class=lnlinks href=#hl-37-10>10</a>
</span><span class=lnt id=hl-37-11><a class=lnlinks href=#hl-37-11>11</a>
</span><span class=lnt id=hl-37-12><a class=lnlinks href=#hl-37-12>12</a>
</span><span class=lnt id=hl-37-13><a class=lnlinks href=#hl-37-13>13</a>
</span><span class=lnt id=hl-37-14><a class=lnlinks href=#hl-37-14>14</a>
</span><span class=lnt id=hl-37-15><a class=lnlinks href=#hl-37-15>15</a>
</span><span class=lnt id=hl-37-16><a class=lnlinks href=#hl-37-16>16</a>
</span><span class=lnt id=hl-37-17><a class=lnlinks href=#hl-37-17>17</a>
</span><span class=lnt id=hl-37-18><a class=lnlinks href=#hl-37-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Dockerfile — 멀티스테이지: 빌드 단계와 런타임 단계 분리</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>python:3.12-slim</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s>build</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app/ app/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pip install --upgrade pip <span class=o>&amp;&amp;</span> pip install fastapi uvicorn<span class=o>[</span>standard<span class=o>]</span> --target /install<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=w> </span><span class=s>python:3.12-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>PYTHONDONTWRITEBYTECODE</span><span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>PYTHONUNBUFFERED</span><span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>APP_VERSION</span><span class=o>=</span><span class=m>1</span>.0.0<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=w> </span><span class=s>/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>build /install /usr/local/lib/python3.12/site-packages<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app/ app/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=w> </span><span class=s>8080</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 비루트 사용자 권장</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> useradd -m appuser <span class=o>&amp;&amp;</span> chown -R appuser /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=w> </span><span class=s>appuser</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;python&#34;</span><span class=p>,</span> <span class=s2>&#34;-m&#34;</span><span class=p>,</span> <span class=s2>&#34;uvicorn&#34;</span><span class=p>,</span> <span class=s2>&#34;app.main:app&#34;</span><span class=p>,</span> <span class=s2>&#34;--host&#34;</span><span class=p>,</span> <span class=s2>&#34;0.0.0.0&#34;</span><span class=p>,</span> <span class=s2>&#34;--port&#34;</span><span class=p>,</span> <span class=s2>&#34;8080&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>로컬 docker-compose 검증</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1> 1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2> 2</a>
</span><span class=lnt id=hl-38-3><a class=lnlinks href=#hl-38-3> 3</a>
</span><span class=lnt id=hl-38-4><a class=lnlinks href=#hl-38-4> 4</a>
</span><span class=lnt id=hl-38-5><a class=lnlinks href=#hl-38-5> 5</a>
</span><span class=lnt id=hl-38-6><a class=lnlinks href=#hl-38-6> 6</a>
</span><span class=lnt id=hl-38-7><a class=lnlinks href=#hl-38-7> 7</a>
</span><span class=lnt id=hl-38-8><a class=lnlinks href=#hl-38-8> 8</a>
</span><span class=lnt id=hl-38-9><a class=lnlinks href=#hl-38-9> 9</a>
</span><span class=lnt id=hl-38-10><a class=lnlinks href=#hl-38-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># docker-compose.yml — 로컬 개발용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>api</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/your-org/hello-api:1.0.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;8080:8080&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>APP_VERSION=1.0.0</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1>1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2>2</a>
</span><span class=lnt id=hl-39-3><a class=lnlinks href=#hl-39-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 로컬 실행/검증</span>
</span></span><span class=line><span class=cl>docker compose up --build -d
</span></span><span class=line><span class=cl>curl http://localhost:8080/healthz
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>이미지 푸시 (예: GHCR)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1>1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2>2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker login ghcr.io
</span></span><span class=line><span class=cl>docker build -t ghcr.io/your-org/hello-api:1.0.0 .
</span></span><span class=line><span class=cl>docker push ghcr.io/your-org/hello-api:1.0.0
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Kubernetes 매니페스트 배포</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1> 1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2> 2</a>
</span><span class=lnt id=hl-41-3><a class=lnlinks href=#hl-41-3> 3</a>
</span><span class=lnt id=hl-41-4><a class=lnlinks href=#hl-41-4> 4</a>
</span><span class=lnt id=hl-41-5><a class=lnlinks href=#hl-41-5> 5</a>
</span><span class=lnt id=hl-41-6><a class=lnlinks href=#hl-41-6> 6</a>
</span><span class=lnt id=hl-41-7><a class=lnlinks href=#hl-41-7> 7</a>
</span><span class=lnt id=hl-41-8><a class=lnlinks href=#hl-41-8> 8</a>
</span><span class=lnt id=hl-41-9><a class=lnlinks href=#hl-41-9> 9</a>
</span><span class=lnt id=hl-41-10><a class=lnlinks href=#hl-41-10>10</a>
</span><span class=lnt id=hl-41-11><a class=lnlinks href=#hl-41-11>11</a>
</span><span class=lnt id=hl-41-12><a class=lnlinks href=#hl-41-12>12</a>
</span><span class=lnt id=hl-41-13><a class=lnlinks href=#hl-41-13>13</a>
</span><span class=lnt id=hl-41-14><a class=lnlinks href=#hl-41-14>14</a>
</span><span class=lnt id=hl-41-15><a class=lnlinks href=#hl-41-15>15</a>
</span><span class=lnt id=hl-41-16><a class=lnlinks href=#hl-41-16>16</a>
</span><span class=lnt id=hl-41-17><a class=lnlinks href=#hl-41-17>17</a>
</span><span class=lnt id=hl-41-18><a class=lnlinks href=#hl-41-18>18</a>
</span><span class=lnt id=hl-41-19><a class=lnlinks href=#hl-41-19>19</a>
</span><span class=lnt id=hl-41-20><a class=lnlinks href=#hl-41-20>20</a>
</span><span class=lnt id=hl-41-21><a class=lnlinks href=#hl-41-21>21</a>
</span><span class=lnt id=hl-41-22><a class=lnlinks href=#hl-41-22>22</a>
</span><span class=lnt id=hl-41-23><a class=lnlinks href=#hl-41-23>23</a>
</span><span class=lnt id=hl-41-24><a class=lnlinks href=#hl-41-24>24</a>
</span><span class=lnt id=hl-41-25><a class=lnlinks href=#hl-41-25>25</a>
</span><span class=lnt id=hl-41-26><a class=lnlinks href=#hl-41-26>26</a>
</span><span class=lnt id=hl-41-27><a class=lnlinks href=#hl-41-27>27</a>
</span><span class=lnt id=hl-41-28><a class=lnlinks href=#hl-41-28>28</a>
</span><span class=lnt id=hl-41-29><a class=lnlinks href=#hl-41-29>29</a>
</span><span class=lnt id=hl-41-30><a class=lnlinks href=#hl-41-30>30</a>
</span><span class=lnt id=hl-41-31><a class=lnlinks href=#hl-41-31>31</a>
</span><span class=lnt id=hl-41-32><a class=lnlinks href=#hl-41-32>32</a>
</span><span class=lnt id=hl-41-33><a class=lnlinks href=#hl-41-33>33</a>
</span><span class=lnt id=hl-41-34><a class=lnlinks href=#hl-41-34>34</a>
</span><span class=lnt id=hl-41-35><a class=lnlinks href=#hl-41-35>35</a>
</span><span class=lnt id=hl-41-36><a class=lnlinks href=#hl-41-36>36</a>
</span><span class=lnt id=hl-41-37><a class=lnlinks href=#hl-41-37>37</a>
</span><span class=lnt id=hl-41-38><a class=lnlinks href=#hl-41-38>38</a>
</span><span class=lnt id=hl-41-39><a class=lnlinks href=#hl-41-39>39</a>
</span><span class=lnt id=hl-41-40><a class=lnlinks href=#hl-41-40>40</a>
</span><span class=lnt id=hl-41-41><a class=lnlinks href=#hl-41-41>41</a>
</span><span class=lnt id=hl-41-42><a class=lnlinks href=#hl-41-42>42</a>
</span><span class=lnt id=hl-41-43><a class=lnlinks href=#hl-41-43>43</a>
</span><span class=lnt id=hl-41-44><a class=lnlinks href=#hl-41-44>44</a>
</span><span class=lnt id=hl-41-45><a class=lnlinks href=#hl-41-45>45</a>
</span><span class=lnt id=hl-41-46><a class=lnlinks href=#hl-41-46>46</a>
</span><span class=lnt id=hl-41-47><a class=lnlinks href=#hl-41-47>47</a>
</span><span class=lnt id=hl-41-48><a class=lnlinks href=#hl-41-48>48</a>
</span><span class=lnt id=hl-41-49><a class=lnlinks href=#hl-41-49>49</a>
</span><span class=lnt id=hl-41-50><a class=lnlinks href=#hl-41-50>50</a>
</span><span class=lnt id=hl-41-51><a class=lnlinks href=#hl-41-51>51</a>
</span><span class=lnt id=hl-41-52><a class=lnlinks href=#hl-41-52>52</a>
</span><span class=lnt id=hl-41-53><a class=lnlinks href=#hl-41-53>53</a>
</span><span class=lnt id=hl-41-54><a class=lnlinks href=#hl-41-54>54</a>
</span><span class=lnt id=hl-41-55><a class=lnlinks href=#hl-41-55>55</a>
</span><span class=lnt id=hl-41-56><a class=lnlinks href=#hl-41-56>56</a>
</span><span class=lnt id=hl-41-57><a class=lnlinks href=#hl-41-57>57</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># k8s/deployment.yaml — 리소스 요청/제한, 프로브 설정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/your-org/hello-api:1.0.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>APP_VERSION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1.0.0&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;100m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;128Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-42-1><a class=lnlinks href=#hl-42-1>1</a>
</span><span class=lnt id=hl-42-2><a class=lnlinks href=#hl-42-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f k8s/deployment.yaml
</span></span><span class=line><span class=cl>kubectl get pods,svc -l <span class=nv>app</span><span class=o>=</span>hello-api
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>오토스케일 (HPA) 추가</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-43-1><a class=lnlinks href=#hl-43-1> 1</a>
</span><span class=lnt id=hl-43-2><a class=lnlinks href=#hl-43-2> 2</a>
</span><span class=lnt id=hl-43-3><a class=lnlinks href=#hl-43-3> 3</a>
</span><span class=lnt id=hl-43-4><a class=lnlinks href=#hl-43-4> 4</a>
</span><span class=lnt id=hl-43-5><a class=lnlinks href=#hl-43-5> 5</a>
</span><span class=lnt id=hl-43-6><a class=lnlinks href=#hl-43-6> 6</a>
</span><span class=lnt id=hl-43-7><a class=lnlinks href=#hl-43-7> 7</a>
</span><span class=lnt id=hl-43-8><a class=lnlinks href=#hl-43-8> 8</a>
</span><span class=lnt id=hl-43-9><a class=lnlinks href=#hl-43-9> 9</a>
</span><span class=lnt id=hl-43-10><a class=lnlinks href=#hl-43-10>10</a>
</span><span class=lnt id=hl-43-11><a class=lnlinks href=#hl-43-11>11</a>
</span><span class=lnt id=hl-43-12><a class=lnlinks href=#hl-43-12>12</a>
</span><span class=lnt id=hl-43-13><a class=lnlinks href=#hl-43-13>13</a>
</span><span class=lnt id=hl-43-14><a class=lnlinks href=#hl-43-14>14</a>
</span><span class=lnt id=hl-43-15><a class=lnlinks href=#hl-43-15>15</a>
</span><span class=lnt id=hl-43-16><a class=lnlinks href=#hl-43-16>16</a>
</span><span class=lnt id=hl-43-17><a class=lnlinks href=#hl-43-17>17</a>
</span><span class=lnt id=hl-43-18><a class=lnlinks href=#hl-43-18>18</a>
</span><span class=lnt id=hl-43-19><a class=lnlinks href=#hl-43-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># k8s/hpa.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>autoscaling/v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>HorizontalPodAutoscaler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>scaleTargetRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-api</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>metrics</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-44-1><a class=lnlinks href=#hl-44-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f k8s/hpa.yaml
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>CI 파이프라인 예시 (GitHub Actions 요약)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-45-1><a class=lnlinks href=#hl-45-1> 1</a>
</span><span class=lnt id=hl-45-2><a class=lnlinks href=#hl-45-2> 2</a>
</span><span class=lnt id=hl-45-3><a class=lnlinks href=#hl-45-3> 3</a>
</span><span class=lnt id=hl-45-4><a class=lnlinks href=#hl-45-4> 4</a>
</span><span class=lnt id=hl-45-5><a class=lnlinks href=#hl-45-5> 5</a>
</span><span class=lnt id=hl-45-6><a class=lnlinks href=#hl-45-6> 6</a>
</span><span class=lnt id=hl-45-7><a class=lnlinks href=#hl-45-7> 7</a>
</span><span class=lnt id=hl-45-8><a class=lnlinks href=#hl-45-8> 8</a>
</span><span class=lnt id=hl-45-9><a class=lnlinks href=#hl-45-9> 9</a>
</span><span class=lnt id=hl-45-10><a class=lnlinks href=#hl-45-10>10</a>
</span><span class=lnt id=hl-45-11><a class=lnlinks href=#hl-45-11>11</a>
</span><span class=lnt id=hl-45-12><a class=lnlinks href=#hl-45-12>12</a>
</span><span class=lnt id=hl-45-13><a class=lnlinks href=#hl-45-13>13</a>
</span><span class=lnt id=hl-45-14><a class=lnlinks href=#hl-45-14>14</a>
</span><span class=lnt id=hl-45-15><a class=lnlinks href=#hl-45-15>15</a>
</span><span class=lnt id=hl-45-16><a class=lnlinks href=#hl-45-16>16</a>
</span><span class=lnt id=hl-45-17><a class=lnlinks href=#hl-45-17>17</a>
</span><span class=lnt id=hl-45-18><a class=lnlinks href=#hl-45-18>18</a>
</span><span class=lnt id=hl-45-19><a class=lnlinks href=#hl-45-19>19</a>
</span><span class=lnt id=hl-45-20><a class=lnlinks href=#hl-45-20>20</a>
</span><span class=lnt id=hl-45-21><a class=lnlinks href=#hl-45-21>21</a>
</span><span class=lnt id=hl-45-22><a class=lnlinks href=#hl-45-22>22</a>
</span><span class=lnt id=hl-45-23><a class=lnlinks href=#hl-45-23>23</a>
</span><span class=lnt id=hl-45-24><a class=lnlinks href=#hl-45-24>24</a>
</span><span class=lnt id=hl-45-25><a class=lnlinks href=#hl-45-25>25</a>
</span><span class=lnt id=hl-45-26><a class=lnlinks href=#hl-45-26>26</a>
</span><span class=lnt id=hl-45-27><a class=lnlinks href=#hl-45-27>27</a>
</span><span class=lnt id=hl-45-28><a class=lnlinks href=#hl-45-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># .github/workflows/build.yml — 빌드/푸시/취약점 스캔 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>build-and-push</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>push]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up QEMU</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/setup-qemu-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up Docker Buildx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/setup-buildx-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Login to GHCR</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/login-action@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>registry</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>username</span><span class=p>:</span><span class=w> </span><span class=l>${{ github.actor }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>password</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build &amp; Push</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>docker/build-push-action@v5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>push</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>tags</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/your-org/hello-api:${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Scan Image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>aquasecurity/trivy-action@master</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>image-ref</span><span class=p>:</span><span class=w> </span><span class=l>ghcr.io/your-org/hello-api:${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>format</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;table&#39;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li><code>/healthz</code> 200 OK, Deployment 2/2 Ready, HPA 동작 확인 (부하 시 Pod 수 증가).</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>멀티아키텍처 이미지 (<code>--platform linux/amd64,linux/arm64</code>), Cosign 서명/검증, Helm 차트화, 카나리아 배포 (Argo Rollouts).</li></ul><h5 id=실습-예제-간단한-웹서버-컨테이너-생성실행>실습 예제: 간단한 웹서버 컨테이너 생성/실행<a hidden class=anchor aria-hidden=true href=#실습-예제-간단한-웹서버-컨테이너-생성실행>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>컨테이너 이미지 생성, 실행 및 환경변수와 네트워크 구현 원리 체험</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>Docker 엔진 설치, bash 쉘, 파일 접근권한</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>이미지 빌드용 Dockerfile 작성</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-46-1><a class=lnlinks href=#hl-46-1>1</a>
</span><span class=lnt id=hl-46-2><a class=lnlinks href=#hl-46-2>2</a>
</span><span class=lnt id=hl-46-3><a class=lnlinks href=#hl-46-3>3</a>
</span><span class=lnt id=hl-46-4><a class=lnlinks href=#hl-46-4>4</a>
</span><span class=lnt id=hl-46-5><a class=lnlinks href=#hl-46-5>5</a>
</span><span class=lnt id=hl-46-6><a class=lnlinks href=#hl-46-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Python 웹서버(Flask) 이미지 예시
</span></span><span class=line><span class=cl>FROM python:3.8
</span></span><span class=line><span class=cl>RUN pip install flask
</span></span><span class=line><span class=cl>COPY app.py /app/app.py  # 주요 애플리케이션 복사
</span></span><span class=line><span class=cl>WORKDIR /app
</span></span><span class=line><span class=cl>CMD [&#34;python&#34;, &#34;app.py&#34;]
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>빌드 및 실행 명령</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-47-1><a class=lnlinks href=#hl-47-1>1</a>
</span><span class=lnt id=hl-47-2><a class=lnlinks href=#hl-47-2>2</a>
</span><span class=lnt id=hl-47-3><a class=lnlinks href=#hl-47-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker build -t myweb:latest .
</span></span><span class=line><span class=cl>docker run --name test1 -d -p 5000:5000 myweb:latest  # 기본 웹서버 실행
</span></span><span class=line><span class=cl>docker run --name test2 -d -e BGCOLOR=orange -p 5001:5000 myweb:latest  # 환경변수 활용 예시
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>상태 확인 및 정리</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-48-1><a class=lnlinks href=#hl-48-1>1</a>
</span><span class=lnt id=hl-48-2><a class=lnlinks href=#hl-48-2>2</a>
</span><span class=lnt id=hl-48-3><a class=lnlinks href=#hl-48-3>3</a>
</span><span class=lnt id=hl-48-4><a class=lnlinks href=#hl-48-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker ps -a                # 실행 컨테이너 목록 확인
</span></span><span class=line><span class=cl>docker stop test1 test2     # 컨테이너 중지
</span></span><span class=line><span class=cl>docker rm test1 test2       # 컨테이너 삭제
</span></span><span class=line><span class=cl>docker rmi myweb:latest     # 이미지 삭제
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>포트별 웹서버 배포, 환경변수에 따라 페이지 색상/동작 변화</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>볼륨 마운트, 네트워크 연결, 멀티 - 컨테이너 (docker-compose)</li></ul><h4 id=실제-도입-사례-분석>실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-왓챠-watcha-mlops-및-microservices-도입>실제 도입 사례: 왓챠 (Watcha) MLOps 및 Microservices 도입<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-왓챠-watcha-mlops-및-microservices-도입>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><ul><li>대규모 추천 시스템, AI 분석 워크로드를 빠르게 배포 및 확장하기 위함</li><li>기존 VM/서버 환경의 유지보수 비용, 배포 지연, 운영 자동화 한계 극복 목적</li></ul><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><ul><li>Kubernetes 오케스트레이션 기반 하이브리드 클라우드</li><li>컨테이너화된 서비스 (추천, 분석, 트래픽 분산) → 자동 배포, 오토스케일러</li><li>Kubeflow 로 머신러닝 파이프라인 및 모델 관리 체계화</li></ul><pre class=mermaid>graph TB
    A[사용자 요청] --&gt; B[&#34;API Gateway (Kubernetes Ingress)&#34;]
    B --&gt; C[추천 서비스 컨테이너]
    C --&gt; D[&#34;MLOps 파이프라인 (Kubeflow)&#34;]
    B --&gt; E[통합 모니터링 플랫폼]
    D --&gt; F[클라우드 스토리지 &amp; DB]
</pre><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-50-1><a class=lnlinks href=#hl-50-1> 1</a>
</span><span class=lnt id=hl-50-2><a class=lnlinks href=#hl-50-2> 2</a>
</span><span class=lnt id=hl-50-3><a class=lnlinks href=#hl-50-3> 3</a>
</span><span class=lnt id=hl-50-4><a class=lnlinks href=#hl-50-4> 4</a>
</span><span class=lnt id=hl-50-5><a class=lnlinks href=#hl-50-5> 5</a>
</span><span class=lnt id=hl-50-6><a class=lnlinks href=#hl-50-6> 6</a>
</span><span class=lnt id=hl-50-7><a class=lnlinks href=#hl-50-7> 7</a>
</span><span class=lnt id=hl-50-8><a class=lnlinks href=#hl-50-8> 8</a>
</span><span class=lnt id=hl-50-9><a class=lnlinks href=#hl-50-9> 9</a>
</span><span class=lnt id=hl-50-10><a class=lnlinks href=#hl-50-10>10</a>
</span><span class=lnt id=hl-50-11><a class=lnlinks href=#hl-50-11>11</a>
</span><span class=lnt id=hl-50-12><a class=lnlinks href=#hl-50-12>12</a>
</span><span class=lnt id=hl-50-13><a class=lnlinks href=#hl-50-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Kubeflow 기반 배포 예시 (실제 Watcha 내부 로직은 아니며, 구조 원리 설명)</span>
</span></span><span class=line><span class=cl><span class=c1># 파드 내 모델 추론 서비스 예시</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span><span class=p>,</span> <span class=n>request</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>joblib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=n>joblib</span><span class=o>.</span><span class=n>load</span><span class=p>(</span><span class=s2>&#34;model.pkl&#34;</span><span class=p>)</span>  <span class=c1># 불변 컨테이너 이미지 활용</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s2>&#34;/predict&#34;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;POST&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>json</span>
</span></span><span class=line><span class=cl>    <span class=n>pred</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>predict</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=s2>&#34;input&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;result&#34;</span><span class=p>:</span> <span class=n>pred</span><span class=o>.</span><span class=n>tolist</span><span class=p>()}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-51-1><a class=lnlinks href=#hl-51-1>1</a>
</span><span class=lnt id=hl-51-2><a class=lnlinks href=#hl-51-2>2</a>
</span><span class=lnt id=hl-51-3><a class=lnlinks href=#hl-51-3>3</a>
</span><span class=lnt id=hl-51-4><a class=lnlinks href=#hl-51-4>4</a>
</span><span class=lnt id=hl-51-5><a class=lnlinks href=#hl-51-5>5</a>
</span><span class=lnt id=hl-51-6><a class=lnlinks href=#hl-51-6>6</a>
</span><span class=lnt id=hl-51-7><a class=lnlinks href=#hl-51-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=c># Dockerfile 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>FROM python:3.9</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN pip install flask joblib scikit-learn</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY model.pkl /app/model.pkl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY app.py /app/app.py</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>WORKDIR /app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>CMD [&#34;python&#34;, &#34;app.py&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><ul><li>배포 시간 70% 단축, 모델 관리 자동화, 트래픽 증가 시 무중단 확장</li><li>운영비용≥30% 절감, 장애 격리 개선, 데이터 엔지니어 생산성 대폭 향상</li></ul><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><ul><li>컨테이너화는 MSA·AI·DevOps 통합에 필수이며, 자동화·관측성·거버넌스를 우선 설계하면 복잡성 리스크 감소</li><li>초기 마이그레이션과 트러블슈팅을 위한 체계적 컨테이너 설계, 모니터링 체계 수립 필수</li></ul><h5 id=실제-도입-사례-netflix-의-마이크로서비스-컨테이너화>실제 도입 사례: Netflix 의 마이크로서비스 컨테이너화<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-netflix-의-마이크로서비스-컨테이너화>#</a></h5><h6 id=배경-및-도입-이유-1>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유-1>#</a></h6><p>Netflix 는 2015 년부터 모놀리식 아키텍처에서 마이크로서비스로 전환하면서 컨테이너화를 도입했다.</p><p>전 세계 2 억 이상의 사용자에게 스트리밍 서비스를 제공하면서 다음과 같은 과제가 있었다:</p><ul><li><strong>확장성</strong>: 글로벌 트래픽 급증에 대한 탄력적 대응</li><li><strong>개발 속도</strong>: 수천 명의 개발자가 독립적으로 배포</li><li><strong>안정성</strong>: 99.9% 가용성 요구사항</li><li><strong>비용 효율성</strong>: 클라우드 리소스 최적 활용</li></ul><h6 id=구현-아키텍처-1>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-1>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;사용자&#34;
        A[모바일 앱]
        B[웹 브라우저]
        C[스마트 TV]
    end
    
    subgraph &#34;Edge/CDN&#34;
        D[CloudFront]
        E[Open Connect]
    end
    
    subgraph &#34;API Gateway&#34;
        F[Zuul Gateway]
    end
    
    subgraph &#34;마이크로서비스 (컨테이너화)&#34;
        G[사용자 서비스]
        H[콘텐츠 서비스]
        I[추천 서비스]
        J[결제 서비스]
        K[시청 기록 서비스]
    end
    
    subgraph &#34;데이터 계층&#34;
        L[Cassandra]
        M[Redis]
        N[S3]
    end
    
    subgraph &#34;인프라&#34;
        O[AWS ECS]
        P[Kubernetes]
        Q[Auto Scaling Groups]
    end
    
    A --&gt; D
    B --&gt; D
    C --&gt; E
    D --&gt; F
    E --&gt; F
    F --&gt; G
    F --&gt; H
    F --&gt; I
    F --&gt; J
    F --&gt; K
    G --&gt; L
    H --&gt; N
    I --&gt; M
    J --&gt; L
    K --&gt; L
    
    O --&gt; G
    O --&gt; H
    P --&gt; I
    P --&gt; J
    Q --&gt; K
</pre><h6 id=핵심-구현-코드-1>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드-1>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-53-1><a class=lnlinks href=#hl-53-1> 1</a>
</span><span class=lnt id=hl-53-2><a class=lnlinks href=#hl-53-2> 2</a>
</span><span class=lnt id=hl-53-3><a class=lnlinks href=#hl-53-3> 3</a>
</span><span class=lnt id=hl-53-4><a class=lnlinks href=#hl-53-4> 4</a>
</span><span class=lnt id=hl-53-5><a class=lnlinks href=#hl-53-5> 5</a>
</span><span class=lnt id=hl-53-6><a class=lnlinks href=#hl-53-6> 6</a>
</span><span class=lnt id=hl-53-7><a class=lnlinks href=#hl-53-7> 7</a>
</span><span class=lnt id=hl-53-8><a class=lnlinks href=#hl-53-8> 8</a>
</span><span class=lnt id=hl-53-9><a class=lnlinks href=#hl-53-9> 9</a>
</span><span class=lnt id=hl-53-10><a class=lnlinks href=#hl-53-10>10</a>
</span><span class=lnt id=hl-53-11><a class=lnlinks href=#hl-53-11>11</a>
</span><span class=lnt id=hl-53-12><a class=lnlinks href=#hl-53-12>12</a>
</span><span class=lnt id=hl-53-13><a class=lnlinks href=#hl-53-13>13</a>
</span><span class=lnt id=hl-53-14><a class=lnlinks href=#hl-53-14>14</a>
</span><span class=lnt id=hl-53-15><a class=lnlinks href=#hl-53-15>15</a>
</span><span class=lnt id=hl-53-16><a class=lnlinks href=#hl-53-16>16</a>
</span><span class=lnt id=hl-53-17><a class=lnlinks href=#hl-53-17>17</a>
</span><span class=lnt id=hl-53-18><a class=lnlinks href=#hl-53-18>18</a>
</span><span class=lnt id=hl-53-19><a class=lnlinks href=#hl-53-19>19</a>
</span><span class=lnt id=hl-53-20><a class=lnlinks href=#hl-53-20>20</a>
</span><span class=lnt id=hl-53-21><a class=lnlinks href=#hl-53-21>21</a>
</span><span class=lnt id=hl-53-22><a class=lnlinks href=#hl-53-22>22</a>
</span><span class=lnt id=hl-53-23><a class=lnlinks href=#hl-53-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=c># Netflix의 마이크로서비스 컨테이너 배포 예시 (단순화)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 서비스별 독립적 배포와 확장이 핵심</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Dockerfile 예시 - Netflix 스타일 최적화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>FROM openjdk:11-jre-slim </span><span class=w> </span><span class=c># Netflix는 주로 Java/Scala 기반 서비스</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 애플리케이션 메트릭 수집을 위한 에이전트 - 관측 가능성 확보</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY newrelic-agent.jar /opt/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY app.jar /opt/app.jar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Netflix의 서비스 디스커버리 Eureka 클라이언트 설정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENV EUREKA_CLIENT_ENABLED=true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENV SPRING_PROFILES_ACTIVE=production</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 컨테이너 최적화 JVM 옵션 - 메모리 효율성과 성능 최적화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENV JAVA_OPTS=&#34;-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -javaagent:/opt/newrelic-agent.jar&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 헬스체크와 그레이스풀 셧다운 - 무중단 배포 지원</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>HEALTHCHECK --interval=30s --timeout=10s --retries=3 \</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>CMD curl -f http://localhost:8080/health || exit 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>EXPOSE 8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>CMD [&#34;java&#34;, &#34;$JAVA_OPTS&#34;, &#34;-jar&#34;, &#34;/opt/app.jar&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-54-1><a class=lnlinks href=#hl-54-1> 1</a>
</span><span class=lnt id=hl-54-2><a class=lnlinks href=#hl-54-2> 2</a>
</span><span class=lnt id=hl-54-3><a class=lnlinks href=#hl-54-3> 3</a>
</span><span class=lnt id=hl-54-4><a class=lnlinks href=#hl-54-4> 4</a>
</span><span class=lnt id=hl-54-5><a class=lnlinks href=#hl-54-5> 5</a>
</span><span class=lnt id=hl-54-6><a class=lnlinks href=#hl-54-6> 6</a>
</span><span class=lnt id=hl-54-7><a class=lnlinks href=#hl-54-7> 7</a>
</span><span class=lnt id=hl-54-8><a class=lnlinks href=#hl-54-8> 8</a>
</span><span class=lnt id=hl-54-9><a class=lnlinks href=#hl-54-9> 9</a>
</span><span class=lnt id=hl-54-10><a class=lnlinks href=#hl-54-10>10</a>
</span><span class=lnt id=hl-54-11><a class=lnlinks href=#hl-54-11>11</a>
</span><span class=lnt id=hl-54-12><a class=lnlinks href=#hl-54-12>12</a>
</span><span class=lnt id=hl-54-13><a class=lnlinks href=#hl-54-13>13</a>
</span><span class=lnt id=hl-54-14><a class=lnlinks href=#hl-54-14>14</a>
</span><span class=lnt id=hl-54-15><a class=lnlinks href=#hl-54-15>15</a>
</span><span class=lnt id=hl-54-16><a class=lnlinks href=#hl-54-16>16</a>
</span><span class=lnt id=hl-54-17><a class=lnlinks href=#hl-54-17>17</a>
</span><span class=lnt id=hl-54-18><a class=lnlinks href=#hl-54-18>18</a>
</span><span class=lnt id=hl-54-19><a class=lnlinks href=#hl-54-19>19</a>
</span><span class=lnt id=hl-54-20><a class=lnlinks href=#hl-54-20>20</a>
</span><span class=lnt id=hl-54-21><a class=lnlinks href=#hl-54-21>21</a>
</span><span class=lnt id=hl-54-22><a class=lnlinks href=#hl-54-22>22</a>
</span><span class=lnt id=hl-54-23><a class=lnlinks href=#hl-54-23>23</a>
</span><span class=lnt id=hl-54-24><a class=lnlinks href=#hl-54-24>24</a>
</span><span class=lnt id=hl-54-25><a class=lnlinks href=#hl-54-25>25</a>
</span><span class=lnt id=hl-54-26><a class=lnlinks href=#hl-54-26>26</a>
</span><span class=lnt id=hl-54-27><a class=lnlinks href=#hl-54-27>27</a>
</span><span class=lnt id=hl-54-28><a class=lnlinks href=#hl-54-28>28</a>
</span><span class=lnt id=hl-54-29><a class=lnlinks href=#hl-54-29>29</a>
</span><span class=lnt id=hl-54-30><a class=lnlinks href=#hl-54-30>30</a>
</span><span class=lnt id=hl-54-31><a class=lnlinks href=#hl-54-31>31</a>
</span><span class=lnt id=hl-54-32><a class=lnlinks href=#hl-54-32>32</a>
</span><span class=lnt id=hl-54-33><a class=lnlinks href=#hl-54-33>33</a>
</span><span class=lnt id=hl-54-34><a class=lnlinks href=#hl-54-34>34</a>
</span><span class=lnt id=hl-54-35><a class=lnlinks href=#hl-54-35>35</a>
</span><span class=lnt id=hl-54-36><a class=lnlinks href=#hl-54-36>36</a>
</span><span class=lnt id=hl-54-37><a class=lnlinks href=#hl-54-37>37</a>
</span><span class=lnt id=hl-54-38><a class=lnlinks href=#hl-54-38>38</a>
</span><span class=lnt id=hl-54-39><a class=lnlinks href=#hl-54-39>39</a>
</span><span class=lnt id=hl-54-40><a class=lnlinks href=#hl-54-40>40</a>
</span><span class=lnt id=hl-54-41><a class=lnlinks href=#hl-54-41>41</a>
</span><span class=lnt id=hl-54-42><a class=lnlinks href=#hl-54-42>42</a>
</span><span class=lnt id=hl-54-43><a class=lnlinks href=#hl-54-43>43</a>
</span><span class=lnt id=hl-54-44><a class=lnlinks href=#hl-54-44>44</a>
</span><span class=lnt id=hl-54-45><a class=lnlinks href=#hl-54-45>45</a>
</span><span class=lnt id=hl-54-46><a class=lnlinks href=#hl-54-46>46</a>
</span><span class=lnt id=hl-54-47><a class=lnlinks href=#hl-54-47>47</a>
</span><span class=lnt id=hl-54-48><a class=lnlinks href=#hl-54-48>48</a>
</span><span class=lnt id=hl-54-49><a class=lnlinks href=#hl-54-49>49</a>
</span><span class=lnt id=hl-54-50><a class=lnlinks href=#hl-54-50>50</a>
</span><span class=lnt id=hl-54-51><a class=lnlinks href=#hl-54-51>51</a>
</span><span class=lnt id=hl-54-52><a class=lnlinks href=#hl-54-52>52</a>
</span><span class=lnt id=hl-54-53><a class=lnlinks href=#hl-54-53>53</a>
</span><span class=lnt id=hl-54-54><a class=lnlinks href=#hl-54-54>54</a>
</span><span class=lnt id=hl-54-55><a class=lnlinks href=#hl-54-55>55</a>
</span><span class=lnt id=hl-54-56><a class=lnlinks href=#hl-54-56>56</a>
</span><span class=lnt id=hl-54-57><a class=lnlinks href=#hl-54-57>57</a>
</span><span class=lnt id=hl-54-58><a class=lnlinks href=#hl-54-58>58</a>
</span><span class=lnt id=hl-54-59><a class=lnlinks href=#hl-54-59>59</a>
</span><span class=lnt id=hl-54-60><a class=lnlinks href=#hl-54-60>60</a>
</span><span class=lnt id=hl-54-61><a class=lnlinks href=#hl-54-61>61</a>
</span><span class=lnt id=hl-54-62><a class=lnlinks href=#hl-54-62>62</a>
</span><span class=lnt id=hl-54-63><a class=lnlinks href=#hl-54-63>63</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># Kubernetes 배포 설정 - Netflix의 오토 스케일링 전략</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>  </span><span class=c># 기본 인스턴스 수</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>netflix/recommendation-service:v1.2.3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c># 리소스 제한 - 멀티테넌시 환경에서 안정성 확보</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1Gi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2Gi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1000m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c># 서비스 발견과 설정 주입 - 마이크로서비스 연결성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>EUREKA_SERVER_URL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;http://eureka-server:8761/eureka&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>REDIS_URL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>secretKeyRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-credentials</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>url</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 수평 확장 설정 - 트래픽에 따른 자동 스케일링</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>autoscaling/v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>HorizontalPodAutoscaler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service-hpa</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>scaleTargetRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>recommendation-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>1000</span><span class=w>  </span><span class=c># Netflix 규모의 확장성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>metrics</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>70</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과-1>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과-1>#</a></h6><ul><li><strong>정량 지표</strong>:<ul><li>배포 시간: 45 분 → 15 분 (67% 단축)</li><li>서비스 가용성: 99.5% → 99.95% 향상</li><li>인프라 비용: 연간 30% 절감</li><li>개발 생산성: 배포 빈도 10 배 증가</li></ul></li><li><strong>정성 개선</strong>:<ul><li>개발팀 자율성 증대: 독립적 배포와 기술 스택 선택</li><li>장애 격리: 개별 서비스 장애가 전체 시스템에 미치는 영향 최소화</li><li>글로벌 확장: 리전별 독립적 스케일링</li></ul></li></ul><h6 id=교훈-및-시사점-1>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점-1>#</a></h6><ul><li><strong>카나리 배포 필수</strong>: 전체 트래픽의 1% 부터 점진적 확장</li><li><strong>서킷 브레이커 패턴</strong>: Hystrix 활용한 장애 전파 방지</li><li><strong>서비스 메시 도입</strong>: Istio 기반 마이크로서비스 간 통신 관리</li><li><strong>관측 가능성 투자</strong>: 분산 추적과 메트릭 수집 인프라 구축</li></ul><h4 id=컨테이너-통합연계-기술-종합-가이드>컨테이너 통합·연계 기술 종합 가이드<a hidden class=anchor aria-hidden=true href=#컨테이너-통합연계-기술-종합-가이드>#</a></h4><p>컨테이너 자체는 애플리케이션 포장 도구다.<br>실서비스로 운영하려면 <strong>빌드·이미지관리 (CI/CD·레지스트리) → 런타임 (K8s·containerd) → 네트워크/스토리지 (CNI/CSI) → 관측 (메트릭/로그/트레이스) → 보안 (이미지 스캔/서명·런타임 보호) → 데이터 플랫폼 (이벤트/스트리밍)</strong> 이 유기적으로 연계되어야 한다.<br>이 연계가 잘되면 배포 속도·신뢰성·보안·관측성이 모두 향상된다.</p><h5 id=컨테이너-통합연계-기술-분류>컨테이너 통합·연계 기술 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-통합연계-기술-분류>#</a></h5><h6 id=cicd--이미지-공급망>CI/CD · 이미지 공급망<a hidden class=anchor aria-hidden=true href=#cicd--이미지-공급망>#</a></h6><ul><li><strong>왜</strong>: 이미지의 신뢰성 확보 (재현성, 취약점 차단) 및 자동 배포를 위해 필수.</li><li><strong>무엇</strong>:<ul><li>빌드 (Builder/BuildKit/Buildpacks)</li><li>레지스트리 (Harbor/Artifactory/GCR)</li><li>스캔 (Trivy/Clair)</li><li>서명 (cosign)</li><li>SBOM(Syft).</li></ul></li><li><strong>어떻게</strong>:<ul><li>CI 파이프라인에서 빌드→스캔→서명→레지스트리 푸시를 연계.</li><li>레지스트리 웹훅으로 배포 트리거.</li><li>안전정책은 OPA/Gatekeeper 로 K8s 레벨에서 강제.</li></ul></li><li><strong>가치</strong>: 배포 신뢰성 증가, 취약점 사전 차단, 규정 준수 (SBOM) 지원.</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>빌드</td><td>BuildKit, Kaniko, Buildpacks</td><td style=text-align:right>CI (GitHub Actions / GitLab CI) 로 자동 빌드</td><td>재현 가능한 아티팩트</td></tr><tr><td>레지스트리</td><td>Harbor, GCR, ECR</td><td style=text-align:right>레지스트리 접근 정책, 레플리케이션</td><td>안정적 배포·캐싱</td></tr><tr><td>보안</td><td>Trivy, Clair, cosign, Syft</td><td style=text-align:right>CI 단계 스캔·서명, SBOM 생성</td><td>공급망 보안·규제 대응</td></tr><tr><td>정책</td><td>OPA/Gatekeeper</td><td style=text-align:right>Admission 컨트롤로 배포 차단</td><td>정책 준수 자동화</td></tr></tbody></table><ul><li>CI 파이프라인에서 " 빌드→스캔→서명→레지스트리 " 를 표준화하면 공급망 공격을 크게 줄이고 배포 안정성을 확보할 수 있다.</li></ul><h6 id=관측-모니터링로깅트레이싱>관측 (모니터링·로깅·트레이싱)<a hidden class=anchor aria-hidden=true href=#관측-모니터링로깅트레이싱>#</a></h6><ul><li><strong>왜</strong>: 분산된 컨테이너 환경에서 문제 원인 추적과 SLO 준수를 위해 필수.</li><li><strong>무엇</strong>:<ul><li>메트릭 (Prometheus)</li><li>시각화 (Grafana)</li><li>로깅 (Fluentd/Logstash/ELK)</li><li>트레이스 (OpenTelemetry, Jaeger)</li><li>알림 (PagerDuty).</li></ul></li><li><strong>어떻게</strong>:<ul><li>애플리케이션 및 인프라에서 표준 포맷 (OpenTelemetry) 으로 지표/트레이스를 수집하고 중앙 저장소에서 분석.</li><li>사이드카/DaemonSet 으로 로그·메트릭 수집기 배포.</li></ul></li><li><strong>가치</strong>: 장애 탐지·복구 시간 단축, 성능 최적화, SLO 기반 운영 가능.</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>메트릭</td><td>Prometheus</td><td style=text-align:right>Exporter → Push/Export → Alert</td><td>SLO 모니터링</td></tr><tr><td>로깅</td><td>Fluentd / Logstash / ELK</td><td style=text-align:right>로그 수집→중앙 저장→검색</td><td>포렌식·디버깅</td></tr><tr><td>트레이스</td><td>OpenTelemetry, Jaeger</td><td style=text-align:right>Trace context 전파 → 샘플링</td><td>분산 원인 분석</td></tr><tr><td>알림</td><td>PagerDuty, OpsGenie</td><td style=text-align:right>Alert → On-call 워크플로우</td><td>빠른 대응</td></tr></tbody></table><ul><li>관측 스택은 배포 초반부터 설계해야 운영 효율이 보장된다. 표준 (OpenTelemetry) 채택을 권장.</li></ul><h6 id=서비스-메시--api-게이트웨이>서비스 메시 · API 게이트웨이<a hidden class=anchor aria-hidden=true href=#서비스-메시--api-게이트웨이>#</a></h6><ul><li><strong>왜</strong>: 마이크로서비스 간 트래픽 제어·보안·관측을 일관되게 적용하려면 필요.</li><li><strong>무엇</strong>:<ul><li>서비스 메시 (Istio, Linkerd)</li><li>API 게이트웨이 (Kong, Ambassador, Kong, API Gateway),</li><li>Ingress Controller.</li></ul></li><li><strong>어떻게</strong>:<ul><li>사이드카 패턴 (서비스 메시) 으로 트래픽을 가로채 정책·암호화·관측을 적용.</li><li>API 게이트웨이는 인증·요청 라우팅·레이트리밋 수행.</li></ul></li><li><strong>가치</strong>: 보안 (서지·mTLS), 트래픽 제어 (캔리·A/B), 세분화된 관측 확보.</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>서비스 메시</td><td>Istio, Linkerd</td><td style=text-align:right>사이드카로 트래픽 가로채기</td><td>mTLS, 정책, 분산 추적</td></tr><tr><td>API GW</td><td>Kong, Ambassador</td><td style=text-align:right>인증·라우팅·CORS·RateLimit</td><td>외부 공개 API 관리</td></tr><tr><td>Ingress</td><td>Nginx-Ingress, Traefik</td><td style=text-align:right>Cluster 외부 진입점 관리</td><td>TLS·로드밸런싱</td></tr></tbody></table><ul><li>서비스 메시와 API GW 는 보안·관측·교체가능한 트래픽 제어 지점을 제공해 대규모 마이크로서비스 운영을 용이하게 한다.</li></ul><h6 id=시크릿키관리--보안-파이프라인>시크릿·키관리 · 보안 파이프라인<a hidden class=anchor aria-hidden=true href=#시크릿키관리--보안-파이프라인>#</a></h6><ul><li><strong>왜</strong>: 민감 정보 (토큰·키·DB 비밀번호) 를 안전하게 관리해야 권한 남용·노출 리스크를 줄일 수 있음.</li><li><strong>무엇</strong>:<ul><li>KMS(AWS KMS/GCP KMS)</li><li>HashiCorp Vault</li><li>Kubernetes Secrets(CSI Secrets Store)</li><li>이미지 서명 (cosign)</li><li>SBOM/SCA 툴</li></ul></li><li><strong>어떻게</strong>:<ul><li>CI 에서 비밀은 직접 저장하지 않고 KMS/Vault 로 주입 (권한 기반)</li><li>배포 시 CSI Secrets Store 로 마운트 또는 K8s Secret 로 주입</li><li>Admission 컨트롤로 비정상 이미지 차단.</li></ul></li><li><strong>가치</strong>: 시크릿 유출 리스크 감소, 감사·회전 (rotate) 정책 자동화.</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>KMS</td><td>AWS KMS, GCP KMS</td><td style=text-align:right>키 관리·암호화 API 연동</td><td>키 관리 자동화</td></tr><tr><td>시크릿 매니저</td><td>Vault, SealedSecrets</td><td style=text-align:right>런타임 주입 (Env/Volume)</td><td>노출 최소화</td></tr><tr><td>정책·스캔</td><td>cosign, Trivy, OPA</td><td style=text-align:right>CI/CD + Admission 연계</td><td>무결성·정책 준수</td></tr></tbody></table><ul><li>시크릿은 중앙 KMS/Vault 로 관리하고, 배포 시 최소 권한으로 주입하는 패턴이 안전하다.</li></ul><h6 id=메시징데이터-플랫폼-이벤트-스트리밍>메시징·데이터 플랫폼 (이벤트 스트리밍)<a hidden class=anchor aria-hidden=true href=#메시징데이터-플랫폼-이벤트-스트리밍>#</a></h6><ul><li><p><strong>왜</strong>: 실시간 이벤트 처리·데이터 파이프라인을 위해 필요. 컨테이너화된 서비스와의 통합으로 데이터 흐름을 자동화할 수 있음.</p></li><li><p><strong>무엇</strong>:</p><ul><li>Kafka</li><li>Pulsar</li><li>RabbitMQ</li><li>데이터 레이크 (Delta Lake, S3 기반)</li><li>CDC 도구 (Debezium) 등.</li></ul></li><li><p><strong>어떻게</strong>:</p><ul><li>서비스는 Kafka 클라이언트로 이벤트 발행·구독</li><li>StatefulSet/Operator 로 Kafka 운영</li><li>데이터 레이크는 배치·스트리밍 출력.</li><li>보안은 SASL/OAuth, TLS 로 보호.</li></ul></li><li><p><strong>가치</strong>: 실시간 처리, 시스템 간 결합도 완화 (이벤트 기반 아키텍처), 분석·ML 파이프라인 연계.</p></li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>스트리밍</td><td>Kafka, Pulsar</td><td style=text-align:right>클라이언트 라이브러리 연동</td><td>실시간 파이프라인</td></tr><tr><td>메시지 큐</td><td>RabbitMQ</td><td style=text-align:right>AMQP 연동</td><td>작업 분산</td></tr><tr><td>데이터 레이크</td><td>S3 / Delta Lake</td><td style=text-align:right>Sink Connector → 저장</td><td>분석·ML 활용</td></tr></tbody></table><ul><li>이벤트 스트리밍은 서비스 간 비동기 통합과 실시간 분석을 가능케 하므로, 컨테이너 앱의 데이터 흐름을 확장하는 핵심 축이다.</li></ul><h6 id=스토리지영속성-csi>스토리지·영속성 (CSI)<a hidden class=anchor aria-hidden=true href=#스토리지영속성-csi>#</a></h6><ul><li><strong>왜</strong>: 상태 저장 애플리케이션 (데이터베이스, 메시지 브로커) 은 영속 스토리지가 필요.</li><li><strong>무엇</strong>:<ul><li>CSI 표준</li><li>Rook/Ceph</li><li>Longhorn</li><li>EBS/GCE PD</li><li>NFS</li><li>StatefulSet 패턴.</li></ul></li><li><strong>어떻게</strong>:<ul><li>StorageClass/Provisioner(CSI) 로 PV 동적 생성→PVC 바인딩→Pod 마운트.</li><li>백업은 Velero 등으로 관리.</li></ul></li><li><strong>가치</strong>: 상태 기반 서비스의 안정적 운영, 복구·스냅샷·확장 지원.</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>블록/퍼시스턴트</td><td>EBS / GCE PD</td><td style=text-align:right>CSI 드라이버 → PV/PVC</td><td>빠른 I/O</td></tr><tr><td>분산 FS</td><td>Ceph(Rook), Longhorn</td><td style=text-align:right>StatefulSet + Operator</td><td>고가용·복제</td></tr><tr><td>백업</td><td>Velero</td><td style=text-align:right>스냅샷·복구 워크플로우</td><td>재해 복구</td></tr></tbody></table><ul><li>상태 저장은 CSI + StatefulSet + 백업·복구로 설계해야 운영 중 데이터 손실을 막을 수 있다.</li></ul><h6 id=오케스트레이션플랫폼-연계-k8smanaged>오케스트레이션·플랫폼 연계 (K8s·Managed)<a hidden class=anchor aria-hidden=true href=#오케스트레이션플랫폼-연계-k8smanaged>#</a></h6><ul><li><strong>왜</strong>: 컨테이너의 대규모 배포·셀프힐·스케일링은 오케스트레이션이 핵심. 또한 Managed 서비스는 운영 비용을 낮춘다.</li><li><strong>무엇</strong>:<ul><li>Kubernetes</li><li>OpenShift</li><li>Nomad</li><li>클라우드 매니지드 (EKS/GKE/AKS) 등.</li></ul></li><li><strong>어떻게</strong>:<ul><li>K8s API 와 CRD/Operator 패턴으로 위의 모든 요소 (CSI, CNI, 관측, 보안) 를 통합·자동화.</li><li>GitOps(ArgoCD) 로 선언적 배포.</li></ul></li><li><strong>가치</strong>: 자동화·확장·운영 표준화, 운영 비용 절감 (Managed).</li></ul><table><thead><tr><th>기술 영역</th><th>기술 예</th><th style=text-align:right>연계 방식</th><th>획득 가치</th></tr></thead><tbody><tr><td>오케스트레이터</td><td>Kubernetes, Nomad</td><td style=text-align:right>API → CRD/Operator</td><td>스케일·셀프힐</td></tr><tr><td>매니지드 서비스</td><td>EKS, GKE, AKS</td><td style=text-align:right>클라우드 연동 서비스</td><td>운영 부담 경감</td></tr><tr><td>GitOps</td><td>ArgoCD, Flux</td><td style=text-align:right>선언적 배포 자동화</td><td>신뢰성 높은 릴리스</td></tr></tbody></table><ul><li>플랫폼은 모든 통합점의 허브다. 오케스트레이션을 중심으로 운영 정책·관측·보안이 적용된다.</li></ul><h5 id=컨테이너-통합-기술-맵-요약>컨테이너 통합 기술 맵 (요약)<a hidden class=anchor aria-hidden=true href=#컨테이너-통합-기술-맵-요약>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 목적</th><th>대표 기술</th><th>연계 포인트</th></tr></thead><tbody><tr><td>CI/CD · 이미지</td><td>신뢰성 있는 아티팩트 생성</td><td>BuildKit, Harbor, Trivy, cosign</td><td>CI 파이프라인 → 레지스트리 → K8s</td></tr><tr><td>관측</td><td>가시성·SLO 관리</td><td>Prometheus, Grafana, OTel, ELK</td><td>Exporter/Agent → 중앙 수집</td></tr><tr><td>서비스 메시·API GW</td><td>트래픽 제어·보안·관측</td><td>Istio, Linkerd, Kong</td><td>사이드카, Ingress</td></tr><tr><td>시크릿·KMS</td><td>민감정보 보호</td><td>Vault, AWS KMS, CSI Secrets</td><td>CI/CD + Runtime 주입</td></tr><tr><td>메시징·데이터</td><td>이벤트·데이터 파이프라인</td><td>Kafka, Pulsar, Debezium</td><td>Producers/Consumers, Connectors</td></tr><tr><td>스토리지 (CSI)</td><td>영속성 제공</td><td>Rook/Ceph, Longhorn, EBS</td><td>PV/PVC, StatefulSet</td></tr><tr><td>플랫폼·오케스트</td><td>배포·운영 허브</td><td>Kubernetes, ArgoCD, EKS</td><td>CRD/Operator, GitOps</td></tr></tbody></table><h3 id=운영-및-최적화>운영 및 최적화<a hidden class=anchor aria-hidden=true href=#운영-및-최적화>#</a></h3><h4 id=컨테이너-관측성-설계구축운영>컨테이너 관측성: 설계·구축·운영<a hidden class=anchor aria-hidden=true href=#컨테이너-관측성-설계구축운영>#</a></h4><p>컨테이너 환경 관측성은 세 가지 데이터로 이루어진다:</p><ul><li><strong>메트릭</strong>(숫자): 서버/컨테이너 자원과 요청률 같은 시계열 데이터—Prometheus 로 수집.</li><li><strong>로그</strong>(텍스트): 이벤트·에러 원본—Fluent Bit → Loki/ELK 로 중앙화.</li><li><strong>트레이스</strong>(추적): 요청의 호출 경로 (P95·P99 병목 파악)—OpenTelemetry → Jaeger.</li></ul><p>이 셋을 결합해 Grafana 에서 SLO 대시보드를 만들고, AlertManager 로 임계값을 감지하면 자동화 (스케일·복구) 를 트리거한다.<br>핵심은 <strong>정확한 지표 설계 (SLI/SLO)</strong> 와 <strong>경보의 품질 (노이즈 최소화)</strong> 이다.</p><h5 id=컨테이너-관측성-기능별-분류>컨테이너 관측성 기능별 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-관측성-기능별-분류>#</a></h5><h6 id=데이터-소스-수집-대상>데이터 소스 (수집 대상)<a hidden class=anchor aria-hidden=true href=#데이터-소스-수집-대상>#</a></h6><ul><li><p><strong>정의</strong>: 관측의 원천 (메트릭·로그·트레이스·이벤트).</p></li><li><p><strong>구성요소</strong>:</p><ul><li>인프라: Node Exporter (노드 CPU/디스크), cAdvisor (컨테이너 리소스), kube-state-metrics (K8s 상태)</li><li>애플리케이션: 애플리케이션 메트릭 (HTTP latency, error count), logs, traces (OpenTelemetry)</li><li>네트워크/서비스 메시: Envoy metrics, CNI 통계</li></ul></li><li><p><strong>수집 빈도/중요도</strong>:</p><ul><li>인프라·컨테이너 메트릭: 5–15s 스크랩 권장</li><li>비즈니스 메트릭: 10–60s (use-case dependent)</li><li>트레이스: 샘플링 (예: 1-10% 기본, 퍼포먼스 문제 시 더 높여 분석)</li></ul></li></ul><table><thead><tr><th>소스</th><th>툴/Exporter</th><th style=text-align:right>주요 데이터</th><th style=text-align:right>권장 빈도</th></tr></thead><tbody><tr><td>노드</td><td>node-exporter</td><td style=text-align:right>CPU, mem, disk, network</td><td style=text-align:right>10s</td></tr><tr><td>컨테이너</td><td>cAdvisor</td><td style=text-align:right>container cpu/mem/io</td><td style=text-align:right>10s</td></tr><tr><td>k8s 상태</td><td>kube-state-metrics</td><td style=text-align:right>pod status, deployments</td><td style=text-align:right>30s</td></tr><tr><td>앱 메트릭</td><td>client libs (Prom client)</td><td style=text-align:right>latency, qps, errors</td><td style=text-align:right>10–30s</td></tr><tr><td>로그</td><td>Fluent Bit/Fluentd</td><td style=text-align:right>structured logs</td><td style=text-align:right>streaming</td></tr><tr><td>트레이스</td><td>OpenTelemetry</td><td style=text-align:right>spans, traces</td><td style=text-align:right>sampled (1–10%)</td></tr></tbody></table><p>관측은 **다층적 (노드→플랫폼→앱)**이며 각 소스별 적절한 수집 빈도·샘플링이 필요하다.</p><h6 id=수집저장-인프라-스택-구성요소>수집·저장 인프라 (스택 구성요소)<a hidden class=anchor aria-hidden=true href=#수집저장-인프라-스택-구성요소>#</a></h6><ul><li><p><strong>핵심 구성</strong>: Prometheus(수집) + remote_write(장기저장: Thanos/Cortex/Mimir) + Loki(로그) + OpenTelemetry/Jaeger(추적) + AlertManager + Grafana.</p></li><li><p><strong>운영 고려</strong>: Prometheus 는 로컬 시계열 DB 로 빠르지만 장기 보관·수평확장은 remote_write 로 해결. 로그는 인덱스·저장소 비용을 고려해 라우팅/파싱·샘플링 필요.</p></li></ul><table><thead><tr><th>역할</th><th>대표 툴</th><th style=text-align:right>비고</th></tr></thead><tbody><tr><td>시계열 수집</td><td>Prometheus</td><td style=text-align:right>pull 기반, 빠른 쿼리</td></tr><tr><td>장기 보관</td><td>Thanos/Cortex/Mimir</td><td style=text-align:right>글로벌 쿼리, 장기 보관</td></tr><tr><td>로그 수집</td><td>Fluent Bit → Loki/ELK</td><td style=text-align:right>라벨/파싱 중요</td></tr><tr><td>분산 추적</td><td>OpenTelemetry → Jaeger/Tempo</td><td style=text-align:right>trace-id 연계</td></tr><tr><td>알림</td><td>AlertManager</td><td style=text-align:right>라우팅·silence 관리</td></tr></tbody></table><p>수집·저장 계층은 성능·비용·가용성 요구에 맞춰 설계해야 하며, remote_write 아키텍처는 필수적이다.</p><h6 id=관측-설계-메트릭레이블slo알림>관측 설계 (메트릭·레이블·SLO·알림)<a hidden class=anchor aria-hidden=true href=#관측-설계-메트릭레이블slo알림>#</a></h6><ul><li><p><strong>메트릭 설계 원칙</strong>:</p><ul><li>의미있는 메트릭 네이밍 (<code>service_request_duration_seconds_bucket</code>)</li><li>낮은 레이블 카디널리티</li><li>유의미한 라벨 (서비스, env, region)</li><li>histogram 사용 권장 (P95/P99 계산).</li></ul></li><li><p><strong>SLO/SLI</strong>:</p><ul><li>SLI(예: 성공률, 응답시간 p95) 정의 → SLO(예: 99.9% 응답시간 &lt; 500ms) 설정 → Error budget 정책 (라이프사이클, burn rate 알림).</li></ul></li><li><p><strong>알림 정책</strong>: 임계값 (Warning/Critical), 그룹화, 재현성 검증, 복구/자동조치 매핑.</p></li></ul><table><thead><tr><th>항목</th><th>권장사항</th><th>이유</th></tr></thead><tbody><tr><td>네이밍</td><td>Prometheus 관례 준수</td><td>일관된 쿼리·대시보드</td></tr><tr><td>라벨</td><td>서비스·env·zone 만</td><td>카드 증가 억제</td></tr><tr><td>Histogram</td><td>latency buckets 사용</td><td>Pxx 계산 용이</td></tr><tr><td>SLO</td><td>SLI → SLO → Error budget</td><td>운영 의사결정 기준</td></tr><tr><td>Alert</td><td>multi-stage(Warning→Critical)</td><td>노이즈 감소</td></tr></tbody></table><p>좋은 관측은 **데이터 설계 (SLI/SLO 포함)**에서 시작하며, 그에 맞춘 알림 설계가 운영 품질을 만든다.</p><h6 id=시각화대시보드분석>시각화·대시보드·분석<a hidden class=anchor aria-hidden=true href=#시각화대시보드분석>#</a></h6><ul><li><strong>대시보드 구성</strong>: 개요 대시 (클러스터 상태), 서비스별 SLO 대시 (오류·지연), 인프라 대시 (노드 포화), 인시던트 뷰 (알림 + 관련 로그/trace 연계).</li><li><strong>분석 워크플로우</strong>: 알림 발생 → 관련 메트릭 드릴다운 → trace/로그 연계 → 원인 파악 → 복구·포스트모템.</li></ul><table><thead><tr><th>대시보드 유형</th><th>핵심 위젯</th><th>목적</th></tr></thead><tbody><tr><td>클러스터 개요</td><td>CPU/메모/Pod 상태</td><td>전체 상태 파악</td></tr><tr><td>서비스 퍼포먼스</td><td>P50/P95/P99, error rate</td><td>고객영향 파악</td></tr><tr><td>SLO 대시보드</td><td>SLO 달성률, Error Budget</td><td>비즈니스 관점</td></tr><tr><td>인시던트 뷰</td><td>Alerts + traces + logs</td><td>빠른 RCA</td></tr></tbody></table><p>대시보드는 <strong>운영자·개발자·비즈니스</strong> 각 관점에 맞춰 설계해야 효과적이다.</p><h6 id=운영자동화-연계-오토스케일인시던트>운영·자동화 연계 (오토스케일·인시던트)<a hidden class=anchor aria-hidden=true href=#운영자동화-연계-오토스케일인시던트>#</a></h6><ul><li><strong>자동화 예시</strong>: Prometheus Alert → webhook → autoscaler API(수평/수직 스케일) 또는 자동 휴리스틱 (예: CPU 지속 80% → scale).</li><li><strong>인시던트 프로세스</strong>: 알림 → 온콜 루트 지정 → Runbook 실행 (수동/자동) → 복구 후 Postmortem.</li><li><strong>검증</strong>: 자동 스케일링은 안전장치 (쿨다운, step-limit) 필요.</li></ul><table><thead><tr><th>자동화 유형</th><th>트리거</th><th>조치 예시</th></tr></thead><tbody><tr><td>오토스케일</td><td>CPU > threshold for X min</td><td>HPA scale up</td></tr><tr><td>자율 복구</td><td>pod crash looping</td><td>recreate / drain node</td></tr><tr><td>롤백</td><td>error rate spike during deploy</td><td>rollback via ArgoCD</td></tr></tbody></table><p>자동화는 복구속도 향상에 효과적이나 <strong>안전장치 (쿨다운·제한)</strong> 가 필수다.</p><h6 id=보안비용확장성-고려사항>보안·비용·확장성 고려사항<a hidden class=anchor aria-hidden=true href=#보안비용확장성-고려사항>#</a></h6><ul><li><strong>보안</strong>: 민감 로그 마스킹, 메트릭/로그 접근 권한 (RBAC), 전송 암호화 (OTLP/TLS).</li><li><strong>비용</strong>: 로그 인덱싱·장기 메트릭 저장 비용 관리 (샘플링·retention 설정).</li><li><strong>확장성</strong>: 수집기 부하 분산, Prometheus federation/remote_write, 로그 플루언트 샤딩.</li></ul><table><thead><tr><th>항목</th><th>위험</th><th>대응책</th></tr></thead><tbody><tr><td>민감데이터</td><td>PII 노출</td><td>마스킹·필터링</td></tr><tr><td>스토리지비용</td><td>장기보관 비용</td><td>샘플링·retention 정책</td></tr><tr><td>수집 부하</td><td>스크랩 폭주</td><td>federation/샤딩</td></tr></tbody></table><p>관측성은 <strong>데이터량이 폭증</strong>하므로 보안·비용·확장성 정책을 미리 설계해야 한다.</p><h5 id=컨테이너-관측성-통합-요약표>컨테이너 관측성 통합 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-관측성-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 구성요소</th><th>목적</th><th>운영 팁</th></tr></thead><tbody><tr><td>데이터 소스</td><td>node-exporter, cAdvisor, app metrics, logs, traces</td><td>신호 수집 (노드→앱)</td><td>적절한 빈도·샘플링 설정</td></tr><tr><td>수집·저장 인프라</td><td>Prometheus, Thanos/Cortex, Loki, OTel</td><td>수집·장기보관</td><td>remote_write 로 확장</td></tr><tr><td>관측 설계</td><td>metric naming, labels, SLO, alerts</td><td>신뢰성 있는 모니터링</td><td>낮은 레이블 카디널리티</td></tr><tr><td>시각화·분석</td><td>Grafana, Jaeger, Kibana</td><td>인시던트 탐지·RCA</td><td>SLO 대시보드 우선</td></tr><tr><td>자동화 연계</td><td>AlertManager, Webhook, HPA</td><td>자동 스케일/복구</td><td>쿨다운·제한 설정</td></tr><tr><td>보안·비용</td><td>RBAC, 마스킹, retention</td><td>안전·비용관리</td><td>샘플링·정책화</td></tr></tbody></table><h4 id=컨테이너-보안컴플라이언스-전주기>컨테이너 보안·컴플라이언스 전주기<a hidden class=anchor aria-hidden=true href=#컨테이너-보안컴플라이언스-전주기>#</a></h4><p>컨테이너 보안·컴플라이언스는 <strong>빌드 (이미지·SBOM·서명) → 배포 (레지스트리 스캔·admission 정책) → 런타임 (seccomp/LSM·런타임 탐지) → 네트워크·접근 제어 → 감사·증적 보관</strong>의 전 (全) 수명주기 파이프라인을 자동화해 위협을 차단하고 규제를 충족시키는 과정이다.<br>핵심 도구로는 Trivy/Grype(스캔), syft(SBOM), cosign+Rekor(서명·투명성), OPA/Kyverno(정책), Falco(런타임 탐지), Calico/Cilium/Istio(네트워크) 등이 쓰이며, 모든 단계에서 자동검증과 로그 보관이 필수다.</p><h5 id=컨테이너-보안컴플라이언스-핵심영역>컨테이너 보안·컴플라이언스 핵심영역<a hidden class=anchor aria-hidden=true href=#컨테이너-보안컴플라이언스-핵심영역>#</a></h5><h6 id=이미지공급망-보안>이미지·공급망 보안<a hidden class=anchor aria-hidden=true href=#이미지공급망-보안>#</a></h6><p>이미지 취약점 스캐닝 (Trivy/Grype), SBOM(SPDX/CycloneDX) 생성 (syft), 이미지 서명 (cosign) 과 투명성 로그 (Rekor) 를 결합해 " 출처·구성·무결성 " 을 보장한다.<br>CI 파이프라인에서 자동화하고 레지스트리·admission 에서 검증한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>이미지 보안</td><td>취약 이미지, 공급망 변조</td><td>SBOM, 서명, 스캔</td><td style=text-align:right>syft, cosign, Trivy, Rekor</td><td>SBOM 존재·서명 검증, 취약점 임계값</td></tr><tr><td>공급망 투명성</td><td>빌드 위변조</td><td>투명성 로그·attestation</td><td style=text-align:right>Rekor, in-toto</td><td>Rekor 기록·attestation 일치</td></tr></tbody></table><ul><li>이미지 보안은 빌드부터 레지스트리까지 자동화된 증빙과 검증이 핵심이며, 서명 + 투명성 로그는 배포 신뢰도를 보장한다.</li></ul><h6 id=런타임-보안격리>런타임 보안·격리<a hidden class=anchor aria-hidden=true href=#런타임-보안격리>#</a></h6><p>컨테이너 특성상 커널을 공유하므로 seccomp/SELinux/AppArmor, capabilities 제거, rootless 실행, 필요시 gVisor/Kata 같은 경량 VM 격리를 병행한다.<br>Falco 로 행위 기반 탐지를 하며, 이상 시 자동 대응 (쿠버네티스 이벤트/알람) 을 구성한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>런타임 보안</td><td>컨테이너 탈출, 권한 상승</td><td>seccomp, LSM, rootless, VM 격리</td><td style=text-align:right>seccomp, SELinux, gVisor, Kata, Falco</td><td>seccomp 프로파일 적용, Falco 탐지 룰</td></tr></tbody></table><ul><li>런타임 보안은 예방 (LSM/seccomp) + 탐지 (Falco) 조합으로 설계하며, 민감 워크로드는 추가 VM 격리를 고려한다.</li></ul><h6 id=네트워크-보안>네트워크 보안<a hidden class=anchor aria-hidden=true href=#네트워크-보안>#</a></h6><p>CNI 네트워크 정책 (네임스페이스·레이블 기반), 서비스 메시 (mTLS) 로 서비스 간 통신을 암호화·정책 적용한다. egress 제어로 외부 데이터 유출을 차단한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>네트워크 보안</td><td>무단 통신, 데이터 유출</td><td>네트워크 정책, mTLS, egress 필터</td><td style=text-align:right>Calico, Cilium, Istio</td><td>정책 커버리지, mTLS 적용률, egress 로그</td></tr></tbody></table><ul><li><pre><code>네트워크는 ‘정책으로 최소권한 통신’을 강제하고, 서비스 메시로 암호화·관측을 더해 데이터 유출 위험을 낮춘다.
</code></pre></li></ul><h6 id=접근권한-관리>접근·권한 관리<a hidden class=anchor aria-hidden=true href=#접근권한-관리>#</a></h6><p>Kubernetes RBAC, OIDC SSO 연동, 서비스 어카운트 관리로 API·리소스 접근을 세분화하고 최소권한 원칙을 적용한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>권한 관리</td><td>무단 API 호출, 권한 남용</td><td>RBAC, OIDC, 네임스페이스 분리</td><td style=text-align:right>K8s RBAC, OpenID, AWS IAM</td><td>권한 스코프 최소화, 정기 권한 검토</td></tr></tbody></table><ul><li><pre><code>접근 통제는 사람과 서비스 모두에 대해 최소권한·주기적 검토·서비스계정 관리가 필수다.
</code></pre></li></ul><h6 id=정책배포-제어>정책·배포 제어<a hidden class=anchor aria-hidden=true href=#정책배포-제어>#</a></h6><p>배포 전 차단을 위해 OPA/Gatekeeper 또는 Kyverno 를 사용, 이미지 서명·SBOM·취약점 기준을 정책으로 강제한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>배포 제어</td><td>취약 이미지 배포</td><td>Admission 정책 (서명·SBOM·취약점)</td><td style=text-align:right>OPA/Gatekeeper, Kyverno</td><td>정책 위반 차단률, false positive 관리</td></tr></tbody></table><ul><li><pre><code>배포 파이프라인에서 '배포 전 차단'을 자동화하면 런타임 리스크를 근본적으로 낮출 수 있다.
</code></pre></li></ul><h6 id=모니터링감사컴플라이언스>모니터링·감사·컴플라이언스<a hidden class=anchor aria-hidden=true href=#모니터링감사컴플라이언스>#</a></h6><p>kube-audit, Fluentd/Prometheus + SIEM 연동, Rekor·SBOM 보관으로 사고조사와 규제증빙을 준비한다. 로그 무결성·보존정책과 자동 리포팅을 마련한다.</p><table><thead><tr><th>보안 계층</th><th>위협</th><th>보안 조치</th><th style=text-align:right>구현 도구</th><th>보안 체크포인트</th></tr></thead><tbody><tr><td>감사·컴플라이언스</td><td>증적 부재, 규제 불이행</td><td>감사 로그, 투명성 로그, SIEM</td><td style=text-align:right>kube-audit, Fluentd, ELK, Rekor</td><td>로그 보존·무결성, 규제 리포트 자동화</td></tr></tbody></table><ul><li><pre><code>감사·증적은 사고 대응과 규제 준수의 근거이므로 로그 무결성·장기 보관·검색성을 보장해야 한다.
</code></pre></li></ul><h5 id=컨테이너-보안컴플라이언스-요약표>컨테이너 보안·컴플라이언스 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-보안컴플라이언스-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 조치</th><th>주요 도구</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>이미지·공급망</td><td>SBOM·서명·스캔</td><td>syft, cosign, Trivy, Rekor</td><td>SBOM 존재·서명 검증, 취약점 SLA</td></tr><tr><td>런타임 보안</td><td>LSM·격리·탐지</td><td>seccomp, SELinux, gVisor, Falco</td><td>프로파일 적용·Falco 룰 검증</td></tr><tr><td>네트워크 보안</td><td>정책·mTLS·egress</td><td>Calico, Cilium, Istio</td><td>정책 커버리지·mTLS 적용률</td></tr><tr><td>접근 관리</td><td>RBAC·OIDC·SA</td><td>K8s RBAC, OIDC, IAM</td><td>권한 최소화·정기 감사</td></tr><tr><td>배포 제어</td><td>Admission 정책</td><td>OPA/Gatekeeper, Kyverno</td><td>정책 위반 차단률</td></tr><tr><td>감사·컴플라이언스</td><td>로그·투명성</td><td>kube-audit, ELK, Rekor</td><td>로그 보존·무결성·리포트</td></tr></tbody></table><h4 id=컨테이너-성능확장성-실행-가이드>컨테이너 성능·확장성 실행 가이드<a hidden class=anchor aria-hidden=true href=#컨테이너-성능확장성-실행-가이드>#</a></h4><p>성능 최적화는 애플리케이션 코드·컨테이너 이미지·컨테이너 리소스 설정·노드 인프라 (네트워크/스토리지) 모두를 함께 최적화해야 효과가 난다.<br>확장성은 파드 수준 (HPA/VPA), 클러스터 수준 (Cluster Autoscaler), 이벤트 수준 (KEDA) 을 적절히 결합하고, 안정성 (프로브·stabilization·PDB) 과 관측성 (신뢰 가능한 메트릭) 을 갖춰야 안전하게 자동화된다.</p><h5 id=컨테이너-성능확장성-핵심-카테고리>컨테이너 성능·확장성 핵심 카테고리<a hidden class=anchor aria-hidden=true href=#컨테이너-성능확장성-핵심-카테고리>#</a></h5><h6 id=이미지시작시간-최적화>이미지·시작시간 최적화<a hidden class=anchor aria-hidden=true href=#이미지시작시간-최적화>#</a></h6><p>이미지 경량화 (멀티스테이지), 레이어 캐시 전략, imagePullPolicy 와 레지스트리 캐시, cold start 완화 (프로브 지연/초기 워밍) 적용.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>멀티스테이지 빌드</td><td>BuildKit, multi-stage Dockerfile</td><td style=text-align:right>이미지 크기↓, 전송시간↓</td><td>빌드 복잡성 증가</td></tr><tr><td>레지스트리 캐시</td><td>Harbor/Registry proxy</td><td style=text-align:right>풀 속도 개선</td><td>캐시 일관성 고려</td></tr><tr><td>콜드 스타트 완화</td><td>readiness delay, warm-up</td><td style=text-align:right>사용자 영향 최소화</td><td>리소스 사용 증가</td></tr></tbody></table><ul><li>이미지를 작고 캐시 친화적으로 만들고, 레지스트리 캐시·초기 워밍으로 시작지연을 줄여라.</li></ul><h6 id=런타임리소스-관리-cpumemqos>런타임·리소스 관리 (CPU/Mem/QoS)<a hidden class=anchor aria-hidden=true href=#런타임리소스-관리-cpumemqos>#</a></h6><p>requests/limits 설정, QoS 클래스, JVM/언어별 container-awareness, cgroups v2 고려.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>requests/limits</td><td>측정 기반 지정</td><td style=text-align:right>안정적 스케줄링</td><td>과소/과대 배정 주의</td></tr><tr><td>QoS 등급</td><td>Guaranteed/Burstable</td><td style=text-align:right>OOM·스케줄 영향</td><td>Guaranteed 는 비용 증가</td></tr><tr><td>JVM 튜닝</td><td>container-aware flags</td><td style=text-align:right>예측 가능 메모리</td><td>GC 튜닝 필요</td></tr></tbody></table><ul><li>적절한 requests/limits 와 QoS 로 스케줄러/노드 행동을 제어하라.</li></ul><h6 id=네트워크-성능-최적화>네트워크 성능 최적화<a hidden class=anchor aria-hidden=true href=#네트워크-성능-최적화>#</a></h6><p>CNI 선택 (eBPF 기반 Cilium 권장), connection pooling, NodeLocal DNS, keep-alive, HTTP/2/gRPC 사용.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>CNI 선택</td><td>Cilium(eBPF) / Calico</td><td style=text-align:right>낮은 레이턴시·정책 성능</td><td>학습곡선 존재</td></tr><tr><td>커넥션 풀링</td><td>HTTP Keep-Alive, gRPC</td><td style=text-align:right>RTT·CPU 절감</td><td>커넥션 수 관리 필요</td></tr><tr><td>DNS 캐시</td><td>NodeLocal DNS</td><td style=text-align:right>DNS 레이턴시↓</td><td>캐시 일관성 관리</td></tr></tbody></table><ul><li>네트워크는 CNI + 커넥션 재사용으로 성능 향상, DNS·서비스 디스커버리 최적화 중요.</li></ul><h6 id=스토리지io-최적화>스토리지/IO 최적화<a hidden class=anchor aria-hidden=true href=#스토리지io-최적화>#</a></h6><p>스토리지 클래스 최적화, 로컬 SSD 사용, IOPS 기반 스케줄링, 캐시 레이어 적용.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>StorageClass 매칭</td><td>provisioned IOPS</td><td style=text-align:right>I/O 병목 완화</td><td>비용 고려</td></tr><tr><td>로컬 캐시</td><td>Redis/Local FS cache</td><td style=text-align:right>지연 감소</td><td>데이터 일관성 고민</td></tr><tr><td>CSI 드라이버 튜닝</td><td>IOPS/throughput 설정</td><td style=text-align:right>안정화</td><td>플랫폼 의존성</td></tr></tbody></table><ul><li>스토리지 클래스와 캐시 전략으로 I/O 병목을 완화하라.</li></ul><h6 id=자동확장오케스트레이션>자동확장·오케스트레이션<a hidden class=anchor aria-hidden=true href=#자동확장오케스트레이션>#</a></h6><p>HPA(V2), VPA, Cluster Autoscaler, KEDA, stabilization 정책, scheduled scaling.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>HPA (multi-metric)</td><td>Prometheus adapter, KEDA</td><td style=text-align:right>자동 파드 확장</td><td>메트릭 품질 중요</td></tr><tr><td>Cluster Autoscaler</td><td>node pool scaling</td><td style=text-align:right>노드 용량 탄력</td><td>spin-up 지연 고려</td></tr><tr><td>VPA</td><td>권장/자동 적용</td><td style=text-align:right>리소스 최적화</td><td>충돌 가능 (스케일 전략과)</td></tr></tbody></table><ul><li>파드·노드·이벤트 기반 스케일을 조합해 확장 정책을 설계하라.</li></ul><h6 id=분산배치가용성-정책>분산·배치·가용성 정책<a hidden class=anchor aria-hidden=true href=#분산배치가용성-정책>#</a></h6><p>affinity/anti-affinity, topologySpreadConstraints, PodDisruptionBudget, PodPriority.</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>topologySpread</td><td>topologySpreadConstraints</td><td style=text-align:right>고가용성 확보</td><td>제약과 스케줄률 영향</td></tr><tr><td>PDB</td><td>minAvailable 설정</td><td style=text-align:right>유지보수 중 가용성</td><td>과도한 제한 주의</td></tr><tr><td>affinity</td><td>node/pod affinity</td><td style=text-align:right>성능·규제 맞춤 배치</td><td>복잡성 증가</td></tr></tbody></table><ul><li>배치 정책으로 장애 도메인 분산·유지보수 안전성 확보.</li></ul><h6 id=g-관측성테스트자동화>G. 관측성·테스트·자동화<a hidden class=anchor aria-hidden=true href=#g-관측성테스트자동화>#</a></h6><p>모니터링 (Prometheus), 분산 트레이싱, 로깅, 부하테스트·카오스, 자동 롤백 (Argo Rollouts).</p><table><thead><tr><th>항목</th><th>구현 방법</th><th style=text-align:right>효과</th><th>주의사항</th></tr></thead><tbody><tr><td>모니터링</td><td>Prometheus + Alertmanager</td><td style=text-align:right>SLI/SLO 확인</td><td>메트릭 정의 중요</td></tr><tr><td>로깅</td><td>Fluentd/ELK</td><td style=text-align:right>문제 조사</td><td>저장비용 고려</td></tr><tr><td>부하/카오스</td><td>k6, Chaos Mesh</td><td style=text-align:right>리스크 확인</td><td>실환경 적용 주의</td></tr></tbody></table><ul><li>신뢰할 수 있는 메트릭과 테스트 파이프라인 없이는 자동확장·자동화가 위험하다.</li></ul><h5 id=성능확장성-핵심-요약표>성능·확장성 핵심 요약표<a hidden class=anchor aria-hidden=true href=#성능확장성-핵심-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 기법</th><th style=text-align:right>핵심 효과</th><th>우선 적용 포인트</th></tr></thead><tbody><tr><td>이미지·시작시간</td><td>멀티스테이지, 캐시</td><td style=text-align:right>시작시간 단축</td><td>빌드 파이프라인 적용</td></tr><tr><td>런타임·리소스</td><td>requests/limits, QoS</td><td style=text-align:right>안정적 스케줄링</td><td>측정 기반 설정</td></tr><tr><td>네트워크</td><td>CNI(eBPF), keep-alive</td><td style=text-align:right>레이턴시·처리량 개선</td><td>CNI 선정·DNS 캐시</td></tr><tr><td>스토리지</td><td>Provisioned IOPS, 로컬 캐시</td><td style=text-align:right>I/O 병목 해소</td><td>StorageClass 설계</td></tr><tr><td>자동확장</td><td>HPA/VPA/CA/KEDA</td><td style=text-align:right>탄력적 처리량 확보</td><td>메트릭 신뢰성 확보</td></tr><tr><td>배치·가용성</td><td>affinity, PDB, spread</td><td style=text-align:right>장애격리·가용성 보장</td><td>배치 규칙 설계</td></tr><tr><td>관측·테스트</td><td>Prometheus, k6, Chaos</td><td style=text-align:right>안정성 검증</td><td>SLO 기반 알람 설계</td></tr></tbody></table><h5 id=자동-확장-설정-예시>자동 확장 설정: 예시<a hidden class=anchor aria-hidden=true href=#자동-확장-설정-예시>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-55-1><a class=lnlinks href=#hl-55-1> 1</a>
</span><span class=lnt id=hl-55-2><a class=lnlinks href=#hl-55-2> 2</a>
</span><span class=lnt id=hl-55-3><a class=lnlinks href=#hl-55-3> 3</a>
</span><span class=lnt id=hl-55-4><a class=lnlinks href=#hl-55-4> 4</a>
</span><span class=lnt id=hl-55-5><a class=lnlinks href=#hl-55-5> 5</a>
</span><span class=lnt id=hl-55-6><a class=lnlinks href=#hl-55-6> 6</a>
</span><span class=lnt id=hl-55-7><a class=lnlinks href=#hl-55-7> 7</a>
</span><span class=lnt id=hl-55-8><a class=lnlinks href=#hl-55-8> 8</a>
</span><span class=lnt id=hl-55-9><a class=lnlinks href=#hl-55-9> 9</a>
</span><span class=lnt id=hl-55-10><a class=lnlinks href=#hl-55-10>10</a>
</span><span class=lnt id=hl-55-11><a class=lnlinks href=#hl-55-11>11</a>
</span><span class=lnt id=hl-55-12><a class=lnlinks href=#hl-55-12>12</a>
</span><span class=lnt id=hl-55-13><a class=lnlinks href=#hl-55-13>13</a>
</span><span class=lnt id=hl-55-14><a class=lnlinks href=#hl-55-14>14</a>
</span><span class=lnt id=hl-55-15><a class=lnlinks href=#hl-55-15>15</a>
</span><span class=lnt id=hl-55-16><a class=lnlinks href=#hl-55-16>16</a>
</span><span class=lnt id=hl-55-17><a class=lnlinks href=#hl-55-17>17</a>
</span><span class=lnt id=hl-55-18><a class=lnlinks href=#hl-55-18>18</a>
</span><span class=lnt id=hl-55-19><a class=lnlinks href=#hl-55-19>19</a>
</span><span class=lnt id=hl-55-20><a class=lnlinks href=#hl-55-20>20</a>
</span><span class=lnt id=hl-55-21><a class=lnlinks href=#hl-55-21>21</a>
</span><span class=lnt id=hl-55-22><a class=lnlinks href=#hl-55-22>22</a>
</span><span class=lnt id=hl-55-23><a class=lnlinks href=#hl-55-23>23</a>
</span><span class=lnt id=hl-55-24><a class=lnlinks href=#hl-55-24>24</a>
</span><span class=lnt id=hl-55-25><a class=lnlinks href=#hl-55-25>25</a>
</span><span class=lnt id=hl-55-26><a class=lnlinks href=#hl-55-26>26</a>
</span><span class=lnt id=hl-55-27><a class=lnlinks href=#hl-55-27>27</a>
</span><span class=lnt id=hl-55-28><a class=lnlinks href=#hl-55-28>28</a>
</span><span class=lnt id=hl-55-29><a class=lnlinks href=#hl-55-29>29</a>
</span><span class=lnt id=hl-55-30><a class=lnlinks href=#hl-55-30>30</a>
</span><span class=lnt id=hl-55-31><a class=lnlinks href=#hl-55-31>31</a>
</span><span class=lnt id=hl-55-32><a class=lnlinks href=#hl-55-32>32</a>
</span><span class=lnt id=hl-55-33><a class=lnlinks href=#hl-55-33>33</a>
</span><span class=lnt id=hl-55-34><a class=lnlinks href=#hl-55-34>34</a>
</span><span class=lnt id=hl-55-35><a class=lnlinks href=#hl-55-35>35</a>
</span><span class=lnt id=hl-55-36><a class=lnlinks href=#hl-55-36>36</a>
</span><span class=lnt id=hl-55-37><a class=lnlinks href=#hl-55-37>37</a>
</span><span class=lnt id=hl-55-38><a class=lnlinks href=#hl-55-38>38</a>
</span><span class=lnt id=hl-55-39><a class=lnlinks href=#hl-55-39>39</a>
</span><span class=lnt id=hl-55-40><a class=lnlinks href=#hl-55-40>40</a>
</span><span class=lnt id=hl-55-41><a class=lnlinks href=#hl-55-41>41</a>
</span><span class=lnt id=hl-55-42><a class=lnlinks href=#hl-55-42>42</a>
</span><span class=lnt id=hl-55-43><a class=lnlinks href=#hl-55-43>43</a>
</span><span class=lnt id=hl-55-44><a class=lnlinks href=#hl-55-44>44</a>
</span><span class=lnt id=hl-55-45><a class=lnlinks href=#hl-55-45>45</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># 고급 HPA 설정 - 다중 메트릭 기반 확장</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>autoscaling/v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>HorizontalPodAutoscaler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>advanced-hpa</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>scaleTargetRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>web-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>          </span><span class=c># 최소 인스턴스 - 기본 가용성 보장</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>100</span><span class=w>        </span><span class=c># 최대 인스턴스 - 비용 제어</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>metrics</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>70</span><span class=w>   </span><span class=c># CPU 70% 시 확장 - 성능 마진 확보</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>   </span><span class=c># 메모리 80% 시 확장 - OOM 방지</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Pods</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>pods</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>metric</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>http_requests_per_second</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>AverageValue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageValue</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;100&#34;</span><span class=w>      </span><span class=c># 초당 요청 100개 기준 - 사용자 경험 보장</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>behavior</span><span class=p>:</span><span class=w>                      </span><span class=c># 확장/축소 속도 제어 - 불필요한 스케일링 방지</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>scaleUp</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>stabilizationWindowSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>policies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Percent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=m>100</span><span class=w>             </span><span class=c># 한 번에 최대 100% 확장</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>15</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>scaleDown</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>stabilizationWindowSeconds</span><span class=p>:</span><span class=w> </span><span class=m>300</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>policies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Percent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>              </span><span class=c># 한 번에 최대 10% 축소 - 안정성 우선</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=컨테이너-장애-대응트러블슈팅-가이드>컨테이너 장애 대응·트러블슈팅 가이드<a hidden class=anchor aria-hidden=true href=#컨테이너-장애-대응트러블슈팅-가이드>#</a></h4><p>컨테이너 장애는 대체로 <strong>이미지/설정/리소스/네트워크/스토리지</strong> 중 하나에서 발생한다.<br>해결은 로그와 이벤트로 원인을 좁히고 (예: <code>kubectl describe pod</code>, <code>kubectl logs --previous</code>), 그 원인에 맞춰 즉시 (이미지 secret 추가, 리소스 조정, 프로브 튜닝) 조치한 뒤, 재발 방지를 위해 프로브·리소스 템플릿·레지스트리 인증·스토리지 정책을 표준화한다.</p><h5 id=컨테이너-문제-분류와-해결법>컨테이너 문제 분류와 해결법<a hidden class=anchor aria-hidden=true href=#컨테이너-문제-분류와-해결법>#</a></h5><h6 id=시작--실행-문제>시작 / 실행 문제<a hidden class=anchor aria-hidden=true href=#시작--실행-문제>#</a></h6><p><strong>설명</strong>:</p><ul><li>컨테이너가 정상적으로 시작되지 않거나 반복 재시작 (CrashLoopBackOff) 되는 경우.</li></ul><p><strong>왜 발생하는가 (원인)</strong>:</p><ul><li>애플리케이션 오류 (런타임 예외, missing dependency)</li><li>잘못된 Command/Entrypoint / 잘못된 환경변수</li><li>프로브 (liveness/readiness) 설정 오류로 정상 컨테이너 강제 재시작</li><li>이미지가 pull 되지 않음 (인증, 네트워크, 이미지 존재 여부)</li></ul><p><strong>진단 (우선순위 명령어)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-56-1><a class=lnlinks href=#hl-56-1>1</a>
</span><span class=lnt id=hl-56-2><a class=lnlinks href=#hl-56-2>2</a>
</span><span class=lnt id=hl-56-3><a class=lnlinks href=#hl-56-3>3</a>
</span><span class=lnt id=hl-56-4><a class=lnlinks href=#hl-56-4>4</a>
</span><span class=lnt id=hl-56-5><a class=lnlinks href=#hl-56-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get pods -o wide
</span></span><span class=line><span class=cl>kubectl describe pod &lt;pod&gt;        <span class=c1># 이벤트와 상태</span>
</span></span><span class=line><span class=cl>kubectl logs &lt;pod&gt; -c &lt;container&gt; <span class=c1># 현재 로그</span>
</span></span><span class=line><span class=cl>kubectl logs &lt;pod&gt; --previous     <span class=c1># 이전 인스턴스 로그</span>
</span></span><span class=line><span class=cl>kubectl get events --sort-by<span class=o>=</span>.metadata.creationTimestamp
</span></span></code></pre></td></tr></table></div></div><p><strong>즉시 조치 (빠른 해결)</strong>:</p><ul><li>로그에서 에러 메시지 (스택트레이스) 확인 → 애플리케이션 문제라면 이미지 수정 후 재배포</li><li>프로브가 원인일 경우 (예: liveness 가 너무 엄격) 임시로 프로브 비활성화 또는 타임아웃 증가</li><li>이미지 Pull 문제라면 <code>imagePullSecrets</code> 설정·레지스트리 접근 확인</li></ul><p><strong>예시—CrashLoopBackOff (안티 → 개선)</strong><br>Bad (프로브가 너무 빨리 체크):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-57-1><a class=lnlinks href=#hl-57-1>1</a>
</span><span class=lnt id=hl-57-2><a class=lnlinks href=#hl-57-2>2</a>
</span><span class=lnt id=hl-57-3><a class=lnlinks href=#hl-57-3>3</a>
</span><span class=lnt id=hl-57-4><a class=lnlinks href=#hl-57-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w> </span>{<span class=w> </span><span class=nt>path: /health, port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w> </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Fix (여유 부여):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-58-1><a class=lnlinks href=#hl-58-1>1</a>
</span><span class=lnt id=hl-58-2><a class=lnlinks href=#hl-58-2>2</a>
</span><span class=lnt id=hl-58-3><a class=lnlinks href=#hl-58-3>3</a>
</span><span class=lnt id=hl-58-4><a class=lnlinks href=#hl-58-4>4</a>
</span><span class=lnt id=hl-58-5><a class=lnlinks href=#hl-58-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w> </span>{<span class=w> </span><span class=nt>path: /health, port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w> </span>}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>예방</strong>:</p><ul><li>애플리케이션 스타트업 경로 (초기화 지점) 테스트, readiness/liveness 표준 템플릿 적용, CI 에서 컨테이너 실행 검증.</li></ul><h6 id=리소스성능-문제>리소스·성능 문제<a hidden class=anchor aria-hidden=true href=#리소스성능-문제>#</a></h6><p><strong>설명</strong>:</p><ul><li>OOMKilled, CPU Throttle, 심한 레이턴시, 스로틀링 등 성능 관련 이슈.</li></ul><p><strong>왜 발생하는가 (원인)</strong>:</p><ul><li>메모리/CPU limits 미설정 또는 과소 설정 → OOM 발생</li><li>요청 (requests) 미설정 → 스케줄러가 과다 배치 → 노드 압력</li><li>cgroups / kubelet 리미트로 CPU throttling 발생</li><li>언어 런타임 (GC) 설정 부적절</li></ul><p><strong>진단 (명령어/지표)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-59-1><a class=lnlinks href=#hl-59-1>1</a>
</span><span class=lnt id=hl-59-2><a class=lnlinks href=#hl-59-2>2</a>
</span><span class=lnt id=hl-59-3><a class=lnlinks href=#hl-59-3>3</a>
</span><span class=lnt id=hl-59-4><a class=lnlinks href=#hl-59-4>4</a>
</span><span class=lnt id=hl-59-5><a class=lnlinks href=#hl-59-5>5</a>
</span><span class=lnt id=hl-59-6><a class=lnlinks href=#hl-59-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl describe pod &lt;pod&gt;            <span class=c1># OOMKilled 표기</span>
</span></span><span class=line><span class=cl>kubectl get pods -o<span class=o>=</span><span class=nv>jsonpath</span><span class=o>=</span><span class=s1>&#39;{..status.containerStatuses[*].state}&#39;</span> 
</span></span><span class=line><span class=cl>kubectl top pod &lt;pod&gt;                 <span class=c1># 리소스 사용 실시간</span>
</span></span><span class=line><span class=cl>kubectl top node
</span></span><span class=line><span class=cl>kubectl logs &lt;pod&gt; <span class=p>|</span> grep -i <span class=s2>&#34;OutOfMemoryError&#34;</span>
</span></span><span class=line><span class=cl>dmesg <span class=p>|</span> grep -i oom                   <span class=c1># 노드-level OOM</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>즉시 조치</strong>:</p><ul><li>메모리 limits 증가 또는 메모리 leak 확인 (프로파일링)</li><li>CPU throttling 이면 limits 를 상향하거나 QoS 조정 (Guaranteed 로 만들기 위해 requests==limits 설정)</li><li>긴 GC 시간 확인 시 힙 사이즈/GC 파라미터 튜닝 (예: JVM <code>-Xmx</code>)</li><li>긴 처리 작업은 배치 처리·큐잉으로 전환</li></ul><p><strong>예시—OOMKilled 대응 매니페스트</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-60-1><a class=lnlinks href=#hl-60-1>1</a>
</span><span class=lnt id=hl-60-2><a class=lnlinks href=#hl-60-2>2</a>
</span><span class=lnt id=hl-60-3><a class=lnlinks href=#hl-60-3>3</a>
</span><span class=lnt id=hl-60-4><a class=lnlinks href=#hl-60-4>4</a>
</span><span class=lnt id=hl-60-5><a class=lnlinks href=#hl-60-5>5</a>
</span><span class=lnt id=hl-60-6><a class=lnlinks href=#hl-60-6>6</a>
</span><span class=lnt id=hl-60-7><a class=lnlinks href=#hl-60-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;250m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>예방</strong>:</p><ul><li>리소스 프로파일링 (로드 테스트), Node allocatable·pod density 산정, HPA/VPA 정책 적용, 알림 (Raise when P95 memory > limit*0.8).</li></ul><h6 id=네트워크--레지스트리-문제>네트워크 · 레지스트리 문제<a hidden class=anchor aria-hidden=true href=#네트워크--레지스트리-문제>#</a></h6><p><strong>설명</strong>:</p><ul><li>이미지 pull 실패, 서비스 디스커버리 실패, DNS 오류, 외부 API 호출 실패.</li></ul><p><strong>왜 발생하는가 (원인)</strong>:</p><ul><li>이미지 레지스트리 접속 불가 (인증/방화벽/프록시)</li><li>클러스터 DNS(CoreDNS) 장애 또는 MTU 불일치로 인한 패킷 분절</li><li>NetworkPolicy 로 인해 통신 차단</li><li>Ingress/Service 설정 오류</li></ul><p><strong>진단 (명령어)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-61-1><a class=lnlinks href=#hl-61-1>1</a>
</span><span class=lnt id=hl-61-2><a class=lnlinks href=#hl-61-2>2</a>
</span><span class=lnt id=hl-61-3><a class=lnlinks href=#hl-61-3>3</a>
</span><span class=lnt id=hl-61-4><a class=lnlinks href=#hl-61-4>4</a>
</span><span class=lnt id=hl-61-5><a class=lnlinks href=#hl-61-5>5</a>
</span><span class=lnt id=hl-61-6><a class=lnlinks href=#hl-61-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl describe pod &lt;pod&gt;            <span class=c1># ImagePullBackOff event</span>
</span></span><span class=line><span class=cl>kubectl get events <span class=p>|</span> grep ImagePull
</span></span><span class=line><span class=cl>kubectl <span class=nb>exec</span> -it &lt;pod&gt; -- nslookup &lt;service&gt; <span class=o>||</span> dig @&lt;dns&gt; &lt;name&gt;
</span></span><span class=line><span class=cl>kubectl <span class=nb>exec</span> -it &lt;pod&gt; -- curl -v http://&lt;svc&gt;:&lt;port&gt;
</span></span><span class=line><span class=cl>kubectl get networkpolicy --all-namespaces
</span></span><span class=line><span class=cl>kubectl logs -n kube-system coredns-xxxxx
</span></span></code></pre></td></tr></table></div></div><p><strong>즉시 조치</strong>:</p><ul><li>이미지 Pull: <code>kubectl create secret docker-registry …</code> 로 <code>imagePullSecrets</code> 추가</li><li>DNS: CoreDNS 재시작, 로그 확인, ConfigMap 튜닝 (cache, forward)</li><li>MTU 이슈: calico/overlay MTU 맞추기 (노드/SLB/VPNTunnel)</li><li>NetworkPolicy: 임시 허용 규칙 적용 후 점진 제한</li></ul><p><strong>예시—imagePullSecret 적용</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-62-1><a class=lnlinks href=#hl-62-1>1</a>
</span><span class=lnt id=hl-62-2><a class=lnlinks href=#hl-62-2>2</a>
</span><span class=lnt id=hl-62-3><a class=lnlinks href=#hl-62-3>3</a>
</span><span class=lnt id=hl-62-4><a class=lnlinks href=#hl-62-4>4</a>
</span><span class=lnt id=hl-62-5><a class=lnlinks href=#hl-62-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl create secret docker-registry regcred <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-server<span class=o>=</span>registry.example.com <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-username<span class=o>=</span>user <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-password<span class=o>=</span>pass <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-email<span class=o>=</span>you@example.com
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Pod 에 추가:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-63-1><a class=lnlinks href=#hl-63-1>1</a>
</span><span class=lnt id=hl-63-2><a class=lnlinks href=#hl-63-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>imagePullSecrets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>regcred</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>예방</strong>:</p><ul><li>레지스트리 헬스 체크·리전 캐시 (프록시), CoreDNS 모니터링, NetworkPolicy 테스트 스위트.</li></ul><h6 id=스토리지--볼륨-문제>스토리지 · 볼륨 문제<a hidden class=anchor aria-hidden=true href=#스토리지--볼륨-문제>#</a></h6><p><strong>설명</strong>:</p><ul><li>PVC 바인딩 실패, 권한 문제로 인한 마운트 에러, 파일시스템 불일치.</li></ul><p><strong>왜 발생하는가 (원인)</strong></p><ul><li>StorageClass misconfiguration, dynamic provisioning 실패</li><li>권한 (SELinux, fsGroup), volumeMode 차이 (Block vs Filesystem)</li><li>노드에 스토리지 드라이버 누락</li></ul><p><strong>진단 (명령어)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-64-1><a class=lnlinks href=#hl-64-1>1</a>
</span><span class=lnt id=hl-64-2><a class=lnlinks href=#hl-64-2>2</a>
</span><span class=lnt id=hl-64-3><a class=lnlinks href=#hl-64-3>3</a>
</span><span class=lnt id=hl-64-4><a class=lnlinks href=#hl-64-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get pvc
</span></span><span class=line><span class=cl>kubectl describe pvc &lt;pvc&gt;
</span></span><span class=line><span class=cl>kubectl describe pv &lt;pv&gt;
</span></span><span class=line><span class=cl>kubectl logs -n kube-system csi-&lt;plugin&gt;   <span class=c1># CSI 드라이버 로그</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>즉시 조치</strong>:</p><ul><li>PVC 이벤트 확인 → StorageClass 확인 및 CSI 재시작</li><li>권한 문제라면 <code>securityContext.fsGroup</code> 또는 Pod 의 <code>runAsUser</code> 조정</li><li>노드에 드라이버 설치 누락이면 해당 노드에 설치/재등록</li></ul><p><strong>예시—fsGroup 사용</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-65-1><a class=lnlinks href=#hl-65-1>1</a>
</span><span class=lnt id=hl-65-2><a class=lnlinks href=#hl-65-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>fsGroup</span><span class=p>:</span><span class=w> </span><span class=m>1000</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>예방</strong>:</p><ul><li>스토리지 프로비저닝 가이드, 권한 템플릿, DR 테스트 (restore 테스트) 정기 수행.</li></ul><h6 id=관측진단-도구기법>관측·진단 (도구·기법)<a hidden class=anchor aria-hidden=true href=#관측진단-도구기법>#</a></h6><p><strong>설명</strong>:</p><ul><li>문제 원인 추적을 돕는 도구·기법: 로그, 메트릭, 이벤트, 트레이스, node-level 진단.</li></ul><p><strong>권장 도구/기법</strong>:</p><ul><li><code>kubectl logs</code>, <code>kubectl describe</code>, <code>kubectl top</code>, node <code>dmesg</code>, <code>journalctl</code></li><li>중앙관측: Prometheus(메트릭), Grafana(대시보드), Loki/ELK(로그), Jaeger/Zipkin(트레이스)</li><li>Debug 컨테이너 (예: <code>kubectl debug</code> 또는 ephemeral debug pod)</li><li>Chaos testing(정기 장애 주입) 으로 복구 시나리오 검증</li></ul><p><strong>즉시 사용 예</strong>:</p><ul><li>문제 발생 시: <code>kubectl logs --previous</code> → <code>kubectl describe</code> → <code>kubectl exec</code> 로 내부 확인 → 메트릭/트레이스로 상관관계 탐색</li></ul><p><strong>예방</strong>:</p><ul><li>로그·메트릭 샘플링·보관 정책, SLO/Alert 정의, runbook 작성 및 주기적 DR 리허설.</li></ul><h5 id=컨테이너-문제-진단해결-요약표>컨테이너 문제 진단·해결 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-문제-진단해결-요약표>#</a></h5><table><thead><tr><th>분류</th><th>대표 증상</th><th>주요 원인</th><th>즉시 진단 명령어</th><th>즉시 조치</th><th>예방</th></tr></thead><tbody><tr><td>시작/실행</td><td>CrashLoopBackOff, Exit 코드</td><td>프로브/앱 예외/이미지 pull 실패</td><td>kubectl describe pod / kubectl logs &ndash;previous</td><td>프로브 완화, 이미지 교체, imagePullSecrets 추가</td><td>CI 검증, readiness/liveness 표준</td></tr><tr><td>리소스</td><td>OOMKilled, CPU Throttle</td><td>메모리 누수/limit 낮음, cgroups</td><td>kubectl top, dmesg</td><td>limits 상향, GC 튜닝, HPA/VPA</td><td>프로파일링, QoS 보장</td></tr><tr><td>네트워크</td><td>ImagePullBackOff, DNS 오류</td><td>인증/네트워크/MTU/CoreDNS</td><td>kubectl describe pod, nslookup, curl</td><td>imagePullSecret 적용, CoreDNS 재시작, MTU 조정</td><td>레지스트리 캐시, DNS 모니터</td></tr><tr><td>스토리지</td><td>PVC 바인딩 실패, permission denied</td><td>StorageClass/CSI, fsGroup</td><td>kubectl describe pvc/pv, CSI logs</td><td>스토리지 설정, fsGroup 적용, 드라이버 설치</td><td>스토리지 권한 템플릿, 복구 테스트</td></tr><tr><td>관측·진단</td><td>로그 부족, 느린 원인파악</td><td>로그 샘플링/보관 부족</td><td>kubectl logs, Prometheus/Grafana</td><td>로그 레벨 올림, 임시 리텐션 증가</td><td>중앙 관측, SLO/Alert 정의</td></tr></tbody></table><p>문제 해결은 <strong>빠른 원인 축소 (로그·이벤트)</strong> → <strong>임시 완화 조치 (프로브/리소스/레지스트리)</strong> → <strong>근본 수정 (코드/이미지/인프라)</strong> 의 흐름을 지켜야 한다. 관측과 정책 (리소스·프로브·레지스트리 인증) 을 미리 표준화하면 평균 MTTR 과 재발률을 크게 낮출 수 있다.</p><h5 id=리소스프로브-템플릿>리소스·프로브 템플릿<a hidden class=anchor aria-hidden=true href=#리소스프로브-템플릿>#</a></h5><p>아래는 <strong>웹 (Web)</strong>, <strong>API</strong>, <strong>배치 (Batch)</strong> 서비스 유형별로 실무에서 쓸 수 있게 정리한 <code>values.yaml</code> 템플릿이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-66-1><a class=lnlinks href=#hl-66-1>  1</a>
</span><span class=lnt id=hl-66-2><a class=lnlinks href=#hl-66-2>  2</a>
</span><span class=lnt id=hl-66-3><a class=lnlinks href=#hl-66-3>  3</a>
</span><span class=lnt id=hl-66-4><a class=lnlinks href=#hl-66-4>  4</a>
</span><span class=lnt id=hl-66-5><a class=lnlinks href=#hl-66-5>  5</a>
</span><span class=lnt id=hl-66-6><a class=lnlinks href=#hl-66-6>  6</a>
</span><span class=lnt id=hl-66-7><a class=lnlinks href=#hl-66-7>  7</a>
</span><span class=lnt id=hl-66-8><a class=lnlinks href=#hl-66-8>  8</a>
</span><span class=lnt id=hl-66-9><a class=lnlinks href=#hl-66-9>  9</a>
</span><span class=lnt id=hl-66-10><a class=lnlinks href=#hl-66-10> 10</a>
</span><span class=lnt id=hl-66-11><a class=lnlinks href=#hl-66-11> 11</a>
</span><span class=lnt id=hl-66-12><a class=lnlinks href=#hl-66-12> 12</a>
</span><span class=lnt id=hl-66-13><a class=lnlinks href=#hl-66-13> 13</a>
</span><span class=lnt id=hl-66-14><a class=lnlinks href=#hl-66-14> 14</a>
</span><span class=lnt id=hl-66-15><a class=lnlinks href=#hl-66-15> 15</a>
</span><span class=lnt id=hl-66-16><a class=lnlinks href=#hl-66-16> 16</a>
</span><span class=lnt id=hl-66-17><a class=lnlinks href=#hl-66-17> 17</a>
</span><span class=lnt id=hl-66-18><a class=lnlinks href=#hl-66-18> 18</a>
</span><span class=lnt id=hl-66-19><a class=lnlinks href=#hl-66-19> 19</a>
</span><span class=lnt id=hl-66-20><a class=lnlinks href=#hl-66-20> 20</a>
</span><span class=lnt id=hl-66-21><a class=lnlinks href=#hl-66-21> 21</a>
</span><span class=lnt id=hl-66-22><a class=lnlinks href=#hl-66-22> 22</a>
</span><span class=lnt id=hl-66-23><a class=lnlinks href=#hl-66-23> 23</a>
</span><span class=lnt id=hl-66-24><a class=lnlinks href=#hl-66-24> 24</a>
</span><span class=lnt id=hl-66-25><a class=lnlinks href=#hl-66-25> 25</a>
</span><span class=lnt id=hl-66-26><a class=lnlinks href=#hl-66-26> 26</a>
</span><span class=lnt id=hl-66-27><a class=lnlinks href=#hl-66-27> 27</a>
</span><span class=lnt id=hl-66-28><a class=lnlinks href=#hl-66-28> 28</a>
</span><span class=lnt id=hl-66-29><a class=lnlinks href=#hl-66-29> 29</a>
</span><span class=lnt id=hl-66-30><a class=lnlinks href=#hl-66-30> 30</a>
</span><span class=lnt id=hl-66-31><a class=lnlinks href=#hl-66-31> 31</a>
</span><span class=lnt id=hl-66-32><a class=lnlinks href=#hl-66-32> 32</a>
</span><span class=lnt id=hl-66-33><a class=lnlinks href=#hl-66-33> 33</a>
</span><span class=lnt id=hl-66-34><a class=lnlinks href=#hl-66-34> 34</a>
</span><span class=lnt id=hl-66-35><a class=lnlinks href=#hl-66-35> 35</a>
</span><span class=lnt id=hl-66-36><a class=lnlinks href=#hl-66-36> 36</a>
</span><span class=lnt id=hl-66-37><a class=lnlinks href=#hl-66-37> 37</a>
</span><span class=lnt id=hl-66-38><a class=lnlinks href=#hl-66-38> 38</a>
</span><span class=lnt id=hl-66-39><a class=lnlinks href=#hl-66-39> 39</a>
</span><span class=lnt id=hl-66-40><a class=lnlinks href=#hl-66-40> 40</a>
</span><span class=lnt id=hl-66-41><a class=lnlinks href=#hl-66-41> 41</a>
</span><span class=lnt id=hl-66-42><a class=lnlinks href=#hl-66-42> 42</a>
</span><span class=lnt id=hl-66-43><a class=lnlinks href=#hl-66-43> 43</a>
</span><span class=lnt id=hl-66-44><a class=lnlinks href=#hl-66-44> 44</a>
</span><span class=lnt id=hl-66-45><a class=lnlinks href=#hl-66-45> 45</a>
</span><span class=lnt id=hl-66-46><a class=lnlinks href=#hl-66-46> 46</a>
</span><span class=lnt id=hl-66-47><a class=lnlinks href=#hl-66-47> 47</a>
</span><span class=lnt id=hl-66-48><a class=lnlinks href=#hl-66-48> 48</a>
</span><span class=lnt id=hl-66-49><a class=lnlinks href=#hl-66-49> 49</a>
</span><span class=lnt id=hl-66-50><a class=lnlinks href=#hl-66-50> 50</a>
</span><span class=lnt id=hl-66-51><a class=lnlinks href=#hl-66-51> 51</a>
</span><span class=lnt id=hl-66-52><a class=lnlinks href=#hl-66-52> 52</a>
</span><span class=lnt id=hl-66-53><a class=lnlinks href=#hl-66-53> 53</a>
</span><span class=lnt id=hl-66-54><a class=lnlinks href=#hl-66-54> 54</a>
</span><span class=lnt id=hl-66-55><a class=lnlinks href=#hl-66-55> 55</a>
</span><span class=lnt id=hl-66-56><a class=lnlinks href=#hl-66-56> 56</a>
</span><span class=lnt id=hl-66-57><a class=lnlinks href=#hl-66-57> 57</a>
</span><span class=lnt id=hl-66-58><a class=lnlinks href=#hl-66-58> 58</a>
</span><span class=lnt id=hl-66-59><a class=lnlinks href=#hl-66-59> 59</a>
</span><span class=lnt id=hl-66-60><a class=lnlinks href=#hl-66-60> 60</a>
</span><span class=lnt id=hl-66-61><a class=lnlinks href=#hl-66-61> 61</a>
</span><span class=lnt id=hl-66-62><a class=lnlinks href=#hl-66-62> 62</a>
</span><span class=lnt id=hl-66-63><a class=lnlinks href=#hl-66-63> 63</a>
</span><span class=lnt id=hl-66-64><a class=lnlinks href=#hl-66-64> 64</a>
</span><span class=lnt id=hl-66-65><a class=lnlinks href=#hl-66-65> 65</a>
</span><span class=lnt id=hl-66-66><a class=lnlinks href=#hl-66-66> 66</a>
</span><span class=lnt id=hl-66-67><a class=lnlinks href=#hl-66-67> 67</a>
</span><span class=lnt id=hl-66-68><a class=lnlinks href=#hl-66-68> 68</a>
</span><span class=lnt id=hl-66-69><a class=lnlinks href=#hl-66-69> 69</a>
</span><span class=lnt id=hl-66-70><a class=lnlinks href=#hl-66-70> 70</a>
</span><span class=lnt id=hl-66-71><a class=lnlinks href=#hl-66-71> 71</a>
</span><span class=lnt id=hl-66-72><a class=lnlinks href=#hl-66-72> 72</a>
</span><span class=lnt id=hl-66-73><a class=lnlinks href=#hl-66-73> 73</a>
</span><span class=lnt id=hl-66-74><a class=lnlinks href=#hl-66-74> 74</a>
</span><span class=lnt id=hl-66-75><a class=lnlinks href=#hl-66-75> 75</a>
</span><span class=lnt id=hl-66-76><a class=lnlinks href=#hl-66-76> 76</a>
</span><span class=lnt id=hl-66-77><a class=lnlinks href=#hl-66-77> 77</a>
</span><span class=lnt id=hl-66-78><a class=lnlinks href=#hl-66-78> 78</a>
</span><span class=lnt id=hl-66-79><a class=lnlinks href=#hl-66-79> 79</a>
</span><span class=lnt id=hl-66-80><a class=lnlinks href=#hl-66-80> 80</a>
</span><span class=lnt id=hl-66-81><a class=lnlinks href=#hl-66-81> 81</a>
</span><span class=lnt id=hl-66-82><a class=lnlinks href=#hl-66-82> 82</a>
</span><span class=lnt id=hl-66-83><a class=lnlinks href=#hl-66-83> 83</a>
</span><span class=lnt id=hl-66-84><a class=lnlinks href=#hl-66-84> 84</a>
</span><span class=lnt id=hl-66-85><a class=lnlinks href=#hl-66-85> 85</a>
</span><span class=lnt id=hl-66-86><a class=lnlinks href=#hl-66-86> 86</a>
</span><span class=lnt id=hl-66-87><a class=lnlinks href=#hl-66-87> 87</a>
</span><span class=lnt id=hl-66-88><a class=lnlinks href=#hl-66-88> 88</a>
</span><span class=lnt id=hl-66-89><a class=lnlinks href=#hl-66-89> 89</a>
</span><span class=lnt id=hl-66-90><a class=lnlinks href=#hl-66-90> 90</a>
</span><span class=lnt id=hl-66-91><a class=lnlinks href=#hl-66-91> 91</a>
</span><span class=lnt id=hl-66-92><a class=lnlinks href=#hl-66-92> 92</a>
</span><span class=lnt id=hl-66-93><a class=lnlinks href=#hl-66-93> 93</a>
</span><span class=lnt id=hl-66-94><a class=lnlinks href=#hl-66-94> 94</a>
</span><span class=lnt id=hl-66-95><a class=lnlinks href=#hl-66-95> 95</a>
</span><span class=lnt id=hl-66-96><a class=lnlinks href=#hl-66-96> 96</a>
</span><span class=lnt id=hl-66-97><a class=lnlinks href=#hl-66-97> 97</a>
</span><span class=lnt id=hl-66-98><a class=lnlinks href=#hl-66-98> 98</a>
</span><span class=lnt id=hl-66-99><a class=lnlinks href=#hl-66-99> 99</a>
</span><span class=lnt id=hl-66-100><a class=lnlinks href=#hl-66-100>100</a>
</span><span class=lnt id=hl-66-101><a class=lnlinks href=#hl-66-101>101</a>
</span><span class=lnt id=hl-66-102><a class=lnlinks href=#hl-66-102>102</a>
</span><span class=lnt id=hl-66-103><a class=lnlinks href=#hl-66-103>103</a>
</span><span class=lnt id=hl-66-104><a class=lnlinks href=#hl-66-104>104</a>
</span><span class=lnt id=hl-66-105><a class=lnlinks href=#hl-66-105>105</a>
</span><span class=lnt id=hl-66-106><a class=lnlinks href=#hl-66-106>106</a>
</span><span class=lnt id=hl-66-107><a class=lnlinks href=#hl-66-107>107</a>
</span><span class=lnt id=hl-66-108><a class=lnlinks href=#hl-66-108>108</a>
</span><span class=lnt id=hl-66-109><a class=lnlinks href=#hl-66-109>109</a>
</span><span class=lnt id=hl-66-110><a class=lnlinks href=#hl-66-110>110</a>
</span><span class=lnt id=hl-66-111><a class=lnlinks href=#hl-66-111>111</a>
</span><span class=lnt id=hl-66-112><a class=lnlinks href=#hl-66-112>112</a>
</span><span class=lnt id=hl-66-113><a class=lnlinks href=#hl-66-113>113</a>
</span><span class=lnt id=hl-66-114><a class=lnlinks href=#hl-66-114>114</a>
</span><span class=lnt id=hl-66-115><a class=lnlinks href=#hl-66-115>115</a>
</span><span class=lnt id=hl-66-116><a class=lnlinks href=#hl-66-116>116</a>
</span><span class=lnt id=hl-66-117><a class=lnlinks href=#hl-66-117>117</a>
</span><span class=lnt id=hl-66-118><a class=lnlinks href=#hl-66-118>118</a>
</span><span class=lnt id=hl-66-119><a class=lnlinks href=#hl-66-119>119</a>
</span><span class=lnt id=hl-66-120><a class=lnlinks href=#hl-66-120>120</a>
</span><span class=lnt id=hl-66-121><a class=lnlinks href=#hl-66-121>121</a>
</span><span class=lnt id=hl-66-122><a class=lnlinks href=#hl-66-122>122</a>
</span><span class=lnt id=hl-66-123><a class=lnlinks href=#hl-66-123>123</a>
</span><span class=lnt id=hl-66-124><a class=lnlinks href=#hl-66-124>124</a>
</span><span class=lnt id=hl-66-125><a class=lnlinks href=#hl-66-125>125</a>
</span><span class=lnt id=hl-66-126><a class=lnlinks href=#hl-66-126>126</a>
</span><span class=lnt id=hl-66-127><a class=lnlinks href=#hl-66-127>127</a>
</span><span class=lnt id=hl-66-128><a class=lnlinks href=#hl-66-128>128</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># values.yaml — 서비스 타입별 권장 설정 샘플</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 1) 웹 서비스 (사용자 트래픽이 있고 비교적 버스트성 있음)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 리소스 권장값(예시) — 서비스 특성에 맞게 프로파일링 후 수정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;200m&#34;</span><span class=w>       </span><span class=c># 평상시 보장되는 CPU(스케줄링 우선도)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>   </span><span class=c># 평상시 보장되는 메모리</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>       </span><span class=c># 버스트 허용 상한 (requests &lt; limits -&gt; Burstable QoS)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512Mi&#34;</span><span class=w>   </span><span class=c># OOM 방지용 상한</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 프로브 권장 (웹은 readiness로 트래픽 라우팅 제어)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>probes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>liveness</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>    </span><span class=c># 앱 스타트업 시간 고려하여 여유 설정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>readiness</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/ready</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># startupProbe는 스타트업이 오래 걸리는 경우 사용(예: 대규모 초기 캐시 로드)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>startup</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 자동스케일(HPA) 권장값</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hpa</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 웹은 CPU+RPS 기반 혼합 스케일링 권장(여기서는 CPU 예시)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetCPUUtilizationPercentage</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 2) API 서비스 (레이턴시 민감 — latency-sensitive)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>api</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 레이턴시 민감한 API는 QoS 보장을 위해 requests == limits로 설정해 &#39;Guaranteed&#39;로 만들거나</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 최소한 requests를 충분히 확보해서 throttling 위험을 낮춘다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>     </span><span class=c># requests == limits -&gt; Guaranteed QoS 권장 (CPU 매니저 static 사용 시 고려)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>probes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>liveness</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>readiness</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/ready</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># API 서비스는 짧은 타임아웃을 권장(빠르게 실패 판단)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>startup</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># HPA: 레이턴시 서비스는 RPS 또는 custom metrics 기반 스케일이 더 정확</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hpa</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>20</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>targetCPUUtilizationPercentage</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 권장: customMetric (e.g., request_rate_per_pod) 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 3) 배치 작업 (Batch / 워크로드)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 배치 작업(Job/CronJob)은 일반적으로 프로브를 사용하지 않으며,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 리소스는 작업 유형에 따라 크게 달라진다. 가급적 requests만 설정해 스케줄링 친화적으로 함.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>batch</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 배치성 작업은 컨테이너 밀도와 스팟 인스턴스 활용을 고려.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># requests만 설정하고 limits는 필요 시에만 지정하면 노드 packing 유리.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;100m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=w>         </span><span class=c># 필요시 상한을 둠 (예: 대규모 계산 단계)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1Gi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 배치는 liveness/readiness 보단 activeDeadline/parallelism 등으로 제어</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>job</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>activeDeadlineSeconds: 3600   # 작업 최대 허용 시간 (예</span><span class=p>:</span><span class=w> </span><span class=l>1시간)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>backoffLimit</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>               </span><span class=c># 실패 재시도 횟수</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>parallelism</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>                </span><span class=c># 병렬 작업 수 (필요시 조정)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># 스케줄링 팁: 스팟 인스턴스 허용/전용 노드 셀렉터 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nodeAffinity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>preferredDuringSchedulingIgnoredDuringExecution</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>weight</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>preference</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>matchExpressions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>node-type</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>operator</span><span class=p>:</span><span class=w> </span><span class=l>In</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>values</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;spot&#34;</span><span class=p>,</span><span class=s2>&#34;batch&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># 공통 권장: 모니터링·알람 기준 (예시는 values에 포함 가능)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>observability</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>alerts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu_throttled_threshold</span><span class=p>:</span><span class=w> </span><span class=m>0.05</span><span class=w>  </span><span class=c># 5% throttled time 초과 시 경고(비율 기준)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory_usage_ratio</span><span class=p>:</span><span class=w> </span><span class=m>0.8</span><span class=w>        </span><span class=c># requests 대비 80% 초과 시 경고</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>pod_restart_rate</span><span class=p>:</span><span class=w> </span><span class=m>0.01</span><span class=w>         </span><span class=c># 단위 시간당 재시작 비율 임계값</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=사용-가이드--튜닝-포인트>사용 가이드 & 튜닝 포인트<a hidden class=anchor aria-hidden=true href=#사용-가이드--튜닝-포인트>#</a></h6><ul><li><p><strong>프로파일링이 우선</strong>: 위 값은 출발점이다. 실제 서비스는 로드 테스트로 CPU/메모리 프로파일을 만들고 requests/limits 를 조정하라.</p></li><li><p><strong>QoS 선택</strong>:</p><ul><li>레이턴시 민감 (예: API) → <code>requests == limits</code> 로 <code>Guaranteed</code> 권장 (스로틀링·노드 경쟁 회피).</li><li>버스트성 (예: 웹) → <code>requests &lt; limits</code> 로 <code>Burstable</code>, HPA 로 대응.</li><li>배치 → requests 만 설정해 높은 팩킹 효율.</li></ul></li><li><p><strong>프로브 튜닝</strong>: startup delay, timeout, failureThreshold 는 애플리케이션의 실제 시작/응답 특성에 맞춰 충분히 여유 주기. (프로브가 너무 엄격하면 정상 애플리케이션을 죽임)</p></li><li><p><strong>오토스케일링</strong>: CPU 외에 RPS, 큐 길이, custom metrics 기반 스케일을 도입하면 더 정확하게 수요를 따라감.</p></li><li><p><strong>모니터링 경보</strong>: throttled metrics, P95/P99 latency, OOMKilled 이벤트를 알람으로 설정해 사전 대응.</p></li></ul><h4 id=컨테이너-sre-자동화-운영-프레임>컨테이너 SRE 자동화 운영 프레임<a hidden class=anchor aria-hidden=true href=#컨테이너-sre-자동화-운영-프레임>#</a></h4><p>SRE 실천은 <strong>측정 가능한 목표 (SLI/SLO)</strong> 를 정하고, 그 목표 안에서 **신뢰성 (availability) 과 개발 속도 (velocity)**를 균형 있게 관리하는 활동이다.<br>컨테이너 환경에서는 모니터링 (메트릭/알림), 자동화 (배포·복구·스케일), 점진적 배포 (카나리), 그리고 보안·관측을 자동화 도구로 연결해 <strong>반복 가능한 운영 루프</strong> 를 만드는 것이 핵심이다.<br>자동화는 사람의 반복노동을 줄이지만 <strong>안전장치 (임계값·쿨다운·롤백)</strong> 가 필수이다.</p><h5 id=sre-자동화-운영-카테고리>SRE 자동화 운영 카테고리<a hidden class=anchor aria-hidden=true href=#sre-자동화-운영-카테고리>#</a></h5><h6 id=모니터링slislo-관리>모니터링·SLI/SLO 관리<a hidden class=anchor aria-hidden=true href=#모니터링slislo-관리>#</a></h6><p>모니터링은 SLI(서비스 레벨 지표) 를 정하고 SLO(목표) 를 세워 에러 예산을 관리하는 활동이다. 적절한 지표 (레이지 응답시간, 에러율, 인프라 지표) 를 수집하고, 알람은 계층화해 노이즈를 줄여야 한다. SLO 위반 시 정책 (릴리스 중단, 에러 예산 보상) 이 자동 또는 운영 절차로 연결되어야 한다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>SLI 선정·측정</td><td>Prometheus, OpenTelemetry</td><td>잘못된 지표 선정 → 무의미 알람</td><td>사용자 여정 기반 SLI 선정</td><td>HTTP 5xx 비율, P95 응답시간</td></tr><tr><td>SLO 정의·에러예산</td><td>Grafana, SLIP</td><td>SLO 미설정 → 무분별한 배포</td><td>정책화 (에러 예산 소진시 조치)</td><td>가용성 %, 에러 예산 소진률</td></tr><tr><td>알림 계층화</td><td>Alertmanager, PagerDuty</td><td>알람 폭주</td><td>임계치·증가율 기반 계층화</td><td>페이지 수/주</td></tr></tbody></table><ul><li><pre><code>SLI/SLO는 결국 운영 의사결정(배포 중단·긴급 롤백)을 자동화하는 기준이다. 정확한 지표와 계층화된 알림 설계가 우선이다.
</code></pre></li></ul><h6 id=배포릴리스-자동화-카나리gitops>배포·릴리스 자동화 (카나리·GitOps)<a hidden class=anchor aria-hidden=true href=#배포릴리스-자동화-카나리gitops>#</a></h6><p>GitOps 와 카나리 자동화는 안전한 배포의 핵심이다. Git 을 단일 소스로 하여 자동 동기화하고, 카나리 분석으로 점진 전환을 자동화한다. 카나리 판정 기준은 통계적 유의성 기반이어야 한다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>GitOps 파이프라인</td><td>ArgoCD, Flux</td><td>수동 배포·설정 드리프트</td><td>Git→클러스터 자동 동기화</td><td>Git sync latency, drift count</td></tr><tr><td>카나리 자동화</td><td>Flagger, Argo Rollouts</td><td>통계 부족 → 잘못된 판정</td><td>샘플 크기 산정·유의성 검사</td><td>에러율, 응답시간 변화</td></tr><tr><td>배포 전략 적용</td><td>Helm, Kustomize</td><td>불일관한 템플릿</td><td>템플릿화·검증 파이프라인</td><td>배포 성공률</td></tr></tbody></table><ul><li><pre><code>GitOps는 변경 이력을 투명하게 만들고 카나리는 실제 사용자 영향도를 측정해 안전하게 확장한다. 자동화는 통계·검증과 함께 적용해야 안전하다.
</code></pre></li></ul><h6 id=자동-복구인시던트-대응>자동 복구·인시던트 대응<a hidden class=anchor aria-hidden=true href=#자동-복구인시던트-대응>#</a></h6><p>헬스체크 기반 자동 재시작, 오퍼레이터를 통한 복구, 사고 시 MTTR 을 단축하는 플레이북과 자동 에스컬레이션 체계가 중요하다. 그러나 자동 복구는 안전장치 없이 적용하면 역효과가 발생할 수 있다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>헬스체크·프로브</td><td>Kubernetes liveness/readiness</td><td>잘못된 헬스체크로 불필요 재시작</td><td>심층 헬스체크·사전 회복 절차</td><td>재시작률, probe 실패율</td></tr><tr><td>오퍼레이터/자동복구</td><td>Custom Operator, K8s Controller</td><td>복구 루프 발생</td><td>백오프·재시도 한계·관찰 후 사람개입</td><td>MTTR, 자동복구 성공율</td></tr><tr><td>사고 플레이북</td><td>Runbook, PagerDuty</td><td>혼란 시 수동조치 지연</td><td>자동 에스컬레이션·체크리스트</td><td>평균 대응시간</td></tr></tbody></table><ul><li><pre><code>자동 복구는 MTTR을 줄이지만 안전장치(백오프·회로차단·사람 개입 루트)를 반드시 포함해야 한다.
</code></pre></li></ul><h6 id=용량-관리오토스케일링>용량 관리·오토스케일링<a hidden class=anchor aria-hidden=true href=#용량-관리오토스케일링>#</a></h6><p>HPA/VPA/Cluster Autoscaler 로 자동 확장하지만 메트릭 설계·쿨다운·버퍼를 통해 과/저확장 리스크를 제어해야 한다. 예측적 스케일링을 적용하면 급증 부하에 더욱 탄력적으로 대응할 수 있다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>HPA/VPA 설정</td><td>Kubernetes HPA/VPA</td><td>단일 메트릭 의존 → 오버스케일</td><td>복합 지표·쿨다운·버퍼 설정</td><td>pod CPU, queue length</td></tr><tr><td>클러스터 오토스케일</td><td>Cluster Autoscaler</td><td>노드 프로비저닝 지연</td><td>예비 용량 또는 예측 스케일</td><td>scale latency, node add time</td></tr><tr><td>비용 최적화</td><td>KEDA, cost tools</td><td>무분별한 스케일링 비용 증가</td><td>정책 기반 스케일, scheduled scale</td><td>비용/시간 단위</td></tr></tbody></table><ul><li><pre><code>자동 스케일링은 메트릭·쿨다운·예측을 결합해야 안정적으로 동작하며 비용·성능 균형 설계가 필요하다.
</code></pre></li></ul><h6 id=보안-자동화컴플라이언스>보안 자동화·컴플라이언스<a hidden class=anchor aria-hidden=true href=#보안-자동화컴플라이언스>#</a></h6><p>이미지 스캔·서명, 시크릿 관리, 정책 엔진 (OPA) 으로 자동 차단을 구성하되, 패치·차단 시 사전 검증과 롤백 절차를 마련해야 한다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>이미지 스캔·서명</td><td>Trivy, cosign</td><td>자동 차단 → 배포 지연</td><td>심각도 기반 분기·카나리 적용</td><td>취약점 수, 서명 비율</td></tr><tr><td>시크릿 관리</td><td>SealedSecrets, Vault</td><td>시크릿 노출 위험</td><td>암호화 저장·접근 제어</td><td>시크릿 접근 로그</td></tr><tr><td>정책 엔진</td><td>OPA/Gatekeeper</td><td>과도 차단</td><td>정책 단계별 적용 (경고→차단)</td><td>정책 위반 수</td></tr></tbody></table><ul><li><pre><code>보안 자동화는 필수이나 자동 차단 정책은 단계적(감시→경고→차단)으로 도입해야 운영 중단을 줄인다.
</code></pre></li></ul><h6 id=관측성-로그트레이스검증>관측성 (로그/트레이스)·검증<a hidden class=anchor aria-hidden=true href=#관측성-로그트레이스검증>#</a></h6><p>메트릭·로그·트레이스의 통합관찰은 문제 탐지·근본원인 분석·카나리 검증의 근간이다. SLO 기반 검증 파이프라인과 연계하여 배포 자동 승인/거부가 가능하다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>메트릭 수집</td><td>Prometheus</td><td>지표 누락·상관분석 어려움</td><td>표준화된 레이블·관점 설계</td><td>metric scrape rate</td></tr><tr><td>로그 중앙화</td><td>ELK, Loki</td><td>로그 파싱·상관성 부족</td><td>구조화 로그·분산 추적 연계</td><td>로그 수, 에러 로그비율</td></tr><tr><td>분산 트레이스</td><td>OpenTelemetry</td><td>서비스 간 호출 병목 파악 어려움</td><td>트레이스 샘플링·상관 인덱스</td><td>trace latency</td></tr></tbody></table><ul><li><pre><code>관측성은 배포 검증과 인시던트 대응의 필수 인프라다. SLO 검증 자동화와 연결하자.
</code></pre></li></ul><h6 id=토일-제거운영-자동화-조직화>토일 제거·운영 자동화 조직화<a hidden class=anchor aria-hidden=true href=#토일-제거운영-자동화-조직화>#</a></h6><p>토일의 정의·계량화 (시간 기준) → 자동화 우선순위화 → 자동화 달성률 측정 (예: Toil 시간 80% 감소) 를 조직 KPI 로 삼는다. SRE 팀과 서비스팀 간 역할·소유권 정의가 필수다.</p><table><thead><tr><th>핵심활동</th><th>도구</th><th>문제 (왜 발생)</th><th>해결방법</th><th>지표 예시</th></tr></thead><tbody><tr><td>토일 계량화</td><td>Time tracking, surveys</td><td>토일 정의 모호</td><td>표준 정의·측정 템플릿</td><td>토일 시간/주</td></tr><tr><td>자동화 파이프라인</td><td>ArgoCD, Jenkins</td><td>자동화 우선순위 부재</td><td>ROI 기반 우선순위화</td><td>자동화율</td></tr><tr><td>운영 문서화</td><td>Runbooks, Playbooks</td><td>지식 편중</td><td>Runbook 표준·훈련</td><td>온콜 해결율</td></tr></tbody></table><ul><li><pre><code>토일 감소는 자동화 기술뿐 아니라 조직적 합의와 KPI로 밀어붙여야 성과가 난다.
</code></pre></li></ul><h5 id=sre-자동화-운영-통합-요약표>SRE 자동화 운영 통합 요약표<a hidden class=anchor aria-hidden=true href=#sre-자동화-운영-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 목표</th><th>대표 도구</th><th>핵심 안전장치 (예시)</th><th>핵심 지표</th></tr></thead><tbody><tr><td>모니터링·SLI/SLO</td><td>신뢰성 목표 관리</td><td>Prometheus, Grafana</td><td>알람 계층화, 에러예산 정책</td><td>SLO 준수율, 에러예산 소진률</td></tr><tr><td>배포·릴리스</td><td>안전한 배포·롤백</td><td>ArgoCD, Flagger</td><td>카나리 통계 검증, Feature flag</td><td>배포 성공률, 롤백 횟수</td></tr><tr><td>자동 복구</td><td>MTTR 단축</td><td>K8s Controller, Operator</td><td>백오프·circuit breaker</td><td>MTTR, 자동복구율</td></tr><tr><td>용량 관리</td><td>성능·비용 균형</td><td>HPA/VPA, Cluster Autoscaler</td><td>cooldown·버퍼 정책</td><td>scale latency, 비용/시간</td></tr><tr><td>보안 자동화</td><td>공급망·런타임 보안</td><td>Trivy, cosign, OPA</td><td>단계적 차단 (경고→차단)</td><td>취약점 수, 정책 위반</td></tr><tr><td>관측성·검증</td><td>문제 탐지·근본원인</td><td>Prometheus, ELK, OTel</td><td>SLO 기반 배포 승인</td><td>metric coverage, trace latency</td></tr><tr><td>토일 제거</td><td>운영 효율화</td><td>ArgoCD, Jenkins</td><td>KPI(자동화율)·런북</td><td>토일 시간, 자동화 달성율</td></tr></tbody></table><h3 id=고급-주제-및-미래-전망>고급 주제 및 미래 전망<a hidden class=anchor aria-hidden=true href=#고급-주제-및-미래-전망>#</a></h3><h4 id=컨테이너-도전과제와-실무-대응전략>컨테이너 도전과제와 실무 대응전략<a hidden class=anchor aria-hidden=true href=#컨테이너-도전과제와-실무-대응전략>#</a></h4><p>컨테이너 기술은 애플리케이션 배포를 표준화하지만, 운영 환경으로 확장할 때는 <strong>기술적 (네트워크·스토리지·보안), 운영적 (스킬·거버넌스), 경제적 (비용)</strong> 문제들이 병존한다.<br>각 문제는 원인 (설계·인프라·조직) 과 영향 (성능저하·보안사고·비용증가) 이 명확하므로, <strong>우선순위 (비즈니스 영향 기준)</strong> 를 매겨 자동화·표준화·관측성·보안 파이프라인을 단계적으로 도입하는 방식이 효과적이다.</p><h5 id=컨테이너-도전과제-기술운영-분류>컨테이너 도전과제: 기술·운영 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-도전과제-기술운영-분류>#</a></h5><h6 id=기술적-복잡성아키텍처-관리>기술적: 복잡성·아키텍처 관리<a hidden class=anchor aria-hidden=true href=#기술적-복잡성아키텍처-관리>#</a></h6><ul><li><strong>문제</strong>: 서비스·도구·플러그인 다양성으로 전체 시스템 복잡도 증가</li><li><strong>원인</strong>: 마이크로서비스 아키텍처, 다양한 CNI/CSI/플러그인 선택, 환경별 설정 불일치</li><li><strong>영향</strong>: 배포·디버깅 지연, 운영 비용 상승, 구성 오류 위험 증가</li><li><strong>해결 방법</strong>: 플랫폼팀 (플랫폼 엔지니어링) 으로 표준 스택 제공, GitOps(ArgoCD) 로 선언적 관리, 서비스 메시로 관측성·트래픽 관리를 중앙화</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>도구·플러그인 다양성</td><td>선택 폭·레거시</td><td style=text-align:right>운영 복잡성↑</td><td>표준 스택·플랫폼팀</td></tr><tr><td>설정 불일치</td><td>환경별 설정</td><td style=text-align:right>배포 오류</td><td>GitOps·IaC</td></tr><tr><td>서비스 의존성</td><td>마이크로서비스 증가</td><td style=text-align:right>장애 확산</td><td>서비스 메시 + 테스트</td></tr></tbody></table><ul><li>복잡성은 &rsquo; 관리의 문제 &rsquo; 다. 표준화된 플랫폼과 선언적 운영, 관측·테스트 자동화로 통제하면 운영 비용을 크게 낮출 수 있다.</li></ul><h6 id=기술적-상태-영속성-관리스토리지-성능>기술적: 상태 (영속성) 관리·스토리지 성능<a hidden class=anchor aria-hidden=true href=#기술적-상태-영속성-관리스토리지-성능>#</a></h6><ul><li><strong>문제</strong>: 컨테이너에서 상태 저장 서비스의 운영·복구가 복잡하고 스토리지 I/O 병목이 발생.</li><li><strong>원인</strong>: 컨테이너 휘발성, 네트워크 기반 분산 스토리지의 오버헤드, CSI 설정 오류</li><li><strong>영향</strong>: DB 성능 저하·데이터 손실 위험·복구 지연</li><li><strong>해결 방법</strong>: StatefulSet + CSI + Operator 패턴, 로컬 NVMe 사용 (필요시), 백업/스냅샷 자동화 (Velero), 관리형 DB 활용</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>상태 저장 복잡성</td><td>휘발성·스케줄링</td><td style=text-align:right>일관성/복구 문제</td><td>StatefulSet·Operator</td></tr><tr><td>스토리지 I/O 병목</td><td>분산 FS 오버헤드</td><td style=text-align:right>DB 성능 저하</td><td>NVMe·로컬 스토리지 선택</td></tr><tr><td>백업·복구</td><td>정책 미비</td><td style=text-align:right>데이터 손실 위험</td><td>자동 백업·테스트 복구</td></tr></tbody></table><ul><li>상태 유지가 필수 서비스는 &rsquo; 컨테이너 친화적 설계 &rsquo; 와 더불어 스토리지 아키텍처 (로컬/분산) 와 복구 정책을 우선 설계해야 한다.</li></ul><h6 id=기술적-네트워크-성능토폴로지>기술적: 네트워크 성능·토폴로지<a hidden class=anchor aria-hidden=true href=#기술적-네트워크-성능토폴로지>#</a></h6><ul><li><strong>문제</strong>: 오버레이·소프트웨어 스위칭으로 인한 레이턴시·처리량 저하</li><li><strong>원인</strong>: 캡슐화, 다중 홉, 네트워크 플러그인 구현 차이</li><li><strong>영향</strong>: 실시간 서비스 품질 저하 (스트리밍, 게임 등)</li><li><strong>해결 방법</strong>: eBPF 기반 CNI(Cilium), SR-IOV, 네트워크 프로파일 (노드풀 분리), 성능 테스트/모니터링</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>오버레이 오버헤드</td><td>캡슐화·소프트웨어 스위칭</td><td style=text-align:right>레이턴시↑</td><td>eBPF·SR-IOV</td></tr><tr><td>네트워크 정책 복잡</td><td>다계층 정책</td><td style=text-align:right>운영 오류</td><td>중앙화된 정책 관리</td></tr><tr><td>성능 벤치마크 부재</td><td>테스트 부족</td><td style=text-align:right>SLA 미달</td><td>정기적 벤치마크</td></tr></tbody></table><ul><li>네트워크 문제는 &rsquo; 설계·실험 &rsquo; 으로 대응 가능하다. eBPF/SR-IOV 등 현대적 데이터플레인 도입과 벤치마크가 핵심이다.</li></ul><h6 id=기술적-보안-공급망런타임>기술적: 보안 (공급망·런타임)<a hidden class=anchor aria-hidden=true href=#기술적-보안-공급망런타임>#</a></h6><ul><li><strong>문제</strong>: 이미지 취약점·런타임 탈출 등 보안 위협 증가</li><li><strong>원인</strong>: 미검증 이미지, 권한 과다, 커널 공유</li><li><strong>영향</strong>: 시스템 침해, 데이터 노출, 규제 리스크</li><li><strong>해결 방법</strong>: CI 스캔 (Trivy), SBOM·서명 (cosign), 정책 차단 (OPA), 런타임 탐지 (Falco), 샌드박스 런타임 (Kata/gVisor)</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>공급망 취약</td><td>미검증 이미지</td><td style=text-align:right>침해 위험</td><td>스캔·서명·SBOM</td></tr><tr><td>런타임 탈출</td><td>권한·커널 공유</td><td style=text-align:right>전체 침해</td><td>최소권한·샌드박스</td></tr><tr><td>정책 미비</td><td>배포 통제 없음</td><td style=text-align:right>규정 위반</td><td>OPA/Gatekeeper</td></tr></tbody></table><ul><li>공급망 보안과 런타임 보호는 &rsquo; 빌드 파이프라인 + 런타임 보호 &rsquo; 의 결합으로 방어해야 한다.</li></ul><h6 id=운영적-스킬-갭조직운영-모델>운영적: 스킬 갭·조직·운영 모델<a hidden class=anchor aria-hidden=true href=#운영적-스킬-갭조직운영-모델>#</a></h6><ul><li><strong>문제</strong>: 전문인력 부족과 운영 경험 미비</li><li><strong>원인</strong>: 빠른 기술 변화, 다양한 도구 요구</li><li><strong>영향</strong>: 도입 지연·운영 오류·보안 미비</li><li><strong>해결 방법</strong>: 플랫폼팀 구성, 체계적 교육·인증, 초기엔 Managed 서비스 활용</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>스킬 갭</td><td>빠른 변화</td><td style=text-align:right>운영 품질 저하</td><td>교육·플랫폼팀</td></tr><tr><td>운영 모델 부재</td><td>책임 분산</td><td style=text-align:right>장애 대응 지연</td><td>SRE·Oncall 문화</td></tr><tr><td>매니지드 활용 부족</td><td>비용 우려</td><td style=text-align:right>운영 부담↑</td><td>단계적 Managed 채택</td></tr></tbody></table><ul><li>조직적 준비가 없으면 기술적 솔루션도 무용지물이다. 플랫폼팀과 교육으로 역량을 빠르게 만들어야 한다.</li></ul><h6 id=운영적-멀티클라우드거버넌스>운영적: 멀티클라우드·거버넌스<a hidden class=anchor aria-hidden=true href=#운영적-멀티클라우드거버넌스>#</a></h6><ul><li><strong>문제</strong>: 여러 클라우드/클러스터의 정책·설정 불일치</li><li><strong>원인</strong>: 벤더별 API·서비스 모델 차이</li><li><strong>영향</strong>: 이식성 저하·운영 중복·비용 증가</li><li><strong>해결 방법</strong>: 추상화 (IaC, Terraform), 멀티클러스터 관리 (Cluster API, Fleet), 정책 중앙화 (GitOps + OPA)</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>클라우드 종속</td><td>벤더 서비스 차이</td><td style=text-align:right>이식성 ↓</td><td>IaC·추상화 계층</td></tr><tr><td>정책 불일치</td><td>수작업 설정</td><td style=text-align:right>규정 위반 가능</td><td>GitOps + 중앙정책</td></tr><tr><td>멀티클러스터 복잡</td><td>상태 동기화</td><td style=text-align:right>운영부담</td><td>Cluster API / Fleet</td></tr></tbody></table><ul><li>멀티클라우드는 기술적 도전뿐 아니라 거버넌스·정책 자동화가 핵심이다.</li></ul><h6 id=운영적-비용-최적화규정-준수>운영적: 비용 최적화·규정 준수<a hidden class=anchor aria-hidden=true href=#운영적-비용-최적화규정-준수>#</a></h6><ul><li><strong>문제</strong>: 동적 리소스 사용으로 비용 예측·통제 어려움, 규제 대응 부담</li><li><strong>원인</strong>: 오토스케일·스팟/온디맨드 혼용, 글로벌 규제 다양성</li><li><strong>영향</strong>: 예산 초과·법적 리스크</li><li><strong>해결 방법</strong>: FinOps 프로세스·도구, 예약 인스턴스·rightsizing, SBOM·감사로그·데이터 레지스트리 설계</li></ul><table><thead><tr><th>항목</th><th>원인</th><th style=text-align:right>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>비용 불확실성</td><td>오토스케일·스팟</td><td style=text-align:right>예산 초과</td><td>FinOps·모니터링</td></tr><tr><td>규정 준수 부담</td><td>다국가 규제</td><td style=text-align:right>법적 리스크</td><td>정책 자동화·감사로그</td></tr></tbody></table><ul><li>비용·규정은 기술적 해법과 조직·프로세스가 함께 맞물려야 해결된다.</li></ul><h5 id=컨테이너-도전과제-통합표>컨테이너 도전과제 통합표<a hidden class=anchor aria-hidden=true href=#컨테이너-도전과제-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 도전</th><th>원인</th><th style=text-align:right>주요 영향</th><th>권장 핵심 대응</th></tr></thead><tbody><tr><td>복잡성 관리</td><td>도구·설정 다양성</td><td>마이크로서비스·플러그인</td><td style=text-align:right>운영비·장애추적 지연</td><td>표준 플랫폼·GitOps</td></tr><tr><td>상태 관리·스토리지</td><td>영속성·IO 병목</td><td>휘발성·분산 FS</td><td style=text-align:right>DB 성능·복구 문제</td><td>CSI+StatefulSet·NVMe</td></tr><tr><td>네트워크 성능</td><td>오버헤드·정책 복잡</td><td>오버레이·캡슐화</td><td style=text-align:right>레이턴시·처리량 저하</td><td>eBPF·SR-IOV·노드풀</td></tr><tr><td>보안 (공급망·런타임)</td><td>이미지·탈출 위험</td><td>미검증 이미지·권한</td><td style=text-align:right>시스템 침해</td><td>스캔·서명·샌드박스</td></tr><tr><td>스킬·조직</td><td>전문인력 부족</td><td>빠른 변화</td><td style=text-align:right>도입 지연·운영 품질↓</td><td>교육·플랫폼팀</td></tr><tr><td>멀티클라우드·거버넌스</td><td>정책 불일치</td><td>벤더별 차이</td><td style=text-align:right>이식성↓·중복운영</td><td>IaC·GitOps·Cluster API</td></tr><tr><td>비용·규정</td><td>비용·규제 관리</td><td>동적 리소스·글로벌 규정</td><td style=text-align:right>예산 초과·법적 리스크</td><td>FinOps·정책자동화</td></tr></tbody></table><h4 id=컨테이너-최신기술-적용-분류와-로드맵>컨테이너 최신기술 적용 분류와 로드맵<a hidden class=anchor aria-hidden=true href=#컨테이너-최신기술-적용-분류와-로드맵>#</a></h4><p>컨테이너 기술은 " 어디에 배포하느냐 (클라우드/엣지), 어떻게 실행하느냐 (전통 Kubernetes / 서버리스 / WASM), 그리고 네트워크·보안 수준을 어떻게 확보하느냐 (eBPF)" 에 따라 진화 중이다.</p><p>2025 년에는 다음이 핵심:</p><ul><li>관리 부담을 줄이는 <strong>서버리스 컨테이너</strong>(운영 단순화)—클라우드 제공자 서비스 권장.</li><li>지연 민감 워크로드는 <strong>엣지 컨테이너</strong>로 분산 (경량 K8s 사용).</li><li>경량·보안·빠른 시작이 필요하면 <strong>WASM</strong> 시범 적용.</li><li>네트워크·보안·관측성은 <strong>eBPF</strong> 기반 툴로 보완.</li></ul><h5 id=컨테이너-최신-기술-분류와-적용방향>컨테이너 최신 기술 분류와 적용방향<a hidden class=anchor aria-hidden=true href=#컨테이너-최신-기술-분류와-적용방향>#</a></h5><h6 id=배포실행-모델>배포·실행 모델<a hidden class=anchor aria-hidden=true href=#배포실행-모델>#</a></h6><p>서버리스 컨테이너 (Fargate 등) 는 인프라 관리를 줄여 운영비용·운영오버헤드를 낮춘다 (단, 비용·성능 특성 확인 필요). 엣지 컨테이너 (k3s 등) 는 지연·대역폭 제약이 있는 환경에 적합하다. 기존 Kubernetes 는 복잡한 제어·확장성에 유리하다.<br>]</p><table><thead><tr><th>모델</th><th>대표기술/서비스</th><th>장점</th><th>단점 / 고려사항</th></tr></thead><tbody><tr><td>서버리스 컨테이너</td><td>AWS Fargate, Azure ACI</td><td>운영 부담 감소, 초단위 과금</td><td>비용 모델 확인 필요, 제어권 제약.</td></tr><tr><td>엣지 컨테이너</td><td>k3s, OpenYurt, Akri</td><td>저지연·로컬 처리, 경량</td><td>오프라인/동기화 복잡성.</td></tr><tr><td>전통 K8s</td><td>EKS/GKE/AKS</td><td>풍부한 기능·에코시스템</td><td>운영복잡도·관리비용</td></tr></tbody></table><ul><li>배포 모델 선택은 <strong>운영 역량·비용 구조·지연 요건</strong>에 따라 결정해야 함.</li></ul><h6 id=런타임-대안-wasm-vs-컨테이너>런타임 대안 (WASM Vs 컨테이너)<a hidden class=anchor aria-hidden=true href=#런타임-대안-wasm-vs-컨테이너>#</a></h6><p>WebAssembly 는 빠른 시작, 작은 메모리, 언어 다형성 장점으로 특정 서버리스·엣지 유스케이스에 매력적이다. 그러나 디버깅·생태계 성숙도는 일부 제한이 있어 점진적 도입 권장.</p><table><thead><tr><th>항목</th><th>WASM (wasmCloud 등)</th><th>컨테이너 (OCI)</th></tr></thead><tbody><tr><td>시작 속도</td><td>매우 빠름</td><td>상대적으로 느림</td></tr><tr><td>격리 수준</td><td>샌드박스 강함</td><td>네임스페이스 기반</td></tr><tr><td>에코시스템</td><td>성장중 (빠르게)</td><td>성숙·광범위</td></tr><tr><td>권장 도입</td><td>짧은 실행·엣지·보안 민감</td><td>범용 서비스 및 레거시</td></tr></tbody></table><ul><li>WASM 은 <strong>특정 목적 (초저지연·경량 기능)</strong> 에 먼저 적용하고, 범용 서비스는 컨테이너 유지.</li></ul><h6 id=네트워킹보안관측-ebpf-중심>네트워킹·보안·관측 (eBPF 중심)<a hidden class=anchor aria-hidden=true href=#네트워킹보안관측-ebpf-중심>#</a></h6><p>eBPF 는 커널 레벨에서 유연한 필터·관측·정책 구현을 가능케 하며, Cilium 과 같은 프로젝트가 K8s 통합으로 채택 확대 중이다. 도입 시 커널 호환성·안전성 검증 필요.</p><table><thead><tr><th>기능</th><th>대표툴</th><th>이점</th><th>고려사항</th></tr></thead><tbody><tr><td>네트워크 정책/보안</td><td>Cilium (eBPF)</td><td>낮은 오버헤드, 높은 가시성</td><td>커널 버전 의존성</td></tr><tr><td>관측성</td><td>eBPF 기반 툴</td><td>심층 가시성 (퍼포먼스)</td><td>운영 복잡도 증가</td></tr><tr><td>런타임 보안</td><td>Falco (eBPF 활용)</td><td>실시간 이상탐지</td><td>규칙 튜닝 필요</td></tr></tbody></table><ul><li>eBPF 도입은 <strong>성능·보안·관측성 향상</strong>을 제공하지만, 커널·운영 고려사항을 반드시 점검해야 함.</li></ul><h6 id=운영비용조직-gitopssrefinops>운영·비용·조직 (GitOps·SRE·FinOps)<a hidden class=anchor aria-hidden=true href=#운영비용조직-gitopssrefinops>#</a></h6><p>GitOps(ArgoCD 등), SRE 문화, FinOps(비용 최적화), AI 기반 자동화는 2025 년 운영 패러다임의 핵심이다. 기술 도입과 함께 조직·프로세스 변화가 필수.</p><table><thead><tr><th>영역</th><th>핵심</th><th>기대효과</th><th>도입포인트</th></tr></thead><tbody><tr><td>GitOps</td><td>ArgoCD, Flux</td><td>배포 안정성·가시성</td><td>PR 기반 CD 파이프라인</td></tr><tr><td>SRE</td><td>SLO/SLI, Error Budget</td><td>가용성 중심 운영</td><td>SLO 정의·책임 분담</td></tr><tr><td>FinOps</td><td>비용 모니터링</td><td>비용 최적화</td><td>태그/계층별 비용 모델</td></tr><tr><td>AI 자동화</td><td>관측·오토리메디에이션</td><td>대응속도 향상</td><td>신중한 자동화 정책</td></tr></tbody></table><ul><li>기술만으로 끝나지 않고 <strong>조직·프로세스 혁신</strong>이 함께 이뤄져야 효과가 난다.</li></ul><h5 id=컨테이너-기술-트렌드-통합-요약표>컨테이너 기술 트렌드 통합 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-기술-트렌드-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표기술/예시</th><th>핵심가치</th><th>도입 시 고려사항</th></tr></thead><tbody><tr><td>배포·실행</td><td>Fargate, k3s, EKS</td><td>운영 단순화·저지연</td><td>비용·네트워크 제약</td></tr><tr><td>런타임 대안</td><td>wasmCloud, Krustlet</td><td>빠른 시작·보안</td><td>생태계 성숙도</td></tr><tr><td>네트워크·보안</td><td>Cilium (eBPF), Falco</td><td>가시성·성능·보안</td><td>커널/호환성</td></tr><tr><td>운영·조직</td><td>GitOps, SRE, FinOps</td><td>배포 안정성·비용통제</td><td>조직 변화 필요</td></tr></tbody></table><h4 id=컨테이너-대안-기술과-적용-가이드>컨테이너 대안 기술과 적용 가이드<a hidden class=anchor aria-hidden=true href=#컨테이너-대안-기술과-적용-가이드>#</a></h4><p>컨테이너에 대한 대안은 크게</p><ol><li>관리형 자동확장인 서버리스 (FaaS)</li><li>보안·격리 강화를 위한 마이크로 VM(예: Firecracker)</li><li>컨테이너 호환성을 유지하면서 격리하는 샌드박스 런타임 (gVisor)</li><li>경량 바이트코드 런타임 (WebAssembly)</li><li>극단적 경량화인 Unikernel<br>등으로 나뉜다.<br>각 대안은 <strong>격리 수준·성능·운영 복잡도·생산성</strong>에서 서로 다른 트레이드오프를 가지므로, 서비스 특성 (보안 요구, 지연 민감도, 운영 역량) 에 따라 하나 또는 하이브리드로 결합해 사용하는 것이 실무적 해법이다.</li></ol><h5 id=컨테이너-대안-기술-분류>컨테이너 대안 기술 분류<a hidden class=anchor aria-hidden=true href=#컨테이너-대안-기술-분류>#</a></h5><h6 id=가상화-기반-대안-microvm--firecracker>가상화 기반 대안 (microVM / Firecracker)<a hidden class=anchor aria-hidden=true href=#가상화-기반-대안-microvm--firecracker>#</a></h6><p>Firecracker 는 마이크로 VM 으로 VM 수준의 격리와 높은 생성 속도를 제공해 서버리스·멀티테넌트 환경에서 보안과 속도를 동시에 추구한다. 하이퍼바이저 (KVM) 를 사용하지만 설계가 극도로 경량화되어 대량의 마이크로 VM 을 효율적으로 운영할 수 있다.</p><table><thead><tr><th>항목</th><th>장점</th><th>단점</th><th>적용 상황</th></tr></thead><tbody><tr><td>Firecracker / microVM</td><td>강력한 격리, 빠른 생성 (마이크로 VM)</td><td>운영·I/O 통합 복잡성, 관리 오버헤드</td><td>멀티테넌시 고격리, 서버리스 인프라</td></tr></tbody></table><ul><li>마이크로 VM 은 &lsquo;VM 수준의 안전성 &rsquo; 과 &rsquo; 컨테이너 수준의 속도 &rsquo; 사이 균형을 제공하므로 고격리·서버리스 인프라에 적합하다.</li></ul><h6 id=샌드박스유저스페이스-격리-gvisor>샌드박스/유저스페이스 격리 (gVisor)<a hidden class=anchor aria-hidden=true href=#샌드박스유저스페이스-격리-gvisor>#</a></h6><p>gVisor 는 컨테이너 툴체인을 그대로 쓰면서 호스트 커널 호출을 유저스페이스에서 처리해 격리를 강화한다. 성능은 네이티브 컨테이너보다 일부 손해가 날 수 있지만 운영 편의성을 크게 해치지 않으면서 보안을 높일 수 있다.</p><table><thead><tr><th>항목</th><th>장점</th><th>단점</th><th>적용 상황</th></tr></thead><tbody><tr><td>gVisor</td><td>컨테이너 호환성 유지, 강화된 격리</td><td>일부 syscall 비호환·성능 저하</td><td>신뢰도 향상 필요, VM 오버헤드 회피</td></tr></tbody></table><ul><li>gVisor 는 VM 을 띄우기 부담스럽지만 더 강한 격리가 필요할 때 합리적 대안이다.</li></ul><h6 id=함수형서버리스-플랫폼-faas--knative--cloud-run>함수형/서버리스 플랫폼 (FaaS / Knative / Cloud Run)<a hidden class=anchor aria-hidden=true href=#함수형서버리스-플랫폼-faas--knative--cloud-run>#</a></h6><p>서버리스는 요청 기반 자동 확장, 운영 부담 감소가 핵심 강점이다. Knative 는 Kubernetes 기반의 오픈 소스 서버리스 플랫폼이고 Cloud Run 은 Knative 기술을 기반으로 한 관리형 서비스다. 그러나 콜드스타트·제한·벤더 락인 이슈가 존재한다.</p><table><thead><tr><th>항목</th><th>장점</th><th>단점</th><th>적용 상황</th></tr></thead><tbody><tr><td>Serverless (Knative/Cloud Run)</td><td>자동 스케일·운영 편의</td><td>콜드스타트·벤더 락인·제한</td><td>이벤트 기반, 짧은 실행 단위</td></tr></tbody></table><ul><li>서버리스는 운영 부담을 줄이지만 서비스 요구 (지속 연결·긴 실행) 에 부적합할 수 있으니 적합성 검토가 필요하다.</li></ul><h6 id=차세대-경량-런타임-webassembly--wasi>차세대 경량 런타임 (WebAssembly / WASI)<a hidden class=anchor aria-hidden=true href=#차세대-경량-런타임-webassembly--wasi>#</a></h6><p>WebAssembly 는 언어 중립적 바이트코드로 빠르게 시작하고 작은 런타임 오버헤드를 제공한다. 엣지와 서버리스에 적합하며, WASI 생태계가 성숙할수록 서버 측 사용이 확대되고 있다. 단, 시스템 레벨 I/O·네이티브 통합은 WASI 표준 진화에 의존한다.</p><table><thead><tr><th>항목</th><th>장점</th><th>단점</th><th>적용 상황</th></tr></thead><tbody><tr><td>WebAssembly / WASI</td><td>초경량·빠른 시작·언어 다양성</td><td>WASI 표준·툴체인 성숙도 필요</td><td>엣지 컴퓨팅, 저지연 함수 실행</td></tr></tbody></table><ul><li>Wasm 은 엣지·서버리스에서 빠르게 채택되며 향후 런타임 대안으로 자리잡을 가능성이 높다.</li></ul><h6 id=연구특수-목적-unikernels>연구·특수 목적 (Unikernels)<a hidden class=anchor aria-hidden=true href=#연구특수-목적-unikernels>#</a></h6><p>Unikernels 는 애플리케이션과 최소한의 OS 를 합쳐 하나의 고도로 최적화된 이미지로 빌드한다. 공격 표면이 작고 성능장점이 있으나 디버깅·운영·생태계 측면에서 제약이 크다. 연구·특수목적 또는 높은 성능/보안이 우선인 시스템에 적합하다.</p><table><thead><tr><th>항목</th><th>장점</th><th>단점</th><th>적용 상황</th></tr></thead><tbody><tr><td>Unikernel</td><td>작은 공격 표면·최적화</td><td>툴·운영·디버깅 한계</td><td>특수 목적, 연구·고성능 시스템</td></tr></tbody></table><ul><li>Unikernel 은 잠재적 장점이 크지만 실무 도입 전 도구·운영성 문제를 신중히 검토해야 한다.</li></ul><h5 id=컨테이너-대안-기술-요약표>컨테이너 대안 기술 요약표<a hidden class=anchor aria-hidden=true href=#컨테이너-대안-기술-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>주요 기술</th><th>핵심 장점</th><th>핵심 단점</th><th>권장 적용 상황</th></tr></thead><tbody><tr><td>가상화 기반</td><td>Firecracker (microVM)</td><td>강력 격리 + 빠른 프로비저닝</td><td>운영 통합 복잡성</td><td>멀티테넌시·보안 우선 환경</td></tr><tr><td>샌드박스 런타임</td><td>gVisor</td><td>컨테이너 호환성 유지, 격리 강화</td><td>성능·호환성 트레이드오프</td><td>VM 오버헤드 회피하면서 보안 향상</td></tr><tr><td>서버리스 / FaaS</td><td>Knative, Cloud Run</td><td>자동 스케일·운영 편의</td><td>콜드스타트·제한·락인 위험</td><td>이벤트 기반·요청 중심 워크로드</td></tr><tr><td>경량 런타임</td><td>WebAssembly / WASI</td><td>초경량·빠른 시작·언어 유연성</td><td>표준·툴체인 성숙도</td><td>엣지, 저지연 함수 실행</td></tr><tr><td>특수·연구</td><td>Unikernels</td><td>작은 공격 표면·성능 최적화</td><td>생태계·운영 제약</td><td>특수 목적·연구·초고성능</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>컨테이너화는 애플리케이션을 운영체제 수준에서 격리된 경량 단위로 패키징해 어디서나 동일하게 실행하도록 보장하는 플랫폼 패턴이다.</p><p>기본 구성은 이미지 빌드 (예: BuildKit) → 레지스트리 (Harbor/Docker Hub) → 런타임 (containerd + runc 또는 kata) → 오케스트레이션 (Kubernetes) → 네트워크 (CNI)·스토리지 (CSI) 플러그인으로 이어진다.<br>이를 통해 개발과 운영 간 환경 격차가 사라지고 배포 주기가 크게 단축되며 자원 밀도가 향상된다.</p><p>그러나 다음 항목들은 명시적 설계·운영이 필요하다.</p><ul><li><strong>보안/공급망</strong>: 이미지 서명·스캔, SBOM, 레지스트리 접근 제어, runtime policy(seccomp, LSM) 적용.</li><li><strong>데이터 (상태성)</strong>: StatefulSet·PV/PVC 패턴, 스토리지 클래스 설계, 백업·복구 절차.</li><li><strong>성능·하드웨어</strong>: GPU/SR-IOV/DPDK 등 특수 하드웨어 연동은 추가 드라이버·정책 필요.</li><li><strong>운영·관측</strong>: CI/CD 및 GitOps 로 배포 자동화, Prometheus/Grafana + tracing/로그로 SLI/SLO 기반 모니터링, 자동 롤백 규칙 (메트릭 기반).</li><li><strong>배포 패턴</strong>: 서비스 위험도에 따라 롤링·카나리·블루그린·A/B 중 선택, 트래픽 분배는 Ingress/LoadBalancer 혹은 서비스메시 (Envoy/Istio) 로 구현.</li></ul><p>실무에서 컨테이너화의 이점을 확실히 얻으려면 단순 도입에서 멈추지 말고 <strong>파이프라인·관측·보안·거버넌스</strong>를 함께 설계해야 한다. 수치 (비용·성능) 는 케이스 바이 케이스이며, 문서에선 &rsquo; 사례적 수치 &rsquo; 로 표기하거나 측정방법을 함께 제시하라.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>단계 / 운영주기</th><th>핵심 작업</th><th style=text-align:right>산출물 (예시)</th><th>책임 (권장)</th><th>수용 기준 / 완료 조건</th></tr></thead><tbody><tr><td>사전 준비 (1–2 개월)</td><td>조직 평가, 파일럿 선정, 교육 계획</td><td style=text-align:right>도입 계획서, 교육 커리큘럼</td><td>플랫폼 PO, 엔지니어링 매니저</td><td>파일럿 앱 선정 완료, 교육일정 확정</td></tr><tr><td>파일럿 구현 (2–3 개월)</td><td>런타임 구축, CI/CD, 기본 관측 도입</td><td style=text-align:right>Helm chart, CI 파이프라인, Prometheus 구성</td><td>플랫폼팀, Dev 팀</td><td>파일럿 서비스 무중단 배포·모니터링 확인</td></tr><tr><td>프로덕션 배포 (3–6 개월)</td><td>보안 정책, 오토스케일, DR 계획</td><td style=text-align:right>OPA 정책, HPA/VPA, 백업 절차</td><td>SRE/보안팀</td><td>보안 스캔 통과, DR 체크리스트 작성</td></tr><tr><td>최적화 (6 개월 +)</td><td>비용 최적화, 메시·멀티클러스터</td><td style=text-align:right>FinOps 리포트, 서비스 메시 구성</td><td>플랫폼팀, FinOps</td><td>TCO 개선 보고서, SLI 개선</td></tr><tr><td>일일 운영</td><td>클러스터·리소스 모니터링</td><td style=text-align:right>대시보드, 알람</td><td>SRE/Oncall</td><td>알람 정상 동작, 핵심 지표 정상 범위</td></tr><tr><td>주간 운영</td><td>취약점 스캔·용량 검토</td><td style=text-align:right>스캔 리포트, 용량 추정</td><td>SRE/Dev 팀</td><td>스캔 조치율, 용량 예측 정확도</td></tr><tr><td>월간 운영</td><td>DR 훈련·플랫폼 업그레이드</td><td style=text-align:right>DR 리허설 결과, 업그레이드 계획</td><td>플랫폼팀</td><td>DR 복구 성공 (시나리오별), 업그레이드 계획 승인</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th style=text-align:center>권장 기간</th><th>핵심 주제</th><th>학습 목표</th><th>실무 연관성</th></tr></thead><tbody><tr><td style=text-align:right>1 단계 (기초)</td><td style=text-align:center>1–3 개월</td><td>네임스페이스, cgroups, 이미지 레이어, Docker 기초</td><td>컨테이너 작동 원리 이해, 간단 이미지 빌드</td><td>문제 원인 분석·경량 이미지 설계</td></tr><tr><td style=text-align:right>2 단계 (구현·운영)</td><td style=text-align:center>2–4 개월</td><td>Dockerfile, 멀티스테이지, 레지스트리, k8s 기초 (Pod/Service/Deployment)</td><td>이미지 표준화·기본 k8s 배포 능력 확보</td><td>CI/CD 연계 배포, 개발→운영 일관성 확보</td></tr><tr><td style=text-align:right>3 단계 (자동화 운영)</td><td style=text-align:center>2–4 개월</td><td>CI/CD, GitOps(ArgoCD), HPA/VPA, 모니터링 (Prometheus)</td><td>자동화 파이프라인 구축, 기본 SLO 관측</td><td>반복 배포·토일 제거, 운영 안정화</td></tr><tr><td style=text-align:right>4 단계 (보안·최적화)</td><td style=text-align:center>2–4 개월</td><td>이미지 스캔·서명, seccomp/AppArmor, 리소스 튜닝, CSI</td><td>공급망 보안·런타임 보안·성능 최적화</td><td>프로덕션 보안·성능 비용 최적화</td></tr><tr><td style=text-align:right>5 단계 (고급·통합)</td><td style=text-align:center>3–6 개월</td><td>Service Mesh, eBPF/WASM, 멀티클라우드, SRE 실전</td><td>대규모 아키텍처 설계·SRE 운영</td><td>멀티리전·엣지·대규모 운영 전략 수립</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>항목</th><th style=text-align:right>중요도</th><th>학습 목표</th><th>실무 연관성</th><th>설명</th><th>추천 실습·평가</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>컨테이너 원리 (네임스페이스·cgroup)</td><td style=text-align:right>필수</td><td>격리·자원 제어 원리 숙지</td><td>문제 분석·성능 튜닝</td><td>리눅스 네임스페이스 종류 (PID/NET/MNT/USER) 와 cgroups 이해</td><td><code>unshare</code>, <code>cgcreate</code> 실습, 짧은 퀴즈</td></tr><tr><td style=text-align:right>1</td><td>이미지 구조·레이어</td><td style=text-align:right>필수</td><td>이미지 캐시·레이어 이해</td><td>빌드 최적화·캐시 활용</td><td>이미지 레이어와 스토리지 드라이버 개념</td><td><code>docker history</code>, 레이어 최적화 과제</td></tr><tr><td style=text-align:right>1</td><td>Docker 기본 명령</td><td style=text-align:right>필수</td><td>이미지 빌드·실행 능력</td><td>개발 환경 일상 업무</td><td>Dockerfile 작성, 볼륨·네트워크</td><td>간단 앱 Dockerize 과제</td></tr><tr><td style=text-align:right>2</td><td>Dockerfile(멀티스테이지)</td><td style=text-align:right>필수</td><td>경량·보안 이미지 빌드</td><td>프로덕션 이미지 관리</td><td>빌드 분리로 런타임 이미지 최소화</td><td>멀티스테이지 예제 빌드 과제</td></tr><tr><td style=text-align:right>2</td><td>레지스트리 운영·태깅</td><td style=text-align:right>필수</td><td>이미지 라이프사이클 관리</td><td>배포·스캐닝 파이프라인</td><td>private registry 설정, 태그 전략</td><td>Harbor/ECR 설정 실습</td></tr><tr><td style=text-align:right>2</td><td>Kubernetes 기본 (Pod/Deployment/Service)</td><td style=text-align:right>필수</td><td>k8s 리소스 이해·배포</td><td>운영 배포의 기초</td><td>Pod 스케줄링, Replica, Service 타입</td><td>minikube/k3s 에 앱 배포 과제</td></tr><tr><td style=text-align:right>2</td><td>영속성 (PV/PVC/StatefulSet)</td><td style=text-align:right>필수</td><td>상태 ful 서비스 운영</td><td>DB·상태 서비스 분리</td><td>PVC 바인딩, StatefulSet 특징</td><td>DB 컨테이너로 PVC 연결 실습</td></tr><tr><td style=text-align:right>3</td><td>CI/CD 파이프라인 (GitHub Actions 등)</td><td style=text-align:right>필수</td><td>빌드→테스트→배포 자동화</td><td>반복 배포·릴리즈 신뢰성</td><td>이미지 빌드 + 테스트 + 레지스트리 푸시</td><td>간단 CI 파이프라인 구축 실습</td></tr><tr><td style=text-align:right>3</td><td>GitOps(ArgoCD/Flux)</td><td style=text-align:right>권장</td><td>선언적 운영 자동화</td><td>변경 추적·롤백 용이</td><td>Git→클러스터 동기화 패턴</td><td>ArgoCD 로 앱 자동 동기화 과제</td></tr><tr><td style=text-align:right>3</td><td>모니터링 (Prometheus/Grafana)</td><td style=text-align:right>필수</td><td>메트릭 수집·대시보드</td><td>SLI/SLO 관측·알람</td><td>Exporter, Alertmanager 설정</td><td>기본 SLI 정의·알람 설정 실습</td></tr><tr><td style=text-align:right>3</td><td>오토스케일링 (HPA/VPA)</td><td style=text-align:right>권장</td><td>수평/수직 확장 이해</td><td>비용·성능 관리</td><td>메트릭 기반 스케일 정책</td><td>HPA 설정 및 부하 테스트</td></tr><tr><td style=text-align:right>4</td><td>이미지 공급망 보안 (Trivy, cosign)</td><td style=text-align:right>필수</td><td>취약점 스캔·서명</td><td>컴플라이언스·보안</td><td>스캔→차단/예외 정책 구성</td><td>CI 내 스캔 파이프라인 적용</td></tr><tr><td style=text-align:right>4</td><td>런타임 보안 (seccomp/AppArmor, rootless)</td><td style=text-align:right>필수</td><td>권한 최소화</td><td>런타임 격리 강화</td><td>프로파일 작성·제한 테스트</td><td>seccomp 적용·동작 확인</td></tr><tr><td style=text-align:right>4</td><td>네트워크 폴리시 (CNI: Calico/Cilium)</td><td style=text-align:right>권장</td><td>Pod 간 통신 제어</td><td>보안·세분화된 정책</td><td>네트워크 정책 작성·적용</td><td>Calico 로 네트워크폴리시 실습</td></tr><tr><td style=text-align:right>4</td><td>성능 튜닝 (리소스·IO)</td><td style=text-align:right>권장</td><td>병목 진단·최적화</td><td>비용·응답성 개선</td><td>CPU/메모리·IO 튜닝 기법</td><td>벤치마크·프로파일링 실습</td></tr><tr><td style=text-align:right>5</td><td>Service Mesh(Istio/Linkerd)</td><td style=text-align:right>선택</td><td>관측·트래픽관리·보안</td><td>복잡 MSA 관제</td><td>사이드카 패턴·mTLS·트래픽 제어</td><td>간단한 트래픽 라우팅 실습</td></tr><tr><td style=text-align:right>5</td><td>SRE·SLO 운영</td><td style=text-align:right>필수</td><td>에러예산 운영·대응</td><td>조직 수준 신뢰성 관리</td><td>SLI→SLO→SLI 모니터링 과정</td><td>SLO 정의·알람/자동화 정책 과제</td></tr><tr><td style=text-align:right>5</td><td>멀티클라우드·엣지 전략</td><td style=text-align:right>선택</td><td>클라우드 포탈·오케스트레이션</td><td>글로벌 분산 운영</td><td>클라우드 이식성·데이터 주권</td><td>간단한 멀티클러스터 실습</td></tr><tr><td style=text-align:right>5</td><td>최신 (ebpf/WASM/Supply Chain)</td><td style=text-align:right>선택</td><td>고급 관측·보안</td><td>고성능·공급망 보안</td><td>eBPF 기반 관측, SLSA 개념</td><td>eBPF 간단 예제, SBOM 생성 실습</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (표준 표기)</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심</td><td>컨테이너 (Container)</td><td>커널 공유 기반의 프로세스 격리 실행 단위</td><td>네임스페이스, Cgroup</td><td>애플리케이션 이식성·경량 배포</td></tr><tr><td>핵심</td><td>컨테이너 이미지 (Container Image)</td><td>종속성 포함 불변 패키지 (실행 단위)</td><td>Dockerfile, 레이어, 레지스트리</td><td>버전관리·롤백 가능한 배포 아티팩트</td></tr><tr><td>핵심</td><td>네임스페이스 (Namespace)</td><td>OS 수준 자원 분리 (프로세스·네트워크 등)</td><td>PID, NET, Mount</td><td>프로세스·네트워크 격리</td></tr><tr><td>핵심</td><td>제어 그룹 (Cgroup)</td><td>리소스 (CPU/메모리/I/O) 할당·제한</td><td>리소스 쿼터</td><td>리소스 제한·메트릭 수집</td></tr><tr><td>구현</td><td>Dockerfile (Dockerfile)</td><td>이미지 빌드 스크립트 선언문</td><td>FROM, RUN, COPY</td><td>CI 에서 이미지 자동 빌드</td></tr><tr><td>구현</td><td>OCI (Open Container Initiative, OCI)</td><td>컨테이너 이미지/런타임 표준</td><td>runc, image spec</td><td>표준 호환 이미지·런타임</td></tr><tr><td>구현</td><td>runc (runc)</td><td>OCI 런타임 레퍼런스 구현체</td><td>OCI runtime</td><td>런타임 레이어의 컨테이너 실행</td></tr><tr><td>구현</td><td>containerd (containerd)</td><td>컨테이너 런타임 데몬</td><td>CRI, runc</td><td>K8s 연동 런타임 엔진</td></tr><tr><td>구현</td><td>CRI-O (CRI-O)</td><td>Kubernetes CRI 구현체</td><td>CRI, containerd</td><td>K8s 전용 경량 런타임</td></tr><tr><td>구현</td><td>레지스트리 (Registry)</td><td>이미지 저장소 (푸시/풀)</td><td>Harbor, Docker Hub</td><td>이미지 배포·캐싱·레플리케이션</td></tr><tr><td>네트워크·스토리지</td><td>CNI (Container Network Interface)</td><td>컨테이너 네트워킹 플러그인 표준</td><td>Calico, Cilium, Flannel</td><td>네트워크 연결·정책 적용</td></tr><tr><td>네트워크·스토리지</td><td>CSI (Container Storage Interface)</td><td>컨테이너용 스토리지 플러그인 표준</td><td>EBS, Ceph, NFS</td><td>PV/PVC 동적 프로비저닝</td></tr><tr><td>네트워크·스토리지</td><td>Service (Kubernetes Service)</td><td>파드 집합에 대한 네트워크 추상화</td><td>ClusterIP, NodePort</td><td>서비스 디스커버리·로드밸런싱</td></tr><tr><td>네트워크·스토리지</td><td>Ingress (Ingress)</td><td>외부 트래픽 라우팅 엔드포인트</td><td>TLS, IngressController</td><td>외부 접근·TLS 종료</td></tr><tr><td>보안·공급망</td><td>SBOM (Software Bill of Materials, SBOM)</td><td>소프트웨어 구성 명세서</td><td>SPDX, Syft</td><td>규정 준수·취약점 추적</td></tr><tr><td>보안·공급망</td><td>이미지 스캔 (Image Scanning)</td><td>이미지 취약점 탐지</td><td>Trivy, Clair</td><td>CI 에서 취약점 차단</td></tr><tr><td>보안·공급망</td><td>이미지 서명 (Image Signing)</td><td>이미지 무결성·출처 검증</td><td>cosign, sigstore</td><td>신뢰할 수 있는 배포 보장</td></tr><tr><td>보안·공급망</td><td>시크릿 관리 (Secret / KMS)</td><td>민감정보 안전 저장·주입</td><td>Vault, AWS KMS</td><td>런타임 시 민감정보 주입</td></tr><tr><td>보안·공급망</td><td>정책 엔진 (OPA, Admission Controller)</td><td>배포 시 정책 강제 지점</td><td>Gatekeeper, Webhook</td><td>정책 기반 배포 통제</td></tr><tr><td>관측·운영</td><td>메트릭 수집 (Prometheus)</td><td>시계열 지표 수집·알람</td><td>Exporter</td><td>SLO·알람 기반 운영</td></tr><tr><td>관측·운영</td><td>분산 추적 (OpenTelemetry)</td><td>트레이스·메트릭·로그 표준화</td><td>Jaeger, Zipkin</td><td>원인 분석·추적</td></tr><tr><td>관측·운영</td><td>로깅 (Fluentd / ELK)</td><td>로그 수집·분석 플랫폼</td><td>Elasticsearch</td><td>포렌식·검색·대시보드</td></tr><tr><td>관측·운영</td><td>백업/복구 (Velero)</td><td>클러스터 리소스와 볼륨 백업·복구</td><td>Snapshot</td><td>재해복구 전략</td></tr><tr><td>오케스트레이션·고급</td><td>Kubernetes (Kubernetes)</td><td>컨테이너 오케스트레이터 표준</td><td>Pod, Deployment, CRD</td><td>배포·스케줄·셀프힐</td></tr><tr><td>오케스트레이션·고급</td><td>Pod (Pod)</td><td>K8s 의 최소 배포 단위 (컨테이너 그룹)</td><td>컨테이너, Volume</td><td>애플리케이션 실행 단위</td></tr><tr><td>오케스트레이션·고급</td><td>Operator (Operator)</td><td>애플리케이션별 자동화 컨트롤러</td><td>CRD, Controller</td><td>복잡 서비스 운영 자동화</td></tr><tr><td>오케스트레이션·고급</td><td>서비스 메시 (Service Mesh)</td><td>사이드카 기반 통신·정책·관측</td><td>Istio, Linkerd</td><td>mTLS·트래픽 제어·관측</td></tr><tr><td>오케스트레이션·고급</td><td>HPA / VPA (Horizontal/Vertical Pod Autoscaler)</td><td>수평/수직 자동 스케일링</td><td>Metrics Server</td><td>트래픽 기반 스케일링</td></tr><tr><td>보안·관측</td><td>런타임 탐지 (Falco)</td><td>런타임 이상행동 탐지 · 룰 기반</td><td>eBPF</td><td>침해 조기탐지·포렌식</td></tr><tr><td>구현·대체</td><td>Podman (Podman)</td><td>daemonless 컨테이너 도구</td><td>Docker 대안</td><td>로컬 개발·루트리스 실행</td></tr><tr><td>보안·격리</td><td>샌드박스 런타임 (gVisor / Kata)</td><td>사용자 공간 격리 또는 VM 기반 격리</td><td>보안 강화</td><td>호스트 보호 (컨테이너 탈출 방지)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://kubernetes.io/docs/>Kubernetes 공식 문서</a></li><li><a href=https://kubernetes.io/blog/>Kubernetes 블로그</a></li><li><a href=https://docs.docker.com/>Docker 공식 문서</a></li><li><a href=https://www.docker.com/blog/>Docker 블로그</a></li><li><a href=https://opencontainers.org/>Open Container Initiative (OCI)</a></li><li><a href=https://www.cncf.io/>Cloud Native Computing Foundation (CNCF)</a></li><li><a href=https://research.google/pubs/pub45406/>Design patterns for container-based distributed systems (Google 연구)</a></li><li><a href=https://csrc.nist.gov/publications/detail/sp/800-190/final>NIST SP 800-190 (Application Container Security Guide)</a></li><li><a href=https://www.cncf.co.kr/ebook/kubernetes/part-1-introduction-to-cloud-native-and-containers/chapter-2-understanding-and-utilizing-container-technology/2-1-background-of-container-technology/2-1-3-necessity-and-benefits-of-containerization/>CNCF 한국 eBook — 컨테이너화 필요성 및 장점</a></li><li><a href=https://www.ibm.com/kr-ko/think/insights/six-keys-to-achieving-advanced-container-monitoring>IBM — 컨테이너 모니터링</a></li><li><a href=https://wikidocs.net/256777>Wikidocs — Docker 입문 실습</a></li><li><a href=https://www.openmaru.io/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%86%8C%EA%B0%9C/>OpenMaru — 컨테이너 필요성 소개</a></li><li><a href=https://www.checkpoint.com/kr/cyber-hub/cloud-security/what-is-container-security/what-is-containerization/>Check Point — 컨테이너화와 보안</a></li><li><a href=https://www.cello-square.com/kr/blog/view-1588.do>Cello Square — 컨테이너 시장 동향</a></li><li><a href=https://docs.redhat.com/ko/documentation/openshift_container_platform/4.8/html/architecture/architecture>Red Hat — OpenShift Container Platform 아키텍처 (문서)</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>