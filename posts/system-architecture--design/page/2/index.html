<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Architecture & Design | hyunyoun's Blog</title><meta name=keywords content="System-Architecture-and-Design"><meta name=description content="System Architecture & Design - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System Architecture & Design"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System Architecture & Design"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Architecture \u0026 Design","item":"https://buenhyden.github.io/posts/system-architecture--design/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>System Architecture & Design</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Synchronous Execution</h2></header><div class=entry-content><p>Synchronous Execution 동기 실행은 각 작업이 완료된 뒤 다음 작업이 시작되는 순차적 모델로, 흐름이 단순하고 예측 가능해 디버깅·검증·일관성에 유리하다.
트랜잭션 처리, 배치/이관, 초기화·종료 루틴처럼 정확한 순서와 원자성이 중요한 영역에 적합하다.
다만 장시간 I/O 나 외부 호출이 포함되면 전체 경로가 대기하며 자원 활용과 확장성이 떨어질 수 있다.
실무에서는 핵심 경계는 동기로 단순화하고, 지연이 큰 단계는 비동기 위임(큐·워커) 으로 분리하며, 타임아웃·재시도·멱등성을 더해 신뢰성과 성능을 함께 달성하는 혼합 설계가 권장된다.
핵심 개념 동기는 예측·검증·정합성을 극대화하는 대신, 대기 시간 누수와 자원 낭비 위험이 있으므로, 경계 분리와 풀/타임아웃 관리가 필수 관점 필수 개념 설명 실무 포인트 이론 순차성/차단 선형 실행·앞 작업 완료 대기 테스트·검증 용이, 처리량 한계 존재 이론 결정성 동일 입력→동일 결과·경로 재현성·회귀 테스트 강점 이론 HoL Blocking 선두 지연 전파 큐/배치 설계 시 주의 실무 트랜잭션/롤백 ACID 흐름에 적합 DB 트랜잭션 경계 최소화 실무 스레드/커넥션 풀 Thread-per-Request 최대 동시성=풀 크기 한계 실무 타임아웃/재시도 느린 리소스 보호 지수 백오프·재시도 예산 기본 동기 호출 패턴 파일/DB/HTTP 요청 동기 처리 명확한 오류 전파/로그 심화 동기↔비동기 경계 병목 국지화 외연 I/O 는 비동기·큐로 분리 심화 관측성/배압 큐 지연·p95·에러율 스로틀/Admission Control 실무 구현 연관성 및 적용 방식 언제 동기로? 순서/정합성·예측가능성이 최우선 (결제, 정산, 재무 배치). 어떻게 병목을 피하나? 풀 사이징 + 타임아웃 + 경계 분리 + 큐 완충. 혼합 패턴: 핵심 크리티컬 섹션은 동기 트랜잭션, 외부 호출/느린 I/O 는 비동기 큐로 오프로딩. 상황 권장 접근 구현 포인트 체크 지표 DB 트랜잭션 처리 동기 짧은 트랜잭션, 커넥션 풀 상한 트랜잭션 시간, 풀 점유율 초기화/부트스트랩 동기 의존 순서 명시, 실패시 페일패스트 부트 시간, 실패 로그 순차 검증 파이프라인 동기 단계 실패 시 즉시 중단/롤백 단계별 실패율 외부 API 연계 (지연 큼) 비동기 경계로 분리 큐·워크플로, 타임아웃/재시도 큐 체류시간, 재시도율 고동시성 읽기 (Report) 비동기/캐시 Read-through 캐시, 배압 히트율, p95 지연 CLI/배치 작업 동기 일괄 처리 + 장애 시 롤백 처리량, 실패시 재처리 동기 실행이 중요한 대표 사례 주문/결제/재고/배송 등 중요한 상태 변화를 수반하는 트랜잭션 실행 순서가 비즈니스상 매우 중요할 때 (재고 차감 후 결제 X - 결제 성공 후 재고 차감 O) 시스템 초기화, 데이터 마이그레이션, 백업 등 일괄 처리 동기 실행과 비동기 실행 비교 항목 동기 실행 (Synchronous) 비동기 실행 (Asynchronous) 처리 흐름 순차적, blocking 병렬, non-blocking 예측 가능성 높음 낮을 수 있음 확장성 낮음 높음 복잡도 낮음 높음 디버깅 용이성 상대적으로 쉬움 복잡, 상태 추적 어려움 실무 적용 예시 트랜잭션, 준비/정리 작업, 초기화, 배치 처리 등 실시간 알림, 대용량 일괄 처리, 비동기 API 등 병목 발생 비교적 쉽게 발생 분담 처리로 병목 완화 가능 기초 개념 (Foundation Understanding) 개념 정의 및 본질적 이해 동기 실행 (Synchronous Execution) 은 작업이 순차적으로 진행되어 이전 작업이 완료된 후에야 다음 작업이 시작되는 실행 모델이다.
이 과정에서 프로그램은 작성된 순서를 그대로 따라가며, 동일한 입력에 대해 항상 동일한 실행 순서와 결과를 보장한다. 본질적 특성은 차단성 (Blocking), 순차성 (Sequential), 결정론성 (Deterministic) 이며, 이러한 구조는 상태 의존성이 큰 로직에서 안정성과 예측 가능성을 제공한다. 다만 I/O·네트워크 지연 시 자원이 유휴 상태가 되어 전체 성능이 저하될 수 있다.
...</p></div><footer class=entry-footer><span title='2025-08-05 08:02:00 +0000 UTC'>August 5, 2025</span>&nbsp;·&nbsp;73 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous Execution" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/execution-strategies/synchronous-execution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Asynchronous Execution</h2></header><div class=entry-content><p>Asynchronous Execution 비동기 실행은 요청한 작업이 완료되기를 기다리지 않고 여러 작업을 병행 처리하는 실행 모델로, CPU·I/O 자원을 효율적으로 활용해 응답성과 처리량을 높인다.
네트워크 호출, 파일 입출력, UI 이벤트 처리 등 지연이 발생하는 작업에서 효과적이며, 콜백, 프로미스, async/await, 코루틴, 이벤트 루프, 메시지 큐 등 다양한 방식으로 구현된다.
JavaScript(Event Loop), Python(asyncio), Java(CompletableFuture), Go(goroutine), Kotlin(coroutine) 등 언어별 지원이 광범위하다.
구성 요소는 이벤트 루프, 워커 풀, completion handler 등이 있으며, 반응형 시스템, 마이크로서비스, 분산 아키텍처에서 성능과 확장성을 극대화한다. 단, 동시성 제어 복잡성과 오류 처리 난이도가 수반된다.
...</p></div><footer class=entry-footer><span title='2025-08-05 08:01:00 +0000 UTC'>August 5, 2025</span>&nbsp;·&nbsp;80 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asynchronous Execution" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/execution-strategies/asynchronous-execution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Object Pooling</h2></header><div class=entry-content><p>Object Pooling Object Pool 은 객체 생성·파괴 비용이 높고, 재사용 가능한 객체가 많은 상황에서 성능과 메모리 효율을 위해 활용하는 디자인 패턴이다. 프레임워크나 라이브러리 수준에서 DB 커넥션, 스레드, 게임용 그래픽 객체 등을 미리 할당해 두고 클라이언트 요청 시 재활용한다. 내부적으로는 객체 수명 관리, 동기화, 재설정 (clean-up) 등을 담당하는 구조를 가지며, 동시성 환경에서의 안전성을 확보하기 위한 lock 또는 blocking queue 구현이 필요하다.
핵심 개념 Object Pooling(오브젝트 풀링): 객체 생성 비용이 큰 경우, 미리 객체를 생성해 풀에 저장하고 필요할 때마다 재사용하는 기법. 풀 (Pool): 재사용 가능한 객체들이 저장되는 공간. 객체 대여/반환: 필요 시 풀에서 객체를 꺼내 사용하고, 사용이 끝나면 다시 풀에 반환. 생성/소멸 오버헤드 감소: 객체 생성/소멸 비용이 큰 경우 성능 저하를 막음. 리소스 효율화: 메모리, 네트워크, 파일 등 리소스 사용 최적화. 상태 초기화 (Reset/Clean-up): 반환 시 객체 내부 상태를 초기화하여 다음 사용을 안전하게 보장. 최대 풀 크기 관리: 필요한 경우 pool 제한, 초과 시 대기·예외 처리. 동시성 제어: 멀티스레드 환경에서 race 조건 방지를 위한 동기화가 필수. 실무 연관성 실무에서는 데이터베이스 커넥션, 스레드, 네트워크 소켓 등 생성/소멸 비용이 큰 리소스 관리에 오브젝트 풀링이 필수적으로 사용된다. 이를 통해 시스템의 응답성, 확장성, 안정성을 높이고, 불필요한 메모리 낭비와 GC 부담을 줄일 수 있다.
...</p></div><footer class=entry-footer><span title='2025-06-24 10:55:00 +0000 UTC'>June 24, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Object Pooling" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/algorithm--data-structures/object-pooling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Throttling</h2></header><div class=entry-content><p>Throttling API Throttling은 API 성능과 가용성을 최적화하기 위한 중요한 트래픽 관리 기법이다. 이는 시스템 자원을 보호하고 서비스의 안정성을 유지하는 데 핵심적인 역할을 한다.
API Throttling의 기본 개념 API Throttling은 시스템이 처리할 수 있는 요청의 양을 제어하는 메커니즘이다. 이는 Rate Limiting과 유사하지만 약간의 차이가 있다. Rate Limiting이 주로 요청을 ‘거부’하는 데 중점을 둔다면, Throttling은 요청의 ‘처리 속도’를 조절하는 데 초점을 맞춘다.
쉽게 말해, Throttling은 트래픽이 과도하게 몰릴 때 시스템이 완전히 중단되거나 요청을 거부하는 대신, 요청 처리 속도를 늦추거나 대기열에 넣어 점진적으로 처리하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-03-09 16:28:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Throttling" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/throttling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting</h2></header><div class=entry-content><p>Rate Limiting API Rate Limiting은 시스템의 안정성과 보안을 유지하면서 공정한 리소스 분배를 보장하는 핵심 메커니즘이다.
Rate Limiting은 특정 시간 간격 동안 API에 대한 요청 수를 제한하는 기술이다. 쉽게 말해, 사용자나 클라이언트가 특정 시간 동안 보낼 수 있는 요청의 횟수에 상한선을 두는 것이다.
예를 들어, “1분당 최대 60회 요청” 또는 “1시간당 1000회 요청"과 같은 제한을 설정할 수 있다. 이러한 제한을 초과하면 API는 일반적으로 HTTP 429 상태 코드(“Too Many Requests”)를 반환하며 요청을 거부한다.
...</p></div><footer class=entry-footer><span title='2025-02-14 01:27:00 +0000 UTC'>February 14, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화 (Lazy Initialization) 4. 전체 개요 (250 자 내외) 지연 초기화는 성능 최적화를 위한 핵심 디자인 패턴으로, 객체 생성을 지연시켜 메모리 사용량을 줄이고 애플리케이션 시작 시간을 단축한다. 프록시 패턴을 활용한 구현, 스레드 안전성 보장, ORM 에서의 지연 로딩, 웹에서의 이미지 지연 로딩 등 다양한 영역에서 활용된다. 적절한 사용 시 성능 향상을 가져오지만, 잘못 사용하면 오히려 성능 저하를 일으킬 수 있어 신중한 적용이 필요하다. 단, 멀티스레드 환경의 동시 초기화 이슈와 디버깅 난이도 증가를 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;26 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/algorithm--data-structures/lazy-initialization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backpressure</h2></header><div class=entry-content><p>Back Pressure 1. 주제의 분류 적합성 “Back Pressure(배압)” 는 시스템 설계 (System Design) 에서 비동기 (Asynchronism) 및 흐름 제어 (Flow Control) 의 핵심 개념으로, “Computer Science and Engineering > System Design > Fundamentals > Asynchronism” 분류가 매우 적절합니다. 실제로 네트워크, 분산 시스템, 리액티브 프로그래밍 등 다양한 IT 인프라와 소프트웨어 아키텍처에서 필수적으로 다루는 기본 원리입니다 [1][2][3][15].
1. 주제 분류 검토 현재 분류: “Computer Science and Engineering” > “System Design” > “Fundamentals” > “Asynchronism”
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backpressure" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/backpressure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache-Aside</h2></header><div class=entry-content><p>Cache-Aside Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.
Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.
이 패턴은 “Lazy Loading” 또는 “Look Aside” 패턴으로도 알려져 있다.
Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside
동작 방식 애플리케이션이 데이터를 요청한다. 캐시를 먼저 확인한다. 캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다. 캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다. 데이터베이스에서 가져온 데이터를 캐시에 저장한다. 데이터를 애플리케이션에 반환한다. 구현 시 고려사항 캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다. TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다. 캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다. 동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다. 장점 성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다. 데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다. 유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다. 장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다. 단점 초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다. 데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다. 추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다. 사용 예시 동시성 처리와 오류 복구를 포함한 버전
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache-Aside" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/caching-strategies/cache-aside/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>N+1 문제 (N plus one problem)</h2></header><div class=entry-content><p>N+1 문제 (N plus One problem) 1단계: 기본 분석 및 검증 1. 대표 태그 생성 ORM (객체-관계 매핑, Object Relational Mapping) 데이터 접근 최적화 (Data Access Optimization) 성능 문제 (Performance Issue) 엔티티 관계 (Entity Relationship) 2. 분류 체계 검증 현재 분류 체계에서 “System Design > System Design Fundamentals > Middlewares > Data Access Middleware > ORMs"는 N+1 문제의 실무적 관점과 기술적 근거를 잘 반영합니다. N+1 문제는 ORM 기반 데이터 접근 계층에서 발생하는 성능 이슈로 가장 빈번하게 등장하므로 분류 체계는 적절합니다. 다만, 실제로는 “Database Systems > Performance Optimization > Query Optimization” 과도 밀접하므로 보완적으로 포함될 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-10-24 11:21:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;66 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to N+1 문제 (N plus one problem)" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/performance-antipatterns/database-antipatterns/n-plus-one-problem/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/system-architecture--design/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>