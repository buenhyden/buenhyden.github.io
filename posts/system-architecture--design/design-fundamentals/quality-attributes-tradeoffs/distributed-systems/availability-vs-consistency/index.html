<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Availability vs. Consistency | hyunyoun's Blog</title><meta name=keywords content="System-Design,Fundamentals,Availability-vs-Consistency"><meta name=description content="가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/quality-attributes-tradeoffs/distributed-systems/availability-vs-consistency/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/quality-attributes-tradeoffs/distributed-systems/availability-vs-consistency/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/quality-attributes-tradeoffs/distributed-systems/availability-vs-consistency/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/quality-attributes-tradeoffs/distributed-systems/availability-vs-consistency/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Availability vs. Consistency"><meta property="og:description" content="가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Availability vs. Consistency"><meta name=twitter:description content="가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Availability vs. Consistency","item":"https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/quality-attributes-tradeoffs/distributed-systems/availability-vs-consistency/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Availability vs. Consistency</h1><div class=post-description>가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다.</div></header><div class=post-content><h2 id=availability-vs-consistency>Availability vs. Consistency<a hidden class=anchor aria-hidden=true href=#availability-vs-consistency>#</a></h2><p>분산 시스템 설계에서 &ldquo;Availability(가용성)&rdquo; 과 &ldquo;Consistency(일관성)&rdquo; 는 동시에 완벽히 만족시키기 어려운 특성이다. 이는 CAP 정리에 의해 설명된다. 시스템 설계 시, 네트워크 분할 상황에서 어느 특성을 우선시할지 결정해야 하며, 이는 시스템의 목적과 요구사항에 따라 달라진다. 2025 년 현재 AI 기반 최적화와 서버리스 아키텍처의 발전으로 새로운 패러다임이 형성되고 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><p>가용성 (Availability)<br>가용성은 시스템이 서비스를 제공할 수 있는 능력을 의미한다. 분산 시스템에서 가용성이 높다는 것은 시스템의 일부가 실패하더라도 전체 시스템이 계속 작동하고 사용자 요청에 응답할 수 있음을 의미한다. 높은 가용성을 가진 시스템은 모든 작동 중인 노드가 항상 읽기 및 쓰기 요청에 응답할 수 있도록 보장한다.</p></li><li><p>일관성 (Consistency)<br>일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장하는 속성이다. 강한 일관성 (Strong Consistency) 을 가진 시스템에서는 데이터에 대한 업데이트가 발생한 후 모든 후속 읽기 작업이 업데이트된 값을 반환해야 한다. 이는 모든 노드가 항상 최신 데이터를 가지고 있어야 함을 의미한다.</p></li><li><p>Partition Tolerance(분할 허용성)<br>분산 시스템이 네트워크 분할(Partition) 상황에서도 계속 작동할 수 있는 능력을 의미한다. 네트워크 분할은 노드 간 통신이 단절되거나 지연되는 현상으로, 시스템의 일부가 격리되더라도 나머지 부분이 정상적으로 동작해야 함을 보장한다.</p></li><li><p>CAP 정리 (CAP Theorem)<br>CAP 정리는 2000 년 Eric Brewer 가 제안한 이론으로, 분산 시스템은 다음 세 가지 특성 중 동시에 두 가지만 보장할 수 있다고 주장한다:<br>1. <strong>일관성 (Consistency)</strong>: 모든 노드가 동시에 동일한 데이터를 볼 수 있음<br>2. <strong>가용성 (Availability)</strong>: 모든 요청이 성공 또는 실패 응답을 받음<br>3. <strong>분할 내성 (Partition Tolerance)</strong>: 네트워크 분할 (노드 간 통신 실패) 발생 시에도 시스템이 계속 작동함<br>실제 분산 환경에서는 네트워크 분할이 발생할 수 있기 때문에, 분할 내성 (P) 은 필수적으로 보장되어야 한다. 따라서 시스템 설계자는 일관성 (C) 과 가용성 (A) 중 하나를 선택해야 하는 상황에 직면한다.</p></li><li><p>네트워크 분할 (Network Partition)<br>네트워크 분할은 네트워크 장애로 인해 노드 간의 통신이 불가능해지는 상황을 의미한다. 이러한 상황에서 시스템은 다음과 같은 선택을 해야 한다:</p><ol><li>일관성을 우선시하여 일부 노드의 가용성을 포기 (CP 시스템)</li><li>가용성을 우선시하여 일시적으로 데이터 일관성을 포기 (AP 시스템)</li></ol></li><li><p>일관성 모델 (Consistency Models)<br>다양한 일관성 모델이 존재하며, 강한 일관성부터 약한 일관성까지 스펙트럼을 형성한다:</p><ol><li><strong>강한 일관성 (Strong Consistency)</strong>: 모든 읽기는 가장 최근의 쓰기를 반영</li><li><strong>결과적 일관성 (Eventual Consistency)</strong>: 일정 시간이 지나면 모든 노드가 동일한 데이터를 갖게 됨</li><li><strong>인과적 일관성 (Causal Consistency)</strong>: 인과 관계가 있는 작업들에 대해서만 일관성 보장</li><li><strong>세션 일관성 (Session Consistency)</strong>: 동일 세션 내에서만 일관성 보장</li></ol></li><li><p>ACID 와 BASE<br>데이터베이스 시스템은 일관성과 가용성에 대한 접근 방식에 따라 다음과 같이 분류된다:</p><ol><li><strong>ACID</strong>(원자성, 일관성, 격리성, 지속성): 강한 일관성을 중시하는 관계형 데이터베이스에서 주로 사용</li><li><strong>BASE</strong>(기본 가용성, 소프트 상태, 결과적 일관성): 가용성을 중시하는 NoSQL 데이터베이스에서 주로 사용</li></ol></li><li><p>PACELC 이론<br>CAP 정리를 확장한 PACELC 이론은 네트워크 분할 (P) 발생 시 일관성 (C) 과 가용성 (A) 중 선택해야 하며, 분할이 없을 때 (E) 는 대기 시간 (L) 과 일관성 (C) 중 선택해야 한다고 설명한다. 이는 시스템 설계 시 더 세밀한 트레이드오프를 고려할 수 있게 한다.</p></li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ol><li><p>분산 시스템 설계의 기본 원칙 제공<br>가용성과 일관성의 트레이드오프를 이해하는 것은 분산 시스템 설계의 기본 원칙이다. 이를 통해 시스템 설계자는 비즈니스 요구사항에 맞는 적절한 결정을 내릴 수 있다.</p></li><li><p>시스템 성능과 신뢰성 최적화<br>적절한 가용성과 일관성 균형을 찾음으로써 시스템의 성능과 신뢰성을 최적화할 수 있다. 비즈니스 상황에 따라 필요한 특성을 우선시하여 리소스를 효율적으로 활용할 수 있다.</p></li><li><p>확장 가능한 아키텍처 설계<br>분산 시스템의 확장성을 고려할 때, 가용성과 일관성의 균형은 핵심적인 결정 요소이다. 이를 이해함으로써 미래 성장에 대비한 확장 가능한 아키텍처를 설계할 수 있다.</p></li><li><p>비즈니스 요구사항 충족<br>다양한 비즈니스 도메인은 서로 다른 가용성과 일관성 요구사항을 가진다. 예를 들어, 금융 시스템은 일관성이 중요하지만, 소셜 미디어 플랫폼은 가용성이 더 중요할 수 있다.</p></li></ol><h3 id=핵심-개념-비교>핵심 개념 비교<a hidden class=anchor aria-hidden=true href=#핵심-개념-비교>#</a></h3><table><thead><tr><th>구분</th><th>가용성 (Availability)</th><th>일관성 (Consistency)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>모든 요청에 응답 보장</td><td>모든 노드의 데이터 동일성 보장</td></tr><tr><td><strong>우선순위</strong></td><td>시스템 접근성과 응답성</td><td>데이터 정확성과 무결성</td></tr><tr><td><strong>트레이드오프</strong></td><td>네트워크 분할 시 일시적 불일치 허용</td><td>분할 시 일부 서비스 중단 가능성</td></tr><tr><td><strong>측정 지표</strong></td><td>Uptime %, MTTR(Mean Time To Recovery)</td><td>복제 지연 시간, 데이터 정합성 검증 주기</td></tr><tr><td>복제 방식</td><td>비동기 복제 (성능 향상)</td><td>동기 복제 (정확성 보장)</td></tr><tr><td>장애 대응</td><td>서비스 유지 (일부 데이터 불일치 허용)</td><td>부분 서비스 중단 가능 (일관성 보장)</td></tr><tr><td>적합한 워크로드</td><td>읽기 위주 작업, 소셜 미디어, 콘텐츠 제공</td><td>금융 거래, 재고 관리, 예약 시스템</td></tr><tr><td>확장성</td><td>일반적으로 더 쉽게 수평 확장 가능</td><td>확장 시 일관성 보장이 더 복잡함</td></tr></tbody></table><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>가용성 (Availability)</th><th>일관성 (Consistency)</th></tr></thead><tbody><tr><td><strong>기능</strong></td><td>서비스 연속성</td><td>일부 장애 발생 시에도 전체 서비스 운영 유지</td><td>장애 발생 시 트랜잭션 일시 중단 가능</td></tr><tr><td></td><td>사용자 경험</td><td>빠른 응답 및 무중단 제공으로 만족도 향상</td><td>응답 속도보다 데이터 정확성이 우선</td></tr><tr><td></td><td>비즈니스 연속성</td><td>시스템 중단 시 손실 최소화</td><td>일관성 유지 위해 중단 발생 가능</td></tr><tr><td></td><td>시스템 확장성</td><td>다중 노드 활용으로 수평 확장 가능</td><td>확장 시 데이터 동기화의 복잡성 증가</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>가용성 (Availability)</th><th>일관성 (Consistency)</th></tr></thead><tbody><tr><td><strong>특징</strong></td><td>데이터 복제</td><td><strong>비동기 복제</strong> (속도 중시)</td><td><strong>동기 복제</strong> (일관성 중시)</td></tr><tr><td></td><td>장애 대응</td><td>무장애 전환 (Failover) 가능</td><td>장애 발생 시 일관성 보장 우선으로 응답 지연 가능</td></tr><tr><td></td><td>처리 방식</td><td><strong>비동기 처리</strong>로 빠른 응답 가능</td><td><strong>동기 처리</strong>로 데이터 정합성 보장</td></tr><tr><td></td><td>트랜잭션 관리</td><td>단순 트랜잭션 우선, 속도 우선</td><td>분산 트랜잭션, 쿼럼 기반 트랜잭션 처리</td></tr><tr><td></td><td>의사 결정 방식</td><td>가용성을 위해 다수 노드 응답 무시 가능</td><td><strong>쿼럼 기반 의사결정</strong>으로 정확도 확보</td></tr><tr><td></td><td>버전 관리</td><td>일반적으로 단순 복제 구조</td><td>버전 관리 및 충돌 해결 로직 필요</td></tr></tbody></table><h3 id=추가-비교-분석>추가 비교 분석<a hidden class=anchor aria-hidden=true href=#추가-비교-분석>#</a></h3><table><thead><tr><th>비교 항목</th><th><strong>가용성 우선 시스템 (AP)</strong></th><th><strong>일관성 우선 시스템 (CP)</strong></th></tr></thead><tbody><tr><td><strong>요청 응답 속도</strong></td><td>빠름–일부 노드에서 응답을 반환 가능</td><td>느림–모든 노드의 응답을 기다려야 함</td></tr><tr><td><strong>데이터 정확성</strong></td><td>낮음–일정 시간 후 일관성 확보 (Eventual Consistency)</td><td>높음–항상 최신 상태의 데이터 제공</td></tr><tr><td><strong>데이터 복구 전략</strong></td><td>단순–충돌 해결 로직만 필요</td><td>복잡–롤백, 트랜잭션 재처리 필요</td></tr><tr><td><strong>개발 복잡도</strong></td><td>중간–충돌 해결 방식 설계 필요</td><td>높음–분산 트랜잭션, 정족수 알고리즘 필요</td></tr><tr><td><strong>합의 알고리즘 사용 유무</strong></td><td>선택–일부 NoSQL 은 Eventually Consistent Replication 사용</td><td>필수–Paxos, Raft 등의 합의 알고리즘 필수</td></tr><tr><td><strong>일관성 모델 예시</strong></td><td>Eventual Consistency, Causal Consistency</td><td>Linearizable, Serializable</td></tr><tr><td><strong>적용 예시</strong></td><td>SNS 피드, 장바구니, IoT 상태 정보 등</td><td>은행 계좌 이체, 주문 처리 시스템 등</td></tr><tr><td><strong>장기 유지보수 용이성</strong></td><td>상태 충돌/복제 이슈로 디버깅 복잡 가능성 있음</td><td>상대적으로 안정적, 테스트 예측 용이</td></tr></tbody></table><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><h4 id=cap-정리-cap-theorem>CAP 정리 (CAP Theorem)<a hidden class=anchor aria-hidden=true href=#cap-정리-cap-theorem>#</a></h4><p>CAP 정리는 분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 분할 내성 (Partition Tolerance) 세 가지를 동시에 만족시킬 수 없다는 원칙이다.</p><p>네트워크 분할이 발생할 때, 시스템은 다음 중 하나를 선택해야 한다:</p><ol><li><strong>CP(일관성 + 분할 내성)</strong>: 일관성을 유지하기 위해 일부 노드의 가용성 포기</li><li><strong>AP(가용성 + 분할 내성)</strong>: 가용성을 유지하기 위해 일시적으로 일관성 약화</li><li><strong>CA(일관성 + 가용성)</strong>: 실제 분산 환경에서는 네트워크 분할이 불가피하므로 이론적으로만 가능</li></ol><p><strong>CAP 정리 적용 예시</strong></p><ul><li><p>CP 시스템 동작 원리</p><ol><li>네트워크 분할 발생 시 소수 파티션의 노드는 쓰기 작업을 거부</li><li>다수 파티션에서만 쓰기 허용</li><li>분할이 해결되면 동기화 진행</li></ol></li><li><p>AP 시스템 동작 원리</p><ol><li>네트워크 분할 발생 시 모든 노드에서 계속 읽기/쓰기 허용</li><li>분할 기간 동안 노드 간 데이터 불일치 발생</li><li>분할이 해결되면 충돌 해결 메커니즘을 통해 일관성 회복</li></ol></li></ul><h4 id=pacelc-이론>PACELC 이론<a hidden class=anchor aria-hidden=true href=#pacelc-이론>#</a></h4><p>PACELC 이론은 CAP 정리를 확장한 개념으로, 네트워크 분할 상황과 정상 상황을 모두 고려한다:</p><ul><li><strong>P</strong>: 네트워크 분할 발생 시<ul><li><strong>A vs C</strong>: 가용성과 일관성 중 선택</li></ul></li><li><strong>E</strong>: 네트워크가 정상일 때<ul><li><strong>L vs C</strong>: 지연 시간 (Latency) 과 일관성 중 선택</li></ul></li></ul><p>이 이론은 분할이 발생하지 않는 일반적인, 정상 상황에서도 트레이드오프가 존재함을 명시한다.</p><table><thead><tr><th>구성 요소</th><th>설명</th></tr></thead><tbody><tr><td><strong>P</strong> (Partition)</td><td>네트워크 분할이 발생할 경우</td></tr><tr><td><strong>A</strong> (Availability)</td><td>분할 시 가용성을 선택하는 시스템</td></tr><tr><td><strong>C</strong> (Consistency)</td><td>분할 시 일관성을 선택하는 시스템</td></tr><tr><td><strong>E</strong> (Else)</td><td>네트워크 분할이 없을 경우</td></tr><tr><td><strong>L</strong> (Latency)</td><td>평상시 지연 시간을 최소화하는 시스템</td></tr><tr><td><strong>C</strong> (Consistency)</td><td>평상시에도 일관성을 유지하는 시스템</td></tr></tbody></table><p><strong>즉, PACELC 는 다음과 같은 의미를 가짐</strong>:</p><blockquote><p>&ldquo;If a partition occurs (P), then the system must choose between Availability (A) and Consistency (C); Else (E), when the system is running normally, it must choose between Latency (L) and Consistency (C).&rdquo;</p></blockquote><p><strong>PACELC 기반 비교 분석</strong></p><table><thead><tr><th>비교 항목</th><th><strong>PA/EL 시스템</strong></th><th><strong>PC/EC 시스템</strong></th></tr></thead><tbody><tr><td><strong>분할 시 처리</strong></td><td>가용성 유지, 일부 데이터 불일치 감수</td><td>응답 거부하고도 일관성 유지</td></tr><tr><td><strong>평상시 처리 방식</strong></td><td>응답 속도 (지연 시간) 최소화</td><td>항상 강한 일관성 보장</td></tr><tr><td><strong>데이터 일관성 모델</strong></td><td>Eventually Consistent 또는 Tunable Consistency 사용</td><td>Strong 또는 Serializability 일관성 유지</td></tr><tr><td><strong>읽기/쓰기 정족수</strong></td><td>조정 가능 (예: W + R > N 규칙)</td><td>읽기/쓰기 시 모두 합의 필요</td></tr><tr><td><strong>적합한 사용 시나리오</strong></td><td>SNS 피드, IoT 데이터 수집, 대용량 로깅</td><td>금융 거래, 결제 시스템, 병렬 트랜잭션이 많은 시스템</td></tr><tr><td><strong>주요 트레이드오프</strong></td><td>데이터 정확성 ↔ 빠른 응답성</td><td>성능 ↔ 정확성</td></tr><tr><td><strong>대표 기술</strong></td><td>Cassandra, DynamoDB, Couchbase</td><td>Spanner, HBase, FaunaDB</td></tr></tbody></table><ul><li>PACELC 이론은 <strong>CAP 의 한계</strong>를 보완하여, <strong>시스템이 정상 상태일 때의 선택 기준까지 포함</strong>하므로 더 정밀한 설계 판단에 유리하다.</li><li><strong>Latency-Sensitive 서비스</strong>(예: 채팅, 검색, IoT) 는 PA/EL 이 적합하다.</li><li><strong>Strong Consistency 가 요구되는 서비스</strong>(예: 금융, 재고, 주문 시스템) 는 PC/EC 기반 설계가 필요하다.</li><li><strong>Tunable Consistency</strong> 옵션을 제공하는 Cassandra 나 DynamoDB 같은 시스템을 활용하면 상황에 맞는 유연한 전략 수립이 가능하다.</li></ul><h4 id=데이터-일관성-모델>데이터 일관성 모델<a hidden class=anchor aria-hidden=true href=#데이터-일관성-모델>#</a></h4><ol><li><strong>강한 일관성 (Strong Consistency)</strong>:<ul><li>모든 읽기 작업은 가장 최신의 쓰기 작업을 반영</li><li>예: 관계형 데이터베이스 (MySQL, PostgreSQL)</li></ul></li><li><strong>약한 일관성 (Weak Consistency)</strong>:<ul><li>읽기 작업이 최신 업데이트를 반영하지 않을 수 있음</li><li>예: 메모리 캐시 (Redis, Memcached)</li></ul></li><li><strong>결과적 일관성 (Eventual Consistency)</strong>:<ul><li>일정 시간이 지나면 모든 노드가 동일한 데이터 상태를 가짐</li><li>예: DynamoDB, Cassandra</li></ul></li><li><strong>인과적 일관성 (Causal Consistency)</strong>:<ul><li>인과 관계가 있는 작업에 대해서만 일관성 보장</li><li>예: MongoDB 의 인과적 일관성 세션</li></ul></li></ol><h4 id=acid-vs-base>ACID vs. BASE<a hidden class=anchor aria-hidden=true href=#acid-vs-base>#</a></h4><table><thead><tr><th>ACID</th><th>BASE</th></tr></thead><tbody><tr><td><strong>A</strong>tomicity (원자성)</td><td><strong>B</strong>asically <strong>A</strong>vailable (기본 가용성)</td></tr><tr><td><strong>C</strong>onsistency (일관성)</td><td><strong>S</strong>oft state (소프트 상태)</td></tr><tr><td><strong>I</strong>solation (격리성)</td><td><strong>E</strong>ventual consistency (결과적 일관성)</td></tr><tr><td><strong>D</strong>urability (지속성)</td><td></td></tr></tbody></table><ul><li><strong>ACID</strong>: 전통적인 관계형 데이터베이스가 따르는 트랜잭션 특성으로, 강한 일관성 보장</li><li><strong>BASE</strong>: NoSQL 데이터베이스가 따르는 특성으로, 가용성과 성능 우선</li></ul><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><h4 id=분산-시스템에서의-일관성-유지-메커니즘>분산 시스템에서의 일관성 유지 메커니즘<a hidden class=anchor aria-hidden=true href=#분산-시스템에서의-일관성-유지-메커니즘>#</a></h4><ul><li><p>합의 알고리즘 (Consensus Algorithms)<br>분산 시스템에서 노드 간 합의를 이루기 위한 알고리즘:</p><ol><li><strong>Paxos</strong>: 비동기 네트워크에서 노드 간 합의를 이루는 알고리즘</li><li><strong>Raft</strong>: Paxos 보다 이해하기 쉽게 설계된 합의 알고리즘</li><li><strong>Byzantine Fault Tolerance(BFT)</strong>: 악의적인 노드가 존재하는 환경에서도 합의를 이루는 알고리즘</li></ol></li><li><p>쿼럼 (Quorum) 기반 시스템<br>쿼럼은 분산 시스템에서 최소한의 동의 수준을 정의한다:</p><ul><li><strong>쓰기 쿼럼 (W)</strong>: 쓰기 작업이 성공하기 위해 필요한 노드 수</li><li><strong>읽기 쿼럼 (R)</strong>: 읽기 작업이 성공하기 위해 필요한 노드 수</li><li><strong>총 노드 수 (N)</strong>: 시스템의 총 노드 수<br>일관성 보장을 위해서는 W + R > N 조건을 만족해야 한다.</li></ul></li><li><p>복제 전략 (Replication Strategies)</p><ol><li><strong>동기식 복제 (Synchronous Replication)</strong>:<ul><li>모든 복제본이 업데이트될 때까지 클라이언트에 응답하지 않음</li><li>강한 일관성 보장, 높은 지연 시간</li></ul></li><li><strong>비동기식 복제 (Asynchronous Replication)</strong>:<ul><li>주 노드가 업데이트되면 클라이언트에 즉시 응답</li><li>복제는 백그라운드에서 진행</li><li>낮은 지연 시간, 일관성 약화</li></ul></li></ol></li></ul><h4 id=가용성-보장-메커니즘>가용성 보장 메커니즘<a hidden class=anchor aria-hidden=true href=#가용성-보장-메커니즘>#</a></h4><ul><li><p>다중화 (Redundancy)<br>시스템 구성 요소를 중복으로 배치하여 장애에 대비한다:</p><ol><li><strong>데이터 중복</strong>: 여러 노드에 동일한 데이터 저장</li><li><strong>서비스 중복</strong>: 동일한 서비스를 여러 인스턴스로 실행</li></ol></li><li><p>장애 감지 및 복구 (Failure Detection and Recovery)</p><ol><li><strong>하트비트 (Heartbeat)</strong>: 노드 간 주기적으로 신호를 주고받아 상태 확인</li><li><strong>타임아웃 (Timeout)</strong>: 일정 시간 응답이 없으면 장애로 판단</li><li><strong>자동 복구 (Auto-recovery)</strong>: 장애 발생 시 자동으로 시스템 복구</li></ol></li><li><p>부하 분산 (Load Balancing)<br>요청을 여러 노드에 분산시켜 가용성과 성능을 향상시킨다:</p><ol><li><strong>라운드 로빈 (Round Robin)</strong>: 순차적으로 노드에 요청 할당</li><li><strong>최소 연결 (Least Connection)</strong>: 연결 수가 가장 적은 노드에 요청 할당</li><li><strong>일관된 해싱 (Consistent Hashing)</strong>: 노드 추가/제거 시 재분배를 최소화</li></ol></li></ul><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=cp일관성--분할-내성-시스템-아키텍처>CP(일관성 + 분할 내성) 시스템 아키텍처<a hidden class=anchor aria-hidden=true href=#cp일관성--분할-내성-시스템-아키텍처>#</a></h4><p>CP 시스템은 일관성을 우선시하며, 네트워크 분할 발생 시 가용성을 희생한다.</p><p><strong>주요 특징</strong></p><ol><li><strong>마스터 - 슬레이브 구조</strong>: 쓰기 작업은 마스터 노드에서만 처리</li><li><strong>동기식 복제</strong>: 대부분의 노드가 데이터를 복제한 후에야 트랜잭션 완료</li><li><strong>강한 일관성 모델</strong>: 모든 노드가 항상 동일한 데이터 상태를 유지</li><li><strong>쿼럼 기반 의사 결정</strong>: 노드 다수의 동의를 필요로 함</li></ol><p><strong>대표적인 CP 시스템</strong></p><ul><li><strong>ZooKeeper</strong>: 분산 조정 서비스</li><li><strong>HBase</strong>: 분산 컬럼형 데이터베이스</li><li><strong>etcd</strong>: 분산 키 - 값 저장소</li><li><strong>MongoDB(기본 설정)</strong>: 문서 지향 데이터베이스</li></ul><p><strong>아키텍처 구성 요소</strong></p><ol><li><strong>합의 관리자 (Consensus Manager)</strong>: Paxos, Raft 등의 합의 알고리즘 구현</li><li><strong>상태 복제기 (State Replicator)</strong>: 노드 간 상태 복제 담당</li><li><strong>로그 관리자 (Log Manager)</strong>: 작업 로그 관리 및 재생</li><li><strong>장애 감지기 (Failure Detector)</strong>: 노드 상태 모니터링</li></ol><h4 id=ap가용성--분할-내성-시스템-아키텍처>AP(가용성 + 분할 내성) 시스템 아키텍처<a hidden class=anchor aria-hidden=true href=#ap가용성--분할-내성-시스템-아키텍처>#</a></h4><p>AP 시스템은 가용성을 우선시하며, 네트워크 분할 발생 시 일관성을 희생한다.</p><p><strong>주요 특징</strong></p><ol><li><strong>멀티 마스터 구조</strong>: 모든 노드가 읽기/쓰기 작업 처리 가능</li><li><strong>비동기식 복제</strong>: 로컬 노드에서 작업 완료 후 다른 노드로 비동기적 복제</li><li><strong>결과적 일관성 모델</strong>: 일정 시간 후에 모든 노드가 동일한 상태에 도달</li><li><strong>충돌 해결 메커니즘</strong>: 데이터 충돌 해결을 위한 벡터 클럭, 머지 등 활용</li></ol><p><strong>대표적인 AP 시스템</strong></p><ul><li><strong>Cassandra</strong>: 분산 NoSQL 데이터베이스</li><li><strong>DynamoDB(기본 설정)</strong>: AWS 의 관리형 NoSQL 데이터베이스</li><li><strong>Riak</strong>: 분산 키 - 값 저장소</li><li><strong>CouchDB</strong>: 문서 지향 데이터베이스</li></ul><p><strong>아키텍처 구성 요소</strong></p><ol><li><strong>안티 - 엔트로피 프로토콜 (Anti-entropy Protocol)</strong>: 노드 간 상태 동기화</li><li><strong>벡터 클럭 (Vector Clocks)</strong>: 이벤트 순서 추적 및 충돌 감지</li><li><strong>머지 해결기 (Merge Resolver)</strong>: 충돌 자동 해결</li><li><strong>가십 프로토콜 (Gossip Protocol)</strong>: 클러스터 멤버십 및 상태 정보 전파</li></ol><h4 id=ca일관성--가용성-시스템의-한계>CA(일관성 + 가용성) 시스템의 한계<a hidden class=anchor aria-hidden=true href=#ca일관성--가용성-시스템의-한계>#</a></h4><p>CA 시스템은 네트워크 분할에 대한 내성이 없으므로, 실제 분산 환경에서는 구현이 불가능하다. 그러나 네트워크 분할이 드물게 발생하는 환경에서는 CA 에 가까운 시스템을 구현할 수 있다.</p><p><strong>주요 특징</strong></p><ol><li><strong>단일 데이터 센터 내 배포</strong>: 네트워크 분할 가능성 최소화</li><li><strong>고가용성 네트워크 인프라</strong>: 중복 네트워크 연결</li><li><strong>로컬 복제</strong>: 지연 시간 최소화를 위한 로컬 복제</li><li><strong>장애 조치 메커니즘</strong>: 빠른 복구를 위한 자동 장애 조치</li></ol><p><strong>예시</strong></p><ul><li><strong>단일 데이터 센터 내 MySQL 클러스터</strong></li><li><strong>로컬 네트워크의 PostgreSQL 복제 설정</strong></li></ul><h3 id=12-장점과-단점>12. 장점과 단점<a hidden class=anchor aria-hidden=true href=#12-장점과-단점>#</a></h3><h4 id=가용성-중심-ap-시스템>가용성 중심 (AP) 시스템<a hidden class=anchor aria-hidden=true href=#가용성-중심-ap-시스템>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>높은 가용성 - 시스템 일부에 장애가 발생해도 서비스 계속 제공</td><td>데이터 일관성 보장 어려움 - 일시적인 데이터 불일치 발생 가능</td></tr><tr><td>짧은 응답 시간 - 로컬 노드에서 즉시 응답 가능</td><td>복잡한 충돌 해결 - 네트워크 분할 후 데이터 충돌 발생 시 해결 필요</td></tr><tr><td>쉬운 수평 확장 - 노드 추가가 상대적으로 용이</td><td>복잡한 애플리케이션 로직 - 일관성이 보장되지 않는 환경을 고려한 설계 필요</td></tr><tr><td>높은 쓰기 성능 - 비동기식 복제로 인한 쓰기 지연 최소화</td><td>트랜잭션 처리 어려움 - ACID 트랜잭션 지원 제한적</td></tr><tr><td>지역적 장애 분리 - 일부 지역 장애가 전체에 영향을 미치지 않음</td><td>정확한 집계 및 분석 어려움 - 데이터 불일치로 인한 결과 정확도 문제</td></tr></tbody></table><h4 id=일관성-중심-cp-시스템>일관성 중심 (CP) 시스템<a hidden class=anchor aria-hidden=true href=#일관성-중심-cp-시스템>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>강한 데이터 일관성 - 모든 노드가 항상 동일한 데이터 상태 유지</td><td>네트워크 분할 시 가용성 저하 - 일부 노드에서 작업 거부 가능</td></tr><tr><td>트랜잭션 처리 용이 - ACID 속성 지원</td><td>상대적으로 높은 응답 지연 - 합의 과정으로 인한 지연 발생</td></tr><tr><td>비즈니스 로직 단순화 - 일관된 데이터 상태를 가정한 설계 가능</td><td>제한된 확장성 - 합의 알고리즘으로 인한 확장 제약</td></tr><tr><td>정확한 데이터 집계 및 분석 - 일관된 데이터로 정확한 결과 도출</td><td>더 많은 네트워크 트래픽 - 합의 과정에서 많은 메시지 교환 필요</td></tr><tr><td>감사 및 규정 준수 용이 - 일관된 상태 추적 가능</td><td>하드웨어 자원 요구 증가 - 동기화 작업으로 인한 자원 소모</td></tr></tbody></table><h3 id=강점과-약점>강점과 약점<a hidden class=anchor aria-hidden=true href=#강점과-약점>#</a></h3><table><thead><tr><th>특성</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>일관성 중심 시스템 (CP)</td><td>데이터 정확성 보장</td><td>응답 지연 및 가용성 저하 가능성</td></tr><tr><td>가용성 중심 시스템 (AP)</td><td>높은 응답성 및 가용성</td><td>데이터 불일치 및 일관성 저하 가능성</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>사용 사례</th><th>권장 접근법</th><th>이유</th><th>예시 기술</th></tr></thead><tbody><tr><td><strong>금융 거래 시스템</strong></td><td>CP (일관성 우선)</td><td>잘못된 거래나 중복 거래 방지가 중요</td><td>PostgreSQL, Google Spanner</td></tr><tr><td><strong>전자상거래 카탈로그</strong></td><td>AP (가용성 우선)</td><td>일시적 불일치보다 서비스 중단이 더 큰 문제</td><td>Cassandra, DynamoDB</td></tr><tr><td><strong>소셜 미디어 피드</strong></td><td>AP (가용성 우선)</td><td>모든 사용자에게 최신 데이터를 즉시 보여줄 필요 없음</td><td>Cassandra, Redis</td></tr><tr><td><strong>재고 관리 시스템</strong></td><td>CP (일관성 우선)</td><td>과잉 판매/재고 부족 방지가 중요</td><td>MySQL 클러스터, MongoDB (강한 일관성 설정)</td></tr><tr><td><strong>실시간 분석 시스템</strong></td><td>AP (가용성 우선)</td><td>대략적 결과도 허용 가능, 가용성이 더 중요</td><td>Elasticsearch, Cassandra</td></tr><tr><td><strong>게임 리더보드</strong></td><td>AP 또는 하이브리드</td><td>항상 최신 데이터가 필요하지 않으나 서비스는 지속되어야 함</td><td>Redis (가용성 설정), MongoDB</td></tr><tr><td><strong>결제 처리 시스템</strong></td><td>CP (일관성 우선)</td><td>정확한 금액 처리가 필수적</td><td>관계형 DB + 2 단계 커밋</td></tr><tr><td><strong>콘텐츠 전송 네트워크</strong></td><td>AP (가용성 우선)</td><td>콘텐츠 제공 가용성이 최우선</td><td>Redis, CloudFront + DynamoDB</td></tr><tr><td><strong>헬스케어 시스템</strong></td><td>CP 또는 하이브리드</td><td>환자 데이터는 정확해야 하지만 일부 기능은 가용성 우선</td><td>PostgreSQL(중요 데이터) + MongoDB(비중요 데이터)</td></tr><tr><td><strong>IoT 데이터 수집</strong></td><td>AP (가용성 우선)</td><td>대량의 데이터, 일부 손실 허용 가능</td><td>Apache Kafka, Cassandra</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><p>시스템의 각 구성 요소는 요구되는 특성에 따라 적절한 CAP 조합을 선택하여 구현된다.</p><h4 id=시나리오-설명>시나리오 설명<a hidden class=anchor aria-hidden=true href=#시나리오-설명>#</a></h4><p>온라인 쇼핑 플랫폼에서는 사용자 경험을 향상시키기 위해 장바구니 기능을 제공한다. 이 시스템은 다음과 같은 요구사항을 가진다:</p><ul><li><strong>가용성 (Availability)</strong>: 사용자는 언제든지 장바구니에 상품을 추가하거나 조회할 수 있어야 한다.</li><li><strong>일관성 (Consistency)</strong>: 결제 시점에는 장바구니의 상태가 정확하게 반영되어야 하며, 재고 부족 등의 문제가 없어야 한다.</li></ul><p>이러한 요구사항을 만족시키기 위해 시스템은 다음과 같은 전략을 채택한다:</p><ul><li><p><strong>AP 시스템</strong>: 상품을 장바구니에 추가하거나 조회하는 기능은 높은 가용성을 위해 AP(Availability and Partition Tolerance) 시스템으로 구현된다. 이로 인해 네트워크 분할이 발생하더라도 사용자는 장바구니 기능을 사용할 수 있다.</p></li><li><p><strong>CP 시스템</strong>: 결제 기능은 데이터의 일관성을 보장하기 위해 CP(Consistency and Partition Tolerance) 시스템으로 구현된다. 결제 시점에는 모든 데이터가 정확하게 반영되어야 하므로, 일관성을 우선시한다.</p></li></ul><h4 id=다이어그램>다이어그램<a hidden class=anchor aria-hidden=true href=#다이어그램>#</a></h4><p>아래 다이어그램은 온라인 쇼핑 플랫폼에서의 장바구니 시스템의 구성과 흐름을 나타낸다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[사용자]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[장바구니 서비스 (AP 시스템)]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[결제 서비스 (CP 시스템)]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[재고 관리 시스템]
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장바구니 서비스</strong>: 사용자의 상품 추가/조회 요청을 처리하며, 높은 가용성을 제공한다.</li><li><strong>결제 서비스</strong>: 결제 요청을 처리하며, 데이터의 일관성을 보장한다.</li><li><strong>재고 관리 시스템</strong>: 상품의 재고를 관리하며, 결제 시점에 재고를 확인한다.</li></ul><h4 id=이-사례에서-배울-수-있는-점>이 사례에서 배울 수 있는 점<a hidden class=anchor aria-hidden=true href=#이-사례에서-배울-수-있는-점>#</a></h4><ol><li><strong>도메인별 요구사항 분석</strong>: 모든 구성 요소에 동일한 접근 방식을 적용하지 않고, 각 도메인의 요구사항에 맞게 CP 와 AP 특성을 선택적으로 적용</li><li><strong>하이브리드 접근법</strong>: 단일 서비스 내에서도 데이터 중요도나 작업 유형에 따라 다른 일관성 모델 적용 가능</li><li><strong>비즈니스 영향 고려</strong>: 일관성과 가용성 중 어떤 것이 비즈니스에 더 중요한지 분석하여 결정</li><li><strong>사용자 경험 최적화</strong>: 사용자에게 직접 영향을 미치는 기능은 가용성을, 백엔드 처리는 일관성을 우선시</li><li><strong>복잡성 관리</strong>: 다양한 기술 스택 사용 시 운영 복잡성이 증가하므로 이를 관리하기 위한 전략 필요</li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><h4 id=단계별-고려사항>단계별 고려사항<a hidden class=anchor aria-hidden=true href=#단계별-고려사항>#</a></h4><table><thead><tr><th>단계</th><th>항목</th><th>주요 내용</th></tr></thead><tbody><tr><td><strong>요구사항 분석</strong></td><td>비즈니스 요구사항 명확화</td><td>데이터 정확성 vs. 서비스 연속성 우선순위 결정, 규제 및 컴플라이언스 요구사항 확인</td></tr><tr><td></td><td>데이터 특성 분석</td><td>데이터 중요도·민감도, 수명 주기, 액세스 패턴 분석</td></tr><tr><td></td><td>사용자 경험 요구사항</td><td>허용 가능한 지연 시간 정의, 장애 발생 시 기대 동작 정의</td></tr><tr><td><strong>설계</strong></td><td>일관성 모델 선택</td><td>강한 일관성 (금융 등), 결과적 일관성 (소셜 피드 등), 세션 일관성 (사용자별)</td></tr><tr><td></td><td>아키텍처 패턴 고려</td><td>CQRS, 이벤트 소싱, 사가 (Saga) 패턴 등 활용</td></tr><tr><td></td><td>데이터 파티셔닝 전략</td><td>지역 기반 파티셔닝, 기능 기반 파티셔닝으로 유연한 일관성 적용</td></tr><tr><td><strong>구현 및 운영</strong></td><td>장애 처리 전략</td><td>장애 감지 및 자동 복구, 네트워크 분할 시 동작 정의</td></tr><tr><td></td><td>모니터링 및 경고 시스템</td><td>복제 지연, 데이터 불일치, 네트워크 상태 실시간 모니터링</td></tr><tr><td></td><td>테스트 전략</td><td>카오스 엔지니어링, 네트워크 분할 테스트, 부하 테스트 도입</td></tr></tbody></table><h4 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h4><table><thead><tr><th>항목</th><th>주요 내용</th></tr></thead><tbody><tr><td>복잡성 관리</td><td>다양한 일관성 모델 사용 시 복잡성 증가, 문서화·교육 필수</td></tr><tr><td>데이터 불일치 해결</td><td>충돌 해결 로직 명확화, 애플리케이션 수준에서 해결 방안 설계</td></tr><tr><td>확장성 고려</td><td>미래 확장성을 고려한 설계, 일관성 모델 변경 비용 고려</td></tr><tr><td>운영 오버헤드</td><td>다양한 기술 스택 운영 복잡성, 모니터링·트러블슈팅 부담 증가</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><h4 id=고려사항>고려사항<a hidden class=anchor aria-hidden=true href=#고려사항>#</a></h4><table><thead><tr><th>구분</th><th>전략/항목</th><th>내용 요약</th></tr></thead><tbody><tr><td><strong>가용성 최적화</strong></td><td>분산 데이터 저장</td><td>지역 기반 데이터 센터 및 위치 기반 라우팅</td></tr><tr><td></td><td>캐싱 전략</td><td>다단계 캐시 계층화, 읽기 부하 감소, 캐시 무효화 전략 필요</td></tr><tr><td></td><td>비동기 처리</td><td>메시지 큐 활용, 응답 우선 처리로 사용자 체감 지연 감소</td></tr><tr><td></td><td>자동 확장</td><td>부하 기반 인프라 자동 확장 및 복구 전략</td></tr><tr><td><strong>일관성 최적화</strong></td><td>쿼럼 기반 접근법</td><td>읽기/쓰기 조합 조정 (예: W + R > N), 네트워크 조건 기반 설정</td></tr><tr><td></td><td>로컬 트랜잭션 활용</td><td>샤딩 및 데이터 배치 전략으로 트랜잭션 로컬화</td></tr><tr><td></td><td>데이터 지역성</td><td>데이터 접근 경로 최적화로 지연 시간 및 충돌 최소화</td></tr><tr><td></td><td>합의 알고리즘 튜닝</td><td>Paxos, Raft 등 알고리즘의 타임아웃, 재시도 등 성능 조정</td></tr><tr><td><strong>트레이드오프 최적화</strong></td><td>하이브리드 일관성 모델</td><td>데이터 유형/업무 성격에 따라 일관성 모델 구분 적용</td></tr><tr><td></td><td>일관성 수준 제어</td><td>클라이언트나 API 에서 일관성 수준 설정 기능 제공</td></tr><tr><td></td><td>비동기 복제 최적화</td><td>우선순위 큐, 복제 지연 감소 기법, 네트워크 트래픽 조절</td></tr><tr><td></td><td>데이터 샤딩 전략</td><td>균등한 샤딩 키 설계, 핫스팟 발생 방지를 위한 리밸런싱</td></tr></tbody></table><h4 id=주의사항-1>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항-1>#</a></h4><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>과도한 최적화 경계</td><td>시스템 복잡도와 유지보수 가능성을 고려한 균형 유지</td></tr><tr><td>일관성 착각 방지</td><td>완벽한 일관성 가정 금지, 엣지 케이스 검증 철저히 수행</td></tr><tr><td>성능 테스트</td><td>장애 조건 및 피크 부하 환경에서의 검증 필수</td></tr><tr><td>자원 사용 효율성</td><td>리소스 활용도 모니터링, 동기화 최소화 및 리팩토링 고려</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>동향</th><th>설명</th><th>관련 기술</th></tr></thead><tbody><tr><td><strong>다중 영역 데이터베이스</strong></td><td>여러 지역에 걸쳐 데이터를 분산하면서도 일관성 관리를 개선한 데이터베이스</td><td>Google Spanner, CockroachDB, YugabyteDB</td></tr><tr><td><strong>양자화된 일관성 모델</strong></td><td>일관성 수준을 세밀하게 조정할 수 있는 새로운 모델</td><td>FaunaDB, MongoDB 5.0+</td></tr><tr><td><strong>에지 - 클라우드 하이브리드 아키텍처</strong></td><td>에지 컴퓨팅과 중앙 클라우드를 결합한 하이브리드 접근법</td><td>AWS Wavelength, Azure Edge Zones</td></tr><tr><td><strong>자율 데이터베이스</strong></td><td>AI 를 활용하여 일관성과 가용성 간 균형을 자동으로 조정</td><td>Oracle Autonomous DB, MongoDB Atlas</td></tr><tr><td><strong>서버리스 데이터베이스</strong></td><td>일관성과 가용성을 관리하는 복잡성을 추상화한 서버리스 솔루션</td><td>AWS Aurora Serverless, Fauna, Planetscale</td></tr><tr><td><strong>CRDT 의 주류화</strong></td><td>충돌 없는 데이터 유형이 분산 시스템에서 널리 채택됨</td><td>Redis Enterprise, Riak, Ditto</td></tr><tr><td><strong>블록체인 영감 합의 알고리즘</strong></td><td>블록체인 기술에서 영감을 받은 새로운 분산 합의 메커니즘</td><td>Solana, Cosmos SDK, Ethereum 2.0</td></tr><tr><td><strong>멀티 모델 데이터베이스</strong></td><td>단일 시스템에서 다양한 데이터 모델과 일관성 옵션 제공</td><td>ArangoDB, FaunaDB, Cosmos DB</td></tr></tbody></table><hr><h3 id=주목해야-할-기술들>주목해야 할 기술들<a hidden class=anchor aria-hidden=true href=#주목해야-할-기술들>#</a></h3><table><thead><tr><th>기술</th><th>특징</th><th>일관성/가용성 관점</th></tr></thead><tbody><tr><td><strong>FoundationDB</strong></td><td>확장 가능한 키 - 값 저장소로 강한 일관성 제공</td><td>ACID 트랜잭션을 유지하면서 분산 환경에서 높은 확장성 제공</td></tr><tr><td><strong>CockroachDB</strong></td><td>SQL 호환 분산 데이터베이스, 글로벌 규모에서 일관성 제공</td><td>강한 일관성과 높은 가용성 동시 제공 시도</td></tr><tr><td><strong>TiDB</strong></td><td>MySQL 호환 분산 데이터베이스, 강한 일관성 지원</td><td>트랜잭션 지원과 수평적 확장성 결합</td></tr><tr><td><strong>Fauna</strong></td><td>서버리스 글로벌 데이터베이스, 일관성과 가용성 균형</td><td>글로벌 분산과 트랜잭션 지원 결합</td></tr><tr><td><strong>PolarDB</strong></td><td>클라우드 네이티브 데이터베이스, 분리된 스토리지와 컴퓨팅</td><td>고성능과 일관성 보장 결합</td></tr><tr><td><strong>YugabyteDB</strong></td><td>PostgreSQL 호환 분산 SQL 데이터베이스</td><td>강한 일관성과 고가용성 동시 제공, Google Spanner 아키텍처 영감</td></tr><tr><td><strong>SingleStore</strong></td><td>메모리 최적화 분산 관계형 데이터베이스</td><td>실시간 분석과 트랜잭션 워크로드를 위한 하이브리드 접근법</td></tr><tr><td><strong>Dgraph</strong></td><td>그래프 데이터베이스, 수평적 확장성</td><td>그래프 데이터에 대한 일관성과 확장성 균형</td></tr><tr><td><strong>NATS JetStream</strong></td><td>영구 스트리밍 플랫폼, 높은 처리량과 낮은 지연 시간</td><td>이벤트 스트리밍에서 일관성과 가용성 균형</td></tr><tr><td><strong>Apache Pulsar</strong></td><td>멀티 테넌트 메시징 및 스트리밍 플랫폼</td><td>계층화된 스토리지와 컴퓨팅으로 가용성과 내구성 향상</td></tr><tr><td><strong>R2DB</strong></td><td>반응형 관계형 데이터베이스</td><td>비동기 및 논블로킹 I/O 로 높은 가용성 제공</td></tr><tr><td><strong>Materialize</strong></td><td>증분 계산을 위한 스트리밍 데이터베이스</td><td>스트리밍 데이터에 대한 일관성 있는 뷰 제공</td></tr><tr><td><strong>PingCAP TiFlash</strong></td><td>HTAP(Hybrid Transactional/Analytical Processing) 컴포넌트</td><td>분석과 트랜잭션 처리에 다른 일관성 모델 적용</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>영역</th><th>전망</th><th>영향</th></tr></thead><tbody><tr><td><strong>AI 기반 자율 시스템</strong></td><td>AI 가 일관성과 가용성 간 균형을 자동으로 조정하는 시스템 등장</td><td>운영 복잡성 감소, 상황에 따른 최적의 트레이드오프 자동 결정</td></tr><tr><td><strong>양자 컴퓨팅 영향</strong></td><td>양자 컴퓨팅의 발전으로 분산 합의 알고리즘 혁신</td><td>더 효율적인 합의 메커니즘, 일관성과 가용성의 새로운 균형점</td></tr><tr><td><strong>에지 컴퓨팅 확산</strong></td><td>데이터와 처리가 에지로 이동, 로컬 일관성 모델 중요성 증가</td><td>지역적으로 강한 일관성, 글로벌 수준에서 약한 일관성의 계층화</td></tr><tr><td><strong>하이브리드 일관성 모델</strong></td><td>단일 시스템 내 다중 일관성 수준 지원 확대</td><td>더 세밀한 일관성/가용성 트레이드오프 제어 가능</td></tr><tr><td><strong>분산 원장 기술 통합</strong></td><td>블록체인과 전통적 분산 시스템의 경계 희석</td><td>새로운 형태의 합의 알고리즘과 불변 데이터 구조 활용</td></tr><tr><td><strong>실시간 글로벌 데이터</strong></td><td>글로벌 수준의 실시간 데이터 처리 요구 증가</td><td>지역 간 일관성 보장하면서 글로벌 가용성 제공하는 기술 발전</td></tr><tr><td><strong>규제 영향 증가</strong></td><td>데이터 주권, 개인정보 보호 규제가 아키텍처 결정에 영향</td><td>지역별 데이터 저장 및 처리, 일관성 모델에 규제 요구사항 반영</td></tr><tr><td><strong>지속 가능한 분산 시스템</strong></td><td>에너지 효율성을 고려한 일관성/가용성 결정</td><td>환경 영향을 최소화하는 새로운 알고리즘과 아키텍처</td></tr></tbody></table><h3 id=추가-학습-내용>추가 학습 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-내용>#</a></h3><table><thead><tr><th>주제</th><th>설명</th><th>학습 자원</th></tr></thead><tbody><tr><td><strong>분산 시스템 이론</strong></td><td>CAP 정리를 넘어선 분산 시스템의 수학적 기초 및 한계</td><td>&ldquo;Designing Data-Intensive Applications&rdquo; (Martin Kleppmann), MIT 분산 시스템 강의</td></tr><tr><td><strong>합의 알고리즘</strong></td><td>Paxos, Raft, BFT 등 다양한 합의 알고리즘의 작동 원리</td><td>&ldquo;In Search of an Understandable Consensus Algorithm&rdquo; (Raft 논문), &ldquo;Paxos Made Simple&rdquo; (Leslie Lamport)</td></tr><tr><td><strong>CRDT (Conflict-free Replicated Data Types)</strong></td><td>자동으로 충돌을 해결하는 데이터 구조의 이론과 응용</td><td>&ldquo;A comprehensive study of Convergent and Commutative Replicated Data Types&rdquo;</td></tr><tr><td><strong>데이터베이스 내부 구현</strong></td><td>다양한 데이터베이스가 일관성과 가용성을 구현하는 내부 메커니즘</td><td>각 데이터베이스 기술 문서, 아키텍처 설명 블로그</td></tr><tr><td><strong>분산 트랜잭션</strong></td><td>2PC, 사가 패턴 등 분산 환경에서의 트랜잭션 관리 기법</td><td>&ldquo;Microservices Patterns&rdquo; (Chris Richardson)</td></tr><tr><td><strong>성능 측정 및 벤치마킹</strong></td><td>일관성과 가용성 트레이드오프 정량화 방법</td><td>YCSB (Yahoo! Cloud Serving Benchmark), TPC 벤치마크</td></tr><tr><td><strong>장애 시뮬레이션</strong></td><td>카오스 엔지니어링을 통한 시스템 탄력성 테스트</td><td>Netflix Chaos Monkey, AWS Fault Injection Simulator</td></tr><tr><td><strong>글로벌 분산 시스템 설계</strong></td><td>지리적으로 분산된 시스템에서의 일관성/가용성 관리</td><td>Google Spanner 논문, &ldquo;Designing Distributed Systems&rdquo; (Brendan Burns)</td></tr><tr><td><strong>양자 컴퓨팅과 분산 합의</strong></td><td>양자 컴퓨팅이 분산 합의 알고리즘에 미칠 영향</td><td>연구 논문, 학술 자료</td></tr><tr><td><strong>에지 컴퓨팅 아키텍처</strong></td><td>에지 - 클라우드 환경에서의 데이터 일관성 관리</td><td>AWS Greengrass, Azure IoT Edge 문서</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>CAP 정리 (CAP Theorem)</td><td>분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 분할 내성 (Partition Tolerance) 세 가지를 동시에 만족시킬 수 없다는 이론</td></tr><tr><td>일관성 (Consistency)</td><td>모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장하는 특성</td></tr><tr><td>가용성 (Availability)</td><td>모든 요청이 성공 또는 실패 응답을 받을 수 있도록 보장하는 특성</td></tr><tr><td>분할 내성 (Partition Tolerance)</td><td>네트워크 분할 (노드 간 통신 실패) 발생 시에도 시스템이 계속 작동하는 특성</td></tr><tr><td>네트워크 분할 (Network Partition)</td><td>네트워크 장애로 인해 노드 간 통신이 불가능해지는 상황</td></tr><tr><td>강한 일관성 (Strong Consistency)</td><td>모든 읽기 작업이 가장 최근의 쓰기 작업을 반영하는 일관성 모델</td></tr><tr><td>결과적 일관성 (Eventual Consistency)</td><td>일정 시간이 지나면 모든 노드가 동일한 데이터 상태를 가지게 되는 일관성 모델</td></tr><tr><td>ACID</td><td>원자성 (Atomicity), 일관성 (Consistency), 격리성 (Isolation), 지속성 (Durability) 의 약자로, 트랜잭션 특성을 나타냄. 전통적인 관계형 데이터베이스의 일관성과 신뢰성을 보장하는 모델이다.</td></tr><tr><td>BASE</td><td>기본 가용성 (Basically Available), 소프트 상태 (Soft state), 결과적 일관성 (Eventual consistency) 의 약자. NoSQL 시스템의 트레이드오프 모델이다.</td></tr><tr><td>PACELC</td><td>네트워크 분할 (P) 발생 시 가용성 (A) 과 일관성 (C) 중 선택, 그렇지 않을 때 (E) 지연 시간 (L) 과 일관성 (C) 중 선택하는 이론</td></tr><tr><td>쿼럼 (Quorum)</td><td>분산 시스템에서 작업 성공을 위해 필요한 최소 노드 수</td></tr><tr><td>2 단계 커밋 (Two-Phase Commit)</td><td>분산 트랜잭션을 위한 프로토콜로, 모든 참가자가 커밋하거나 모두 롤백함</td></tr><tr><td>합의 알고리즘 (Consensus Algorithm)</td><td>분산 시스템에서 노드들이 특정 값에 대해 합의하는 알고리즘 (예: Paxos, Raft)</td></tr><tr><td>벡터 클럭 (Vector Clock)</td><td>분산 시스템에서 이벤트 순서를 추적하고 충돌을 감지하기 위한 논리적 시계</td></tr><tr><td>CRDT(Conflict-free Replicated Data Type)</td><td>수학적으로 충돌 해결이 보장되는 데이터 구조</td></tr><tr><td>동기식 복제 (Synchronous Replication)</td><td>모든 복제본이 업데이트된 후 클라이언트에 응답하는 복제 방식</td></tr><tr><td>비동기식 복제 (Asynchronous Replication)</td><td>주 노드 업데이트 후 즉시 응답하고, 복제는 백그라운드에서 진행하는 방식</td></tr><tr><td>샤딩 (Sharding)</td><td>데이터를 여러 노드에 분산하여 저장하는 기법</td></tr><tr><td>인과적 일관성 (Causal Consistency)</td><td>인과 관계가 있는 작업들에 대해서만 순서를 보장하는 일관성 모델</td></tr><tr><td>세션 일관성 (Session Consistency)</td><td>동일 세션 내에서만 일관성을 보장하는 모델</td></tr><tr><td>Eventual Consistency (최종 일관성)</td><td>네트워크 지연이나 장애 이후 시간이 지나면 결국 모든 노드가 동일한 상태로 수렴하는 일관성 모델입니다.</td></tr><tr><td>Strong Consistency (강한 일관성)</td><td>모든 읽기 연산이 가장 최근의 쓰기 연산 결과를 반환하는 일관성 모델입니다.</td></tr><tr><td>Linearizability (선형화 가능성)</td><td>연산이 순차적으로 처리되는 것처럼 보이도록 하는 일관성 보장 방식으로, Strong Consistency 의 일종입니다.</td></tr><tr><td>Raft Consensus Algorithm (Raft 합의 알고리즘)</td><td>리더를 중심으로 한 간단하고 이해하기 쉬운 분산 합의 알고리즘입니다.</td></tr><tr><td>Paxos Consensus Algorithm (Paxos 합의 알고리즘)</td><td>분산 시스템의 노드들이 서로 신뢰할 수 없을 때도 합의를 이끌어내기 위한 알고리즘입니다.</td></tr><tr><td>CRDT (Conflict-free Replicated Data Type)</td><td>분산 시스템에서 동시성이 보장된 상태에서 충돌 없이 데이터 일관성을 유지할 수 있는 데이터 구조입니다.</td></tr><tr><td>Network Partition (네트워크 분할)</td><td>네트워크 장애로 인해 시스템 노드 간 통신이 불가능해지는 상황을 의미합니다.</td></tr><tr><td>Failover (장애 조치)</td><td>시스템 구성 요소가 실패했을 때 자동으로 백업 구성 요소로 전환되는 메커니즘입니다.</td></tr><tr><td>Read/Write Quorum (읽기/쓰기 정족수)</td><td>분산된 데이터베이스에서 일관성을 유지하기 위한 읽기 또는 쓰기 요청 수의 기준입니다.</td></tr><tr><td>TCC</td><td>Try-Confirm-Cancel 분산 트랜잭션 패턴</td></tr></tbody></table><hr><h3 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h3><ul><li><a href=https://robertgreiner.com/cap-theorem-revisited/>CAP 정리 재고찰</a></li><li><a href=http://ksat.me/a-plain-english-introduction-to-cap-theorem>CAP 정리 쉬운 소개</a></li><li><a href=https://dataintensive.net/>데이터 중심 애플리케이션 설계(Martin Kleppmann)</a></li><li><a href=https://research.google/pubs/pub39966/>구글 Spanner 논문</a></li><li><a href=https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html>AWS 일관성 모델 문서</a></li><li><a href=https://www.cs.umd.edu/~abadi/papers/abadi-pacelc.pdf>PACELC 이론</a></li><li><a href=https://www.mongodb.com/docs/manual/core/read-isolation-consistency-recency/>MongoDB 일관성 모델</a></li><li><a href=https://cassandra.apache.org/doc/latest/architecture/overview.html>Cassandra 아키텍처</a></li><li><a href=https://jepsen.io/analyses>Jepsen DB 일관성 분석</a></li><li><a href=https://robertgreiner.com/cap-theorem-revisited/>CAP Theorem Revisited – robertgreiner.com</a></li><li><a href=http://ksat.me/a-plain-english-introduction-to-cap-theorem>A Plain English Introduction to CAP Theorem – ksat.me</a></li><li><a href=https://www.scylladb.com/2020/06/17/pacelc-the-other-theorem-every-distributed-system-designer-should-know/>PACELC Explained – ScyllaDB</a></li><li><a href=https://www.microsoft.com/en-us/research/project/crdt/>CRDTs – Conflict-free Replicated Data Types – Microsoft Research</a></li><li><a href=https://thesecretlivesofdata.com/raft/>The Raft Consensus Algorithm – The Secret Lives of Data</a></li><li><a href=http://ksat.me/a-plain-english-introduction-to-cap-theorem>CAP Theorem Illustrated Guide</a></li><li><a href=https://cloud.google.com/spanner/docs/whitepapers/SpannerAndCAP>Google Spanner CAP 접근법</a></li><li><a href=https://aws.amazon.com/architecture/cap/>AWS 아키텍처 센터 - CAP 패턴</a></li></ul><hr></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>