<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design Patterns | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Software-Design-Patterns,Code-Reusability"><meta name=description content="디자인 패턴과 원칙은 소프트웨어 개발에서 반복되는 설계 문제에 대한 검증된 해결책과 지침으로, GoF (Gang of Four) 의 23 가지 패턴 (생성/구조/행위) 과 SOLID, DRY, KISS 등의 설계 원칙을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는 소프트웨어 아키텍처의 핵심 요소이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design Patterns"><meta property="og:description" content="디자인 패턴과 원칙은 소프트웨어 개발에서 반복되는 설계 문제에 대한 검증된 해결책과 지침으로, GoF (Gang of Four) 의 23 가지 패턴 (생성/구조/행위) 과 SOLID, DRY, KISS 등의 설계 원칙을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는 소프트웨어 아키텍처의 핵심 요소이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design Patterns"><meta name=twitter:description content="디자인 패턴과 원칙은 소프트웨어 개발에서 반복되는 설계 문제에 대한 검증된 해결책과 지침으로, GoF (Gang of Four) 의 23 가지 패턴 (생성/구조/행위) 과 SOLID, DRY, KISS 등의 설계 원칙을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는 소프트웨어 아키텍처의 핵심 요소이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Software Design Patterns","item":"https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-patterns/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Software Design Patterns</h1><div class=post-description>디자인 패턴과 원칙은 소프트웨어 개발에서 반복되는 설계 문제에 대한 검증된 해결책과 지침으로, GoF (Gang of Four) 의 23 가지 패턴 (생성/구조/행위) 과 SOLID, DRY, KISS 등의 설계 원칙을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는 소프트웨어 아키텍처의 핵심 요소이다.</div></header><div class=post-content><h2 id=software-design-patterns>Software Design Patterns<a hidden class=anchor aria-hidden=true href=#software-design-patterns>#</a></h2><p>디자인 패턴과 원칙은 현대 소프트웨어 개발의 근간을 이루는 개념으로, 1994 년 Gang of Four 가 정리한 23 가지 클래식 패턴을 중심으로 생성, 구조, 행위 패턴으로 분류되며, SOLID 등의 설계 원칙과 함께 적용되어 객체지향 소프트웨어의 품질과 유지보수성을 크게 향상시킨다. 이들은 개발자 간의 공통 언어 역할을 하며, 검증된 모범 사례를 제공하여 소프트웨어 개발의 효율성과 품질을 동시에 보장한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>소프트웨어 디자인 패턴 (Software Design Pattern)</strong> 은 객체 지향 설계에서 자주 발생하는 문제를 해결하기 위해 정립된 일반화된 설계 해법이다. 이는 특정 언어나 구현에 종속되지 않으며, 구조적 설계를 위한 반복 가능한 설계 템플릿 역할을 한다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ul><li><strong>설계 원칙 (Design Principles)</strong>: 소프트웨어 설계의 품질을 높이기 위한 일반적인 지침이다. 예를 들어, SOLID 원칙은 객체 지향 설계에서의 모범 사례를 제공한다.</li><li><strong>Gang of Four (GoF) 패턴</strong>: 1994 년 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides 가 &ldquo;Design Patterns: Elements of Reusable Object-Oriented Software&rdquo; 에서 정리한 23 가지 클래식 디자인 패턴으로, 현재까지도 소프트웨어 설계의 기초가 되고 있다.</li><li><strong>SOLID 원칙</strong>: Robert C. Martin 이 제시한 5 가지 객체지향 설계 원칙으로, 소프트웨어의 유지보수성, 확장성, 유연성을 향상시키는 핵심 지침이다.</li><li><strong>설계 원칙 (Design Principles)</strong>: DRY (Don&rsquo;t Repeat Yourself), KISS (Keep It Simple, Stupid), YAGNI (You Aren&rsquo;t Gonna Need It) 등 좋은 소프트웨어 설계를 위한 지침들이다.</li></ul><h4 id=실무-연관성-분석>실무 연관성 분석<a hidden class=anchor aria-hidden=true href=#실무-연관성-분석>#</a></h4><table><thead><tr><th>요소</th><th>실무 연관성</th></tr></thead><tbody><tr><td>재사용 가능한 구조</td><td>모듈화된 서비스/클래스 설계에 바로 적용 가능</td></tr><tr><td>유지보수성</td><td>기능 확장 시 기존 코드 변경 최소화 가능</td></tr><tr><td>설계 문서화</td><td>팀 내 설계 공유 및 아키텍처 문서 명확화에 기여</td></tr><tr><td>구현 코드 템플릿</td><td>테스트 코드 및 리팩토링 전략 수립 시 효과적</td></tr></tbody></table><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p><strong>디자인 패턴의 기원</strong></p><ul><li>1994 년 &ldquo;Gang of Four(GoF)&rdquo; 가 디자인 패턴의 개념을 정립하고 23 가지 패턴을 공식화했다.</li><li>패턴은 소프트웨어 설계의 실무 경험과 연구에서 도출된 것으로, 실무적 문제 해결을 목표로 한다.</li></ul><p><strong>패턴의 확장</strong></p><ul><li>다양한 도메인 (웹, 모바일, 임베디드 등) 과 기술 (클라우드, AI 등) 에 맞춰 새로운 패턴이 계속 등장하고 있다.</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>소프트웨어 디자인 패턴의 주요 목적은 소프트웨어 설계에서 반복적으로 발생하는 문제에 대한 검증된 재사용 가능한 해결책을 제공하는 것이다.</p><p>디자인 패턴의 필요성은 다음과 같다:</p><ol><li><p><strong>개발 과정 가속화</strong>: 디자인 패턴은 검증된 개발 패러다임을 제공하여 개발 과정을 빠르게 한다. 개발자가 매번 새롭게 해결책을 고안할 필요 없이 검증된 방식을 활용할 수 있다.</p></li><li><p><strong>숨겨진 문제 예방</strong>: 새로 작성된 코드는 종종 나중에 발견되는 숨겨진 문제를 가질 수 있으며, 이러한 문제는 시간이 지남에 따라 큰 이슈로 발전할 수 있다. 디자인 패턴을 재사용하면 이러한 문제를 예방하고 코드 가독성을 향상시킬 수 있다.</p></li><li><p><strong>일반화된 해결책 제공</strong>: 디자인 패턴은 특정 문제에 묶이지 않는 일반화된 해결책을 문서화된 형식으로 제공한다.</p></li><li><p><strong>커뮤니케이션 개선</strong>: 디자인 패턴은 개발자 간의 의사소통을 위한 공통 언어를 제공한다. 특정 패턴 이름만으로도 복잡한 설계 개념을 전달할 수 있다.</p></li><li><p><strong>소프트웨어 품질 향상</strong>: 디자인 패턴은 소프트웨어 디자인의 모범 사례를 형식화하여 품질, 유지보수성, 확장성이 더 좋은 소프트웨어를 만들 수 있게 한다.</p></li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p>소프트웨어 디자인 패턴의 주요 기능과 역할은 다음과 같다:</p><ol><li><p><strong>문제 - 해결책 매핑 제공</strong>: 각 패턴은 특정 유형의 문제와 그에 대한 해결책을 매핑한다. 이를 통해 개발자는 자신이 직면한 문제에 적합한 해결책을 빠르게 찾을 수 있다.</p></li><li><p><strong>코드 구조화</strong>: 디자인 패턴은 코드를 구조화하고 조직화하는 방법을 제공하여 복잡성을 관리하고 유지보수성을 향상시킨다.</p></li><li><p><strong>객체 간 관계 정의</strong>: 특히 객체지향 디자인에서 패턴은 객체 간의 관계와 상호작용을 정의하는 데 중요한 역할을 한다.</p></li><li><p><strong>추상화 레벨 제공</strong>: 디자인 패턴은 프로그래밍 패러다임과 구체적인 알고리즘 사이의 중간 수준의 추상화를 제공한다.</p></li><li><p><strong>재사용성 촉진</strong>: 패턴은 검증된 설계를 재사용함으로써 소프트웨어 개발의 효율성을 높인다.</p></li><li><p><strong>유연성 지원</strong>: 디자인 패턴은 시스템이 변화에 더 잘 적응할 수 있도록 유연한 구조를 제공한다.</p></li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>언어 독립적</td><td>C++, Java, Python 등 다양한 언어에 적용 가능</td></tr><tr><td>구조화된 해법</td><td>설계 수준에서 코드보다 추상적으로 접근</td></tr><tr><td>검증된 재사용</td><td>수많은 프로젝트에서 입증된 품질</td></tr><tr><td>확장성 중심</td><td>변경에 유연하게 대응하는 설계 구조 제공</td></tr></tbody></table><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><strong>인터페이스에 프로그래밍하기</strong>: 구체적인 구현보다는 추상 인터페이스에 의존한다.</li><li><strong>상속보다 구성 선호</strong>: 많은 패턴은 클래스 상속보다 객체 구성을 통해 유연성을 높인다.</li><li><strong>결합도 최소화</strong>: 패턴은 객체 간의 결합도를 최소화하여 시스템의 유연성과 유지보수성을 향상시킨다.</li><li><strong>재사용성</strong>: 패턴은 코드 재사용을 촉진하여 개발 효율성을 높인다.</li></ol><h4 id=solid-원칙>SOLID 원칙<a hidden class=anchor aria-hidden=true href=#solid-원칙>#</a></h4><table><thead><tr><th>원칙</th><th>정의</th><th>목적</th></tr></thead><tbody><tr><td>Single Responsibility Principle(단일 책임 원칙)</td><td>클래스는 <strong>하나의 책임</strong>만 가져야 한다</td><td><strong>응집도 향상</strong>, <strong>결합도 감소</strong></td></tr><tr><td>Open-Closed Principle(개방 - 폐쇄 원칙)</td><td><strong>확장에는 열려 있고</strong>, <strong>수정에는 닫혀 있어야 한다</strong></td><td>기존 코드 수정 없이 <strong>기능 확장 가능</strong></td></tr><tr><td>Liskov Substitution Principle(리스코프 치환 원칙)</td><td>상위 타입 객체를 <strong>하위 타입 객체로 치환 가능</strong>해야 한다</td><td><strong>상속 관계의 일관성</strong> 보장</td></tr><tr><td>Interface Segregation Principle(인터페이스 분리 원칙)</td><td>클라이언트는 <strong>사용하지 않는 인터페이스에 의존</strong>하지 않아야 한다</td><td><strong>인터페이스 응집도 향상</strong>, <strong>불필요한 의존 제거</strong></td></tr><tr><td>Dependency Inversion Principle(의존성 역전 원칙)</td><td><strong>고수준 모듈이 저수준 모듈에 의존</strong>하지 않아야 한다</td><td><strong>결합도 감소</strong>, <strong>모듈 간 유연성 향상</strong>, <strong>추상화 기반 설계</strong></td></tr></tbody></table><h4 id=기타-핵심-원칙>기타 핵심 원칙<a hidden class=anchor aria-hidden=true href=#기타-핵심-원칙>#</a></h4><ul><li><strong>DRY (Don&rsquo;t Repeat Yourself)</strong>: 코드 중복을 피하고 단일 진실 원천을 유지</li><li><strong>KISS (Keep It Simple, Stupid)</strong>: 가능한 한 단순하게 설계</li><li><strong>YAGNI (You Aren&rsquo;t Gonna Need It)</strong>: 필요하지 않은 기능을 미리 구현하지 않음</li></ul><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><p>디자인 패턴의 작동 방식은 일반적으로 <strong>객체의 역할 분리</strong>, <strong>동적 위임</strong>, <strong>인터페이스 기반의 설계</strong>로 설명된다.</p><p>각 패턴은 다음과 같은 원리를 내포한다:</p><ul><li><strong>역할 기반 분리</strong>: 객체에 명확한 책임을 부여하여 관심사를 분리</li><li><strong>런타임 조합</strong>: 전략, 상태, 데코레이터 패턴 등은 실행 중 객체를 교체하여 유연성을 확보</li><li><strong>구현 은닉</strong>: 인터페이스 또는 추상 클래스를 통해 구현을 감추고, 클라이언트는 오직 계약만 사용</li><li><strong>의존성 주입</strong>: 팩토리, 싱글턴 등을 통해 객체 생성 및 주입 방식 정의</li></ul><p><strong>작동 원리 예시 다이어그램 (전략 패턴 기준)</strong></p><pre class=mermaid>classDiagram
    class Context {
        +setStrategy(strategy: Strategy)
        +executeStrategy()
    }
    class Strategy {
        &lt;&lt;interface&gt;&gt;
        +execute()
    }
    class ConcreteStrategyA {
        +execute()
    }
    class ConcreteStrategyB {
        +execute()
    }

    Context --&gt; Strategy : uses
    Strategy &lt;|-- ConcreteStrategyA
    Strategy &lt;|-- ConcreteStrategyB
</pre><ul><li><code>Context</code> 객체는 실행 시점에 <code>Strategy</code> 인터페이스를 구현한 구체 클래스를 주입받고, <code>execute()</code> 메서드를 호출하여 다양한 알고리즘을 실행할 수 있다.</li></ul><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><p><strong>패턴 선택 기준</strong></p><ul><li>문제 유형, 시스템 요구사항, 확장성, 유지보수성 고려</li></ul><p><strong>구현 절차</strong></p><ol><li>문제 분석 및 패턴 선택</li><li>클래스/객체 구조 설계</li><li>인터페이스 정의</li><li>실제 코드 구현 및 테스트</li></ol><p>디자인 패턴 구현 시 사용하는 대표적인 기법은 다음과 같다:</p><table><thead><tr><th>기법</th><th>정의</th><th>구성</th><th>목적</th><th>예시</th></tr></thead><tbody><tr><td>인터페이스 기반 설계</td><td>구현체를 숨기고 인터페이스를 통해 접근</td><td>인터페이스 + 구현체</td><td>유연한 변경, DI 지원</td><td>전략, 옵저버</td></tr><tr><td>팩토리 메서드</td><td>객체 생성을 서브 클래스에 위임</td><td>Creator + Product</td><td>객체 생성 책임 분리</td><td>팩토리 메서드</td></tr><tr><td>객체 합성</td><td>기존 객체를 포함하여 새 객체 구성</td><td>기존 객체 포함</td><td>상속 대신 합성을 통한 확장</td><td>데코레이터, 어댑터</td></tr><tr><td>이벤트 기반</td><td>이벤트 발생 → 리스너 반응 구조</td><td>Subject + Observer</td><td>비동기 연동</td><td>옵저버</td></tr><tr><td>책임 연쇄</td><td>요청을 처리할 수 있는 객체를 체인 연결</td><td>Handler + 다음 핸들러</td><td>동적 요청 처리</td><td>Chain of Responsibility</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>기반 원칙 또는 특성</th></tr></thead><tbody><tr><td><strong>재사용성 향상</strong></td><td>검증된 설계 구조를 반복적으로 활용하여 동일 문제에 대한 중복 해결 방지</td><td>표준화된 패턴 구조</td></tr><tr><td><strong>유지보수 용이성</strong></td><td>모듈화된 구조로 변경 시 영향 범위 최소화, 단일 책임 원칙에 부합</td><td>SRP(단일 책임 원칙), 모듈화</td></tr><tr><td><strong>확장성 확보</strong></td><td>새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장 가능</td><td>OCP(개방 - 폐쇄 원칙), 유연한 구조</td></tr><tr><td><strong>코드 가독성 향상</strong></td><td>명확한 책임 분리와 구조화된 설계로 이해가 쉬움</td><td>인터페이스 설계 기반, 역할 분리</td></tr><tr><td><strong>개발자 간 의사소통 용이</strong></td><td>패턴 명칭과 구조가 공통 언어 역할을 하여 협업 시 설계 의도 전달에 도움</td><td>GoF 용어 체계, 설계 커뮤니케이션 도구</td></tr><tr><td><strong>개발 생산성 및 품질 향상</strong></td><td>검증된 설계 솔루션을 활용하여 개발 시간 단축 및 에러 감소</td><td>재사용성 + 표준화 + 문서화</td></tr></tbody></table><h3 id=단점과-문제점-및-해결방안>단점과 문제점 및 해결방안<a hidden class=anchor aria-hidden=true href=#단점과-문제점-및-해결방안>#</a></h3><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><table><thead><tr><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>복잡성 증가</strong></td><td>단순한 문제에도 패턴을 적용하면 불필요하게 코드 구조가 복잡해짐</td><td>필요한 경우에만 적용 (YAGNI 원칙), 단순화 리팩토링</td></tr><tr><td><strong>학습 곡선 존재</strong></td><td>다양한 패턴 개념과 적용 맥락 이해가 어려워 진입 장벽이 있음</td><td>교육 자료 제공, 시각화 도구 활용, 팀 내 패턴 공유 세션 운영</td></tr><tr><td><strong>과도한 추상화</strong></td><td>추상화 계층이 많아져 코드 흐름 파악이 어려움</td><td>단순한 문제엔 단순한 구조 유지, KISS 원칙 적용</td></tr><tr><td><strong>성능 저하 가능성</strong></td><td>위임 또는 추상화를 통한 오버헤드로 인해 런타임 성능이 저하될 수 있음</td><td>병목 분석 후 최적화, 불필요한 추상화 제거</td></tr><tr><td><strong>오용/남용 가능성</strong></td><td>상황에 맞지 않는 패턴을 적용해 설계 품질과 유지보수성이 오히려 저하됨</td><td>패턴 적용 전 문제 도메인 분석, 코드 리뷰 및 설계 검토 프로세스 구축</td></tr></tbody></table><h4 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h4><table><thead><tr><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td><strong>패턴 오용</strong></td><td>문제 분석 부족, 패턴 이름에 대한 과도한 의존</td><td>복잡성 증가, 가독성 저하</td><td>코드 리뷰 시 구조 과도 여부 확인</td><td>요구사항 기반 패턴 선택 훈련</td><td>리팩토링 및 불필요 추상화 제거</td></tr><tr><td><strong>성능 저하</strong></td><td>추상화와 위임으로 인한 성능 병목</td><td>응답 지연, 리소스 낭비</td><td>프로파일링 도구 사용</td><td>필요한 경우만 패턴 적용</td><td>병목 구간 단순화, 캐시 적용 등 최적화</td></tr><tr><td><strong>불필요한 계층 증가</strong></td><td>과도한 인터페이스/추상화 레이어 도입</td><td>유지보수 어려움, 디버깅 복잡</td><td>클래스 간 의존 시각화 및 계층 분석 도구 사용</td><td>과도한 계층화 방지</td><td>KISS 원칙에 기반한 구조 리팩토링</td></tr><tr><td><strong>이해도 차이</strong></td><td>팀원 간 디자인 패턴에 대한 지식 차이</td><td>협업 지연, 오해에 따른 버그 발생</td><td>설계 문서 부족 여부 점검, 리뷰 내 용어 확인</td><td>설계 문서화, 팀 내 공유/교육 세션</td><td>문서 기반 설계 리뷰 및 지속적 교육 실시</td></tr><tr><td><strong>패턴 남용</strong></td><td>" 모든 문제에 패턴 적용 " 이라는 잘못된 접근</td><td>불필요한 구조화, 개발 속도 저하</td><td>코드 구조의 과잉 복잡성 점검</td><td>패턴이 아닌 단순 구조 우선 고려</td><td>YAGNI, KISS 원칙 병행 적용</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>카테고리</th><th>도전 과제 항목</th><th>설명</th><th>실질적 해결 방향 또는 접근 전략</th></tr></thead><tbody><tr><td><strong>기술 환경 대응</strong></td><td>프레임워크 내장 패턴과의 충돌</td><td>Spring, Django 등에서 이미 구현된 패턴과 사용자 정의 패턴이 충돌할 수 있음</td><td>프레임워크 패턴 분석 후 커스터마이징 전략 수립</td></tr><tr><td></td><td>클라우드 네이티브 대응</td><td>Stateless, Auto-scaling, Lifecycle 관리와 패턴의 일관성 확보 필요</td><td>상태 공유 최소화, 풀링/싱글턴 사용 시 생명주기 인식 강화</td></tr><tr><td></td><td>마이크로서비스 통합</td><td>각 서비스 단위에서의 패턴 재정의 필요, 통신 방식 (동기/비동기) 에 따른 패턴 변경 필요</td><td>서비스 경계 기반 설계 원칙과 EDA/CQRS 패턴 조합 고려</td></tr><tr><td><strong>성능 및 확장성 고려</strong></td><td>런타임 성능 최적화</td><td>옵저버, 전략 등 런타임 동적 바인딩 패턴의 성능 저하 가능성</td><td>병목 구간 식별 후 프록시 제거 또는 캐싱 적용, AOT 가능성 검토</td></tr><tr><td></td><td>메모리 관리 어려움</td><td>싱글턴, 풀링 객체가 GC 방해할 수 있음</td><td>SoftReference, TTL 관리, 명시적 해제 전략 병행</td></tr><tr><td></td><td>대규모 시스템의 패턴 조합</td><td>복잡한 구조 내 여러 패턴 결합 시 의도 충돌 가능성</td><td>시퀀스 다이어그램과 설계 문서로 명확히 의도 표현, Domain 별 분리 적용</td></tr><tr><td><strong>패턴 선택 및 전략</strong></td><td>적절한 패턴 선택의 어려움</td><td>문제 상황에 최적화된 패턴을 경험 없이 고르기 어려움</td><td>패턴 카탈로그 기반 분석, 프로토타입 구현 후 효과 측정</td></tr><tr><td></td><td>진화하는 요구사항 대응</td><td>초기 설계 패턴이 새로운 요구에 맞지 않게 되는 경우 발생</td><td>확장 가능한 구조 설계 및 플러그인 방식 아키텍처 고려</td></tr><tr><td></td><td>패턴 커스터마이징 필요</td><td>복합 비즈니스 요구에 맞게 패턴을 변형해야 하는 경우</td><td>변경 가능한 부분과 고정된 부분을 명확히 구분하는 설계 전략 적용</td></tr><tr><td><strong>조직 및 협업</strong></td><td>팀 간 이해도 격차</td><td>패턴에 대한 이해 수준이 다르면 구현 목적이 왜곡되거나 유지보수에 문제 발생</td><td>코드 리뷰, 기술 공유 세션, 설계 의도 문서화 강화</td></tr><tr><td></td><td>문서화와 설계 커뮤니케이션</td><td>의사결정의 근거 없이 패턴이 적용되면 협업 시 의도 파악이 어려움</td><td>UML 기반 설계 문서와 주석으로 설계 근거 명시</td></tr><tr><td></td><td>표준화된 설계 가이드 부재</td><td>동일한 유형의 문제를 매번 다르게 해결함으로써 유지보수 어려움 발생</td><td>조직 내 패턴 적용 Best Practice 정리 및 적용 기준 수립</td></tr><tr><td><strong>학습과 도입</strong></td><td>신규 패턴 학습 필요</td><td>기존에 없던 최신 패턴 (ex. Reactor Pattern, Saga 등) 이해 및 적용이 어려움</td><td>도메인 기반 학습 및 실제 서비스 아키텍처 분석을 통한 사례 중심 접근</td></tr><tr><td></td><td>실무 적용 한계</td><td>레거시 코드, 특정 도메인에서는 구조적으로 패턴 적용이 어려움</td><td>점진적 리팩토링 및 코드 주변화 전략으로 부분 적용</td></tr><tr><td></td><td>패턴의 진화와 추적 어려움</td><td>패턴은 시간이 지남에 따라 새로운 구현 방식과 개념으로 진화함</td><td>지속적 기술 동향 추적과 내부 Wiki/Pattern Repository 구축</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류</th><th>패턴</th><th>설명</th></tr></thead><tbody><tr><td>생성 (Creational)</td><td>싱글톤 (Singleton)</td><td>애플리케이션 내에서 하나의 인스턴스만 생성되도록 보장</td></tr><tr><td></td><td>팩토리 메서드 (Factory Method)</td><td>객체 생성을 하위 클래스에 위임하여 확장성과 유연성 확보</td></tr><tr><td></td><td>추상 팩토리 (Abstract Factory)</td><td>관련된 객체들을 일관성 있게 생성하는 인터페이스 제공</td></tr><tr><td></td><td>빌더 (Builder)</td><td>복합 객체의 생성 절차를 분리하여 동일한 생성 과정에서 다양한 표현 가능</td></tr><tr><td></td><td>프로토타입 (Prototype)</td><td>기존 객체를 복제하여 새로운 객체 생성</td></tr><tr><td>구조 (Structural)</td><td>어댑터 (Adapter)</td><td>서로 다른 인터페이스를 가진 클래스들을 연결</td></tr><tr><td></td><td>브리지 (Bridge)</td><td>구현부와 추상화를 분리하여 독립적으로 확장</td></tr><tr><td></td><td>컴포지트 (Composite)</td><td>트리 구조의 객체를 구성하고 전체 - 부분을 동일하게 다룸</td></tr><tr><td></td><td>데코레이터 (Decorator)</td><td>객체에 동적으로 새로운 기능을 추가</td></tr><tr><td></td><td>퍼사드 (Facade)</td><td>복잡한 하위 시스템에 대한 간단한 인터페이스 제공</td></tr><tr><td></td><td>프록시 (Proxy)</td><td>객체에 대한 접근을 제어하는 대리 객체 제공</td></tr><tr><td></td><td>플라이웨이트 (Flyweight)</td><td>메모리 사용 최적화를 위해 객체를 공유</td></tr><tr><td>행위 (Behavioral)</td><td>옵저버 (Observer)</td><td>상태 변화에 따라 종속 객체들에게 알림을 전달</td></tr><tr><td></td><td>전략 (Strategy)</td><td>알고리즘을 캡슐화하여 런타임에 교체 가능</td></tr><tr><td></td><td>상태 (State)</td><td>객체의 상태에 따라 동작을 변경</td></tr><tr><td></td><td>커맨드 (Command)</td><td>요청을 객체로 캡슐화하여 매개변수화 및 큐잉 가능</td></tr><tr><td></td><td>책임 연쇄 (Chain of Responsibility)</td><td>요청을 처리할 수 있는 객체를 체인 형태로 연결</td></tr><tr><td></td><td>방문자 (Visitor)</td><td>구조는 변경하지 않고, 기능만 확장할 수 있도록 분리</td></tr><tr><td></td><td>템플릿 메서드 (Template Method)</td><td>알고리즘의 구조는 고정하고, 세부 구현만 하위 클래스에서 처리</td></tr><tr><td></td><td>인터프리터 (Interpreter)</td><td>언어의 문법을 해석하고 처리하는 구조 제공</td></tr><tr><td></td><td>미디에이터 (Mediator)</td><td>객체들 간의 복잡한 통신을 중앙 집중화</td></tr><tr><td></td><td>메멘토 (Memento)</td><td>객체의 상태를 저장하고 복원할 수 있는 기능 제공</td></tr></tbody></table><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th><strong>도메인</strong></th><th><strong>패턴</strong></th><th><strong>적용 사례</strong></th><th><strong>주요 목적</strong></th><th><strong>효과 및 기대 결과</strong></th></tr></thead><tbody><tr><td><strong>백엔드 설계</strong></td><td>Singleton</td><td>설정 관리, 로깅 시스템</td><td>전역 인스턴스 공유</td><td>일관성 유지, 메모리 절감</td></tr><tr><td></td><td>Factory Method</td><td>설정 파서, 문서 생성기</td><td>객체 생성 로직 분리</td><td>유연한 인스턴스 생성 및 확장성 확보</td></tr><tr><td></td><td>Strategy</td><td>인증 방식 선택, 결제 정책 적용</td><td>동적 행위 전환</td><td>정책 변경 시 코드 수정 없이 대응 가능</td></tr><tr><td></td><td>Template Method</td><td>후처리 훅, 공통 워크플로우 처리</td><td>공통 알고리즘 구조화</td><td>중복 제거, 커스터마이징 포인트 제공</td></tr><tr><td><strong>UI 프론트엔드</strong></td><td>Composite</td><td>React/Vue 컴포넌트 계층화</td><td>계층적 구조 표현</td><td>UI 재사용성 증가, 일관된 구성</td></tr><tr><td></td><td>Decorator</td><td>UI 기능 확장, 런타임 스타일 동적 부여</td><td>런타임 기능 확장</td><td>최소한의 변경으로 UI 기능 확장</td></tr><tr><td></td><td>Observer</td><td>상태 관리 (Redux, Recoil 등)</td><td>상태 변화 감지 및 반영</td><td>실시간 UI 동기화, 예측 가능한 흐름</td></tr><tr><td><strong>API & 마이크로서비스</strong></td><td>Facade</td><td>API Gateway, GraphQL BFF</td><td>복잡성 은폐</td><td>클라이언트 호출 간결화, 보안 경계 분리</td></tr><tr><td></td><td>Adapter</td><td>API 버전 변환, 서드파티 API 호환성</td><td>인터페이스 호환화</td><td>레거시 시스템 통합, 외부 연동 유연화</td></tr><tr><td></td><td>Proxy</td><td>API 요청 캐싱, 인증 필터링</td><td>접근 제어, 트래픽 최적화</td><td>성능 향상, 인증 로직 위임</td></tr><tr><td><strong>데이터 처리 및 접근</strong></td><td>DAO (Data Access Object)</td><td>MyBatis, JPA 등에서의 DB 접근 추상화</td><td>비즈니스 로직과 데이터 접근 분리</td><td>유지보수성 향상, 테스트 용이성 확보</td></tr><tr><td></td><td>Repository</td><td>도메인 중심 데이터 처리 (DDD)</td><td>엔티티의 저장/조회 책임 분리</td><td>비즈니스 중심 설계 가능</td></tr><tr><td><strong>동시성/이벤트 처리</strong></td><td>Command</td><td>Undo/Redo 시스템, 메시지 큐 처리</td><td>요청 캡슐화 및 재실행 지원</td><td>작업 추적, 큐잉 가능, 분산 처리 용이화</td></tr><tr><td></td><td>Mediator</td><td>UI 컴포넌트 간 상태 조율, Pub/Sub 메시지 허브</td><td>중재자 역할 수행</td><td>구성요소 간 결합도 감소, 중심 조정자 도입</td></tr><tr><td></td><td>Observer</td><td>Kafka 소비자, 이벤트 처리 시스템</td><td>상태 변화 감지 후 전달</td><td>실시간 알림, 느슨한 결합</td></tr><tr><td><strong>게임 및 인터랙티브 앱</strong></td><td>State</td><td>캐릭터 상태 머신, UI 상태 전환</td><td>상태 기반 전환 관리</td><td>조건에 따라 동작 변경 유연화</td></tr><tr><td></td><td>Command</td><td>키 입력 처리, 매크로 시스템</td><td>행위 캡슐화 및 큐잉</td><td>로깅, 실행 취소/재실행, 테스트 용이화</td></tr><tr><td><strong>아키텍처 기반</strong></td><td>Front Controller</td><td>Spring DispatcherServlet 등</td><td>요청 진입점 통일</td><td>로깅, 보안, 인증 필터링 통합 관리</td></tr><tr><td></td><td>MVC</td><td>Spring, Django MVC 구조</td><td>관심사 분리</td><td>코드 유지보수 용이, 역할 명확화</td></tr><tr><td></td><td>Service Locator</td><td>DI Container 기반 서비스 탐색</td><td>객체 생성 위치 은닉</td><td>느슨한 결합, 유연한 의존성 주입</td></tr><tr><td><strong>시스템 리소스 관리</strong></td><td>Object Pool</td><td>DB Connection Pool (HikariCP), Thread Pool</td><td>리소스 재사용, 초기화 비용 절감</td><td>성능 향상, GC 부하 감소</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-대형-전자결제-시스템-설계>사례 1: 대형 전자결제 시스템 설계<a hidden class=anchor aria-hidden=true href=#사례-1-대형-전자결제-시스템-설계>#</a></h4><p><strong>요구사항</strong>:</p><ul><li>다양한 결제 수단 (신용카드, 간편결제, 가상계좌 등)</li><li>결제 수단 추가 및 변경의 유연성</li><li>사용자에게 결제 진행상황 실시간 알림</li></ul><p><strong>사용된 패턴 및 구성</strong>:</p><table><thead><tr><th>패턴</th><th>적용 위치</th><th>역할</th></tr></thead><tbody><tr><td>전략 (Strategy)</td><td>각 결제 수단 구현</td><td>결제 방식 교체를 유연하게 지원</td></tr><tr><td>옵저버 (Observer)</td><td>알림 서비스</td><td>결제 상태 변화 시 사용자에게 알림 전송</td></tr><tr><td>싱글톤 (Singleton)</td><td>Configuration, Logger</td><td>전역에서 동일 인스턴스 사용</td></tr><tr><td>커맨드 (Command)</td><td>결제 요청 큐</td><td>요청을 객체화하여 비동기 처리</td></tr></tbody></table><p><strong>시스템 구성 다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Client]
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[PaymentController]
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[PaymentStrategyFactory] → [KakaoPayStrategy]
</span></span><span class=line><span class=cl>                        → [CardPayStrategy]
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[Command Queue] → [Command Handler]
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[PaymentState] → [Notification Observer]
</span></span></code></pre></td></tr></table></div></div><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>구분</strong></th><th><strong>고려사항</strong></th><th><strong>설명</strong></th><th><strong>권장 사항</strong></th></tr></thead><tbody><tr><td><strong>1. 패턴 선정 전략</strong></td><td>적절한 패턴 선택</td><td>문제의 구조와 컨텍스트에 맞는 패턴을 분석 후 적용</td><td>요구사항 기반 분석, 프로토타입으로 검증, 반복성 있는 문제에만 적용</td></tr><tr><td></td><td>과도한 추상화 방지</td><td>단순한 문제에 복잡한 패턴 적용 시 설계가 오히려 불명확해짐</td><td>YAGNI 원칙 준수, 단순한 해결책 우선</td></tr><tr><td></td><td>프레임워크 내장 패턴 확인</td><td>사용 중인 프레임워크 (Spring, Django 등) 에 내장된 기능과 중복될 수 있음</td><td>프레임워크 기능 우선 검토, 중복 회피</td></tr><tr><td><strong>2. 협업 및 팀 역량</strong></td><td>팀 공감대 형성</td><td>팀원 간 패턴에 대한 이해 차이는 협업과 유지보수의 큰 장애가 될 수 있음</td><td>코드 리뷰, 기술 세미나, 설명이 포함된 문서화</td></tr><tr><td></td><td>문서화</td><td>사용한 패턴의 목적과 구조가 문서화되지 않으면 타 개발자의 이해도 저하</td><td>README, UML, 주석 활용하여 설계 의도 명확히 표현</td></tr><tr><td></td><td>코드 리뷰 통한 공유</td><td>적용된 패턴이 적절한지 팀 차원에서 검토 필요</td><td>리뷰 시 패턴 목적·효과에 대한 피드백 포함</td></tr><tr><td><strong>3. 유지보수 및 테스트</strong></td><td>테스트 용이성 확보</td><td>일부 패턴은 테스트하기 어려운 구조를 초래할 수 있음</td><td>의존성 주입, 인터페이스 분리, Mock 전략 활용</td></tr><tr><td></td><td>변경 영향도 최소화</td><td>패턴 구조 변경이 전체 시스템에 파급효과를 줄 수 있음</td><td>인터페이스 기반 설계, 의존성 역전 (DIP) 적용</td></tr><tr><td></td><td>확장성과 진화 고려</td><td>패턴이 향후 기능 추가나 변경에 장애가 되지 않도록 구조 설계 필요</td><td>확장 포인트 확보, 점진적 리팩토링 전략 수립</td></tr><tr><td><strong>4. 운영과 성능</strong></td><td>성능에 미치는 영향</td><td>일부 패턴은 오버헤드 (추상화, 위임 등) 발생 가능</td><td>성능 프로파일링 도구 활용, 성능 민감 영역에서는 경량 패턴 적용 (Flyweight 등)</td></tr><tr><td></td><td>리팩토링 시점</td><td>초기 설계 단계에서 무리한 패턴 도입은 오히려 리팩토링 부담 가중</td><td>요구사항이 명확해지고 코드가 성숙한 후 점진적 도입</td></tr><tr><td></td><td>언어/환경에 따른 제약</td><td>일부 패턴은 특정 언어나 프레임워크에서 더 자연스럽게 동작함</td><td>언어 특성 고려하여 적용, 기술스택 친화적 설계</td></tr><tr><td><strong>5. 패턴 조합 전략</strong></td><td>패턴 간 상호작용 관리</td><td>여러 패턴을 함께 사용할 때 기능 중복이나 구조 충돌 발생 위험</td><td>최소 조합, 핵심 흐름에 집중된 설계, 상호작용 시퀀스 명확히 정리</td></tr><tr><td></td><td>유지 가능한 복잡성 유지</td><td>조합된 패턴의 복잡성이 유지보수성과 충돌할 수 있음</td><td>단순함 우선, 기능 단위로 모듈화하여 관리</td></tr></tbody></table><ul><li><strong>패턴은 도구이지 목적이 아니다.</strong> → 필요할 때만 적용</li><li><strong>팀과의 합의, 문서화, 테스트 전략이 함께 가야 한다.</strong></li><li><strong>확장성과 성능은 반드시 사전 고려</strong> → 조기 리팩토링보다 점진적 도입</li><li><strong>프레임워크와 언어의 특성을 고려한 설계 필요</strong></li><li><strong>패턴 간 조합 시는 충돌 여부와 유지보수성을 최우선으로 판단</strong></li></ul><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>고려사항</strong></th><th><strong>설명</strong></th><th><strong>권장 사항 / 주의할 점</strong></th><th></th></tr></thead><tbody><tr><td><strong>1. 성능 영향 분석</strong></td><td>성능 측정 및 모니터링</td><td>패턴 적용 전후의 성능 차이를 프로파일링 및 벤치마킹으로 측정</td><td>추상화 오버헤드, 메서드 체이닝 등 병목 식별 → 프로파일링 도구 사용</td><td></td></tr><tr><td></td><td>핫 패스 최적화</td><td>패턴 도입으로 인해 성능 민감 구간 (핫 패스) 에서 오버헤드 발생 가능</td><td>인라인 캐싱, 구조 단순화, 정적 경로 적용</td><td></td></tr><tr><td></td><td>불필요한 연산 지연</td><td>즉시 필요하지 않은 계산은 지연 처리</td><td>Lazy Evaluation 적용, 사용자 응답성과의 트레이드오프 고려</td><td></td></tr><tr><td><strong>2. 메모리 및 객체 관리</strong></td><td>객체 수 증가 및 메모리 사용량</td><td>추상화 계층 및 객체 생성을 수반하는 패턴은 메모리 부담 발생 가능</td><td>Flyweight, Object Pool 적용으로 공유 또는 재사용</td><td></td></tr><tr><td></td><td>GC 영향 및 생명주기 관리</td><td>Singleton, Memento 패턴 등 장수 객체는 GC 에 악영향</td><td>약한 참조 (WeakReference), 명시적 해제 전략 고려</td><td></td></tr><tr><td></td><td>불필요한 상태 보존</td><td>상태 보존형 패턴은 메모리 낭비 및 관리 복잡성 유발</td><td>꼭 필요한 경우에만 상태 유지, 상태 정리 메커니즘 도입</td><td></td></tr><tr><td></td><td>초기화 비용 최적화</td><td>복잡한 패턴의 초기화 과정이 시스템 부팅 또는 요청 지연을 유발할 수 있음</td><td>Lazy Initialization, 초기화 지연, 비동기 로딩 전략 사용</td><td></td></tr><tr><td><strong>3. 구조 최적화 및 단순화</strong></td><td>과도한 간접 참조 구조</td><td>레이어 과다 도입은 호출 비용 증가와 유지보수 부담 유발</td><td>필요한 추상화만 적용, KISS 원칙 준수, 필수 경로만 분리 설계</td><td></td></tr><tr><td></td><td>중복 패턴 적용</td><td>유사 기능을 가진 여러 패턴을 중첩 적용 시 기능 충돌 가능</td><td>팀 내 공통 패턴 가이드라인 수립, 패턴 조합 시 인터페이스 충돌 체크</td><td></td></tr><tr><td></td><td>경량화 구현</td><td>복잡한 패턴의 전체 구현이 과할 수 있음</td><td>부분 구현, 커스터마이징 통한 경량 패턴 적용</td><td></td></tr><tr><td><strong>4. 동시성 및 병렬성 대응</strong></td><td>Thread-safety 확보</td><td>Singleton, Lazy 등은 동시 접근 시 레이스 컨디션 위험</td><td>동기화, 불변 객체, synchronized 블록 최소화, lock-free 알고리즘 도입</td><td></td></tr><tr><td></td><td>Lock 사용 최소화</td><td>동기화 방식은 병렬성 성능 저하 초래 가능</td><td>필요 최소한의 임계영역만 보호, CAS(Compare-And-Swap) 전략 사용</td><td></td></tr><tr><td></td><td>비동기 초기화 고려</td><td>복잡한 초기화 로직을 메인 스레드에서 수행할 경우 지연 발생 가능</td><td>비동기 초기화 처리, 초기화 완료 여부 캐싱</td><td></td></tr><tr><td><strong>5. 캐싱 및 데이터 재사용</strong></td><td>결과 캐싱</td><td>연산 비용이 큰 결과는 캐싱을 통해 재사용</td><td>메모이제이션, TTL 기반 캐시, 정합성 유지 전략 병행</td><td></td></tr><tr><td></td><td>캐시 무효화 및 일관성</td><td>캐시된 데이터의 정합성 유지 및 갱신 시점 관리 필요</td><td>캐시 무효화 정책 수립, 데이터 변경 시점 캐시 제거 혹은 갱신 적용</td><td></td></tr><tr><td></td><td>반복 연산 최적화</td><td>동일한 연산을 반복 수행 시 처리 비용 상승</td><td>결과 저장 및 재활용 전략 적용</td><td></td></tr><tr><td><strong>6. 운영 환경 최적화</strong></td><td>언어 및 플랫폼 특성 고려</td><td>특정 언어 (JVM, Python 등) 는 GC/런타임 최적화 전략이 상이함</td><td>언어 친화적 패턴 선택 (예: Python 은 싱글톤보다 모듈 방식 우선)</td><td></td></tr><tr><td></td><td>비즈니스 우선순위 반영</td><td>모든 경로를 동일하게 최적화할 필요 없음</td><td>사용자 응답성과 직접 연결된 경로에 리소스를 집중 투자</td><td></td></tr><tr><td></td><td>코드 가독성과 유지보수성 균형</td><td>지나친 최적화로 코드 복잡도가 증가할 경우 유지보수가 어려워짐</td><td>성능 vs 가독성 트레이드오프 명확히 판단 → 핵심 로직 외는 명료성 유지 우선</td><td></td></tr></tbody></table><ul><li><strong>측정 → 설계 → 적용 → 검증</strong>의 루프를 유지해야 실질적인 성능 개선으로 이어짐</li><li>**공유와 재사용 (Flyweight, Pooling)**은 메모리와 성능 모두에 효과적</li><li><strong>캐싱 전략은 데이터 무결성과 트레이드오프 관계</strong>에 있으므로 검토 후 도입</li><li><strong>병렬성, 초기화, GC 등 시스템 자원 제약을 패턴 구조가 고려해야 함</strong></li><li><strong>언어/플랫폼 특성을 무시한 패턴 설계는 최적화 실패를 유발할 수 있음</strong></li></ul><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><h4 id=패턴의-진화-및-확장>패턴의 진화 및 확장<a hidden class=anchor aria-hidden=true href=#패턴의-진화-및-확장>#</a></h4><table><thead><tr><th>세부 주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>다중 패러다임 패턴</td><td>Hybrid Patterns</td><td>객체지향, 함수형, 이벤트 기반 등을 조합한 패턴으로 복잡한 시스템에 대응</td></tr><tr><td>도메인 특화 패턴</td><td>Domain-Specific Patterns</td><td>금융, 의료, IoT 등 특정 도메인에 특화된 문제 해결 방식</td></tr><tr><td>메타 패턴</td><td>Meta Patterns</td><td>여러 디자인 패턴을 결합해 복잡한 요구사항을 추상화하고 단순화</td></tr><tr><td>클린 아키텍처</td><td>Dependency Inversion Principle</td><td>의존성 역전 원칙 기반 설계로 유지보수성과 테스트 용이성 확보</td></tr><tr><td>AI 기반 확장</td><td>AI Design Patterns</td><td>AI 시스템 특성 (모델, 추론, 데이터 흐름 등) 에 맞춘 설계 패턴</td></tr><tr><td>양자 기반 확장</td><td>Quantum Patterns</td><td>양자 알고리즘과 시스템에 맞춘 새로운 유형의 설계 패턴</td></tr></tbody></table><h4 id=적용-기술-및-시스템-환경-변화>적용 기술 및 시스템 환경 변화<a hidden class=anchor aria-hidden=true href=#적용-기술-및-시스템-환경-변화>#</a></h4><table><thead><tr><th>카테고리</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>엣지 컴퓨팅</td><td>Edge Design Patterns</td><td>엣지 디바이스의 리소스 제약, 실시간 요구에 최적화된 패턴</td></tr><tr><td>클라우드 네이티브</td><td>Cloud Design Patterns</td><td>마이크로서비스, 서버리스 등 클라우드 환경을 위한 구조화된 설계</td></tr><tr><td>분산 시스템</td><td>Distributed System Patterns</td><td>Circuit Breaker, Timeout, Bulkhead 등의 복원력 패턴</td></tr><tr><td>리액티브 시스템</td><td>Reactive Patterns</td><td>이벤트 기반 비동기 시스템을 위한 CQRS, Event Sourcing 등</td></tr></tbody></table><h4 id=패턴의-교육적협업적-가치>패턴의 교육적·협업적 가치<a hidden class=anchor aria-hidden=true href=#패턴의-교육적협업적-가치>#</a></h4><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>공통 언어로서의 패턴</td><td>팀 간 의사소통을 원활히 하고 설계 품질을 정량화하는 데 기여</td></tr><tr><td>교육 및 훈련 필요성</td><td>패턴 이해도를 높이기 위해 온보딩, 문서화, 워크숍 등 필요</td></tr><tr><td>실무 중심의 적용 전략</td><td>이론보다 실제 상황에 맞는 패턴과 원칙의 선택과 조합이 중요</td></tr></tbody></table><h4 id=패턴의-분류와-적용-유형>패턴의 분류와 적용 유형<a hidden class=anchor aria-hidden=true href=#패턴의-분류와-적용-유형>#</a></h4><table><thead><tr><th>유형</th><th>주요 예시</th><th>설명</th></tr></thead><tbody><tr><td>생성 패턴</td><td>Factory, Builder, Singleton 등</td><td>객체 생성 로직을 분리하고 유연하게 관리</td></tr><tr><td>구조 패턴</td><td>Adapter, Composite, Flyweight 등</td><td>객체 간 구조를 정리하고 재사용성을 높임</td></tr><tr><td>행위 패턴</td><td>Observer, Command, Strategy 등</td><td>객체 간 상호작용과 책임 분산을 조절</td></tr><tr><td>함수형 패턴</td><td>Monad, Functor 등</td><td>순수 함수 기반 상태 관리와 제어 흐름을 추상화</td></tr><tr><td>동시성 패턴</td><td>Thread Pool, Producer-Consumer, Actor Model 등</td><td>안전한 멀티스레드 운영과 작업 분산을 처리</td></tr><tr><td>성능 최적화 패턴</td><td>Lazy Loading, Object Pool 등</td><td>리소스 절약과 빠른 응답성 확보</td></tr><tr><td>캐싱 패턴</td><td>Cache Aside, Write-Through 등</td><td>데이터 일관성과 접근 속도 개선</td></tr></tbody></table><h4 id=자동화-및-검증-도입>자동화 및 검증 도입<a hidden class=anchor aria-hidden=true href=#자동화-및-검증-도입>#</a></h4><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>패턴 기반 코드 생성</td><td>AI 도구가 요구사항에 따라 적절한 디자인 패턴 기반 코드를 자동 생성</td></tr><tr><td>수학적 검증 및 형식화</td><td>패턴의 정확성과 안정성을 보장하기 위한 형식적 방법론 및 수학적 모델 기반 검증</td></tr></tbody></table><h4 id=오용-및-실무-이슈>오용 및 실무 이슈<a hidden class=anchor aria-hidden=true href=#오용-및-실무-이슈>#</a></h4><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>과도한 패턴 적용</td><td>문제에 맞지 않는 패턴 사용은 오히려 복잡성과 성능 저하를 초래</td></tr><tr><td>레거시 적용 한계</td><td>기존 시스템에서는 구조적 제약으로 인해 일부 패턴 적용이 제한됨</td></tr></tbody></table><h3 id=반드시-학습해야할-내용>반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#반드시-학습해야할-내용>#</a></h3><table><thead><tr><th>대분류</th><th>주제·세부 영역</th><th>핵심 학습 포인트 (무엇을, 왜)</th></tr></thead><tbody><tr><td><strong>1. 설계 원칙 & OOP</strong></td><td>SOLID · DRY · KISS · 캡슐화·다형성 등</td><td>유지보수성과 유연성을 높이는 객체지향·코드 품질 원칙 총정리</td></tr><tr><td><strong>2. GoF 패턴 분류</strong></td><td>Creational · Structural · Behavioral</td><td>23 개 패턴의 의도·구조·적용 시나리오 체득</td></tr><tr><td><strong>3. 패턴 선택·적용 전략</strong></td><td>문제 분석·패턴 선정 기준 · 안티패턴→패턴 전환</td><td>상황별 최적 패턴 선택·리팩터링 기법</td></tr><tr><td><strong>4. 시각화 & 문서화 도구</strong></td><td>UML(클래스·시퀀스) · 패턴 카탈로그 작성법</td><td>설계 의도 공유·코드 리뷰 효율화</td></tr><tr><td><strong>5. 고급/엔터프라이즈 패턴</strong></td><td>- 엔터프라이즈 통합 (EIP) - 메시징 (pub/sub, request-reply)</td><td>대규모 시스템 통합·비동기 아키텍처 설계</td></tr><tr><td><strong>6. 성능·메모리 패턴</strong></td><td>Lazy Loading · Prefetching Object Pool · Flyweight</td><td>연산·메모리 오버헤드 최소화, GC 부담 경감</td></tr><tr><td><strong>7. 보안 패턴</strong></td><td>Authentication · Authorization · TLS 관리</td><td>보안 요구사항을 설계 단계에서 해결</td></tr><tr><td><strong>8. 테스트 패턴</strong></td><td>DI · Test Double · POM · 테스트 자동화</td><td>테스트 가능성·품질 향상, CI/CD 연계</td></tr><tr><td><strong>9. 동시성·병렬 패턴</strong></td><td>Thread Pool, Reactor, Actor 등</td><td>멀티스레드·논블로킹 환경 문제 해결</td></tr><tr><td><strong>10. UI/프론트엔드 패턴</strong></td><td>MVC · 컴포넌트 패턴 · 상태 관리 (Flux 등)</td><td>재사용성·반응성 UI 설계</td></tr><tr><td><strong>11. 클라우드 & MSA 패턴</strong></td><td>서버리스·이벤트 기반·Saga·Circuit Breaker</td><td>마이크로서비스·클라우드 네이티브 확장성 확보</td></tr><tr><td><strong>12. 리액티브/비동기 패턴</strong></td><td>Reactive Streams · Back-pressure</td><td>고부하 환경의 실시간 데이터 처리</td></tr><tr><td><strong>13. 아키텍처 방법론</strong></td><td>Clean Architecture · DDD · 시스템 설계 원칙</td><td>계층·도메인 중심 설계, 확장·유지보수 전략</td></tr><tr><td><strong>14. 코드 품질 & 리팩토링</strong></td><td>Clean Code · Refactoring 패턴</td><td>점진적 품질 개선·기술 부채 관리</td></tr><tr><td><strong>15. 개발 프로세스 패턴</strong></td><td>Agile Design · TDD · DevOps 패턴</td><td>빠른 피드백·배포 자동화·개발 - 운영 협업</td></tr><tr><td><strong>16. 데이터·DB 패턴</strong></td><td>DAO · Repository · 데이터 파이프라인 패턴</td><td>데이터 접근 분리·대용량 처리 최적화</td></tr><tr><td><strong>17. AI/ML 패턴</strong></td><td>Feature Store, Model Registry 등</td><td>AI 시스템의 재현성·확장성·운영 패턴</td></tr><tr><td><strong>18. 블록체인 & IoT 패턴</strong></td><td>스마트 컨트랙트 설계 · 디바이스 게이트웨이</td><td>분산 원장·엣지 디바이스 통합 설계</td></tr><tr><td><strong>19. 지속 가능 SW 패턴</strong></td><td>그린 엔지니어링 · 에너지 효율 알고리즘</td><td>탄소·전력 절감형 소프트웨어 설계</td></tr><tr><td><strong>20. 학습·조직 역량</strong></td><td>코드 리뷰·기술 세미나·패턴 가이드라인</td><td>팀원 간 지식 공유·표준화·품질 확보</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=디자인-패턴-분류-및-핵심-용어>디자인 패턴 분류 및 핵심 용어<a hidden class=anchor aria-hidden=true href=#디자인-패턴-분류-및-핵심-용어>#</a></h3><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>패턴 개념</td><td>디자인 패턴 (Design Pattern)</td><td>소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책</td></tr><tr><td></td><td>안티 패턴 (Anti-pattern)</td><td>흔히 사용되지만 문제가 되거나 비효율적인 설계 방식</td></tr><tr><td></td><td>패턴 언어 (Pattern Language)</td><td>서로 연관된 패턴들의 집합으로, 복합 문제에 대한 해법을 체계적으로 제공</td></tr><tr><td>GoF 패턴</td><td>GoF (Gang of Four)</td><td>23 가지 디자인 패턴을 체계화한 4 인의 저자 그룹</td></tr><tr><td>생성 패턴</td><td>Factory Method</td><td>객체 생성을 서브클래스에 위임하는 패턴</td></tr><tr><td></td><td>Singleton</td><td>시스템에 하나의 인스턴스만 존재하도록 보장하는 패턴</td></tr><tr><td></td><td>Lazy Loading</td><td>실제 사용 시점까지 객체 생성을 지연시키는 기법</td></tr><tr><td>구조 패턴</td><td>MVC (Model-View-Controller)</td><td>UI, 로직, 데이터 모델을 분리하여 유지보수성을 높이는 구조</td></tr><tr><td>행위 패턴</td><td>Observer</td><td>상태 변경 시 등록된 객체에 알림을 전달하는 구조</td></tr><tr><td></td><td>Strategy</td><td>알고리즘을 런타임에 교체 가능하도록 추상화한 패턴</td></tr><tr><td></td><td>Command</td><td>요청을 객체로 캡슐화하여 실행/취소/저장 등을 가능하게 하는 패턴</td></tr><tr><td></td><td>Template Method</td><td>알고리즘 구조는 고정하고, 세부 구현은 서브클래스에 위임하는 패턴</td></tr><tr><td>자원 관리 패턴</td><td>Object Pool</td><td>생성 비용이 큰 객체를 재사용하는 구조로, 메모리/성능 최적화에 유리</td></tr></tbody></table><h3 id=객체지향-설계-원칙-및-설계-기법>객체지향 설계 원칙 및 설계 기법<a hidden class=anchor aria-hidden=true href=#객체지향-설계-원칙-및-설계-기법>#</a></h3><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>객체지향 원칙</td><td>SOLID</td><td>객체지향 설계의 5 가지 원칙: SRP, OCP, LSP, ISP, DIP</td></tr><tr><td></td><td>SRP (단일 책임 원칙)</td><td>하나의 클래스는 하나의 책임만 가져야 한다</td></tr><tr><td></td><td>OCP (개방/폐쇄 원칙)</td><td>확장에는 열려 있고 수정에는 닫혀 있어야 한다</td></tr><tr><td></td><td>LSP (리스코프 치환 원칙)</td><td>서브타입은 언제나 기반 타입으로 대체 가능해야 한다</td></tr><tr><td></td><td>ISP (인터페이스 분리 원칙)</td><td>사용하지 않는 기능에 의존하지 않도록 인터페이스 분리</td></tr><tr><td></td><td>DIP (의존 역전 원칙)</td><td>고수준 모듈이 저수준 모듈에 의존하지 않도록 한다</td></tr><tr><td>설계 철학</td><td>DRY (Don&rsquo;t Repeat Yourself)</td><td>중복을 피하고 재사용 가능한 설계 지향</td></tr><tr><td></td><td>KISS (Keep It Simple, Stupid)</td><td>단순함을 유지하라는 설계 원칙</td></tr><tr><td></td><td>YAGNI (You Aren&rsquo;t Gonna Need It)</td><td>실제로 필요할 때까지 구현하지 말 것</td></tr><tr><td>고급 설계</td><td>정책 기반 설계 (Policy-Based Design)</td><td>클래스의 동작을 정책 클래스로 구성하여 유연성과 재사용성 확보</td></tr><tr><td></td><td>의존성 주입 (Dependency Injection)</td><td>객체가 필요한 의존성을 외부로부터 주입받는 방식</td></tr><tr><td></td><td>제어 역전 (Inversion of Control)</td><td>프로그램 제어 흐름을 프레임워크가 담당하는 구조</td></tr></tbody></table><h3 id=객체지향-개념-및-구조적-원리>객체지향 개념 및 구조적 원리<a hidden class=anchor aria-hidden=true href=#객체지향-개념-및-구조적-원리>#</a></h3><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>OOP 기본</td><td>캡슐화 (Encapsulation)</td><td>객체의 내부 상태를 감추고 외부에는 인터페이스만 제공</td></tr><tr><td></td><td>추상화 (Abstraction)</td><td>불필요한 세부 정보를 숨기고 핵심적인 개념만 표현</td></tr><tr><td></td><td>다형성 (Polymorphism)</td><td>동일한 인터페이스로 다양한 구현체를 사용할 수 있는 성질</td></tr><tr><td></td><td>응집도 (Cohesion)</td><td>모듈 내부 구성 요소들이 얼마나 밀접하게 관련되어 있는가</td></tr><tr><td></td><td>결합도 (Coupling)</td><td>다른 모듈에 얼마나 의존적인가. 낮은 결합도가 바람직함</td></tr><tr><td>설계 표현</td><td>UML</td><td>소프트웨어 구조와 동작을 시각화하기 위한 표준 모델링 언어</td></tr></tbody></table><h3 id=ai-및-현대-아키텍처-관련-용어>AI 및 현대 아키텍처 관련 용어<a hidden class=anchor aria-hidden=true href=#ai-및-현대-아키텍처-관련-용어>#</a></h3><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>AI 개념</td><td>Agentic AI (에이전틱 AI)</td><td>자율적으로 목표를 설정하고 행동하는 AI 에이전트</td></tr><tr><td></td><td>SLM (소형 언어 모델)</td><td>엣지 환경 등에서 경량화된 특화된 언어 모델</td></tr><tr><td></td><td>RAG (검색 기반 생성)</td><td>외부 지식을 검색하여 생성 과정에 통합하는 AI 기술</td></tr><tr><td>아키텍처 원리</td><td>클린 아키텍처 (Clean Architecture)</td><td>의존성 역전 원칙 기반의 계층적 아키텍처로 유지보수성 향상</td></tr><tr><td>시스템 구조 설계</td><td>CQRS</td><td>읽기와 쓰기 연산을 분리하여 확장성과 성능을 최적화</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://refactoring.guru/design-patterns>Refactoring Guru – Design Patterns</a></li><li><a href=https://sourcemaking.com/design_patterns>SourceMaking – Design Patterns</a></li><li><a href=https://en.wikipedia.org/wiki/Software_design_pattern>Wikipedia – Software design pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Creational_pattern>Wikipedia – Creational pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Structural_pattern>Wikipedia – Structural pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Strategy_pattern>Wikipedia – Strategy pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Adapter_pattern>Wikipedia – Adapter pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Singleton_pattern>Wikipedia – Singleton pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Visitor_pattern>Wikipedia – Visitor pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller>Wikipedia – Model–View–Controller</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>