<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Serverless Architecture | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Architecture,Architecture-Styles,Cloud-Native-Architecture,Serverless,Function-as-a-Service,Backend-as-a-Service"><meta name=description content="Serverless Architecture 는 개발자가 인프라 관리 없이 코드 (함수) 를 클라우드에 배포하고, 이벤트 기반으로 자동 실행·확장하며 **비용 효율성**, **운영 오버헤드 감소**, **빠른 시장 출시**를 달성하는 클라우드 네이티브 구성이며, FaaS 와 BaaS 가 핵심이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Serverless Architecture"><meta property="og:description" content="Serverless Architecture 는 개발자가 인프라 관리 없이 코드 (함수) 를 클라우드에 배포하고, 이벤트 기반으로 자동 실행·확장하며 **비용 효율성**, **운영 오버헤드 감소**, **빠른 시장 출시**를 달성하는 클라우드 네이티브 구성이며, FaaS 와 BaaS 가 핵심이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Serverless Architecture"><meta name=twitter:description content="Serverless Architecture 는 개발자가 인프라 관리 없이 코드 (함수) 를 클라우드에 배포하고, 이벤트 기반으로 자동 실행·확장하며 **비용 효율성**, **운영 오버헤드 감소**, **빠른 시장 출시**를 달성하는 클라우드 네이티브 구성이며, FaaS 와 BaaS 가 핵심이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":5,"name":"Serverless Architecture","item":"https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Serverless Architecture</h1><div class=post-description>Serverless Architecture 는 개발자가 인프라 관리 없이 코드 (함수) 를 클라우드에 배포하고, 이벤트 기반으로 자동 실행·확장하며 <strong>비용 효율성</strong>, <strong>운영 오버헤드 감소</strong>, <strong>빠른 시장 출시</strong>를 달성하는 클라우드 네이티브 구성이며, FaaS 와 BaaS 가 핵심이다.</div></header><div class=post-content><h2 id=serverless-architecture>Serverless Architecture<a hidden class=anchor aria-hidden=true href=#serverless-architecture>#</a></h2><p>Serverless Architecture(서버리스 아키텍처) 는 개발자가 서버 인프라를 직접 관리하지 않고, 클라우드 서비스 제공자가 컴퓨팅 리소스의 프로비저닝, 확장, 운영을 자동으로 처리하는 현대적 아키텍처 스타일이다. 대표적으로 Function as a Service(FaaS, 함수형 서비스) 와 Backend as a Service(BaaS, 백엔드 서비스) 가 있으며, 이벤트 기반 트리거, 자동 확장, 사용량 기반 과금, 빠른 배포와 높은 확장성을 특징으로 한다. 이로 인해 개발자는 비즈니스 로직 구현에 집중할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>Serverless Architecture(서버리스 아키텍처) 는 서버 인프라 관리 없이, 클라우드 서비스 제공자가 모든 인프라 운영을 책임지고, 개발자는 코드 (주로 함수 단위) 만 작성하여 배포하는 아키텍처 스타일이다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><p><strong>서버리스 컴퓨팅 (Serverless Computing)</strong></p><ul><li>클라우드 제공업체가 서버 인프라를 완전히 관리하는 실행 모델</li><li>개발자는 서버 프로비저닝, 확장, 유지보수에서 해방됨</li><li>" 서버가 없다 " 는 의미가 아니라 " 서버 관리가 없다 " 는 의미</li><li>종류:<ul><li><strong>Function as a Service (FaaS)</strong>: 이벤트 trigger 로 코드를 실행, 클라우드 제공</li><li><strong>Backend as a Service (BaaS)</strong>: 인증, DB, 메시징 등 관리형 서비스 활용</li></ul></li></ul><p><strong>이벤트 기반 아키텍처 (Event-Driven Architecture)</strong></p><ul><li>특정 이벤트나 트리거에 의해 함수가 실행되는 방식</li><li>HTTP 요청, 데이터베이스 변경, 파일 업로드 등이 이벤트 소스가 됨</li><li>비동기적이고 반응형 시스템 구조</li></ul><p><strong>무상태성 (Statelessness)</strong></p><ul><li>함수 간 상태 정보를 공유하지 않는 설계 원칙</li><li>각 함수 실행은 독립적이며 이전 실행과 무관</li><li>외부 저장소를 통해 상태 관리 필요</li></ul><h4 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h4><p><strong>자동 확장성 (Auto Scaling)</strong></p><ul><li>요청량에 따라 자동으로 리소스를 확장하거나 축소</li><li>제로 스케일링 (Zero Scaling) 지원으로 비용 최적화</li><li>트래픽 급증 시 즉시 대응 가능</li></ul><p><strong>사용량 기반 과금 (Pay-per-Use)</strong></p><ul><li>실제 코드 실행 시간에 대해서만 과금</li><li>유휴 시간에 대한 비용 부담 없음</li><li>예측 불가능한 워크로드에 대한 비용 효율성</li></ul><h4 id=실무-구현-연관성>실무 구현 연관성<a hidden class=anchor aria-hidden=true href=#실무-구현-연관성>#</a></h4><p><strong>아키텍처 설계 측면</strong></p><ul><li>마이크로서비스 아키텍처와의 자연스러운 결합</li><li>API 우선 설계 (API-First Design) 접근법 활용</li><li>이벤트 소싱 (Event Sourcing) 패턴 적용</li></ul><p><strong>개발 프로세스 측면</strong></p><ul><li>CI/CD 파이프라인과의 긴밀한 통합</li><li>Infrastructure as Code (IaC) 활용 필수</li><li>모니터링 및 관찰성 (Observability) 강화 필요</li></ul><p><strong>운영 관리 측면</strong></p><ul><li>DevOps 문화와의 시너지 효과</li><li>분산 시스템 관리 복잡성 증가</li><li>보안 모델의 변화 (제로 트러스트 보안)</li></ul><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>서버리스 아키텍처의 등장 배경은 전통적인 서버 관리의 복잡성과 비효율성에서 시작된다. 2014 년 아마존이 AWS Lambda 를 출시하면서 Function as a Service (FaaS) 의 개념이 본격적으로 도입되었다. 이전에는 개발팀이 하드웨어 프로비저닝, 운영체제 관리, 보안 업데이트, 백업 등 인프라 관련 업무에 상당한 시간과 자원을 투입해야 했다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p><strong>주요 목적</strong></p><ul><li>인프라 관리 복잡성 제거를 통한 개발 생산성 향상</li><li>비용 효율성 증대를 통한 운영비 절감</li><li>자동 확장성을 통한 안정적인 서비스 제공</li><li>빠른 출시 시간 (Time-to-Market) 단축</li></ul><p><strong>필요성</strong></p><ul><li>급변하는 비즈니스 요구사항에 대한 민첩한 대응</li><li>예측 불가능한 트래픽 패턴에 대한 효과적인 대응</li><li>개발 리소스의 핵심 업무 집중 필요성</li><li>스타트업과 중소기업의 인프라 비용 부담 해결</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li><strong>이벤트 처리 (Event Processing)</strong><ul><li>HTTP 요청, 데이터베이스 트리거, 파일 업로드 등 다양한 이벤트 처리</li><li>실시간 데이터 스트림 처리</li><li>스케줄링된 작업 실행</li></ul></li><li><strong>API 엔드포인트 제공</strong><ul><li>RESTful API 및 GraphQL API 구현</li><li>마이크로서비스 간 통신 지원</li><li>써드파티 서비스 통합</li></ul></li><li><strong>데이터 처리 및 변환</strong><ul><li>실시간 데이터 분석 및 변환</li><li>이미지/비디오 처리</li><li>로그 분석 및 집계</li></ul></li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>동적 확장성 (Dynamic Scalability)</strong>:<br>서버리스 함수는 요청량에 따라 자동으로 확장되며, 트래픽이 없을 때는 제로 스케일링을 통해 리소스를 완전히 해제한다.</li><li><strong>이벤트 기반 실행 (Event-Driven Execution)</strong>:<br>함수는 특정 이벤트가 발생했을 때만 실행되며, 이벤트가 없으면 비활성 상태를 유지한다.</li><li><strong>단기 실행 (Short-Lived Execution)</strong>:<br>대부분의 서버리스 플랫폼은 함수 실행 시간에 제한을 두어 (예: AWS Lambda 15 분) 단기 실행에 최적화되어 있다.</li><li><strong>관리형 인프라 (Managed Infrastructure)</strong>:<br>모든 인프라 관리는 클라우드 제공업체가 담당하며, 개발자는 코드 작성에만 집중할 수 있다.</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ul><li><strong>단일 책임 원칙 (Single Responsibility Principle)</strong>:<br>각 함수는 하나의 명확한 기능만을 수행해야 하며, 복잡한 로직은 여러 함수로 분리한다.</li><li><strong>무상태 설계 (Stateless Design)</strong>:<br>함수 간에는 상태를 공유하지 않으며, 필요한 상태는 외부 저장소를 통해 관리한다.</li><li><strong>멱등성 (Idempotency)</strong>:<br>동일한 입력에 대해 여러 번 실행해도 같은 결과를 보장해야 한다.</li><li><strong>장애 복원력 (Fault Tolerance)</strong>:<br>개별 함수의 장애가 전체 시스템에 영향을 주지 않도록 설계한다.</li></ul><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><p><strong>이벤트 기반 처리 원리</strong></p><pre class=mermaid>graph TD
    A[이벤트 발생] --&gt; B[이벤트 라우팅]
    B --&gt; C[함수 트리거]
    C --&gt; D[리소스 할당]
    D --&gt; E[함수 실행]
    E --&gt; F[결과 반환]
    F --&gt; G[리소스 해제]
</pre><p>이벤트가 발생하면 클라우드 플랫폼이 해당 이벤트를 적절한 함수로 라우팅하고, 필요한 컴퓨팅 리소스를 동적으로 할당하여 함수를 실행한 후 결과를 반환하고 리소스를 해제한다.</p><p><strong>자동 확장 원리</strong></p><pre class=mermaid>graph LR
    A[트래픽 증가] --&gt; B[새 인스턴스 생성]
    B --&gt; C[로드 분산]
    C --&gt; D[병렬 처리]
    D --&gt; E[트래픽 감소]
    E --&gt; F[인스턴스 해제]
</pre><p>트래픽이 증가하면 플랫폼이 자동으로 새로운 함수 인스턴스를 생성하여 로드를 분산시키고, 트래픽이 감소하면 불필요한 인스턴스를 해제한다.</p><h3 id=작동-원리-및-방식>작동 원리 및 방식<a hidden class=anchor aria-hidden=true href=#작동-원리-및-방식>#</a></h3><p><strong>함수 라이프사이클</strong></p><pre class=mermaid>sequenceDiagram
    participant C as Client
    participant G as API Gateway
    participant P as Platform
    participant F as Function
    participant S as Storage

    C-&gt;&gt;G: HTTP Request
    G-&gt;&gt;P: Route Request
    P-&gt;&gt;P: Cold/Warm Start Check
    alt Cold Start
        P-&gt;&gt;P: Initialize Runtime
        P-&gt;&gt;F: Load Function Code
    end
    P-&gt;&gt;F: Execute Function
    F-&gt;&gt;S: Access External Data
    S-&gt;&gt;F: Return Data
    F-&gt;&gt;P: Return Result
    P-&gt;&gt;G: Response
    G-&gt;&gt;C: HTTP Response
</pre><p>클라이언트 요청이 API Gateway 를 통해 들어오면, 플랫폼은 함수가 이미 실행 중인지 (Warm Start) 또는 새로 시작해야 하는지 (Cold Start) 를 확인한다. Cold Start 의 경우 런타임 환경을 초기화하고 함수 코드를 로드한 후 실행한다.</p><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p>서버리스 아키텍처는 여러 핵심 구성 요소들이 유기적으로 결합된 형태이다. 각 요소는 자동 확장, 무상태, 종량 과금이라는 Serverless 핵심 원칙과 연관되며, 이벤트 기반 호출 흐름을 지원한다.</p><pre class=mermaid>graph TB
    subgraph &#34;Client Layer&#34;
        A[Web Client]
        B[Mobile Client]
        C[IoT Device]
    end
    
    subgraph &#34;API Layer&#34;
        D[API Gateway]
        E[Load Balancer]
    end
    
    subgraph &#34;Function Layer (FaaS)&#34;
        F[Authentication Function]
        G[Business Logic Function]
        H[Data Processing Function]
    end
    
    subgraph &#34;Backend Services (BaaS)&#34;
        I[Database]
        J[Object Storage]
        K[Message Queue]
        L[Third-party APIs]
    end
    
    subgraph &#34;Event Sources&#34;
        M[HTTP Events]
        N[Database Events]
        O[File Events]
        P[Schedule Events]
    end
    
    A --&gt; D
    B --&gt; D
    C --&gt; D
    D --&gt; F
    D --&gt; G
    D --&gt; H
    F --&gt; I
    G --&gt; I
    G --&gt; J
    H --&gt; K
    H --&gt; L
    M --&gt; F
    N --&gt; G
    O --&gt; H
    P --&gt; H
</pre><h4 id=구성요소>구성요소<a hidden class=anchor aria-hidden=true href=#구성요소>#</a></h4><table><thead><tr><th><strong>구분</strong></th><th><strong>구성요소</strong></th><th><strong>기능</strong></th><th><strong>역할</strong></th><th><strong>특징</strong></th></tr></thead><tbody><tr><td><strong>필수</strong></td><td>API Gateway</td><td>클라이언트 요청을 함수로 라우팅</td><td>인증, 권한 부여, 요청/응답 변환 및 트래픽 제어</td><td>HTTP 엔드포인트 제공, REST/GraphQL 지원</td></tr><tr><td></td><td>Function Runtime</td><td>함수 코드 실행 환경 제공</td><td>코드 실행, 메모리/수명 주기 관리, 로깅 지원</td><td>Node.js, Python, Go 등 다양한 언어 지원</td></tr><tr><td></td><td>Event Sources</td><td>함수 실행을 유발하는 이벤트 제공</td><td>HTTP 요청, DB 변경, 파일 업로드 등 이벤트 트리거 역할</td><td>동기/비동기 이벤트 처리 모두 지원</td></tr><tr><td></td><td>Storage Services</td><td>데이터 저장소 제공</td><td>함수 실행 중 생성된 데이터의 저장 및 공유</td><td>DB, 객체 스토리지 (S3 등), 서버리스 파일시스템 포함</td></tr><tr><td><strong>선택</strong></td><td>Message Queues</td><td>비동기 메시지 처리 및 버퍼링</td><td>서비스 간 느슨한 결합, 트래픽 완충, 장애 전파 방지</td><td>확장성, 내결함성 강화 (예: SQS, Pub/Sub)</td></tr><tr><td></td><td>Monitoring & Logging</td><td>시스템 성능/오류 모니터링 및 추적</td><td>애플리케이션 상태 가시성 제공</td><td>로그 집계, 메트릭 수집, 분산 트레이싱 (X-Ray 등)</td></tr><tr><td></td><td>Security Services</td><td>인증, 인가, 데이터 보호 기능 제공</td><td>제로 트러스트 기반 보안 정책 적용 및 관리</td><td>IAM, API Key, 암호화, VPC 격리 등 포함</td></tr><tr><td></td><td>CI/CD Pipeline</td><td>코드 자동 배포 및 테스트</td><td>개발 - 운영 간 파이프라인 자동화, 생산성 향상</td><td>IaC 연동, Git 기반 워크플로우 적용 가능</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th><strong>구현 기법</strong></th><th><strong>정의</strong></th><th><strong>주요 구성 요소</strong></th><th><strong>주요 목적</strong></th><th><strong>실전 예시 (요약)</strong></th></tr></thead><tbody><tr><td><strong>Function as a Service (FaaS)</strong></td><td>개별 함수 단위로 배포되고, 트리거에 따라 실행되는 서버리스 실행 모델</td><td>- 함수 코드<br>- 트리거<br>- 런타임 환경<br>- IAM 역할</td><td>함수 단위 서비스 분리 및 확장성 확보</td><td>AWS Lambda + API Gateway (REST 처리)</td></tr><tr><td><strong>Backend as a Service (BaaS)</strong></td><td>인증, DB, 스토리지 등 백엔드 기능을 API 로 제공하는 관리형 백엔드 서비스</td><td>- 인증<br>- 데이터베이스<br>- 스토리지<br>- 푸시 알림</td><td>백엔드 인프라 부담 감소, 빠른 개발 가능</td><td>Firebase Auth + Firestore (사용자 인증 및 저장)</td></tr><tr><td><strong>이벤트 기반 아키텍처</strong></td><td>이벤트에 반응하여 함수나 서비스가 실행되는 비동기적 분산 시스템 패턴</td><td>- 이벤트 프로듀서<br>- 이벤트 라우터<br>- 이벤트 컨슈머</td><td>느슨한 결합 및 고확장성 확보</td><td>S3 업로드 트리거 → Lambda 이미지 처리</td></tr><tr><td><strong>Serverless 마이크로서비스</strong></td><td>각 기능을 독립 함수로 분리하여 API 를 통해 통신하는 마이크로서비스 아키텍처</td><td>- 독립 서비스<br>- API Gateway<br>- 분산 데이터 스토어</td><td>독립 배포, 기능별 확장, 장애 격리</td><td>Lambda 함수 기반 주문/재고/결제 서비스 분리 구성</td></tr></tbody></table><h4 id=추가-구현-기법-및-고급-패턴>추가 구현 기법 및 고급 패턴<a hidden class=anchor aria-hidden=true href=#추가-구현-기법-및-고급-패턴>#</a></h4><table><thead><tr><th>구현 기법</th><th>설명</th><th>실전 적용 고려사항</th></tr></thead><tbody><tr><td><strong>1. Step Functions / Orchestration</strong></td><td>서버리스 함수들을 정의된 순서대로 흐름 제어 (직렬/병렬/조건 분기 등)</td><td>AWS Step Functions, Azure Durable Functions 등</td></tr><tr><td><strong>2. EventBridge 기반 이벤트 브로커</strong></td><td>다수의 서비스 간 Pub/Sub 메시징 구조. 느슨한 결합 + 이벤트 라우팅</td><td>필터링, 리트라이, DLQ 구성이 필수</td></tr><tr><td><strong>3. API Gateway 기반 Aggregation</strong></td><td>여러 Lambda 함수로 분산된 로직을 하나의 API 로 통합</td><td>API Composition 패턴 + Mapping Template 활용</td></tr><tr><td><strong>4. GraphQL + Serverless Resolver</strong></td><td>단일 GraphQL Endpoint 에서 리졸버 별 Lambda 연결</td><td>AWS AppSync 또는 Apollo Server + Lambda</td></tr><tr><td><strong>5. Function Chaining with Queues</strong></td><td>함수 실행 결과를 다음 함수에 연결하는 구성. 비동기 파이프라인 구현</td><td>SQS/SNS → Lambda 체인 또는 S3 → EventBridge 활용</td></tr><tr><td><strong>6. Serverless Cron Jobs</strong></td><td>정기 실행 기반 작업 구성. 배치나 리포트 처리 등에 적합</td><td>CloudWatch Events / EventBridge Schedule 사용</td></tr><tr><td><strong>7. Serverless Data Pipeline</strong></td><td>데이터 수집 → 변환 → 저장 흐름을 Lambda + Kinesis + Glue 등으로 구성</td><td>처리 순서 보장, 장애 복구 처리 고려 필요</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>1. 운영 효율성</strong></td><td><strong>서버 관리 불필요</strong></td><td>인프라 유지보수, 패치, 확장 등의 작업이 불필요하여 운영 부담을 대폭 감소시킴</td></tr><tr><td></td><td><strong>자동 확장성</strong></td><td>요청 수 또는 트래픽에 따라 자동으로 함수 인스턴스를 확장/축소 (제로 스케일링 포함)</td></tr><tr><td></td><td><strong>무상태 구조 (Stateless)</strong></td><td>각 함수 실행이 독립적으로 수행되어 수평 확장 및 장애 격리에 유리함</td></tr><tr><td></td><td><strong>운영 복잡성 감소</strong></td><td>보안 업데이트, 장애 대응, 백업 등 대부분의 운영 책임을 클라우드 제공자가 담당</td></tr><tr><td></td><td><strong>내결함성</strong></td><td>개별 함수 실패가 전체 시스템에 영향을 주지 않으며, 고립성과 자동 복구가 가능함</td></tr><tr><td><strong>2. 비용 최적화</strong></td><td><strong>사용량 기반 과금</strong></td><td>실제 실행된 시간과 호출 횟수만큼만 과금되며, 유휴 상태일 경우 비용이 발생하지 않음 (Pay-per-execution)</td></tr><tr><td></td><td><strong>예측 불가능한 워크로드 대응</strong></td><td>트래픽 변동이 큰 서비스에 유리하며, 스팟 인스턴스 대비 더 정밀한 비용 제어 가능</td></tr><tr><td><strong>3. 개발 생산성</strong></td><td><strong>빠른 배포/릴리즈 속도</strong></td><td>인프라 설정 없이 바로 코드 배포 가능하며, CI/CD 파이프라인과 쉽게 통합됨</td></tr><tr><td></td><td><strong>빠른 프로토타이핑 및 MVP 출시</strong></td><td>아이디어 구현에서 서비스 배포까지의 사이클이 짧아 스타트업이나 실험적 서비스에 적합함</td></tr><tr><td></td><td><strong>비즈니스 로직 집중 가능</strong></td><td>서버나 인프라 관련 작업 없이 오직 애플리케이션 기능 구현에만 집중할 수 있어 개발 효율 극대화</td></tr><tr><td></td><td><strong>다양한 언어 지원</strong></td><td>Python, JavaScript, Go, Java, C# 등 주요 언어를 지원하여 개발자의 기술 선택 폭이 넓음</td></tr><tr><td><strong>4. 아키텍처 유연성</strong></td><td><strong>이벤트 기반 구조 지원</strong></td><td>HTTP 요청, 메시지 큐, 스토리지 변경 등 다양한 이벤트 소스로 유연한 아키텍처 설계가 가능</td></tr><tr><td></td><td><strong>마이크로서비스와 결합 용이</strong></td><td>단일 책임 함수 구조와 잘 맞으며, 도메인 분리와 확장 가능한 분산 시스템 설계에 적합함</td></tr></tbody></table><h3 id=단점과-문제점-그리고-해결방안>단점과 문제점 그리고 해결방안<a hidden class=anchor aria-hidden=true href=#단점과-문제점-그리고-해결방안>#</a></h3><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><table><thead><tr><th>카테고리</th><th>항목</th><th>설명</th><th>해결책 또는 우회 전략</th></tr></thead><tbody><tr><td>성능/지연</td><td>콜드 스타트 지연</td><td>비활성 상태의 함수가 새로 인스턴스될 때 초기화 지연 발생</td><td>Provisioned Concurrency, 함수 워밍업, 경량화 런타임 사용</td></tr><tr><td>실행 제한</td><td>시간 및 메모리 제약</td><td>플랫폼별로 함수 실행 시간 (예: 15 분) 및 메모리 제한 존재</td><td>작업 분할 (예: AWS Step Functions), 외부 워커 사용</td></tr><tr><td>플랫폼 종속성</td><td>벤더 락인</td><td>특정 클라우드 서비스 (API, 구성 방식 등) 에 종속</td><td>멀티클라우드 전략, OpenFaaS, Serverless Framework, 추상화 계층 도입</td></tr><tr><td>운영 복잡도</td><td>디버깅 및 로깅 어려움</td><td>분산 함수 호출 간의 흐름 추적이 어려움</td><td>OpenTelemetry, CloudWatch, DataDog 등 통합 트레이싱 도구 도입</td></tr><tr><td>상태 관리</td><td>무상태로 인한 제약</td><td>서버리스 함수는 기본적으로 상태를 저장하지 않기 때문에 외부 저장소 필요</td><td>Redis, DynamoDB, 외부 세션 저장소, 상태 저장 마이크로서비스 도입</td></tr><tr><td>네트워크 구조</td><td>네트워크 지연</td><td>다수 함수 간 호출 또는 외부 서비스 접근 시 네트워크 오버헤드 발생</td><td>함수 클러스터링, 데이터/함수 지역성 최적화, 캐싱 전략</td></tr><tr><td>테스트/개발 환경</td><td>로컬 환경 한계</td><td>실제 환경과 로컬 테스트 환경의 차이로 인해 사전 검증 어려움</td><td><code>localstack</code>, <code>sam-cli</code>, <code>serverless-offline</code> 등을 활용한 환경 구성</td></tr></tbody></table><h4 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h4><table><thead><tr><th>카테고리</th><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단 도구</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>성능</td><td>메모리 누수</td><td>GC 미작동, 파일 핸들/DB 연결 미종료, 정적 객체 과다 유지 등</td><td>성능 저하, 비용 증가, 장애 가능성</td><td>메모리 프로파일러, CloudWatch, NewRelic</td><td>정적 분석 도구, 연결 해제 코드 삽입, 정기 점검</td><td>리소스 풀링, 연결 해제 보장 코드, context manager 사용</td></tr><tr><td>보안</td><td>과도한 권한 부여</td><td>IAM 정책 부재, 최소 권한 원칙 미준수</td><td>민감 정보 노출, 무단 접근 가능</td><td>AWS IAM Access Analyzer, CloudTrail 등</td><td>최소 권한 정책, 정책 자동화 도구 사용</td><td>역할 기반 접근 제어, 암호화 및 키 관리 강화</td></tr><tr><td>비용</td><td>함수 호출 폭증</td><td>무한 루프, 트리거 오류, DDoS, 무제한 반복 호출 등</td><td>비용 폭증, 서비스 중단</td><td>비용 알림, Cloud Cost Explorer</td><td>리소스 제한 설정, 실행 횟수 제한, 코드 품질 점검</td><td>레이트 리미팅, 서킷 브레이커, 쿼터 설정</td></tr><tr><td>데이터 정합성</td><td>상태 불일치 및 경쟁 조건</td><td>다중 함수 간 상태 공유 미흡, 트랜잭션 부재, 멱등성 미보장</td><td>데이터 정합성 오류, 비즈니스 로직 오작동</td><td>로깅, 이벤트 로그 분석, 정합성 검증 로직</td><td>이벤트 소싱, SAGA/보상 트랜잭션 패턴 적용</td><td>멱등 처리, 락 기반 보장, 큐 기반 순차 처리</td></tr><tr><td>가용성</td><td>API 호출 실패</td><td>외부 시스템 실패, 의존 함수 장애, 리소스 초과</td><td>시스템 일부 기능 불가</td><td>상태 코드 로깅, Retry/Error log 분석</td><td>재시도 로직, 대체 경로 (fallback), 장애 격리</td><td>리트라이 + 지수 백오프, Dead Letter Queue</td></tr><tr><td>배포 리스크</td><td>함수 버전 간 충돌</td><td>트리거 및 이벤트 구조 변경, 의존 버전 불일치</td><td>호출 실패 또는 예외 발생</td><td>Canary 배포, 모니터링 + 롤백 조건 설정</td><td>버전 고정, 트리거 테스트 자동화, A/B 테스트 적용</td><td>점진적 배포, 블루그린 배포 전략 적용</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>도전 과제</strong></th><th><strong>원인</strong></th><th><strong>영향</strong></th><th><strong>대응 전략</strong></th></tr></thead><tbody><tr><td><strong>성능 최적화</strong></td><td>콜드 스타트 지연</td><td>초기 함수 로딩 지연, VPC 연결, 대용량 라이브러리</td><td>사용자 응답 지연, SLA 위반 가능성</td><td>Provisioned Concurrency, 함수 워밍업, 런타임 최적화</td></tr><tr><td></td><td>네트워크 오버헤드</td><td>클라우드 간 통신, 외부 API 호출 시 지연</td><td>처리 시간 증가, 비용 상승</td><td>CDN, 지역 분산 배포, Edge 서버리스 (예: Cloudflare Workers)</td></tr><tr><td><strong>관찰성 및 운영</strong></td><td>관측성 부족</td><td>짧은 함수 실행 시간, 이벤트 기반 호출로 트랜잭션 흐름 추적 어려움</td><td>장애 원인 진단 어려움, 운영 효율 저하</td><td>OpenTelemetry, X-Ray, 통합 로깅 및 메트릭 수집</td></tr><tr><td><strong>보안 및 규정 준수</strong></td><td>새로운 보안 위협 대응 필요 (예: Denial of Wallet)</td><td>비용 기반 공격, 멀티 테넌시 환경의 경계 불명확성</td><td>비용 손실, 인증/인가 취약점</td><td>제로 트러스트 모델, IAM 최소 권한, 요청 제한 정책</td></tr><tr><td></td><td>컴플라이언스 및 감사 대응</td><td>분산 환경에서의 감사 추적 어려움</td><td>법적/보안 규제 위반 위험</td><td>암호화, 감사 로그 중앙화, 정책 기반 접근 제어</td></tr><tr><td><strong>플랫폼 전략</strong></td><td>벤더 종속성 (Vendor Lock-in)</td><td>특정 CSP 의 독자적 서비스에 의존</td><td>이식성 제한, 장기 비용 증가</td><td>멀티 클라우드 CDK, OpenFaaS 등 추상화 도구 도입</td></tr><tr><td></td><td>복잡한 트랜잭션/워크플로우 처리</td><td>함수 간 상태 공유 불가, 복잡한 호출 체계</td><td>상태 비일관성, 복잡한 예외 처리</td><td>상태 머신 (Step Functions), 이벤트 소싱 기반 설계</td></tr><tr><td><strong>통합 및 마이그레이션</strong></td><td>레거시 시스템 통합</td><td>이질적인 시스템 아키텍처, 데이터 이전 어려움</td><td>통합 장애, 운영 이중화 비용</td><td>API Gateway + 래퍼 패턴, 점진적 마이그레이션 전략</td></tr><tr><td><strong>지능형 제어</strong></td><td>예측 기반 자동화 부족 (콜드 스타트 등)</td><td>트래픽 패턴 변동성, 통계 기반 스케일링의 한계</td><td>오버프로비저닝 또는 언더프로비저닝</td><td>트랜스포머 기반 예측 모델 도입, ML 기반 워밍업 제어</td></tr></tbody></table><h3 id=분류-기준별-유형>분류 기준별 유형<a hidden class=anchor aria-hidden=true href=#분류-기준별-유형>#</a></h3><table><thead><tr><th><strong>분류 기준</strong></th><th><strong>유형</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>실행 모델</strong></td><td>FaaS (Function as a Service)</td><td>함수 단위로 실행되는 서버리스 모델 (예: AWS Lambda, Azure Functions)</td></tr><tr><td></td><td>BaaS (Backend as a Service)</td><td>인증, DB, 스토리지 등 백엔드 기능을 API 기반으로 제공 (예: Firebase)</td></tr><tr><td><strong>트리거 방식</strong></td><td>동기식 호출 (Synchronous)</td><td>HTTP 요청과 같이 즉시 응답이 필요한 처리 방식</td></tr><tr><td></td><td>비동기식 호출 (Asynchronous)</td><td>이벤트, 큐, 스토리지 트리거 등 지연 응답이 허용되는 처리 방식</td></tr><tr><td><strong>구성 단위</strong></td><td>단일 함수 기반</td><td>독립적인 단일 함수로 구성되는 서버리스 구조</td></tr><tr><td></td><td>마이크로서비스 함수 조합</td><td>여러 함수로 구성된 서버리스 마이크로서비스 패턴 (컴포지션 기반 설계)</td></tr><tr><td><strong>실행 환경</strong></td><td>퍼블릭 클라우드 기반</td><td>AWS, Azure, GCP 등의 CSP 환경에서 실행</td></tr><tr><td></td><td>프라이빗/온프레미스 환경</td><td>자체 인프라 기반의 서버리스 플랫폼 (예: OpenFaaS, Knative)</td></tr><tr><td></td><td>엣지 서버리스 (Edge Serverless)</td><td>사용자 가까운 엣지에서 실행되는 분산 함수 (예: Cloudflare Workers, Deno Deploy)</td></tr><tr><td><strong>배포 방식</strong></td><td>배치 기반 배포</td><td>수동 배포 또는 간단한 스크립트를 통한 일괄 배포</td></tr><tr><td></td><td>CI/CD 자동화 기반</td><td>GitOps, 파이프라인 기반의 지속적 배포 (예: GitHub Actions + SAM)</td></tr><tr><td><strong>언어 런타임</strong></td><td>인터프리터 기반</td><td>Python, JavaScript, Ruby 등 빠른 시작과 유연성 중심</td></tr><tr><td></td><td>컴파일 기반</td><td>Java, Go,.NET 등 고성능 및 정적 타입 기반 환경</td></tr></tbody></table><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th>카테고리</th><th>사용 사례</th><th>목적</th><th>주요 구성 요소</th><th>기대 효과</th></tr></thead><tbody><tr><td>데이터 처리</td><td>이미지 리사이징 자동화</td><td>이미지 업로드 시 실시간 트랜스폼</td><td><strong>S3 + Lambda + CloudFront</strong></td><td>처리 자동화, 서버 운영 비용 절감, 확장성 확보</td></tr><tr><td></td><td>실시간 ETL 파이프라인</td><td>데이터 정제 및 적재</td><td><strong>Kinesis + Lambda + DynamoDB</strong></td><td>실시간 처리, 스케일 대응, ETL 자동화</td></tr><tr><td></td><td>IoT 센서 데이터 처리</td><td>고빈도 센서 데이터의 집계 및 저장</td><td><strong>IoT Core + Lambda + Timestream</strong></td><td>대규모 이벤트 처리, 유지 비용 최소화</td></tr><tr><td>이벤트 기반</td><td>실시간 알림 시스템</td><td>사용자/시스템 이벤트 발생 시 알림 전송</td><td><strong>SNS/SQS + Lambda + Firebase/Slack/Webhook</strong></td><td>빠른 이벤트 반응, 사용자 경험 향상</td></tr><tr><td></td><td>웹훅 이벤트 처리 (예: Stripe, GitHub)</td><td>외부 시스템 이벤트 수신 후 내부 처리 연동</td><td><strong>API Gateway + Lambda + 외부 서비스 (Webhook)</strong></td><td>자동 트리거, 워크플로우 통합</td></tr><tr><td>AI / ML</td><td>머신러닝 모델 인퍼런스</td><td>예측, 분류 등 AI 서비스 실행</td><td><strong>S3 + Lambda + SageMaker Endpoint or TensorFlow.js</strong></td><td>비용 절감, 온디맨드 AI 실행</td></tr><tr><td></td><td>상품 추천 / 이미지 분류</td><td>사용자 맞춤형 추천 또는 자동 라벨링</td><td><strong>Lambda + Pretrained Model + DynamoDB</strong></td><td>빠른 응답 시간, 서버 관리 최소화</td></tr><tr><td>챗봇/자동화</td><td>챗봇 백엔드</td><td>사용자 질의 처리, 응답 자동화</td><td><strong>API Gateway + Lambda + NLP API (e.g., Lex, GPT)</strong></td><td>무중단 서비스, 손쉬운 유지보수</td></tr><tr><td>모바일 백엔드</td><td>모바일 앱 API 서버</td><td>경량 API 백엔드, 서버 없는 아키텍처 구현</td><td><strong>API Gateway + Lambda + RDS/DynamoDB</strong></td><td>신속한 개발, 자동 확장, 비용 최적화</td></tr><tr><td>전자상거래</td><td>쇼핑몰 백엔드 처리 (상품, 채팅, 세션)</td><td>고빈도 트래픽 대응, 빠른 CRUD</td><td><strong>Lambda + DynamoDB</strong></td><td>빠른 응답 속도, 트래픽 급증 대응 용이</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-넷플릭스의-동영상-인코딩-시스템>사례 1: 넷플릭스의 동영상 인코딩 시스템<a hidden class=anchor aria-hidden=true href=#사례-1-넷플릭스의-동영상-인코딩-시스템>#</a></h4><p>넷플릭스는 서버리스 아키텍처를 활용하여 대용량 동영상 콘텐츠의 인코딩과 배포 시스템을 구축했다.</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    A[콘텐츠 업로드] --&gt; B[S3 저장소]
    B --&gt; C[Lambda 트리거]
    C --&gt; D[동영상 분할]
    D --&gt; E[병렬 인코딩]
    E --&gt; F[품질별 변환]
    F --&gt; G[CDN 배포]
    G --&gt; H[사용자 스트리밍]
</pre><p><strong>워크플로우</strong>:</p><ol><li>콘텐츠 제작팀이 원본 동영상을 S3 에 업로드</li><li>S3 이벤트가 Lambda 함수를 트리거</li><li>Lambda 함수가 동영상을 5 분 단위로 분할</li><li>각 세그먼트를 60 개의 병렬 스트림으로 인코딩</li><li>다양한 해상도와 품질로 변환</li><li>CloudFront CDN 을 통해 전 세계 배포</li></ol><p><strong>서버리스 아키텍처의 역할</strong>:</p><ul><li>자동 확장: 업로드 volume 에 따라 자동으로 처리 능력 조절</li><li>비용 최적화: 실제 인코딩 시간에 대해서만 과금</li><li>병렬 처리: 동시에 수백 개의 인코딩 작업 실행</li><li>내결함성: 개별 세그먼트 처리 실패가 전체에 미치는 영향 최소화</li></ul><p><strong>서버리스 적용 전후 차이점</strong>:</p><ul><li><strong>적용 전 (전통적 서버 기반)</strong>:<ul><li>24/7 실행되는 인코딩 서버 클러스터 필요</li><li>피크 시간 대비 과도한 리소스 프로비저닝</li><li>서버 관리, 패치, 모니터링 등 운영 부담</li><li>장애 시 전체 시스템 영향</li></ul></li><li><strong>적용 후 (서버리스 기반)</strong>:<ul><li>필요 시에만 리소스 사용</li><li>자동 확장으로 처리량 최적화</li><li>인프라 관리 부담 제거</li><li>개별 함수 장애가 전체에 미치는 영향 최소화</li></ul></li></ul><h4 id=사례-2-이미지-처리-파이프라인>사례 2: 이미지 처리 파이프라인<a hidden class=anchor aria-hidden=true href=#사례-2-이미지-처리-파이프라인>#</a></h4><p><strong>시스템 구성</strong>: S3(스토리지), Lambda(함수), DynamoDB(메타데이터 저장)</p><p><strong>Workflow</strong>: 이미지 업로드 → S3 이벤트 → Lambda 실행 → 이미지 변환/저장 → DynamoDB 기록<br><strong>다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant User
    participant S3
    participant Lambda
    participant DynamoDB

    User-&gt;&gt;S3: 이미지 업로드
    S3-&gt;&gt;Lambda: 이벤트 트리거
    Lambda-&gt;&gt;S3: 이미지 처리/저장
    Lambda-&gt;&gt;DynamoDB: 메타데이터 기록
</pre><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>고려사항</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th></tr></thead><tbody><tr><td><strong>아키텍처 설계</strong></td><td>함수 크기 최적화</td><td>큰 함수는 콜드 스타트 지연, 배포 및 유지보수 복잡도 증가</td><td>단일 책임 원칙 (SRP), 함수 분리, 경량 라이브러리 사용</td></tr><tr><td></td><td>상태 관리 분리</td><td>서버리스 함수는 기본적으로 무상태 (stateless) 환경</td><td>외부 DB/스토리지 활용 (S3, RDS 등)</td></tr><tr><td></td><td>함수 호출 구조</td><td>과도한 함수 간 호출은 &ldquo;Lambda Pinball&rdquo; 안티패턴을 유발</td><td>Step Functions 등 오케스트레이터 활용</td></tr><tr><td><strong>성능 관리</strong></td><td>콜드 스타트 대응</td><td>초기 요청 시 함수 초기화 지연 (특히 VPC 연결, 대용량 라이브러리 사용 시)</td><td>Provisioned Concurrency, Lambda Layer</td></tr><tr><td></td><td>메모리 할당 최적화</td><td>메모리는 CPU 성능과 비용에 직접 영향</td><td>벤치마크 기반 최적 메모리 설정 (128MB~3GB 조정)</td></tr><tr><td><strong>보안 관리</strong></td><td>IAM 권한 최소화</td><td>과도한 권한 설정은 보안 취약점 초래 가능</td><td>Least Privilege 원칙, 함수 단위 정책 설정</td></tr><tr><td></td><td>외부 호출 제어</td><td>트리거 오용, 인가되지 않은 API 접근 등 보안 리스크 존재</td><td>API Gateway + WAF 설정, 네트워크 격리 (VPC/Subnet)</td></tr><tr><td><strong>모니터링 및 운영</strong></td><td>로그 및 트레이싱 통합</td><td>서버리스 환경은 분산되어 있어 디버깅 및 모니터링 어려움</td><td>CloudWatch, X-Ray, OpenTelemetry 연동</td></tr><tr><td></td><td>실행 흐름 가시성 확보</td><td>이벤트 기반 비동기 호출로 인해 호출 경로 추적 어려움</td><td>트랜잭션 ID 기반 로깅, 구조화된 로그 설계</td></tr><tr><td><strong>비용 관리</strong></td><td>호출 및 리소스 비용 관리</td><td>짧은 실행이라도 고빈도 호출 또는 외부 API 사용으로 비용 급증 가능</td><td>비용 알림 설정, 호출 패턴 분석, 리소스 프로파일링</td></tr><tr><td><strong>개발 프로세스</strong></td><td>로컬 개발 및 테스트 환경 구성</td><td>클라우드에서만 실행 가능한 특성 때문에 개발자 생산성 저하 가능</td><td>SAM CLI, LocalStack, Serverless Framework 활용</td></tr><tr><td><strong>플랫폼 전략</strong></td><td>벤더 종속성 관리</td><td>특정 CSP 의 서비스에 지나치게 의존하면 이식성 저하</td><td>추상화 계층 도입, 멀티 클라우드 CDK/Infra 도구 사용</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>최적화 요소</strong></th><th><strong>설명</strong></th><th><strong>권장 전략</strong></th></tr></thead><tbody><tr><td><strong>1. 성능 최적화</strong></td><td>콜드 스타트 최소화</td><td>함수가 초기화되는 시점의 지연 최소화</td><td>프로비저닝된 동시성 설정, 워밍업 트리거 사용, 공통 패키지 Layer 분리</td></tr><tr><td></td><td>함수 실행 속도 향상</td><td>실행 로직의 지연 최소화</td><td>경량화된 코드 구성, 단일 책임 함수, 효율적인 알고리즘, 비동기/배치 처리 적용</td></tr><tr><td></td><td>초기화 외부화</td><td>DB/SDK 초기화를 핸들러 외부로 분리하여 반복 초기화 방지</td><td>핸들러 외부에 클라이언트 생성 (<code>boto3</code>, <code>pg</code>, etc.)</td></tr><tr><td><strong>2. 코드 최적화</strong></td><td>패키지 경량화</td><td>배포 크기 축소를 통한 로딩 시간 단축</td><td>공통 라이브러리를 Layer 로 분리, 최소 의존성만 포함한 배포 패키지 구성</td></tr><tr><td></td><td>언어 및 런타임 선택</td><td>실행 속도와 Cold Start 성능에 영향을 주는 실행 환경</td><td>Node.js, Go, Python 등 최적 언어 선택, 런타임 버전 최신 유지</td></tr><tr><td><strong>3. 리소스 최적화</strong></td><td>메모리/타임아웃 설정 튜닝</td><td>과도하거나 부족한 설정은 비용 또는 오류 발생 요인이 됨</td><td>CloudWatch 기반 리소스 프로파일링, 점진적 조정</td></tr><tr><td></td><td>사용량 기반 자원 관리</td><td>리소스를 효율적으로 사용하지 않으면 비용만 증가</td><td>리소스 자동 할당 기반의 Autoscaling, 예약/스케줄링 처리</td></tr><tr><td><strong>4. 네트워크 최적화</strong></td><td>외부 호출 최소화</td><td>외부 API 또는 DB 호출 지연이 전체 성능 저하를 유발</td><td>캐싱 계층 도입, 연결 풀링, 비동기 큐 또는 배치 처리 활용</td></tr><tr><td><strong>5. 운영 자동화</strong></td><td>배포 자동화</td><td>환경 불일치, 수동 오류 방지</td><td>IaC 도구 (Terraform, CDK) 기반 정의 + CI/CD 파이프라인 연동</td></tr><tr><td></td><td>테스트 자동화</td><td>서버리스 특성상 로컬 환경과의 차이 존재 → 신뢰도 있는 테스트 필요</td><td>로컬 테스트 프레임워크 활용 (<code>SAM</code>, <code>LocalStack</code>, <code>pytest</code>, <code>jest</code> 등)</td></tr><tr><td></td><td>성능 분석 및 벤치마크</td><td>최적화 지표 기반 개선</td><td>CloudWatch, X-Ray, vHive, REAP, LibProf 등을 통한 지표 분석 및 cold/warm 비교</td></tr><tr><td><strong>6. 비용 최적화</strong></td><td>종량 과금 모델 이해</td><td>GB- 초 + 호출 횟수 기반 과금 구조</td><td>짧은 실행 + 적정 메모리 조합 설계, 호출 횟수 최소화, 불필요한 트리거 제거</td></tr><tr><td></td><td>FinOps 전략 적용</td><td>사용량 시각화 및 예산 예측</td><td>비용 대시보드 구성, 경고 임계값 설정, 리소스 태깅 기반 비용 분석</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>1. 아키텍처</strong></td><td>서버리스 구조</td><td>FaaS, BaaS</td><td>서버 인프라 관리 없이 함수 단위 또는 관리형 백엔드로 구성된 클라우드 네이티브 구조</td></tr><tr><td></td><td>이벤트 기반 설계</td><td>Event-driven Architecture</td><td>트리거 기반 구조로 유연한 분산 시스템 구성 가능</td></tr><tr><td></td><td>이벤트 스토밍 설계 기법</td><td>Domain Event Modeling</td><td>도메인 중심의 이벤트 흐름 기반 설계 방식, 마이크로서비스와의 결합에 적합</td></tr><tr><td></td><td>함수 체인 방지 패턴</td><td>Orchestrator 활용, 함수 분리 전략</td><td>과도한 함수 호출 연결 (Pinball) 방지로 성능 및 유지보수성 확보</td></tr><tr><td><strong>2. 운영/성능 최적화</strong></td><td>자동 확장</td><td>이벤트 기반 오토스케일링</td><td>요청 수에 따라 자동으로 함수 인스턴스가 확장/축소되어 자원 낭비를 방지함</td></tr><tr><td></td><td>콜드 스타트 최적화</td><td>패키지 크기, 런타임, warm-up 전략</td><td>초기화 지연 (Cold Start) 을 줄이기 위한 구조적/코드적 최적화 방법</td></tr><tr><td></td><td>엣지 서버리스</td><td>Edge Functions (Cloudflare Workers 등)</td><td>사용자 위치와 가까운 Edge 환경에서 실행하여 레이턴시 감소</td></tr><tr><td><strong>3. 관찰성 및 운영 도구</strong></td><td>분산 추적 및 모니터링</td><td>X-Ray, OpenTelemetry, Jaeger</td><td>다중 함수 호출 흐름을 시각화하고 문제 지점을 추적할 수 있는 관찰성 (Observability) 도구 적용</td></tr><tr><td></td><td>FinOps 운영 전략</td><td>비용 시각화, 예산 경고, 활용량 기반 분석</td><td>종량 과금 환경에서 비용을 효과적으로 추적 및 예측하여 예산 초과 방지</td></tr><tr><td><strong>4. 보안</strong></td><td>최소 권한 및 IAM 관리</td><td>RBAC, IAM 정책 분리</td><td>최소 권한 원칙에 따라 자원별 접근 권한을 분리하여 보안 사고 방지</td></tr><tr><td></td><td>입력 검증 및 Webhook 보안</td><td>시그니처 검증, 입력 스키마 검증</td><td>외부 트리거 진입점에서의 취약점 방지 및 공격면 최소화</td></tr><tr><td></td><td>제로 트러스트 모델</td><td>클라우드 함수 단위 인증/권한 확인</td><td>모든 요청에 대해 인증/검증을 수행하는 세밀한 서버리스 보안 모델 적용</td></tr><tr><td><strong>5. 멀티 클라우드/이식성</strong></td><td>벤더 락인 완화</td><td>추상화 레이어, 멀티 클라우드 프레임워크 사용</td><td>특정 클라우드에 종속되지 않도록 설계하여 이식성과 유연성 확보</td></tr><tr><td><strong>6. AI/신기술 융합</strong></td><td>서버리스 AI 통합</td><td>GenAI + Lambda 등 결합</td><td>LLM 이나 AI 모델을 서버리스 구조로 통합하여 지능형 애플리케이션 구성</td></tr></tbody></table><h3 id=반드시-학습해야할-내용>반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#반드시-학습해야할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>1. 클라우드 기초 이해</strong></td><td>클라우드 플랫폼 이해</td><td>AWS / Azure / GCP</td><td>각 클라우드의 서버리스 서비스 (FaaS, BaaS 등) 구조 및 비교</td></tr><tr><td><strong>2. 서버리스 핵심 개념</strong></td><td>서버리스 아키텍처의 구성 요소</td><td>FaaS, BaaS</td><td>함수 단위 실행 / 인증, DB, 메시징 등 관리형 백엔드 서비스 활용법</td></tr><tr><td></td><td>자동 확장 원리</td><td>오토스케일링</td><td>트래픽 변화에 따라 자동으로 리소스를 확장/축소하는 구조 및 원리</td></tr><tr><td></td><td>콜드 스타트 대응</td><td>Cold Start / Provisioned Concurrency</td><td>초기 실행 지연 최소화 전략: 사전 프로비저닝, 워밍업 트릭 등</td></tr><tr><td><strong>3. 프로그래밍 언어/런타임</strong></td><td>서버리스 친화 언어</td><td>Python / JavaScript</td><td>서버리스 실행에 널리 사용되는 언어 숙련도 확보</td></tr><tr><td><strong>4. 이벤트 트리거 구성</strong></td><td>트리거/이벤트 유형</td><td>HTTP / 메시지 큐 / 스토리지 이벤트</td><td>다양한 이벤트 소스를 통한 Lambda 등 함수 실행 트리거 설계</td></tr><tr><td><strong>5. 아키텍처 설계 및 패턴</strong></td><td>마이크로서비스와의 결합</td><td>분산 시스템, 마이크로서비스 통합</td><td>서버리스 기반으로 MSA 구성 시 고려사항 및 통신 전략</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>Event Sourcing / CQRS</td><td>상태 변경을 이벤트로 캡처 + 읽기/쓰기 모델 분리</td></tr><tr><td></td><td>서버리스 안티패턴</td><td>Lambda‑Pinball, Grain-of-Sand</td><td>과도한 분할 또는 연결 복잡성 증가로 인한 설계 실패 사례</td></tr><tr><td><strong>6. 배포 및 운영 자동화</strong></td><td>IaC 및 CD 도구 활용</td><td>Serverless Framework / AWS CDK / Terraform</td><td>선언형 인프라 및 지속적 배포 구현 방식</td></tr><tr><td></td><td>멀티 클라우드 대응</td><td>Serverless Framework / Knative</td><td>벤더 종속성 감소 및 포팅 전략 강화</td></tr><tr><td><strong>7. 모니터링 및 관찰성</strong></td><td>로깅/분산 추적</td><td>AWS X-Ray / OpenTelemetry</td><td>함수 호출 흐름, 오류 발생 지점, 병목 등을 시각화 및 추적</td></tr><tr><td><strong>8. 보안 및 정책 관리</strong></td><td>권한 관리</td><td>IAM / 최소 권한 원칙</td><td>자원 접근 제어를 위한 역할 기반 권한 및 보안 정책 설계</td></tr><tr><td></td><td>입력 보안 및 웹훅 보호</td><td>Webhook 서명 검증 / 입력 검증</td><td>외부 호출에 대한 유효성 검증 및 공격면 축소 전략</td></tr><tr><td></td><td>서버리스 특화 보안 위협</td><td>Denial-of-Wallet / 코드 취약점</td><td>과금 유발 공격, 패키지 종속성 등 서버리스 환경 고유 보안 리스크 대응</td></tr><tr><td><strong>9. 비용 및 최적화</strong></td><td>종량 과금 모델 이해</td><td>GB- 초, 요청 수 기반 청구</td><td>처리 시간과 메모리 크기 기반 과금 구조 이해 및 예산 계획</td></tr><tr><td></td><td>최적화 전략</td><td>함수 패키지 크기, 의존성 관리</td><td>콜드 스타트와 비용을 줄이기 위한 성능/크기 최적화</td></tr><tr><td><strong>10. 상태/세션 처리</strong></td><td>상태 저장 문제</td><td>Stateless 원칙, 외부 상태 관리</td><td>함수 상태는 외부 저장소로 위임하며, DB 또는 캐시를 통한 세션 유지</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>컴퓨팅 모델</strong></td><td><strong>FaaS (Function as a Service)</strong></td><td>이벤트 기반 함수 단위 실행 모델. 서버리스 아키텍처의 핵심 구성 요소</td></tr><tr><td></td><td><strong>BaaS (Backend as a Service)</strong></td><td>인증, DB, 스토리지, 메시징 등 백엔드 기능을 API 형태로 제공하는 서비스</td></tr><tr><td><strong>실행 동작 및 성능</strong></td><td><strong>Cold Start</strong></td><td>함수가 비활성 상태에서 처음 호출될 때 초기화로 인해 발생하는 지연</td></tr><tr><td></td><td><strong>Warm Start</strong></td><td>이미 초기화된 인스턴스에서 빠르게 함수가 실행되는 상태</td></tr><tr><td></td><td><strong>Provisioned Concurrency</strong></td><td>항상 일정 수의 함수 인스턴스를 미리 준비하여 콜드 스타트 지연을 제거</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td><strong>Stateless</strong></td><td>함수는 상태를 저장하지 않으며, 요청 간 상태는 외부 저장소에 보관</td></tr><tr><td></td><td><strong>Lambda-Pinball</strong></td><td>함수 간 과도한 호출로 인한 체인 복잡성과 지연이 발생하는 서버리스 아키텍처 안티패턴</td></tr><tr><td></td><td><strong>Event Sourcing</strong></td><td>상태 변경을 이벤트 시퀀스로 저장하여 시스템 상태를 재구성하는 이벤트 중심 아키텍처 패턴</td></tr><tr><td></td><td><strong>CQRS</strong></td><td>Command 와 Query 를 분리하여 성능, 확장성, 복잡도 관리를 향상시키는 아키텍처 패턴</td></tr><tr><td></td><td><strong>Saga Pattern</strong></td><td>분산 트랜잭션을 여러 로컬 트랜잭션으로 나누어 보상 작업을 포함해 처리하는 장기 트랜잭션 관리 패턴</td></tr><tr><td><strong>트리거 및 연동</strong></td><td><strong>Event Source</strong></td><td>함수 실행을 유발하는 외부 이벤트 소스 (예: HTTP 요청, 메시지 큐, 스토리지 변경 등)</td></tr><tr><td><strong>인프라 관리 도구</strong></td><td><strong>Infrastructure as Code (IaC)</strong></td><td>인프라 자원을 코드로 선언 및 자동화하여 운영 일관성과 버전 관리를 가능하게 하는 방식</td></tr><tr><td><strong>모니터링 및 운영</strong></td><td><strong>Distributed Tracing</strong></td><td>여러 마이크로서비스 간의 요청 흐름을 추적하여 병목 지점 및 성능 병해 분석에 활용</td></tr><tr><td></td><td><strong>Observability</strong></td><td>메트릭, 로그, 트레이스를 통해 시스템의 상태를 외부에서 명확하게 이해할 수 있는 능력</td></tr><tr><td><strong>안정성 패턴</strong></td><td><strong>Circuit Breaker</strong></td><td>연쇄 장애를 막기 위해 일정 실패 조건 시 요청 차단 후 복구를 시도하는 패턴</td></tr><tr><td><strong>보안 원칙</strong></td><td><strong>IAM (Identity and Access Management)</strong></td><td>클라우드 자원에 대한 인증, 권한 제어, 역할 기반 접근 제어를 담당하는 핵심 서비스</td></tr><tr><td></td><td><strong>Zero Trust</strong></td><td>네트워크 내부/외부를 불문하고 모든 요청에 대해 지속적으로 검증을 수행하는 보안 아키텍처 모델</td></tr><tr><td></td><td><strong>Least Privilege Principle</strong></td><td>사용자나 서비스에 최소한의 권한만 부여하여 보안을 강화하는 정책</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://docs.aws.amazon.com/lambda/>AWS Lambda 공식 문서</a></li><li><a href=https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview>Azure Functions 개요</a></li><li><a href=https://cloud.google.com/functions/docs>Google Cloud Functions 문서</a></li><li><a href=https://martinfowler.com/articles/serverless.html>Martin Fowler의 Serverless 아키텍처 분석</a></li><li><a href=https://www.stan.vision/journal/the-rise-of-serverless-architecture-in-2024-transforming-modern-web-development>서버리스 아키텍처 2024년 트렌드 분석</a></li><li><a href=https://docs.datadoghq.com/serverless/>Datadog 서버리스 모니터링 가이드</a></li><li><a href=https://www.geeksforgeeks.org/blogs/future-of-serverless-computing/>GeeksforGeeks: Serverless Computing의 미래 전망</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>