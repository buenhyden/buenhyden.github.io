<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>데이터베이스 인덱싱 (Database Indexing) | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,Database-Systems,Database-Optimization,인덱싱"><meta name=description content="인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/indexing/database-indexing/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/indexing/database-indexing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/indexing/database-indexing/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="데이터베이스 인덱싱 (Database Indexing)"><meta property="og:description" content="인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T02:11:00+00:00"><meta property="article:modified_time" content="2024-10-22T02:11:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="Database-Systems"><meta property="article:tag" content="Database-Optimization"><meta property="article:tag" content="인덱싱"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="데이터베이스 인덱싱 (Database Indexing)"><meta name=twitter:description content="인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"데이터베이스 인덱싱 (Database Indexing)","item":"https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/indexing/database-indexing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"데이터베이스 인덱싱 (Database Indexing)","name":"데이터베이스 인덱싱 (Database Indexing)","description":"인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조","keywords":["Backend-Development","Database-Systems","Database-Optimization","인덱싱"],"articleBody":"데이터베이스 인덱싱 (Database Indexing) 인덱스는 책의 목차와 유사한 역할을 한다.\n데이터베이스에서 인덱스를 사용하면 전체 테이블을 스캔하지 않고도 원하는 데이터를 빠르게 찾을 수 있다.\n인덱스는 테이블의 하나 또는 여러 개의 컬럼을 기반으로 생성될 수 있습니다.\n특징:\n자동 정렬\n인덱스는 항상 정렬된 상태를 유지한다. 새로운 데이터가 추가될 때마다 정렬된 순서를 유지하기 위해 재정렬이 발생한다. 독립적 저장\n인덱스는 실제 데이터와 별도의 공간에 저장된다. 원본 데이터의 위치를 가리키는 포인터를 포함한다. 선택적 생성\n모든 칼럼에 인덱스를 생성할 필요는 없다. 검색이 자주 발생하는 칼럼에 대해 선택적으로 생성한다. 장점:\n검색 속도 향상\n전체 테이블을 스캔하지 않고 인덱스를 통해 빠르게 데이터를 찾을 수 있습니다. WHERE 절의 조건이나 JOIN 연산의 효율성이 크게 향상됩니다. 정렬 비용 감소\nORDER BY 절을 사용할 때 이미 정렬된 인덱스를 활용할 수 있습니다. 추가적인 정렬 작업이 필요하지 않아 성능이 향상됩니다. 테이블 스캔 감소\n필요한 데이터만 선별적으로 접근할 수 있어 시스템 리소스 사용이 감소합니다. 단점:\n추가 저장 공간 필요\n인덱스는 별도의 저장 공간을 필요로 합니다. 데이터베이스 크기가 증가할수록 인덱스가 차지하는 공간도 증가합니다. 데이터 변경 작업의 성능 저하\nINSERT, UPDATE, DELETE 작업 시 인덱스도 함께 수정해야 합니다. 이로 인해 데이터 변경 작업의 속도가 저하될 수 있습니다. 인덱스 최적화 전략:\n선별적 인덱스 생성\n검색이 자주 발생하는 칼럼에 대해서만 인덱스를 생성합니다. 불필요한 인덱스는 제거하여 시스템 부하를 줄입니다. 복합 인덱스 활용\n함께 자주 검색되는 칼럼들에 대해 복합 인덱스를 생성합니다. 칼럼의 순서를 신중히 결정하여 효율성을 극대화합니다. 인덱스 재구성\n주기적으로 인덱스를 재구성하여 단편화를 제거합니다. 성능 저하를 예방하고 최적의 상태를 유지합니다. 사용 빈도가 높은 쿼리와 해당 컬럼을 파악하여 인덱스를 생성한다.\n인덱스의 크기와 유지 관리 비용을 고려하여 주기적으로 점검하고 불필요한 인덱스는 제거한다.\n쿼리 최적화와 함께 인덱스 최적화를 고려한다.\n정기적인 성능 모니터링과 리팩토링을 통해 인덱스 전략을 지속적으로 개선한다.\n주의사항:\n인덱스를 과도하게 사용하면 오히려 성능이 저하될 수 있다. 데이터의 변경이 빈번한 컬럼보다는 조회가 주로 이루어지는 컬럼에 인덱스를 생성하는 것이 좋다. Cardinality가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리하다. 인덱스의 종류 인덱스는 여러 기준에 따라 다양하게 분류될 수 있다.\n각 분류 기준에 따른 인덱스 종류를 살펴보자.\n구조에 따른 분류 데이터가 인덱스와 물리적으로 어떻게 연관되어 있는지를 기준으로 나뉜다.\n클러스터형 인덱스 (Clustered Index)\n클러스터형 인덱스는 테이블의 데이터가 인덱스의 순서에 따라 물리적으로 정렬되어 저장되는 방식.\n즉, 데이터 자체가 인덱스를 구성하며, 인덱스의 키 값 순서에 따라 데이터가 정렬된다.\n특징:\n1. 데이터 정렬: 테이블의 데이터가 자동으로 정렬되며, 인덱스 키 값이 데이터의 저장 순서를 결정한다.\n2. 테이블당 하나만 생성 가능: 클러스터형 인덱스는 데이터의 물리적 저장 방식을 변경하기 때문에 하나의 테이블에 하나만 생성할 수 있다.\n3. 빠른 검색: 범위 검색이나 정렬된 결과를 반환하는 쿼리에 매우 효율적이다.\n장점:\n빠른 범위 검색: 데이터를 물리적으로 정렬하므로 범위 기반 검색이 빠르다. 효율적인 정렬 작업: ORDER BY와 같은 정렬 작업에서 추가적인 비용이 거의 들지 않는다.\n단점: 데이터 수정 비용 증가: 데이터를 삽입, 삭제, 수정할 때마다 물리적 정렬을 유지해야 하므로 오버헤드가 발생한다. 추가 저장 공간 필요: 클러스터형 인덱스를 유지하기 위한 메타데이터가 필요하다. 1 2 3 4 5 6 7 8 9 10 11 -- employees 테이블 생성 CREATE TABLE employees ( id INT PRIMARY KEY, last_name VARCHAR(50), first_name VARCHAR(50), age INT, department VARCHAR(50) ); -- id 컬럼을 기준으로 클러스터형 인덱스 생성 CREATE CLUSTERED INDEX idx_id ON employees(id); 비클러스터형 인덱스 (Non-Clustered Index)\n비클러스터형 인덱스는 테이블의 데이터와 별도로 저장되며, 인덱스는 데이터의 위치를 가리키는 포인터를 포함한다.\n데이터 자체는 물리적으로 정렬되지 않고, 별도의 구조로 관리된다.\n특징:\n1. 독립적인 데이터 구조: 비클러스터형 인덱스는 테이블 데이터와 별도로 저장된다.\n2. 여러 개 생성 가능: 하나의 테이블에 여러 개의 비클러스터형 인덱스를 생성할 수 있다.\n3. 포인터 사용: 인덱스를 통해 데이터를 찾을 때 포인터를 사용하여 실제 데이터를 참조한다.\n장점:\n1. 유연성: 여러 열이나 열 조합에 대해 다양한 비클러스터형 인덱스를 생성할 수 있다.\n2. 데이터 변경 시 영향 적음: 클러스터형 인덱스처럼 물리적 정렬을 유지할 필요가 없어 삽입/삭제 시 부담이 적다.\n단점:\n1. 속도 저하 가능성: 데이터를 검색할 때 한 번 더 포인터를 통해 실제 데이터를 참조해야 하므로 클러스터형보다 느릴 수 있다.\n2. 추가 저장 공간 필요: 별도의 구조로 저장되기 때문에 추가적인 저장 공간이 요구됩니다.\n1 2 3 4 5 6 7 8 9 10 11 -- employees 테이블 생성 CREATE TABLE employees ( id INT PRIMARY KEY, last_name VARCHAR(50), first_name VARCHAR(50), age INT, department VARCHAR(50) ); -- last_name 컬럼에 대한 비클러스터형 인덱스 생성 CREATE NONCLUSTERED INDEX idx_last_name ON employees(last_name); 특징 클러스터형 인덱스 비클러스터형 인덱스 데이터 정렬 여부 물리적으로 정렬됨 별도로 저장되며 물리적 순서와 무관 테이블당 개수 제한 하나만 가능 여러 개 가능 검색 속도 범위 검색 및 정렬 작업에 매우 빠름 포인터를 통해 접근하므로 다소 느림 저장 공간 요구량 상대적으로 적음 추가적인 저장 공간 필요 데이터 변경 비용 높음 낮음 사용 목적과 테이블 특성에 따라 선택해야 한다.\n클러스터형은 범위 검색과 정렬 작업이 많은 경우 적합하며, 비클러스터형은 다양한 열 조합으로 검색해야 하는 경우 유용합니다. 키 속성에 따른 분류 인덱스가 테이블의 키와 어떤 관계를 가지는지를 기준으로 나눈다.\n기본 인덱스 (Primary Index)\n기본 인덱스는 테이블의 **기본 키(Primary Key)**에 대해 자동으로 생성되는 인덱스이다.\n기본 키는 테이블의 각 행을 고유하게 식별하며, 데이터 무결성을 보장한다.\n일반적으로 클러스터형 인덱스로 구현되며, 데이터가 물리적으로 정렬된다.\n특징:\n고유성 보장: 기본 키 값은 중복될 수 없으며, NULL 값을 허용하지 않는다. 데이터 정렬: 기본 키를 기준으로 데이터가 물리적으로 정렬된다. 테이블당 하나만 생성 가능: 한 테이블에 하나의 기본 인덱스만 존재할 수 있다.\n장점: 데이터 검색 속도 향상: 기본 키를 이용한 검색이 매우 빠르다. 데이터 무결성 보장: 고유성과 NULL 금지를 통해 데이터의 일관성을 유지한다.\n단점: 삽입/삭제/수정 시 오버헤드: 데이터 정렬을 유지해야 하므로 성능 저하가 발생할 수 있다. 테이블당 하나만 생성 가능: 추가적인 키를 기준으로 정렬하려면 보조 인덱스를 사용해야 한다. 1 2 3 4 5 6 -- employees 테이블 생성 시 기본키 설정 CREATE TABLE employees ( id INT PRIMARY KEY, last_name VARCHAR(50), first_name VARCHAR(50) ); 보조 인덱스 (Secondary Index)\n보조 인덱스는 기본 키 외의 열(Column)에 대해 생성되는 인덱스를 의미한다.\n기본적으로 비클러스터형 인덱스로 구현되며, 데이터와 별도로 저장된다.\n특징\n1. 다양한 열에 생성 가능: 기본 키가 아닌 열에도 생성할 수 있다.\n2. 포인터 사용: 보조 인덱스는 실제 데이터를 가리키는 포인터를 포함한다.\n3. 데이터 정렬 없음: 보조 인덱스를 생성한다고 해서 데이터가 물리적으로 정렬되지는 않는다.\n장점\n1. 다양한 검색 조건 지원: 기본 키 외의 열을 기준으로 효율적인 검색이 가능하다.\n2. 여러 개 생성 가능: 하나의 테이블에 여러 개의 보조 인덱스를 생성할 수 있다.\n단점:\n추가적인 저장 공간 필요: 보조 인덱스를 저장하기 위한 별도의 구조가 필요하다. 검색 속도 저하 가능성: 데이터를 검색할 때 포인터를 통해 실제 데이터를 참조해야 하므로 기본 인덱스보다 느릴 수 있다. 1 2 -- employees 테이블에서 last_name에 대한 보조 인덱스 생성 CREATE INDEX idx_last_name ON employees(last_name); 특징 기본 인덱스 (Primary Index) 보조 인덱스 (Secondary Index) 정렬 여부 데이터가 물리적으로 정렬됨 데이터와 별도로 저장, 정렬되지 않음 유일성 고유성을 강제 고유성 강제하지 않음 생성 가능 개수 테이블당 하나 여러 개 생성 가능 검색 속도 빠름 포인터 참조로 인해 다소 느림 저장 공간 요구량 상대적으로 적음 추가적인 저장 공간 필요 데이터 커버리지에 따른 분류 데이터 커버리지란 인덱스가 실제 데이터를 얼마나 세밀하게 가리키는지를 의미한다.\n밀집 인덱스 (Dense Index)\n밀집 인덱스는 데이터 파일의 모든 검색 키 값에 대해 인덱스 엔트리를 가지고 있는 인덱스.\n특징:\n1. 모든 레코드에 대해 인덱스 엔트리가 존재한다.\n2. 인덱스 크기가 상대적으로 큽니다.\n3. 데이터 검색 속도가 빠릅니다.\n장점:\n모든 레코드에 대한 직접적인 접근이 가능하다. COUNT() 같은 집계 함수를 사용할 때 데이터 파일에 접근하지 않고도 처리할 수 있어 효율적이다.\n단점: 인덱스 크기가 크므로 저장 공간을 많이 차지한다. 데이터 변경 시 인덱스 업데이트 비용이 높다. 1 2 3 4 5 학번: 모든 학생의 학번에 대해 인덱스 생성 1001 → 레코드 위치 1 1002 → 레코드 위치 2 1003 → 레코드 위치 3 1004 → 레코드 위치 4 희소 인덱스 (Sparse Index)\n희소 인덱스는 데이터 파일의 일부 레코드 또는 데이터 블록에 대해서만 인덱스 엔트리를 가지고 있는 인덱스이다.\n특징:\n1. 각 데이터 블록을 대표하는 키 값만 인덱스에 포함된다.\n2. 인덱스 크기가 상대적으로 작다.\n3. 데이터의 물리적 순서에 의존한다.\n장점:\n인덱스 크기가 작아 저장 공간을 적게 사용한다. 인덱스 갱신 비용이 낮다. 일반적으로 밀집 인덱스보다 인덱스 단계 수가 1정도 적어 디스크 접근 횟수가 줄어들 수 있다.\n단점: 특정 레코드를 찾기 위해 추가적인 탐색이 필요할 수 있다. 데이터 파일의 물리적 순서에 의존하므로 유연성이 떨어진다. 1 2 3 4 5 학년별로 그룹화된 데이터의 시작점만 인덱스 생성 1학년 시작 → 레코드 위치 1 2학년 시작 → 레코드 위치 251 3학년 시작 → 레코드 위치 501 4학년 시작 → 레코드 위치 751 인덱스 선택 기준\n데이터 특성 고려 고유한 값이 많고 정확한 검색이 필요한 경우 → 밀집 인덱스 데이터가 정렬되어 있고 범위 검색이 많은 경우 → 희소 인덱스 시스템 리소스 고려 저장 공간이 충분하고 검색 성능이 중요한 경우 → 밀집 인덱스 저장 공간이 제한적이고 데이터가 잘 정렬된 경우 → 희소 인덱스 데이터 변경 빈도 고려 데이터 변경이 적고 빠른 검색이 필요한 경우 → 밀집 인덱스 데이터 변경이 빈번한 경우 → 희소 인덱스 키 구성에 따른 분류 인덱스를 구성하는 컬럼의 수에 따라 나뉜다.\n단일 키 인덱스 (Single-Key Index)\n단일 키 인덱스는 하나의 컬럼만을 사용하여 생성된 인덱스.\n특징:\n1. 구조가 간단하고 구현이 쉽다.\n2. 특정 컬럼에 대한 검색 속도를 향상시킨다.\n3. 데이터베이스 시스템의 부하를 줄일 수 있다.\n장점: 구현이 간단하고 유지보수가 쉽다. 특정 컬럼에 대한 검색이 빈번할 때 효과적.\n단점: 여러 컬럼을 조합한 복잡한 쿼리에는 효율성이 떨어질 수 있다. 다중 조건 검색에는 적합하지 않을 수 있다. 복합 키 인덱스 (Composite Index)\n복합 키 인덱스는 두 개 이상의 컬럼을 조합하여 생성된 인덱스.\n특징:\n1. 여러 컬럼을 조합하여 하나의 인덱스로 만든다.\n2. 컬럼의 순서가 중요하다.\n3. 최대 32개까지의 컬럼을 조합할 수 있다.\n장점: 여러 컬럼을 동시에 검색할 때 검색 속도가 개선된다. 데이터 정렬의 효율성이 높아진다. 인덱스의 용량을 절감할 수 있다. 복잡한 쿼리의 최적화에 도움이 된다.\n단점 인덱스 생성 시 컬럼 순서가 중요하므로 설계에 주의가 필요하다. 첫 번째 컬럼이 조건에 포함되지 않으면 인덱스가 효과적으로 작동하지 않을 수 있다. 너무 많은 컬럼을 포함하면 오히려 성능이 저하될 수 있다.\n사용 시 주의사항: WHERE 절에 자주 사용되는 컬럼들로 구성해야 한다. 컬럼의 순서는 검색 조건에서 자주 사용되는 순서대로 지정해야 한다. 인덱스에 포함된 컬럼 수가 많아질수록 성능이 저하될 수 있으므로 적절한 수의 컬럼을 선택해야 한다. 고유성에 따른 분류 고유 인덱스 (Unique Index)\n인덱스 키 값이 테이블 내에서 유일함을 보장합니다. 중복된 값을 허용하지 않습니다. 비고유 인덱스 (Non-Unique Index)\n인덱스 키 값의 중복을 허용합니다. 특수 목적 인덱스 비트맵 인덱스 (Bitmap Index)\n적은 수의 고유 값을 가진 컬럼에 효과적입니다. 비트 벡터를 사용하여 데이터의 존재 여부를 표현합니다. 함수 기반 인덱스 (Function-Based Index)\n컬럼의 값 자체가 아닌, 컬럼에 특정 함수를 적용한 결과를 인덱싱합니다. 함수나 수식이 포함된 조건 검색에 유용하다. 공간 인덱스 (Spatial Index)\n지리적 데이터나 다차원 데이터를 효율적으로 검색하기 위해 사용됩니다. 전문 인덱스 (Full-Text Index)\n텍스트 데이터의 전체 내용을 검색하는 데 사용됩니다. 문서나 게시글 내용 검색에 사용된다. 데이터 구조에 따른 분류 B-트리 인덱스 (B-Tree Index) 가장 일반적으로 사용되는 인덱스 구조입니다. 균형 잡힌 트리 구조로, 검색, 삽입, 삭제 연산이 효율적입니다. 해시 인덱스 (Hash Index) 해시 함수를 사용하여 키를 특정 버킷에 매핑합니다. 등호 비교에는 매우 효율적이지만, 범위 검색에는 적합하지 않습니다. R-트리 인덱스 (R-Tree Index) 공간 데이터를 위한 특수한 구조입니다. 지리 정보 시스템에서 주로 사용됩니다. 참고 및 출처 ","wordCount":"1714","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-22T02:11:00Z","dateModified":"2024-10-22T02:11:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/indexing/database-indexing/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">데이터베이스 인덱싱 (Database Indexing)</h1><div class=post-description>인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조</div><div class=post-meta><span title='2024-10-22 02:11:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Systems%20and%20Infrastructure/Database%20Systems/Indexing/Database-Indexing.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#데이터베이스-인덱싱-database-indexing>데이터베이스 인덱싱 (Database Indexing)</a><ul><li><a href=#인덱스의-종류>인덱스의 종류</a></li><li><a href=#고유성에-따른-분류>고유성에 따른 분류</a></li><li><a href=#특수-목적-인덱스>특수 목적 인덱스</a></li><li><a href=#데이터-구조에-따른-분류>데이터 구조에 따른 분류</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=데이터베이스-인덱싱-database-indexing>데이터베이스 인덱싱 (Database Indexing)<a hidden class=anchor aria-hidden=true href=#데이터베이스-인덱싱-database-indexing>#</a></h2><p>인덱스는 책의 목차와 유사한 역할을 한다.<br>데이터베이스에서 인덱스를 사용하면 전체 테이블을 스캔하지 않고도 원하는 데이터를 빠르게 찾을 수 있다.<br>인덱스는 테이블의 하나 또는 여러 개의 컬럼을 기반으로 생성될 수 있습니다.</p><p>특징:</p><ol><li><p>자동 정렬</p><ul><li>인덱스는 항상 정렬된 상태를 유지한다.</li><li>새로운 데이터가 추가될 때마다 정렬된 순서를 유지하기 위해 재정렬이 발생한다.</li></ul></li><li><p>독립적 저장</p><ul><li>인덱스는 실제 데이터와 별도의 공간에 저장된다.</li><li>원본 데이터의 위치를 가리키는 포인터를 포함한다.</li></ul></li><li><p>선택적 생성</p><ul><li>모든 칼럼에 인덱스를 생성할 필요는 없다.</li><li>검색이 자주 발생하는 칼럼에 대해 선택적으로 생성한다.</li></ul></li></ol><p>장점:</p><ol><li><p>검색 속도 향상</p><ul><li>전체 테이블을 스캔하지 않고 인덱스를 통해 빠르게 데이터를 찾을 수 있습니다.</li><li>WHERE 절의 조건이나 JOIN 연산의 효율성이 크게 향상됩니다.</li></ul></li><li><p>정렬 비용 감소</p><ul><li>ORDER BY 절을 사용할 때 이미 정렬된 인덱스를 활용할 수 있습니다.</li><li>추가적인 정렬 작업이 필요하지 않아 성능이 향상됩니다.</li></ul></li><li><p>테이블 스캔 감소</p><ul><li>필요한 데이터만 선별적으로 접근할 수 있어 시스템 리소스 사용이 감소합니다.</li></ul></li></ol><p>단점:</p><ol><li><p>추가 저장 공간 필요</p><ul><li>인덱스는 별도의 저장 공간을 필요로 합니다.</li><li>데이터베이스 크기가 증가할수록 인덱스가 차지하는 공간도 증가합니다.</li></ul></li><li><p>데이터 변경 작업의 성능 저하</p><ul><li>INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 수정해야 합니다.</li><li>이로 인해 데이터 변경 작업의 속도가 저하될 수 있습니다.</li></ul></li></ol><p>인덱스 최적화 전략:</p><ol><li><p>선별적 인덱스 생성</p><ul><li>검색이 자주 발생하는 칼럼에 대해서만 인덱스를 생성합니다.</li><li>불필요한 인덱스는 제거하여 시스템 부하를 줄입니다.</li></ul></li><li><p>복합 인덱스 활용</p><ul><li>함께 자주 검색되는 칼럼들에 대해 복합 인덱스를 생성합니다.</li><li>칼럼의 순서를 신중히 결정하여 효율성을 극대화합니다.</li></ul></li><li><p>인덱스 재구성</p><ul><li>주기적으로 인덱스를 재구성하여 단편화를 제거합니다.</li><li>성능 저하를 예방하고 최적의 상태를 유지합니다.</li></ul></li><li><p>사용 빈도가 높은 쿼리와 해당 컬럼을 파악하여 인덱스를 생성한다.</p></li><li><p>인덱스의 크기와 유지 관리 비용을 고려하여 주기적으로 점검하고 불필요한 인덱스는 제거한다.</p></li><li><p>쿼리 최적화와 함께 인덱스 최적화를 고려한다.</p></li><li><p>정기적인 성능 모니터링과 리팩토링을 통해 인덱스 전략을 지속적으로 개선한다.</p></li></ol><p>주의사항:</p><ol><li>인덱스를 과도하게 사용하면 오히려 성능이 저하될 수 있다.</li><li>데이터의 변경이 빈번한 컬럼보다는 조회가 주로 이루어지는 컬럼에 인덱스를 생성하는 것이 좋다.</li><li>Cardinality가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리하다.</li></ol><h3 id=인덱스의-종류>인덱스의 종류<a hidden class=anchor aria-hidden=true href=#인덱스의-종류>#</a></h3><p>인덱스는 여러 기준에 따라 다양하게 분류될 수 있다.<br>각 분류 기준에 따른 인덱스 종류를 살펴보자.</p><h4 id=구조에-따른-분류>구조에 따른 분류<a hidden class=anchor aria-hidden=true href=#구조에-따른-분류>#</a></h4><p>데이터가 인덱스와 물리적으로 어떻게 연관되어 있는지를 기준으로 나뉜다.</p><ol><li><p><strong>클러스터형 인덱스 (Clustered Index)</strong><br>클러스터형 인덱스는 테이블의 데이터가 <strong>인덱스의 순서에 따라 물리적으로 정렬</strong>되어 저장되는 방식.<br>즉, 데이터 자체가 인덱스를 구성하며, 인덱스의 키 값 순서에 따라 데이터가 정렬된다.<br>특징:<br>1. <strong>데이터 정렬</strong>: 테이블의 데이터가 자동으로 정렬되며, 인덱스 키 값이 데이터의 저장 순서를 결정한다.<br>2. <strong>테이블당 하나만 생성 가능</strong>: 클러스터형 인덱스는 데이터의 물리적 저장 방식을 변경하기 때문에 하나의 테이블에 하나만 생성할 수 있다.<br>3. <strong>빠른 검색</strong>: 범위 검색이나 정렬된 결과를 반환하는 쿼리에 매우 효율적이다.<br>장점:</p><ol><li><strong>빠른 범위 검색</strong>: 데이터를 물리적으로 정렬하므로 범위 기반 검색이 빠르다.</li><li><strong>효율적인 정렬 작업</strong>: ORDER BY와 같은 정렬 작업에서 추가적인 비용이 거의 들지 않는다.<br>단점:</li><li><strong>데이터 수정 비용 증가</strong>: 데이터를 삽입, 삭제, 수정할 때마다 물리적 정렬을 유지해야 하므로 오버헤드가 발생한다.</li><li><strong>추가 저장 공간 필요</strong>: 클러스터형 인덱스를 유지하기 위한 메타데이터가 필요하다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- employees 테이블 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>last_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>first_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>age</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>department</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- id 컬럼을 기준으로 클러스터형 인덱스 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=n>CLUSTERED</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_id</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>employees</span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>비클러스터형 인덱스 (Non-Clustered Index)</strong><br>비클러스터형 인덱스는 테이블의 데이터와 별도로 저장되며, <strong>인덱스는 데이터의 위치를 가리키는 포인터를 포함</strong>한다.<br>데이터 자체는 물리적으로 정렬되지 않고, 별도의 구조로 관리된다.<br>특징:<br>1. <strong>독립적인 데이터 구조</strong>: 비클러스터형 인덱스는 테이블 데이터와 별도로 저장된다.<br>2. <strong>여러 개 생성 가능</strong>: 하나의 테이블에 여러 개의 비클러스터형 인덱스를 생성할 수 있다.<br>3. <strong>포인터 사용</strong>: 인덱스를 통해 데이터를 찾을 때 포인터를 사용하여 실제 데이터를 참조한다.<br>장점:<br>1. <strong>유연성</strong>: 여러 열이나 열 조합에 대해 다양한 비클러스터형 인덱스를 생성할 수 있다.<br>2. <strong>데이터 변경 시 영향 적음</strong>: 클러스터형 인덱스처럼 물리적 정렬을 유지할 필요가 없어 삽입/삭제 시 부담이 적다.<br>단점:<br>1. <strong>속도 저하 가능성</strong>: 데이터를 검색할 때 한 번 더 포인터를 통해 실제 데이터를 참조해야 하므로 클러스터형보다 느릴 수 있다.<br>2. <strong>추가 저장 공간 필요</strong>: 별도의 구조로 저장되기 때문에 추가적인 저장 공간이 요구됩니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- employees 테이블 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>last_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>first_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>age</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>department</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- last_name 컬럼에 대한 비클러스터형 인덱스 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=n>NONCLUSTERED</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_last_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>employees</span><span class=p>(</span><span class=n>last_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><table><thead><tr><th>특징</th><th>클러스터형 인덱스</th><th>비클러스터형 인덱스</th></tr></thead><tbody><tr><td><strong>데이터 정렬 여부</strong></td><td>물리적으로 정렬됨</td><td>별도로 저장되며 물리적 순서와 무관</td></tr><tr><td><strong>테이블당 개수 제한</strong></td><td>하나만 가능</td><td>여러 개 가능</td></tr><tr><td><strong>검색 속도</strong></td><td>범위 검색 및 정렬 작업에 매우 빠름</td><td>포인터를 통해 접근하므로 다소 느림</td></tr><tr><td><strong>저장 공간 요구량</strong></td><td>상대적으로 적음</td><td>추가적인 저장 공간 필요</td></tr><tr><td><strong>데이터 변경 비용</strong></td><td>높음</td><td>낮음</td></tr></tbody></table><p>사용 목적과 테이블 특성에 따라 선택해야 한다.</p><ul><li>클러스터형은 범위 검색과 정렬 작업이 많은 경우 적합하며,</li><li>비클러스터형은 다양한 열 조합으로 검색해야 하는 경우 유용합니다.</li></ul><h4 id=키-속성에-따른-분류>키 속성에 따른 분류<a hidden class=anchor aria-hidden=true href=#키-속성에-따른-분류>#</a></h4><p><strong>인덱스가 테이블의 키와 어떤 관계를 가지는지</strong>를 기준으로 나눈다.</p><ol><li><p><strong>기본 인덱스 (Primary Index)</strong><br>기본 인덱스는 테이블의 **기본 키(Primary Key)**에 대해 자동으로 생성되는 인덱스이다.<br>기본 키는 테이블의 각 행을 고유하게 식별하며, 데이터 무결성을 보장한다.<br>일반적으로 클러스터형 인덱스로 구현되며, 데이터가 물리적으로 정렬된다.<br>특징:</p><ol><li><strong>고유성 보장</strong>: 기본 키 값은 중복될 수 없으며, NULL 값을 허용하지 않는다.</li><li><strong>데이터 정렬</strong>: 기본 키를 기준으로 데이터가 물리적으로 정렬된다.</li><li><strong>테이블당 하나만 생성 가능</strong>: 한 테이블에 하나의 기본 인덱스만 존재할 수 있다.<br>장점:<ol><li>데이터 검색 속도 향상: 기본 키를 이용한 검색이 매우 빠르다.</li><li>데이터 무결성 보장: 고유성과 NULL 금지를 통해 데이터의 일관성을 유지한다.<br>단점:</li><li>삽입/삭제/수정 시 오버헤드: 데이터 정렬을 유지해야 하므로 성능 저하가 발생할 수 있다.</li><li>테이블당 하나만 생성 가능: 추가적인 키를 기준으로 정렬하려면 보조 인덱스를 사용해야 한다.</li></ol></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- employees 테이블 생성 시 기본키 설정
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>last_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>first_name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>보조 인덱스 (Secondary Index)</strong><br>보조 인덱스는 기본 키 외의 열(Column)에 대해 생성되는 인덱스를 의미한다.<br>기본적으로 비클러스터형 인덱스로 구현되며, 데이터와 별도로 저장된다.<br>특징<br>1. <strong>다양한 열에 생성 가능</strong>: 기본 키가 아닌 열에도 생성할 수 있다.<br>2. <strong>포인터 사용</strong>: 보조 인덱스는 실제 데이터를 가리키는 포인터를 포함한다.<br>3. <strong>데이터 정렬 없음</strong>: 보조 인덱스를 생성한다고 해서 데이터가 물리적으로 정렬되지는 않는다.<br>장점<br>1. 다양한 검색 조건 지원: 기본 키 외의 열을 기준으로 효율적인 검색이 가능하다.<br>2. 여러 개 생성 가능: 하나의 테이블에 여러 개의 보조 인덱스를 생성할 수 있다.<br>단점:</p><ol><li>추가적인 저장 공간 필요: 보조 인덱스를 저장하기 위한 별도의 구조가 필요하다.</li><li>검색 속도 저하 가능성: 데이터를 검색할 때 포인터를 통해 실제 데이터를 참조해야 하므로 기본 인덱스보다 느릴 수 있다.</li></ol></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- employees 테이블에서 last_name에 대한 보조 인덱스 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_last_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>employees</span><span class=p>(</span><span class=n>last_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>특징</th><th>기본 인덱스 (Primary Index)</th><th>보조 인덱스 (Secondary Index)</th></tr></thead><tbody><tr><td><strong>정렬 여부</strong></td><td>데이터가 물리적으로 정렬됨</td><td>데이터와 별도로 저장, 정렬되지 않음</td></tr><tr><td><strong>유일성</strong></td><td>고유성을 강제</td><td>고유성 강제하지 않음</td></tr><tr><td><strong>생성 가능 개수</strong></td><td>테이블당 하나</td><td>여러 개 생성 가능</td></tr><tr><td><strong>검색 속도</strong></td><td>빠름</td><td>포인터 참조로 인해 다소 느림</td></tr><tr><td><strong>저장 공간 요구량</strong></td><td>상대적으로 적음</td><td>추가적인 저장 공간 필요</td></tr></tbody></table><h4 id=데이터-커버리지에-따른-분류>데이터 커버리지에 따른 분류<a hidden class=anchor aria-hidden=true href=#데이터-커버리지에-따른-분류>#</a></h4><p>데이터 커버리지란 인덱스가 실제 데이터를 얼마나 세밀하게 가리키는지를 의미한다.</p><ol><li><p><strong>밀집 인덱스 (Dense Index)</strong><br>밀집 인덱스는 데이터 파일의 모든 검색 키 값에 대해 인덱스 엔트리를 가지고 있는 인덱스.<br>특징:<br>1. 모든 레코드에 대해 인덱스 엔트리가 존재한다.<br>2. 인덱스 크기가 상대적으로 큽니다.<br>3. 데이터 검색 속도가 빠릅니다.<br>장점:</p><ol><li>모든 레코드에 대한 직접적인 접근이 가능하다.</li><li>COUNT() 같은 집계 함수를 사용할 때 데이터 파일에 접근하지 않고도 처리할 수 있어 효율적이다.<br>단점:</li><li>인덱스 크기가 크므로 저장 공간을 많이 차지한다.</li><li>데이터 변경 시 인덱스 업데이트 비용이 높다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>학번: 모든 학생의 학번에 대해 인덱스 생성
</span></span><span class=line><span class=cl>1001 → 레코드 위치 1
</span></span><span class=line><span class=cl>1002 → 레코드 위치 2
</span></span><span class=line><span class=cl>1003 → 레코드 위치 3
</span></span><span class=line><span class=cl>1004 → 레코드 위치 4
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>희소 인덱스 (Sparse Index)</strong><br>희소 인덱스는 데이터 파일의 일부 레코드 또는 데이터 블록에 대해서만 인덱스 엔트리를 가지고 있는 인덱스이다.<br>특징:<br>1. 각 데이터 블록을 대표하는 키 값만 인덱스에 포함된다.<br>2. 인덱스 크기가 상대적으로 작다.<br>3. 데이터의 물리적 순서에 의존한다.<br>장점:</p><ol><li>인덱스 크기가 작아 저장 공간을 적게 사용한다.</li><li>인덱스 갱신 비용이 낮다.</li><li>일반적으로 밀집 인덱스보다 인덱스 단계 수가 1정도 적어 디스크 접근 횟수가 줄어들 수 있다.<br>단점:</li><li>특정 레코드를 찾기 위해 추가적인 탐색이 필요할 수 있다.</li><li>데이터 파일의 물리적 순서에 의존하므로 유연성이 떨어진다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>학년별로 그룹화된 데이터의 시작점만 인덱스 생성
</span></span><span class=line><span class=cl>1학년 시작 → 레코드 위치 1
</span></span><span class=line><span class=cl>2학년 시작 → 레코드 위치 251
</span></span><span class=line><span class=cl>3학년 시작 → 레코드 위치 501
</span></span><span class=line><span class=cl>4학년 시작 → 레코드 위치 751
</span></span></code></pre></td></tr></table></div></div></li></ol><p>인덱스 선택 기준</p><ol><li>데이터 특성 고려<ul><li>고유한 값이 많고 정확한 검색이 필요한 경우 → 밀집 인덱스</li><li>데이터가 정렬되어 있고 범위 검색이 많은 경우 → 희소 인덱스</li></ul></li><li>시스템 리소스 고려<ul><li>저장 공간이 충분하고 검색 성능이 중요한 경우 → 밀집 인덱스</li><li>저장 공간이 제한적이고 데이터가 잘 정렬된 경우 → 희소 인덱스</li></ul></li><li>데이터 변경 빈도 고려<ul><li>데이터 변경이 적고 빠른 검색이 필요한 경우 → 밀집 인덱스</li><li>데이터 변경이 빈번한 경우 → 희소 인덱스</li></ul></li></ol><h4 id=키-구성에-따른-분류>키 구성에 따른 분류<a hidden class=anchor aria-hidden=true href=#키-구성에-따른-분류>#</a></h4><p>인덱스를 구성하는 컬럼의 수에 따라 나뉜다.</p><ol><li><strong>단일 키 인덱스 (Single-Key Index)</strong><br>단일 키 인덱스는 하나의 컬럼만을 사용하여 생성된 인덱스.<br>특징:<br>1. 구조가 간단하고 구현이 쉽다.<br>2. 특정 컬럼에 대한 검색 속도를 향상시킨다.<br>3. 데이터베이스 시스템의 부하를 줄일 수 있다.<br>장점:<ol><li>구현이 간단하고 유지보수가 쉽다.</li><li>특정 컬럼에 대한 검색이 빈번할 때 효과적.<br>단점:</li><li>여러 컬럼을 조합한 복잡한 쿼리에는 효율성이 떨어질 수 있다.</li><li>다중 조건 검색에는 적합하지 않을 수 있다.</li></ol></li><li><strong>복합 키 인덱스 (Composite Index)</strong><br>복합 키 인덱스는 두 개 이상의 컬럼을 조합하여 생성된 인덱스.<br>특징:<br>1. 여러 컬럼을 조합하여 하나의 인덱스로 만든다.<br>2. 컬럼의 순서가 중요하다.<br>3. 최대 32개까지의 컬럼을 조합할 수 있다.<br>장점:<ol><li>여러 컬럼을 동시에 검색할 때 검색 속도가 개선된다.</li><li>데이터 정렬의 효율성이 높아진다.</li><li>인덱스의 용량을 절감할 수 있다.</li><li>복잡한 쿼리의 최적화에 도움이 된다.<br>단점</li><li>인덱스 생성 시 컬럼 순서가 중요하므로 설계에 주의가 필요하다.</li><li>첫 번째 컬럼이 조건에 포함되지 않으면 인덱스가 효과적으로 작동하지 않을 수 있다.</li><li>너무 많은 컬럼을 포함하면 오히려 성능이 저하될 수 있다.<br>사용 시 주의사항:</li><li>WHERE 절에 자주 사용되는 컬럼들로 구성해야 한다.</li><li>컬럼의 순서는 검색 조건에서 자주 사용되는 순서대로 지정해야 한다.</li><li>인덱스에 포함된 컬럼 수가 많아질수록 성능이 저하될 수 있으므로 적절한 수의 컬럼을 선택해야 한다.</li></ol></li></ol><h3 id=고유성에-따른-분류>고유성에 따른 분류<a hidden class=anchor aria-hidden=true href=#고유성에-따른-분류>#</a></h3><ol start=4><li><p><strong>고유 인덱스 (Unique Index)</strong></p><ul><li>인덱스 키 값이 테이블 내에서 유일함을 보장합니다.</li><li>중복된 값을 허용하지 않습니다.</li></ul></li><li><p><strong>비고유 인덱스 (Non-Unique Index)</strong></p><ul><li>인덱스 키 값의 중복을 허용합니다.</li></ul></li></ol><h3 id=특수-목적-인덱스>특수 목적 인덱스<a hidden class=anchor aria-hidden=true href=#특수-목적-인덱스>#</a></h3><ol start=6><li><p><strong>비트맵 인덱스 (Bitmap Index)</strong></p><ul><li>적은 수의 고유 값을 가진 컬럼에 효과적입니다.</li><li>비트 벡터를 사용하여 데이터의 존재 여부를 표현합니다.</li></ul></li><li><p><strong>함수 기반 인덱스 (Function-Based Index)</strong></p><ul><li>컬럼의 값 자체가 아닌, 컬럼에 특정 함수를 적용한 결과를 인덱싱합니다.</li><li>함수나 수식이 포함된 조건 검색에 유용하다.</li></ul></li><li><p><strong>공간 인덱스 (Spatial Index)</strong></p><ul><li>지리적 데이터나 다차원 데이터를 효율적으로 검색하기 위해 사용됩니다.</li></ul></li><li><p><strong>전문 인덱스 (Full-Text Index)</strong></p><ul><li>텍스트 데이터의 전체 내용을 검색하는 데 사용됩니다.</li><li>문서나 게시글 내용 검색에 사용된다.</li></ul></li></ol><h3 id=데이터-구조에-따른-분류>데이터 구조에 따른 분류<a hidden class=anchor aria-hidden=true href=#데이터-구조에-따른-분류>#</a></h3><ol start=10><li><strong>B-트리 인덱스 (B-Tree Index)</strong></li></ol><ul><li>가장 일반적으로 사용되는 인덱스 구조입니다.</li><li>균형 잡힌 트리 구조로, 검색, 삽입, 삭제 연산이 효율적입니다.</li></ul><ol start=11><li><strong>해시 인덱스 (Hash Index)</strong></li></ol><ul><li>해시 함수를 사용하여 키를 특정 버킷에 매핑합니다.</li><li>등호 비교에는 매우 효율적이지만, 범위 검색에는 적합하지 않습니다.</li></ul><ol start=12><li>R-트리 인덱스 (R-Tree Index)</li></ol><ul><li>공간 데이터를 위한 특수한 구조입니다.</li><li>지리 정보 시스템에서 주로 사용됩니다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/database-systems/>Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/database-optimization/>Database-Optimization</a></li><li><a href=https://buenhyden.github.io/tags/%EC%9D%B8%EB%8D%B1%EC%8B%B1/>인덱싱</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/performance/query-optimization/query-optimization/><span class=title>« Prev</span><br><span>쿼리 최적화 (Query Optimization)</span>
</a><a class=next href=https://buenhyden.github.io/posts/systems-and-infrastructure/networking-and-communication/fundamentals/cloud-networking/><span class=title>Next »</span><br><span>Cloud Networking</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>