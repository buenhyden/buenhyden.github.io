<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>임계 영역 (Critical Section) | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Concurrency-and-Parallelism,Synchronization,Critical-Section"><meta name=description content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="임계 영역 (Critical Section)"><meta property="og:description" content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-04T07:49:00+00:00"><meta property="article:modified_time" content="2024-10-04T07:49:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="Concurrency-and-Parallelism"><meta property="article:tag" content="Synchronization"><meta property="article:tag" content="Critical-Section"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="임계 영역 (Critical Section)"><meta name=twitter:description content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"임계 영역 (Critical Section)","item":"https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"임계 영역 (Critical Section)","name":"임계 영역 (Critical Section)","description":"여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역","keywords":["Computer-Science-Fundamentals","Operating-systems","Process-Management","Concurrency-and-Parallelism","Synchronization","Critical-Section"],"articleBody":"임계 영역 (Critical Section) 운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.\n이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.\n여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.\n1 2 3 4 5 6 7 8 9 10 # 임계 영역 예시 balance = 1000 # 공유 자원 def withdraw(amount): global balance # 임계 영역 시작 temp = balance temp = temp - amount balance = temp # 임계 영역 종료 임계 영역 문제의 해결 조건 상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다. 진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다. 한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다. 임계 영역 관련 문제와 해결 방법 구분 데드락(Deadlock) 경쟁 상태(Race Condition) 기아 상태(Starvation) 라이브락(Livelock) 정의 두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태 여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태 특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태 프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태 발생 원인 상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족 공유 자원에 대한 동시 접근, 원자성 결여 부적절한 자원 할당 정책, 우선순위 역전 현상 프로세스들의 과도한 양보, 재귀적 회피 동작 결과 시스템 전체 또는 일부 프로세스의 완전한 정지 데이터 불일치, 예측 불가능한 결과 특정 프로세스의 실행 지연 또는 무한 대기 CPU 자원 소비, 실제 작업 진행 없음 특징 프로세스들이 움직이지 않고 완전히 멈춤 타이밍에 따라 결과가 비결정적 자원 할당의 불공정성 프로세스들이 활발히 상태 변경 해결 방법 프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거 동기화 메커니즘 사용(뮤텍스, 세마포어 등) 에이징(Aging) 기법 도입, 공정한 스케줄링 무작위 대기 시간 도입, 우선순위 조정 예방 기법 자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정 임계 영역 설정, 원자적 연산 사용 자원 예약 시스템, 우선순위 조정 메커니즘 타임아웃 설정, 재시도 횟수 제한 탐지 방법 자원 할당 그래프 분석, 대기 사이클 검출 데이터 일관성 검사, 로그 분석 자원 할당 통계 모니터링 CPU 사용률 분석, 진행률 모니터링 영향 범위 전체 시스템 또는 관련 프로세스 그룹 공유 자원을 사용하는 프로세스들 특정 프로세스 또는 프로세스 그룹 상호 작용하는 프로세스 그룹 복구 방법 프로세스 재시작, 시스템 재부팅 트랜잭션 롤백, 상태 복원 우선순위 재조정, 자원 재할당 프로세스 재시작 또는 동작 패턴 변경 모니터링 방법 시스템 자원 모니터링, 프로세스 상태 감시 로그 분석, 데이터 정합성 검사 자원 할당 히스토리 분석 CPU 사용률 추적, 진행 상태 모니터링 해결 방법 상호 배제(Mutual Exclusion) 구현:\n뮤텍스(Mutex): 하나의 공유 자원에 대한 접근을 제어한다. 세마포어(Semaphore): 여러 개의 공유 자원에 대한 접근을 제어한다. 동기화 기법:\n피터슨 알고리즘(Peterson’s Algorithm): 두 프로세스 간의 상호 배제를 소프트웨어적으로 구현한다. 베이커리 알고리즘(Bakery Algorithm): 여러 프로세스 간의 상호 배제를 구현한다. 하드웨어 지원:\n테스트와 설정(Test-and-Set) 명령어: 원자적 연산을 통해 상호 배제를 구현한다. 비교와 교환(Compare-and-Swap) 명령어: 더 정교한 동기화 제어를 가능하게 한다. 운영체제 수준의 지원:\n모니터(Monitor): 고수준의 동기화 메커니즘으로, 상호 배제를 자동으로 보장한다. 조건 변수(Condition Variables): 프로세스 간 통신과 동기화를 위해 사용된다. 프로그래밍 언어 수준의 지원:\n동기화 키워드(예: Java의 synchronized): 임계 영역에 대한 접근을 언어 차원에서 제어한다. 락-프리(Lock-Free) 및 대기-프리(Wait-Free) 알고리즘:\n락을 사용하지 않고도 동시성을 관리하는 고급 기법. 해결 방법들을 적용할 때 고려해야 할 중요한 원칙 상호 배제(Mutual Exclusion) 한 번에 하나의 프로세스만 임계 영역에 진입할 수 있도록 보장 적절한 동기화 메커니즘 사용 진행(Progress) 임계 영역에 있는 프로세스가 없다면 진입을 원하는 프로세스가 진입할 수 있어야 함 기아 상태 방지 한정 대기(Bounded Waiting) 프로세스의 임계 영역 진입 요청 후 무한정 대기하지 않도록 보장 공정성 확보 원자성(Atomicity) 임계 영역의 연산은 중단되지 않고 완전히 수행되어야 함 트랜잭션 관리 임계 영역 최적화 기법 임계 영역 최소화 임계 영역을 가능한 한 작게 유지하는 것이 중요하다.\n이를 통해 동기화로 인한 오버헤드를 줄이고 병렬 처리 효율을 높일 수 있다.\n공유 데이터 접근 코드만 임계 영역으로 설정 계산 로직은 임계 영역 밖으로 이동 세밀한 잠금 (Fine-grained Locking) 큰 임계 영역을 여러 개의 작은 임계 영역으로 나누는 기법.\n데이터 구조의 일부분만 잠그도록 설계 동시성을 높이고 대기 시간을 줄임 락-프리 알고리즘 (Lock-free Algorithms) 락을 사용하지 않고 원자적 연산을 활용하여 동기화를 구현한다.\nCompare-and-Swap (CAS) 등의 원자적 연산 사용 데드락 위험 제거 및 성능 향상 읽기-쓰기 락 (Read-Write Locks) 읽기 작업과 쓰기 작업에 대해 서로 다른 락을 사용한다.\n다수의 읽기 작업 동시 허용 쓰기 작업 시에만 배타적 접근 비동기 프로그래밍 (Asynchronous Programming) 비동기 프로그래밍 모델을 사용하여 임계 영역 접근을 최소화한다.\n이벤트 기반 프로그래밍 콜백 또는 Promise 패턴 활용 락 결합 (Lock Coalescing) 여러 개의 연속된 락 획득과 해제를 하나로 합치는 기법.\n락 획득/해제 횟수 감소 오버헤드 감소 및 성능 향상 락 계층화 (Lock Hierarchies) 락을 계층적으로 구성하여 데드락을 방지하고 성능을 개선한다.\n락 획득 순서 강제 복잡한 동기화 시나리오에서 유용 참고 및 출처 ","wordCount":"748","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-04T07:49:00Z","dateModified":"2024-10-04T07:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">임계 영역 (Critical Section)</h1><div class=post-description>여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역</div><div class=post-meta><span title='2024-10-04 07:49:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Systems%20and%20Infrastructure/Operating%20systems/Process%20Management/Concurrency%20and%20Parallelism/Synchronization/Critical%20Section/__index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#임계-영역-critical-section>임계 영역 (Critical Section)</a><ul><li><a href=#임계-영역-문제의-해결-조건>임계 영역 문제의 해결 조건</a></li><li><a href=#임계-영역-관련-문제와-해결-방법>임계 영역 관련 문제와 해결 방법</a></li><li><a href=#임계-영역-최적화-기법>임계 영역 최적화 기법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=임계-영역-critical-section>임계 영역 (Critical Section)<a hidden class=anchor aria-hidden=true href=#임계-영역-critical-section>#</a></h2><p>운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.<br>이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.</p><p>여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 임계 영역 예시</span>
</span></span><span class=line><span class=cl><span class=n>balance</span> <span class=o>=</span> <span class=mi>1000</span>  <span class=c1># 공유 자원</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>    <span class=c1># 임계 영역 시작</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span> <span class=o>-</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>    <span class=n>balance</span> <span class=o>=</span> <span class=n>temp</span>
</span></span><span class=line><span class=cl>    <span class=c1># 임계 영역 종료</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=임계-영역-문제의-해결-조건>임계 영역 문제의 해결 조건<a hidden class=anchor aria-hidden=true href=#임계-영역-문제의-해결-조건>#</a></h3><ol><li>상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다.</li><li>진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다.</li><li>한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다.</li></ol><h3 id=임계-영역-관련-문제와-해결-방법>임계 영역 관련 문제와 해결 방법<a hidden class=anchor aria-hidden=true href=#임계-영역-관련-문제와-해결-방법>#</a></h3><table><thead><tr><th>구분</th><th>데드락(Deadlock)</th><th>경쟁 상태(Race Condition)</th><th>기아 상태(Starvation)</th><th>라이브락(Livelock)</th></tr></thead><tbody><tr><td>정의</td><td>두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태</td><td>여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태</td><td>특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태</td><td>프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태</td></tr><tr><td>발생 원인</td><td>상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족</td><td>공유 자원에 대한 동시 접근, 원자성 결여</td><td>부적절한 자원 할당 정책, 우선순위 역전 현상</td><td>프로세스들의 과도한 양보, 재귀적 회피 동작</td></tr><tr><td>결과</td><td>시스템 전체 또는 일부 프로세스의 완전한 정지</td><td>데이터 불일치, 예측 불가능한 결과</td><td>특정 프로세스의 실행 지연 또는 무한 대기</td><td>CPU 자원 소비, 실제 작업 진행 없음</td></tr><tr><td>특징</td><td>프로세스들이 움직이지 않고 완전히 멈춤</td><td>타이밍에 따라 결과가 비결정적</td><td>자원 할당의 불공정성</td><td>프로세스들이 활발히 상태 변경</td></tr><tr><td>해결 방법</td><td>프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거</td><td>동기화 메커니즘 사용(뮤텍스, 세마포어 등)</td><td>에이징(Aging) 기법 도입, 공정한 스케줄링</td><td>무작위 대기 시간 도입, 우선순위 조정</td></tr><tr><td>예방 기법</td><td>자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정</td><td>임계 영역 설정, 원자적 연산 사용</td><td>자원 예약 시스템, 우선순위 조정 메커니즘</td><td>타임아웃 설정, 재시도 횟수 제한</td></tr><tr><td>탐지 방법</td><td>자원 할당 그래프 분석, 대기 사이클 검출</td><td>데이터 일관성 검사, 로그 분석</td><td>자원 할당 통계 모니터링</td><td>CPU 사용률 분석, 진행률 모니터링</td></tr><tr><td>영향 범위</td><td>전체 시스템 또는 관련 프로세스 그룹</td><td>공유 자원을 사용하는 프로세스들</td><td>특정 프로세스 또는 프로세스 그룹</td><td>상호 작용하는 프로세스 그룹</td></tr><tr><td>복구 방법</td><td>프로세스 재시작, 시스템 재부팅</td><td>트랜잭션 롤백, 상태 복원</td><td>우선순위 재조정, 자원 재할당</td><td>프로세스 재시작 또는 동작 패턴 변경</td></tr><tr><td>모니터링 방법</td><td>시스템 자원 모니터링, 프로세스 상태 감시</td><td>로그 분석, 데이터 정합성 검사</td><td>자원 할당 히스토리 분석</td><td>CPU 사용률 추적, 진행 상태 모니터링</td></tr></tbody></table><h4 id=해결-방법>해결 방법<a hidden class=anchor aria-hidden=true href=#해결-방법>#</a></h4><ol><li><p>상호 배제(Mutual Exclusion) 구현:</p><ul><li>뮤텍스(Mutex): 하나의 공유 자원에 대한 접근을 제어한다.</li><li>세마포어(Semaphore): 여러 개의 공유 자원에 대한 접근을 제어한다.</li></ul></li><li><p>동기화 기법:</p><ul><li>피터슨 알고리즘(Peterson&rsquo;s Algorithm): 두 프로세스 간의 상호 배제를 소프트웨어적으로 구현한다.</li><li>베이커리 알고리즘(Bakery Algorithm): 여러 프로세스 간의 상호 배제를 구현한다.</li></ul></li><li><p>하드웨어 지원:</p><ul><li>테스트와 설정(Test-and-Set) 명령어: 원자적 연산을 통해 상호 배제를 구현한다.</li><li>비교와 교환(Compare-and-Swap) 명령어: 더 정교한 동기화 제어를 가능하게 한다.</li></ul></li><li><p>운영체제 수준의 지원:</p><ul><li>모니터(Monitor): 고수준의 동기화 메커니즘으로, 상호 배제를 자동으로 보장한다.</li><li>조건 변수(Condition Variables): 프로세스 간 통신과 동기화를 위해 사용된다.</li></ul></li><li><p>프로그래밍 언어 수준의 지원:</p><ul><li>동기화 키워드(예: Java의 synchronized): 임계 영역에 대한 접근을 언어 차원에서 제어한다.</li></ul></li><li><p>락-프리(Lock-Free) 및 대기-프리(Wait-Free) 알고리즘:</p><ul><li>락을 사용하지 않고도 동시성을 관리하는 고급 기법.</li></ul></li></ol><h5 id=해결-방법들을-적용할-때-고려해야-할-중요한-원칙>해결 방법들을 적용할 때 고려해야 할 중요한 원칙<a hidden class=anchor aria-hidden=true href=#해결-방법들을-적용할-때-고려해야-할-중요한-원칙>#</a></h5><ul><li>상호 배제(Mutual Exclusion)<ul><li>한 번에 하나의 프로세스만 임계 영역에 진입할 수 있도록 보장</li><li>적절한 동기화 메커니즘 사용</li></ul></li><li>진행(Progress)<ul><li>임계 영역에 있는 프로세스가 없다면 진입을 원하는 프로세스가 진입할 수 있어야 함</li><li>기아 상태 방지</li></ul></li><li>한정 대기(Bounded Waiting)<ul><li>프로세스의 임계 영역 진입 요청 후 무한정 대기하지 않도록 보장</li><li>공정성 확보</li></ul></li><li>원자성(Atomicity)<ul><li>임계 영역의 연산은 중단되지 않고 완전히 수행되어야 함</li><li>트랜잭션 관리</li></ul></li></ul><h3 id=임계-영역-최적화-기법>임계 영역 최적화 기법<a hidden class=anchor aria-hidden=true href=#임계-영역-최적화-기법>#</a></h3><h4 id=임계-영역-최소화>임계 영역 최소화<a hidden class=anchor aria-hidden=true href=#임계-영역-최소화>#</a></h4><p>임계 영역을 가능한 한 작게 유지하는 것이 중요하다.<br>이를 통해 동기화로 인한 오버헤드를 줄이고 병렬 처리 효율을 높일 수 있다.</p><ul><li>공유 데이터 접근 코드만 임계 영역으로 설정</li><li>계산 로직은 임계 영역 밖으로 이동</li></ul><h4 id=세밀한-잠금-fine-grained-locking>세밀한 잠금 (Fine-grained Locking)<a hidden class=anchor aria-hidden=true href=#세밀한-잠금-fine-grained-locking>#</a></h4><p>큰 임계 영역을 여러 개의 작은 임계 영역으로 나누는 기법.</p><ul><li>데이터 구조의 일부분만 잠그도록 설계</li><li>동시성을 높이고 대기 시간을 줄임</li></ul><h4 id=락-프리-알고리즘-lock-free-algorithms>락-프리 알고리즘 (Lock-free Algorithms)<a hidden class=anchor aria-hidden=true href=#락-프리-알고리즘-lock-free-algorithms>#</a></h4><p>락을 사용하지 않고 원자적 연산을 활용하여 동기화를 구현한다.</p><ul><li>Compare-and-Swap (CAS) 등의 원자적 연산 사용</li><li>데드락 위험 제거 및 성능 향상</li></ul><h4 id=읽기-쓰기-락-read-write-locks>읽기-쓰기 락 (Read-Write Locks)<a hidden class=anchor aria-hidden=true href=#읽기-쓰기-락-read-write-locks>#</a></h4><p>읽기 작업과 쓰기 작업에 대해 서로 다른 락을 사용한다.</p><ul><li>다수의 읽기 작업 동시 허용</li><li>쓰기 작업 시에만 배타적 접근</li></ul><h4 id=비동기-프로그래밍-asynchronous-programming>비동기 프로그래밍 (Asynchronous Programming)<a hidden class=anchor aria-hidden=true href=#비동기-프로그래밍-asynchronous-programming>#</a></h4><p>비동기 프로그래밍 모델을 사용하여 임계 영역 접근을 최소화한다.</p><ul><li>이벤트 기반 프로그래밍</li><li>콜백 또는 Promise 패턴 활용</li></ul><h4 id=락-결합-lock-coalescing>락 결합 (Lock Coalescing)<a hidden class=anchor aria-hidden=true href=#락-결합-lock-coalescing>#</a></h4><p>여러 개의 연속된 락 획득과 해제를 하나로 합치는 기법.</p><ul><li>락 획득/해제 횟수 감소</li><li>오버헤드 감소 및 성능 향상</li></ul><h4 id=락-계층화-lock-hierarchies>락 계층화 (Lock Hierarchies)<a hidden class=anchor aria-hidden=true href=#락-계층화-lock-hierarchies>#</a></h4><p>락을 계층적으로 구성하여 데드락을 방지하고 성능을 개선한다.</p><ul><li>락 획득 순서 강제</li><li>복잡한 동기화 시나리오에서 유용</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-and-parallelism/>Concurrency-and-Parallelism</a></li><li><a href=https://buenhyden.github.io/tags/synchronization/>Synchronization</a></li><li><a href=https://buenhyden.github.io/tags/critical-section/>Critical-Section</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/__index/><span class=title>« Prev</span><br><span>상호 배제 (Mutual Exclusion)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/concurrency-control/concurrency/><span class=title>Next »</span><br><span>동시성 (Concurrency)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>