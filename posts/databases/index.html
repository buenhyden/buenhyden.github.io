<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>데이터베이스 (Database) | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Database-Systems,RDBMS,NoSQL,Time-Series-DB,OODB,ORDB"><meta name=description content="구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/databases/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/databases/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/databases/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/databases/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="데이터베이스 (Database)"><meta property="og:description" content="구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="데이터베이스 (Database)"><meta name=twitter:description content="구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"데이터베이스 (Database)","item":"https://buenhyden.github.io/posts/databases/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>데이터베이스 (Database)</h1><div class=post-description>구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다.</div></header><div class=post-content><h2 id=데이터베이스-database>데이터베이스 (Database)<a hidden class=anchor aria-hidden=true href=#데이터베이스-database>#</a></h2><p>데이터베이스는 구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다.<br>데이터베이스는 데이터를 효율적으로 저장, 관리, 검색할 수 있도록 설계된 시스템으로, 현대 사회에서 정보 관리의 핵심 역할을 담당하고 있다.</p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><strong>데이터 독립성</strong>: 물리적 독립성과 논리적 독립성을 제공한다.</li><li><strong>데이터 무결성</strong>: 데이터의 정확성, 일관성, 유효성을 유지한다.</li><li><strong>데이터 보안성</strong>: 허가된 사용자만 데이터에 접근할 수 있도록 한다.</li><li><strong>데이터 일관성</strong>: 데이터의 불일치를 방지한다.</li><li><strong>데이터 중복 최소화</strong>: 데이터 중복을 줄여 저장 공간을 효율적으로 사용한다.</li></ol><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><ol><li>데이터의 효율적인 저장 및 관리</li><li>데이터 접근성 향상</li><li>데이터 무결성 보장</li><li>데이터 보안 강화</li><li>데이터 공유 및 협업 지원</li></ol><h3 id=구조>구조<a hidden class=anchor aria-hidden=true href=#구조>#</a></h3><p>데이터베이스는 일반적으로 다음과 같은 구조를 가진다.</p><ol><li><strong>스키마</strong>: 데이터베이스의 구조와 제약조건을 정의</li><li><strong>테이블</strong>: 관련 데이터를 행과 열로 구성</li><li><strong>필드</strong>: 테이블의 열로, 특정 유형의 데이터를 저장</li><li><strong>레코드</strong>: 테이블의 행으로, 관련 데이터의 집합</li></ol><h3 id=데이터베이스-관리-시스템database-management-system>데이터베이스 관리 시스템(Database Management System)<a hidden class=anchor aria-hidden=true href=#데이터베이스-관리-시스템database-management-system>#</a></h3><p>DBMS(데이터베이스 관리 시스템)는 데이터베이스를 생성, 관리 및 사용할 수 있게 해주는 소프트웨어 시스템.<br>데이터베이스는 정보의 저장소이고, DBMS는 이 저장소를 효율적으로 관리하고 사용할 수 있게 해주는 도구이다.</p><p>주요 기능:</p><ol><li>정의 기능: 데이터의 구조, 형식, 제약조건 등을 명세한다.</li><li>구축 기능: 데이터를 DBMS가 관리하는 저장 장치에 저장한다.</li><li>조작 기능: 데이터 검색, 갱신, 삽입, 삭제 등의 작업을 수행한다.</li><li>공유 기능: 여러 사용자와 프로그램이 데이터베이스에 동시에 접근할 수 있게 한다.</li><li>보호 기능: 하드웨어나 소프트웨어의 오동작, 권한 없는 접근으로부터 시스템을 보호한다.</li><li>유지보수 기능: 시간에 따라 변화하는 요구사항을 반영할 수 있게 한다.</li></ol><p>특징:</p><ol><li>데이터 독립성: 응용 프로그램과 데이터를 분리하여 관리한다.</li><li>동시성 제어: 여러 사용자의 동시 접근을 관리한다.</li><li>데이터 무결성: 데이터의 정확성과 일관성을 보장한다.</li><li>보안 관리: 사용자 권한을 설정하고 데이터 접근을 제어한다.</li><li>백업 및 복구: 데이터 손실을 방지하고 복구 기능을 제공한다.</li></ol><h3 id=유형>유형<a hidden class=anchor aria-hidden=true href=#유형>#</a></h3><ol><li><strong>계층형 데이터베이스</strong> (1960년대~): 트리 구조로 데이터를 저장합니다.</li><li><strong>네트워크형 데이터베이스</strong> (1960년대~): 데이터 간 N:N 관계를 지원합니다.</li><li><strong>관계형 데이터베이스</strong> (1970년대~): 테이블 형태로 데이터를 저장하며, SQL을 사용합니다.</li><li><strong>객체지향형 데이터베이스</strong> (1980년대~): 객체 형태로 데이터를 저장합니다.</li><li><strong>객체 관계형 데이터베이스</strong> (1990년대~): 관계형 모델에 객체지향 개념을 도입했습니다.</li><li><strong>NoSQL 데이터베이스</strong> (2000년대~): 비정형 데이터 처리에 유리합니다.</li><li><strong>NewSQL 데이터베이스</strong> (2010년대~): RDBMS와 NoSQL의 장점을 결합했습니다.</li></ol><h4 id=계층형-데이터베이스-hierarchical-database>계층형 데이터베이스 (Hierarchical Database)<a hidden class=anchor aria-hidden=true href=#계층형-데이터베이스-hierarchical-database>#</a></h4><p>계층형 데이터베이스(Hierarchical Database)는 데이터를 트리 구조로 저장하고 관리하는 데이터베이스 모델.</p><p>구조와 특징:</p><ul><li>데이터가 부모-자식 관계로 구성되어 있어 트리 형태의 구조를 가집니다.</li><li>각 레코드는 하나의 부모만을 가질 수 있습니다.</li><li>상위 레코드와 하위 레코드 간에 1:N의 관계만 존재합니다.</li></ul><p>장점:</p><ul><li>데이터 접근 속도가 빠릅니다.</li><li>데이터 사용량을 쉽게 예측할 수 있습니다.</li><li>참조 무결성(Referential integrity)이 내장되어 있어 자동으로 시행됩니다.</li></ul><p>단점:</p><ul><li>복잡한 관계 표현이 어렵습니다.</li><li>데이터 중복 문제가 발생할 수 있습니다.</li><li>초기 설정 후 변화하는 프로세스를 수용하기 어렵습니다.</li></ul><p>주요 계층형 데이터베이스 시스템:</p><ol><li><p><strong>IBM의 IMS (Information Management System)</strong>:</p><ul><li>가장 대표적인 계층형 데이터베이스 관리 시스템입니다.</li><li>대형 메인프레임 환경에서 주로 사용됩니다.</li></ul></li><li><p><strong>Windows Registry</strong>:</p><ul><li>Windows 운영 체제의 설정 정보를 저장하는 데 사용되는 계층형 데이터베이스입니다.</li></ul></li><li><p><strong>LDAP (Lightweight Directory Access Protocol)</strong>:</p><ul><li>네트워크 상의 디렉터리 서비스를 위한 프로토콜로, 계층형 구조를 사용합니다.</li></ul></li><li><p><strong>XML 데이터베이스</strong>:</p><ul><li>XML 문서의 계층적 구조를 그대로 저장하고 관리하는 데이터베이스 시스템입니다.</li></ul></li><li><p><strong>파일 시스템</strong>:</p><ul><li>하드디스크, DVD 등의 파일 시스템도 계층형 데이터베이스의 한 형태로 볼 수 있습니다.</li></ul></li></ol><h4 id=네트워크형-데이터베이스-ndb>네트워크형 데이터베이스 (NDB)<a hidden class=anchor aria-hidden=true href=#네트워크형-데이터베이스-ndb>#</a></h4><p>네트워크형 데이터베이스는 데이터를 네트워크 구조로 표현하는 데이터베이스 모델.</p><p>구조와 특징:</p><ul><li>데이터를 노드(레코드)와 링크(관계)로 표현하는 그래프 구조를 가집니다.</li><li>N:N(다대다) 관계를 직접 표현할 수 있어 계층형 데이터베이스의 한계를 극복했습니다.</li><li>레코드 간 복잡한 관계를 그물망처럼 표현할 수 있습니다.</li></ul><p>장점:</p><ul><li>데이터 접근성과 유연성이 향상되었습니다.</li><li>계층형 데이터베이스에 비해 더 복잡한 관계를 표현할 수 있습니다.</li><li>데이터 추출이 빠르고 효과적입니다.</li></ul><p>단점:</p><ul><li>구조가 복잡하여 유지보수가 어렵습니다.</li><li>데이터베이스 구조 변경 시 모든 데이터를 갱신해야 하므로 무결성 유지가 어렵습니다.</li><li>프로그래머가 모든 구조를 이해해야 하므로 프로그래밍이 복잡합니다.</li></ul><p>주요 네트워크형 데이터베이스 시스템:</p><ol><li><p><strong>IDMS (Integrated Database Management System)</strong>:</p><ul><li>Computer Associates(현 Broadcom)에서 개발한 대표적인 네트워크형 DBMS입니다.</li><li>메인프레임 환경에서 주로 사용되었습니다.</li></ul></li><li><p><strong>IDS (Integrated Data Store)</strong>:</p><ul><li>General Electric에서 개발한 초기 네트워크형 데이터베이스 시스템입니다.</li></ul></li><li><p><strong>TOTAL</strong>:</p><ul><li>Cincom Systems에서 개발한 네트워크형 DBMS입니다.</li></ul></li><li><p><strong>DMS 1100</strong>:</p><ul><li>Unisys에서 개발한 네트워크형 데이터베이스 관리 시스템입니다.</li></ul></li></ol><h4 id=관계형-데이터베이스-relational-database>관계형 데이터베이스 (Relational Database)<a hidden class=anchor aria-hidden=true href=#관계형-데이터베이스-relational-database>#</a></h4><p>관계형 데이터베이스(RDBMS)는 데이터를 테이블 형태로 구조화하여 저장하고 관리하는 데이터베이스 시스템</p><p>특징:</p><ul><li>데이터의 구조화:<ul><li>데이터를 테이블 형태로 저장하며, 각 테이블은 행(레코드)과 열(필드)로 구성됩니다.</li><li>테이블 간의 관계를 정의하여 데이터를 효율적으로 관리합니다.</li></ul></li><li>데이터 무결성과 일관성:<ul><li>ACID(원자성, 일관성, 고립성, 지속성) 특성을 통해 데이터의 무결성과 일관성을 보장합니다.</li><li>트랜잭션 처리를 통해 데이터의 정확성을 유지합니다.</li></ul></li><li>SQL 사용:<ul><li>표준화된 SQL(Structured Query Language)을 사용하여 데이터를 조작하고 관리합니다.</li><li>SQL을 통해 복잡한 쿼리와 데이터 분석이 가능합니다.</li></ul></li><li>스키마 정의:<ul><li>데이터베이스 스키마를 통해 데이터의 구조와 제약조건을 명확하게 정의합니다.</li><li>정형화된 데이터 구조를 가지고 있어 데이터의 일관성을 유지하기 쉽습니다.</li></ul></li><li>보안과 접근 제어:<ul><li>사용자 인증과 권한 관리를 통해 데이터에 대한 보안을 제공합니다.</li><li>데이터베이스 수준에서 세밀한 접근 제어가 가능합니다.</li></ul></li><li>확장성과 성능<ul><li>인덱싱을 통해 데이터 검색 속도를 향상시킬 수 있습니다.</li><li>대규모 데이터 처리와 복잡한 쿼리 실행에 적합합니다.</li></ul></li></ul><p>주요 관계형 데이터베이스 시스템:</p><ol><li><p>MySQL:</p><ul><li>오픈 소스 RDBMS로, 웹 애플리케이션에 널리 사용됩니다.</li><li>다양한 운영 체제에서 작동하며 빠른 성능과 높은 신뢰성을 제공합니다.</li><li>PHP와의 호환성이 뛰어나 웹 개발에 자주 사용됩니다.</li></ul></li><li><p>Oracle Database:</p><ul><li>엔터프라이즈급 RDBMS로, 대규모 데이터 처리에 적합합니다.</li><li>높은 확장성과 안정성을 제공하며, 복잡한 트랜잭션 처리에 강점이 있습니다.</li><li>PL/SQL을 사용하여 저장 프로시저와 함수를 작성할 수 있습니다.</li></ul></li><li><p>Microsoft SQL Server:</p><ul><li>Windows 환경에 최적화된 RDBMS입니다.</li><li>비즈니스 인텔리전스 및 데이터 분석 기능이 통합되어 있습니다.</li><li>.NET 프레임워크와의 높은 호환성을 제공합니다.</li></ul></li><li><p>PostgreSQL:</p><ul><li>오픈 소스 RDBMS로, 확장성과 표준 준수에 중점을 둡니다.</li><li>복잡한 쿼리와 대규모 데이터베이스 관리에 적합합니다.</li><li>지리 정보 시스템(GIS) 데이터 처리에 강점이 있습니다.</li></ul></li><li><p>IBM DB2:</p><ul><li>대규모 트랜잭션 처리와 데이터 웨어하우징에 적합한 엔터프라이즈급 RDBMS입니다.</li><li>AI 및 기계 학습 기능이 통합되어 있습니다.</li><li>다양한 플랫폼에서 작동할 수 있습니다.</li></ul></li><li><p>SQLite:</p><ul><li>경량화된 RDBMS로, 로컬 스토리지가 필요한 애플리케이션에 적합합니다.</li><li>서버 설정이 필요 없어 모바일 앱과 데스크톱 애플리케이션에서 자주 사용됩니다.</li><li>단일 파일로 전체 데이터베이스를 저장할 수 있습니다.</li></ul></li></ol><h4 id=객체지향형-데이터베이스-object-oriented-database-oodb>객체지향형 데이터베이스 (object-oriented Database; OODB)<a hidden class=anchor aria-hidden=true href=#객체지향형-데이터베이스-object-oriented-database-oodb>#</a></h4><p>객체지향 데이터베이스(OODBMS)는 객체지향 프로그래밍 패러다임을 데이터베이스 기술과 결합한 시스템입니다.</p><p>객체지향 데이터베이스의 주요 특징:</p><ol><li><strong>복합 객체 지원</strong>: 복잡한 데이터 구조를 직접 표현할 수 있습니다.</li><li><strong>객체 식별자(OID)</strong>: 각 객체에 고유한 식별자를 부여하여 객체의 정체성을 유지합니다.</li><li><strong>캡슐화</strong>: 데이터와 그 데이터를 조작하는 메서드를 하나의 단위로 묶습니다.</li><li><strong>상속</strong>: 기존 클래스의 속성과 메서드를 새로운 클래스가 물려받을 수 있습니다.</li><li><strong>다형성</strong>: 같은 이름의 메서드가 객체에 따라 다르게 동작할 수 있습니다.</li><li><strong>버전 관리</strong>: 객체의 여러 버전을 저장하고 관리할 수 있습니다.</li><li><strong>장기 트랜잭션 지원</strong>: 복잡하고 장시간 실행되는 트랜잭션을 효과적으로 처리합니다.</li></ol><p>주요 객체지향 데이터베이스 시스템:</p><ol><li><p><strong>GemStone/OPAL</strong></p><ul><li>GemStone Systems에서 개발</li><li>Smalltalk 프로그래밍 언어와 통합되어 있음</li></ul></li><li><p><strong>ObjectStore</strong></p><ul><li>Object Design(후에 Excelon)에서 개발</li><li>C++와 Java 언어를 지원</li></ul></li><li><p><strong>Versant</strong></p><ul><li>Versant Object Technologies에서 개발</li><li>분산 객체 관리에 강점</li></ul></li><li><p><strong>ONTOS</strong></p><ul><li>Ontos사에서 개발</li><li>C++와 통합된 객체 데이터베이스 시스템</li></ul></li><li><p><strong>O2 (후에 ARDENT)</strong></p><ul><li>ARDENT Software에서 인수</li><li>객체지향 데이터베이스와 객체-관계형 데이터베이스의 특성을 결합</li></ul></li><li><p><strong>Objectivity/DB</strong></p><ul><li>Objectivity Inc에서 개발</li><li>대규모 분산 데이터베이스 관리에 적합</li></ul></li><li><p><strong>POET</strong></p><ul><li>POET Software에서 개발</li><li>객체 영속성 관리에 중점</li></ul></li><li><p><strong>Jasmine</strong></p><ul><li>Fujitsu-GM에서 개발</li><li>멀티미디어 데이터 관리에 강점</li></ul></li></ol><h4 id=객체-관계형-데이터베이스-object-relational-database-ord-ordb>객체 관계형 데이터베이스 (object-relational Database; ORD, ORDB)<a hidden class=anchor aria-hidden=true href=#객체-관계형-데이터베이스-object-relational-database-ord-ordb>#</a></h4><p>관계형 데이터베이스와 객체지향 데이터베이스의 특성을 결합한 데이터베이스 관리 시스템</p><p>특징:</p><ol><li><strong>복합 데이터 타입 지원</strong>: 사용자 정의 타입, 복잡한 객체, 배열 등을 지원합니다.</li><li><strong>상속</strong>: 테이블과 데이터 타입에 대한 상속을 지원하여 객체지향적 모델링이 가능합니다.</li><li><strong>다형성</strong>: 다양한 클래스의 객체를 공통 상위 클래스로 처리할 수 있어 유연성이 높습니다.</li><li><strong>캡슐화</strong>: 데이터와 메서드를 객체 내에 캡슐화하여 데이터 추상화를 촉진합니다.</li><li><strong>SQL 확장</strong>: 객체 관계형 개념을 지원하기 위해 표준 SQL을 확장합니다.</li></ol><p>주요 객체관계형 데이터베이스 시스템과 특징:</p><ol><li><p>Oracle Database: 객체관계형 기능을 가장 광범위하게 구현한 DBMS 중 하나.<br>주요 특징:<br>- 사용자 정의 타입, 상속, 다형성 등 객체지향 기능 지원<br>- 복잡한 비즈니스 모델을 관계형 데이터베이스에 저장 가능<br>- PL/SQL을 통한 객체지향 프로그래밍 지원</p></li><li><p>PostgreSQL: 강력한 오픈소스 객체관계형 데이터베이스 시스템입니다.<br>주요 특징:<br>- 사용자 정의 타입, 테이블 상속, 함수 오버로딩 등 객체지향 기능 제공<br>- JSON 데이터 타입 지원으로 유연한 데이터 모델링 가능<br>- 확장 가능한 아키텍처로 새로운 데이터 타입, 함수, 연산자 추가 가능</p></li><li><p>IBM DB2: 엔터프라이즈급 객체관계형 데이터베이스 시스템입니다.<br>주요 특징:<br>- 객체 뷰, 사용자 정의 타입, 구조화된 타입 지원<br>- XML 데이터 처리를 위한 pureXML 기술 제공<br>- AI 기능 통합으로 데이터 과학 및 머신러닝 지원</p></li><li><p>Microsoft SQL Server: Windows 환경에서 널리 사용되는 객체관계형 데이터베이스입니다.<br>주요 특징:<br>- 사용자 정의 타입, 테이블 값 함수 등 객체지향 기능 제공<br>-.NET 프레임워크와의 긴밀한 통합<br>- 공간 데이터 처리를 위한 기능 내장</p></li></ol><h4 id=nosql-데이터베이스>NoSQL 데이터베이스<a hidden class=anchor aria-hidden=true href=#nosql-데이터베이스>#</a></h4><p>전통적인 관계형 데이터베이스의 한계를 극복하기 위해 등장.<br>다양한 종류의 NoSQL 데이터베이스들이 각자의 특징과 장점을 가지고 있다.</p><p>특징:</p><ol><li>유연한 스키마:<br>NoSQL 데이터베이스는 유연한 스키마를 제공하여 구조화, 반구조화 및 비구조화된 데이터를 쉽게 처리할 수 있습니다. 이는 데이터 모델을 쉽게 변경하고 진화시킬 수 있게 해줍니다.</li><li>수평적 확장성:<br>NoSQL 데이터베이스는 수평적으로 쉽게 확장할 수 있도록 설계되었습니다. 이는 데이터베이스 클러스터에 노드를 추가하여 대규모 데이터와 높은 트래픽을 처리할 수 있음을 의미합니다.</li><li>고가용성:<br>분산 아키텍처를 통해 NoSQL 데이터베이스는 높은 가용성을 제공합니다. 데이터의 여러 복사본을 유지하여 노드 장애에도 지속적인 서비스를 보장합니다.</li><li>다양한 데이터 모델 지원:<br>NoSQL 데이터베이스는 문서, 키-값, 그래프, 와이드 컬럼 등 다양한 데이터 모델을 지원합니다. 이를 통해 애플리케이션의 특정 요구사항에 맞는 데이터 모델을 선택할 수 있습니다.</li><li>빠른 쿼리 성능:<br>NoSQL 데이터베이스는 복잡한 조인 없이 빠른 쿼리 성능을 제공합니다. 이는 대규모 데이터셋에서 빠른 데이터 검색을 가능하게 합니다.</li><li>대규모 데이터 처리:<br>NoSQL 데이터베이스는 대량의 데이터를 효율적으로 처리하도록 설계되었습니다. 이는 빅데이터, 실시간 분석, IoT 등의 사용 사례에 적합합니다.</li><li>개발 민첩성:<br>NoSQL 데이터베이스의 유연성은 애자일 개발 방법론과 잘 맞습니다. 개발자들은 빠르게 시작하고 데이터 모델을 반복적으로 개선할 수 있습니다.</li></ol><h5 id=주요-유형>주요 유형<a hidden class=anchor aria-hidden=true href=#주요-유형>#</a></h5><h6 id=문서-데이터베이스>문서 데이터베이스<a hidden class=anchor aria-hidden=true href=#문서-데이터베이스>#</a></h6><p>문서 데이터베이스는 JSON이나 BSON 형식의 문서로 데이터를 저장합니다.</p><p><strong>특징:</strong></p><ul><li>유연한 스키마 구조</li><li>복잡한 데이터 구조 표현 가능</li><li>높은 확장성</li></ul><p><strong>주요 예시:</strong></p><ul><li>MongoDB</li><li>CouchDB</li><li>Couchbase</li></ul><h6 id=키-값-데이터베이스>키-값 데이터베이스<a hidden class=anchor aria-hidden=true href=#키-값-데이터베이스>#</a></h6><p>키-값 데이터베이스는 단순한 키-값 쌍으로 데이터를 저장합니다.</p><p><strong>특징:</strong></p><ul><li>빠른 읽기와 쓰기 성능</li><li>단순한 구조</li><li>높은 확장성</li></ul><p><strong>주요 예시:</strong></p><ul><li>Redis</li><li>Amazon DynamoDB</li><li>Riak</li></ul><h6 id=와이드-컬럼-스토어-컬럼-패밀리-데이터베이스>와이드 컬럼 스토어 (컬럼 패밀리 데이터베이스)<a hidden class=anchor aria-hidden=true href=#와이드-컬럼-스토어-컬럼-패밀리-데이터베이스>#</a></h6><p>와이드 컬럼 스토어는 열 지향적으로 데이터를 저장합니다.</p><p><strong>특징:</strong></p><ul><li>대용량 데이터 처리에 적합</li><li>높은 확장성</li><li>유연한 스키마</li></ul><p><strong>주요 예시:</strong></p><ul><li>Apache Cassandra</li><li>HBase</li><li>Google Bigtable</li></ul><h6 id=그래프-데이터베이스>그래프 데이터베이스<a hidden class=anchor aria-hidden=true href=#그래프-데이터베이스>#</a></h6><p>그래프 데이터베이스는 노드와 엣지를 사용하여 데이터 간의 관계를 저장합니다.</p><p><strong>특징:</strong></p><ul><li>복잡한 관계 표현에 적합</li><li>빠른 관계 탐색</li><li>유연한 데이터 모델</li></ul><p><strong>주요 예시:</strong></p><ul><li>Neo4j</li><li>Amazon Neptune</li><li>OrientDB</li></ul><h5 id=고려해야할-사항>고려해야할 사항<a hidden class=anchor aria-hidden=true href=#고려해야할-사항>#</a></h5><ol><li>데이터 모델: 데이터의 구조와 접근 패턴을 고려하여 적절한 NoSQL 유형을 선택해야 합니다. 예를 들어, 복잡한 관계가 많은 데이터는 그래프 데이터베이스가 적합할 수 있습니다.</li><li>확장성 요구사항: 수평적 확장이 필요한 경우, Cassandra나 MongoDB와 같은 분산 데이터베이스를 고려해야 합니다.</li><li>일관성 요구사항: 강한 일관성이 필요한지, 아니면 최종적 일관성으로 충분한지 검토해야 합니다. 예를 들어, 금융 거래는 강한 일관성이 필요할 수 있습니다.</li></ol><h4 id=newsql-데이터베이스>NewSQL 데이터베이스<a hidden class=anchor aria-hidden=true href=#newsql-데이터베이스>#</a></h4><p> 관계형 데이터베이스의 ACID 특성과 NoSQL의 확장성을 결합한 새로운 유형의 데이터베이스 시스템</p><p>주요 특징:</p><ol><li>SQL 지원: ANSI SQL 문법을 지원하여 기존 관계형 데이터베이스와의 호환성을 제공합니다.</li><li>ACID 트랜잭션: 데이터의 일관성과 무결성을 보장하는 ACID 특성을 지원합니다.</li><li>수평적 확장성: NoSQL처럼 Scale-out 방식으로 쉽게 확장할 수 있습니다.</li><li>고성능: 인메모리 처리, 분산 아키텍처 등을 통해 높은 처리 성능을 제공합니다.</li><li>비잠금 동시성 제어: MVCC(Multi-Version Concurrency Control) 등의 기법을 사용하여 동시성을 관리합니다.</li><li>분산 아키텍처: 데이터를 여러 노드에 분산 저장하여 가용성과 내구성을 높입니다.</li><li>자동 샤딩: 데이터를 자동으로 여러 노드에 분산하여 저장합니다.</li></ol><p>주요 NewSQL 데이터베이스 시스템:</p><ol><li><p>Google Spanner:</p><ul><li>구글에서 개발한 글로벌 분산 데이터베이스</li><li>강력한 일관성과 고가용성 제공</li></ul></li><li><p>VoltDB:</p><ul><li>인메모리 기반의 고성능 NewSQL 데이터베이스</li><li>OLTP 워크로드에 최적화</li></ul></li><li><p>CockroachDB:</p><ul><li>분산 SQL 데이터베이스로 강력한 일관성과 고가용성 제공</li><li>자동 샤딩과 복제 기능 내장</li></ul></li><li><p>NuoDB:</p><ul><li>분산 SQL 데이터베이스로 클라우드 환경에 최적화</li><li>유연한 확장성과 고가용성 제공</li></ul></li><li><p>MemSQL (현재 SingleStore):</p><ul><li>분산 인메모리 SQL 데이터베이스</li><li>실시간 분석과 트랜잭션 처리에 적합</li></ul></li><li><p>TiDB:</p><ul><li>오픈소스 분산 SQL 데이터베이스</li><li>MySQL 호환성과 수평적 확장성 제공</li></ul></li></ol><h4 id=time-series-데이터베이스>Time Series 데이터베이스<a hidden class=anchor aria-hidden=true href=#time-series-데이터베이스>#</a></h4><p>Time series 데이터베이스(TSDB)는 시간에 따라 정렬된 데이터를 효율적으로 저장, 관리 및 분석하기 위해 최적화된 데이터베이스 시스템입니다.</p><p>특징:</p><ol><li>시간 기반 데이터 저장: 데이터를 시간순으로 저장하고 인덱싱합니다.</li><li>높은 확장성: IoT 장치 등에서 생성되는 대량의 시계열 데이터를 효율적으로 처리할 수 있습니다.</li><li>고성능 쿼리: 시간 기반 작업에 최적화되어 특정 시간 범위의 데이터를 빠르게 검색할 수 있습니다.</li><li>실시간 분석: 많은 TSDB가 실시간 처리 기능을 제공하여 즉각적인 분석과 시각화가 가능합니다.</li><li>데이터 압축: 시계열 데이터의 특성을 활용한 효율적인 압축 알고리즘을 사용합니다.</li><li>데이터 수명 주기 관리: 오래된 데이터를 자동으로 삭제하거나 다운샘플링하는 기능을 제공합니다.</li></ol><p>주요 종류:</p><ol><li>InfluxDB: 오픈 소스 TSDB로, 높은 성능과 확장성을 제공합니다.</li><li>TimescaleDB: PostgreSQL 기반의 오픈 소스 TSDB로, SQL을 지원합니다.</li><li>OpenTSDB: 분산 시계열 데이터베이스로, 대규모 데이터 처리에 적합합니다.</li><li>Prometheus: 모니터링과 알림에 특화된 TSDB입니다.</li><li>Amazon Timestream: AWS에서 제공하는 완전 관리형 TSDB 서비스입니다.</li><li>QuestDB: 고성능 오픈 소스 SQL 데이터베이스로, 시계열 데이터 처리에 최적화되어 있습니다.</li><li>Graphite: 시계열 데이터의 저장과 그래프 생성에 특화된 TSDB입니다.</li></ol><h4 id=vector-데이터베이스>Vector 데이터베이스<a hidden class=anchor aria-hidden=true href=#vector-데이터베이스>#</a></h4><p>고차원 벡터 데이터를 효율적으로 저장하고 검색하기 위해 설계된 특수한 데이터베이스 시스템</p><p>주요 특징:</p><ol><li>최적화된 벡터 저장: 고차원 벡터의 저장 및 검색을 위해 특수한 데이터 구조와 알고리즘을 사용합니다.</li><li>유사도 기반 검색: 코사인 유사도나 유클리드 거리 등의 메트릭을 사용하여 유사한 벡터를 빠르게 찾아냅니다.</li><li>확장성: 수평적 확장이 가능하도록 설계되어 대량의 데이터와 쿼리를 효과적으로 처리합니다.</li><li>실시간 처리: 빠른 응답 시간과 저지연 성능을 제공합니다.</li><li>다차원 데이터 지원: 이미지, 텍스트, 오디오 등 다양한 유형의 비정형 데이터를 벡터로 변환하여 저장합니다.</li><li>머신러닝 통합: AI 및 머신러닝 모델과의 연계가 용이합니다.</li></ol><p>주요 Vector 데이터베이스 종류</p><ol><li><p>Pinecone:</p><ul><li>완전 관리형 벡터 데이터베이스</li><li>클라우드 네이티브 설계로 확장성이 뛰어남</li></ul></li><li><p>Weaviate:</p><ul><li>오픈소스 벡터 데이터베이스</li><li>Python, Go, Java, JavaScript 지원</li><li>유연한 쿼리 기능 제공</li></ul></li><li><p>Milvus:</p><ul><li>오픈소스 벡터 데이터베이스</li><li>Python, Go, C++ 지원</li><li>대규모 데이터 처리에 적합</li></ul></li><li><p>Qdrant:</p><ul><li>오픈소스 벡터 데이터베이스</li><li>Rust로 작성되어 높은 성능 제공</li></ul></li><li><p>Vespa:</p><ul><li>Yahoo!에서 개발한 오픈소스 벡터 데이터베이스</li><li>풍부한 기능과 검증된 성능</li></ul></li><li><p>Chroma:</p><ul><li>오픈소스 벡터 데이터베이스</li><li>간단한 설정과 사용이 특징</li></ul></li><li><p>Faiss (Facebook AI Similarity Search):</p><ul><li>Facebook에서 개발한 라이브러리</li><li>효율적인 유사성 검색 및 군집화 제공</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><p><a href=https://velog.io/@y55nms/15.-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A2%85%EB%A5%98>y55nms.log(데이터베이스 종류)</a></p><h3 id=rdb>RDB<a hidden class=anchor aria-hidden=true href=#rdb>#</a></h3><p><a href=https://yozm.wishket.com/magazine/detail/675/>관계형 데이터베이스(RDB)란 무엇인가요?</a><br><a href=https://www.whatap.io/ko/blog/141/index.html>비전공자도 이해할수있는 DB와 SQL</a><br><a href=https://www.itworld.co.kr/news/319554>SQL 쿼리 속도를 높이는 9가지 방법</a></p><h3 id=vdb>VDB<a hidden class=anchor aria-hidden=true href=#vdb>#</a></h3><p><a href=https://learn.microsoft.com/en-us/semantic-kernel/memories/vector-db>What is a vector database?</a><br><a href=https://velog.io/@woonge/Vector-DB-%EB%A7%A8%EB%95%85%EC%97%90-%ED%97%A4%EB%94%A9%ED%95%98%EA%B8%B0-1>#1. Vector DB 탐색 배경과 종류</a><br><a href=https://hotorch.tistory.com/407>[Vector DB] 1. Vector Database 배경 & 필요성</a><br><a href=https://hotorch.tistory.com/406>[Vector DB] 2. Vector Database 종류 & 한계점</a><br><a href="https://devocean.sk.com/blog/techBoardDetail.do?ID=164964&amp;boardType=techBlog">ChatGPT의 전두엽(장기기억 저장소)으로 각광받고 있는 Vector DB에 대해 알아보자</a><br><a href="https://news.hada.io/topic?id=9147&amp;utm_source=pytorchkr">▲ Vector Database란?</a><br><a href=https://smilegate.ai/en/2023/11/07/vector-database-%EB%B2%A1%ED%84%B0-%EC%9E%84%EB%B2%A0%EB%94%A9%EC%9D%84-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B3%A0-%EA%B2%80%EC%83%89%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81/>Vector Database: 벡터 임베딩을 저장하고 검색하는 가장 효율적인 방법</a><br><a href=https://velog.io/@tura/vector-databases>Vector Database (feat. Pinecone)</a></p><p><a href=https://velog.io/@tura/vector-databases>Vector Database (feat. Pinecone)</a></p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Connection Pool</h2></header><div class=entry-content><p>Connection Pool Connection pool(연결 풀)은 데이터베이스 연결을 효율적으로 관리하기 위한 기술이다.
이 기술은 애플리케이션의 성능을 향상시키고 리소스 사용을 최적화하는 데 중요한 역할을 한다.
Connection pool은 데이터베이스 연결을 재사용 가능한 형태로 캐시하는 메커니즘이다.
이는 애플리케이션이 데이터베이스에 연결할 때마다 새로운 연결을 생성하는 대신, 미리 생성된 연결을 사용할 수 있게 해준다.
Connection pool은 현대 데이터베이스 애플리케이션에서 필수적인 기술로, 적절히 구현 및 설정될 경우 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있다.
https://medium.com/@sujoy.swe/database-connection-pool-647843dd250b
Connection Pool의 작동 원리 초기화: 애플리케이션 시작 시 미리 정해진 수의 데이터베이스 연결을 생성하여 풀에 저장한다. 연결 요청: 클라이언트가 데이터베이스 작업을 요청하면, 풀에서 사용 가능한 연결을 가져온다. 연결 사용: 클라이언트는 가져온 연결을 사용하여 데이터베이스 작업을 수행한다. 연결 반환: 작업이 완료되면 연결은 풀로 다시 반환된다. 연결 관리: 풀은 연결의 수명주기를 관리하며, 필요에 따라 새로운 연결을 생성하거나 오래된 연결을 제거한다. Connection Pool의 주요 설정 파라미터 초기 연결 수 (initialSize):
...</p></div><footer class=entry-footer><span title='2024-10-25 06:35:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2973 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Connection Pool" href=https://buenhyden.github.io/posts/databases/connection-pool/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ER(Entity-Relationship) 모델링</h2></header><div class=entry-content><p>ER(Entity-Relationship) 모델링 ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.
![An entity–attribute-relationship diagram for an MMORPG using Chen’s notation](1024px-ER_Diagram_MMORPG.png “https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png_
주요 구성 요소 개체(Entity)
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.
예를 들어, ‘학생’, ‘강좌’, ‘교수’ 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.
예시:
학생 개체의 경우: 실체: 개별 학생들 표현: ‘학생’ 이라는 개체로 모델링 속성: 학번, 이름, 학과, 연락처 등 속성(Attribute)
속성은 개체의 특성이나 성질을 나타낸다.
타원형으로 표현되며, 개체와 선으로 연결된다.
속성의 종류: 단일값 속성: 하나의 값만 가지는 속성 (예: 학번) 다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호) 유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이) 키 속성: 개체를 유일하게 식별하는 속성 (예: 학번) 관계(Relationship)
관계는 개체들 간의 연관성을 나타낸다.
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.
관계의 종류: 일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결 일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결 다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결
관계 표현 예시: 1 2 3 4 5 [학생] ----&lt; 수강 >---- [강좌] | | (학번) (과목코드) (이름) (과목명) (학과) (학점) ER 모델링의 단계 요구사항 분석
시스템에서 필요한 데이터와 기능을 파악한다.
예: “대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…”
...</p></div><footer class=entry-footer><span title='2024-10-25 02:06:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;355 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ER(Entity-Relationship) 모델링" href=https://buenhyden.github.io/posts/databases/entity-relationship-modeling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Object-Relational Mapping</h2></header><div class=entry-content><p>Object-Relational Mapping (ORM) 객체 지향 프로그래밍 언어와 관계형 데이터베이스 사이의 불일치를 해결하기 위한 기술
특징:
객체와 데이터베이스 테이블 간의 매핑 SQL 쿼리 대신 객체 지향적 방식으로 데이터베이스 조작 데이터베이스 독립성 제공 장점:
직관적이고 가독성 좋은 코드 작성 가능 생산성 향상: 개발자가 비즈니스 로직에 집중 가능 재사용성과 유지보수성 증가 데이터베이스 종속성 감소 단점:
성능 저하 가능성: 복잡한 쿼리의 경우 최적화가 어려울 수 있음 학습 곡선: ORM 사용법을 익히는 데 시간이 필요 복잡한 쿼리 처리의 한계: 매우 복잡한 쿼리는 직접 SQL 작성이 필요할 수 있음 ORM과 raw query 사이에는 성능 차이가 존재한다.
일반적으로 raw SQL이 ORM보다 더 나은 성능을 보인다.
주요 차이점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-12-16 12:59:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;207 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Object-Relational Mapping" href=https://buenhyden.github.io/posts/databases/more-about-databases/object-relational-mapping/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 불일치 (Data Inconsistency)</h2></header><div class=entry-content><p>데이터 불일치 (Data Inconsistency) 동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황
Source: https://www.geeksforgeeks.org/what-is-data-inconsistency-in-dbms/
발생 조건 데이터 불일치가 발생하는 주요 조건:
동시성 작업 여러 프로세스나 스레드가 동시에 데이터를 수정할 때 트랜잭션이 적절히 관리되지 않을 때 분산 환경 네트워크 지연이나 실패가 발생할 때 데이터 복제 과정에서 시간 차이가 발생할 때 캐싱 문제 캐시 무효화가 제대로 이루어지지 않을 때 캐시와 원본 데이터 간의 동기화 실패 시스템 오류 하드웨어 오류, 네트워크 문제, 소프트웨어 버그 등으로 인해 발생할 수 있다. 데이터 통합 문제: 서로 다른 소스의 데이터를 통합할 때 발생할 수 있다 해결책 및 방지책 데이터 표준화: 데이터 형식, 값, 표현을 일관되게 만든다. 데이터 검증: 데이터 입력 시 유효성 검사를 수행한다. 데이터 정제: 오류를 식별하고 수정하는 과정을 거친다. 데이터 거버넌스: 데이터 관리에 대한 명확한 정책과 절차를 수립한다. 동기화 메커니즘: 분산 시스템에서 데이터 동기화를 위한 알고리즘을 사용한다. 실제 시스템에서의 예방책 데이터 감사: 정기적인 데이터 감사를 통해 불일치를 식별한다. 자동화 도구 사용: 데이터 품질 관리 도구를 활용하여 불일치를 자동으로 탐지한다. 데이터 프로파일링: 데이터의 특성을 이해하고 잠재적 문제를 파악한다. 버전 관리: 데이터 변경 이력을 추적하여 불일치 발생 시 원인을 파악한다. 고려사항 및 주의사항 성능 영향: 데이터 일관성 유지 메커니즘이 시스템 성능에 미치는 영향을 고려해야 한다. 확장성: 대규모 분산 시스템에서의 데이터 일관성 유지 방법을 고려해야 한다. 사용자 교육: 데이터 입력 및 수정 시 주의사항에 대해 사용자를 교육해야 한다. 비즈니스 규칙 반영: 데이터 일관성 규칙에 비즈니스 로직을 반영해야 한다. 주의 사항 및 모범 사례 버전 관리 모든 데이터 변경에 버전 번호 부여 낙관적 락킹 구현 충돌 감지 및 해결 메커니즘 구축 캐시 전략 Cache-Aside 패턴 사용 적절한 TTL(Time-To-Live) 설정 캐시 무효화 전략 수립 동기화 메커니즘 분산 락 사용 이벤트 기반 동기화 멱등성 보장 모니터링 및 감사 버전 이력 관리 변경 로그 기록 불일치 감지 알림 실제 구현시 고려사항 확장성 수평적 확장을 고려한 설계 샤딩 전략 수립 복제 지연 관리 성능 캐시 적중률 최적화 인덱스 전략 수립 배치 처리 활용 복구 전략 백업 및 복구 계획 롤백 메커니즘 데이터 정합성 검증 모범 사례 단일 진실 소스(Single Source of Truth) 유지 데이터 품질 메트릭 정의 및 모니터링 데이터 소유권 및 책임 명확화 지속적인 데이터 품질 개선 프로세스 구축 데이터 불일치 해결을 위한 명확한 워크플로우 수립 파이썬 예제로 보는 데이터 불일치 다음은 데이터 불일치가 발생할 수 있는 상황과 이를 해결하는 방법을 보여주는 예제
...</p></div><footer class=entry-footer><span title='2024-10-25 07:22:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;975 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 불일치 (Data Inconsistency)" href=https://buenhyden.github.io/posts/databases/data-inconsistency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>N plus one problem</h2></header><div class=entry-content><p>N plus one problem N+1 문제는 하나의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 연관된 데이터를 조회하기 위해 N번의 추가 쿼리가 발생하는 현상을 말한다.
주로 ORM(Object-Relational Mapping) 기술을 사용할 때 발생하는 성능 관련 이슈로 데이터베이스에 불필요하게 많은 쿼리를 실행하게 되는 상황을 말한다.
발생 원인 연관 관계 매핑: 주로 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생한다. 지연 로딩(Lazy Loading): 연관된 엔티티를 실제로 사용할 때 추가적인 쿼리가 발생한다. 즉시 로딩(Eager Loading): 연관된 엔티티를 함께 조회하려 할 때 추가 쿼리가 발생할 수 있다. 문제점 성능 저하: 불필요한 데이터베이스 쿼리로 인해 애플리케이션의 성능이 크게 저하된다. 네트워크 부하: 데이터베이스와의 통신이 증가하여 네트워크 부하가 증가한다. 데이터베이스 부하: 과도한 쿼리 실행으로 데이터베이스 서버에 부담을 준다. 이러한 N+1 문제는 데이터베이스 성능에 큰 영향을 미칠 수 있으므로, 개발 초기 단계부터 인지하고 적절한 해결 방법을 적용하는 것이 중요하다.
특히 대규모 애플리케이션에서는 이 문제를 해결하지 않으면 심각한 성능 저하를 경험할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 11:21:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;475 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to N plus one problem" href=https://buenhyden.github.io/posts/databases/more-about-databases/n-plus-one-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 최적화 (Database Optimization)</h2></header><div class=entry-content><p>데이터베이스 최적화 (Database Optimization) 데이터베이스 최적화(Database Optimization)는 데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 다양한 기법과 프로세스를 의미한다.
데이터베이스 최적화의 목적 쿼리 응답 시간 단축 시스템 자원 사용 효율성 증대 데이터베이스의 전반적인 성능 향상 사용자 경험 개선 주요 최적화 기법 인덱스 최적화 적절한 인덱스 생성으로 데이터 검색 속도 향상 자주 사용되는 컬럼에 인덱스 적용 불필요한 인덱스 제거로 오버헤드 감소 1 2 3 4 5 -- 카디널리티가 높은 컬럼에 인덱스 생성 CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date); -- 조건절에 자주 사용되는 컬럼 조합에 대한 인덱스 CREATE INDEX idx_products_category_price ON products(category_id, price); 불필요한 인덱스 제거도 중요하다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:12:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;493 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 최적화 (Database Optimization)" href=https://buenhyden.github.io/posts/databases/more-about-databases/database-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Databases's Fundamentals</h2></header><div class=entry-content><p></p></div><footer class=entry-footer>0 min&nbsp;·&nbsp;0 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Databases's Fundamentals" href=https://buenhyden.github.io/posts/databases/fundamentals/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>트랜잭션 (Tracsactions)</h2></header><div class=entry-content><p>트랜잭션 (Tracsactions) 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
트랜잭션은 데이터베이스의 무결성을 보장하고 일관성 있는 상태를 유지하는 데 중요한 역할을 한다.
데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위를 구성하는 연산들의 집합.
이는 한 번에 모두 수행되어야 할 일련의 데이터베이스 연산들을 의미한다.
트랜잭션의 역할:
데이터 무결성 보장: 여러 작업이 하나의 단위로 처리되어 부분적인 데이터 변경을 방지합니다. 동시성 제어: 여러 사용자가 동시에 데이터에 접근할 때 데이터의 일관성을 유지합니다. 오류 복구: 트랜잭션 실행 중 오류가 발생하면 이전 상태로 롤백하여 데이터의 안정성을 보장합니다. 복잡한 비즈니스 로직 처리: 여러 단계의 작업을 하나의 논리적 단위로 처리할 수 있게 합니다. 트랜잭션의 특성 (ACID):
...</p></div><footer class=entry-footer><span title='2024-10-24 13:19:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1025 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 트랜잭션 (Tracsactions)" href=https://buenhyden.github.io/posts/databases/more-about-databases/tracsactions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RDBMS</h2></header><div class=entry-content><p>관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS) 데이터를 행과 열로 이루어진 테이블 형태로 저장하고 관리하는 시스템.
여기서 ‘관계형’이라는 말은 이 테이블들이 서로 관계를 맺을 수 있다는 의미이다.
기본 구성요소:
테이블(Table):
데이터를 저장하는 기본 단위.
예를 들어 ‘직원’ 테이블에는 각 직원의 정보가 행으로 저장되며, 이름, 나이, 부서와 같은 속성들이 열이 된다.
각 테이블은 반드시 고유한 기본 키(Primary Key)를 가져야 한다.
예를 들어 직원 테이블에서는 ‘직원번호’가 기본 키가 될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 01:55:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;454 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDBMS" href=https://buenhyden.github.io/posts/databases/rdbms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NoSQL</h2></header><div class=entry-content><p>NoSQL NoSQL(Not Only SQL)은 전통적인 관계형 데이터베이스와는 다른 접근 방식을 취하는 데이터베이스 시스템이다. NoSQL 데이터베이스는 대규모 데이터 처리, 유연한 데이터 모델, 그리고 낮은 지연 시간이 필요한 애플리케이션을 위해 최적화되어 있다.
NoSQL 데이터베이스는 빅데이터, 실시간 웹 애플리케이션, IoT 등 다양한 분야에서 활용되고 있으며, 데이터의 다양성과 규모가 증가함에 따라 그 중요성이 더욱 커지고 있다.
NoSQL 데이터베이스의 주요 특징 유연한 스키마: 구조화되지 않은 데이터를 쉽게 저장하고 관리할 수 있다. 확장성: 수평적 확장이 용이하여 대용량 데이터 처리에 적합하다. 고성능: 대규모 데이터 처리와 실시간 애플리케이션에 최적화되어 있다. 분산 컴퓨팅: 여러 노드에 데이터를 분산하여 처리 속도와 내결함성을 향상시킨다. NoSQL 데이터베이스의 주요 유형 키-값 데이터베이스: 간단한 키-값 쌍으로 데이터를 저장한다. 예: Amazon DynamoDB 문서 지향 데이터베이스: JSON이나 XML 같은 문서 형식으로 데이터를 저장한다. 예: MongoDB 컬럼 지향 데이터베이스: 데이터를 컬럼 단위로 저장하여 집계 쿼리에 효율적이다. 예: Apache Cassandra 그래프 데이터베이스: 엔티티 간의 관계를 노드와 엣지로 표현한다. 예: Neo4j NoSQL의 주요 사용 사례 대규모 데이터 처리
로그 데이터, 센서 데이터 등 대량의 데이터를 효율적으로 처리한다.
...</p></div><footer class=entry-footer><span title='2024-10-23 06:34:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;215 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NoSQL" href=https://buenhyden.github.io/posts/databases/nosql/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/databases/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>