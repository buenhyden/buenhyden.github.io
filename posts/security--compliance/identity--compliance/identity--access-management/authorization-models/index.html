<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Authorization Models | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,Authorization-Models"><meta name=description content="API 권한 부여(Authorization)는 인증(Authentication)이 완료된 후, 사용자가 어떤 리소스에 접근할 수 있는지를 결정하는 중요한 보안 메커니즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Authorization Models"><meta property="og:description" content="API 권한 부여(Authorization)는 인증(Authentication)이 완료된 후, 사용자가 어떤 리소스에 접근할 수 있는지를 결정하는 중요한 보안 메커니즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Authorization Models"><meta name=twitter:description content="API 권한 부여(Authorization)는 인증(Authentication)이 완료된 후, 사용자가 어떤 리소스에 접근할 수 있는지를 결정하는 중요한 보안 메커니즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Authorization Models","item":"https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Authorization Models</h1><div class=post-description>API 권한 부여(Authorization)는 인증(Authentication)이 완료된 후, 사용자가 어떤 리소스에 접근할 수 있는지를 결정하는 중요한 보안 메커니즘이다.</div></header><div class=post-content><h2 id=authorization-models>Authorization Models<a hidden class=anchor aria-hidden=true href=#authorization-models>#</a></h2><p>API 권한 부여(Authorization)는 인증(Authentication)이 완료된 후, 사용자가 어떤 리소스에 접근할 수 있는지를 결정하는 중요한 보안 메커니즘이다. 권한 부여는 사용자의 신원이 확인된 후(인증), 해당 사용자가 특정 API 리소스나 작업에 접근할 수 있는 권한이 있는지를 확인하는 과정이다.</p><h3 id=인증authentication과-권한-부여authorization의-차이>인증(Authentication)과 권한 부여(Authorization)의 차이<a hidden class=anchor aria-hidden=true href=#인증authentication과-권한-부여authorization의-차이>#</a></h3><p>API 보안 맥락에서 이 두 개념의 차이를 명확히 이해하는 것이 중요하다:</p><p><strong>인증(Authentication):</strong></p><ul><li>&ldquo;당신이 누구인지&rdquo; 확인하는 과정</li><li>사용자나 시스템의 신원을 검증</li><li>주로 자격 증명(사용자 이름/비밀번호, 토큰, 인증서 등)을 통해 이루어짐</li></ul><p><strong>권한 부여(Authorization):</strong></p><ul><li>&ldquo;무엇을 할 수 있는지&rdquo; 결정하는 과정</li><li>인증된 사용자의 접근 권한과 작업 권한을 정의</li><li>인증 이후에 진행되는 프로세스</li></ul><h3 id=주요-api-권한-부여-방법>주요 API 권한 부여 방법<a hidden class=anchor aria-hidden=true href=#주요-api-권한-부여-방법>#</a></h3><table><thead><tr><th>모델</th><th>설명</th><th>주요 특징</th><th>장점</th><th>단점</th><th>적용 사례</th><th>보안 수준</th></tr></thead><tbody><tr><td>ABAC (Attribute Based Access Control)</td><td>사용자, 리소스, 환경의 속성을 기반으로 접근을 제어하는 모델</td><td>• 다양한 속성 기반 결정<br>• 동적 정책 적용<br>• 상황 인식 가능</td><td>• 세밀한 접근 제어<br>• 유연한 정책 설정<br>• 상황에 따른 동적 제어</td><td>• 구현 복잡도 높음<br>• 성능 오버헤드<br>• 정책 관리 어려움</td><td>• 클라우드 서비스<br>• IoT 시스템<br>• 의료 정보 시스템</td><td>높음</td></tr><tr><td>DAC (Discretionary Access Control)</td><td>리소스 소유자가 직접 접근 권한을 제어하는 모델</td><td>• 소유자 중심 제어<br>• 권한 위임 가능<br>• 유연한 권한 관리</td><td>• 사용자 자율성 높음<br>• 구현 용이<br>• 유연한 관리</td><td>• 보안 일관성 부족<br>• 권한 남용 위험<br>• 중앙 통제 어려움</td><td>• 파일 시스템<br>• 개인용 컴퓨터<br>• 소규모 조직</td><td>낮음</td></tr><tr><td>MAC (Mandatory Access Control)</td><td>중앙에서 정의한 보안 정책에 따라 엄격히 접근을 제어하는 모델</td><td>• 중앙 집중식 제어<br>• 엄격한 보안 레벨<br>• 정책 강제 적용</td><td>• 높은 보안성<br>• 일관된 정책 적용<br>• 중앙 통제 용이</td><td>• 유연성 부족<br>• 관리 부담 큼<br>• 사용자 불편</td><td>• 군사 시스템<br>• 정부 기관<br>• 높은 보안 요구 환경</td><td>매우 높음</td></tr><tr><td>PBAC (Purpose Based Access Control)</td><td>데이터 사용 목적을 기반으로 접근을 제어하는 모델</td><td>• 목적 기반 결정<br>• 데이터 사용 추적<br>• 규정 준수 강조</td><td>• 개인정보 보호<br>• 규정 준수 용이<br>• 투명한 관리</td><td>• 목적 정의 어려움<br>• 검증 복잡<br>• 오버헤드 발생</td><td>• 의료 서비스<br>• 금융 시스템<br>• 개인정보 처리</td><td>높음</td></tr><tr><td>RBAC (Role Based Access Control)</td><td>사용자의 역할을 기반으로 접근을 제어하는 모델</td><td>• 역할 기반 권한<br>• 계층적 구조<br>• 권한 그룹화</td><td>• 관리 효율성<br>• 구현 용이<br>• 확장성 좋음</td><td>• 복잡한 정책 구현 어려움<br>• 동적 변경 제한<br>• 역할 폭발 현상</td><td>• 기업 시스템<br>• 웹 애플리케이션<br>• 대규모 조직</td><td>중간</td></tr></tbody></table><h4 id=역할-기반-접근-제어-role-based-access-control-rbac>역할 기반 접근 제어 (Role-Based Access Control, RBAC)<a hidden class=anchor aria-hidden=true href=#역할-기반-접근-제어-role-based-access-control-rbac>#</a></h4><p>사용자에게 역할을 할당하고, 각 역할에 특정 권한을 부여하는 방식이다.</p><p><strong>작동 방식:</strong></p><ol><li>사용자는 하나 이상의 역할(role)에 할당된다.</li><li>각 역할은 특정 API 리소스나 작업에 대한 권한 집합을 가진다.</li><li>사용자의 API 요청이 들어오면, 시스템은 사용자의 역할을 확인하고 해당 역할에 필요한 권한이 있는지 검증한다.</li></ol><p><strong>예시 역할:</strong></p><ul><li>관리자(Admin): 모든 리소스에 대한 전체 접근 권한</li><li>편집자(Editor): 읽기 및 쓰기 권한, 일부 삭제 권한</li><li>조회자(Viewer): 읽기 전용 권한</li></ul><p><strong>장점:</strong></p><ul><li>관리가 용이하다 - 역할 변경만으로 여러 사용자의 권한을 한 번에 수정할 수 있다.</li><li>직관적인 모델로 이해하기 쉽다.</li><li>대부분의 조직 구조에 자연스럽게 맞다.</li></ul><p><strong>단점:</strong></p><ul><li>매우 세분화된 권한 제어가 필요한 경우 관리가 복잡해질 수 있다.</li><li>특정 상황이나 조건에 따른 동적 권한 부여가 제한적이다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>기업용 애플리케이션</li><li>팀 기반 협업 도구</li><li>조직 구조가 명확한 시스템</li></ul><h4 id=속성-기반-접근-제어-attribute-based-access-control-abac>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC)<a hidden class=anchor aria-hidden=true href=#속성-기반-접근-제어-attribute-based-access-control-abac>#</a></h4><p>사용자, 리소스, 환경의 속성을 기반으로 접근 권한을 결정하는 더 유연한 모델.</p><p><strong>속성의 종류:</strong></p><ul><li>사용자 속성: 역할, 부서, 직급, 소속 등</li><li>리소스 속성: 유형, 소유자, 민감도 등급, 생성 날짜 등</li><li>환경 속성: 시간, 위치, 사용 기기, 네트워크 등</li></ul><p><strong>작동 방식:</strong></p><ol><li>정책(policy)으로 접근 규칙을 정의한다: &ldquo;부서가 X이고 직급이 Y 이상인 사용자는 민감도 등급 Z 이하의 리소스에 접근 가능&rdquo;</li><li>사용자가 요청할 때 관련된 모든 속성을 평가하여 정책 준수 여부를 확인한다.</li></ol><p><strong>장점:</strong></p><ul><li>매우 세분화된 권한 제어가 가능하다.</li><li>동적인 상황에 기반한 유연한 권한 부여가 가능하다.</li><li>복잡한 규정 준수 요구사항을 충족시킬 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>구현 및 관리가 복잡하다.</li><li>많은 속성과 정책이 있을 경우 성능에 영향을 줄 수 있다.</li><li>직관적으로 이해하기 어려울 수 있다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>의료 정보 시스템</li><li>금융 서비스 API</li><li>정부 시스템</li><li>복잡한 규정 준수가 필요한 산업</li></ul><h4 id=oauth-20-범위-scopes>OAuth 2.0 범위 (Scopes)<a hidden class=anchor aria-hidden=true href=#oauth-20-범위-scopes>#</a></h4><p>OAuth 2.0 프레임워크에서 제공하는 권한 부여 메커니즘으로, 클라이언트 애플리케이션이 사용자 리소스에 접근할 수 있는 범위를 제한한다.</p><p><strong>작동 방식:</strong></p><ol><li>클라이언트 애플리케이션이 특정 범위(scope)에 대한 접근을 요청한다.</li><li>사용자는 이러한 권한 부여에 동의한다.</li><li>서버는 요청된 범위로 제한된 액세스 토큰을 발급한다.</li><li>클라이언트는 해당 토큰으로 범위 내의 API 엔드포인트에만 접근할 수 있다.</li></ol><p><strong>예시 범위:</strong></p><ul><li><code>read:users</code>: 사용자 정보 읽기 권한</li><li><code>write:posts</code>: 게시물 작성 권한</li><li><code>delete:comments</code>: 댓글 삭제 권한</li></ul><p><strong>장점:</strong></p><ul><li>사용자가 제3자 애플리케이션에 제공할 권한을 명시적으로 제어할 수 있다.</li><li>최소 권한 원칙을 효과적으로 구현할 수 있다.</li><li>널리 채택된 표준으로 다양한 라이브러리와 도구가 존재한다.</li></ul><p><strong>단점:</strong></p><ul><li>설계와 구현이 복잡할 수 있다.</li><li>범위 정의에 신중한 계획이 필요하다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>소셜 미디어 API 통합</li><li>제3자 애플리케이션 에코시스템</li><li>사용자 데이터에 접근하는 공개 API</li></ul><h4 id=권한-기반-접근-제어-permission-based-access-control>권한 기반 접근 제어 (Permission-Based Access Control)<a hidden class=anchor aria-hidden=true href=#권한-기반-접근-제어-permission-based-access-control>#</a></h4><p>세분화된 개별 권한을 직접 사용자나 그룹에 할당하는 방식이다. RBAC의 변형으로 볼 수 있다.</p><p><strong>작동 방식:</strong></p><ol><li>시스템에서 가능한 모든 작업에 대해 개별 권한을 정의한다.</li><li>사용자나 그룹에 직접 이러한 권한을 할당한다.</li><li>API 요청 시 사용자가 필요한 특정 권한을 가지고 있는지 확인한다.</li></ol><p><strong>장점:</strong></p><ul><li>매우 세분화된 제어가 가능하다.</li><li>역할보다 더 유연한 권한 할당이 가능하다.</li><li>최소 권한 원칙을 정확하게 구현할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>권한 수가 많아지면 관리가 복잡해진다.</li><li>사용자 수가 많은 시스템에서는 유지보수가 어려울 수 있다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>복잡한 워크플로우가 있는 시스템</li><li>세분화된 리소스 접근 제어가 필요한 애플리케이션</li><li>다양한 사용자 유형이 있는 복잡한 시스템</li></ul><h4 id=jwt-클레임-기반-권한-부여-jwt-claims-based-authorization>JWT 클레임 기반 권한 부여 (JWT Claims-Based Authorization)<a hidden class=anchor aria-hidden=true href=#jwt-클레임-기반-권한-부여-jwt-claims-based-authorization>#</a></h4><p>JWT(JSON Web Token)의 클레임을 활용하여 권한 정보를 토큰에 직접 포함시키는 방식.</p><p><strong>작동 방식:</strong></p><ol><li>인증 서버는 사용자 권한 정보(역할, 권한 등)를 JWT 클레임에 포함시켜 토큰 발급</li><li>클라이언트는 API 요청 시 이 토큰을 전송</li><li>API 서버는 토큰을 검증하고 포함된 클레임을 확인하여 접근 권한 결정</li></ol><p><strong>예시 JWT 클레임:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;sub&#34;</span><span class=p>:</span> <span class=s2>&#34;1234567890&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;John Doe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;roles&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;editor&#34;</span><span class=p>,</span> <span class=s2>&#34;moderator&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;permissions&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;read:users&#34;</span><span class=p>,</span> <span class=s2>&#34;write:posts&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;exp&#34;</span><span class=p>:</span> <span class=mi>1516239022</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점:</strong></p><ul><li>상태 비저장(stateless) 방식으로 확장성이 높다.</li><li>권한 정보가 토큰에 포함되어 있어 추가 조회가 필요 없다.</li><li>마이크로서비스 아키텍처에 적합하다.</li></ul><p><strong>단점:</strong></p><ul><li>토큰이 발급된 후에는 권한을 즉시 취소하기 어렵다.</li><li>권한 정보가 많을 경우 토큰 크기가 커질 수 있다.</li><li>토큰 탈취 시 포함된 모든 권한이 노출된다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>마이크로서비스 아키텍처</li><li>분산 시스템</li><li>단일 페이지 애플리케이션(SPA)</li><li>모바일 애플리케이션</li></ul><h4 id=정책-기반-접근-제어-policy-based-access-control>정책 기반 접근 제어 (Policy-Based Access Control)<a hidden class=anchor aria-hidden=true href=#정책-기반-접근-제어-policy-based-access-control>#</a></h4><p>중앙 집중식 정책 엔진을 사용하여 동적인 권한 부여 결정을 내리는 방식이다. 종종 ABAC와 함께 사용된다.</p><p><strong>작동 방식:</strong></p><ol><li>접근 정책을 특정 언어나 형식으로 정의한다(예: XACML, OPA Rego 등).</li><li>중앙화된 정책 의사 결정 지점(Policy Decision Point, PDP)이 요청을 평가한다.</li><li>정책 집행 지점(Policy Enforcement Point, PEP)이 결정을 적용한다.</li></ol><p><strong>장점:</strong></p><ul><li>접근 제어 로직을 애플리케이션 코드에서 분리할 수 있다.</li><li>정책을 중앙에서 관리하고 동적으로 업데이트할 수 있다.</li><li>복잡한 조건부 로직과 비즈니스 규칙을 표현할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>구현이 복잡하고 추가 인프라가 필요하다.</li><li>성능 오버헤드가 발생할 수 있다.</li><li>정책 작성과 디버깅이 어려울 수 있다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>대규모 엔터프라이즈 시스템</li><li>복잡한 규정 준수 요구사항이 있는 산업</li><li>자주 변경되는 접근 정책이 필요한 환경</li></ul><h4 id=맥락-기반-접근-제어-contextual-access-control>맥락 기반 접근 제어 (Contextual Access Control)<a hidden class=anchor aria-hidden=true href=#맥락-기반-접근-제어-contextual-access-control>#</a></h4><p>사용자의 행동 패턴, 위치, 시간 등 맥락 정보를 기반으로 접근 권한을 동적으로 결정하는 방식이다.</p><p><strong>고려되는 맥락 요소:</strong></p><ul><li>접근 시간과 날짜</li><li>지리적 위치</li><li>IP 주소 및 네트워크 정보</li><li>사용 기기 및 브라우저</li><li>이전 사용 패턴</li></ul><p><strong>작동 방식:</strong></p><ol><li>사용자 인증 시 다양한 맥락 정보를 수집한다.</li><li>이 정보를 정상적인 사용 패턴과 비교한다.</li><li>위험도를 평가하여 접근 수준을 동적으로 조정한다.</li></ol><p><strong>장점:</strong></p><ul><li>보안을 강화하면서도 정상적인 사용은 방해하지 않는다.</li><li>위험 기반 접근 방식으로 이상 행동을 탐지할 수 있다.</li><li>적응형 보안 모델을 구현할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>구현이 복잡하고 고급 분석 능력이 필요하다.</li><li>오탐지가 발생할 수 있어 사용자 경험에 영향을 줄 수 있다.</li><li>개인정보 보호 문제가 발생할 수 있다.</li></ul><p><strong>적합한 사용 사례:</strong></p><ul><li>금융 API</li><li>의료 정보 시스템</li><li>고급 보안이 필요한 기업 애플리케이션</li><li>민감한 데이터를 처리하는 서비스</li></ul><h3 id=api-권한-부여-구현-패턴>API 권한 부여 구현 패턴<a hidden class=anchor aria-hidden=true href=#api-권한-부여-구현-패턴>#</a></h3><h4 id=api-게이트웨이를-통한-중앙-집중식-권한-부여>API 게이트웨이를 통한 중앙 집중식 권한 부여<a hidden class=anchor aria-hidden=true href=#api-게이트웨이를-통한-중앙-집중식-권한-부여>#</a></h4><p><strong>작동 방식:</strong></p><ol><li>모든 API 요청이 게이트웨이를 통과한다.</li><li>게이트웨이는 인증 및 권한 부여 검사를 수행한다.</li><li>권한이 있는 요청만 해당 백엔드 서비스로 전달된다.</li></ol><p><strong>장점:</strong></p><ul><li>권한 부여 로직을 중앙화하여 일관성을 보장한다.</li><li>백엔드 서비스는 권한 부여에 대해 걱정할 필요가 없다.</li><li>정책 변경을 한 곳에서 적용할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>단일 장애 지점이 될 수 있다.</li><li>성능 병목 현상이 발생할 수 있다.</li><li>세분화된 권한 부여를 위해 백엔드 컨텍스트가 필요할 수 있다.</li></ul><h4 id=마이크로서비스-아키텍처의-분산-권한-부여>마이크로서비스 아키텍처의 분산 권한 부여<a hidden class=anchor aria-hidden=true href=#마이크로서비스-아키텍처의-분산-권한-부여>#</a></h4><p><strong>작동 방식:</strong></p><ol><li>각 마이크로서비스가 자체 권한 부여 로직을 구현한다.</li><li>서비스 간 통신 시 권한 정보가 전파된다(토큰, 컨텍스트 등).</li><li>각 서비스는 자신의 도메인 내에서 접근 결정을 내린다.</li></ol><p><strong>장점:</strong></p><ul><li>서비스의 자율성과 독립성을 유지한다.</li><li>도메인별로 특화된 권한 부여 로직을 구현할 수 있다.</li><li>단일 장애 지점을 방지한다.</li></ul><p><strong>단점:</strong></p><ul><li>일관된 정책 적용이 어려울 수 있다.</li><li>서비스 간 권한 전파 메커니즘이 필요하다.</li><li>중복 코드와 로직이 발생할 수 있다.</li></ul><h4 id=외부-권한-부여-서비스-external-authorization-service>외부 권한 부여 서비스 (External Authorization Service)<a hidden class=anchor aria-hidden=true href=#외부-권한-부여-서비스-external-authorization-service>#</a></h4><p><strong>작동 방식:</strong></p><ol><li>전용 권한 부여 서비스(예: OPA, ORY Keto)를 구축한다.</li><li>모든 서비스가 접근 결정을 위해 이 서비스에 쿼리한다.</li><li>권한 부여 서비스는 중앙 정책 저장소를 유지하고 결정을 내린다.</li></ol><p><strong>장점:</strong></p><ul><li>권한 부여 로직을 완전히 분리한다.</li><li>일관된 정책 적용을 보장한다.</li><li>전문화된 서비스로 복잡한 권한 부여 로직을 처리할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>추가적인 네트워크 호출로 인한 지연이 발생한다.</li><li>권한 부여 서비스에 대한 의존성이 생긴다.</li><li>구현과 유지보수가 복잡할 수 있다.</li></ul><h3 id=api-권한-부여-모범-사례>API 권한 부여 모범 사례<a hidden class=anchor aria-hidden=true href=#api-권한-부여-모범-사례>#</a></h3><ol><li><p>최소 권한 원칙 적용</p><ul><li>사용자와 애플리케이션에 필요한 최소한의 권한만 부여한다.</li><li>기본적으로 모든 접근을 거부하고, 명시적으로 허용된 접근만 허용한다.</li><li>권한을 정기적으로 검토하고 불필요한 권한을 제거한다.</li></ul></li><li><p>권한 부여 로직의 세분화</p><ul><li>리소스 수준에서 권한을 제어한다(전체 API가 아닌 특정 엔드포인트나 데이터).</li><li>작업 유형(읽기, 쓰기, 삭제 등)에 따라 권한을 분리한다.</li><li>필요한 경우 데이터 필드 수준의 접근 제어를 구현한다.</li></ul></li><li><p>권한 부여 결정 캐싱</p><ul><li>권한 부여 결정을 적절히 캐싱하여 성능을 향상시킨다.</li><li>캐시 무효화 전략을 구현하여 변경된 권한이 적시에 적용되도록 한다.</li><li>분산 시스템에서는 일관된 캐싱 메커니즘을 사용한다.</li></ul></li><li><p>보안 로깅 및 감사</p><ul><li>모든 권한 부여 결정과 접근 시도를 로깅한다.</li><li>감사 추적을 위해 누가, 무엇을, 언제, 어디서 접근했는지 기록한다.</li><li>권한 변경 이력을 추적하고 변경 사유를 문서화한다.</li></ul></li><li><p>권한 상승 경로 제공</p><ul><li>특수한 상황을 위한 임시 권한 상승 메커니즘을 구현한다.</li><li>권한 상승 요청에 대한 승인 프로세스를 구축한다.</li><li>상승된 권한의 사용을 면밀히 모니터링하고 감사한다.</li></ul></li></ol><h3 id=산업별-api-권한-부여-요구사항>산업별 API 권한 부여 요구사항<a hidden class=anchor aria-hidden=true href=#산업별-api-권한-부여-요구사항>#</a></h3><h4 id=금융-서비스>금융 서비스<a hidden class=anchor aria-hidden=true href=#금융-서비스>#</a></h4><ul><li>FAPI(Financial-grade API) 표준 준수</li><li>트랜잭션 수준의 권한 부여</li><li>이중 인증(MFA)과 결합된 권한 부여</li><li>규제 요구사항에 따른 세분화된 접근 제어</li></ul><h4 id=의료>의료<a hidden class=anchor aria-hidden=true href=#의료>#</a></h4><ul><li>HIPAA 규정 준수를 위한 엄격한 접근 제어</li><li>환자 동의 기반 권한 부여</li><li>비상 접근 프로토콜(Break-glass 프로토콜)</li><li>역할 기반 접근과 맥락 기반 접근의 조합</li></ul><h4 id=소매-및-전자상거래>소매 및 전자상거래<a hidden class=anchor aria-hidden=true href=#소매-및-전자상거래>#</a></h4><ul><li>고객 데이터에 대한 개인정보 보호 중심 접근 제어</li><li>판매자와 구매자에 대한 차별화된 권한 모델</li><li>결제 처리에 대한 엄격한 권한 제어</li><li>프로모션 및 할인 적용에 대한 특별 권한</li></ul><h4 id=정부-시스템>정부 시스템<a hidden class=anchor aria-hidden=true href=#정부-시스템>#</a></h4><ul><li>다단계 승인 워크플로우</li><li>법적 권한에 기반한 접근 제어</li><li>엄격한 데이터 분류와 접근 제어</li><li>상세한 감사 추적 요구사항</li></ul><h3 id=권한-부여-표준-및-프레임워크>권한 부여 표준 및 프레임워크<a hidden class=anchor aria-hidden=true href=#권한-부여-표준-및-프레임워크>#</a></h3><h4 id=xacml-extensible-access-control-markup-language>XACML (eXtensible Access Control Markup Language)<a hidden class=anchor aria-hidden=true href=#xacml-extensible-access-control-markup-language>#</a></h4><p>XML 기반의 정책 언어와 처리 모델을 제공하는 표준으로, 속성 기반 접근 제어(ABAC)를 구현하는 데 사용된다.</p><p><strong>구성 요소:</strong></p><ul><li>PAP(Policy Administration Point): 정책 관리</li><li>PDP(Policy Decision Point): 정책 결정</li><li>PEP(Policy Enforcement Point): 정책 집행</li><li>PIP(Policy Information Point): 속성 정보 제공</li></ul><p><strong>장점:</strong></p><ul><li>세분화된 정책 표현이 가능하다.</li><li>다양한 환경과 조직 간에 정책을 공유할 수 있다.</li><li>많은 기업용 솔루션에서 지원한다.</li></ul><p><strong>단점:</strong></p><ul><li>복잡하고 구현하기 어렵다.</li><li>성능 오버헤드가 발생할 수 있다.</li><li>XML 구문이 번거롭고 읽기 어려울 수 있다.</li></ul><h4 id=opa-open-policy-agent>OPA (Open Policy Agent)<a hidden class=anchor aria-hidden=true href=#opa-open-policy-agent>#</a></h4><p>클라우드 네이티브 애플리케이션을 위한 오픈소스 정책 엔진으로, Rego라는 선언적 정책 언어를 사용한다.</p><p><strong>특징:</strong></p><ul><li>선언적 정책 언어(Rego)</li><li>JSON/YAML 데이터 모델</li><li>컨테이너와 마이크로서비스 아키텍처에 최적화</li><li>Kubernetes 통합</li></ul><p><strong>장점:</strong></p><ul><li>클라우드 네이티브 환경에 적합하다.</li><li>경량화되고 높은 성능을 제공한다.</li><li>다양한 시스템과 통합이 용이하다.</li></ul><p><strong>단점:</strong></p><ul><li>학습 곡선이 가파를 수 있다.</li><li>복잡한 규칙에 대한 디버깅이 어려울 수 있다.</li></ul><h4 id=oauth-20--uma-user-managed-access>OAuth 2.0 + UMA (User-Managed Access)<a hidden class=anchor aria-hidden=true href=#oauth-20--uma-user-managed-access>#</a></h4><p>OAuth 2.0의 확장으로, 사용자가 여러 애플리케이션과 서비스에 걸쳐 자신의 리소스에 대한 접근을 관리할 수 있게 한다.</p><p><strong>특징:</strong></p><ul><li>사용자 중심의 권한 관리</li><li>자원 세트(Resource Sets)와 정책</li><li>클레임 토큰 기반 권한 부여</li><li>권한 부여 서버(Authorization Server)와 리소스 서버(Resource Server) 분리</li></ul><p><strong>장점:</strong></p><ul><li>사용자가 자신의 데이터 접근을 직접 제어할 수 있다.</li><li>다양한 애플리케이션과 서비스에 일관된 권한 관리를 제공한다.</li><li>OAuth 2.0 기반 시스템과 호환된다.</li></ul><p><strong>단점:</strong></p><ul><li>구현이 복잡하다.</li><li>아직 널리 채택되지 않았다.</li><li>최종 사용자 인터페이스가 복잡할 수 있다.</li></ul><h3 id=권한-부여의-미래-동향>권한 부여의 미래 동향<a hidden class=anchor aria-hidden=true href=#권한-부여의-미래-동향>#</a></h3><h4 id=제로-트러스트-권한-부여-zero-trust-authorization>제로 트러스트 권한 부여 (Zero Trust Authorization)<a hidden class=anchor aria-hidden=true href=#제로-트러스트-권한-부여-zero-trust-authorization>#</a></h4><p>네트워크 위치나 사용자 신원만으로 접근 권한을 부여하지 않고, 매 요청마다 다양한 요소를 고려하여 지속적으로 접근 권한을 검증하는 모델이다.</p><p><strong>핵심 원칙:</strong></p><ul><li>&ldquo;항상 검증, 절대 신뢰하지 않음&rdquo;</li><li>모든 요청을 잠재적 위협으로 간주</li><li>최소 권한 접근</li><li>지속적인 인증과 권한 부여</li><li>종합적인 보안 모니터링</li></ul><p><strong>발전 방향:</strong></p><ul><li>실시간 위험 평가 기반 접근 제어</li><li>행동 분석과 머신러닝을 통한 이상 탐지</li><li>세션 기반이 아닌 요청 기반의 권한 부여</li></ul><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DAC</h2></header><div class=entry-content><p>재량적 접근 제어(Discretionary Access Control, DAC) 재량적 접근 제어는 리소스의 소유자가 해당 리소스에 대한다른 사용자들의 접근 권한을 직접 제어할 수 있는 접근 제어 방식.
이는 우리가 일상적으로 사용하는 컴퓨터의 파일 시스템과 매우 유사한 방식으로 작동한다.
예를 들어, 여러분이 문서를 만들면 해당 문서의 소유자가 되어 다른 사람들에게 읽기, 쓰기, 또는 실행 권한을 부여할 수 있다.
개인용 컴퓨터나 작은 규모의 조직에서 사용되며, 높은 수준의 보안이 요구되는 환경에서는 다른 접근 제어 방식과 함께 사용되는 것이 일반적이다.
예를 들어, 기업 환경에서는 DAC와 함께 역할 기반 접근 제어(RBAC)나 강제적 접근 제어(MAC)를 함께 사용하여 보안을 강화하는 경우가 많다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DAC" href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/dac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MAC</h2></header><div class=entry-content><p>강제적 접근 제어(Mandatory Access Control, MAC) 시스템 전체에 걸쳐 중앙에서 정의된 보안 정책에 따라 접근 권한을 강제로 적용하는 접근 제어 방식.
이는 개별 사용자나 소유자가 임의로 접근 권한을 변경할 수 없다는 점에서 DAC와 큰 차이가 있다.
군사, 정부 기관, 금융 기관 등 높은 수준의 보안이 요구되는 환경에서 사용된다.
일반적인 기업이나 개인용 시스템에서는 구현의 복잡성과 관리 부담 때문에 다른 접근 제어 방식을 선호하는 경우가 많다.
작동원리:
두 가지 중요한 보안 원칙을 적용한다:
...</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MAC" href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/mac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PBAC</h2></header><div class=entry-content><p>정책 기반 접근 제어(Policy-Based Access Control, PBAC) 중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.
각 정책은 “누가”, “무엇을”, “어떤 조건에서” 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.
현대적인 클라우드 환경이나 마이크로서비스 아키텍처에서 특히 유용하다.
AWS IAM, Azure RBAC 등의 클라우드 서비스들이 PBAC를 구현한 대표적인 예시.
작동 방식:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Policy { constructor(name, conditions, effect) { this.name = name; this.conditions = conditions; this.effect = effect; // 'allow' 또는 'deny' } evaluate(context) { try { // 모든 조건을 평가 return this.conditions.every(condition => condition(context)); } catch (error) { console.error(`Policy evaluation error: ${error.message}`); return false; } } } class PolicyEngine { constructor() { this.policies = new Map(); } addPolicy(policy) { this.policies.set(policy.name, policy); } evaluateAccess(context) { let finalDecision = false; for (const policy of this.policies.values()) { const matches = policy.evaluate(context); if (matches) { finalDecision = policy.effect === 'allow'; // 명시적인 거부 정책이 있으면 즉시 거부 if (policy.effect === 'deny') { return false; } } } return finalDecision; } } // 정책 조건 예시들 const conditions = { isWorkingHours: (context) => { const hour = context.time.getHours(); return hour >= 9 && hour &lt; 18; }, isInternalNetwork: (context) => { return context.ipAddress.startsWith('192.168.'); }, hasRole: (role) => (context) => { return context.user.roles.includes(role); }, hasPermission: (permission) => (context) => { return context.user.permissions.includes(permission); } }; // 정책 엔진 사용 예시 const policyEngine = new PolicyEngine(); // HR 문서 접근 정책 const hrDocumentPolicy = new Policy( 'HR_Document_Access', [ conditions.isWorkingHours, conditions.isInternalNetwork, conditions.hasRole('HR'), conditions.hasPermission('read_hr_documents') ], 'allow' ); // 주말 접근 제한 정책 const weekendRestrictionPolicy = new Policy( 'Weekend_Restriction', [ (context) => { const day = context.time.getDay(); return day === 0 || day === 6; } ], 'deny' ); policyEngine.addPolicy(hrDocumentPolicy); policyEngine.addPolicy(weekendRestrictionPolicy); // 접근 시도 예시 const accessContext = { user: { name: 'Alice', roles: ['HR'], permissions: ['read_hr_documents'] }, time: new Date('2024-12-17T14:00:00'), // 평일 오후 2시 ipAddress: '192.168.1.100', resource: 'employee_records' }; const hasAccess = policyEngine.evaluateAccess(accessContext); console.log(`Access granted: ${hasAccess}`); 주요 특징 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 중앙 집중식 관리: 정책을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 컨텍스트 인식: 사용자 신원, 리소스 특성, 시간, 위치 등 다양한 컨텍스트 정보를 고려한다. 동적 평가: 접근 요청 시 실시간으로 정책을 평가하여 결정을 내린다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 정책 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 일관성 유지: 중앙에서 관리되는 정책으로 전체 시스템의 일관성을 보장한다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AdvancedPolicyEngine { constructor() { this.policies = new Map(); this.auditLog = []; } addPolicy(policy) { this.policies.set(policy.name, policy); } async evaluateAccess(context) { const decisions = []; const startTime = Date.now(); try { for (const policy of this.policies.values()) { const decision = { policyName: policy.name, effect: policy.effect, matches: await policy.evaluate(context), timestamp: new Date() }; decisions.push(decision); if (decision.matches && policy.effect === 'deny') { this.logDecision(context, decisions, 'denied'); return false; } } const finalDecision = decisions.some(d => d.matches && d.effect === 'allow'); this.logDecision(context, decisions, finalDecision ? 'allowed' : 'denied'); return finalDecision; } catch (error) { this.logError(context, error); throw error; } } logDecision(context, decisions, result) { const logEntry = { timestamp: new Date(), user: context.user.name, resource: context.resource, action: context.action, decisions: decisions, finalResult: result, contextSnapshot: { …context } }; this.auditLog.push(logEntry); } logError(context, error) { const errorEntry = { timestamp: new Date(), type: 'error', user: context.user.name, error: error.message, stack: error.stack, context: { …context } }; this.auditLog.push(errorEntry); } getAuditLog(filters = {}) { return this.auditLog.filter(entry => { return Object.entries(filters).every(([key, value]) => entry[key] === value ); }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PBAC" href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/pbac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ABAC</h2></header><div class=entry-content><p>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC) ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.
이를 통해 매우 세분화되고 유연한 접근 제어가 가능하다.
의료, 금융, 정부 등 복잡한 보안 요구사항을 가진 분야에서 유용하게 활용될 수 있다.
주요 특징 유연성: 다양한 속성 조합을 통해 복잡한 접근 제어 정책을 수용할 수 있다. 세분화: 사용자 역할뿐만 아니라 다양한 속성을 고려하여 더 정교한 접근 제어가 가능하다. 동적 정책: 실시간 속성 변화에 따라 접근 제어 결정을 동적으로 수행할 수 있다. 확장성: 새로운 속성을 쉽게 추가하여 정책을 확장할 수 있다. ABAC의 주요 구성 요소 속성: 주체, 객체, 환경 조건에 대한 특성을 정의한다. 주체(Subject) 속성 사용자 ID, 이름, 직급, 부서, 보안 등급 근속 연수, 자격증, 교육 이수 여부 소속 조직, 프로젝트 참여 이력 객체(Object/Resource) 속성 데이터 분류, 보안 레벨 소유자, 작성일, 만료일 프로젝트 코드, 부서 코드 데이터 타입, 크기, 형식 행동(Action) 속성 읽기, 쓰기, 삭제, 수정 승인, 거부, 이관 다운로드, 공유, 인쇄 환경(Environment) 속성 접근 시간, 위치 네트워크 종류(내부/외부) 디바이스 종류, 보안 상태 현재 위험 수준 정책 모델: 속성들의 조합으로 접근 제어 규칙을 정의한다. 아키텍처 모델: ABAC 시스템의 구현 방식을 정의한다. ABAC의 장점 높은 유연성과 세분화된 접근 제어 가능 동적이고 컨텍스트 인식적인 정책 적용 가능 새로운 사용자나 리소스에 대해 개별 권한 설정 없이 속성만으로 접근 제어 가능 ABAC의 단점 구현 및 관리의 복잡성 성능 영향: 많은 속성을 평가해야 하므로 처리 시간이 길어질 수 있음 정책 설계의 어려움: 복잡한 속성 조합으로 인한 예기치 않은 결과 발생 가능성 모범 사례 정책 설계
...</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ABAC" href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/abac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RBAC</h2></header><div class=entry-content><p>규칙 기반 접근 제어(Rule-Based Access Control, RBAC) RBAC는 “만약 ~라면 ~할 수 있다"와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다.
각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.
클라우드 환경, 마이크로서비스 아키텍처, IoT 시스템 등 동적이고 복잡한 환경에서 특히 유용하며, 보안 요구사항이 높고 빠르게 변화하는 조직에 적합하다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Rule { constructor(condition, consequence) { // 규칙의 조건부(if)와 결과부(then)를 정의합니다 this.condition = condition; this.consequence = consequence; } evaluate(context) { // 주어진 컨텍스트에 대해 규칙을 평가합니다 if (this.condition(context)) { return this.consequence; } return null; } } class RuleEngine { constructor() { this.rules = []; } addRule(rule) { // 새로운 규칙을 규칙 엔진에 추가합니다 this.rules.push(rule); } evaluateAccess(context) { // 모든 규칙을 순차적으로 평가합니다 for (const rule of this.rules) { const result = rule.evaluate(context); if (result !== null) { return result; } } // 기본적으로는 접근을 거부합니다 return false; } } 주요 특징 규칙 기반 결정: 사용자의 속성, 리소스의 특성, 환경 조건 등을 고려한 규칙을 설정하여 접근 권한을 결정한다. 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 동적 평가: 접근 요청 시 실시간으로 규칙을 평가하여 결정을 내린다. 중앙 집중식 관리: 규칙을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 규칙 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 투명성: 규칙이 명시적으로 정의되어 있어 접근 제어 결정의 이유를 쉽게 이해할 수 있다. 단점 복잡성: 규칙이 많아지면 관리가 복잡해질 수 있다. 성능 영향: 많은 규칙을 평가해야 할 경우 처리 시간이 길어질 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RBAC" href=https://buenhyden.github.io/posts/security--compliance/identity--compliance/identity--access-management/authorization-models/rbac/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>