<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rate Limiting Pattern | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Software-Architecture-Patterns,Rate-Limiting-Pattern"><meta name=description content="Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Rate Limiting Pattern"><meta property="og:description" content="Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-27T11:41:00+00:00"><meta property="article:modified_time" content="2024-09-27T11:41:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Software-Architecture-Patterns"><meta property="article:tag" content="Rate-Limiting-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Rate Limiting Pattern"><meta name=twitter:description content="Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Architecture and System Design","item":"https://buenhyden.github.io/posts/architecture-and-system-design/"},{"@type":"ListItem","position":3,"name":"Architectue Patterns","item":"https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/"},{"@type":"ListItem","position":4,"name":"Rate Limiting Pattern","item":"https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rate Limiting Pattern","name":"Rate Limiting Pattern","description":"Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.","keywords":["System-and-Software-Architecture","Software-Architecture-Patterns","Rate-Limiting-Pattern"],"articleBody":"Rate Limiting Pattern “Rate Limiting Pattern\"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.\n이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.\nRate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.\n주로 다음 목적을 위해 사용된다:\n서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:\n사용자당 초당 10회 API 호출 제한. IP 주소당 일일 100회 로그인 시도 허용. 이 패턴은 시스템 안정성과 사용자 경험 사이의 균형을 유지하는 데 필수적이다.\n최신 클라우드 네이티브 아키텍처에서는 API 게이트웨이(예: Kong, Spring Cloud Gateway)에 기본 통합되어 점진적으로 확장 가능한 설계가 일반화되고 있다.\n핵심 구성 요소 식별자(Identifier)\n사용자 ID, IP 주소, API 키 등 요청자를 구분하는 기준. 유연한 정책 지원을 위해 다중 계층 식별 가능(예: 사용자 + 디바이스). 제한 규칙(Limit Rules)\n시간 창(Window): 1초, 1분, 1일 등 제한 기간. 허용량: 시간 창 내 최대 요청 수(예: 분당 100회). 계층화: 서비스 등급에 따른 차등 제한(무료 vs 유료). 알고리즘 유형\n고정 윈도우(Fixed Window): 일정한 시간 간격(예: 1분)으로 요청 수를 카운트하여, 해당 기간 내에 허용된 요청 수를 초과하면 추가 요청을 차단한다. 슬라이딩 윈도우(Sliding Window): 고정 윈도우의 단점을 보완하기 위해, 현재 시점을 기준으로 과거 일정 기간 동안의 요청 수를 카운트하여 제한한다. 토큰 버킷(Token Bucket): 버킷에 일정량의 토큰을 저장하고, 각 요청 시 토큰을 소모한다. 버킷은 일정 속도로 토큰을 채우며, 토큰이 부족하면 요청을 제한한다. 누출 버킷(Leaky Bucket): 버킷에 요청을 큐 형태로 저장하고, 일정한 속도로 버킷에서 요청을 처리한다. 버킷이 가득 차면 추가 요청을 버리거나 지연시킨다. 분산 시스템 구현 전략 저장소 선택\n인메모리 캐시(Redis): INCR 및 EXPIRE 명령어로 초고속 처리. 1 2 3 4 # Redis 예시: 사용자별 분당 100회 제한 EXISTS user:123 INCR user:123 EXPIRE user:123 60 동기화 방식: 중앙 집중식: 모든 노드가 공유 저장소 사용 → 정확도 높으나 병목 발생 가능. 분산 동기화: 각 노드가 로컬 카운터 유지 후 주기적 동기화 → 성능 우선. 오류 처리 전략\n429 Too Many Requests: HTTP 상태 코드로 제한 사실 통지. 재시도 지시: Retry-After 헤더를 활용한 재시도 시간 안내. 계층적 제한: 글로벌 제한 + 특정 엔드포인트별 추가 제한 조합. 실제 적용 사례 클라우드플레어의 로그인 보호\n1 2 3 1. **규칙**: IP당 5분 동안 10회 로그인 시도 허용. 2. **조치**: 초과 시 30분 차단 + CAPTCHA 요청. 3. **효과**: 크리덴셜 스터핑 공격 90% 감소. 마이크로서비스 간 호출 제어\n문제 상황: 서비스 A가 서비스 B를 과도하게 호출해 장애 발생. 해결책: 서비스 A에 분당 500회 호출 제한 장치 추가. 초과 요청은 Circuit Breaker 패턴과 연동해 폴백 처리. 설계 시 고려사항 성능 vs 정확성 트레이드오프: 분산 카운터는 AP(가용성-분할 허용) 시스템 특성상 일시적 불일치 가능. 장기적 추적 필요성: 24시간 이상의 제한 창은 영구 저장소와 캐시 조합 필요. 규칙 관리 인터페이스: 동적 설정 변경을 위한 Admin API 제공. 구현 시 고려사항 제한 범위 결정: IP 주소, 사용자 ID, API 키 등 어떤 기준으로 요청을 제한할지 결정해야 한다. 시간 창 설정: 요청을 카운트할 시간 범위를 설정해야 한다. 예외 처리: 중요한 서비스나 사용자에 대해 예외를 설정할지 여부를 결정해야 한다. 분산 환경 고려: 여러 서버나 인스턴스에서 일관된 Rate Limiting을 적용하기 위한 메커니즘이 필요하다. 장점: 참고 및 출처 ","wordCount":"509","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-27T11:41:00Z","dateModified":"2024-09-27T11:41:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/architecture-and-system-design/>Architecture and System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/architecture-and-system-design/architectue-patterns/>Architectue Patterns</a></div><h1 class="post-title entry-hint-parent">Rate Limiting Pattern</h1><div class=post-description>Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.</div><div class=post-meta><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Architecture%20and%20System%20Design/Architectue%20Patterns/Performance%20and%20Rate%20Limiting/Rate-Limiting-Pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#rate-limiting-pattern>Rate Limiting Pattern</a><ul><li><a href=#핵심-구성-요소>핵심 구성 요소</a></li><li><a href=#분산-시스템-구현-전략>분산 시스템 구현 전략</a></li><li><a href=#실제-적용-사례>실제 적용 사례</a></li><li><a href=#설계-시-고려사항>설계 시 고려사항</a></li><li><a href=#구현-시-고려사항>구현 시 고려사항</a></li></ul></li><li><a href=#장점><strong>장점:</strong></a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=rate-limiting-pattern>Rate Limiting Pattern<a hidden class=anchor aria-hidden=true href=#rate-limiting-pattern>#</a></h2><p>&ldquo;Rate Limiting Pattern"은 소프트웨어 아키텍처에서 <strong>서비스의 과도한 사용을 방지</strong>하고 자원을 공정하게 분배하기 위한 핵심 전략이다.<br>이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.</p><p><strong>Rate Limiting</strong>은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.<br>주로 다음 목적을 위해 사용된다:</p><ul><li><strong>서비스 장애 예방</strong>: DDoS 공격, API 오용, 리소스 고갈 방지.</li><li><strong>비용 관리</strong>: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지.</li><li><strong>공정한 자원 분배</strong>: 특정 사용자가 시스템을 독점하지 않도록 제어.</li></ul><p>예시:</p><ul><li>사용자당 초당 10회 API 호출 제한.</li><li>IP 주소당 일일 100회 로그인 시도 허용.</li></ul><p>이 패턴은 <strong>시스템 안정성</strong>과 <strong>사용자 경험</strong> 사이의 균형을 유지하는 데 필수적이다.<br>최신 클라우드 네이티브 아키텍처에서는 API 게이트웨이(예: Kong, Spring Cloud Gateway)에 기본 통합되어 점진적으로 확장 가능한 설계가 일반화되고 있다.</p><h3 id=핵심-구성-요소>핵심 구성 요소<a hidden class=anchor aria-hidden=true href=#핵심-구성-요소>#</a></h3><ol><li><p>식별자(Identifier)</p><ul><li><strong>사용자 ID</strong>, <strong>IP 주소</strong>, <strong>API 키</strong> 등 요청자를 구분하는 기준.</li><li>유연한 정책 지원을 위해 다중 계층 식별 가능(예: 사용자 + 디바이스).</li></ul></li><li><p>제한 규칙(Limit Rules)</p><ul><li><strong>시간 창(Window)</strong>: 1초, 1분, 1일 등 제한 기간.</li><li><strong>허용량</strong>: 시간 창 내 최대 요청 수(예: 분당 100회).</li><li><strong>계층화</strong>: 서비스 등급에 따른 차등 제한(무료 vs 유료).</li></ul></li><li><p>알고리즘 유형</p><ul><li><strong>고정 윈도우(Fixed Window):</strong><ul><li>일정한 시간 간격(예: 1분)으로 요청 수를 카운트하여, 해당 기간 내에 허용된 요청 수를 초과하면 추가 요청을 차단한다.</li></ul></li><li><strong>슬라이딩 윈도우(Sliding Window):</strong><ul><li>고정 윈도우의 단점을 보완하기 위해, 현재 시점을 기준으로 과거 일정 기간 동안의 요청 수를 카운트하여 제한한다.</li></ul></li><li><strong>토큰 버킷(Token Bucket):</strong><ul><li>버킷에 일정량의 토큰을 저장하고, 각 요청 시 토큰을 소모한다. 버킷은 일정 속도로 토큰을 채우며, 토큰이 부족하면 요청을 제한한다.</li></ul></li><li><strong>누출 버킷(Leaky Bucket):</strong><ul><li>버킷에 요청을 큐 형태로 저장하고, 일정한 속도로 버킷에서 요청을 처리한다. 버킷이 가득 차면 추가 요청을 버리거나 지연시킨다.</li></ul></li></ul></li></ol><h3 id=분산-시스템-구현-전략>분산 시스템 구현 전략<a hidden class=anchor aria-hidden=true href=#분산-시스템-구현-전략>#</a></h3><ol><li><p>저장소 선택</p><ul><li><strong>인메모리 캐시(Redis)</strong>: <code>INCR</code> 및 <code>EXPIRE</code> 명령어로 초고속 처리.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Redis 예시: 사용자별 분당 100회 제한</span>
</span></span><span class=line><span class=cl>EXISTS user:123
</span></span><span class=line><span class=cl>INCR user:123
</span></span><span class=line><span class=cl>EXPIRE user:123 <span class=m>60</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>동기화 방식</strong>:<ul><li><strong>중앙 집중식</strong>: 모든 노드가 공유 저장소 사용 → 정확도 높으나 병목 발생 가능.</li><li><strong>분산 동기화</strong>: 각 노드가 로컬 카운터 유지 후 주기적 동기화 → 성능 우선.</li></ul></li></ul></li><li><p>오류 처리 전략</p><ul><li><strong>429 Too Many Requests</strong>: HTTP 상태 코드로 제한 사실 통지.</li><li><strong>재시도 지시</strong>: <code>Retry-After</code> 헤더를 활용한 재시도 시간 안내.</li><li><strong>계층적 제한</strong>: 글로벌 제한 + 특정 엔드포인트별 추가 제한 조합.</li></ul></li></ol><h3 id=실제-적용-사례>실제 적용 사례<a hidden class=anchor aria-hidden=true href=#실제-적용-사례>#</a></h3><ol><li><p>클라우드플레어의 로그인 보호</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=k>1.</span> <span class=gs>**규칙**</span>: IP당 5분 동안 10회 로그인 시도 허용.
</span></span><span class=line><span class=cl><span class=k>2.</span> <span class=gs>**조치**</span>: 초과 시 30분 차단 + CAPTCHA 요청.
</span></span><span class=line><span class=cl><span class=k>3.</span> <span class=gs>**효과**</span>: 크리덴셜 스터핑 공격 90% 감소.
</span></span></code></pre></td></tr></table></div></div></li><li><p>마이크로서비스 간 호출 제어</p><ul><li><strong>문제 상황</strong>: 서비스 A가 서비스 B를 과도하게 호출해 장애 발생.</li><li><strong>해결책</strong>:<ul><li>서비스 A에 분당 500회 호출 제한 장치 추가.</li><li>초과 요청은 Circuit Breaker 패턴과 연동해 폴백 처리.</li></ul></li></ul></li></ol><h3 id=설계-시-고려사항>설계 시 고려사항<a hidden class=anchor aria-hidden=true href=#설계-시-고려사항>#</a></h3><ul><li><strong>성능 vs 정확성 트레이드오프</strong>: 분산 카운터는 AP(가용성-분할 허용) 시스템 특성상 일시적 불일치 가능.</li><li><strong>장기적 추적 필요성</strong>: 24시간 이상의 제한 창은 영구 저장소와 캐시 조합 필요.</li><li><strong>규칙 관리 인터페이스</strong>: 동적 설정 변경을 위한 Admin API 제공.</li></ul><h3 id=구현-시-고려사항>구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#구현-시-고려사항>#</a></h3><ul><li><strong>제한 범위 결정:</strong><ul><li>IP 주소, 사용자 ID, API 키 등 어떤 기준으로 요청을 제한할지 결정해야 한다.</li></ul></li><li><strong>시간 창 설정:</strong><ul><li>요청을 카운트할 시간 범위를 설정해야 한다.</li></ul></li><li><strong>예외 처리:</strong><ul><li>중요한 서비스나 사용자에 대해 예외를 설정할지 여부를 결정해야 한다.</li></ul></li><li><strong>분산 환경 고려:</strong><ul><li>여러 서버나 인스턴스에서 일관된 Rate Limiting을 적용하기 위한 메커니즘이 필요하다.</li></ul></li></ul><h2 id=장점><strong>장점:</strong><a hidden class=anchor aria-hidden=true href=#장점>#</a></h2><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-architecture-patterns/>Software-Architecture-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/rate-limiting-pattern/>Rate-Limiting-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/><span class=title>« Prev</span><br><span>Log</span>
</a><a class=next href=https://buenhyden.github.io/posts/architecture-and-system-design/architectue-styles/cloud-native/serverless/serverless-architecture/><span class=title>Next »</span><br><span>Serverless Architecture</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>