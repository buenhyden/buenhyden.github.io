<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Apache Pulsar vs. RabbitMQ | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,Event-and-Message-Brokers,Message-Broker-Systems,Apache-Pulsar"><meta name=description content="Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Apache Pulsar vs. RabbitMQ"><meta property="og:description" content="Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-02T06:04:00+00:00"><meta property="article:modified_time" content="2025-04-02T06:04:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="Event-and-Message-Brokers"><meta property="article:tag" content="Message-Broker-Systems"><meta property="article:tag" content="Apache-Pulsar"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Apache Pulsar vs. RabbitMQ"><meta name=twitter:description content="Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Architecture and System Design","item":"https://buenhyden.github.io/posts/architecture-and-system-design/"},{"@type":"ListItem","position":3,"name":"Event and Message Brokers","item":"https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/"},{"@type":"ListItem","position":4,"name":"Messaging Systems","item":""},{"@type":"ListItem","position":5,"name":"Event Streaming Platforms","item":""},{"@type":"ListItem","position":6,"name":"Apache Pulsar","item":"https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/"},{"@type":"ListItem","position":7,"name":"Apache Pulsar vs. RabbitMQ","item":"https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Apache Pulsar vs. RabbitMQ","name":"Apache Pulsar vs. RabbitMQ","description":"Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다.","keywords":["Backend-Development","Event-and-Message-Brokers","Message-Broker-Systems","Apache-Pulsar"],"articleBody":"Apache Pulsar vs. RabbitMQ Apache Pulsar와 RabbitMQ는 메시징 시스템으로서 각각 고유한 강점과 약점을 가지고 있으며, 사용 사례에 따라 적합한 선택이 달라질 수 있다.\n기본 개념 및 역사 Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 처음부터 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다.\nRabbitMQ RabbitMQ는 2007년 Rabbit Technologies Ltd.에서 개발되었으며, 현재는 VMware의 일부인 Pivotal Software에서 관리되고 있다. Erlang으로 작성된 RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다. 신뢰성, 유연성, 상호 운용성에 중점을 두고 설계되었다.\n아키텍처 비교 Pulsar는 독특한 다계층 아키텍처를 가지고 있다:\n스토리지와 컴퓨팅의 분리: Pulsar의 가장 큰 아키텍처적 특징은 메시지 처리(컴퓨팅)와 메시지 저장(스토리지)이 분리되어 있다는 점이다. 구성 요소: 브로커(Broker): 클라이언트 요청을 처리하고 메시지 전달을 관리한다. 북키퍼(BookKeeper): 분산 로그 저장소로, 실제 메시지 저장을 담당한다. 북키(Bookie): BookKeeper의 개별 저장 노드이다. ZooKeeper: 클러스터 메타데이터 관리와 조정을 담당한다. 세그먼트 기반 스토리지: 메시지는 세그먼트 단위로 저장되고 관리된다. 계층적 네임스페이스: 테넌트(Tenant) \u003e 네임스페이스(Namespace) \u003e 토픽(Topic)의 계층 구조를 가진다. RabbitMQ는 보다 전통적인 메시지 브로커 아키텍처를 가지고 있다:\n단일 통합 아키텍처: RabbitMQ에서는 메시지 처리와 저장이 모두 브로커 내에서 이루어진다. 구성 요소: Exchange: 프로듀서로부터 받은 메시지를 적절한 큐로 라우팅한다. Queue: 메시지가 저장되는 버퍼이다. Binding: Exchange와 Queue 사이의 관계를 정의한다. Virtual Host: 분리된 리소스 그룹으로, 다중 테넌시를 지원한다. 메모리 및 디스크 저장: 메시지는 기본적으로 메모리에 저장되며, 필요한 경우 디스크로 이동된다. 클러스터링: 고가용성을 위해 여러 노드를 클러스터링할 수 있다. 메시징 모델 Pulsar는 다양한 메시징 패러다임을 지원한다:\n발행-구독(Publish-Subscribe): 여러 소비자가 동일한 메시지를 받을 수 있다. 큐(Queue): 메시지는 소비자 그룹의 단일 소비자에게만 전달된다. 구독 유형: Exclusive: 단일 소비자만 토픽을 구독할 수 있다. Shared: 여러 소비자가 메시지를 공유한다(로드 밸런싱). Failover: 주 소비자가 실패하면 대기 소비자가 메시지를 받는다. Key_Shared: 동일한 키를 가진 메시지는 항상 같은 소비자에게 라우팅된다. 세그먼트 기반 저장소: 메시지는 추가만 가능한(append-only) 로그에 저장된다. 메시지 보존: 메시지는 소비 여부와 관계없이 구성된 보존 정책에 따라 저장된다. RabbitMQ는 AMQP를 기반으로 한 메시징 모델을 제공한다:\nExchange 타입: Direct: 라우팅 키와 정확히 일치하는 큐로 메시지를 전달한다. Fanout: 연결된 모든 큐에 메시지를 브로드캐스트한다. Topic: 와일드카드를 포함한 패턴 매칭을 통해 메시지를 라우팅한다. Headers: 메시지 헤더 속성을 기반으로 라우팅한다. 메시지 인지(Acknowledgment): 소비자는 메시지 처리 후 확인을 보내며, 확인이 없으면 메시지가 다시 큐에 추가된다. 메시지 삭제: 메시지는 소비되면 기본적으로 큐에서 제거된다. 메시지 우선순위: 메시지에 우선순위를 설정할 수 있다. TTL(Time-to-Live): 메시지와 큐에 대한 TTL을 설정할 수 있다. 성능 및 확장성 Apache Pulsar의 성능 및 확장성 스토리지와 컴퓨팅 분리: 독립적으로 확장 가능하다. 성능 특성: 매우 높은 처리량 지원 일관적으로 낮은 지연 시간 수백만 토픽 지원 확장 방식: 브로커 확장: 처리 용량 증가 북키 확장: 스토리지 용량 증가 독립적인 수평적 확장 티어드 스토리지: 오래된 메시지를 저비용 스토리지(S3, GCS 등)로 자동 이동하여 비용 효율적으로 대용량 데이터 저장 가능 RabbitMQ의 성능 및 확장성 성능 특성: 중간 수준의 처리량 매우 낮은 지연 시간(특히 작은 메시지의 경우) 수천 개의 큐 처리에 최적화 확장 방식: 클러스터링: 여러 노드에 큐 분산 미러링: 고가용성을 위한 큐 복제 주로 수직적 확장에 의존 메모리 요구사항: 활성 메시지는 주로 메모리에 저장되므로 대용량 메시지 저장 시 메모리 압박 발생 가능 내구성 및 신뢰성 Apache Pulsar의 내구성 및 신뢰성 복제 전략: BookKeeper의 쿼럼 기반 복제 Write Quorum과 Ack Quorum 설정 가능 읽기 및 쓰기에 대한 쿼럼 보장 장애 처리: 브로커 장애: 영향 최소화(데이터는 BookKeeper에 저장됨) 북키 장애: 자동 장애 복구 및 데이터 재조정 트랜잭션 지원: 멀티 토픽 트랜잭션 가능 정확히 한 번 처리: 보장된 메시지 전달 의미론 지원 RabbitMQ의 내구성 및 신뢰성 복제 전략: 미러링 큐: 모든 노드에 동일한 큐 복제 퀴럼 큐: Raft 합의 알고리즘 기반 복제 장애 처리: 노드 장애: 미러링된 큐로 자동 장애 복구 네트워크 파티션: 파티션 감지 및 처리 정책 메시지 지속성: 디스크에 메시지 저장 설정 가능 확인 모드: 다양한 확인 모드로 신뢰성 수준 조정 가능 주요 기능 비교 다중 테넌시\nPulsar:\n내장된 테넌트 및 네임스페이스 개념 강력한 리소스 격리 테넌트별 인증 및 권한 관리 RabbitMQ:\nVirtual Host를 통한 기본적인 테넌트 분리 완전한 리소스 격리를 제공하지는 않음 프로토콜 지원\nPulsar:\n자체 바이너리 프로토콜 Kafka 프로토콜 어댑터 WebSocket 지원 RabbitMQ:\nAMQP 0-9-1 (기본) MQTT STOMP HTTP WebSocket 지역 간 복제\nPulsar:\n내장된 지역 간 복제 기능 네임스페이스 또는 토픽 단위 복제 설정 비동기 복제로 성능 영향 최소화 RabbitMQ:\n내장된 지역 간 복제 기능 없음 페더레이션 플러그인이나 솔로우(Shovel) 플러그인을 통해 제한적으로 구현 가능 스키마 관리\nPulsar:\n내장된 스키마 레지스트리 Avro, JSON, Protobuf 등 다양한 형식 지원 스키마 진화 및 호환성 검사 RabbitMQ:\n내장된 스키마 관리 기능 없음 메시지 형식에 대한 제약 없음 처리 기능\nPulsar:\nPulsar Functions: 서버리스 스타일의 경량 처리 Pulsar IO: 외부 시스템과의 커넥터 Pulsar SQL: 저장된 데이터에 대한 SQL 쿼리 RabbitMQ:\n내장된 처리 기능 제한적 주로 메시지 브로커 역할에 집중 운영 및 관리 구성 및 배포\nPulsar:\n복잡한 다계층 아키텍처로 초기 설정이 복잡 여러 구성 요소(ZooKeeper, BookKeeper, Broker) 관리 필요 Kubernetes 및 클라우드 환경 지원 RabbitMQ:\n비교적 간단한 설정 및 배포 단일 구성 요소로 관리 용이 다양한 환경에서의 배포 지원 모니터링 및 관리 도구\nPulsar:\nPulsar Manager: 웹 기반 관리 도구 REST API Prometheus 메트릭 상대적으로 덜 성숙한 관리 도구 RabbitMQ:\n포괄적인 내장 관리 UI 풍부한 플러그인 에코시스템 상세한 모니터링 및 알람 기능 성숙한 관리 도구 커뮤니티 및 지원\nPulsar:\n성장하는 활발한 커뮤니티 Apache 재단 지원 상대적으로 새로운 프로젝트 RabbitMQ:\n오랜 역사와 안정적인 커뮤니티 VMware의 상업적 지원 풍부한 문서와 사용 사례 사용 사례 비교 Apache Pulsar에 적합한 사용 사례\n대용량 이벤트 스트리밍: 높은 처리량과 대용량 데이터 처리가 필요한 경우 다중 테넌트 환경: 여러 팀이나 애플리케이션이 동일한 메시징 인프라를 공유하는 경우 하이브리드 메시징 패턴: 발행-구독과 큐 기반 메시징을 모두 필요로 하는 경우 지역 간 메시징: 전 세계적으로 분산된 시스템 간 메시지 교환이 필요한 경우 장기 메시지 보존: 메시지를 장기간 보존하고 재생해야 하는 경우 IoT 및 센서 데이터 처리: 대량의 센서 데이터를 수집하고 처리해야 하는 경우 RabbitMQ에 적합한 사용 사례\n복잡한 라우팅 요구사항: 다양한 조건에 따른 메시지 라우팅이 필요한 경우 마이크로서비스 간 통신: 서비스 간 비동기 통신 채널이 필요한 경우 작업 분배: 백그라운드 작업을 여러 작업자에게 분배해야 하는 경우 우선순위 큐: 메시지 처리 우선순위가 중요한 경우 RPC(Remote Procedure Call) 패턴: 요청-응답 패턴의 비동기 통신이 필요한 경우 낮은 지연 시간 요구사항: 메시지 전달의 지연 시간이 매우 중요한 경우 Apache Pulsar vs. RabbitMQ 비교 특성 Apache Pulsar RabbitMQ 개발 시작 2016년 Yahoo 2007년 Rabbit Technologies 프로그래밍 언어 Java/C++ Erlang 아키텍처 다계층(스토리지와 컴퓨팅 분리) 단일 통합 아키텍처 스토리지 엔진 Apache BookKeeper(분산 로그) 메모리와 디스크(Mnesia) 주요 프로토콜 자체 바이너리 프로토콜 AMQP, MQTT, STOMP, HTTP 메시징 패러다임 발행-구독 및 큐 발행-구독 및 큐 토픽/큐 구조 계층적(테넌트/네임스페이스/토픽) 평면적(Virtual Host/Queue) 다중 테넌시 강력한 내장 지원 Virtual Host를 통한 기본 지원 복제 모델 쿼럼 기반 복제 미러링 큐, 퀴럼 큐 구독 유형 Exclusive, Shared, Failover, Key_Shared 기본적으로 경쟁 소비자 모델 메시지 라우팅 기본적인 라우팅 다양한 Exchange 타입으로 풍부한 라우팅 메시지 보존 영구 저장, 티어드 스토리지 메모리+디스크, 소비 후 일반적으로 삭제 스키마 관리 내장된 스키마 레지스트리 지원하지 않음 최대 처리량 매우 높음(수백만 메시지/초) 중간(수십만 메시지/초) 지연 시간 매우 낮음(밀리초 단위) 매우 낮음(특히 작은 메시지의 경우) 지역 간 복제 내장 기능 플러그인을 통한 제한적 지원 트랜잭션 지원(멀티 토픽) 제한적 지원 처리 기능 Pulsar Functions, Pulsar IO, Pulsar SQL 제한적, 주로 외부 처리에 의존 메시지 우선순위 제한적 지원 강력한 지원 확장성 수평적 확장 우수 수직적 확장에 더 의존적 리소스 요구사항 상대적으로 높음 상대적으로 낮음 설정 복잡성 높음 중간 관리 도구 Pulsar Manager, REST API 포괄적인 내장 관리 UI, 풍부한 플러그인 커뮤니티 성숙도 성장 중 매우 성숙함 적합한 워크로드 대용량 스트리밍, 장기 데이터 보존 복잡한 라우팅, 낮은 지연 시간 요구사항 클라이언트 언어 지원 Java, Python, Go, C++, Node.js 등 Java, Python, Ruby, PHP,.NET, Node.js 등 배포 방식 자체 호스팅, 클라우드 네이티브 자체 호스팅, 클라우드, 서비스형 제공 오픈소스 라이선스 Apache License 2.0 Mozilla Public License 선택 가이드 Apache Pulsar를 선택해야 하는 경우\n매우 높은 처리량과 대용량 메시지 처리가 필요한 경우 장기간 메시지 보존이 중요한 경우 다중 테넌트 환경을 구축하려는 경우 지역 간 메시징이 필요한 경우 스토리지와 컴퓨팅을 독립적으로 확장하고 싶은 경우 다양한 구독 패턴이 필요한 경우 미래 지향적인 클라우드 네이티브 솔루션을 찾는 경우 RabbitMQ를 선택해야 하는 경우\n복잡한 메시지 라우팅 패턴이 필요한 경우 다양한 메시징 프로토콜 지원이 필요한 경우 설정과 관리의 단순성이 중요한 경우 리소스 요구사항이 제한적인 경우 성숙하고 검증된 솔루션이 필요한 경우 우선순위 큐와 같은 특화된 메시징 기능이 필요한 경우 기존 AMQP 기반 시스템과의 통합이 필요한 경우 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1325","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-02T06:04:00Z","dateModified":"2025-04-02T06:04:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/architecture-and-system-design/>Architecture and System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/>Event and Message Brokers</a>&nbsp;»&nbsp;<a href>Messaging Systems</a>&nbsp;»&nbsp;<a href>Event Streaming Platforms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/>Apache Pulsar</a></div><h1 class="post-title entry-hint-parent">Apache Pulsar vs. RabbitMQ</h1><div class=post-description>Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다.</div><div class=post-meta><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Architecture%20and%20System%20Design/Event%20and%20Message%20Brokers/Messaging%20Systems/Event%20Streaming%20Platforms/Apache%20Pulsar/apache-pulsar-vs-rabbitmq.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#apache-pulsar-vs-rabbitmq>Apache Pulsar vs. RabbitMQ</a><ul><li><a href=#기본-개념-및-역사>기본 개념 및 역사</a></li><li><a href=#아키텍처-비교>아키텍처 비교</a></li><li><a href=#메시징-모델>메시징 모델</a></li><li><a href=#성능-및-확장성>성능 및 확장성</a></li><li><a href=#내구성-및-신뢰성>내구성 및 신뢰성</a></li><li><a href=#주요-기능-비교>주요 기능 비교</a></li><li><a href=#운영-및-관리>운영 및 관리</a></li><li><a href=#사용-사례-비교>사용 사례 비교</a></li><li><a href=#apache-pulsar-vs-rabbitmq-비교>Apache Pulsar vs. RabbitMQ 비교</a></li><li><a href=#선택-가이드>선택 가이드</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=apache-pulsar-vs-rabbitmq>Apache Pulsar vs. RabbitMQ<a hidden class=anchor aria-hidden=true href=#apache-pulsar-vs-rabbitmq>#</a></h2><p>Apache Pulsar와 RabbitMQ는 메시징 시스템으로서 각각 고유한 강점과 약점을 가지고 있으며, 사용 사례에 따라 적합한 선택이 달라질 수 있다.</p><h3 id=기본-개념-및-역사>기본 개념 및 역사<a hidden class=anchor aria-hidden=true href=#기본-개념-및-역사>#</a></h3><h4 id=apache-pulsar>Apache Pulsar<a hidden class=anchor aria-hidden=true href=#apache-pulsar>#</a></h4><p>Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 처음부터 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다.</p><h4 id=rabbitmq>RabbitMQ<a hidden class=anchor aria-hidden=true href=#rabbitmq>#</a></h4><p>RabbitMQ는 2007년 Rabbit Technologies Ltd.에서 개발되었으며, 현재는 VMware의 일부인 Pivotal Software에서 관리되고 있다. Erlang으로 작성된 RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다. 신뢰성, 유연성, 상호 운용성에 중점을 두고 설계되었다.</p><h3 id=아키텍처-비교>아키텍처 비교<a hidden class=anchor aria-hidden=true href=#아키텍처-비교>#</a></h3><p>Pulsar는 독특한 다계층 아키텍처를 가지고 있다:</p><ol><li><strong>스토리지와 컴퓨팅의 분리</strong>: Pulsar의 가장 큰 아키텍처적 특징은 메시지 처리(컴퓨팅)와 메시지 저장(스토리지)이 분리되어 있다는 점이다.</li><li><strong>구성 요소</strong>:<ul><li><strong>브로커(Broker)</strong>: 클라이언트 요청을 처리하고 메시지 전달을 관리한다.</li><li><strong>북키퍼(BookKeeper)</strong>: 분산 로그 저장소로, 실제 메시지 저장을 담당한다.</li><li><strong>북키(Bookie)</strong>: BookKeeper의 개별 저장 노드이다.</li><li><strong>ZooKeeper</strong>: 클러스터 메타데이터 관리와 조정을 담당한다.</li></ul></li><li><strong>세그먼트 기반 스토리지</strong>: 메시지는 세그먼트 단위로 저장되고 관리된다.</li><li><strong>계층적 네임스페이스</strong>: 테넌트(Tenant) > 네임스페이스(Namespace) > 토픽(Topic)의 계층 구조를 가진다.</li></ol><p>RabbitMQ는 보다 전통적인 메시지 브로커 아키텍처를 가지고 있다:</p><ol><li><strong>단일 통합 아키텍처</strong>: RabbitMQ에서는 메시지 처리와 저장이 모두 브로커 내에서 이루어진다.</li><li><strong>구성 요소</strong>:<ul><li><strong>Exchange</strong>: 프로듀서로부터 받은 메시지를 적절한 큐로 라우팅한다.</li><li><strong>Queue</strong>: 메시지가 저장되는 버퍼이다.</li><li><strong>Binding</strong>: Exchange와 Queue 사이의 관계를 정의한다.</li><li><strong>Virtual Host</strong>: 분리된 리소스 그룹으로, 다중 테넌시를 지원한다.</li></ul></li><li><strong>메모리 및 디스크 저장</strong>: 메시지는 기본적으로 메모리에 저장되며, 필요한 경우 디스크로 이동된다.</li><li><strong>클러스터링</strong>: 고가용성을 위해 여러 노드를 클러스터링할 수 있다.</li></ol><h3 id=메시징-모델>메시징 모델<a hidden class=anchor aria-hidden=true href=#메시징-모델>#</a></h3><p>Pulsar는 다양한 메시징 패러다임을 지원한다:</p><ol><li><strong>발행-구독(Publish-Subscribe)</strong>: 여러 소비자가 동일한 메시지를 받을 수 있다.</li><li><strong>큐(Queue)</strong>: 메시지는 소비자 그룹의 단일 소비자에게만 전달된다.</li><li><strong>구독 유형</strong>:<ul><li><strong>Exclusive</strong>: 단일 소비자만 토픽을 구독할 수 있다.</li><li><strong>Shared</strong>: 여러 소비자가 메시지를 공유한다(로드 밸런싱).</li><li><strong>Failover</strong>: 주 소비자가 실패하면 대기 소비자가 메시지를 받는다.</li><li><strong>Key_Shared</strong>: 동일한 키를 가진 메시지는 항상 같은 소비자에게 라우팅된다.</li></ul></li><li><strong>세그먼트 기반 저장소</strong>: 메시지는 추가만 가능한(append-only) 로그에 저장된다.</li><li><strong>메시지 보존</strong>: 메시지는 소비 여부와 관계없이 구성된 보존 정책에 따라 저장된다.</li></ol><p>RabbitMQ는 AMQP를 기반으로 한 메시징 모델을 제공한다:</p><ol><li><strong>Exchange 타입</strong>:<ul><li><strong>Direct</strong>: 라우팅 키와 정확히 일치하는 큐로 메시지를 전달한다.</li><li><strong>Fanout</strong>: 연결된 모든 큐에 메시지를 브로드캐스트한다.</li><li><strong>Topic</strong>: 와일드카드를 포함한 패턴 매칭을 통해 메시지를 라우팅한다.</li><li><strong>Headers</strong>: 메시지 헤더 속성을 기반으로 라우팅한다.</li></ul></li><li><strong>메시지 인지(Acknowledgment)</strong>: 소비자는 메시지 처리 후 확인을 보내며, 확인이 없으면 메시지가 다시 큐에 추가된다.</li><li><strong>메시지 삭제</strong>: 메시지는 소비되면 기본적으로 큐에서 제거된다.</li><li><strong>메시지 우선순위</strong>: 메시지에 우선순위를 설정할 수 있다.</li><li><strong>TTL(Time-to-Live)</strong>: 메시지와 큐에 대한 TTL을 설정할 수 있다.</li></ol><h3 id=성능-및-확장성>성능 및 확장성<a hidden class=anchor aria-hidden=true href=#성능-및-확장성>#</a></h3><h4 id=apache-pulsar의-성능-및-확장성>Apache Pulsar의 성능 및 확장성<a hidden class=anchor aria-hidden=true href=#apache-pulsar의-성능-및-확장성>#</a></h4><ol><li><strong>스토리지와 컴퓨팅 분리</strong>: 독립적으로 확장 가능하다.</li><li><strong>성능 특성</strong>:<ul><li>매우 높은 처리량 지원</li><li>일관적으로 낮은 지연 시간</li><li>수백만 토픽 지원</li></ul></li><li><strong>확장 방식</strong>:<ul><li>브로커 확장: 처리 용량 증가</li><li>북키 확장: 스토리지 용량 증가</li><li>독립적인 수평적 확장</li></ul></li><li><strong>티어드 스토리지</strong>: 오래된 메시지를 저비용 스토리지(S3, GCS 등)로 자동 이동하여 비용 효율적으로 대용량 데이터 저장 가능</li></ol><h4 id=rabbitmq의-성능-및-확장성>RabbitMQ의 성능 및 확장성<a hidden class=anchor aria-hidden=true href=#rabbitmq의-성능-및-확장성>#</a></h4><ol><li><strong>성능 특성</strong>:<ul><li>중간 수준의 처리량</li><li>매우 낮은 지연 시간(특히 작은 메시지의 경우)</li><li>수천 개의 큐 처리에 최적화</li></ul></li><li><strong>확장 방식</strong>:<ul><li>클러스터링: 여러 노드에 큐 분산</li><li>미러링: 고가용성을 위한 큐 복제</li><li>주로 수직적 확장에 의존</li></ul></li><li><strong>메모리 요구사항</strong>: 활성 메시지는 주로 메모리에 저장되므로 대용량 메시지 저장 시 메모리 압박 발생 가능</li></ol><h3 id=내구성-및-신뢰성>내구성 및 신뢰성<a hidden class=anchor aria-hidden=true href=#내구성-및-신뢰성>#</a></h3><h4 id=apache-pulsar의-내구성-및-신뢰성>Apache Pulsar의 내구성 및 신뢰성<a hidden class=anchor aria-hidden=true href=#apache-pulsar의-내구성-및-신뢰성>#</a></h4><ol><li><strong>복제 전략</strong>:<ul><li>BookKeeper의 쿼럼 기반 복제</li><li>Write Quorum과 Ack Quorum 설정 가능</li><li>읽기 및 쓰기에 대한 쿼럼 보장</li></ul></li><li><strong>장애 처리</strong>:<ul><li>브로커 장애: 영향 최소화(데이터는 BookKeeper에 저장됨)</li><li>북키 장애: 자동 장애 복구 및 데이터 재조정</li></ul></li><li><strong>트랜잭션 지원</strong>: 멀티 토픽 트랜잭션 가능</li><li><strong>정확히 한 번 처리</strong>: 보장된 메시지 전달 의미론 지원</li></ol><h4 id=rabbitmq의-내구성-및-신뢰성>RabbitMQ의 내구성 및 신뢰성<a hidden class=anchor aria-hidden=true href=#rabbitmq의-내구성-및-신뢰성>#</a></h4><ol><li><strong>복제 전략</strong>:<ul><li>미러링 큐: 모든 노드에 동일한 큐 복제</li><li>퀴럼 큐: Raft 합의 알고리즘 기반 복제</li></ul></li><li><strong>장애 처리</strong>:<ul><li>노드 장애: 미러링된 큐로 자동 장애 복구</li><li>네트워크 파티션: 파티션 감지 및 처리 정책</li></ul></li><li><strong>메시지 지속성</strong>: 디스크에 메시지 저장 설정 가능</li><li><strong>확인 모드</strong>: 다양한 확인 모드로 신뢰성 수준 조정 가능</li></ol><h3 id=주요-기능-비교>주요 기능 비교<a hidden class=anchor aria-hidden=true href=#주요-기능-비교>#</a></h3><ol><li><p>다중 테넌시<br><strong>Pulsar</strong>:</p><ul><li>내장된 테넌트 및 네임스페이스 개념</li><li>강력한 리소스 격리</li><li>테넌트별 인증 및 권한 관리</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>Virtual Host를 통한 기본적인 테넌트 분리</li><li>완전한 리소스 격리를 제공하지는 않음</li></ul></li><li><p>프로토콜 지원<br><strong>Pulsar</strong>:</p><ul><li>자체 바이너리 프로토콜</li><li>Kafka 프로토콜 어댑터</li><li>WebSocket 지원</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>AMQP 0-9-1 (기본)</li><li>MQTT</li><li>STOMP</li><li>HTTP</li><li>WebSocket</li></ul></li><li><p>지역 간 복제<br><strong>Pulsar</strong>:</p><ul><li>내장된 지역 간 복제 기능</li><li>네임스페이스 또는 토픽 단위 복제 설정</li><li>비동기 복제로 성능 영향 최소화</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>내장된 지역 간 복제 기능 없음</li><li>페더레이션 플러그인이나 솔로우(Shovel) 플러그인을 통해 제한적으로 구현 가능</li></ul></li><li><p>스키마 관리<br><strong>Pulsar</strong>:</p><ul><li>내장된 스키마 레지스트리</li><li>Avro, JSON, Protobuf 등 다양한 형식 지원</li><li>스키마 진화 및 호환성 검사</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>내장된 스키마 관리 기능 없음</li><li>메시지 형식에 대한 제약 없음</li></ul></li><li><p>처리 기능<br><strong>Pulsar</strong>:</p><ul><li>Pulsar Functions: 서버리스 스타일의 경량 처리</li><li>Pulsar IO: 외부 시스템과의 커넥터</li><li>Pulsar SQL: 저장된 데이터에 대한 SQL 쿼리</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>내장된 처리 기능 제한적</li><li>주로 메시지 브로커 역할에 집중</li></ul></li></ol><h3 id=운영-및-관리>운영 및 관리<a hidden class=anchor aria-hidden=true href=#운영-및-관리>#</a></h3><ol><li><p>구성 및 배포<br><strong>Pulsar</strong>:</p><ul><li>복잡한 다계층 아키텍처로 초기 설정이 복잡</li><li>여러 구성 요소(ZooKeeper, BookKeeper, Broker) 관리 필요</li><li>Kubernetes 및 클라우드 환경 지원</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>비교적 간단한 설정 및 배포</li><li>단일 구성 요소로 관리 용이</li><li>다양한 환경에서의 배포 지원</li></ul></li><li><p>모니터링 및 관리 도구<br><strong>Pulsar</strong>:</p><ul><li>Pulsar Manager: 웹 기반 관리 도구</li><li>REST API</li><li>Prometheus 메트릭</li><li>상대적으로 덜 성숙한 관리 도구</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>포괄적인 내장 관리 UI</li><li>풍부한 플러그인 에코시스템</li><li>상세한 모니터링 및 알람 기능</li><li>성숙한 관리 도구</li></ul></li><li><p>커뮤니티 및 지원<br><strong>Pulsar</strong>:</p><ul><li>성장하는 활발한 커뮤니티</li><li>Apache 재단 지원</li><li>상대적으로 새로운 프로젝트</li></ul><p><strong>RabbitMQ</strong>:</p><ul><li>오랜 역사와 안정적인 커뮤니티</li><li>VMware의 상업적 지원</li><li>풍부한 문서와 사용 사례</li></ul></li></ol><h3 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h3><ul><li><p>Apache Pulsar에 적합한 사용 사례</p><ol><li><strong>대용량 이벤트 스트리밍</strong>: 높은 처리량과 대용량 데이터 처리가 필요한 경우</li><li><strong>다중 테넌트 환경</strong>: 여러 팀이나 애플리케이션이 동일한 메시징 인프라를 공유하는 경우</li><li><strong>하이브리드 메시징 패턴</strong>: 발행-구독과 큐 기반 메시징을 모두 필요로 하는 경우</li><li><strong>지역 간 메시징</strong>: 전 세계적으로 분산된 시스템 간 메시지 교환이 필요한 경우</li><li><strong>장기 메시지 보존</strong>: 메시지를 장기간 보존하고 재생해야 하는 경우</li><li><strong>IoT 및 센서 데이터 처리</strong>: 대량의 센서 데이터를 수집하고 처리해야 하는 경우</li></ol></li><li><p>RabbitMQ에 적합한 사용 사례</p><ol><li><strong>복잡한 라우팅 요구사항</strong>: 다양한 조건에 따른 메시지 라우팅이 필요한 경우</li><li><strong>마이크로서비스 간 통신</strong>: 서비스 간 비동기 통신 채널이 필요한 경우</li><li><strong>작업 분배</strong>: 백그라운드 작업을 여러 작업자에게 분배해야 하는 경우</li><li><strong>우선순위 큐</strong>: 메시지 처리 우선순위가 중요한 경우</li><li><strong>RPC(Remote Procedure Call) 패턴</strong>: 요청-응답 패턴의 비동기 통신이 필요한 경우</li><li><strong>낮은 지연 시간 요구사항</strong>: 메시지 전달의 지연 시간이 매우 중요한 경우</li></ol></li></ul><h3 id=apache-pulsar-vs-rabbitmq-비교>Apache Pulsar vs. RabbitMQ 비교<a hidden class=anchor aria-hidden=true href=#apache-pulsar-vs-rabbitmq-비교>#</a></h3><table><thead><tr><th>특성</th><th>Apache Pulsar</th><th>RabbitMQ</th></tr></thead><tbody><tr><td><strong>개발 시작</strong></td><td>2016년 Yahoo</td><td>2007년 Rabbit Technologies</td></tr><tr><td><strong>프로그래밍 언어</strong></td><td>Java/C++</td><td>Erlang</td></tr><tr><td><strong>아키텍처</strong></td><td>다계층(스토리지와 컴퓨팅 분리)</td><td>단일 통합 아키텍처</td></tr><tr><td><strong>스토리지 엔진</strong></td><td>Apache BookKeeper(분산 로그)</td><td>메모리와 디스크(Mnesia)</td></tr><tr><td><strong>주요 프로토콜</strong></td><td>자체 바이너리 프로토콜</td><td>AMQP, MQTT, STOMP, HTTP</td></tr><tr><td><strong>메시징 패러다임</strong></td><td>발행-구독 및 큐</td><td>발행-구독 및 큐</td></tr><tr><td><strong>토픽/큐 구조</strong></td><td>계층적(테넌트/네임스페이스/토픽)</td><td>평면적(Virtual Host/Queue)</td></tr><tr><td><strong>다중 테넌시</strong></td><td>강력한 내장 지원</td><td>Virtual Host를 통한 기본 지원</td></tr><tr><td><strong>복제 모델</strong></td><td>쿼럼 기반 복제</td><td>미러링 큐, 퀴럼 큐</td></tr><tr><td><strong>구독 유형</strong></td><td>Exclusive, Shared, Failover, Key_Shared</td><td>기본적으로 경쟁 소비자 모델</td></tr><tr><td><strong>메시지 라우팅</strong></td><td>기본적인 라우팅</td><td>다양한 Exchange 타입으로 풍부한 라우팅</td></tr><tr><td><strong>메시지 보존</strong></td><td>영구 저장, 티어드 스토리지</td><td>메모리+디스크, 소비 후 일반적으로 삭제</td></tr><tr><td><strong>스키마 관리</strong></td><td>내장된 스키마 레지스트리</td><td>지원하지 않음</td></tr><tr><td><strong>최대 처리량</strong></td><td>매우 높음(수백만 메시지/초)</td><td>중간(수십만 메시지/초)</td></tr><tr><td><strong>지연 시간</strong></td><td>매우 낮음(밀리초 단위)</td><td>매우 낮음(특히 작은 메시지의 경우)</td></tr><tr><td><strong>지역 간 복제</strong></td><td>내장 기능</td><td>플러그인을 통한 제한적 지원</td></tr><tr><td><strong>트랜잭션</strong></td><td>지원(멀티 토픽)</td><td>제한적 지원</td></tr><tr><td><strong>처리 기능</strong></td><td>Pulsar Functions, Pulsar IO, Pulsar SQL</td><td>제한적, 주로 외부 처리에 의존</td></tr><tr><td><strong>메시지 우선순위</strong></td><td>제한적 지원</td><td>강력한 지원</td></tr><tr><td><strong>확장성</strong></td><td>수평적 확장 우수</td><td>수직적 확장에 더 의존적</td></tr><tr><td><strong>리소스 요구사항</strong></td><td>상대적으로 높음</td><td>상대적으로 낮음</td></tr><tr><td><strong>설정 복잡성</strong></td><td>높음</td><td>중간</td></tr><tr><td><strong>관리 도구</strong></td><td>Pulsar Manager, REST API</td><td>포괄적인 내장 관리 UI, 풍부한 플러그인</td></tr><tr><td><strong>커뮤니티 성숙도</strong></td><td>성장 중</td><td>매우 성숙함</td></tr><tr><td><strong>적합한 워크로드</strong></td><td>대용량 스트리밍, 장기 데이터 보존</td><td>복잡한 라우팅, 낮은 지연 시간 요구사항</td></tr><tr><td><strong>클라이언트 언어 지원</strong></td><td>Java, Python, Go, C++, Node.js 등</td><td>Java, Python, Ruby, PHP,.NET, Node.js 등</td></tr><tr><td><strong>배포 방식</strong></td><td>자체 호스팅, 클라우드 네이티브</td><td>자체 호스팅, 클라우드, 서비스형 제공</td></tr><tr><td><strong>오픈소스 라이선스</strong></td><td>Apache License 2.0</td><td>Mozilla Public License</td></tr></tbody></table><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ol><li><p>Apache Pulsar를 선택해야 하는 경우</p><ul><li>매우 높은 처리량과 대용량 메시지 처리가 필요한 경우</li><li>장기간 메시지 보존이 중요한 경우</li><li>다중 테넌트 환경을 구축하려는 경우</li><li>지역 간 메시징이 필요한 경우</li><li>스토리지와 컴퓨팅을 독립적으로 확장하고 싶은 경우</li><li>다양한 구독 패턴이 필요한 경우</li><li>미래 지향적인 클라우드 네이티브 솔루션을 찾는 경우</li></ul></li><li><p>RabbitMQ를 선택해야 하는 경우</p><ul><li>복잡한 메시지 라우팅 패턴이 필요한 경우</li><li>다양한 메시징 프로토콜 지원이 필요한 경우</li><li>설정과 관리의 단순성이 중요한 경우</li><li>리소스 요구사항이 제한적인 경우</li><li>성숙하고 검증된 솔루션이 필요한 경우</li><li>우선순위 큐와 같은 특화된 메시징 기능이 필요한 경우</li><li>기존 AMQP 기반 시스템과의 통합이 필요한 경우</li></ul></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/event-and-message-brokers/>Event-and-Message-Brokers</a></li><li><a href=https://buenhyden.github.io/tags/message-broker-systems/>Message-Broker-Systems</a></li><li><a href=https://buenhyden.github.io/tags/apache-pulsar/>Apache-Pulsar</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/architecture-and-system-design/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-kafka/><span class=title>« Prev</span><br><span>Apache Pulsar vs. Kafka</span>
</a><a class=next href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-basic-authentication/><span class=title>Next »</span><br><span>jwt vs. Basic Authentication</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>