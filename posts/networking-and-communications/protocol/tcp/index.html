<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TCP | hyunyoun's Blog</title>
<meta name=keywords content="Networking-and-Communications,Protocol,TCP,Transmission-Control-Protocol"><meta name=description content="TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="TCP"><meta property="og:description" content="TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T04:21:00+00:00"><meta property="article:modified_time" content="2024-10-02T04:21:00+00:00"><meta property="article:tag" content="Networking-and-Communications"><meta property="article:tag" content="Protocol"><meta property="article:tag" content="TCP"><meta property="article:tag" content="Transmission-Control-Protocol"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="TCP"><meta name=twitter:description content="TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Network","item":"https://buenhyden.github.io/posts/networking-and-communications/"},{"@type":"ListItem","position":3,"name":"Network Protocol","item":"https://buenhyden.github.io/posts/networking-and-communications/protocol/"},{"@type":"ListItem","position":4,"name":"TCP","item":"https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TCP","name":"TCP","description":"TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜","keywords":["Networking-and-Communications","Protocol","TCP","Transmission-Control-Protocol"],"articleBody":"TCP (Transmission Control Protocol) 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로, IP(Internet Protocol)와 함께 TCP/IP로 널리 알려져 있다.\nTCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜이다.\nOSI 7계층에서 TCP는 전송 계층(Transport Layer)인 4계층에 위치하며,\nTCP/IP 4계층 모델에서도 마찬가지로 전송 계층에 해당한다.\n이 위치에서 TCP는 데이터의 신뢰성 있는 전송을 담당하는 핵심적인 역할을 수행한다.\nTCP의 가장 중요한 특징은 연결 지향성과 신뢰성이다.\n연결 지향성이란 데이터를 주고받기 전에 먼저 연결을 설정하는 것을 의미하는데, 이는 3-way handshaking이라는 과정을 통해 이루어진다.\n신뢰성은 데이터가 손실없이 순서대로 전달되는 것을 보장한다는 의미이다.\n주요 특징 신뢰성 보장: TCP는 데이터가 정확하게, 순서대로, 그리고 오류 없이 전달되도록 보장한다. 연결 지향적: 데이터 전송 전에 연결을 설정하고, 전송 후에는 연결을 종료한다. 흐름 제어: 수신자의 처리 능력에 맞춰 데이터 전송 속도를 조절한다. 혼잡 제어: 네트워크의 혼잡 상태를 감지하고 데이터 전송 속도를 조절한다. 전이중(Full-Duplex) 통신: 양방향으로 동시에 데이터 전송이 가능하다. 점대점(Point to Point) 통신: 정확히 2개의 종단점을 가진다. Window Size:\n한 번에 전송할 수 있는 데이터의 양을 조절하는 값.\n이는 흐름제어와 직접적인 관련이 있으며, 수신측의 처리 능력에 따라 동적으로 조절된다.\nMSS(Maximum Segment Size):\nTCP가 한 번에 전송할 수 있는 최대 세그먼트 크기를 의미한다.\n이는 네트워크의 특성을 고려하여 설정된다.\n타임아웃과 재전송:\n일정 시간 내에 ACK를 받지 못하면 패킷 손실로 간주하고 재전송을 수행한다.\n이는 데이터의 신뢰성을 보장하는 중요한 메커니즘이다.\nSlow Start:\n네트워크 혼잡을 방지하기 위해 처음에는 적은 양의 데이터부터 전송을 시작한다.\n장점 신뢰성 있는 데이터 전송 순서 보장 오류 검출 및 복구 흐름 제어를 통한 효율적인 네트워크 사용 다양한 애플리케이션 지원 (웹 브라우징, 이메일, 파일 전송 등) 동작 방식 %%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '12px'}, 'flowchart': {'width': 400, 'height': 250, 'diagramPadding': 8}}}%% sequenceDiagram participant Client participant Server Note over Client,Server: 3-way Handshake (연결 수립) Client-\u003e\u003eServer: SYN (Seq = x) Server--\u003e\u003eClient: SYN + ACK (Seq = y, Ack = x+1) Client-\u003e\u003eServer: ACK (Seq = x+1, Ack = y+1) Note over Client,Server: 데이터 전송 Note over Client,Server: 4-way Handshake (연결 종료) Client-\u003e\u003eServer: FIN Server--\u003e\u003eClient: ACK Note right of Server: CLOSE_WAIT 상태 Server-\u003e\u003eClient: FIN Note left of Client: TIME_WAIT 상태 Client--\u003e\u003eServer: ACK 데이터 전송:\n순차번호(Sequence Number)를 사용하여 패킷의 순서를 보장한다. 확인응답(ACK)을 통해 패킷의 수신을 확인한다. 흐름제어와 혼잡제어를 통해 네트워크의 효율성을 관리한다. 연결 종료 (4-way handshaking):\nFIN과 ACK 패킷을 주고받으며 연결을 종료한다. 연결 설정: 3-way Handshake\n목적: 클라이언트와 서버 간의 연결을 설정하고 초기 시퀀스 번호를 동기화\n과정\nSYN (클라이언트 → 서버) 클라이언트가 연결을 시작하려고 SYN 패킷을 보낸다. SYN 플래그가 1로 설정된다. 초기 시퀀스 번호(ISN)를 포함한다. SYN-ACK (서버 → 클라이언트) 서버가 SYN을 받고 응답한다. SYN과 ACK 플래그가 모두 1로 설정된다. 서버의 ISN을 포함합니다. 확인 응답 번호는 클라이언트의 ISN + 1입니다. ACK (클라이언트 → 서버) 클라이언트가 서버의 응답을 확인합니다. ACK 플래그가 1로 설정됩니다. 확인 응답 번호는 서버의 ISN + 1입니다. 이 과정이 완료되면 연결이 설정되고 데이터 전송이 시작될 수 있다. 데이터 전송\n연결이 설정된 후, TCP는 다음과 같은 방식으로 데이터를 전송한다:\n세그먼트 분할: 큰 데이터를 작은 조각(세그먼트)으로 나눈다. 순서 번호 부여: 각 세그먼트에 번호를 매겨 순서를 보장한다. 확인 응답: 수신자는 받은 데이터에 대해 확인 응답을 보낸다. 재전송: 손실된 데이터는 자동으로 재전송된다. 연결 종료: 4-way Handshake\n목적: 클라이언트와 서버 간의 연결을 안전하게 종료한다.\n과정\nFIN (클라이언트 → 서버) 클라이언트가 연결 종료를 요청한다. FIN 플래그가 1로 설정된다. ACK (서버 → 클라이언트) 서버가 FIN을 받았음을 확인한다. ACK 플래그가 1로 설정된다. 이 시점에서 클라이언트→서버 방향의 연결이 닫힌다.\n3.FIN (서버 → 클라이언트) 서버가 모든 데이터 전송을 완료하고 연결 종료를 요청한다. FIN 플래그가 1로 설정된다. ACK (클라이언트 → 서버) 클라이언트가 서버의 FIN을 확인한다. ACK 플래그가 1로 설정된다. 이 과정이 완료되면 연결이 완전히 종료된다. 클라이언트는 마지막 ACK 전송 후 일정 시간 (일반적으로 2MSL) 동안 TIME_WAIT 상태를 유지하여 지연된 패킷을 처리한다. 데이터를 세그먼트로 나누는 이유 네트워크 제한 사항 준수 MTU(Maximum Transmission Unit) 제한: 네트워크 계층 프로토콜마다 MTU가 다르며, TCP는 이를 초과하지 않도록 데이터를 분할한다. 효율적인 전송: 큰 데이터 스트림을 작은 세그먼트로 나누어 네트워크 패킷에 맞게 전송한다. 신뢰성 향상 오류 처리: 작은 세그먼트로 나누면 오류 발생 시 해당 세그먼트만 재전송할 수 있어 효율적이다. 순서 보장: 각 세그먼트에 시퀀스 번호를 할당하여 수신 측에서 올바른 순서로 재조립할 수 있다. 흐름 제어 및 혼잡 제어 수신자 처리 능력 고려: 세그먼트 단위로 전송함으로써 수신자의 처리 능력에 맞춰 데이터 전송 속도를 조절할 수 있다. 네트워크 상태 대응: 세그먼트 단위로 전송하면 네트워크 혼잡 상황에 더 유연하게 대응할 수 있다. 세그먼트로 나누는 데이터가 에러를 감지하는 방법 TCP는 세그먼트로 나눈 데이터의 에러를 감지하기 위해 다음과 같은 방법들을 사용한다:\n체크섬(Checksum)\n각 세그먼트에는 16비트 체크섬 필드가 포함된다. 송신자는 데이터를 기반으로 체크섬을 계산하여 세그먼트에 포함시킨다. 수신자는 받은 세그먼트의 체크섬을 다시 계산하여 송신자의 체크섬과 비교한다. 두 체크섬이 일치하지 않으면 해당 세그먼트는 손상된 것으로 간주하고 폐기한다. 시퀀스 번호(Sequence Numbers)\nTCP는 각 데이터 세그먼트에 고유한 시퀀스 번호를 할당한다. 이를 통해 수신자는 데이터의 순서를 확인하고 누락된 세그먼트를 감지할 수 있다. 순서가 맞지 않는 세그먼트를 받으면 에러로 간주한다. 확인 응답(Acknowledgements)\n수신자는 성공적으로 받은 데이터에 대해 확인 응답(ACK)을 보낸다. 송신자는 일정 시간 내에 ACK를 받지 못하면 해당 세그먼트가 손실되었다고 판단한다. 중복된 ACK를 연속으로 받으면 특정 세그먼트의 손실을 감지할 수 있다. 참고 및 출처 ","wordCount":"787","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-02T04:21:00Z","dateModified":"2024-10-02T04:21:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/>Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/protocol/>Network Protocol</a></div><h1 class="post-title entry-hint-parent">TCP</h1><div class=post-description>TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜</div><div class=post-meta><span title='2024-10-02 04:21:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;787 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#tcp-transmission-control-protocol>TCP (Transmission Control Protocol)</a><ul><li><a href=#주요-특징>주요 특징</a></li><li><a href=#장점>장점</a></li><li><a href=#동작-방식>동작 방식</a></li><li><a href=#데이터를-세그먼트로-나누는-이유>데이터를 세그먼트로 나누는 이유</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=tcp-transmission-control-protocol>TCP (Transmission Control Protocol)<a hidden class=anchor aria-hidden=true href=#tcp-transmission-control-protocol>#</a></h2><p>인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로, IP(Internet Protocol)와 함께 TCP/IP로 널리 알려져 있다.<br>TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜이다.</p><p>OSI 7계층에서 TCP는 전송 계층(Transport Layer)인 4계층에 위치하며,<br>TCP/IP 4계층 모델에서도 마찬가지로 전송 계층에 해당한다.<br>이 위치에서 TCP는 데이터의 신뢰성 있는 전송을 담당하는 핵심적인 역할을 수행한다.</p><p>TCP의 가장 중요한 특징은 연결 지향성과 신뢰성이다.<br>연결 지향성이란 데이터를 주고받기 전에 먼저 연결을 설정하는 것을 의미하는데, 이는 3-way handshaking이라는 과정을 통해 이루어진다.<br>신뢰성은 데이터가 손실없이 순서대로 전달되는 것을 보장한다는 의미이다.</p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li><strong>신뢰성 보장</strong>: TCP는 데이터가 정확하게, 순서대로, 그리고 오류 없이 전달되도록 보장한다.</li><li><strong>연결 지향적</strong>: 데이터 전송 전에 연결을 설정하고, 전송 후에는 연결을 종료한다.</li><li><strong>흐름 제어</strong>: 수신자의 처리 능력에 맞춰 데이터 전송 속도를 조절한다.</li><li><strong>혼잡 제어</strong>: 네트워크의 혼잡 상태를 감지하고 데이터 전송 속도를 조절한다.</li><li><strong>전이중(Full-Duplex) 통신</strong>: 양방향으로 동시에 데이터 전송이 가능하다.</li><li><strong>점대점(Point to Point) 통신</strong>: 정확히 2개의 종단점을 가진다.</li></ol><blockquote><p>Window Size:<br>한 번에 전송할 수 있는 데이터의 양을 조절하는 값.<br>이는 흐름제어와 직접적인 관련이 있으며, 수신측의 처리 능력에 따라 동적으로 조절된다.</p></blockquote><blockquote><p>MSS(Maximum Segment Size):<br>TCP가 한 번에 전송할 수 있는 최대 세그먼트 크기를 의미한다.<br>이는 네트워크의 특성을 고려하여 설정된다.</p></blockquote><blockquote><p>타임아웃과 재전송:<br>일정 시간 내에 ACK를 받지 못하면 패킷 손실로 간주하고 재전송을 수행한다.<br>이는 데이터의 신뢰성을 보장하는 중요한 메커니즘이다.</p></blockquote><blockquote><p>Slow Start:<br>네트워크 혼잡을 방지하기 위해 처음에는 적은 양의 데이터부터 전송을 시작한다.</p></blockquote><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>신뢰성 있는 데이터 전송</li><li>순서 보장</li><li>오류 검출 및 복구</li><li>흐름 제어를 통한 효율적인 네트워크 사용</li><li>다양한 애플리케이션 지원 (웹 브라우징, 이메일, 파일 전송 등)</li></ol><h3 id=동작-방식>동작 방식<a hidden class=anchor aria-hidden=true href=#동작-방식>#</a></h3><pre class=mermaid>%%{init: {&#39;theme&#39;: &#39;default&#39;, &#39;themeVariables&#39;: { &#39;fontSize&#39;: &#39;12px&#39;}, &#39;flowchart&#39;: {&#39;width&#39;: 400, &#39;height&#39;: 250, &#39;diagramPadding&#39;: 8}}}%%
sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: 3-way Handshake (연결 수립)
    Client-&gt;&gt;Server: SYN (Seq = x)
    Server--&gt;&gt;Client: SYN + ACK (Seq = y, Ack = x+1)
    Client-&gt;&gt;Server: ACK (Seq = x+1, Ack = y+1)
    
    Note over Client,Server: 데이터 전송
    
    Note over Client,Server: 4-way Handshake (연결 종료)
    Client-&gt;&gt;Server: FIN
    Server--&gt;&gt;Client: ACK
    Note right of Server: CLOSE_WAIT 상태
    Server-&gt;&gt;Client: FIN
    Note left of Client: TIME_WAIT 상태
    Client--&gt;&gt;Server: ACK
</pre><ol start=2><li><p>데이터 전송:</p><ul><li>순차번호(Sequence Number)를 사용하여 패킷의 순서를 보장한다.</li><li>확인응답(ACK)을 통해 패킷의 수신을 확인한다.</li><li>흐름제어와 혼잡제어를 통해 네트워크의 효율성을 관리한다.</li></ul></li><li><p>연결 종료 (4-way handshaking):</p><ul><li>FIN과 ACK 패킷을 주고받으며 연결을 종료한다.</li></ul></li><li><p>연결 설정: 3-way Handshake<br>목적: 클라이언트와 서버 간의 연결을 설정하고 초기 시퀀스 번호를 동기화<br>과정</p><ol><li>SYN (클라이언트 → 서버)<ul><li>클라이언트가 연결을 시작하려고 SYN 패킷을 보낸다.</li><li>SYN 플래그가 1로 설정된다.</li><li>초기 시퀀스 번호(ISN)를 포함한다.</li></ul></li><li>SYN-ACK (서버 → 클라이언트)<ul><li>서버가 SYN을 받고 응답한다.</li><li>SYN과 ACK 플래그가 모두 1로 설정된다.</li><li>서버의 ISN을 포함합니다.</li><li>확인 응답 번호는 클라이언트의 ISN + 1입니다.</li></ul></li><li>ACK (클라이언트 → 서버)<ul><li>클라이언트가 서버의 응답을 확인합니다.</li><li>ACK 플래그가 1로 설정됩니다.</li><li>확인 응답 번호는 서버의 ISN + 1입니다.</li></ul></li></ol><ul><li>이 과정이 완료되면 연결이 설정되고 데이터 전송이 시작될 수 있다.</li></ul></li><li><p>데이터 전송<br>연결이 설정된 후, TCP는 다음과 같은 방식으로 데이터를 전송한다:</p><ol><li><strong>세그먼트 분할</strong>: 큰 데이터를 작은 조각(세그먼트)으로 나눈다.</li><li><strong>순서 번호 부여</strong>: 각 세그먼트에 번호를 매겨 순서를 보장한다.</li><li><strong>확인 응답</strong>: 수신자는 받은 데이터에 대해 확인 응답을 보낸다.</li><li><strong>재전송</strong>: 손실된 데이터는 자동으로 재전송된다.</li></ol></li><li><p>연결 종료: 4-way Handshake<br>목적: 클라이언트와 서버 간의 연결을 안전하게 종료한다.<br>과정</p><ol><li>FIN (클라이언트 → 서버)<ul><li>클라이언트가 연결 종료를 요청한다.</li><li>FIN 플래그가 1로 설정된다.</li></ul></li><li>ACK (서버 → 클라이언트)<ul><li>서버가 FIN을 받았음을 확인한다.</li><li>ACK 플래그가 1로 설정된다.</li><li>이 시점에서 클라이언트→서버 방향의 연결이 닫힌다.<br>3.FIN (서버 → 클라이언트)</li><li>서버가 모든 데이터 전송을 완료하고 연결 종료를 요청한다.</li><li>FIN 플래그가 1로 설정된다.</li></ul></li><li>ACK (클라이언트 → 서버)<ul><li>클라이언트가 서버의 FIN을 확인한다.</li><li>ACK 플래그가 1로 설정된다.</li></ul></li></ol><ul><li>이 과정이 완료되면 연결이 완전히 종료된다.</li><li>클라이언트는 마지막 ACK 전송 후 일정 시간 (일반적으로 2MSL) 동안 TIME_WAIT 상태를 유지하여 지연된 패킷을 처리한다.</li></ul></li></ol><h3 id=데이터를-세그먼트로-나누는-이유>데이터를 세그먼트로 나누는 이유<a hidden class=anchor aria-hidden=true href=#데이터를-세그먼트로-나누는-이유>#</a></h3><ol><li>네트워크 제한 사항 준수<ol><li>MTU(Maximum Transmission Unit) 제한: 네트워크 계층 프로토콜마다 MTU가 다르며, TCP는 이를 초과하지 않도록 데이터를 분할한다.</li><li>효율적인 전송: 큰 데이터 스트림을 작은 세그먼트로 나누어 네트워크 패킷에 맞게 전송한다.</li></ol></li><li>신뢰성 향상<ol><li>오류 처리: 작은 세그먼트로 나누면 오류 발생 시 해당 세그먼트만 재전송할 수 있어 효율적이다.</li><li>순서 보장: 각 세그먼트에 시퀀스 번호를 할당하여 수신 측에서 올바른 순서로 재조립할 수 있다.</li></ol></li><li>흐름 제어 및 혼잡 제어<ol><li>수신자 처리 능력 고려: 세그먼트 단위로 전송함으로써 수신자의 처리 능력에 맞춰 데이터 전송 속도를 조절할 수 있다.</li><li>네트워크 상태 대응: 세그먼트 단위로 전송하면 네트워크 혼잡 상황에 더 유연하게 대응할 수 있다.</li></ol></li></ol><h4 id=세그먼트로-나누는-데이터가-에러를-감지하는-방법>세그먼트로 나누는 데이터가 에러를 감지하는 방법<a hidden class=anchor aria-hidden=true href=#세그먼트로-나누는-데이터가-에러를-감지하는-방법>#</a></h4><p>TCP는 세그먼트로 나눈 데이터의 에러를 감지하기 위해 다음과 같은 방법들을 사용한다:</p><ol><li><p>체크섬(Checksum)</p><ul><li>각 세그먼트에는 16비트 체크섬 필드가 포함된다.</li><li>송신자는 데이터를 기반으로 체크섬을 계산하여 세그먼트에 포함시킨다.</li><li>수신자는 받은 세그먼트의 체크섬을 다시 계산하여 송신자의 체크섬과 비교한다.</li><li>두 체크섬이 일치하지 않으면 해당 세그먼트는 손상된 것으로 간주하고 폐기한다.</li></ul></li><li><p>시퀀스 번호(Sequence Numbers)</p><ul><li>TCP는 각 데이터 세그먼트에 고유한 시퀀스 번호를 할당한다.</li><li>이를 통해 수신자는 데이터의 순서를 확인하고 누락된 세그먼트를 감지할 수 있다.</li><li>순서가 맞지 않는 세그먼트를 받으면 에러로 간주한다.</li></ul></li><li><p>확인 응답(Acknowledgements)</p><ul><li>수신자는 성공적으로 받은 데이터에 대해 확인 응답(ACK)을 보낸다.</li><li>송신자는 일정 시간 내에 ACK를 받지 못하면 해당 세그먼트가 손실되었다고 판단한다.</li><li>중복된 ACK를 연속으로 받으면 특정 세그먼트의 손실을 감지할 수 있다.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-and-communications/>Networking-and-Communications</a></li><li><a href=https://buenhyden.github.io/tags/protocol/>Protocol</a></li><li><a href=https://buenhyden.github.io/tags/tcp/>TCP</a></li><li><a href=https://buenhyden.github.io/tags/transmission-control-protocol/>Transmission-Control-Protocol</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/networking-and-communications/media-access-control-address/><span class=title>« Prev</span><br><span>Media Access Control Address (MAC Address)</span>
</a><a class=next href=https://buenhyden.github.io/posts/networking-and-communications/protocol/udp/><span class=title>Next »</span><br><span>UDP</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>