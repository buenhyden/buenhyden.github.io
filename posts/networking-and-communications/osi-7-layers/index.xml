<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Network Layer - OSI 7 계층</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/</link><description>Recent content in Network Layer - OSI 7 계층 on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 25 Sep 2024 02:03:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/index.xml" rel="self" type="application/rss+xml"/><item><title>OSI 7 Layers - 1. Phygical Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-1-phygical-layer/</link><pubDate>Wed, 25 Sep 2024 07:18:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-1-phygical-layer/</guid><description>
&lt;h2>Physical Layer (물리적 계층)&lt;/h2>&lt;p>Physical Layer(물리 계층)는 네트워크 통신의 가장 기본적인 계층으로, 데이터의 물리적 전송을 담당한다.&lt;/p>
&lt;p>OSI 모델의 최하위 계층으로, 실제 데이터 비트를 물리적 매체를 통해 전송하는 역할을 한다. 이 계층은 데이터를 전기적, 광학적, 또는 전자기적 신호로 변환하여 전송한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/osi_model_physical_layer_1.png"
alt="Physical Layer"
title="Physical Layer"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>주요 역할과 기능&lt;/h3>&lt;ol>
&lt;li>
&lt;p>데이터의 물리적 전송:&lt;br>
컴퓨터의 0과 1로 이루어진 디지털 데이터를 전기 신호, 빛, 전파 등의 물리적 신호로 변환한다.&lt;br>
예를 들어:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>디지털 데이터: 1 0 1 1 0
물리적 신호: 높음-낮음-높음-높음-낮음 (전압 변화)&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>전송 매체 관리:&lt;br>
다양한 종류의 케이블과 무선 매체를 통해 데이터를 전송한다.&lt;/p>
&lt;ol>
&lt;li>유선 매체:
&lt;ul>
&lt;li>트위스트 페어 케이블 (일반적인 랜선)&lt;/li>
&lt;li>동축 케이블 (케이블 TV에서 사용)&lt;/li>
&lt;li>광섬유 케이블 (빛을 사용한 고속 통신)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>무선 매체:
&lt;ul>
&lt;li>전파 (Wi-Fi, 휴대전화)&lt;/li>
&lt;li>적외선 (TV 리모컨)&lt;/li>
&lt;li>마이크로파 (위성 통신)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>비트 동기화: 송신자와 수신자 간의 비트 전송 타이밍을 맞춘다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터 속도 제어: 초당 전송되는 비트 수를 관리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>물리적 토폴로지 정의: 네트워크의 물리적 배치 방식을 지정한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>데이터 단위&lt;/h3>&lt;p>데이터를 비트(Bit) 단위로 처리하며, 이 비트들은 전기 신호, 빛, 또는 전파 등의 물리적인 형태로 변환되어 전송된다.&lt;/p>
&lt;p>비트 스트림은 다음과 같은 구조로 구성된다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span class="line">&lt;span class="cl">[프리앰블] [데이터 비트] [포스트앰블]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>각 필드의 역할은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>프리앰블 (Preamble)
&lt;ul>
&lt;li>수신자의 비트 동기화를 위한 특별한 비트 패턴&lt;/li>
&lt;li>일반적으로 반복되는 패턴 사용 (예: &amp;ldquo;10101010&amp;rdquo;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 비트 (Data Bits)
&lt;ul>
&lt;li>실제 전송하고자 하는 정보&lt;/li>
&lt;li>인코딩 방식에 따라 변환됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>포스트앰블 (Postamble)
&lt;ul>
&lt;li>전송 종료를 나타내는 비트 패턴&lt;/li>
&lt;li>프레임 간 구분을 위해 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>디지털 데이터를 물리적 신호(전기, 광학, 무선)로 변환한다.&lt;/li>
&lt;li>수신 시 물리적 신호를 디지털 데이터(0과 1)로 변환하여 상위 계층으로 전달한다.&lt;/li>
&lt;/ol>
&lt;h4>신호 변환과 인코딩 방식&lt;/h4>&lt;p>물리 계층에서는 디지털 인코딩을 통하여 이진 데이터(0과 1)를 물리적 신호로 변환한다.&lt;/p>
&lt;ol>
&lt;li>단극성 인코딩 (Unipolar Encoding)&lt;br>
가장 단순한 형태의 인코딩 방식.&lt;br>
비트 0은 전압 없음(0V)으로 표현된다.&lt;br>
장점: 구현이 간단함&lt;br>
단점: DC 성분이 있어 전력 소비가 크고, 클록 복구가 어려움&lt;/li>
&lt;li>NRZ (Non-Return to Zero) 인코딩
&lt;ol>
&lt;li>NRZ-L (Level)&lt;br>
비트값에 따라 전압 레벨이 결정된다.&lt;/li>
&lt;li>NRZ-I (Invert)&lt;br>
비트 1에서 전압 레벨이 반전되고, 비트 0에서는 이전 레벨을 유지된다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Manchester 인코딩&lt;br>
비트당 두 개의 신호 레벨을 사용하며, 각 비트 주기의 중간에서 전이가 발생한다. IEEE 802.3 (이더넷)에서 사용된다.&lt;br>
장점:
&lt;ul>
&lt;li>클록 정보가 데이터에 포함됨&lt;/li>
&lt;li>DC 성분이 없음&lt;/li>
&lt;li>오류 검출이 용이함&lt;br>
단점:&lt;/li>
&lt;li>대역폭 요구사항이 높음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>차동 Manchester 인코딩&lt;br>
Manchester 인코딩의 변형으로, 비트값에 따라 전이의 유무가 결정된다.&lt;/li>
&lt;li>MLT-3 (Multi-Level Transition) 인코딩&lt;br>
세 가지 신호 레벨(+V, 0, -V)을 사용하며, 비트 1에서만 다음 레벨로 순차적으로 전이된다.&lt;/li>
&lt;li>B8ZS (Bipolar with 8-Zero Substitution)&lt;br>
길다란 0의 시퀀스를 특별한 패턴으로 대체하여 클록 복구를 용이하게 한다.&lt;/li>
&lt;/ol>
&lt;p>각 인코딩 방식은 특정한 용도와 환경에 최적화되어 있다.&lt;br>
예를 들어:&lt;/p>
&lt;ul>
&lt;li>고속 네트워크: MLT-3 (100Base-TX)&lt;/li>
&lt;li>이더넷: Manchester (10Base-T)&lt;/li>
&lt;li>장거리 통신: B8ZS (T1 회선)&lt;/li>
&lt;/ul>
&lt;p>인코딩 방식 구현 예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 단극성 인코딩 (Unipolar Encoding)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">unipolar_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 5V for bit 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 0V for bit 0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># NRZ-L (Level)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">nrz_l_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># +5V&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># -5V&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># NRZ-I (Invert)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">nrz_i_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="c1"># 시작 레벨&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">current_level&lt;/span> &lt;span class="c1"># 레벨 반전&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_level&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Manchester 인코딩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">manchester_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1"># 하향 전이&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1"># 상향 전이&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 차동 Manchester 인코딩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">differential_manchester_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">previous_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 항상 중간에서 전이 발생&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">previous_level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">previous_level&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">previous_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">previous_level&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 시작에서 전이 후 중간에서도 전이&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">previous_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">previous_level&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">previous_level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">previous_level&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># MLT-3 (Multi-Level Transition) 인코딩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">mlt3_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">levels&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 가능한 신호 레벨&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">current_index&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">levels&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">current_index&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># B8ZS (Bipolar with 8-Zero Substitution)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">b8zs_encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bits&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zero_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_pulse&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># 마지막 펄스의 극성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bit&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zero_count&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">zero_count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 8개의 0을 특별한 패턴으로 대체&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">violation_pattern&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">last_pulse&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">last_pulse&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">last_pulse&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">last_pulse&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">violation_pattern&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zero_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_pulse&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">last_pulse&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">signal&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">last_pulse&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zero_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">signal&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>주의 사항과 고려 사항&lt;/h3>&lt;p>물리 계층을 설계하고 운영할 때 다음 사항들을 고려해야 한다:&lt;/p>
&lt;ol>
&lt;li>신호 감쇠 (Attenuation)&lt;br>
거리에 따른 신호 세기 감소를 고려해야 한다.&lt;/li>
&lt;li>간섭 (Interference)
&lt;ul>
&lt;li>전자기적 간섭&lt;/li>
&lt;li>크로스토크&lt;/li>
&lt;li>외부 노이즈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>케이블 설치와 유지보수
&lt;ul>
&lt;li>최대 케이블 길이 준수&lt;/li>
&lt;li>적절한 접지&lt;/li>
&lt;li>물리적 보호&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비용과 확장성
&lt;ul>
&lt;li>초기 설치 비용&lt;/li>
&lt;li>유지보수 비용&lt;/li>
&lt;li>향후 확장 가능성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>OSI 7 Layers - 2. DataLink Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/</link><pubDate>Wed, 25 Sep 2024 07:17:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/</guid><description>
&lt;h2>DataLink Layer (데이터 연결 계층)&lt;/h2>&lt;p>OSI 7계층의 &lt;strong>Data Link Layer&lt;/strong> (데이터 연결 계층)은 OSI 모델의 두 번째 계층으로, 물리적 네트워크에서 노드 간의 데이터 전송을 담당한다.&lt;br>
이 계층은 상위 계층에서 받은 패킷을 프레임으로 캡슐화하고, 물리적 주소를 추가하여 데이터 전송을 관리한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/data_link_layer_osi_model.png"
alt="Data Link Layer"
title="Data Link Layer"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>기능&lt;/h3>&lt;ol>
&lt;li>프레이밍 (Framing):&lt;br>
패킷을 프레임으로 나누어 전송하며, 각 프레임의 시작과 끝을 정의하는 비트 패턴을 추가한다.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>프레이밍 (Framing)&lt;br>
데이터링크 계층에서의 프레이밍은 상위 계층에서 받은 데이터를 물리적 전송에 적합한 크기의 프레임(frame)으로 나누는 과정이다. 각 프레임은 데이터를 안전하게 전달하기 위한 추가 정보들을 포함하게 된다.&lt;/p>
&lt;p>프레임의 구조와 각 부분의 역할&lt;br>
일반적인 프레임은 다음과 같은 구조를 가진다:&lt;/p>
&lt;ul>
&lt;li>시작 구분자(Start Delimiter): 프레임의 시작을 알리는 특별한 비트 패턴이다.&lt;/li>
&lt;li>헤더(Header): 송신자와 수신자의 MAC 주소, 프레임 유형, 제어 정보 등을 포함한다.&lt;/li>
&lt;li>페이로드(Payload): 실제 전송하고자 하는 데이터가 들어있는 부분.&lt;/li>
&lt;li>트레일러(Trailer): 오류 검출을 위한 체크섬(CRC)과 프레임 끝을 나타내는 구분자를 포함한다.&lt;/li>
&lt;/ul>
&lt;p>프레이밍 방식의 종류&lt;br>
프레이밍에는 여러 가지 방식이 있으며, 각각의 특징을 이해하는 것이 중요하다:&lt;/p>
&lt;ul>
&lt;li>문자 기반 프레이밍
&lt;ul>
&lt;li>특별한 문자를 사용하여 프레임의 시작과 끝을 표시한다.&lt;/li>
&lt;li>예를 들어, ASCII 문자의 STX(Start of Text)와 ETX(End of Text)를 사용할 수 있다. 이는 간단하지만, 데이터 안에 이러한 특별 문자가 포함되어 있을 경우 문제가 될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비트 스터핑(Bit Stuffing)
&lt;ul>
&lt;li>특정 비트 패턴을 프레임의 경계로 사용하고, 데이터 내에 이러한 패턴이 나타나지 않도록 추가 비트를 삽입한다.&lt;/li>
&lt;li>예를 들어, 여섯 개의 연속된 1을 경계로 사용한다면, 데이터 내에서 다섯 개의 연속된 1이 나타날 때마다 0을 삽입한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>바이트 수 표시&lt;br>
프레임의 시작 부분에 전체 프레임의 길이를 명시한다.&lt;br>
이는 단순하고 효율적이지만, 길이 필드가 손상될 경우 프레임 전체를 잃을 수 있다.&lt;/p>
&lt;p>프레이밍의 중요성과 이점
- 신뢰성 있는 전송: 프레이밍은 데이터의 경계를 명확히 하고 오류를 검출할 수 있게 해준다.
- 흐름 제어와 오류 제어: 각 프레임 단위로 흐름 제어와 오류 제어를 수행할 수 있다. 문제가 발생하면 해당 프레임만 재전송하면 된다.
- 효율적인 네트워크 사용: 적절한 크기의 프레임으로 나눔으로써 네트워크 자원을 효율적으로 사용할 수 있다.&lt;/p>
&lt;p>프레이밍 관련 주의사항&amp;gt;
- 프레임 크기: 너무 크면 오류 가능성이 높아지고, 너무 작으면 오버헤드가 증가한다. 따라서 적절한 크기 선택이 중요하다.&lt;br>
오버헤드 고려: 각 프레임마다 헤더와 트레일러가 추가되므로, 이로 인한 오버헤드를 고려해야 한다.&lt;br>
프레임 동기화: 수신자가 프레임의 시작과 끝을 정확히 인식할 수 있도록 해야 한다.&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>```python
class Frame:
def __init__(self):
self.start_delimiter = 0x7E # 프레임 시작 표시
self.destination_address = None # 목적지 MAC 주소
self.source_address = None # 출발지 MAC 주소
self.data = None # 실제 데이터
self.fcs = None # Frame Check Sequence
self.end_delimiter = 0x7E # 프레임 종료 표시
```
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>물리적 주소 지정 (Physical Addressing)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>각 프레임에 송신자와 수신자의 MAC 주소를 포함시킨다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>오류 감지 및 수정 (Error Detection and Correction)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>체크섬, CRC(순환 중복 검사) 등을 사용하여 오류를 감지하고, 오류 발생 시 재전송 요청을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>CRC(Cyclic Redundancy Check)&lt;br>
데이터의 무결성을 확인하기 위한 오류 감지 코드.&lt;/p>
&lt;ul>
&lt;li>목적
&lt;ul>
&lt;li>데이터 전송 중 발생할 수 있는 오류를 감지한다.&lt;/li>
&lt;li>저장 장치에서 데이터의 정확성을 확인한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>작동 방식
&lt;ol>
&lt;li>데이터를 이진 다항식으로 취급한다.&lt;/li>
&lt;li>미리 정의된 생성 다항식으로 데이터를 나눈다.&lt;/li>
&lt;li>나눗셈의 나머지가 CRC 체크섬이 된다.&lt;/li>
&lt;li>이 체크섬을 데이터에 추가하여 전송한다.&lt;/li>
&lt;li>수신자는 같은 과정을 반복하여 체크섬을 계산한다.&lt;/li>
&lt;li>계산된 체크섬과 받은 체크섬을 비교한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>장점
&lt;ul>
&lt;li>구현이 간단하다.&lt;/li>
&lt;li>하드웨어로 쉽게 구현할 수 있다.&lt;/li>
&lt;li>일반적인 전송 오류를 효과적으로 감지한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>활용
&lt;ul>
&lt;li>네트워크 통신에서 데이터 무결성 확인.&lt;/li>
&lt;li>저장 장치에서 데이터 정확성 검증&lt;/li>
&lt;li>다양한 통신 프로토콜에서 오류 감지에 사용.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>
&lt;p>&lt;strong>흐름 제어 (Flow Control)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 조절한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>매체 접근 제어 (Media Access Control)&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>여러 장치가 동일한 전송 매체를 사용할 때 충돌을 방지하기 위한 규칙을 설정한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;/h3>&lt;ul>
&lt;li>&lt;strong>복잡성&lt;/strong>: 데이터 링크 계층은 하드웨어의 복잡성을 숨기고, 상위 계층에 간단한 인터페이스를 제공한다.&lt;/li>
&lt;li>&lt;strong>하위 계층 의존성&lt;/strong>: 물리적 계층에 의존하여 데이터를 전송하며, 물리적 매체의 특성에 따라 다르게 동작할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4>두 개의 서브 레이어&lt;/h4>&lt;p>데이터 링크 계층은 두 개의 부계층으로 나뉜다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[데이터링크 계층]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── LLC (Logical Link Control) - 상위 계층
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── MAC (Media Access Control) - 하위 계층&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>LLC(Logical Link Control) 계층&lt;/h5>&lt;p>데이터링크 계층의 상위 계층으로, 네트워크 계층과 MAC 계층 사이의 인터페이스 역할을 한다.&lt;br>
프로토콜 다중화 및 흐름 제어 기능 제공한다.&lt;/p>
&lt;p>주요 기능:&lt;/p>
&lt;ul>
&lt;li>다중화 메커니즘 제공 (여러 네트워크 프로토콜이 동일한 네트워크 매체를 공유할 수 있게 함)&lt;/li>
&lt;li>흐름 제어&lt;/li>
&lt;li>오류 관리&lt;/li>
&lt;li>프레임 동기화&lt;/li>
&lt;/ul>
&lt;h5>MAC(Media Access Control) 계층&lt;/h5>&lt;p>데이터링크 계층의 하위 계층으로, 물리적 매체와 직접 상호작용하는 하드웨어를 제어한다.&lt;br>
물리적 매체 접근 관리 및 주소 지정&lt;/p>
&lt;p>MAC 주소 예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>00:1A:2B:3C:4D:5E&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>주요 기능:&lt;/p>
&lt;ul>
&lt;li>프레임 구분 및 인식&lt;/li>
&lt;li>주소 지정 (MAC 주소 사용)&lt;/li>
&lt;li>데이터 전송의 투명성 제공&lt;/li>
&lt;li>오류 보호 (프레임 체크 시퀀스 생성 및 확인)&lt;/li>
&lt;li>물리적 전송 매체에 대한 접근 제어&lt;/li>
&lt;/ul>
&lt;h3>데이터 단위와 기본 구조&lt;/h3>&lt;p>데이터 연결 계층의 기본 데이터 단위는 프레임(Frame)이다.&lt;/p>
&lt;p>기본 구조는 이와 같다:&lt;/p>
&lt;ul>
&lt;li>헤더(Header): MAC 주소 및 제어 정보 포함&lt;/li>
&lt;li>데이터(Data): 상위 계층에서 받은 패킷&lt;/li>
&lt;li>트레일러(Trailer): 오류 검출 정보 포함&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span class="line">&lt;span class="cl">[프레임 시작 구분자] [주소 필드] [제어 필드] [데이터 필드] [FCS] [프레임 종료 구분자]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>각 필드의 역할은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>프레임 구분자
&lt;ul>
&lt;li>8비트 크기&lt;/li>
&lt;li>프레임의 시작과 끝을 표시&lt;/li>
&lt;li>일반적으로 특별한 비트 패턴 사용 (예: 10101011)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>주소 필드
&lt;ul>
&lt;li>MAC 주소 포함 (출발지, 목적지)&lt;/li>
&lt;li>각각 48비트 길이 (예: 00:1A:2B:3C:4D:5E)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>제어 필드
&lt;ul>
&lt;li>프레임 종류 식별&lt;/li>
&lt;li>순서 번호&lt;/li>
&lt;li>흐름 제어 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>데이터 필드
&lt;ul>
&lt;li>실제 전송할 데이터&lt;/li>
&lt;li>일반적으로 46~1500바이트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FCS(Frame Check Sequence)
&lt;ul>
&lt;li>오류 검출을 위한 체크섬&lt;/li>
&lt;li>CRC-32 알고리즘 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>상위 계층에서 패킷을 수신하면 이를 프레임으로 캡슐화한다.&lt;/li>
&lt;li>각 프레임에 송신자와 수신자의 MAC 주소를 추가하고, 오류 검출 정보를 포함시킨다.&lt;/li>
&lt;li>프레임을 물리적 계층에 전달하여 전송한다.&lt;/li>
&lt;li>수신 측에서는 비트를 받아 프레임으로 조립하고, 오류를 검사한 후 상위 계층으로 전달한다.&lt;/li>
&lt;/ol>
&lt;h3>주의 사항&lt;/h3>&lt;ul>
&lt;li>충돌 관리: 여러 장치가 동일한 매체를 사용할 때 충돌이 발생할 수 있으므로 이를 관리해야 한다.&lt;/li>
&lt;li>신뢰성 보장: 데이터 링크 계층은 신뢰성 있는 전송을 보장하기 위해 오류 감지 및 수정 기능이 필요하다.&lt;/li>
&lt;li>다양한 네트워크 기술 지원: Ethernet, Wi-Fi 등 다양한 기술에 따라 동작 방식이 달라질 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>주요 프로토콜과 기술&lt;/h3>&lt;h4>이더넷(Ethernet)&lt;/h4>&lt;p>컴퓨터 네트워크 기술 중 가장 널리 사용되는 근거리 통신망(LAN) 기술.&lt;/p>
&lt;p>이더넷은 CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 방식을 사용한다.&lt;br>
이를 실생활에 비유하면 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>다른 사람이 말하고 있는지 확인 (Carrier Sense)&lt;/li>
&lt;li>말하기 시작 (Multiple Access)&lt;/li>
&lt;li>다른 사람과 동시에 말했는지 확인 (Collision Detection)&lt;/li>
&lt;li>잠시 기다렸다가 다시 시도&lt;/li>
&lt;/ol>
&lt;p>이더넷(Ethernet) 프레임의 구조:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[프리앰블(8바이트)][목적지 MAC(6바이트)][출발지 MAC(6바이트)][타입(2바이트)][데이터(46-1500바이트)][체크섬(4바이트)]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>
#### 이더넷 프레임의 구조
이더넷 프레임은 데이터를 전송하기 위한 기본 단위:
```python
class EthernetFrame:
def __init__(self):
self.preamble = &amp;#34;10101010&amp;#34; * 7 # 동기화
self.sfd = &amp;#34;10101011&amp;#34; # 프레임 시작
self.dest_mac = &amp;#34;&amp;#34; # 목적지 MAC 주소
self.src_mac = &amp;#34;&amp;#34; # 출발지 MAC 주소
self.type = &amp;#34;&amp;#34; # 프로토콜 타입
self.data = &amp;#34;&amp;#34; # 실제 데이터
self.fcs = &amp;#34;&amp;#34; # 오류 검사&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>Preamble: 7바이트(56비트)의 특별한 패턴으로, 네트워크 장비들의 시계를 동기화하는 역할.&lt;/li>
&lt;li>SFD (Start Frame Delimiter): 1바이트(8비트)로, 실제 프레임의 시작을 알리는 표시. 프리앰블과 비슷하지만 마지막 비트가 다른 이 패턴은 &amp;ldquo;이제 진짜 데이터가 시작됩니다&amp;quot;라고 알리는 신호와 같다.&lt;/li>
&lt;li>Destination MAC Address (목적지 MAC 주소): 6바이트(48비트) 길이의 수신자 하드웨어 주소. 각 네트워크 장비는 이 주소를 보고 자신에게 온 프레임인지 판단한다. 예를 들어 &amp;ldquo;00:1A:2B:3C:4D:5E&amp;rdquo; 같은 형식을 가진다.&lt;/li>
&lt;li>Source MAC Address (출발지 MAC 주소): 역시 6바이트(48비트) 길이로, 보내는 장비의 하드웨어 주소. 응답이 필요할 때 이 주소로 회신할 수 있다.&lt;/li>
&lt;li>Type (또는 Length): 2바이트(16비트)로, 두 가지 용도로 사용된다:
&lt;ul>
&lt;li>1500보다 큰 값: 상위 계층 프로토콜의 종류를 나타낸다 (예: IPv4는 0x0800).&lt;/li>
&lt;li>1500이하의 값: 데이터 필드의 길이를 나타낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Data (페이로드): 46~1500바이트의 실제 전송할 데이터. 최소 46바이트가 되지 않으면 패딩(padding)을 추가하여 채운다. 이는 너무 작은 프레임으로 인한 충돌 감지의 어려움을 방지하기 위함.&lt;/li>
&lt;li>FCS (Frame Check Sequence): 4바이트(32비트)의 오류 검사 코드. CRC(Cyclic Redundancy Check) 알고리즘을 사용하여 프레임이 전송 중에 손상되었는지 확인.&lt;/li>
&lt;/ul>
&lt;p>이더넷의 장점과 특징:&lt;/p>
&lt;ol>
&lt;li>설치와 유지보수의 용이성
&lt;ul>
&lt;li>새로운 기기 추가가 쉬움&lt;/li>
&lt;li>문제 발견이 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장성:
&lt;ul>
&lt;li>네트워크 확장이 용이&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이더넷의 현대적 발전:&lt;/p>
&lt;ol>
&lt;li>Power over Ethernet (PoE):&lt;br>
네트워크 케이블을 통해 전력도 함께 공급&lt;/li>
&lt;li>에너지 효율적 이더넷:&lt;br>
사용하지 않을 때 전력 소비 감소&lt;/li>
&lt;/ol>
&lt;p>미래 발전 방향:&lt;/p>
&lt;ol>
&lt;li>속도 향상:&lt;br>
현재 400Gbps 이더넷까지 개발되어 있으며, 더 빠른 속도를 위한 연구가 진행 중.&lt;/li>
&lt;li>스마트 네트워킹:&lt;br>
인공지능과 결합하여 더 효율적인 네트워크 관리가 가능해질 것으로 예상.&lt;/li>
&lt;/ol>
&lt;h4>PPP(Point-to-Point Protocol)&lt;/h4>&lt;p>두 스테이션 간의 통신을 담당하며 강력한 보안기능과 여러가지 네트워크 계층 프로토콜을 한꺼번에 지원한다.&lt;/p>
&lt;p>PPP(Point-to-Point Protocol)는 VPN(Virtual Private Network) 기술의 기초가 되었으며, 모바일 네트워크에도 PPP의 개념이 활용된다.&lt;/p>
&lt;p>연결 설정 과정은 다음과 같은 단계로 이루어진다:&lt;/p>
&lt;ol>
&lt;li>LCP(Link Control Protocol) 단계&lt;/li>
&lt;li>인증 단계 (선택사항)&lt;/li>
&lt;li>NCP(Network Control Protocol) 단계&lt;/li>
&lt;/ol>
&lt;p>PPP의 주요 구성 요소:&lt;/p>
&lt;ol>
&lt;li>LCP(Link Control Protocol): 링크를 설정하고 유지하는 역할을 담당한다.
&lt;ul>
&lt;li>최대 전송 단위(MTU) 설정&lt;/li>
&lt;li>인증 프로토콜 선택&lt;/li>
&lt;li>품질 모니터링 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>인증 프로토콜: 두 가지 주요 인증 방식을 제공한다:
&lt;ol>
&lt;li>PAP(Password Authentication Protocol)&lt;/li>
&lt;li>CHAP(Challenge Handshake Authentication Protocol)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>NCP(Network Control Protocol): 네트워크 계층 프로토콜을 설정한다.
&lt;ol>
&lt;li>IP 주소 할당&lt;/li>
&lt;li>DNS 서버 설정&lt;/li>
&lt;li>라우팅 정보 교환&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>PPP 프레임의 기본 구조:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">PPPFrame&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;01111110&amp;#39;&lt;/span> &lt;span class="c1"># 시작/끝 표시&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">address&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;FF&amp;#39;&lt;/span> &lt;span class="c1"># 브로드캐스트 주소&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">control&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;03&amp;#39;&lt;/span> &lt;span class="c1"># 제어 필드&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">protocol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span> &lt;span class="c1"># 상위 계층 프로토콜&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">payload&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span> &lt;span class="c1"># 실제 데이터&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fcs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span> &lt;span class="c1"># 오류 검사&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>Flag (&amp;lsquo;01111110&amp;rsquo;): 플래그는 프레임의 시작과 끝을 나타내는 1바이트의 특별한 비트 패턴. 01111110이라는 고유한 패턴을 사용하여 프레임의 시작과 끝을 명확하게 구분한다. 만약 데이터 내용 중에 이 패턴이 우연히 나타나면 비트 스터핑(bit stuffing)이라는 기술을 사용하여 구분한다.&lt;/li>
&lt;li>Address (&amp;lsquo;FF&amp;rsquo;): PPP는 두 지점 간의 직접 연결이므로, 복잡한 주소 지정이 필요하지 않다. 따라서 이 필드는 항상 &amp;lsquo;FF&amp;rsquo;(브로드캐스트 주소)라는 단일 값을 사용한다.&lt;/li>
&lt;li>Control (&amp;lsquo;03&amp;rsquo;): 제어 필드는 프레임의 종류와 기능을 나타낸다.&lt;br>
기본값인 &amp;lsquo;03&amp;rsquo;은 비번호화된 정보를 의미이다.&lt;br>
제어 필드는 다음과 같은 정보를 포함할 수 있다:&lt;br>
- 프레임의 종류 (정보, 감독, 비번호)&lt;br>
- 시퀀스 번호&lt;br>
- 확인 응답 정보&lt;/li>
&lt;li>Protocol: 상위 계층에서 사용하는 프로토콜의 종류를 나타내는 2바이트 필드.&lt;br>
예를 들어:&lt;br>
- 0x0021: IPv4&lt;br>
- 0x0057: IPv6&lt;br>
- 0xc021: LCP (Link Control Protocol)&lt;br>
- 0x8021: IPCP (IP Control Protocol)&lt;/li>
&lt;li>Payload (실제 데이터): 전송하고자 하는 실제 데이터가 들어있는 필드. 이 부분의 크기는 가변적이며, MTU(Maximum Transmission Unit)에 따라 제한된다.&lt;br>
PPP는 다음과 같은 특징을 가진 데이터를 전송할 수 있다:
&lt;ul>
&lt;li>일반적인 IP 패킷&lt;/li>
&lt;li>압축된 TCP/IP 헤더&lt;/li>
&lt;li>인증 데이터&lt;/li>
&lt;li>링크 제어 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FCS (Frame Check Sequence): 프레임의 무결성을 검사하기 위한 오류 검사 코드. 기본적으로 16비트 CRC를 사용하지만, 선택적으로 32비트 CRC를 사용할 수도 있다.&lt;br>
FCS는 다음과 같은 기능을 수행한다:
&lt;ul>
&lt;li>전송 중 발생할 수 있는 비트 오류 검출&lt;/li>
&lt;li>데이터 손상 여부 확인&lt;/li>
&lt;li>필요한 경우 재전송 요청&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>PPP의 특징과 장점:&lt;/p>
&lt;ol>
&lt;li>오류 감지와 복구: 데이터 전송 중 발생하는 오류를 감지하고 처리한다.
&lt;ul>
&lt;li>프레임 체크섬 검사&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다중 프로토콜 지원: IP뿐만 아니라 다양한 네트워크 프로토콜을 지원한다.
&lt;ul>
&lt;li>IP 프로토콜 지원&lt;/li>
&lt;li>IPX 프로토콜 지원&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>압축 기능: 데이터를 압축하여 전송 효율을 높인다.
&lt;ul>
&lt;li>헤더 압축&lt;/li>
&lt;li>데이터 압축&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4>HDLC(High-Level Data Link Control)&lt;/h4>&lt;p>두 장치 간에 데이터를 안전하고 효율적으로 전송하기 위한 데이터 링크 계층 프로토콜.&lt;/p>
&lt;p>HDLC의 작동 방식:&lt;/p>
&lt;ol>
&lt;li>연결 설정:&lt;br>
SABM(Set Asynchronous Balanced Mode) 프레임 전송&lt;br>
UA(Unnumbered Acknowledgment) 응답 대기&lt;/li>
&lt;li>데이터 전송:&lt;br>
정보 프레임 생성 및 전송&lt;br>
확인응답 대기&lt;/li>
&lt;li>오류 제어:&lt;br>
HDLC는 다음과 같은 방식으로 오류를 처리한다:&lt;br>
- REJ(Reject) 프레임 전송&lt;br>
- 재전송 대기&lt;/li>
&lt;/ol>
&lt;p>HDLC 프레임의 구조:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>[Flag(8비트)][주소(8비트)][제어(8/16비트)][정보(가변길이)][FCS(16/32비트)][Flag(8비트)]&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ul>
&lt;li>각 필드의 역할:
&lt;ol>
&lt;li>Flag (01111110):&lt;br>
프레임의 시작과 끝을 나타내는 특별한 비트 패턴.&lt;br>
마치 편지의 봉투와 같은 역할을 한다.&lt;/li>
&lt;li>주소 필드:&lt;br>
데이터를 받을 장치의 주소를 나타낸다.&lt;/li>
&lt;li>제어 필드:&lt;br>
프레임의 종류와 순서 번호 등을 나타낸다.
&lt;ul>
&lt;li>정보 프레임(I-frame): 실제 데이터 전송&lt;/li>
&lt;li>감독 프레임(S-frame): 흐름 제어와 오류 복구&lt;/li>
&lt;li>비번호 프레임(U-frame): 연결 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>HDLC의 주요 특징:&lt;/p>
&lt;ol>
&lt;li>비트 스터핑: 프레임 내에서 플래그 패턴이 우연히 나타나는 것을 방지한다.&lt;/li>
&lt;li>전이중 통신: 양방향으로 동시에 데이터를 전송할 수 있다:&lt;/li>
&lt;/ol>
&lt;p>실제 활용 사례:&lt;/p>
&lt;ol>
&lt;li>전용선 통신: 두 지점 간의 안정적인 데이터 통신에 사용된다.&lt;/li>
&lt;li>라우터 간 통신: 네트워크 장비 간의 데이터 전송에 활용된다.&lt;/li>
&lt;/ol>
&lt;h3>실생활 예시로 이해하기&lt;/h3>&lt;ol>
&lt;li>
&lt;p>Wi-Fi 연결 과정:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>1. 노트북이 공유기를 발견
2. MAC 주소를 확인하여 연결 요청
3. 공유기가 응답하고 연결 수립
4. 데이터 교환 시작&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>스마트폰 핫스팟:&lt;br>
다른 기기와 연결될 때 MAC 주소를 통한 식별이 이루어진다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>문제 해결과 주의사항&lt;/h3>&lt;p>일반적인 문제들과 해결 방법:&lt;/p>
&lt;ol>
&lt;li>MAC 주소 충돌&lt;/li>
&lt;li>프레임 손실: 재전송 메커니즘을 통해 해결한다.&lt;/li>
&lt;/ol>
&lt;h3>데이터링크 계층의 발전 방향&lt;/h3>&lt;ol>
&lt;li>
&lt;p>속도 개선:&lt;br>
새로운 이더넷 표준의 개발:&lt;br>
- 10 Gigabit Ethernet&lt;br>
- 40/100 Gigabit Ethernet&lt;/p>
&lt;/li>
&lt;li>
&lt;p>보안 강화:&lt;br>
MAC 주소 필터링, 포트 보안 등의 기술 발전.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>에너지 효율:&lt;br>
그린 이더넷 기술의 발전:&lt;br>
- Energy Efficient Ethernet (IEEE 802.3az)&lt;br>
- 저전력 모드 지원&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>OSI 7 Layers - 3. Network Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/</link><pubDate>Wed, 25 Sep 2024 07:17:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/</guid><description>
&lt;h2>Network Layer(네트워크 계층)&lt;/h2>&lt;p>네트워크 계층은 OSI 모델의 3계층으로, 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다.&lt;br>
이 계층은 라우팅, 패킷 포워딩, 인터네트워킹 등을 수행한다.&lt;/p>
&lt;p>네트워크 계층은 데이터의 종단 간 전달을 담당하는 중요한 계층으로, 효율적인 라우팅과 주소 지정을 통해 복잡한 네트워크 환경에서도 안정적인 통신을 가능하게 한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/Network%20Layer/osi_model_network_layer_3.png"
alt="Network Layer"
title="Network Layer"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>역할과 기능&lt;/h3>&lt;ol>
&lt;li>&lt;strong>라우팅&lt;/strong>: 데이터 패킷의 최적 경로를 결정한다.&lt;/li>
&lt;li>논리적 주소 지정: IP 주소를 사용하여 장치를 식별한다.&lt;/li>
&lt;li>패킷 포워딩: 패킷을 다음 네트워크 노드로 전달한다.&lt;/li>
&lt;li>패킷화: 상위 계층에서 받은 데이터를 패킷으로 분할한다.&lt;/li>
&lt;li>인터네트워킹: 서로 다른 네트워크 간의 통신을 가능하게 한다.&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;/h3>&lt;ul>
&lt;li>비연결성 서비스를 제공한다.&lt;/li>
&lt;li>종단 간 통신을 담당한다.&lt;/li>
&lt;li>QoS(Quality of Service)를 제공한다.&lt;/li>
&lt;/ul>
&lt;h3>데이터 단위와 구조&lt;/h3>&lt;ul>
&lt;li>데이터 단위: 패킷(Packet)&lt;/li>
&lt;li>기본 구조: 헤더 + 데이터
&lt;ul>
&lt;li>헤더: 출발지 IP 주소, 목적지 IP 주소, 프로토콜 정보 등&lt;/li>
&lt;li>데이터: 상위 계층에서 전달받은 정보&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4>IPv4 와 IPv6 의 Header 비교&lt;/h4>&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/Network%20Layer/comparing-ipv4-and-ipv6-headers.png"
alt="IPv4 Header vs IPv6 Header"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://www.networkacademy.io/ccna/ipv6/ipv4-vs-ipv6" target="_blank" rel="noopener">https://www.networkacademy.io/ccna/ipv6/ipv4-vs-ipv6&lt;/a> _&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>필드&lt;/th>
&lt;th>IPv4&lt;/th>
&lt;th>IPv6&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>Bit&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Version&lt;/td>
&lt;td>Version&lt;/td>
&lt;td>Version&lt;/td>
&lt;td>IP 프로토콜 버전&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IHL&lt;/td>
&lt;td>IHL&lt;/td>
&lt;td>-&lt;/td>
&lt;td>헤더 길이 (IPv6 에서는 고정 길이로 제거됨)&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Type of Service&lt;/td>
&lt;td>Type of Service&lt;/td>
&lt;td>Traffic Class&lt;/td>
&lt;td>패킷 우선순위 또는 서비스 유형 지정 지정&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Total Length&lt;/td>
&lt;td>Total Length&lt;/td>
&lt;td>Payload Length&lt;/td>
&lt;td>데이터 페이로드 길이&lt;/td>
&lt;td>16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Identification&lt;/td>
&lt;td>Identification&lt;/td>
&lt;td>-&lt;/td>
&lt;td>단편화 관련 필드 (IPv6 에서는 제거됨)&lt;/td>
&lt;td>16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Flags&lt;/td>
&lt;td>Flags&lt;/td>
&lt;td>-&lt;/td>
&lt;td>단편화 관련 필드 (IPv6 에서는 제거됨)&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Fragment Offset&lt;/td>
&lt;td>Fragment Offset&lt;/td>
&lt;td>-&lt;/td>
&lt;td>단편화 관련 필드 (IPv6 에서는 제거됨)&lt;/td>
&lt;td>13&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TTL&lt;/td>
&lt;td>TTL&lt;/td>
&lt;td>Hop Limit&lt;/td>
&lt;td>패킷의 최대 홉 수&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Protocol&lt;/td>
&lt;td>Protocol&lt;/td>
&lt;td>Next Header&lt;/td>
&lt;td>상위 계층 프로토콜 식별&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Header Checksum&lt;/td>
&lt;td>Header Checksum&lt;/td>
&lt;td>-&lt;/td>
&lt;td>오류 검출 (IPv6 에서는 제거됨)&lt;/td>
&lt;td>16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Source Address&lt;/td>
&lt;td>Source Address&lt;/td>
&lt;td>Source Address&lt;/td>
&lt;td>송신자의 IP 주소&lt;/td>
&lt;td>IPv4: 32&lt;br>IPv6: 128&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Destination Address&lt;/td>
&lt;td>Destination Address&lt;/td>
&lt;td>Destination Address&lt;/td>
&lt;td>수신자의 IP 주소&lt;/td>
&lt;td>IPv4: 32&lt;br>IPv6: 128&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Options&lt;/td>
&lt;td>Options&lt;/td>
&lt;td>-&lt;/td>
&lt;td>추가 옵션 (IPv6 에서는 확장 헤더로 대체됨)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Padding&lt;/td>
&lt;td>Padding&lt;/td>
&lt;td>-&lt;/td>
&lt;td>패딩 (IPv6 에서는 제거됨)&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Flow Label&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Flow Label&lt;/td>
&lt;td>플로우 식별을 위한 레이블&lt;/td>
&lt;td>20&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>상위 계층으로부터 데이터를 받아 패킷으로 분할한다.&lt;/li>
&lt;li>각 패킷에 출발지와 목적지 IP 주소를 포함한 헤더를 추가한다.&lt;/li>
&lt;li>라우팅 알고리즘을 사용하여 최적의 경로를 결정한다.&lt;/li>
&lt;li>패킷을 다음 홉(hop)으로 전달한다.&lt;/li>
&lt;li>목적지에 도착할 때까지 3-4 과정을 반복한다.&lt;/li>
&lt;/ol>
&lt;h4>라우팅 프로토콜과 알고리즘&lt;/h4>&lt;p>네트워크 계층에서는 다양한 라우팅 프로토콜을 사용한다:&lt;/p>
&lt;ul>
&lt;li>정적 라우팅: 수동으로 설정된 경로를 사용한다.&lt;/li>
&lt;li>동적 라우팅: 자동으로 최적의 경로를 찾아 업데이트한다.&lt;/li>
&lt;/ul>
&lt;h3>주의 사항&lt;/h3>&lt;ul>
&lt;li>네트워크 계층은 신뢰성 있는 데이터 전송을 보장하지 않는다. 이는 상위 계층(전송 계층)의 역할이다.&lt;/li>
&lt;li>IP 주소 충돌을 방지해야 한다.&lt;/li>
&lt;li>라우팅 테이블의 최신성과 정확성을 유지해야 한다.&lt;/li>
&lt;/ul>
&lt;h3>네트워크 계층의 중요성&lt;/h3>&lt;p>네트워크 계층은 다음과 같은 이유로 중요하다:&lt;/p>
&lt;ol>
&lt;li>다양한 네트워크 연결: 서로 다른 유형의 네트워크를 연결할 수 있게 한다.&lt;/li>
&lt;li>확장성: 큰 규모의 네트워크를 효율적으로 관리할 수 있다.&lt;/li>
&lt;li>유연성: 다양한 라우팅 프로토콜을 사용하여 네트워크 환경에 적응할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>네트워크 계층의 주요 프로토콜&lt;/h3>&lt;ol>
&lt;li>IP(Internet Protocol): 가장 기본적인 네트워크 계층 프로토콜.&lt;/li>
&lt;li>ICMP(Internet Control Message Protocol): 네트워크 상태와 오류를 보고하는 프로토콜.&lt;/li>
&lt;li>RIP, OSPF와 같은 라우팅 프로토콜: 라우터들이 경로 정보를 교환하는 프로토콜.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>OSI 7 Layers - 4. Transport Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/</link><pubDate>Wed, 25 Sep 2024 07:17:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/</guid><description>
&lt;h2>Transport Layer(전송 계층)&lt;/h2>&lt;p>전송 계층은 OSI 모델의 4번째 계층으로, 종단 간(end-to-end) 통신을 담당한다.&lt;br>
이 계층은 상위 계층에서 받은 데이터를 세그먼트로 분할하고, 목적지에서 다시 조립하여 신뢰성 있는 데이터 전송을 보장한다.&lt;/p>
&lt;p>전송 계층은 네트워크 통신의 신뢰성과 효율성을 보장하는 중요한 역할을 수행하며, 상위 계층의 애플리케이션에 투명한 데이터 전송 서비스를 제공한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/osi_model_transport_layer_4.png"
alt="Transport Layer"
title="Transport Layer"
loading="lazy" />
&lt;/figure> _Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>역할과 기능&lt;/h3>&lt;ol>
&lt;li>세그멘테이션과 재조립: 데이터를 세그먼트로 분할하고 목적지에서 재조립한다.&lt;/li>
&lt;li>연결 제어: 연결 지향적(TCP) 또는 비연결형(UDP) 서비스를 제공한다.&lt;/li>
&lt;li>흐름 제어: 송신자와 수신자 간의 데이터 전송 속도를 조절한다.&lt;/li>
&lt;li>오류 제어: 데이터 전송 중 발생한 오류를 감지하고 수정한다.&lt;/li>
&lt;li>다중화와 역다중화: 여러 애플리케이션의 데이터를 하나의 연결로 전송하고 수신 시 분리한다.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>세그멘테이션 (Segmentation)&lt;/p>
&lt;ul>
&lt;li>상위 계층에서 받은 큰 데이터를 더 작은 단위인 세그먼트로 나누는 과정이다.&lt;/li>
&lt;li>효율적인 오류 처리: 세그먼트 단위로 오류를 처리할 수 있어, 문제가 발생했을 때 해당 세그먼트만 재전송하면 된다.&lt;/li>
&lt;li>네트워크 자원의 효율적 사용: 작은 단위로 나누어 전송함으로써 네트워크 대역폭을 효율적으로 사용할 수 있다.&lt;/li>
&lt;li>다중화(Multiplexing) 가능: 여러 애플리케이션의 데이터를 동시에 전송할 수 있다.&lt;/li>
&lt;li>작동 방식
&lt;ol>
&lt;li>데이터 분할 애플리케이션 계층에서 받은 데이터를 적절한 크기의 세그먼트로 나눈다.&lt;br>
TCP의 경우, Maximum Segment Size(MSS)를 기준으로 데이터를 나눈다.&lt;br>
MSS는 일반적으로 MTU에서 IP와 TCP 헤더 크기를 뺀 값이다.&lt;/li>
&lt;li>순서 번호 할당 각 세그먼트에는 순서 번호(Sequence Number)가 부여된다.&lt;br>
이는 수신측에서 데이터를 올바른 순서로 재조립할 수 있게 해준다.&lt;/li>
&lt;li>헤더 추가 각 세그먼트에는 TCP 또는 UDP 헤더가 추가된다.&lt;br>
TCP 헤더의 경우 다음과 같은 중요한 정보를 포함한다:
&lt;ul>
&lt;li>출발지/목적지 포트 번호&lt;/li>
&lt;li>순서 번호(Sequence Number)&lt;/li>
&lt;li>확인 응답 번호(Acknowledgment Number)&lt;/li>
&lt;li>윈도우 크기&lt;/li>
&lt;li>체크섬&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>세그멘테이션 관련 고려사항
&lt;ol>
&lt;li>세그먼트 크기 선택
&lt;ul>
&lt;li>너무 크면: 재전송 시 비효율적&lt;/li>
&lt;li>너무 작으면: 헤더 오버헤드 증가&lt;/li>
&lt;li>최적의 크기 선택이 중요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>버퍼 관리: 수신측에서 세그먼트를 저장하고 재조립할 수 있는 충분한 버퍼 공간이 필요하다.&lt;/li>
&lt;li>타이밍 관리: 재전송 타이머, 확인 응답 대기 시간 등을 적절히 관리해야 한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>TCP와 UDP의 세그멘테이션 차이
&lt;ul>
&lt;li>TCP와 UDP는 세그멘테이션을 다르게 처리한다.&lt;/li>
&lt;li>TCP의 세그멘테이션:
&lt;ul>
&lt;li>신뢰성 있는 전송을 보장&lt;/li>
&lt;li>순서 보장&lt;/li>
&lt;li>흐름 제어와 혼잡 제어 제공&lt;/li>
&lt;li>세그먼트 손실 시 재전송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>UDP의 세그멘테이션:
&lt;ul>
&lt;li>단순히 데이터그램으로 나누기만 함&lt;/li>
&lt;li>순서 보장 없음&lt;/li>
&lt;li>신뢰성 보장 없음&lt;/li>
&lt;li>더 빠른 전송 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3>특징&lt;/h3>&lt;ul>
&lt;li>종단 간 통신을 제공한다.&lt;/li>
&lt;li>신뢰성 있는 데이터 전송을 보장한다.&lt;/li>
&lt;li>포트 번호를 사용하여 애플리케이션을 식별한다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>port (포트)&lt;br>
네트워크에서 서로 다른 프로세스들이 통신할 수 있도록 구분해주는 논리적인 접속 위치.&lt;br>
각 포트는 16 비트 숫자로 표현되며, 범위는 0~65535&lt;br>
역할&lt;/p>
&lt;ul>
&lt;li>데이터 트래픽 분류: 포트는 컴퓨터가 받는 네트워크 트래픽을 종류별로 구분하는 데 도움을 준다.&lt;/li>
&lt;li>서비스 식별: 각 포트는 특정 서비스나 애플리케이션과 연결되어 있어, 데이터가 어떤 서비스로 전달되어야 하는 식별&lt;/li>
&lt;li>다중화 (Multiplexing): 하나의 네트워크 연결을 통해 여러 서비스나 애플리케이션이 동시에 통신할 수 있게 됨.&lt;br>
기능&lt;/li>
&lt;li>통신 엔드포인트 제공: 네트워크 상의 특정 서비스나 프로세스와의 통신을 위한 엔드포인트&lt;/li>
&lt;li>데이터 라우팅: 들어오는 데이터를 올바른 애플리케이션이나 서비스로 전달&lt;/li>
&lt;li>프로토콜 구분: 각 포트는 특정 네트워크 프로토콜 (예: HTTP(80), HTTPS(443), FTP(21), SMTP(25)) 과 연관되어 있어 프로토콜 별 통신을 가능하게 함.&lt;/li>
&lt;li>동시 연결 관리: 하나의 IP 주소에서 여러 개의 네트워크 연결을 동시에 관리할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3>데이터 단위와 구조&lt;/h3>&lt;p>데이터 단위: 세그먼트(TCP) 또는 데이터그램(UDP)&lt;br>
기본 구조: 헤더 + 데이터&lt;br>
헤더 필드:&lt;/p>
&lt;ul>
&lt;li>출발지 포트 번호&lt;/li>
&lt;li>목적지 포트 번호&lt;/li>
&lt;li>시퀀스 번호 (TCP)&lt;/li>
&lt;li>확인 응답 번호 (TCP)&lt;/li>
&lt;li>체크섬&lt;/li>
&lt;/ul>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>애플리케이션 계층에서 데이터를 받는다.&lt;/li>
&lt;li>데이터를 세그먼트로 분할한다.&lt;/li>
&lt;li>각 세그먼트에 헤더를 추가한다.&lt;/li>
&lt;li>네트워크 계층으로 세그먼트를 전달한다.&lt;/li>
&lt;li>수신 측에서는 세그먼트를 재조립하여 애플리케이션 계층으로 전달한다.&lt;/li>
&lt;/ol>
&lt;h3>주요 프로토콜&lt;/h3>&lt;ol>
&lt;li>TCP (Transmission Control Protocol):
&lt;ul>
&lt;li>연결 지향적이고 신뢰성 있는 데이터 전송을 제공한다.&lt;/li>
&lt;li>데이터의 순서를 보장하고 손실된 데이터를 재전송한다.&lt;/li>
&lt;li>흐름 제어와 혼잡 제어 제공&lt;/li>
&lt;li>3-way handshake: TCP 연결을 설정하는 과정.
&lt;ol>
&lt;li>SYN: 연결 요청&lt;/li>
&lt;li>SYN-ACK: 요청 승인&lt;/li>
&lt;li>ACK: 연결 설정 완료&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>4-way Handshake: 클라이언트와 서버 간의 연결을 종료하는 과정.
&lt;ol>
&lt;li>FIN (클라이언트 → 서버): 클라이언트가 연결 종료를 요청.&lt;/li>
&lt;li>ACK (서버 → 클라이언트): 서버가 FIN을 받았음을 확인. 클라이언트→서버 방향의 연결이 닫힌다.&lt;/li>
&lt;li>FIN (서버 → 클라이언트): 서버가 모든 데이터 전송을 완료하고 연결 종료를 요청한다.&lt;/li>
&lt;li>ACK (클라이언트 → 서버): 클라이언트가 서버의 FIN을 확인한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>UDP (User Datagram Protocol):
&lt;ul>
&lt;li>비연결형이고 신뢰성이 낮지만 빠른 전송을 제공한다.&lt;/li>
&lt;li>순서나 신뢰성 보장 없음&lt;/li>
&lt;li>실시간 애플리케이션에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주의 사항&lt;/h3>&lt;ul>
&lt;li>네트워크 혼잡을 방지하기 위한 적절한 흐름 제어가 필요하다.&lt;/li>
&lt;li>TCP와 UDP의 특성을 이해하고 적절히 선택해야 한다.&lt;/li>
&lt;li>포트 번호 충돌을 피해야 한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>OSI 7 Layers - 5. Session Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-5-session-layer/</link><pubDate>Wed, 25 Sep 2024 07:17:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-5-session-layer/</guid><description>
&lt;h2>Session Layer(세션 계층)&lt;/h2>&lt;p>세션 계층은 OSI 모델의 5번째 계층으로, 통신 세션을 구성하는 계층이다.&lt;br>
응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 프로세스들의 논리적인 연결을 담당한다.&lt;/p>
&lt;p>세션 계층은 네트워크 통신에서 연결의 지속성과 신뢰성을 보장하는 중요한 역할을 수행한다.&lt;br>
특히 장기간 지속되는 연결이 필요한 애플리케이션에서 중요한 기능을 제공한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/osi_model_session_layer_5.png"
alt="Session Layer"
title="Session Layer"
loading="lazy" />
&lt;/figure> _Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>역할과 기능&lt;/h3>&lt;ol>
&lt;li>세션 연결 설정 및 유지, 종료&lt;/li>
&lt;li>데이터 교환 동기화&lt;/li>
&lt;li>체크포인팅을 통한 데이터 복구&lt;/li>
&lt;li>대화 제어 (Duplex, Half-duplex, Full-duplex 통신)&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;/h3>&lt;ul>
&lt;li>TCP/IP 세션을 관리하고 연결을 유지한다.&lt;/li>
&lt;li>양방향 통신을 지원합니다.&lt;/li>
&lt;li>인증과 권한 부여 기능을 제공할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;h3>데이터 단위&lt;/h3>&lt;p>세션 계층의 데이터 단위는 일반적으로 &amp;ldquo;메시지&amp;quot;라고 불린다.&lt;/p>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>세션 설정: 통신하려는 양쪽 응용 프로그램 간에 세션을 설정한다.
&lt;ol>
&lt;li>연결 요청&lt;/li>
&lt;li>매개변수 협상&lt;/li>
&lt;li>연결 확인&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>데이터 전송: 설정된 세션을 통해 데이터를 주고받는다.
&lt;ol>
&lt;li>동기화 지점 확인&lt;/li>
&lt;li>데이터 전송&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>동기화: 데이터 전송 중 체크포인트를 설정하여 오류 발생 시 복구할 수 있게 한다.&lt;/li>
&lt;li>세션 종료: 통신이 끝나면 세션을 종료한다.&lt;/li>
&lt;/ol>
&lt;h3>주요 프로토콜&lt;/h3>&lt;ul>
&lt;li>NetBIOS (Network Basic Input/Output System)&lt;/li>
&lt;li>RPC (Remote Procedure Call)&lt;/li>
&lt;li>NFS (Network File System)&lt;/li>
&lt;/ul>
&lt;h3>주의 사항&lt;/h3>&lt;ul>
&lt;li>세션 계층은 현재 TCP/IP 모델에서는 응용 계층에 통합되어 있어, 실제 구현에서는 명확히 구분되지 않을 수 있다.&lt;/li>
&lt;li>세션 관리의 중요성을 인식하고, 적절한 세션 유지 및 종료 메커니즘을 구현해야 한다.
&lt;ul>
&lt;li>세션 타임아웃 관리&lt;/li>
&lt;li>리소스 사용량 모니터링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 최적화
&lt;ul>
&lt;li>적절한 체크포인트 간격 설정&lt;/li>
&lt;li>효율적인 동기화 메커니즘 사용&lt;/li>
&lt;li>리소스 사용량 모니터링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3>참고 및 출처&lt;/h3></description></item><item><title>OSI 7 Layers - 6. Presentation Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-6-presentation-layer/</link><pubDate>Wed, 25 Sep 2024 07:17:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-6-presentation-layer/</guid><description>
&lt;h2>Presentation Layer(프레젠테이션 계층)&lt;/h2>&lt;p>프레젠테이션 계층은 OSI 모델의 6번째 계층으로, 데이터의 표현 방식을 담당한다.&lt;br>
이 계층은 응용 계층과 세션 계층 사이에 위치하며, 데이터의 형식과 구조를 결정한다.&lt;/p>
&lt;p>프레젠테이션 계층은 네트워크 통신에서 데이터의 표현과 보안을 담당하는 중요한 계층으로, 다양한 시스템 간의 원활한 데이터 교환을 가능하게 한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/osi_model_presentation_layer_6.png"
alt="Presentation Layer"
title="Presentation Layer"
loading="lazy" />
&lt;/figure> _Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>역할과 기능&lt;/h3>&lt;ol>
&lt;li>데이터 변환: 송신 측과 수신 측 사이에서 데이터 형식을 변환한다.&lt;/li>
&lt;li>인코딩과 디코딩: 데이터를 다양한 형식으로 인코딩하고 디코딩한다.&lt;/li>
&lt;li>암호화와 복호화: 데이터의 보안을 위해 암호화 및 복호화를 수행한다.&lt;/li>
&lt;li>데이터 압축: 효율적인 전송을 위해 데이터를 압축하고 해제한다.&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;/h3>&lt;ul>
&lt;li>데이터의 의미와 구문을 보존하면서 형식을 변환한다.&lt;/li>
&lt;li>응용 계층의 부담을 덜어주는 역할을 한다.&lt;/li>
&lt;li>다양한 데이터 형식을 지원한다 (예: JPEG, MPEG, ASCII, EBCDIC).&lt;/li>
&lt;/ul>
&lt;h4>프레젠테이션 계층의 중요한 표준들&lt;/h4>&lt;ol>
&lt;li>
&lt;p>문자 인코딩:&lt;/p>
&lt;ul>
&lt;li>ASCII: 기본 영문자와 특수문자&lt;/li>
&lt;li>Unicode: 전 세계의 문자 지원&lt;/li>
&lt;li>UTF-8: 가변 길이 인코딩&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>멀티미디어 형식:&lt;/p>
&lt;ul>
&lt;li>이미지: JPEG, PNG, GIF&lt;/li>
&lt;li>비디오: MPEG, H&lt;/li>
&lt;li>오디오: MP3, WAV&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>암호화 프로토콜:&lt;/p>
&lt;ul>
&lt;li>SSL/TLS: 보안 통신&lt;/li>
&lt;li>DES, AES: 데이터 암호화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>데이터 단위&lt;/h3>&lt;p>프레젠테이션 계층의 데이터 단위는 일반적으로 &amp;ldquo;데이터&amp;quot;라고 불린다.&lt;/p>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>응용 계층에서 받은 데이터를 표준화된 형식으로 변환한다.&lt;/li>
&lt;li>필요한 경우 데이터를 압축하거나 암호화한다.&lt;/li>
&lt;li>변환된 데이터를 세션 계층으로 전달한다.&lt;/li>
&lt;li>수신 측에서는 역순으로 과정을 수행하여 원래의 데이터 형식으로 복원한다.&lt;/li>
&lt;/ol>
&lt;h3>주요 프로토콜&lt;/h3>&lt;p>JPEG, MPEG, SSL, TLS, ASCII, EBCDIC&lt;/p>
&lt;h3>주의 사항&lt;/h3>&lt;ul>
&lt;li>데이터 변환 과정에서 정보의 손실이 없도록 주의해야 한다.&lt;/li>
&lt;li>암호화 알고리즘의 선택과 관리에 신중해야 한다.&lt;/li>
&lt;li>다양한 시스템 간의 호환성을 고려해야 한다.&lt;/li>
&lt;/ul>
&lt;h3>중요성&lt;/h3>&lt;ol>
&lt;li>시스템 간 호환성: 서로 다른 데이터 표현 방식을 사용하는 시스템 간의 통신을 가능하게 한다.&lt;/li>
&lt;li>데이터 보안: 암호화를 통해 데이터의 기밀성을 보장한다.&lt;/li>
&lt;li>효율적인 데이터 전송: 데이터 압축을 통해 네트워크 리소스를 절약한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>OSI 7 Layers - 7. Application Layer</title><link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-7-application-layer/</link><pubDate>Wed, 25 Sep 2024 07:16:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-7-application-layer/</guid><description>
&lt;h2>Application Layer(애플리케이션 계층)&lt;/h2>&lt;p>애플리케이션 계층은 OSI 모델의 최상위 계층으로, 사용자와 직접 상호작용하는 소프트웨어를 지원하는 계층이다.&lt;br>
이 계층은 사용자가 네트워크 자원에 접근할 수 있도록 인터페이스를 제공한다.&lt;/p>
&lt;p>애플리케이션 계층은 네트워크 통신의 최종 목적지로, 사용자의 요구사항을 네트워크 서비스로 연결하는 중요한 역할을 수행한다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Networking%20and%20Communications/OSI%207%20Layers/osi_model_application_layer_7.png"
alt="Application Layer"
title="Application Layer"
loading="lazy" />
&lt;/figure> _Source: &lt;a href="https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener">https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/&lt;/a> _&lt;/p>
&lt;h3>역할과 기능&lt;/h3>&lt;ol>
&lt;li>사용자와 네트워크 간의 인터페이스 제공&lt;/li>
&lt;li>다양한 네트워크 서비스 제공 (이메일, 파일 전송, 웹 브라우징 등)&lt;/li>
&lt;li>사용자 데이터의 송수신 관리&lt;/li>
&lt;li>네트워크 자원에 대한 접근 제어&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;/h3>&lt;ol>
&lt;li>사용자 지향적: 사용자가 직접 상호작용하는 유일한 OSI 계층.&lt;/li>
&lt;li>다양한 프로토콜: 각 애플리케이션의 요구사항에 맞는 다양한 프로토콜을 사용한다.&lt;/li>
&lt;li>데이터 형식 관리: 애플리케이션 간에 교환되는 데이터의 형식을 관리한다.&lt;/li>
&lt;li>보안 및 인증: 사용자 인증 및 데이터 암호화와 같은 보안 메커니즘을 구현한다.&lt;/li>
&lt;li>하위 계층의 서비스를 활용하여 작동&lt;/li>
&lt;/ol>
&lt;h3>데이터 단위&lt;/h3>&lt;p>애플리케이션 계층의 데이터 단위는 &amp;ldquo;메시지&amp;rdquo; 또는 &amp;ldquo;데이터&amp;quot;라고 불린다.&lt;/p>
&lt;h3>주요 프로토콜&lt;/h3>&lt;p>HTTP, SMTP, FTP, DNS, SSH, Telnet 등&lt;/p>
&lt;h3>작동 방식&lt;/h3>&lt;ol>
&lt;li>사용자로부터 요청을 받음&lt;/li>
&lt;li>요청을 적절한 형식의 메시지로 변환&lt;/li>
&lt;li>하위 계층(표현 계층)으로 메시지 전달&lt;/li>
&lt;li>수신된 데이터를 사용자가 이해할 수 있는 형태로 변환하여 제공&lt;/li>
&lt;/ol>
&lt;h3>주의 사항&lt;/h3>&lt;ol>
&lt;li>보안: 애플리케이션 계층은 사용자와 직접 상호작용하므로 보안에 특히 주의해야 한다.&lt;/li>
&lt;li>성능: 대량의 데이터 처리 시 효율적인 관리가 필요하다.&lt;/li>
&lt;li>호환성: 다양한 애플리케이션과 프로토콜 간의 호환성을 고려해야 한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item></channel></rss>