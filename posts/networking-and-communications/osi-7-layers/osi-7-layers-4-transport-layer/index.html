<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OSI 7 Layers - 4. Transport Layer | hyunyoun's Blog</title>
<meta name=keywords content="Networking-and-Communications,OSI-7-Layers,Transport-Layer,전송-계층,Segmentation"><meta name=description content="4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="OSI 7 Layers - 4. Transport Layer"><meta property="og:description" content="4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-25T07:17:00+00:00"><meta property="article:modified_time" content="2024-09-25T07:17:00+00:00"><meta property="article:tag" content="Networking-and-Communications"><meta property="article:tag" content="OSI-7-Layers"><meta property="article:tag" content="Transport-Layer"><meta property="article:tag" content="전송-계층"><meta property="article:tag" content="Segmentation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="OSI 7 Layers - 4. Transport Layer"><meta name=twitter:description content="4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Network","item":"https://buenhyden.github.io/posts/networking-and-communications/"},{"@type":"ListItem","position":3,"name":"Network Layer - OSI 7 계층","item":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/"},{"@type":"ListItem","position":4,"name":"OSI 7 Layers - 4. Transport Layer","item":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OSI 7 Layers - 4. Transport Layer","name":"OSI 7 Layers - 4. Transport Layer","description":"4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다","keywords":["Networking-and-Communications","OSI-7-Layers","Transport-Layer","전송-계층","Segmentation"],"articleBody":"Transport Layer(전송 계층) 전송 계층은 OSI 모델의 4번째 계층으로, 종단 간(end-to-end) 통신을 담당한다.\n이 계층은 상위 계층에서 받은 데이터를 세그먼트로 분할하고, 목적지에서 다시 조립하여 신뢰성 있는 데이터 전송을 보장한다.\n전송 계층은 네트워크 통신의 신뢰성과 효율성을 보장하는 중요한 역할을 수행하며, 상위 계층의 애플리케이션에 투명한 데이터 전송 서비스를 제공한다.\nSource: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/\n역할과 기능 세그멘테이션과 재조립: 데이터를 세그먼트로 분할하고 목적지에서 재조립한다. 연결 제어: 연결 지향적(TCP) 또는 비연결형(UDP) 서비스를 제공한다. 흐름 제어: 송신자와 수신자 간의 데이터 전송 속도를 조절한다. 오류 제어: 데이터 전송 중 발생한 오류를 감지하고 수정한다. 다중화와 역다중화: 여러 애플리케이션의 데이터를 하나의 연결로 전송하고 수신 시 분리한다. 세그멘테이션 (Segmentation)\n상위 계층에서 받은 큰 데이터를 더 작은 단위인 세그먼트로 나누는 과정이다. 효율적인 오류 처리: 세그먼트 단위로 오류를 처리할 수 있어, 문제가 발생했을 때 해당 세그먼트만 재전송하면 된다. 네트워크 자원의 효율적 사용: 작은 단위로 나누어 전송함으로써 네트워크 대역폭을 효율적으로 사용할 수 있다. 다중화(Multiplexing) 가능: 여러 애플리케이션의 데이터를 동시에 전송할 수 있다. 작동 방식 데이터 분할 애플리케이션 계층에서 받은 데이터를 적절한 크기의 세그먼트로 나눈다.\nTCP의 경우, Maximum Segment Size(MSS)를 기준으로 데이터를 나눈다.\nMSS는 일반적으로 MTU에서 IP와 TCP 헤더 크기를 뺀 값이다. 순서 번호 할당 각 세그먼트에는 순서 번호(Sequence Number)가 부여된다.\n이는 수신측에서 데이터를 올바른 순서로 재조립할 수 있게 해준다. 헤더 추가 각 세그먼트에는 TCP 또는 UDP 헤더가 추가된다.\nTCP 헤더의 경우 다음과 같은 중요한 정보를 포함한다: 출발지/목적지 포트 번호 순서 번호(Sequence Number) 확인 응답 번호(Acknowledgment Number) 윈도우 크기 체크섬 세그멘테이션 관련 고려사항 세그먼트 크기 선택 너무 크면: 재전송 시 비효율적 너무 작으면: 헤더 오버헤드 증가 최적의 크기 선택이 중요 버퍼 관리: 수신측에서 세그먼트를 저장하고 재조립할 수 있는 충분한 버퍼 공간이 필요하다. 타이밍 관리: 재전송 타이머, 확인 응답 대기 시간 등을 적절히 관리해야 한다. TCP와 UDP의 세그멘테이션 차이 TCP와 UDP는 세그멘테이션을 다르게 처리한다. TCP의 세그멘테이션: 신뢰성 있는 전송을 보장 순서 보장 흐름 제어와 혼잡 제어 제공 세그먼트 손실 시 재전송 UDP의 세그멘테이션: 단순히 데이터그램으로 나누기만 함 순서 보장 없음 신뢰성 보장 없음 더 빠른 전송 가능 특징 종단 간 통신을 제공한다. 신뢰성 있는 데이터 전송을 보장한다. 포트 번호를 사용하여 애플리케이션을 식별한다. port (포트)\n네트워크에서 서로 다른 프로세스들이 통신할 수 있도록 구분해주는 논리적인 접속 위치.\n각 포트는 16 비트 숫자로 표현되며, 범위는 0~65535\n역할\n데이터 트래픽 분류: 포트는 컴퓨터가 받는 네트워크 트래픽을 종류별로 구분하는 데 도움을 준다. 서비스 식별: 각 포트는 특정 서비스나 애플리케이션과 연결되어 있어, 데이터가 어떤 서비스로 전달되어야 하는 식별 다중화 (Multiplexing): 하나의 네트워크 연결을 통해 여러 서비스나 애플리케이션이 동시에 통신할 수 있게 됨.\n기능 통신 엔드포인트 제공: 네트워크 상의 특정 서비스나 프로세스와의 통신을 위한 엔드포인트 데이터 라우팅: 들어오는 데이터를 올바른 애플리케이션이나 서비스로 전달 프로토콜 구분: 각 포트는 특정 네트워크 프로토콜 (예: HTTP(80), HTTPS(443), FTP(21), SMTP(25)) 과 연관되어 있어 프로토콜 별 통신을 가능하게 함. 동시 연결 관리: 하나의 IP 주소에서 여러 개의 네트워크 연결을 동시에 관리할 수 있게 한다. 데이터 단위와 구조 데이터 단위: 세그먼트(TCP) 또는 데이터그램(UDP)\n기본 구조: 헤더 + 데이터\n헤더 필드:\n출발지 포트 번호 목적지 포트 번호 시퀀스 번호 (TCP) 확인 응답 번호 (TCP) 체크섬 작동 방식 애플리케이션 계층에서 데이터를 받는다. 데이터를 세그먼트로 분할한다. 각 세그먼트에 헤더를 추가한다. 네트워크 계층으로 세그먼트를 전달한다. 수신 측에서는 세그먼트를 재조립하여 애플리케이션 계층으로 전달한다. 주요 프로토콜 TCP (Transmission Control Protocol): 연결 지향적이고 신뢰성 있는 데이터 전송을 제공한다. 데이터의 순서를 보장하고 손실된 데이터를 재전송한다. 흐름 제어와 혼잡 제어 제공 3-way handshake: TCP 연결을 설정하는 과정. SYN: 연결 요청 SYN-ACK: 요청 승인 ACK: 연결 설정 완료 4-way Handshake: 클라이언트와 서버 간의 연결을 종료하는 과정. FIN (클라이언트 → 서버): 클라이언트가 연결 종료를 요청. ACK (서버 → 클라이언트): 서버가 FIN을 받았음을 확인. 클라이언트→서버 방향의 연결이 닫힌다. FIN (서버 → 클라이언트): 서버가 모든 데이터 전송을 완료하고 연결 종료를 요청한다. ACK (클라이언트 → 서버): 클라이언트가 서버의 FIN을 확인한다. UDP (User Datagram Protocol): 비연결형이고 신뢰성이 낮지만 빠른 전송을 제공한다. 순서나 신뢰성 보장 없음 실시간 애플리케이션에 적합하다. 주의 사항 네트워크 혼잡을 방지하기 위한 적절한 흐름 제어가 필요하다. TCP와 UDP의 특성을 이해하고 적절히 선택해야 한다. 포트 번호 충돌을 피해야 한다. 참고 및 출처 ","wordCount":"627","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-25T07:17:00Z","dateModified":"2024-09-25T07:17:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/>Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/>Network Layer - OSI 7 계층</a></div><h1 class="post-title entry-hint-parent">OSI 7 Layers - 4. Transport Layer</h1><div class=post-description>4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다</div><div class=post-meta><span title='2024-09-25 07:17:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;627 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Networking%20and%20Communications/OSI%207%20Layers/OSI-7-Layers-4-Transport-Layer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#transport-layer전송-계층>Transport Layer(전송 계층)</a><ul><li><a href=#역할과-기능>역할과 기능</a></li><li><a href=#특징>특징</a></li><li><a href=#데이터-단위와-구조>데이터 단위와 구조</a></li><li><a href=#작동-방식>작동 방식</a></li><li><a href=#주요-프로토콜>주요 프로토콜</a></li><li><a href=#주의-사항>주의 사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=transport-layer전송-계층>Transport Layer(전송 계층)<a hidden class=anchor aria-hidden=true href=#transport-layer전송-계층>#</a></h2><p>전송 계층은 OSI 모델의 4번째 계층으로, 종단 간(end-to-end) 통신을 담당한다.<br>이 계층은 상위 계층에서 받은 데이터를 세그먼트로 분할하고, 목적지에서 다시 조립하여 신뢰성 있는 데이터 전송을 보장한다.</p><p>전송 계층은 네트워크 통신의 신뢰성과 효율성을 보장하는 중요한 역할을 수행하며, 상위 계층의 애플리케이션에 투명한 데이터 전송 서비스를 제공한다.</p><p><figure><img alt="Transport Layer" loading=lazy src=/img/osi_model_transport_layer_4.png><figcaption>Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/</figcaption></figure></p><h3 id=역할과-기능>역할과 기능<a hidden class=anchor aria-hidden=true href=#역할과-기능>#</a></h3><ol><li>세그멘테이션과 재조립: 데이터를 세그먼트로 분할하고 목적지에서 재조립한다.</li><li>연결 제어: 연결 지향적(TCP) 또는 비연결형(UDP) 서비스를 제공한다.</li><li>흐름 제어: 송신자와 수신자 간의 데이터 전송 속도를 조절한다.</li><li>오류 제어: 데이터 전송 중 발생한 오류를 감지하고 수정한다.</li><li>다중화와 역다중화: 여러 애플리케이션의 데이터를 하나의 연결로 전송하고 수신 시 분리한다.</li></ol><blockquote><p>세그멘테이션 (Segmentation)</p><ul><li>상위 계층에서 받은 큰 데이터를 더 작은 단위인 세그먼트로 나누는 과정이다.</li><li>효율적인 오류 처리: 세그먼트 단위로 오류를 처리할 수 있어, 문제가 발생했을 때 해당 세그먼트만 재전송하면 된다.</li><li>네트워크 자원의 효율적 사용: 작은 단위로 나누어 전송함으로써 네트워크 대역폭을 효율적으로 사용할 수 있다.</li><li>다중화(Multiplexing) 가능: 여러 애플리케이션의 데이터를 동시에 전송할 수 있다.</li><li>작동 방식<ol><li>데이터 분할 애플리케이션 계층에서 받은 데이터를 적절한 크기의 세그먼트로 나눈다.<br>TCP의 경우, Maximum Segment Size(MSS)를 기준으로 데이터를 나눈다.<br>MSS는 일반적으로 MTU에서 IP와 TCP 헤더 크기를 뺀 값이다.</li><li>순서 번호 할당 각 세그먼트에는 순서 번호(Sequence Number)가 부여된다.<br>이는 수신측에서 데이터를 올바른 순서로 재조립할 수 있게 해준다.</li><li>헤더 추가 각 세그먼트에는 TCP 또는 UDP 헤더가 추가된다.<br>TCP 헤더의 경우 다음과 같은 중요한 정보를 포함한다:<ul><li>출발지/목적지 포트 번호</li><li>순서 번호(Sequence Number)</li><li>확인 응답 번호(Acknowledgment Number)</li><li>윈도우 크기</li><li>체크섬</li></ul></li></ol></li><li>세그멘테이션 관련 고려사항<ol><li>세그먼트 크기 선택<ul><li>너무 크면: 재전송 시 비효율적</li><li>너무 작으면: 헤더 오버헤드 증가</li><li>최적의 크기 선택이 중요</li></ul></li><li>버퍼 관리: 수신측에서 세그먼트를 저장하고 재조립할 수 있는 충분한 버퍼 공간이 필요하다.</li><li>타이밍 관리: 재전송 타이머, 확인 응답 대기 시간 등을 적절히 관리해야 한다.</li></ol></li><li>TCP와 UDP의 세그멘테이션 차이<ul><li>TCP와 UDP는 세그멘테이션을 다르게 처리한다.</li><li>TCP의 세그멘테이션:<ul><li>신뢰성 있는 전송을 보장</li><li>순서 보장</li><li>흐름 제어와 혼잡 제어 제공</li><li>세그먼트 손실 시 재전송</li></ul></li><li>UDP의 세그멘테이션:<ul><li>단순히 데이터그램으로 나누기만 함</li><li>순서 보장 없음</li><li>신뢰성 보장 없음</li><li>더 빠른 전송 가능</li></ul></li></ul></li></ul></blockquote><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>종단 간 통신을 제공한다.</li><li>신뢰성 있는 데이터 전송을 보장한다.</li><li>포트 번호를 사용하여 애플리케이션을 식별한다.</li></ul><blockquote><p>port (포트)<br>네트워크에서 서로 다른 프로세스들이 통신할 수 있도록 구분해주는 논리적인 접속 위치.<br>각 포트는 16 비트 숫자로 표현되며, 범위는 0~65535<br>역할</p><ul><li>데이터 트래픽 분류: 포트는 컴퓨터가 받는 네트워크 트래픽을 종류별로 구분하는 데 도움을 준다.</li><li>서비스 식별: 각 포트는 특정 서비스나 애플리케이션과 연결되어 있어, 데이터가 어떤 서비스로 전달되어야 하는 식별</li><li>다중화 (Multiplexing): 하나의 네트워크 연결을 통해 여러 서비스나 애플리케이션이 동시에 통신할 수 있게 됨.<br>기능</li><li>통신 엔드포인트 제공: 네트워크 상의 특정 서비스나 프로세스와의 통신을 위한 엔드포인트</li><li>데이터 라우팅: 들어오는 데이터를 올바른 애플리케이션이나 서비스로 전달</li><li>프로토콜 구분: 각 포트는 특정 네트워크 프로토콜 (예: HTTP(80), HTTPS(443), FTP(21), SMTP(25)) 과 연관되어 있어 프로토콜 별 통신을 가능하게 함.</li><li>동시 연결 관리: 하나의 IP 주소에서 여러 개의 네트워크 연결을 동시에 관리할 수 있게 한다.</li></ul></blockquote><h3 id=데이터-단위와-구조>데이터 단위와 구조<a hidden class=anchor aria-hidden=true href=#데이터-단위와-구조>#</a></h3><p>데이터 단위: 세그먼트(TCP) 또는 데이터그램(UDP)<br>기본 구조: 헤더 + 데이터<br>헤더 필드:</p><ul><li>출발지 포트 번호</li><li>목적지 포트 번호</li><li>시퀀스 번호 (TCP)</li><li>확인 응답 번호 (TCP)</li><li>체크섬</li></ul><h3 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h3><ol><li>애플리케이션 계층에서 데이터를 받는다.</li><li>데이터를 세그먼트로 분할한다.</li><li>각 세그먼트에 헤더를 추가한다.</li><li>네트워크 계층으로 세그먼트를 전달한다.</li><li>수신 측에서는 세그먼트를 재조립하여 애플리케이션 계층으로 전달한다.</li></ol><h3 id=주요-프로토콜>주요 프로토콜<a hidden class=anchor aria-hidden=true href=#주요-프로토콜>#</a></h3><ol><li>TCP (Transmission Control Protocol):<ul><li>연결 지향적이고 신뢰성 있는 데이터 전송을 제공한다.</li><li>데이터의 순서를 보장하고 손실된 데이터를 재전송한다.</li><li>흐름 제어와 혼잡 제어 제공</li><li>3-way handshake: TCP 연결을 설정하는 과정.<ol><li>SYN: 연결 요청</li><li>SYN-ACK: 요청 승인</li><li>ACK: 연결 설정 완료</li></ol></li><li>4-way Handshake: 클라이언트와 서버 간의 연결을 종료하는 과정.<ol><li>FIN (클라이언트 → 서버): 클라이언트가 연결 종료를 요청.</li><li>ACK (서버 → 클라이언트): 서버가 FIN을 받았음을 확인. 클라이언트→서버 방향의 연결이 닫힌다.</li><li>FIN (서버 → 클라이언트): 서버가 모든 데이터 전송을 완료하고 연결 종료를 요청한다.</li><li>ACK (클라이언트 → 서버): 클라이언트가 서버의 FIN을 확인한다.</li></ol></li></ul></li><li>UDP (User Datagram Protocol):<ul><li>비연결형이고 신뢰성이 낮지만 빠른 전송을 제공한다.</li><li>순서나 신뢰성 보장 없음</li><li>실시간 애플리케이션에 적합하다.</li></ul></li></ol><h3 id=주의-사항>주의 사항<a hidden class=anchor aria-hidden=true href=#주의-사항>#</a></h3><ul><li>네트워크 혼잡을 방지하기 위한 적절한 흐름 제어가 필요하다.</li><li>TCP와 UDP의 특성을 이해하고 적절히 선택해야 한다.</li><li>포트 번호 충돌을 피해야 한다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-and-communications/>Networking-and-Communications</a></li><li><a href=https://buenhyden.github.io/tags/osi-7-layers/>OSI-7-Layers</a></li><li><a href=https://buenhyden.github.io/tags/transport-layer/>Transport-Layer</a></li><li><a href=https://buenhyden.github.io/tags/%EC%A0%84%EC%86%A1-%EA%B3%84%EC%B8%B5/>전송-계층</a></li><li><a href=https://buenhyden.github.io/tags/segmentation/>Segmentation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-4-application-layer/><span class=title>« Prev</span><br><span>TCP/IP 4계층 - 4. Application Layer</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/4-implementation/><span class=title>Next »</span><br><span>4. 구현 (Implementation)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>