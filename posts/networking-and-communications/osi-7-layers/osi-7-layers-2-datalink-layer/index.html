<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OSI 7 Layers - 2. DataLink Layer | hyunyoun's Blog</title>
<meta name=keywords content="Networking-and-Communications,OSI-7-Layers,Data-Link-Layer,데이터연결-계층,Framing"><meta name=description content="OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="OSI 7 Layers - 2. DataLink Layer"><meta property="og:description" content="OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-25T07:17:00+00:00"><meta property="article:modified_time" content="2024-09-25T07:17:00+00:00"><meta property="article:tag" content="Networking-and-Communications"><meta property="article:tag" content="OSI-7-Layers"><meta property="article:tag" content="Data-Link-Layer"><meta property="article:tag" content="데이터연결-계층"><meta property="article:tag" content="Framing"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="OSI 7 Layers - 2. DataLink Layer"><meta name=twitter:description content="OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Network","item":"https://buenhyden.github.io/posts/networking-and-communications/"},{"@type":"ListItem","position":3,"name":"Network Layer - OSI 7 계층","item":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/"},{"@type":"ListItem","position":4,"name":"OSI 7 Layers - 2. DataLink Layer","item":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OSI 7 Layers - 2. DataLink Layer","name":"OSI 7 Layers - 2. DataLink Layer","description":"OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당","keywords":["Networking-and-Communications","OSI-7-Layers","Data-Link-Layer","데이터연결-계층","Framing"],"articleBody":"DataLink Layer (데이터 연결 계층) OSI 7계층의 Data Link Layer (데이터 연결 계층)은 OSI 모델의 두 번째 계층으로, 물리적 네트워크에서 노드 간의 데이터 전송을 담당한다.\n이 계층은 상위 계층에서 받은 패킷을 프레임으로 캡슐화하고, 물리적 주소를 추가하여 데이터 전송을 관리한다.\nSource: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/\n기능 프레이밍 (Framing):\n패킷을 프레임으로 나누어 전송하며, 각 프레임의 시작과 끝을 정의하는 비트 패턴을 추가한다. 프레이밍 (Framing)\n데이터링크 계층에서의 프레이밍은 상위 계층에서 받은 데이터를 물리적 전송에 적합한 크기의 프레임(frame)으로 나누는 과정이다. 각 프레임은 데이터를 안전하게 전달하기 위한 추가 정보들을 포함하게 된다.\n프레임의 구조와 각 부분의 역할\n일반적인 프레임은 다음과 같은 구조를 가진다:\n시작 구분자(Start Delimiter): 프레임의 시작을 알리는 특별한 비트 패턴이다. 헤더(Header): 송신자와 수신자의 MAC 주소, 프레임 유형, 제어 정보 등을 포함한다. 페이로드(Payload): 실제 전송하고자 하는 데이터가 들어있는 부분. 트레일러(Trailer): 오류 검출을 위한 체크섬(CRC)과 프레임 끝을 나타내는 구분자를 포함한다. 프레이밍 방식의 종류\n프레이밍에는 여러 가지 방식이 있으며, 각각의 특징을 이해하는 것이 중요하다:\n문자 기반 프레이밍 특별한 문자를 사용하여 프레임의 시작과 끝을 표시한다. 예를 들어, ASCII 문자의 STX(Start of Text)와 ETX(End of Text)를 사용할 수 있다. 이는 간단하지만, 데이터 안에 이러한 특별 문자가 포함되어 있을 경우 문제가 될 수 있다. 비트 스터핑(Bit Stuffing) 특정 비트 패턴을 프레임의 경계로 사용하고, 데이터 내에 이러한 패턴이 나타나지 않도록 추가 비트를 삽입한다. 예를 들어, 여섯 개의 연속된 1을 경계로 사용한다면, 데이터 내에서 다섯 개의 연속된 1이 나타날 때마다 0을 삽입한다. 바이트 수 표시\n프레임의 시작 부분에 전체 프레임의 길이를 명시한다.\n이는 단순하고 효율적이지만, 길이 필드가 손상될 경우 프레임 전체를 잃을 수 있다.\n프레이밍의 중요성과 이점 - 신뢰성 있는 전송: 프레이밍은 데이터의 경계를 명확히 하고 오류를 검출할 수 있게 해준다. - 흐름 제어와 오류 제어: 각 프레임 단위로 흐름 제어와 오류 제어를 수행할 수 있다. 문제가 발생하면 해당 프레임만 재전송하면 된다. - 효율적인 네트워크 사용: 적절한 크기의 프레임으로 나눔으로써 네트워크 자원을 효율적으로 사용할 수 있다.\n프레이밍 관련 주의사항\u003e - 프레임 크기: 너무 크면 오류 가능성이 높아지고, 너무 작으면 오버헤드가 증가한다. 따라서 적절한 크기 선택이 중요하다.\n오버헤드 고려: 각 프레임마다 헤더와 트레일러가 추가되므로, 이로 인한 오버헤드를 고려해야 한다.\n프레임 동기화: 수신자가 프레임의 시작과 끝을 정확히 인식할 수 있도록 해야 한다.\n```python class Frame: def __init__(self): self.start_delimiter = 0x7E # 프레임 시작 표시 self.destination_address = None # 목적지 MAC 주소 self.source_address = None # 출발지 MAC 주소 self.data = None # 실제 데이터 self.fcs = None # Frame Check Sequence self.end_delimiter = 0x7E # 프레임 종료 표시 ``` 물리적 주소 지정 (Physical Addressing):\n각 프레임에 송신자와 수신자의 MAC 주소를 포함시킨다. 오류 감지 및 수정 (Error Detection and Correction):\n체크섬, CRC(순환 중복 검사) 등을 사용하여 오류를 감지하고, 오류 발생 시 재전송 요청을 한다. CRC(Cyclic Redundancy Check)\n데이터의 무결성을 확인하기 위한 오류 감지 코드.\n목적 데이터 전송 중 발생할 수 있는 오류를 감지한다. 저장 장치에서 데이터의 정확성을 확인한다. 작동 방식 데이터를 이진 다항식으로 취급한다. 미리 정의된 생성 다항식으로 데이터를 나눈다. 나눗셈의 나머지가 CRC 체크섬이 된다. 이 체크섬을 데이터에 추가하여 전송한다. 수신자는 같은 과정을 반복하여 체크섬을 계산한다. 계산된 체크섬과 받은 체크섬을 비교한다. 장점 구현이 간단하다. 하드웨어로 쉽게 구현할 수 있다. 일반적인 전송 오류를 효과적으로 감지한다. 활용 네트워크 통신에서 데이터 무결성 확인. 저장 장치에서 데이터 정확성 검증 다양한 통신 프로토콜에서 오류 감지에 사용. 흐름 제어 (Flow Control):\n송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 조절한다. 매체 접근 제어 (Media Access Control):\n여러 장치가 동일한 전송 매체를 사용할 때 충돌을 방지하기 위한 규칙을 설정한다. 특징 복잡성: 데이터 링크 계층은 하드웨어의 복잡성을 숨기고, 상위 계층에 간단한 인터페이스를 제공한다. 하위 계층 의존성: 물리적 계층에 의존하여 데이터를 전송하며, 물리적 매체의 특성에 따라 다르게 동작할 수 있다. 두 개의 서브 레이어 데이터 링크 계층은 두 개의 부계층으로 나뉜다:\n1 2 3 [데이터링크 계층] ├── LLC (Logical Link Control) - 상위 계층 └── MAC (Media Access Control) - 하위 계층 LLC(Logical Link Control) 계층 데이터링크 계층의 상위 계층으로, 네트워크 계층과 MAC 계층 사이의 인터페이스 역할을 한다.\n프로토콜 다중화 및 흐름 제어 기능 제공한다.\n주요 기능:\n다중화 메커니즘 제공 (여러 네트워크 프로토콜이 동일한 네트워크 매체를 공유할 수 있게 함) 흐름 제어 오류 관리 프레임 동기화 MAC(Media Access Control) 계층 데이터링크 계층의 하위 계층으로, 물리적 매체와 직접 상호작용하는 하드웨어를 제어한다.\n물리적 매체 접근 관리 및 주소 지정\nMAC 주소 예시:\n1 00:1A:2B:3C:4D:5E 주요 기능:\n프레임 구분 및 인식 주소 지정 (MAC 주소 사용) 데이터 전송의 투명성 제공 오류 보호 (프레임 체크 시퀀스 생성 및 확인) 물리적 전송 매체에 대한 접근 제어 데이터 단위와 기본 구조 데이터 연결 계층의 기본 데이터 단위는 프레임(Frame)이다.\n기본 구조는 이와 같다:\n헤더(Header): MAC 주소 및 제어 정보 포함 데이터(Data): 상위 계층에서 받은 패킷 트레일러(Trailer): 오류 검출 정보 포함 1 [프레임 시작 구분자] [주소 필드] [제어 필드] [데이터 필드] [FCS] [프레임 종료 구분자] 각 필드의 역할은 다음과 같다:\n프레임 구분자 8비트 크기 프레임의 시작과 끝을 표시 일반적으로 특별한 비트 패턴 사용 (예: 10101011) 주소 필드 MAC 주소 포함 (출발지, 목적지) 각각 48비트 길이 (예: 00:1A:2B:3C:4D:5E) 제어 필드 프레임 종류 식별 순서 번호 흐름 제어 정보 데이터 필드 실제 전송할 데이터 일반적으로 46~1500바이트 FCS(Frame Check Sequence) 오류 검출을 위한 체크섬 CRC-32 알고리즘 사용 작동 방식 상위 계층에서 패킷을 수신하면 이를 프레임으로 캡슐화한다. 각 프레임에 송신자와 수신자의 MAC 주소를 추가하고, 오류 검출 정보를 포함시킨다. 프레임을 물리적 계층에 전달하여 전송한다. 수신 측에서는 비트를 받아 프레임으로 조립하고, 오류를 검사한 후 상위 계층으로 전달한다. 주의 사항 충돌 관리: 여러 장치가 동일한 매체를 사용할 때 충돌이 발생할 수 있으므로 이를 관리해야 한다. 신뢰성 보장: 데이터 링크 계층은 신뢰성 있는 전송을 보장하기 위해 오류 감지 및 수정 기능이 필요하다. 다양한 네트워크 기술 지원: Ethernet, Wi-Fi 등 다양한 기술에 따라 동작 방식이 달라질 수 있다. 주요 프로토콜과 기술 이더넷(Ethernet) 컴퓨터 네트워크 기술 중 가장 널리 사용되는 근거리 통신망(LAN) 기술.\n이더넷은 CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 방식을 사용한다.\n이를 실생활에 비유하면 다음과 같다:\n다른 사람이 말하고 있는지 확인 (Carrier Sense) 말하기 시작 (Multiple Access) 다른 사람과 동시에 말했는지 확인 (Collision Detection) 잠시 기다렸다가 다시 시도 이더넷(Ethernet) 프레임의 구조:\n1 [프리앰블(8바이트)][목적지 MAC(6바이트)][출발지 MAC(6바이트)][타입(2바이트)][데이터(46-1500바이트)][체크섬(4바이트)] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #### 이더넷 프레임의 구조 이더넷 프레임은 데이터를 전송하기 위한 기본 단위: ```python class EthernetFrame: def __init__(self): self.preamble = \"10101010\" * 7 # 동기화 self.sfd = \"10101011\" # 프레임 시작 self.dest_mac = \"\" # 목적지 MAC 주소 self.src_mac = \"\" # 출발지 MAC 주소 self.type = \"\" # 프로토콜 타입 self.data = \"\" # 실제 데이터 self.fcs = \"\" # 오류 검사 Preamble: 7바이트(56비트)의 특별한 패턴으로, 네트워크 장비들의 시계를 동기화하는 역할. SFD (Start Frame Delimiter): 1바이트(8비트)로, 실제 프레임의 시작을 알리는 표시. 프리앰블과 비슷하지만 마지막 비트가 다른 이 패턴은 “이제 진짜 데이터가 시작됩니다\"라고 알리는 신호와 같다. Destination MAC Address (목적지 MAC 주소): 6바이트(48비트) 길이의 수신자 하드웨어 주소. 각 네트워크 장비는 이 주소를 보고 자신에게 온 프레임인지 판단한다. 예를 들어 “00:1A:2B:3C:4D:5E” 같은 형식을 가진다. Source MAC Address (출발지 MAC 주소): 역시 6바이트(48비트) 길이로, 보내는 장비의 하드웨어 주소. 응답이 필요할 때 이 주소로 회신할 수 있다. Type (또는 Length): 2바이트(16비트)로, 두 가지 용도로 사용된다: 1500보다 큰 값: 상위 계층 프로토콜의 종류를 나타낸다 (예: IPv4는 0x0800). 1500이하의 값: 데이터 필드의 길이를 나타낸다. Data (페이로드): 46~1500바이트의 실제 전송할 데이터. 최소 46바이트가 되지 않으면 패딩(padding)을 추가하여 채운다. 이는 너무 작은 프레임으로 인한 충돌 감지의 어려움을 방지하기 위함. FCS (Frame Check Sequence): 4바이트(32비트)의 오류 검사 코드. CRC(Cyclic Redundancy Check) 알고리즘을 사용하여 프레임이 전송 중에 손상되었는지 확인. 이더넷의 장점과 특징:\n설치와 유지보수의 용이성 새로운 기기 추가가 쉬움 문제 발견이 쉬움 확장성: 네트워크 확장이 용이 이더넷의 현대적 발전:\nPower over Ethernet (PoE):\n네트워크 케이블을 통해 전력도 함께 공급 에너지 효율적 이더넷:\n사용하지 않을 때 전력 소비 감소 미래 발전 방향:\n속도 향상:\n현재 400Gbps 이더넷까지 개발되어 있으며, 더 빠른 속도를 위한 연구가 진행 중. 스마트 네트워킹:\n인공지능과 결합하여 더 효율적인 네트워크 관리가 가능해질 것으로 예상. PPP(Point-to-Point Protocol) 두 스테이션 간의 통신을 담당하며 강력한 보안기능과 여러가지 네트워크 계층 프로토콜을 한꺼번에 지원한다.\nPPP(Point-to-Point Protocol)는 VPN(Virtual Private Network) 기술의 기초가 되었으며, 모바일 네트워크에도 PPP의 개념이 활용된다.\n연결 설정 과정은 다음과 같은 단계로 이루어진다:\nLCP(Link Control Protocol) 단계 인증 단계 (선택사항) NCP(Network Control Protocol) 단계 PPP의 주요 구성 요소:\nLCP(Link Control Protocol): 링크를 설정하고 유지하는 역할을 담당한다. 최대 전송 단위(MTU) 설정 인증 프로토콜 선택 품질 모니터링 설정 인증 프로토콜: 두 가지 주요 인증 방식을 제공한다: PAP(Password Authentication Protocol) CHAP(Challenge Handshake Authentication Protocol) NCP(Network Control Protocol): 네트워크 계층 프로토콜을 설정한다. IP 주소 할당 DNS 서버 설정 라우팅 정보 교환 PPP 프레임의 기본 구조:\n1 2 3 4 5 6 7 8 class PPPFrame: def __init__(self): self.flag = '01111110' # 시작/끝 표시 self.address = 'FF' # 브로드캐스트 주소 self.control = '03' # 제어 필드 self.protocol = '' # 상위 계층 프로토콜 self.payload = '' # 실제 데이터 self.fcs = '' # 오류 검사 Flag (‘01111110’): 플래그는 프레임의 시작과 끝을 나타내는 1바이트의 특별한 비트 패턴. 01111110이라는 고유한 패턴을 사용하여 프레임의 시작과 끝을 명확하게 구분한다. 만약 데이터 내용 중에 이 패턴이 우연히 나타나면 비트 스터핑(bit stuffing)이라는 기술을 사용하여 구분한다. Address (‘FF’): PPP는 두 지점 간의 직접 연결이므로, 복잡한 주소 지정이 필요하지 않다. 따라서 이 필드는 항상 ‘FF’(브로드캐스트 주소)라는 단일 값을 사용한다. Control (‘03’): 제어 필드는 프레임의 종류와 기능을 나타낸다.\n기본값인 ‘03’은 비번호화된 정보를 의미이다.\n제어 필드는 다음과 같은 정보를 포함할 수 있다:\n- 프레임의 종류 (정보, 감독, 비번호)\n- 시퀀스 번호\n- 확인 응답 정보 Protocol: 상위 계층에서 사용하는 프로토콜의 종류를 나타내는 2바이트 필드.\n예를 들어:\n- 0x0021: IPv4\n- 0x0057: IPv6\n- 0xc021: LCP (Link Control Protocol)\n- 0x8021: IPCP (IP Control Protocol) Payload (실제 데이터): 전송하고자 하는 실제 데이터가 들어있는 필드. 이 부분의 크기는 가변적이며, MTU(Maximum Transmission Unit)에 따라 제한된다.\nPPP는 다음과 같은 특징을 가진 데이터를 전송할 수 있다: 일반적인 IP 패킷 압축된 TCP/IP 헤더 인증 데이터 링크 제어 정보 FCS (Frame Check Sequence): 프레임의 무결성을 검사하기 위한 오류 검사 코드. 기본적으로 16비트 CRC를 사용하지만, 선택적으로 32비트 CRC를 사용할 수도 있다.\nFCS는 다음과 같은 기능을 수행한다: 전송 중 발생할 수 있는 비트 오류 검출 데이터 손상 여부 확인 필요한 경우 재전송 요청 PPP의 특징과 장점:\n오류 감지와 복구: 데이터 전송 중 발생하는 오류를 감지하고 처리한다. 프레임 체크섬 검사 다중 프로토콜 지원: IP뿐만 아니라 다양한 네트워크 프로토콜을 지원한다. IP 프로토콜 지원 IPX 프로토콜 지원 압축 기능: 데이터를 압축하여 전송 효율을 높인다. 헤더 압축 데이터 압축 HDLC(High-Level Data Link Control) 두 장치 간에 데이터를 안전하고 효율적으로 전송하기 위한 데이터 링크 계층 프로토콜.\nHDLC의 작동 방식:\n연결 설정:\nSABM(Set Asynchronous Balanced Mode) 프레임 전송\nUA(Unnumbered Acknowledgment) 응답 대기 데이터 전송:\n정보 프레임 생성 및 전송\n확인응답 대기 오류 제어:\nHDLC는 다음과 같은 방식으로 오류를 처리한다:\n- REJ(Reject) 프레임 전송\n- 재전송 대기 HDLC 프레임의 구조:\n1 [Flag(8비트)][주소(8비트)][제어(8/16비트)][정보(가변길이)][FCS(16/32비트)][Flag(8비트)] 각 필드의 역할: Flag (01111110):\n프레임의 시작과 끝을 나타내는 특별한 비트 패턴.\n마치 편지의 봉투와 같은 역할을 한다. 주소 필드:\n데이터를 받을 장치의 주소를 나타낸다. 제어 필드:\n프레임의 종류와 순서 번호 등을 나타낸다. 정보 프레임(I-frame): 실제 데이터 전송 감독 프레임(S-frame): 흐름 제어와 오류 복구 비번호 프레임(U-frame): 연결 관리 HDLC의 주요 특징:\n비트 스터핑: 프레임 내에서 플래그 패턴이 우연히 나타나는 것을 방지한다. 전이중 통신: 양방향으로 동시에 데이터를 전송할 수 있다: 실제 활용 사례:\n전용선 통신: 두 지점 간의 안정적인 데이터 통신에 사용된다. 라우터 간 통신: 네트워크 장비 간의 데이터 전송에 활용된다. 실생활 예시로 이해하기 Wi-Fi 연결 과정:\n1 2 3 4 1. 노트북이 공유기를 발견 2. MAC 주소를 확인하여 연결 요청 3. 공유기가 응답하고 연결 수립 4. 데이터 교환 시작 스마트폰 핫스팟:\n다른 기기와 연결될 때 MAC 주소를 통한 식별이 이루어진다.\n문제 해결과 주의사항 일반적인 문제들과 해결 방법:\nMAC 주소 충돌 프레임 손실: 재전송 메커니즘을 통해 해결한다. 데이터링크 계층의 발전 방향 속도 개선:\n새로운 이더넷 표준의 개발:\n- 10 Gigabit Ethernet\n- 40/100 Gigabit Ethernet\n보안 강화:\nMAC 주소 필터링, 포트 보안 등의 기술 발전.\n에너지 효율:\n그린 이더넷 기술의 발전:\n- Energy Efficient Ethernet (IEEE 802.3az)\n- 저전력 모드 지원\n참고 및 출처 ","wordCount":"1876","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-25T07:17:00Z","dateModified":"2024-09-25T07:17:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/>Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/>Network Layer - OSI 7 계층</a></div><h1 class="post-title entry-hint-parent">OSI 7 Layers - 2. DataLink Layer</h1><div class=post-description>OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당</div><div class=post-meta><span title='2024-09-25 07:17:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1876 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#datalink-layer-데이터-연결-계층>DataLink Layer (데이터 연결 계층)</a><ul><li><a href=#기능>기능</a></li><li><a href=#특징>특징</a></li><li><a href=#데이터-단위와-기본-구조>데이터 단위와 기본 구조</a></li><li><a href=#작동-방식>작동 방식</a></li><li><a href=#주의-사항>주의 사항</a></li><li><a href=#주요-프로토콜과-기술>주요 프로토콜과 기술</a></li><li><a href=#실생활-예시로-이해하기>실생활 예시로 이해하기</a></li><li><a href=#문제-해결과-주의사항>문제 해결과 주의사항</a></li><li><a href=#데이터링크-계층의-발전-방향>데이터링크 계층의 발전 방향</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=datalink-layer-데이터-연결-계층>DataLink Layer (데이터 연결 계층)<a hidden class=anchor aria-hidden=true href=#datalink-layer-데이터-연결-계층>#</a></h2><p>OSI 7계층의 <strong>Data Link Layer</strong> (데이터 연결 계층)은 OSI 모델의 두 번째 계층으로, 물리적 네트워크에서 노드 간의 데이터 전송을 담당한다.<br>이 계층은 상위 계층에서 받은 패킷을 프레임으로 캡슐화하고, 물리적 주소를 추가하여 데이터 전송을 관리한다.</p><p><figure><img alt="Data Link Layer" loading=lazy src=/img/data_link_layer_osi_model.png><figcaption>Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/</figcaption></figure></p><h3 id=기능>기능<a hidden class=anchor aria-hidden=true href=#기능>#</a></h3><ol><li>프레이밍 (Framing):<br>패킷을 프레임으로 나누어 전송하며, 각 프레임의 시작과 끝을 정의하는 비트 패턴을 추가한다.</li></ol><blockquote><p>프레이밍 (Framing)<br>데이터링크 계층에서의 프레이밍은 상위 계층에서 받은 데이터를 물리적 전송에 적합한 크기의 프레임(frame)으로 나누는 과정이다. 각 프레임은 데이터를 안전하게 전달하기 위한 추가 정보들을 포함하게 된다.</p><p>프레임의 구조와 각 부분의 역할<br>일반적인 프레임은 다음과 같은 구조를 가진다:</p><ul><li>시작 구분자(Start Delimiter): 프레임의 시작을 알리는 특별한 비트 패턴이다.</li><li>헤더(Header): 송신자와 수신자의 MAC 주소, 프레임 유형, 제어 정보 등을 포함한다.</li><li>페이로드(Payload): 실제 전송하고자 하는 데이터가 들어있는 부분.</li><li>트레일러(Trailer): 오류 검출을 위한 체크섬(CRC)과 프레임 끝을 나타내는 구분자를 포함한다.</li></ul><p>프레이밍 방식의 종류<br>프레이밍에는 여러 가지 방식이 있으며, 각각의 특징을 이해하는 것이 중요하다:</p><ul><li>문자 기반 프레이밍<ul><li>특별한 문자를 사용하여 프레임의 시작과 끝을 표시한다.</li><li>예를 들어, ASCII 문자의 STX(Start of Text)와 ETX(End of Text)를 사용할 수 있다. 이는 간단하지만, 데이터 안에 이러한 특별 문자가 포함되어 있을 경우 문제가 될 수 있다.</li></ul></li><li>비트 스터핑(Bit Stuffing)<ul><li>특정 비트 패턴을 프레임의 경계로 사용하고, 데이터 내에 이러한 패턴이 나타나지 않도록 추가 비트를 삽입한다.</li><li>예를 들어, 여섯 개의 연속된 1을 경계로 사용한다면, 데이터 내에서 다섯 개의 연속된 1이 나타날 때마다 0을 삽입한다.</li></ul></li></ul><p>바이트 수 표시<br>프레임의 시작 부분에 전체 프레임의 길이를 명시한다.<br>이는 단순하고 효율적이지만, 길이 필드가 손상될 경우 프레임 전체를 잃을 수 있다.</p><p>프레이밍의 중요성과 이점
- 신뢰성 있는 전송: 프레이밍은 데이터의 경계를 명확히 하고 오류를 검출할 수 있게 해준다.
- 흐름 제어와 오류 제어: 각 프레임 단위로 흐름 제어와 오류 제어를 수행할 수 있다. 문제가 발생하면 해당 프레임만 재전송하면 된다.
- 효율적인 네트워크 사용: 적절한 크기의 프레임으로 나눔으로써 네트워크 자원을 효율적으로 사용할 수 있다.</p><p>프레이밍 관련 주의사항>
- 프레임 크기: 너무 크면 오류 가능성이 높아지고, 너무 작으면 오버헤드가 증가한다. 따라서 적절한 크기 선택이 중요하다.<br>오버헤드 고려: 각 프레임마다 헤더와 트레일러가 추가되므로, 이로 인한 오버헤드를 고려해야 한다.<br>프레임 동기화: 수신자가 프레임의 시작과 끝을 정확히 인식할 수 있도록 해야 한다.</p></blockquote><pre><code>```python
class Frame:
	def __init__(self):
		self.start_delimiter = 0x7E  # 프레임 시작 표시
		self.destination_address = None  # 목적지 MAC 주소
		self.source_address = None      # 출발지 MAC 주소
		self.data = None               # 실제 데이터
		self.fcs = None                # Frame Check Sequence
		self.end_delimiter = 0x7E      # 프레임 종료 표시
```
</code></pre><ol><li><p><strong>물리적 주소 지정 (Physical Addressing)</strong>:</p><ul><li>각 프레임에 송신자와 수신자의 MAC 주소를 포함시킨다.</li></ul></li><li><p><strong>오류 감지 및 수정 (Error Detection and Correction)</strong>:</p><ul><li>체크섬, CRC(순환 중복 검사) 등을 사용하여 오류를 감지하고, 오류 발생 시 재전송 요청을 한다.</li></ul></li></ol><blockquote><p>CRC(Cyclic Redundancy Check)<br>데이터의 무결성을 확인하기 위한 오류 감지 코드.</p><ul><li>목적<ul><li>데이터 전송 중 발생할 수 있는 오류를 감지한다.</li><li>저장 장치에서 데이터의 정확성을 확인한다.</li></ul></li><li>작동 방식<ol><li>데이터를 이진 다항식으로 취급한다.</li><li>미리 정의된 생성 다항식으로 데이터를 나눈다.</li><li>나눗셈의 나머지가 CRC 체크섬이 된다.</li><li>이 체크섬을 데이터에 추가하여 전송한다.</li><li>수신자는 같은 과정을 반복하여 체크섬을 계산한다.</li><li>계산된 체크섬과 받은 체크섬을 비교한다.</li></ol></li><li>장점<ul><li>구현이 간단하다.</li><li>하드웨어로 쉽게 구현할 수 있다.</li><li>일반적인 전송 오류를 효과적으로 감지한다.</li></ul></li><li>활용<ul><li>네트워크 통신에서 데이터 무결성 확인.</li><li>저장 장치에서 데이터 정확성 검증</li><li>다양한 통신 프로토콜에서 오류 감지에 사용.</li></ul></li></ul></blockquote><ol start=3><li><p><strong>흐름 제어 (Flow Control)</strong>:</p><ul><li>송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 조절한다.</li></ul></li><li><p><strong>매체 접근 제어 (Media Access Control)</strong>:</p><ul><li>여러 장치가 동일한 전송 매체를 사용할 때 충돌을 방지하기 위한 규칙을 설정한다.</li></ul></li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>복잡성</strong>: 데이터 링크 계층은 하드웨어의 복잡성을 숨기고, 상위 계층에 간단한 인터페이스를 제공한다.</li><li><strong>하위 계층 의존성</strong>: 물리적 계층에 의존하여 데이터를 전송하며, 물리적 매체의 특성에 따라 다르게 동작할 수 있다.</li></ul><h4 id=두-개의-서브-레이어>두 개의 서브 레이어<a hidden class=anchor aria-hidden=true href=#두-개의-서브-레이어>#</a></h4><p>데이터 링크 계층은 두 개의 부계층으로 나뉜다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[데이터링크 계층]
</span></span><span class=line><span class=cl>    ├── LLC (Logical Link Control) - 상위 계층
</span></span><span class=line><span class=cl>    └── MAC (Media Access Control) - 하위 계층
</span></span></code></pre></td></tr></table></div></div><h5 id=llclogical-link-control-계층>LLC(Logical Link Control) 계층<a hidden class=anchor aria-hidden=true href=#llclogical-link-control-계층>#</a></h5><p>데이터링크 계층의 상위 계층으로, 네트워크 계층과 MAC 계층 사이의 인터페이스 역할을 한다.<br>프로토콜 다중화 및 흐름 제어 기능 제공한다.</p><p>주요 기능:</p><ul><li>다중화 메커니즘 제공 (여러 네트워크 프로토콜이 동일한 네트워크 매체를 공유할 수 있게 함)</li><li>흐름 제어</li><li>오류 관리</li><li>프레임 동기화</li></ul><h5 id=macmedia-access-control-계층>MAC(Media Access Control) 계층<a hidden class=anchor aria-hidden=true href=#macmedia-access-control-계층>#</a></h5><p>데이터링크 계층의 하위 계층으로, 물리적 매체와 직접 상호작용하는 하드웨어를 제어한다.<br>물리적 매체 접근 관리 및 주소 지정</p><p>MAC 주소 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>00:1A:2B:3C:4D:5E
</span></span></code></pre></td></tr></table></div></div><p>주요 기능:</p><ul><li>프레임 구분 및 인식</li><li>주소 지정 (MAC 주소 사용)</li><li>데이터 전송의 투명성 제공</li><li>오류 보호 (프레임 체크 시퀀스 생성 및 확인)</li><li>물리적 전송 매체에 대한 접근 제어</li></ul><h3 id=데이터-단위와-기본-구조>데이터 단위와 기본 구조<a hidden class=anchor aria-hidden=true href=#데이터-단위와-기본-구조>#</a></h3><p>데이터 연결 계층의 기본 데이터 단위는 프레임(Frame)이다.</p><p>기본 구조는 이와 같다:</p><ul><li>헤더(Header): MAC 주소 및 제어 정보 포함</li><li>데이터(Data): 상위 계층에서 받은 패킷</li><li>트레일러(Trailer): 오류 검출 정보 포함</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[프레임 시작 구분자] [주소 필드] [제어 필드] [데이터 필드] [FCS] [프레임 종료 구분자]
</span></span></code></pre></td></tr></table></div></div><p>각 필드의 역할은 다음과 같다:</p><ol><li>프레임 구분자<ul><li>8비트 크기</li><li>프레임의 시작과 끝을 표시</li><li>일반적으로 특별한 비트 패턴 사용 (예: 10101011)</li></ul></li><li>주소 필드<ul><li>MAC 주소 포함 (출발지, 목적지)</li><li>각각 48비트 길이 (예: 00:1A:2B:3C:4D:5E)</li></ul></li><li>제어 필드<ul><li>프레임 종류 식별</li><li>순서 번호</li><li>흐름 제어 정보</li></ul></li><li>데이터 필드<ul><li>실제 전송할 데이터</li><li>일반적으로 46~1500바이트</li></ul></li><li>FCS(Frame Check Sequence)<ul><li>오류 검출을 위한 체크섬</li><li>CRC-32 알고리즘 사용</li></ul></li></ol><h3 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h3><ol><li>상위 계층에서 패킷을 수신하면 이를 프레임으로 캡슐화한다.</li><li>각 프레임에 송신자와 수신자의 MAC 주소를 추가하고, 오류 검출 정보를 포함시킨다.</li><li>프레임을 물리적 계층에 전달하여 전송한다.</li><li>수신 측에서는 비트를 받아 프레임으로 조립하고, 오류를 검사한 후 상위 계층으로 전달한다.</li></ol><h3 id=주의-사항>주의 사항<a hidden class=anchor aria-hidden=true href=#주의-사항>#</a></h3><ul><li>충돌 관리: 여러 장치가 동일한 매체를 사용할 때 충돌이 발생할 수 있으므로 이를 관리해야 한다.</li><li>신뢰성 보장: 데이터 링크 계층은 신뢰성 있는 전송을 보장하기 위해 오류 감지 및 수정 기능이 필요하다.</li><li>다양한 네트워크 기술 지원: Ethernet, Wi-Fi 등 다양한 기술에 따라 동작 방식이 달라질 수 있다.</li></ul><h3 id=주요-프로토콜과-기술>주요 프로토콜과 기술<a hidden class=anchor aria-hidden=true href=#주요-프로토콜과-기술>#</a></h3><h4 id=이더넷ethernet>이더넷(Ethernet)<a hidden class=anchor aria-hidden=true href=#이더넷ethernet>#</a></h4><p>컴퓨터 네트워크 기술 중 가장 널리 사용되는 근거리 통신망(LAN) 기술.</p><p>이더넷은 CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 방식을 사용한다.<br>이를 실생활에 비유하면 다음과 같다:</p><ol><li>다른 사람이 말하고 있는지 확인 (Carrier Sense)</li><li>말하기 시작 (Multiple Access)</li><li>다른 사람과 동시에 말했는지 확인 (Collision Detection)</li><li>잠시 기다렸다가 다시 시도</li></ol><p>이더넷(Ethernet) 프레임의 구조:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[프리앰블(8바이트)][목적지 MAC(6바이트)][출발지 MAC(6바이트)][타입(2바이트)][데이터(46-1500바이트)][체크섬(4바이트)]
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#### 이더넷 프레임의 구조
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>이더넷 프레임은 데이터를 전송하기 위한 기본 단위:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>```python
</span></span><span class=line><span class=cl>class EthernetFrame:
</span></span><span class=line><span class=cl>    def __init__(self):
</span></span><span class=line><span class=cl>        self.preamble = &#34;10101010&#34; * 7  # 동기화
</span></span><span class=line><span class=cl>        self.sfd = &#34;10101011&#34;           # 프레임 시작
</span></span><span class=line><span class=cl>        self.dest_mac = &#34;&#34;              # 목적지 MAC 주소
</span></span><span class=line><span class=cl>        self.src_mac = &#34;&#34;               # 출발지 MAC 주소
</span></span><span class=line><span class=cl>        self.type = &#34;&#34;                  # 프로토콜 타입
</span></span><span class=line><span class=cl>        self.data = &#34;&#34;                  # 실제 데이터
</span></span><span class=line><span class=cl>        self.fcs = &#34;&#34;                   # 오류 검사
</span></span></code></pre></td></tr></table></div></div><ul><li>Preamble: 7바이트(56비트)의 특별한 패턴으로, 네트워크 장비들의 시계를 동기화하는 역할.</li><li>SFD (Start Frame Delimiter): 1바이트(8비트)로, 실제 프레임의 시작을 알리는 표시. 프리앰블과 비슷하지만 마지막 비트가 다른 이 패턴은 &ldquo;이제 진짜 데이터가 시작됩니다"라고 알리는 신호와 같다.</li><li>Destination MAC Address (목적지 MAC 주소): 6바이트(48비트) 길이의 수신자 하드웨어 주소. 각 네트워크 장비는 이 주소를 보고 자신에게 온 프레임인지 판단한다. 예를 들어 &ldquo;00:1A:2B:3C:4D:5E&rdquo; 같은 형식을 가진다.</li><li>Source MAC Address (출발지 MAC 주소): 역시 6바이트(48비트) 길이로, 보내는 장비의 하드웨어 주소. 응답이 필요할 때 이 주소로 회신할 수 있다.</li><li>Type (또는 Length): 2바이트(16비트)로, 두 가지 용도로 사용된다:<ul><li>1500보다 큰 값: 상위 계층 프로토콜의 종류를 나타낸다 (예: IPv4는 0x0800).</li><li>1500이하의 값: 데이터 필드의 길이를 나타낸다.</li></ul></li><li>Data (페이로드): 46~1500바이트의 실제 전송할 데이터. 최소 46바이트가 되지 않으면 패딩(padding)을 추가하여 채운다. 이는 너무 작은 프레임으로 인한 충돌 감지의 어려움을 방지하기 위함.</li><li>FCS (Frame Check Sequence): 4바이트(32비트)의 오류 검사 코드. CRC(Cyclic Redundancy Check) 알고리즘을 사용하여 프레임이 전송 중에 손상되었는지 확인.</li></ul><p>이더넷의 장점과 특징:</p><ol><li>설치와 유지보수의 용이성<ul><li>새로운 기기 추가가 쉬움</li><li>문제 발견이 쉬움</li></ul></li><li>확장성:<ul><li>네트워크 확장이 용이</li></ul></li></ol><p>이더넷의 현대적 발전:</p><ol><li>Power over Ethernet (PoE):<br>네트워크 케이블을 통해 전력도 함께 공급</li><li>에너지 효율적 이더넷:<br>사용하지 않을 때 전력 소비 감소</li></ol><p>미래 발전 방향:</p><ol><li>속도 향상:<br>현재 400Gbps 이더넷까지 개발되어 있으며, 더 빠른 속도를 위한 연구가 진행 중.</li><li>스마트 네트워킹:<br>인공지능과 결합하여 더 효율적인 네트워크 관리가 가능해질 것으로 예상.</li></ol><h4 id=ppppoint-to-point-protocol>PPP(Point-to-Point Protocol)<a hidden class=anchor aria-hidden=true href=#ppppoint-to-point-protocol>#</a></h4><p>두 스테이션 간의 통신을 담당하며 강력한 보안기능과 여러가지 네트워크 계층 프로토콜을 한꺼번에 지원한다.</p><p>PPP(Point-to-Point Protocol)는 VPN(Virtual Private Network) 기술의 기초가 되었으며, 모바일 네트워크에도 PPP의 개념이 활용된다.</p><p>연결 설정 과정은 다음과 같은 단계로 이루어진다:</p><ol><li>LCP(Link Control Protocol) 단계</li><li>인증 단계 (선택사항)</li><li>NCP(Network Control Protocol) 단계</li></ol><p>PPP의 주요 구성 요소:</p><ol><li>LCP(Link Control Protocol): 링크를 설정하고 유지하는 역할을 담당한다.<ul><li>최대 전송 단위(MTU) 설정</li><li>인증 프로토콜 선택</li><li>품질 모니터링 설정</li></ul></li><li>인증 프로토콜: 두 가지 주요 인증 방식을 제공한다:<ol><li>PAP(Password Authentication Protocol)</li><li>CHAP(Challenge Handshake Authentication Protocol)</li></ol></li><li>NCP(Network Control Protocol): 네트워크 계층 프로토콜을 설정한다.<ol><li>IP 주소 할당</li><li>DNS 서버 설정</li><li>라우팅 정보 교환</li></ol></li></ol><p>PPP 프레임의 기본 구조:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>PPPFrame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>flag</span> <span class=o>=</span> <span class=s1>&#39;01111110&#39;</span>          <span class=c1># 시작/끝 표시</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=s1>&#39;FF&#39;</span>             <span class=c1># 브로드캐스트 주소</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>control</span> <span class=o>=</span> <span class=s1>&#39;03&#39;</span>             <span class=c1># 제어 필드</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>protocol</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>              <span class=c1># 상위 계층 프로토콜</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>payload</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>               <span class=c1># 실제 데이터</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>fcs</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span>                   <span class=c1># 오류 검사</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Flag (&lsquo;01111110&rsquo;): 플래그는 프레임의 시작과 끝을 나타내는 1바이트의 특별한 비트 패턴. 01111110이라는 고유한 패턴을 사용하여 프레임의 시작과 끝을 명확하게 구분한다. 만약 데이터 내용 중에 이 패턴이 우연히 나타나면 비트 스터핑(bit stuffing)이라는 기술을 사용하여 구분한다.</li><li>Address (&lsquo;FF&rsquo;): PPP는 두 지점 간의 직접 연결이므로, 복잡한 주소 지정이 필요하지 않다. 따라서 이 필드는 항상 &lsquo;FF&rsquo;(브로드캐스트 주소)라는 단일 값을 사용한다.</li><li>Control (&lsquo;03&rsquo;): 제어 필드는 프레임의 종류와 기능을 나타낸다.<br>기본값인 &lsquo;03&rsquo;은 비번호화된 정보를 의미이다.<br>제어 필드는 다음과 같은 정보를 포함할 수 있다:<br>- 프레임의 종류 (정보, 감독, 비번호)<br>- 시퀀스 번호<br>- 확인 응답 정보</li><li>Protocol: 상위 계층에서 사용하는 프로토콜의 종류를 나타내는 2바이트 필드.<br>예를 들어:<br>- 0x0021: IPv4<br>- 0x0057: IPv6<br>- 0xc021: LCP (Link Control Protocol)<br>- 0x8021: IPCP (IP Control Protocol)</li><li>Payload (실제 데이터): 전송하고자 하는 실제 데이터가 들어있는 필드. 이 부분의 크기는 가변적이며, MTU(Maximum Transmission Unit)에 따라 제한된다.<br>PPP는 다음과 같은 특징을 가진 데이터를 전송할 수 있다:<ul><li>일반적인 IP 패킷</li><li>압축된 TCP/IP 헤더</li><li>인증 데이터</li><li>링크 제어 정보</li></ul></li><li>FCS (Frame Check Sequence): 프레임의 무결성을 검사하기 위한 오류 검사 코드. 기본적으로 16비트 CRC를 사용하지만, 선택적으로 32비트 CRC를 사용할 수도 있다.<br>FCS는 다음과 같은 기능을 수행한다:<ul><li>전송 중 발생할 수 있는 비트 오류 검출</li><li>데이터 손상 여부 확인</li><li>필요한 경우 재전송 요청</li></ul></li></ul><p>PPP의 특징과 장점:</p><ol><li>오류 감지와 복구: 데이터 전송 중 발생하는 오류를 감지하고 처리한다.<ul><li>프레임 체크섬 검사</li></ul></li><li>다중 프로토콜 지원: IP뿐만 아니라 다양한 네트워크 프로토콜을 지원한다.<ul><li>IP 프로토콜 지원</li><li>IPX 프로토콜 지원</li></ul></li><li>압축 기능: 데이터를 압축하여 전송 효율을 높인다.<ul><li>헤더 압축</li><li>데이터 압축</li></ul></li></ol><h4 id=hdlchigh-level-data-link-control>HDLC(High-Level Data Link Control)<a hidden class=anchor aria-hidden=true href=#hdlchigh-level-data-link-control>#</a></h4><p>두 장치 간에 데이터를 안전하고 효율적으로 전송하기 위한 데이터 링크 계층 프로토콜.</p><p>HDLC의 작동 방식:</p><ol><li>연결 설정:<br>SABM(Set Asynchronous Balanced Mode) 프레임 전송<br>UA(Unnumbered Acknowledgment) 응답 대기</li><li>데이터 전송:<br>정보 프레임 생성 및 전송<br>확인응답 대기</li><li>오류 제어:<br>HDLC는 다음과 같은 방식으로 오류를 처리한다:<br>- REJ(Reject) 프레임 전송<br>- 재전송 대기</li></ol><p>HDLC 프레임의 구조:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Flag(8비트)][주소(8비트)][제어(8/16비트)][정보(가변길이)][FCS(16/32비트)][Flag(8비트)]
</span></span></code></pre></td></tr></table></div></div><ul><li>각 필드의 역할:<ol><li>Flag (01111110):<br>프레임의 시작과 끝을 나타내는 특별한 비트 패턴.<br>마치 편지의 봉투와 같은 역할을 한다.</li><li>주소 필드:<br>데이터를 받을 장치의 주소를 나타낸다.</li><li>제어 필드:<br>프레임의 종류와 순서 번호 등을 나타낸다.<ul><li>정보 프레임(I-frame): 실제 데이터 전송</li><li>감독 프레임(S-frame): 흐름 제어와 오류 복구</li><li>비번호 프레임(U-frame): 연결 관리</li></ul></li></ol></li></ul><p>HDLC의 주요 특징:</p><ol><li>비트 스터핑: 프레임 내에서 플래그 패턴이 우연히 나타나는 것을 방지한다.</li><li>전이중 통신: 양방향으로 동시에 데이터를 전송할 수 있다:</li></ol><p>실제 활용 사례:</p><ol><li>전용선 통신: 두 지점 간의 안정적인 데이터 통신에 사용된다.</li><li>라우터 간 통신: 네트워크 장비 간의 데이터 전송에 활용된다.</li></ol><h3 id=실생활-예시로-이해하기>실생활 예시로 이해하기<a hidden class=anchor aria-hidden=true href=#실생활-예시로-이해하기>#</a></h3><ol><li><p>Wi-Fi 연결 과정:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 노트북이 공유기를 발견
</span></span><span class=line><span class=cl>2. MAC 주소를 확인하여 연결 요청
</span></span><span class=line><span class=cl>3. 공유기가 응답하고 연결 수립
</span></span><span class=line><span class=cl>4. 데이터 교환 시작
</span></span></code></pre></td></tr></table></div></div></li><li><p>스마트폰 핫스팟:<br>다른 기기와 연결될 때 MAC 주소를 통한 식별이 이루어진다.</p></li></ol><h3 id=문제-해결과-주의사항>문제 해결과 주의사항<a hidden class=anchor aria-hidden=true href=#문제-해결과-주의사항>#</a></h3><p>일반적인 문제들과 해결 방법:</p><ol><li>MAC 주소 충돌</li><li>프레임 손실: 재전송 메커니즘을 통해 해결한다.</li></ol><h3 id=데이터링크-계층의-발전-방향>데이터링크 계층의 발전 방향<a hidden class=anchor aria-hidden=true href=#데이터링크-계층의-발전-방향>#</a></h3><ol><li><p>속도 개선:<br>새로운 이더넷 표준의 개발:<br>- 10 Gigabit Ethernet<br>- 40/100 Gigabit Ethernet</p></li><li><p>보안 강화:<br>MAC 주소 필터링, 포트 보안 등의 기술 발전.</p></li><li><p>에너지 효율:<br>그린 이더넷 기술의 발전:<br>- Energy Efficient Ethernet (IEEE 802.3az)<br>- 저전력 모드 지원</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-and-communications/>Networking-and-Communications</a></li><li><a href=https://buenhyden.github.io/tags/osi-7-layers/>OSI-7-Layers</a></li><li><a href=https://buenhyden.github.io/tags/data-link-layer/>Data-Link-Layer</a></li><li><a href=https://buenhyden.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%B0%EA%B2%B0-%EA%B3%84%EC%B8%B5/>데이터연결-계층</a></li><li><a href=https://buenhyden.github.io/tags/framing/>Framing</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-2-internet-layer/><span class=title>« Prev</span><br><span>TCP/IP 4계층 - 2. Internet Layer</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/3-design/><span class=title>Next »</span><br><span>3. 설계 (Design)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>