<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Serverless deployment | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,MSA-Patterns,Deployment,Serverless-deployment"><meta name=description content="Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/serverless-deployment/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/serverless-deployment/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/serverless-deployment/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Serverless deployment"><meta property="og:description" content="Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-13T11:34:00+00:00"><meta property="article:modified_time" content="2024-11-13T11:34:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Deployment"><meta property="article:tag" content="Serverless-Deployment"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Serverless deployment"><meta name=twitter:description content="Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps and Infrastructure","item":"https://buenhyden.github.io/posts/devops-and-platform-engineering/"},{"@type":"ListItem","position":3,"name":"CI/CD","item":"https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/"},{"@type":"ListItem","position":4,"name":"Serverless deployment","item":"https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/serverless-deployment/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Serverless deployment","name":"Serverless deployment","description":"Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다.","keywords":["System-and-Software-Architecture","MSA-Patterns","Deployment","Serverless-deployment"],"articleBody":"Serverless Deployment Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 접근 방식이다.\nServerless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.\n결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.\n주요 특징 자동 확장성: 평소에는 5명의 사용자가 사용하는 앱이 있다고 가정하자. 해당 앱의 사용자가 어느 날 1000명이 된다면 서버리스는 1000개의 트래픽을 감당할 수 있는 인스턴스를 동적으로 증가시켜 요청을 처리할 수 있다. 비용 효율성: 리소스를 사용한 만큼만 비용으로 청구하기 때문에, 경제적으로 유리하다. 유휴 상태의 서버에 대한 비용을 지불할 필요가 없다. 개발 집중: 개발자는 백엔드 서버의 구매, 프로비저닝, 관리에 대해 걱정할 필요가 없다. 클라우드 제공업체가 서버 인프라에 대한 프로비저닝, 유지 관리, 스케일링 등의 일상적인 작업을 처리하며, 개발자는 배포를 위해 코드를 컨테이너에 패키징하기만 하면 된다. 이벤트 기반 실행: 서버리스 애플리케이션은 배포되고 나면 필요에 따라 자동으로 스케일 업되거나 스케일 다운된다. 퍼블릭 클라우드 제공업체의 서버리스 오퍼링은 일반적으로 이벤트 기반 실행 모델을 통해 온디맨드로 미터링된다. 그러므로 서버리스 기능이 유휴 상태일 때는 아무런 비용도 들지 않는다. 장점 빠른 개발 및 배포: 서버리스는 개발자가 프로비저닝하기 위한 작업에 필요한 인프라를 명시적으로 설명할 필요를 줄여줌으로써 DevOps 도입을 지원한다. 제3사 BaaS 오퍼링의 모든 구성 요소를 통합해 애플리케이션 개발을 더욱 간소화할 수도 있다. 운영 비용 절감: 서버리스 모델에서 운영 비용이 낮아지는 이유는 항상 자체 서버를 실행하고 관리하는 대신 필요한 만큼 클라우드 기반 컴퓨팅 시간에 대해 비용을 지불하기 때문이다. 글로벌 확장 용이성: Lambda@Edge를 통해 글로벌 애플리케이션을 만들 수 있다. CloudFront 요청과 응답을 변경하기 위해 사용한다. 즉, 뷰어 요청을 오리진으로 보내지 않고도 viewer request, viewer response 람다 함수를 통해 뷰어에게 응답을 줄 수 있다. 단점 콜드 스타트: 서버리스 함수가 처음 호출될 때 초기화 시간이 소요될 수 있어서 Cold Start라는 현상이 발생할 수 있다. 이는 응답 시간에 영향을 줄 수 있다. 제한된 실행 환경: 서버리스 환경에서는 일부 제약이 있을 수 있으며, 실행 시간이나 메모리 크기 등이 제한될 수 있다. 디버깅 어려움: 로컬 환경에서 디버깅하기 어려울 수 있으며, 특히 이벤트 기반의 함수에서는 테스트 하기가 어려울 수 있다. 주요 서버리스 플랫폼 AWS Lambda Microsoft Azure Functions Google Cloud Functions IBM Cloud Functions Cloudflare Workers 이러한 플랫폼들은 각각의 특징과 장단점을 가지고 있으며, 개발자는 프로젝트의 요구사항에 따라 적절한 플랫폼을 선택할 수 있다.\n사용 예시 예를 들어, AWS Lambda를 사용하여 서버리스 배포를 진행하려면 다음과 같은 단계를 따른다:\n코드 작성: Lambda 함수로 실행할 코드를 작성한다. 패키징: 코드를 ZIP 파일로 묶는다. 업로드: AWS Lambda 콘솔이나 CLI를 통해 ZIP 파일을 업로드한다. 트리거 설정: HTTP 요청을 처리하려면 API Gateway를 설정하여 Lambda 함수를 트리거한다. 참고 및 출처 ","wordCount":"440","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-13T11:34:00Z","dateModified":"2024-11-13T11:34:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/serverless-deployment/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-platform-engineering/>DevOps and Infrastructure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/>CI/CD</a></div><h1 class="post-title entry-hint-parent">Serverless deployment</h1><div class=post-description>Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다.</div><div class=post-meta><span title='2024-11-13 11:34:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/DevOps%20and%20Platform%20Engineering/CI-CD/Deployment%20and%20Operations/serverless-deployment.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#serverless-deployment>Serverless Deployment</a><ul><li><a href=#주요-특징>주요 특징</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#주요-서버리스-플랫폼>주요 서버리스 플랫폼</a></li><li><a href=#사용-예시>사용 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=serverless-deployment>Serverless Deployment<a hidden class=anchor aria-hidden=true href=#serverless-deployment>#</a></h2><p>Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 접근 방식이다.</p><p>Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.</p><p>결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.</p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li>자동 확장성: 평소에는 5명의 사용자가 사용하는 앱이 있다고 가정하자. 해당 앱의 사용자가 어느 날 1000명이 된다면 서버리스는 1000개의 트래픽을 감당할 수 있는 인스턴스를 동적으로 증가시켜 요청을 처리할 수 있다.</li><li>비용 효율성: 리소스를 사용한 만큼만 비용으로 청구하기 때문에, 경제적으로 유리하다. 유휴 상태의 서버에 대한 비용을 지불할 필요가 없다.</li><li>개발 집중: 개발자는 백엔드 서버의 구매, 프로비저닝, 관리에 대해 걱정할 필요가 없다. 클라우드 제공업체가 서버 인프라에 대한 프로비저닝, 유지 관리, 스케일링 등의 일상적인 작업을 처리하며, 개발자는 배포를 위해 코드를 컨테이너에 패키징하기만 하면 된다.</li><li>이벤트 기반 실행: 서버리스 애플리케이션은 배포되고 나면 필요에 따라 자동으로 스케일 업되거나 스케일 다운된다. 퍼블릭 클라우드 제공업체의 서버리스 오퍼링은 일반적으로 이벤트 기반 실행 모델을 통해 온디맨드로 미터링된다. 그러므로 서버리스 기능이 유휴 상태일 때는 아무런 비용도 들지 않는다.</li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>빠른 개발 및 배포: 서버리스는 개발자가 프로비저닝하기 위한 작업에 필요한 인프라를 명시적으로 설명할 필요를 줄여줌으로써 DevOps 도입을 지원한다. 제3사 BaaS 오퍼링의 모든 구성 요소를 통합해 애플리케이션 개발을 더욱 간소화할 수도 있다.</li><li>운영 비용 절감: 서버리스 모델에서 운영 비용이 낮아지는 이유는 항상 자체 서버를 실행하고 관리하는 대신 필요한 만큼 클라우드 기반 컴퓨팅 시간에 대해 비용을 지불하기 때문이다.</li><li>글로벌 확장 용이성: Lambda@Edge를 통해 글로벌 애플리케이션을 만들 수 있다. CloudFront 요청과 응답을 변경하기 위해 사용한다. 즉, 뷰어 요청을 오리진으로 보내지 않고도 viewer request, viewer response 람다 함수를 통해 뷰어에게 응답을 줄 수 있다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li>콜드 스타트: 서버리스 함수가 처음 호출될 때 초기화 시간이 소요될 수 있어서 Cold Start라는 현상이 발생할 수 있다. 이는 응답 시간에 영향을 줄 수 있다.</li><li>제한된 실행 환경: 서버리스 환경에서는 일부 제약이 있을 수 있으며, 실행 시간이나 메모리 크기 등이 제한될 수 있다.</li><li>디버깅 어려움: 로컬 환경에서 디버깅하기 어려울 수 있으며, 특히 이벤트 기반의 함수에서는 테스트 하기가 어려울 수 있다.</li></ol><h3 id=주요-서버리스-플랫폼>주요 서버리스 플랫폼<a hidden class=anchor aria-hidden=true href=#주요-서버리스-플랫폼>#</a></h3><ol><li>AWS Lambda</li><li>Microsoft Azure Functions</li><li>Google Cloud Functions</li><li>IBM Cloud Functions</li><li>Cloudflare Workers</li></ol><p>이러한 플랫폼들은 각각의 특징과 장단점을 가지고 있으며, 개발자는 프로젝트의 요구사항에 따라 적절한 플랫폼을 선택할 수 있다.</p><h3 id=사용-예시>사용 예시<a hidden class=anchor aria-hidden=true href=#사용-예시>#</a></h3><p>예를 들어, AWS Lambda를 사용하여 서버리스 배포를 진행하려면 다음과 같은 단계를 따른다:</p><ol><li><strong>코드 작성:</strong> Lambda 함수로 실행할 코드를 작성한다.</li><li><strong>패키징:</strong> 코드를 ZIP 파일로 묶는다.</li><li><strong>업로드:</strong> AWS Lambda 콘솔이나 CLI를 통해 ZIP 파일을 업로드한다.</li><li><strong>트리거 설정:</strong> HTTP 요청을 처리하려면 API Gateway를 설정하여 Lambda 함수를 트리거한다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/deployment/>Deployment</a></li><li><a href=https://buenhyden.github.io/tags/serverless-deployment/>Serverless-Deployment</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/deployment-and-operations/single-service-per-host/><span class=title>« Prev</span><br><span>Single Service per Host</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented/service-decomposition-strategies/self-contained-service/><span class=title>Next »</span><br><span>Self-contained Service</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>