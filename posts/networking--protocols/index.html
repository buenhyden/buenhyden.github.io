<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking & Protocols | hyunyoun's Blog</title><meta name=keywords content="Networking-and-Protocols"><meta name=description content="Networking & Protocols - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking--protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking & Protocols"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking & Protocols"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Networking \u0026 Protocols","item":"https://buenhyden.github.io/posts/networking--protocols/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Networking & Protocols</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Idempotent Consumer</h2></header><div class=entry-content><p>Idempotent Consumer Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.
Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.
Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 11:43:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Idempotent Consumer" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-processing/idempotent-processing/idempotent-consumer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Producer-Consumer Pattern</h2></header><div class=entry-content><p>Producer-Consumer Pattern Producer-Consumer Pattern은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 주로 동시성 프로그래밍과 분산 시스템에서 사용된다.
이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.
https://jenkov.com/tutorials/java-concurrency/producer-consumer.html
주요 구성 요소 프로듀서 (Producer): 데이터나 작업을 생성하는 엔티티. 컨슈머 (Consumer): 프로듀서가 생성한 데이터나 작업을 처리하는 엔티티. 버퍼 (Buffer): 프로듀서와 컨슈머 사이에서 데이터를 임시 저장하는 공유 자원. 주로 큐(Queue)의 형태로 구현된다. 작동 방식 프로듀서는 데이터나 작업을 생성하여 버퍼에 추가한다. 컨슈머는 버퍼에서 데이터나 작업을 가져와 처리한다. 버퍼는 프로듀서와 컨슈머 사이의 중간 저장소 역할을 하며, 동기화를 관리한다. 주요 특징 비동기 처리: 프로듀서와 컨슈머가 독립적으로 작동하여 비동기 처리가 가능하다. 버퍼링: 버퍼를 통해 생산과 소비 속도의 차이를 조절할 수 있다. 병렬 처리: 여러 프로듀서와 컨슈머가 동시에 작업할 수 있어 병렬 처리가 가능하다. 느슨한 결합: 프로듀서와 컨슈머는 서로에 대해 직접적인 의존성이 없다. 장점 처리량 향상: 생산과 소비를 병렬로 수행하여 전체 시스템의 처리량을 높일 수 있다. 유연성: 프로듀서와 컨슈머를 독립적으로 확장할 수 있다. 부하 분산: 버퍼를 통해 작업 부하를 균등하게 분산시킬 수 있다. 피크 부하 관리: 일시적인 부하 증가를 버퍼를 통해 완화할 수 있다. 단점 복잡성: 동기화와 버퍼 관리로 인해 시스템 복잡도가 증가할 수 있다. 메모리 사용: 버퍼가 큰 경우 메모리 사용량이 증가할 수 있다. 지연 가능성: 버퍼가 가득 차거나 비어있을 때 지연이 발생할 수 있다. 적용 사례 작업 큐 시스템: 백그라운드 작업 처리, 이메일 발송 등의 비동기 작업 관리 로그 처리 시스템: 대량의 로그 데이터를 효율적으로 수집하고 분석 스트리밍 데이터 처리: 실시간 데이터 스트림의 처리 및 분석 멀티스레드 애플리케이션: 스레드 간 작업 분배 및 동기화 구현 시 고려사항 동기화 메커니즘: 버퍼 접근 시 적절한 동기화 방법(예: 세마포어, 뮤텍스) 사용 버퍼 크기 조정: 시스템 요구사항에 맞는 적절한 버퍼 크기 설정 예외 처리: 버퍼 오버플로우, 언더플로우 등의 예외 상황 관리 종료 조건: 프로듀서와 컨슈머의 적절한 종료 시점 및 방법 정의 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:12:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Producer-Consumer Pattern" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-processing/producer-consumer/producer-consumer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web</h2></header><div class=entry-content><p>Web Web(월드 와이드 웹)은 인터넷을 통해 접근할 수 있는 정보의 거대한 네트워크이다.
1989년 팀 버너스 리(Tim Berners-Lee)가 유럽입자물리연구소(CERN)에서 처음 제안했으며, 전 세계 컴퓨터들을 연결하여 정보를 공유할 수 있는 거대한 네트워크를 구축하는 것을 목표로 했다.
Web의 발전은 단순한 정보 제공에서 시작하여 사용자 참여와 상호작용을 거쳐, 현재는 지능형 및 분산형 시스템으로 진화하고 있다.
이러한 발전은 기술의 진보와 사용자 요구의 변화를 반영하며, 앞으로도 계속해서 새로운 형태로 발전할 것으로 예상된다.
Web의 발전 과정 Web 1.0 1990년대 초부터 2000년대 초까지의 초기 웹 시대를 지칭하며, 주로 정적인 읽기 전용 콘텐츠로 구성되어 있었다.
이 시기의 웹사이트는 정보 제공자가 콘텐츠를 생성하고, 사용자는 이를 단순히 소비하는 구조로, 상호작용이 제한적이었다
...</p></div><footer class=entry-footer><span title='2024-12-04 12:40:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/web/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Networking and Communication Overview</h2></header><div class=entry-content><p>Networking and Communication 아래는 “Networking and Communication(네트워킹 및 통신)” 에 대한 IT 백엔드 개발자 관점의 포괄적 조사 결과입니다.
1. 태그 Network-Architecture Communication-Protocols Data-Transmission Network-Security 2. 분류 구조 분석 분류: Computer Science and Engineering > Systems and Infrastructure
적절성 분석:
네트워킹 및 통신은 컴퓨터 시스템과 인프라의 핵심 기능 중 하나로, 시스템 및 인프라 (Systems and Infrastructure) 하위에 분류하는 것이 타당함. 네트워킹은 다양한 시스템이 상호 연결되어 데이터와 자원을 공유하는 구조의 기반이기 때문 13. 근거:
네트워킹은 컴퓨터, 서버, 라우터, 스위치 등 다양한 하드웨어와 소프트웨어가 결합되어 인프라를 형성하며, 시스템 간 통신 및 데이터 교환을 담당함 13. 3. 요약 문장 네트워킹은 컴퓨터와 기기들이 서로 연결되어 정보와 자원을 효율적으로 공유할 수 있게 하는 시스템으로, 다양한 프로토콜과 아키텍처를 통해 안정적이고 확장 가능한 통신 환경을 구현한다 15.
...</p></div><footer class=entry-footer><span title='2024-09-19 12:30:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;77 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Networking and Communication Overview" href=https://buenhyden.github.io/posts/networking--protocols/overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Addressing</h2></header><div class=entry-content><p>Addressing 네트워크 주소 지정은 물리 주소 (MAC) 와 논리 주소 (IP) 의 계층적 체계와 이를 연결하는 해석 절차 (ARP/NDP, DNS) 로 이뤄진다.
IPv4 는 주소 부족으로 NAT/CGNAT에 의존하고, IPv6 는 광대한 공간으로 자동 구성 (SLAAC)·Anycast 등을 활용한다.
실무에서는 집계 가능한 CIDR 설계, IPAM·DHCP 로 자동화, 멀티클라우드·Kubernetes 의 주소 중복 예방, NAT 로 인한 추적·보안 영향 평가, DNS·방화벽·RPKI 같은 거버넌스 체계를 함께 설계해야 라우팅 수렴·보안 경계·서비스 성능을 확보할 수 있다.
핵심 개념 주소는 네트워크에서 ’ 누구 (식별자)’ 와 ’ 어디 (위치)’ 를 정하는 핵심 도구이며, 올바른 주소 계획·할당·보안·자동화가 안정적 네트워크 운영의 기초다.
...</p></div><footer class=entry-footer><span title='2025-09-04 02:15:00 +0000 UTC'>September 4, 2025</span>&nbsp;·&nbsp;80 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Addressing" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/addressing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Models</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-08-30 16:52:00 +0000 UTC'>August 30, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Models" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Traffic Management</h2></header><div class=entry-content><p>Traffic Management 트래픽 관리는 네트워크와 애플리케이션 전반에서 데이터 흐름을 제어해 성능·보안·비용 효율성을 확보하는 핵심 기술이다.
전송 계층에서는 QUIC, BBR로 TCP 한계를 극복하고, 네트워크 계층에서는 AQM, ECN, DiffServ로 혼잡과 지연을 줄인다. 서비스 계층에서는 로드밸런서, DNS 기반 GSLB, 서비스 메시, API Gateway를 통해 트래픽을 분산·제어하며, Failover·레이트 제한·미러링 같은 정책을 적용한다.
Edge 에서는 CDN, Anycast, WAF가 성능과 보안을 강화한다.
실무에서는 AWS ELB, GCP Load Balancer, Envoy, Istio, eBPF 등이 활용되며, 운영자는 p95/p99 지연·오류율 같은 지표를 기준으로 품질을 지속적으로 검증한다.
...</p></div><footer class=entry-footer><span title='2025-08-28 04:24:00 +0000 UTC'>August 28, 2025</span>&nbsp;·&nbsp;58 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traffic Management" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Request Response Cycle</h2></header><div class=entry-content><p>Request-Response Cycle Request‑Response 사이클은 분산 클라이언트‑서버 시스템에서 주로 사용되는 통신 패턴으로, 클라이언트가 HTTP 요청을 보내면 서버는 요청 라인, 헤더, 본문을 분석한 뒤, 비즈니스 로직 및 데이터베이스 처리 후 상태 코드, 헤더, 본문을 포함한 HTTP 응답을 생성하여 반환한다.
이 사이클에는 요청 유효성 검사, 인증/인가, 로깅, 미들웨어, 캐싱, 에러 처리 등의 기능이 포함되며, 웹 프레임워크에서는 각 단계를 모듈화 및 자동화하여 개발 생산성과 유지보수성을 확보한다.
네트워크 연결, TCP 핸드셰이크, TLS 암호화, HTTP 프로토콜 버전 (1.1/2/3) 등의 하부 인프라도 전체 흐름에 영향을 미치며, 대기 시간, 확장성, 보안 등의 관점에서 최적화 및 고려가 필요하다.
...</p></div><footer class=entry-footer><span title='2025-07-10 15:44:00 +0000 UTC'>July 10, 2025</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Request Response Cycle" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/synchronous-communication/request-response/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Systems</h2></header><div class=entry-content><p>Messaging Systems 메시징 시스템 (Messaging Systems) 은 애플리케이션 또는 서비스 간 메시지를 안전하게 송수신하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 장애 복원력, 실시간 데이터 처리 등 백엔드 시스템의 핵심 요구사항을 충족한다. 대표적으로 메시지 큐, 이벤트 스트리밍 플랫폼, 태스크 큐 등이 있으며, 각각 작업 분산, 실시간 이벤트 처리, 대규모 데이터 파이프라인 등 다양한 시나리오에 활용된다. 현대 분산 시스템과 마이크로서비스 아키텍처에서 메시징 시스템은 필수적이다.
핵심 개념 메시징 시스템 (Messaging Systems) 은 독립적인 소프트웨어 구성 요소 간의 비동기 통신을 가능하게 하는 인프라이다. 이를 통해 시스템의 결합도를 낮추고, 확장성과 장애 허용성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2025-04-22 13:59:00 +0000 UTC'>April 22, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Systems" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain Name System</h2></header><div class=entry-content><p>Domain Name System DNS(Domain Name System) 는 인터넷의 전화번호부와 같은 역할을 한다. 사람이 읽고 이해할 수 있는 도메인 이름 (예: &lt;www.example.com>) 을 컴퓨터가 이해할 수 있는 IP 주소 (예: 192.0.2.1) 로 변환해주는 시스템이다. 이 변환 과정은 사용자가 인터넷에서 웹사이트나 API 에 접근할 때 필수적인 단계이다.
DNS 의 작동 방식 DNS 변환 과정은 여러 단계로 이루어지는 분산 시스템이다.
이 과정을 “DNS 조회 " 또는 “DNS 해석 " 이라고 부른다.
DNS 조회 과정 사용자 입력: 사용자가 브라우저에 도메인 이름 (api.example.com) 을 입력한다. 로컬 DNS 캐시 확인: 브라우저와 운영체제는 먼저 자체 캐시를 확인하여 최근에 방문한 도메인의 IP 주소를 찾는다. 리커시브 DNS 서버 질의: 캐시에서 찾지 못하면, 요청은 일반적으로 ISP(인터넷 서비스 제공업체) 가 제공하는 리커시브 DNS 서버로 전달된다. 루트 DNS 서버 질의: 리커시브 서버는 전 세계에 분산된 루트 DNS 서버에 질의한다. 루트 서버는 최상위 도메인 (TLD) 서버의 위치를 알려준다. TLD DNS 서버 질의: 리커시브 서버는 TLD 서버 (예:.com,.org,.net) 에 질의하여 해당 도메인의 권한 있는 네임서버의 위치를 알아낸다. 권한 있는 네임서버 질의: 리커시브 서버는 권한 있는 네임서버에 도메인 이름에 대한 IP 주소를 요청한다. 응답 반환: IP 주소는 리커시브 서버를 통해 사용자의 컴퓨터로 반환된다. 이 정보는 일정 기간 동안 캐시된다. 연결 설정: 브라우저는 이제 해당 IP 주소를 사용하여 웹 서버 또는 API 서버에 연결한다. DNS(도메인 네임 시스템) 는 인터넷 및 네트워크에서 도메인 명을 IP 주소로 변환하는 분산형 네임 서비스로, 브라우저 등 응용 프로그램이 사람 친화적인 도메인 명을 네트워크 자원 (서버) 으로 연결할 수 있도록 지원한다. 이는 계층적 구조로 설계되어 전 세계에 분산된 수많은 DNS 서버가 협력해 트래픽 분산, 보안, 확장성을 실현하며, 인터넷 서비스의 접근성과 신뢰성, 확장성을 높이는 필수적인 시스템 컴포넌트이다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Name System" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/internet-layer/network-services/dns/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/networking--protocols/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>