<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking & Protocols | hyunyoun's Blog</title><meta name=keywords content="Networking-and-Protocols"><meta name=description content="Networking & Protocols - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking--protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking & Protocols"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking & Protocols"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Networking \u0026 Protocols","item":"https://buenhyden.github.io/posts/networking--protocols/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Networking & Protocols</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Networking and Communication Overview</h2></header><div class=entry-content><p>Networking and Communication 아래는 “Networking and Communication(네트워킹 및 통신)” 에 대한 IT 백엔드 개발자 관점의 포괄적 조사 결과입니다.
1. 태그 Network-Architecture Communication-Protocols Data-Transmission Network-Security 2. 분류 구조 분석 분류: Computer Science and Engineering > Systems and Infrastructure
적절성 분석:
네트워킹 및 통신은 컴퓨터 시스템과 인프라의 핵심 기능 중 하나로, 시스템 및 인프라 (Systems and Infrastructure) 하위에 분류하는 것이 타당함. 네트워킹은 다양한 시스템이 상호 연결되어 데이터와 자원을 공유하는 구조의 기반이기 때문 13. 근거:
네트워킹은 컴퓨터, 서버, 라우터, 스위치 등 다양한 하드웨어와 소프트웨어가 결합되어 인프라를 형성하며, 시스템 간 통신 및 데이터 교환을 담당함 13. 3. 요약 문장 네트워킹은 컴퓨터와 기기들이 서로 연결되어 정보와 자원을 효율적으로 공유할 수 있게 하는 시스템으로, 다양한 프로토콜과 아키텍처를 통해 안정적이고 확장 가능한 통신 환경을 구현한다 15.
...</p></div><footer class=entry-footer><span title='2024-09-19 12:30:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;77 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Networking and Communication Overview" href=https://buenhyden.github.io/posts/networking--protocols/overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Core Protocols</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-10-02 14:16:00 +0000 UTC'>October 2, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Core Protocols" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Basic Concepts</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-10-02 14:01:00 +0000 UTC'>October 2, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Basic Concepts" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Traffic Management</h2></header><div class=entry-content><p>Traffic Management 트래픽 관리는 네트워크와 애플리케이션 전반에서 데이터 흐름을 제어해 성능·보안·비용 효율성을 확보하는 핵심 기술이다.
전송 계층에서는 QUIC, BBR로 TCP 한계를 극복하고, 네트워크 계층에서는 AQM, ECN, DiffServ로 혼잡과 지연을 줄인다. 서비스 계층에서는 로드밸런서, DNS 기반 GSLB, 서비스 메시, API Gateway를 통해 트래픽을 분산·제어하며, Failover·레이트 제한·미러링 같은 정책을 적용한다.
Edge 에서는 CDN, Anycast, WAF가 성능과 보안을 강화한다.
실무에서는 AWS ELB, GCP Load Balancer, Envoy, Istio, eBPF 등이 활용되며, 운영자는 p95/p99 지연·오류율 같은 지표를 기준으로 품질을 지속적으로 검증한다.
...</p></div><footer class=entry-footer><span title='2025-08-28 04:24:00 +0000 UTC'>August 28, 2025</span>&nbsp;·&nbsp;58 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traffic Management" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker vs. Message Broker</h2></header><div class=entry-content><p>Event Broker vs. Message Broker 이벤트 브로커와 메시지 브로커는 현대 분산 시스템에서 핵심적인 미들웨어로, 서비스 간 결합도를 낮추고 확장성, 신뢰성, 실시간성, 장애 복원력을 제공한다. 이벤트 브로커는 Pub/Sub, 이벤트 스트리밍, 실시간 데이터 분배에 최적화되어 있으며, 메시지 브로커는 큐잉, 복잡한 라우팅, 포맷 변환, 트랜잭션 등 엔터프라이즈 통합에 강점을 보인다. 두 기술은 아키텍처, 메시징 패턴, 처리 방식, 주요 기능 등에서 차이가 있으며, 실제 환경에서는 요구사항에 따라 혼합 적용되기도 한다.
핵심 개념 메시지 브로커는 작업 처리와 안정성 중심의 통신에 적합하며, 명령 (Command), 요청 - 응답, 복잡한 라우팅이 필요한 경우에 효과적이다. 이벤트 브로커는 실시간 스트리밍, 이벤트 소싱, 이벤트 기반 데이터 흐름이 중심인 아키텍처에 최적화되어 있다. 양자 모두 분산 시스템에서의 decoupling, 비동기성, 확장성 확보에 필수적인 미들웨어이며, 도메인/업무의 특성에 따라 적절히 선택하거나 병행하여 사용하는 것이 권장된다. 항목 Event Broker (이벤트 브로커) Message Broker (메시지 브로커) 기본 정의 시스템 내에서 발생한 이벤트를 토픽 기반 Pub/Sub 모델로 중계 및 브로드캐스트하는 미들웨어 송신자와 수신자 간의 메시지를 큐 기반 Point-to-Point 방식으로 중개 및 전달하는 미들웨어 기반 모델 Log 기반, Publish-Subscribe 모델 Queue 기반, Routing 기반 (Direct, Topic, Fanout, Headers) 메시지 처리 방식 여러 구독자가 동일 이벤트를 동시에 소비 가능 (1:N, N:N 확장에 유리) 메시지를 수신한 단일 소비자가 처리 (1:1 또는 Load Balancing 처리) 용도 중심성 상태 변화, 알림, 데이터 변경 전파 등 이벤트 스트리밍 중심 (Event-based) 작업 명령, 요청 처리, 커맨드 전송 중심 (Command-based) 재처리 및 리텐션 로그 기반으로 이벤트 보존 가능 (리텐션/압축 설정), 이벤트 재처리 및 타임 트래블 가능 일반적으로 메시지 소비 후 삭제, 재처리는 DLQ 기반 처리 주요 특징 실시간 이벤트 스트리밍, 대용량 데이터 브로드캐스트, 이벤트 소싱 및 추적 가능 신뢰성 높은 메시지 전달, 메시지 포맷 변환, 복잡한 라우팅 지원 대표 구현체 Apache Kafka, Apache Pulsar, Amazon EventBridge, Azure Event Grid, Solace PubSub+ RabbitMQ, Apache ActiveMQ, IBM MQ, Amazon SQS Event Broker vs. Message Broker 비교 이벤트 브로커와 메시지 브로커는 모두 메시지 기반의 비동기 통신 미들웨어이다. 하지만 이벤트 중심 (Event-Driven Architecture) 과 메시지 큐잉 및 라우팅 (Queueing & Routing) 이라는 핵심 원칙과 동작 방식의 차이가 있다.
...</p></div><footer class=entry-footer><span title='2025-07-18 05:55:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Broker vs. Message Broker" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Request Response Cycle</h2></header><div class=entry-content><p>Request-Response Cycle Request‑Response 사이클은 분산 클라이언트‑서버 시스템에서 주로 사용되는 통신 패턴으로, 클라이언트가 HTTP 요청을 보내면 서버는 요청 라인, 헤더, 본문을 분석한 뒤, 비즈니스 로직 및 데이터베이스 처리 후 상태 코드, 헤더, 본문을 포함한 HTTP 응답을 생성하여 반환한다.
이 사이클에는 요청 유효성 검사, 인증/인가, 로깅, 미들웨어, 캐싱, 에러 처리 등의 기능이 포함되며, 웹 프레임워크에서는 각 단계를 모듈화 및 자동화하여 개발 생산성과 유지보수성을 확보한다.
네트워크 연결, TCP 핸드셰이크, TLS 암호화, HTTP 프로토콜 버전 (1.1/2/3) 등의 하부 인프라도 전체 흐름에 영향을 미치며, 대기 시간, 확장성, 보안 등의 관점에서 최적화 및 고려가 필요하다.
...</p></div><footer class=entry-footer><span title='2025-07-10 15:44:00 +0000 UTC'>July 10, 2025</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Request Response Cycle" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/synchronous-communication/request-response/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Systems</h2></header><div class=entry-content><p>Messaging Systems 메시징 시스템 (Messaging Systems) 은 애플리케이션 또는 서비스 간 메시지를 안전하게 송수신하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 장애 복원력, 실시간 데이터 처리 등 백엔드 시스템의 핵심 요구사항을 충족한다. 대표적으로 메시지 큐, 이벤트 스트리밍 플랫폼, 태스크 큐 등이 있으며, 각각 작업 분산, 실시간 이벤트 처리, 대규모 데이터 파이프라인 등 다양한 시나리오에 활용된다. 현대 분산 시스템과 마이크로서비스 아키텍처에서 메시징 시스템은 필수적이다.
핵심 개념 메시징 시스템 (Messaging Systems) 은 독립적인 소프트웨어 구성 요소 간의 비동기 통신을 가능하게 하는 인프라이다. 이를 통해 시스템의 결합도를 낮추고, 확장성과 장애 허용성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2025-04-22 13:59:00 +0000 UTC'>April 22, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Systems" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events 서버 전송 이벤트(Server-Sent Events, SSE)는 웹 서버가 클라이언트 브라우저로 데이터를 자동으로 푸시할 수 있게 해주는 웹 기술이다. 전통적인 HTTP 통신에서는 클라이언트가 요청을 보내고 서버가 응답하는 방식이었지만, SSE는 서버가 필요할 때마다 자발적으로 데이터를 전송할 수 있는 단방향 통신 채널을 제공한다.
SSE는 HTML5 표준의 일부로, EventSource API를 통해 구현된다. 이 기술은 기존 HTTP 프로토콜 위에서 작동하며, 특별한 프로토콜 전환 없이 실시간 통신이 가능하다는 장점이 있다.
SSE의 핵심 특징 서버 전송 이벤트는 다음과 같은 주요 특징을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:31:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Polling</h2></header><div class=entry-content><p>Polling 폴링(Polling)은 API 통합 패턴 중 가장 기본적이면서도 널리 사용되는 방식이다. 이 패턴은 단순하지만 다양한 상황에서 효과적으로 활용될 수 있으며, 올바르게 구현하면 강력한 통합 메커니즘이 될 수 있다.
폴링의 기본 개념 폴링은 클라이언트가 주기적으로 서버에 요청을 보내 새로운 정보나 상태 변화를 확인하는 통신 방식이다. 이는 ‘끌어오기(Pull)’ 방식의 대표적인 예로, 클라이언트가 능동적으로 서버에서 정보를 요청한다.
폴링의 작동 원리 폴링의 기본 작동 과정은 다음과 같다:
클라이언트가 서버에 정보 요청을 보낸다. 서버는 현재 상태나 데이터를 응답으로 반환한다. 클라이언트는 일정 시간(폴링 간격) 동안 대기한다. 대기 시간이 끝나면 클라이언트는 다시 1단계로 돌아가 요청을 반복한다. 이 과정은 클라이언트가 중단하거나 다른 통신 방식으로 전환할 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2025-03-08 15:53:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polling" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Webhooks</h2></header><div class=entry-content><p>Webhook Webhook은 API 통합 패턴 중 하나로, 실시간 데이터 전송과 시스템 간 효율적인 통신을 가능하게 하는 중요한 메커니즘이다.
Webhook은 현대 API 통합 패턴에서 핵심적인 요소로, 실시간 이벤트 기반 아키텍처를 구현하는 데 효과적인 방법이다. 적절한 설계, 구현, 보안 조치를 통해 시스템 간의 효율적이고 안전한 통신을 가능하게 한다.
하지만 복잡성, 보안 문제, 신뢰성 등의 문제를 고려해야 하므로, 사용 사례에 따라 폴링, WebSocket, SSE 등 다른 통합 패턴과 적절히 조합하여 사용하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 15:52:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Webhooks" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/webhooks/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/networking--protocols/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>