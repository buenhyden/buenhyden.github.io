<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PDU(Protocol Data Unit, 프로토콜 데이터 단위) | hyunyoun's Blog</title><meta name=keywords content="Networking-and-Protocols,Network-Fundamentals,Basic-Concepts,Data-Transmission,PDU,OSI-Model,protocol-data-unit,encapsulation,header-trailer"><meta name=description content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="PDU(Protocol Data Unit, 프로토콜 데이터 단위)"><meta property="og:description" content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="PDU(Protocol Data Unit, 프로토콜 데이터 단위)"><meta name=twitter:description content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"PDU(Protocol Data Unit, 프로토콜 데이터 단위)","item":"https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>PDU(Protocol Data Unit, 프로토콜 데이터 단위)</h1><div class=post-description>PDU(Protocol Data Unit)는 각 계층이 <em>상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸</em> 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다.</div></header><div class=post-content><h2 id=pduprotocol-data-unit-프로토콜-데이터-단위>PDU(Protocol Data Unit, 프로토콜 데이터 단위)<a hidden class=anchor aria-hidden=true href=#pduprotocol-data-unit-프로토콜-데이터-단위>#</a></h2><p>PDU(Protocol Data Unit) 는 네트워크 통신에서 각 프로토콜 계층이 다루는 데이터 블록을 의미하며, 계층별로 서로 다른 명칭과 헤더 구조를 가진다.</p><p>OSI 참조 모델 (7 계층) 과 TCP/IP 모델 (4 계층) 은 모두 PDU 를 통해 계층 간 역할 분리와 독립성을 구현한다.<br>물리 계층 (Layer 1) 에서는 비트 (Bit) 스트림으로 표현되고,<br>데이터링크 계층 (Layer 2) 에서는 프레임 (Frame) 에 MAC 주소와 FCS 를 포함하며,<br>네트워크 계층 (Layer 3) 에서는 패킷 (Packet) 에 IP 주소를 담고,<br>전송 계층 (Layer 4) 에서는 세그먼트 (Segment, TCP) 또는 데이터그램 (Datagram, UDP) 에 포트 번호를 명시한다.<br>상위 계층 (5~7 계층) 은 통칭 데이터 (Data) 또는 메시지로 불린다.</p><p>각 계층은 상위 계층 PDU 를 페이로드로 받아들이고 고유 헤더를 추가하는 캡슐화 (Encapsulation) 를 수행하며, 수신 측은 역캡슐화 (Decapsulation) 를 통해 원본 데이터를 복원한다.</p><p>PDU 구조 이해는 패킷 분석, 방화벽 규칙 설정, QoS(Quality of Service) 정책, MTU(Maximum Transmission Unit) 최적화 등 실무 네트워크 운영의 핵심이다. 또한 SDN(Software-Defined Networking), NFV(Network Functions Virtualization) 환경에서 계층별 헤더 조작과 트래픽 제어를 위한 기초 지식으로 작용한다.</p><h2 id=기본-개념과-배경>기본 개념과 배경<a hidden class=anchor aria-hidden=true href=#기본-개념과-배경>#</a></h2><p>PDU 의 정의와 특징, 등장 배경, 해결하려는 문제, 흔한 오해, 핵심 용어 정합을 다룬다. 네트워크 계층 모델의 근간이 되는 개념을 명확히 이해하는 것이 목표다.</p><h3 id=정의-definition>정의 (Definition)<a hidden class=anchor aria-hidden=true href=#정의-definition>#</a></h3><p>PDU(Protocol Data Unit) 는 <strong>네트워크 프로토콜 스택의 각 계층에서 처리·전송하는 데이터 블록</strong>을 의미한다.<br>보통 <code>헤더(제어정보) + 페이로드(SDU)</code> 구조를 가지며 각 계층의 동작 규칙에 따라 다르게 이름을 가지며 네트워크 프로토콜 효율화에 중요한 역할을 한다.</p><p>OSI 참조 모델과 TCP/IP 모델에서 각 계층은 고유한 PDU 이름과 헤더·트레일러 구조를 정의하며, 이를 통해 계층 간 역할 분리와 독립적 프로토콜 설계를 구현한다.<br>예를 들어, TCP 세그먼트는 전송 계층 PDU 로, IP 패킷은 네트워크 계층 PDU 로, 이더넷 프레임은 데이터링크 계층 PDU 로 지칭된다.</p><h3 id=특징-characteristics>특징 (Characteristics)<a hidden class=anchor aria-hidden=true href=#특징-characteristics>#</a></h3><p>PDU 는 각 계층마다 별도의 명칭 (예: Bit, Frame, Packet, Segment 등) 을 가지며, 계층별 프로토콜에 따라 구조와 필드 구성이 달라진다. 캡슐화 과정을 거치며 이전 계층의 데이터 (SDU) 를 포함하고, 송수신 동작의 독립성을 유지한다.</p><ul><li><strong>계층별 고유 명칭</strong>: 물리 (비트), 데이터링크 (프레임), 네트워크 (패킷), 전송 (세그먼트/데이터그램), 상위 (데이터/메시지) 로 구분된다.</li><li><strong>헤더·트레일러 구조</strong>: 각 계층은 상위 PDU 를 페이로드로 받아 자신의 제어 정보 (헤더, 선택적 트레일러) 를 추가한다.</li><li><strong>캡슐화·역캡슐화</strong>: 송신 측은 상위→하위 순으로 헤더를 추가 (캡슐화), 수신 측은 하위→상위 순으로 헤더를 제거 (역캡슐화) 한다.</li><li><strong>독립성과 투명성</strong>: 각 계층은 상·하위 계층의 내부 구현을 알 필요 없이 PDU 인터페이스만 준수하면 된다.</li><li><strong>실무 도구 연계</strong>: 패킷 분석기 (Wireshark, tcpdump), 방화벽 (iptables, ACL), 로드밸런서가 PDU 헤더를 기반으로 동작한다.</li></ul><h4 id=pdu-의-12-가지-구조적-특징>PDU 의 12 가지 구조적 특징<a hidden class=anchor aria-hidden=true href=#pdu-의-12-가지-구조적-특징>#</a></h4><p>PDU 의 12 가지 특징은</p><ol><li>**구조/명명</li><li><strong>크기/경로 제약</strong></li><li><strong>신뢰/품질 제어</strong></li><li><strong>운영/가시성·성능</strong><br>의 4 가지 차원으로 묶인다. 이는 상호 의존적이다.<br>구조/옵션 결정이 곧바로 크기/경로 제약에 반영되고, 여기서의 실패는 신뢰/품질의 재전송·지연을 키운다. 암호화·오프로딩은 관찰성을 바꾸므로, 캡처 위치와 텔레메트리를 &rsquo; 이중화 &rsquo; 하는 것이 빠른 트러블슈팅의 핵심이다.</li></ol><p>실무에서는 이 4 가지 차원을 동시에 점검해야 헤더 예산·손실/지연·보안·관찰성이 균형을 이룬다.<br>핵심은 &ldquo;<strong>헤더가 쌓이면 MTU 는 줄고</strong>, 그 결과 <strong>분할/단편화·재전송</strong>이 증가하며, <strong>암호화/오프로딩/터널</strong>은 분석 난이도를 높인다 " 는 연쇄 효과를 이해하는 것이다.</p><h5 id=구조명명>구조/명명<a hidden class=anchor aria-hidden=true href=#구조명명>#</a></h5><ul><li><strong>계층 종속 명명</strong>—같은 " 데이터 덩어리 " 라도 관찰 지점에 따라 이름과 의미가 달라진다. 스위치 포트 미러는 L2 <em>Frame</em>을, 라우터/방화벽은 L3 <em>Packet</em>을, 호스트의 소켓 계층은 L4 <em>Segment/Datagram</em>을 본다. 명칭 혼동은 문제 위치 추적을 어렵게 하므로, 증상 보고·캡처·로그를 모두 동일 계층 기준으로 맞추는 것이 중요하다.</li><li><strong>헤더 구조 (고정 + 옵션/확장)</strong>—IPv4 IHL, TCP Options, IPv6 Extension Header, 802.1Q VLAN 처럼 <em>고정 필드 + 가변 옵션</em> 조합이다. 옵션은 확장성과 유연성을 주지만, 오버헤드 증가·미들박스 호환성·슬로패스 전환 위험이 따른다. 운영선에서는 필요 옵션만 최소화하고, 중간장비 호환성 목록을 유지한다.</li><li><strong>주소/식별/흐름 라벨</strong>—MAC/IP/Port 의 전통적 5- 튜플 외에도 IPv6 Flow Label, QUIC Connection ID(CID), VLAN ID, SPI(IPsec) 등 식별자가 있다. 해시 기반 로드밸런싱/ECMP 는 이들 필드를 키로 사용해 흐름을 분산한다. NAT/터널이 개입하면 키 구성이 바뀌므로, 트래픽 핑거프린팅과 경로 일관성을 재검증해야 한다.</li></ul><h5 id=크기경로-제약>크기/경로 제약<a hidden class=anchor aria-hidden=true href=#크기경로-제약>#</a></h5><ul><li><strong>길이 제약 (MTU/MSS/최소 프레임)</strong>—MTU 는 상위 모든 PDU 크기에 상한을 건다. 이더넷 최소 프레임 (패딩 포함) 과 무선 MAC 오버헤드, 터널/보안 헤더가 결합되면 유효 페이로드가 급감한다. MSS 는 TCP 협상 시 안전한 상한을 제공하지만, 실제 경로 MTU 와 불일치하면 재전송·블랙홀이 발생한다.</li><li><strong>단편화 정책 차이 (IPv4/IPv6)</strong>—IPv4 는 중간 라우터 단편화가 가능 (DF=0), IPv6 는 송신자만 단편화 가능하다. 단편화는 손실/지연·CPU 비용을 증가시키므로 <em>회피가 원칙</em>이다. 운영에서는 PMTUD/PLPMTUD 로 크기를 조정하고, 방화벽에서 조각 (Fragments) 처리를 신중히 설계한다.</li><li><strong>PMTUD/PLPMTUD</strong>—ICMP 신호에 의존하는 전통 PMTUD(IPv4 Frag Needed, IPv6 PTB) 는 필터링되면 실패한다. PLPMTUD 는 실제 데이터/프로브로 안전 크기를 탐색해 블랙홀을 줄인다. 경로가 자주 바뀌는 모바일/클라우드 환경에서 특히 중요하다.</li><li><strong>터널/오버레이 중첩</strong>—VLAN/QinQ/VXLAN/GRE/IPsec/GTP-U 는 새로운 헤더를 추가해 경계 밖의 L2/L3 를 가상화한다. 중첩 깊이가 증가하면 헤더 예산이 급격히 줄어 PMTUD 실패·단편화·성능 저하로 이어진다. 터널 종단에서 MTU 조정·MSS 클램핑·외부 단편화 방지 설정을 함께 적용한다.</li></ul><h5 id=신뢰품질-제어>신뢰/품질 제어<a hidden class=anchor aria-hidden=true href=#신뢰품질-제어>#</a></h5><ul><li><strong>오류 검출/복구</strong>—L2 FCS(CRC)·IPv4 헤더 체크섬·L4 체크섬·TLS/QUIC 의 AEAD 가 계층별로 무결성을 보장한다. 검출 범위와 비용이 달라 중복도 존재한다 (예: IPv6 은 라우터 성능을 위해 헤더 체크섬 제거). 체크섬/암호 검증 실패는 즉시 드롭되므로, 관찰 지표 (드롭 카운터, ICV 오류) 를 병행 모니터링해야 한다.</li><li><strong>순서/신뢰 의미</strong>—TCP 는 순서/재전송/흐름·혼잡제어를 제공해 <em>바이트 스트림</em>을 보장한다. UDP 는 비연결/무보장으로 지연 예측 가능성이 높고, QUIC 은 UDP 위에 <em>스트림 단위</em> 신뢰·복구를 제공해 HOL(Head-of-Line) 문제를 줄인다. 응용의 메시지 경계 보존 요구에 따라 적절한 전송을 선택해야 한다.</li><li><strong>혼잡/우선 신호 (ECN/DSCP)</strong>—ECN 의 ECT/CE 비트로 드롭 없이 혼잡 신호를 전달하고, DSCP/Traffic Class 로 클래스 기반 큐잉을 수행한다. ECN 이 비활성/표백 (bleach) 되는 경로에서는 이득이 제한되며, AQM(RED/CoDel/FQ-CoDel) 과의 조합에서 효과가 크다. 마킹/정책 일관성을 엔드·경계 장비에서 교차 검증한다.</li></ul><h5 id=운영가시성성능>운영/가시성·성능<a hidden class=anchor aria-hidden=true href=#운영가시성성능>#</a></h5><ul><li><strong>오프로딩 (TSO/GSO/GRO 등)</strong>—호스트는 큰 PDU 를 NIC 가 분할/병합하도록 위임하여 PPS/CPU 비용을 낮춘다. 이때 호스트 로컬 캡처에선 <em>큰 가상 세그먼트</em>로 보일 수 있어 온와이어 현실과 불일치한다. 분석은 미러 포트/경계 장비 캡처와 교차하고, ethtool/드라이버 카운터로 상태를 확인한다.</li><li><strong>보안과 가시성의 상호작용</strong>—TLS 1.3/QUIC 은 메타데이터까지 광범위하게 암호화하여 DPI/미들박스 의존 진단을 어렵게 한다. 대신 엔드포인트 텔레메트리 (연결 통계, 실패 코드) 와 패시브 지표 (QUIC 스핀 비트 등, 배포 정책에 따라) 로 관찰성을 보완한다. 암호화 태그/레코드로 헤더 오버헤드가 늘어나 MTU 예산을 소모한다.</li></ul><h5 id=pdu-의-12-가지-구조적-특징-요약>PDU 의 12 가지 구조적 특징 (요약)<a hidden class=anchor aria-hidden=true href=#pdu-의-12-가지-구조적-특징-요약>#</a></h5><table><thead><tr><th style=text-align:center>차원</th><th>특징</th><th>설명</th><th>대표 필드/메커니즘</th><th>영향 (성능/신뢰/보안)</th></tr></thead><tbody><tr><td style=text-align:center>구조/명명</td><td>계층 종속 명명</td><td>L2=Frame, L3=Packet, L4=Segment/Datagram 등 관찰 계층에 따라 명칭·의미 상이</td><td>802.3/802.11, IP, TCP/UDP</td><td>모델 정합·분석 정확도 ↑</td></tr><tr><td style=text-align:center>구조/명명</td><td>헤더 구조 (고정 + 옵션)</td><td>고정 필드 + 옵션/확장 (EH/옵션) 로 확장성·호환성·오버헤드 균형</td><td>IHL, Next Header, TCP Options</td><td>오버헤드·확장성 트레이드오프</td></tr><tr><td style=text-align:center>구조/명명</td><td>주소/식별/흐름 라벨</td><td>5- 튜플 외 CID/Flow Label/VLAN/SPI 등 식별자</td><td>SA/DA, Src/Dst, FlowLbl, DCID/SCID</td><td>로드밸런싱/추적성/정책</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>길이 제약 (MTU/MSS/최소 프레임)</td><td>MTU/MSS/패딩 규칙이 최대 페이로드를 결정</td><td>MTU, TotalLen, PayloadLen</td><td>블랙홀/재전송/지연 영향</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>단편화 정책</td><td>IPv4(중간 가능) vs IPv6(송신자만)</td><td>DF, FragOff, IPv6 Frag EH</td><td>재조립 비용/손실 민감</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>PMTUD/PLPMTUD</td><td>경로 MTU 탐색; ICMP 의존/프로빙 기반</td><td>ICMP FragNeeded/PTB</td><td>블랙홀 회피/적응성</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>터널/오버레이 중첩</td><td>VLAN/VXLAN/GRE/IPsec 등 헤더 중첩</td><td>EtherType, VNI, SPI</td><td>MTU 악화·성능 저하</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>오류 검출/복구</td><td>FCS/체크섬/AEAD 등 계층별 무결성·복구</td><td>FCS, HeaderChk, L4 Checksum, AEAD Tag</td><td>무결성/처리비용/드롭 패턴</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>순서/신뢰 의미</td><td>TCP(순서·재전송), UDP(비연결), QUIC(스트림 단위)</td><td>Seq/Ack, Stream ID</td><td>지연/손실/복원 전략 차이</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>혼잡/우선 신호</td><td>ECN/DSCP 로 혼잡·우선순위 신호화</td><td>ECT/CE, DSCP/Traffic Class</td><td>드롭률·품질 보장</td></tr><tr><td style=text-align:center>운영/가시성·성능</td><td>보안↔가시성</td><td>TLS/QUIC 암호화로 가시성↓·오버헤드↑</td><td>TLS Record, AEAD</td><td>DPI 난이도·MTU 예산</td></tr><tr><td style=text-align:center>운영/가시성·성능</td><td>오프로딩 (TSO/GSO/GRO)</td><td>NIC 분할/병합으로 PPS↑, 캡처 왜곡 우려</td><td>Linux Offloads</td><td>CPU↓/가시성 주의</td></tr></tbody></table><h3 id=등장-배경-background>등장 배경 (Background)<a hidden class=anchor aria-hidden=true href=#등장-배경-background>#</a></h3><p>계층화된 네트워크 모델 (OSI, TCP/IP) 은 시스템 간 통신을 표준화하고, 확장성과 신뢰성을 높이기 위해 개발되었다. 각 계층의 PDU 는 이러한 설계 원칙에 따라 독립적으로 정의되며, 계층 간 인터페이스 및 프로토콜 동작을 명확하게 한다.</p><ul><li>1970 년대 초기 네트워크는 단일 프로토콜 (예: ARPANET NCP) 로 구성되어 확장성과 상호운용성에 한계가 있었다.</li><li>1974 년 Vint Cerf 와 Bob Kahn 의 TCP/IP 설계</li><li>1984 년 ISO 의 OSI 참조 모델 표준화를 통해 <strong>계층화된 프로토콜 스택</strong> 개념이 정립되었다.</li></ul><p>각 계층이 독립적으로 PDU 를 정의함으로써, 하드웨어·소프트웨어 변경 시에도 상·하위 계층에 영향을 최소화하고, 이기종 네트워크 간 상호운용성을 확보할 수 있게 되었다.<br>이후 이더넷 (IEEE 802.3), Wi-Fi(IEEE 802.11), MPLS, VXLAN 등 다양한 프로토콜이 PDU 구조를 기반으로 발전했다.</p><h3 id=해결하려는-문제-problem>해결하려는 문제 (Problem)<a hidden class=anchor aria-hidden=true href=#해결하려는-문제-problem>#</a></h3><p>PDU 개념은 데이터 통신에서 계층 간 정보 전송의 불명확성, 데이터 포장 과정의 오류, 프로토콜 혼동 문제를 해결하고, 계층마다 일관된 데이터 단위 관리와 에러 검출/복구를 가능하게 한다.</p><p><strong>Before PDU 개념 도입</strong>:</p><ul><li>단일 프로토콜로 모든 기능 (주소 지정, 라우팅, 오류 제어, 흐름 제어) 을 처리 → 복잡도 증가, 변경 어려움</li><li>이기종 네트워크 연결 시 전체 프로토콜 재설계 필요</li><li>네트워크 문제 발생 시 원인 계층 파악 곤란</li></ul><p><strong>After PDU 개념 도입</strong>:</p><ul><li>각 계층이 명확한 PDU 와 인터페이스를 정의 → 역할 분리, 모듈화</li><li>새로운 프로토콜 추가·교체 시 해당 계층만 수정 → 유연성 향상</li><li>계층별 PDU 헤더 분석으로 문제 원인 계층 신속 식별 → 트러블슈팅 효율화</li><li>방화벽·QoS·SDN 등 네트워크 제어 정책을 계층별 헤더 기반으로 구현 가능</li></ul><h3 id=흔한-오해-misconceptions>흔한 오해 (Misconceptions)<a hidden class=anchor aria-hidden=true href=#흔한-오해-misconceptions>#</a></h3><h4 id=오해-1-pdu-는-모든-계층에서--패킷--으로-부른다>오해 1: PDU 는 모든 계층에서 &rsquo; 패킷 &rsquo; 으로 부른다<a hidden class=anchor aria-hidden=true href=#오해-1-pdu-는-모든-계층에서--패킷--으로-부른다>#</a></h4><p><strong>오해</strong>: 데이터 전송 단위를 모두 &rsquo; 패킷 &rsquo; 으로 지칭한다<br><strong>원인</strong>: 네트워크 용어의 일반화/간소화<br><strong>반례</strong>: 전송 계층은 &rsquo; 세그먼트 &lsquo;(TCP), 네트워크 계층 (Layer 3) 은 &rsquo; 패킷 &lsquo;, 프레임 (Layer 2), 세그먼트 (Layer 4) 이라 불린다<br><strong>올바른 개념</strong>: PDU 는 각 계층별 데이터 단위의 총칭이고, 패킷은 그 중 네트워크 계층 (IP) PDU 를 가리킨다.</p><h4 id=오해-2-pdu-는-원래-데이터와-별개로-존재한다>오해 2: PDU 는 원래 데이터와 별개로 존재한다<a hidden class=anchor aria-hidden=true href=#오해-2-pdu-는-원래-데이터와-별개로-존재한다>#</a></h4><p><strong>오해</strong>: PDU 와 원래 데이터가 별도의 단위로 간주된다<br><strong>원인</strong>: 헤더와 페이로드 구분 개념의 오해<br><strong>반례</strong>: PDU 는 항상 각각의 계층 데이터 (=SDU) 와 해당 계층 제어정보가 결합된 전체 메시지이다<br><strong>올바른 개념</strong>: PDU = 상위 계층 데이터 (SDU) + 현재 계층 제어정보</p><h4 id=오해-3-헤더만-추가하면-pdu-가-된다>오해 3: 헤더만 추가하면 PDU 가 된다<a hidden class=anchor aria-hidden=true href=#오해-3-헤더만-추가하면-pdu-가-된다>#</a></h4><p><strong>오해</strong>: 헤더만 있으면 PDU 구조가 완성된다고 이해<br><strong>원인</strong>: 캡슐화 개념 학습 시 헤더 추가에만 집중<br><strong>반례</strong>: 데이터링크 계층 (예: 이더넷) 은 헤더뿐 아니라 트레일러 (FCS, Frame Check Sequence) 도 추가하며, 일부 프로토콜은 페이로드 패딩도 포함<br><strong>올바른 개념</strong>: PDU 는 헤더 + 페이로드 + (선택적) 트레일러로 구성되며, 계층별로 트레일러 유무와 패딩 규칙이 다르다.</p><h4 id=오해-4-상위-계층-pdu-는-하위-계층과-무관하다>오해 4: 상위 계층 PDU 는 하위 계층과 무관하다<a hidden class=anchor aria-hidden=true href=#오해-4-상위-계층-pdu-는-하위-계층과-무관하다>#</a></h4><p><strong>오해</strong>: 각 계층 PDU 는 완전히 독립적이므로 상호 영향이 없다<br><strong>원인</strong>: 계층 독립성 원칙을 절대적으로 해석<br><strong>반례</strong>: MTU(Maximum Transmission Unit) 제약, IP 단편화 (Fragmentation), TCP MSS(Maximum Segment Size) 조정 등 하위 계층의 물리적 제약이 상위 계층 PDU 크기에 직접 영향을 미침<br><strong>올바른 개념</strong>: 계층 간 독립성은 인터페이스 수준의 추상화이며, 성능·효율성 측면에서는 상·하위 계층 간 PDU 크기 협상과 최적화가 필수다.</p><h3 id=핵심-개념-정의용어-정합>핵심 개념 정의·용어 정합<a hidden class=anchor aria-hidden=true href=#핵심-개념-정의용어-정합>#</a></h3><p>PDU(Protocol Data Unit), SDU(Service Data Unit) 는 계층화 모델에서 각각 &rsquo; 동일 계층 간 송수신 단위 &rsquo; 와 &rsquo; 인접 계층간 전달 단위 &rsquo; 로 정의된다.<br>각 계층의 PDU 명칭, 구조, 역할을 명확히 구분해야 하며, 용어 혼동을 방지하는 것이 중요하다.</p><p><strong>사전 지식 (Prerequisites)</strong>:</p><ul><li>OSI 7 계층 모델, TCP/IP 4 계층 모델</li><li>네트워크 주소 체계 (MAC, IP, Port)</li><li>기본 네트워킹 용어 (라우팅, 스위칭, 패킷 교환)</li></ul><p><strong>핵심 용어</strong>:</p><ul><li><strong>Encapsulation(캡슐화)</strong>: 상위 계층 PDU 를 페이로드로 받아 헤더·트레일러를 추가하는 과정</li><li><strong>Decapsulation(역캡슐화)</strong>: 수신 측에서 하위→상위 순으로 헤더·트레일러를 제거하여 원본 데이터 복원</li><li><strong>Header(헤더)</strong>: PDU 앞부분에 추가되는 제어 정보 (주소, 순서 번호, 플래그 등)</li><li><strong>Trailer(트레일러)</strong>: PDU 뒷부분에 추가되는 제어 정보 (예: FCS, CRC)</li><li><strong>Payload(페이로드)</strong>: 상위 계층 PDU 또는 실제 사용자 데이터</li><li><strong>MTU(Maximum Transmission Unit)</strong>: 네트워크 계층이 데이터링크 계층으로 전달할 수 있는 최대 패킷 크기</li><li><strong>MSS(Maximum Segment Size)</strong>: TCP 세그먼트의 최대 페이로드 크기</li></ul><h2 id=계층별-pdu-구조-및-명칭>계층별 PDU 구조 및 명칭<a hidden class=anchor aria-hidden=true href=#계층별-pdu-구조-및-명칭>#</a></h2><p>OSI 7 계층과 TCP/IP 모델의 각 계층별 PDU 명칭, 헤더 구조, 주요 필드를 상세히 다룬다. 실무에서 가장 많이 사용되는 이더넷 프레임, IP 패킷, TCP 세그먼트를 중심으로 설명한다.</p><h3 id=osi-7-계층-pdu-매핑>OSI 7 계층 PDU 매핑<a hidden class=anchor aria-hidden=true href=#osi-7-계층-pdu-매핑>#</a></h3><table><thead><tr><th>OSI 계층</th><th style=text-align:center>계층 번호</th><th>PDU 명칭</th><th>주요 헤더 정보</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>물리 (Physical)</td><td style=text-align:center>1</td><td>비트 (Bit)</td><td>없음 (전기·광 신호)</td><td>Ethernet PHY, RS-232</td></tr><tr><td>데이터링크 (Data Link)</td><td style=text-align:center>2</td><td>프레임 (Frame)</td><td>MAC 주소 (출발지·목적지), FCS</td><td>Ethernet, Wi-Fi(802.11), PPP</td></tr><tr><td>네트워크 (Network)</td><td style=text-align:center>3</td><td>패킷 (Packet)</td><td>IP 주소 (출발지·목적지), TTL, 프로토콜 ID</td><td>IPv4, IPv6, ICMP</td></tr><tr><td>전송 (Transport)</td><td style=text-align:center>4</td><td>세그먼트 (Segment) / 데이터그램 (Datagram)</td><td>포트 번호 (출발지·목적지), 순서 번호, 체크섬</td><td>TCP, UDP, SCTP</td></tr><tr><td>세션 (Session)</td><td style=text-align:center>5</td><td>데이터 (Data)</td><td>세션 ID, 동기화 포인트</td><td>NetBIOS, RPC</td></tr><tr><td>표현 (Presentation)</td><td style=text-align:center>6</td><td>데이터 (Data)</td><td>인코딩, 암호화 정보</td><td>TLS, JPEG, MPEG</td></tr><tr><td>응용 (Application)</td><td style=text-align:center>7</td><td>메시지 (Message) / 데이터 (Data)</td><td>응용 프로토콜별 헤더</td><td>HTTP, DNS, SMTP, FTP</td></tr></tbody></table><ul><li>하위 3 계층 (1~3) 은 네트워크 인프라 계층으로, 주소 지정과 라우팅을 담당하며 PDU 명칭이 명확히 구분된다.</li><li>전송 계층 (4) 은 종단 간 연결 제어를 담당하며, TCP 는 세그먼트, UDP 는 데이터그램으로 구분된다.</li><li>상위 3 계층 (5~7) 은 OSI 모델에서는 각각 정의되지만, TCP/IP 모델에서는 응용 계층으로 통합되어 " 데이터 " 또는 " 메시지 " 로 통칭된다.</li></ul><pre class=mermaid>flowchart TD
    application-layer[&#34;application-layer(Data)&#34;]
    transport-layer[&#34;transport-layer(Segment/Datagram)&#34;]
    network-layer[&#34;network-layer(Packet)&#34;]
    datalink-layer[&#34;datalink-layer(Frame)&#34;]
    physical-layer[&#34;physical-layer(Bit)&#34;]

    application-layer --&gt; transport-layer
    transport-layer --&gt; network-layer
    network-layer --&gt; datalink-layer
    datalink-layer --&gt; physical-layer
</pre><p>&lt;OSI 7 계층에서의 PDU 흐름><br>상위 계층 데이터가 하위 계층으로 내려갈 때, 각 계층에서 헤더가 추가되어 계층별로 새로운 PDU 가 생성된다.<br>실제 송신시에는 physical 계층의 신호 (Bit) 로 변환된다.</p><h3 id=tcpip-모델-pdu-매핑>TCP/IP 모델 PDU 매핑<a hidden class=anchor aria-hidden=true href=#tcpip-모델-pdu-매핑>#</a></h3><p>TCP/IP 프로토콜 스택 구성과 각 계층 PDU 의 특징, 구조를 병렬 비교한다.</p><table><thead><tr><th>TCP/IP 계층</th><th>PDU 명칭</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>응용 (Application)</td><td>데이터 (Data)</td><td>HTTP, FTP, DNS</td></tr><tr><td>전송 (Transport)</td><td>세그먼트 (Segment)/데이터그램 (Datagram)</td><td>TCP, UDP</td></tr><tr><td>인터넷 (Internet)</td><td>패킷 (Packet)</td><td>IP</td></tr><tr><td>네트워크 액세스 (Link)</td><td>프레임 (Frame)</td><td>Ethernet, Wi-Fi</td></tr></tbody></table><p>&lt;TCP/IP 모델 계층별 PDU 비교><br>TCP/IP 스택에서는 OSI 에 비해 계층 수가 적지만, 각 계층의 PDU 명칭과 실제 동작 방식은 OSI 와 거의 동일하다. 또한 네트워크 장비나 툴에서 각 PDU 명칭을 올바르게 사용하는 것이 중요하다.</p><pre class=mermaid>graph TD
    A[응용 계층&lt;br&gt;Application Layer] --&gt;|데이터/메시지&lt;br&gt;Data/Message| B[전송 계층&lt;br&gt;Transport Layer]
    B --&gt;|세그먼트Segment or 데이터그램Datagram| C[인터넷 계층&lt;br&gt;Internet Layer]
    C --&gt;|패킷Packet| D[네트워크 접근 계층&lt;br&gt;Network Access Layer]
    D --&gt;|프레임Frame| E[물리 매체&lt;br&gt;Physical Medium]
    E --&gt;|비트Bit| F[네트워크 전송]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
    style E fill:#f5e1ff
</pre><p>TCP/IP 4 계층 모델은 OSI 모델을 단순화하여, 응용 (5<del>7 계층 통합), 전송 (4 계층), 인터넷 (3 계층), 네트워크 접근 (1</del>2 계층 통합) 으로 구성된다.<br>각 계층은 상위 PDU 를 페이로드로 받아 자신의 헤더를 추가하며, 최하위 네트워크 접근 계층에서 프레임으로 캡슐화된 후 비트 스트림으로 전송된다. 이 도식은 실무에서 가장 많이 사용되는 모델로, 인터넷 프로토콜 스택의 핵심 구조를 나타낸다.</p><h3 id=이더넷-프레임-구조-layer-2-pdu>이더넷 프레임 구조 (Layer 2 PDU)<a hidden class=anchor aria-hidden=true href=#이더넷-프레임-구조-layer-2-pdu>#</a></h3><table><thead><tr><th>필드</th><th style=text-align:center>크기 (바이트)</th><th>설명</th></tr></thead><tbody><tr><td>Preamble</td><td style=text-align:center>7</td><td>프레임 시작 신호 (10101010 패턴)</td></tr><tr><td>SFD(Start Frame Delimiter)</td><td style=text-align:center>1</td><td>프레임 시작 (10101011)</td></tr><tr><td>Destination MAC</td><td style=text-align:center>6</td><td>목적지 MAC 주소</td></tr><tr><td>Source MAC</td><td style=text-align:center>6</td><td>출발지 MAC 주소</td></tr><tr><td>Type/Length</td><td style=text-align:center>2</td><td>상위 프로토콜 타입 (예: 0x0800=IPv4) 또는 페이로드 길이</td></tr><tr><td>Payload</td><td style=text-align:center>46~1500</td><td>상위 계층 PDU(IP 패킷 등)</td></tr><tr><td>FCS(Frame Check Sequence)</td><td style=text-align:center>4</td><td>CRC-32 오류 검출</td></tr></tbody></table><p><strong>코드 예시: Python 으로 이더넷 프레임 파싱</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_ethernet_frame</span><span class=p>(</span><span class=n>frame_bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이더넷 프레임을 파싱하여 주요 필드 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: frame_bytes (bytes) - 이더넷 프레임 바이트 스트림
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 파싱된 필드 딕셔너리
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 최소 길이 검증 (Preamble·SFD 제외 시 64바이트)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>frame_bytes</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>64</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Invalid frame length&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Preamble·SFD는 물리 계층에서 제거되므로 보통 Wireshark 등에서는 보이지 않음</span>
</span></span><span class=line><span class=cl>    <span class=c1># 여기서는 Destination MAC부터 시작한다고 가정</span>
</span></span><span class=line><span class=cl>    <span class=n>dst_mac</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>6</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>src_mac</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>6</span><span class=p>:</span><span class=mi>12</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_type</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!H&#39;</span><span class=p>,</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>12</span><span class=p>:</span><span class=mi>14</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Big-endian 2바이트</span>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>14</span><span class=p>:</span><span class=o>-</span><span class=mi>4</span><span class=p>]</span>  <span class=c1># FCS 4바이트 제외</span>
</span></span><span class=line><span class=cl>    <span class=n>fcs</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!I&#39;</span><span class=p>,</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=o>-</span><span class=mi>4</span><span class=p>:])[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;dst_mac&#39;</span><span class=p>:</span> <span class=n>dst_mac</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;src_mac&#39;</span><span class=p>:</span> <span class=n>src_mac</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;type&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>eth_type</span><span class=p>),</span>  <span class=c1># 예: 0x0800 (IPv4), 0x86dd (IPv6)</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;payload_len&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>payload</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;fcs&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>fcs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 프레임 (간략화, 실제는 Wireshark 캡처 데이터 사용)</span>
</span></span><span class=line><span class=cl><span class=c1># 예: dst_mac=ff:ff:ff:ff:ff:ff, src_mac=00:11:22:33:44:55, type=0x0800, payload=46바이트, FCS=임의</span>
</span></span><span class=line><span class=cl><span class=n>example_frame</span> <span class=o>=</span> <span class=nb>bytes</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;ffffffffffff001122334455080000450000…&#39;</span> <span class=o>+</span> <span class=s1>&#39;12345678&#39;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 실제 사용 시: result = parse_ethernet_frame(example_frame)</span>
</span></span></code></pre></td></tr></table></div></div><p>이더넷 프레임은 데이터링크 계층 PDU 로, MAC 주소 기반 스위칭을 위한 헤더와 오류 검출을 위한 FCS 트레일러를 포함한다.<br>Type/Length 필드 (2 바이트) 는 상위 프로토콜 (예: IPv4=0x0800, ARP=0x0806) 을 식별하며, Payload 는 46~1500 바이트 범위를 가진다 (MTU=1518 바이트, Jumbo Frame 은 9000 바이트까지 확장 가능). FCS 는 CRC-32 알고리즘으로 프레임 전체의 무결성을 검증한다.</p><h3 id=ip-패킷-구조-layer-3-pdu>IP 패킷 구조 (Layer 3 PDU)<a hidden class=anchor aria-hidden=true href=#ip-패킷-구조-layer-3-pdu>#</a></h3><p><strong>IPv4 헤더 주요 필드</strong>:</p><table><thead><tr><th>필드</th><th style=text-align:center>크기 (비트)</th><th>설명</th></tr></thead><tbody><tr><td>Version</td><td style=text-align:center>4</td><td>IP 버전 (4)</td></tr><tr><td>IHL(Internet Header Length)</td><td style=text-align:center>4</td><td>헤더 길이 (4 바이트 단위, 최소 5=20 바이트)</td></tr><tr><td>DSCP/ECN</td><td style=text-align:center>8</td><td>서비스 품질 (QoS) 및 혼잡 제어</td></tr><tr><td>Total Length</td><td style=text-align:center>16</td><td>헤더 + 페이로드 전체 길이 (최대 65535 바이트)</td></tr><tr><td>Identification</td><td style=text-align:center>16</td><td>단편화 시 원본 패킷 식별자</td></tr><tr><td>Flags + Fragment Offset</td><td style=text-align:center>16</td><td>단편화 제어 (DF, MF 플래그 및 오프셋)</td></tr><tr><td>TTL(Time To Live)</td><td style=text-align:center>8</td><td>라우팅 홉 제한 (0 도달 시 패킷 폐기)</td></tr><tr><td>Protocol</td><td style=text-align:center>8</td><td>상위 프로토콜 (6=TCP, 17=UDP, 1=ICMP)</td></tr><tr><td>Header Checksum</td><td style=text-align:center>16</td><td>헤더 오류 검출 (페이로드 제외)</td></tr><tr><td>Source IP</td><td style=text-align:center>32</td><td>출발지 IPv4 주소</td></tr><tr><td>Destination IP</td><td style=text-align:center>32</td><td>목적지 IPv4 주소</td></tr><tr><td>Options</td><td style=text-align:center>가변</td><td>선택적 필드 (보안, 라우팅 기록 등)</td></tr></tbody></table><p><strong>IP 패킷 캡슐화 플로우</strong></p><pre class=mermaid>sequenceDiagram
    participant App as 응용 계층
    participant TCP as 전송 계층(TCP)
    participant IP as 네트워크 계층(IP)
    participant DL as 데이터링크 계층
    
    App-&gt;&gt;TCP: 데이터 전송 요청
    TCP-&gt;&gt;TCP: 세그먼트 생성&lt;br&gt;(헤더 추가: 출발지·목적지 포트)
    TCP-&gt;&gt;IP: 세그먼트 전달
    IP-&gt;&gt;IP: 패킷 생성&lt;br&gt;(헤더 추가: 출발지·목적지 IP, TTL)
    IP-&gt;&gt;DL: 패킷 전달
    DL-&gt;&gt;DL: 프레임 생성&lt;br&gt;(헤더·트레일러 추가: MAC 주소, FCS)
    DL-&gt;&gt;DL: 물리 매체로 비트 전송
</pre><p>IP 패킷은 네트워크 계층 PDU 로, 출발지·목적지 IP 주소, TTL, 프로토콜 ID 등을 포함한다.<br>TTL 은 라우팅 루프 방지를 위해 각 라우터를 거칠 때마다 1 씩 감소하며, 0 도달 시 패킷이 폐기된다.<br>Identification, Flags, Fragment Offset 필드는 MTU 초과 시 패킷 단편화와 재조립에 사용된다. Header Checksum 은 헤더만 검증하며, 페이로드 무결성은 상위 계층 (예: TCP 체크섬) 이 담당한다.</p><h3 id=tcp-세그먼트-구조-layer-4-pdu>TCP 세그먼트 구조 (Layer 4 PDU)<a hidden class=anchor aria-hidden=true href=#tcp-세그먼트-구조-layer-4-pdu>#</a></h3><p><strong>TCP 헤더 주요 필드</strong>:</p><table><thead><tr><th>필드</th><th style=text-align:center>크기 (비트)</th><th>설명</th></tr></thead><tbody><tr><td>Source Port</td><td style=text-align:center>16</td><td>출발지 포트 번호 (0~65535)</td></tr><tr><td>Destination Port</td><td style=text-align:center>16</td><td>목적지 포트 번호</td></tr><tr><td>Sequence Number</td><td style=text-align:center>32</td><td>세그먼트 순서 번호 (재조립용)</td></tr><tr><td>Acknowledgment Number</td><td style=text-align:center>32</td><td>수신 확인 번호 (다음 기대 순서)</td></tr><tr><td>Data Offset</td><td style=text-align:center>4</td><td>TCP 헤더 길이 (4 바이트 단위, 최소 5=20 바이트)</td></tr><tr><td>Flags</td><td style=text-align:center>9</td><td>제어 플래그 (SYN, ACK, FIN, RST, PSH, URG 등)</td></tr><tr><td>Window Size</td><td style=text-align:center>16</td><td>수신 윈도우 크기 (흐름 제어)</td></tr><tr><td>Checksum</td><td style=text-align:center>16</td><td>헤더 + 페이로드 + 의사 헤더 오류 검출</td></tr><tr><td>Urgent Pointer</td><td style=text-align:center>16</td><td>긴급 데이터 포인터 (URG 플래그 설정 시)</td></tr><tr><td>Options</td><td style=text-align:center>가변</td><td>선택적 필드 (MSS, Window Scale, SACK 등)</td></tr></tbody></table><p><strong>코드 예시: Python 으로 TCP 세그먼트 파싱</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_tcp_segment</span><span class=p>(</span><span class=n>segment_bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    TCP 세그먼트를 파싱하여 주요 필드 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: segment_bytes (bytes) - TCP 세그먼트 바이트 스트림
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 파싱된 필드 딕셔너리
</span></span></span><span class=line><span class=cl><span class=s2>    에러케이스: 최소 길이(20바이트) 미만 시 ValueError
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>segment_bytes</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;TCP segment too short&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Big-endian 형식으로 헤더 파싱</span>
</span></span><span class=line><span class=cl>    <span class=n>src_port</span><span class=p>,</span> <span class=n>dst_port</span><span class=p>,</span> <span class=n>seq</span><span class=p>,</span> <span class=n>ack</span><span class=p>,</span> <span class=n>offset_flags</span><span class=p>,</span> <span class=n>window</span><span class=p>,</span> <span class=n>checksum</span><span class=p>,</span> <span class=n>urg_ptr</span> <span class=o>=</span> \
</span></span><span class=line><span class=cl>        <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!HHIIHHH&#39;</span><span class=p>,</span> <span class=n>segment_bytes</span><span class=p>[:</span><span class=mi>20</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Data Offset은 상위 4비트(4바이트 단위)</span>
</span></span><span class=line><span class=cl>    <span class=n>header_len</span> <span class=o>=</span> <span class=p>(</span><span class=n>offset_flags</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=c1># Flags는 하위 9비트 (NS=1, CWR=1, ECE=1, URG=1, ACK=1, PSH=1, RST=1, SYN=1, FIN=1)</span>
</span></span><span class=line><span class=cl>    <span class=n>flags</span> <span class=o>=</span> <span class=n>offset_flags</span> <span class=o>&amp;</span> <span class=mh>0x01FF</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>segment_bytes</span><span class=p>[</span><span class=n>header_len</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;src_port&#39;</span><span class=p>:</span> <span class=n>src_port</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;dst_port&#39;</span><span class=p>:</span> <span class=n>dst_port</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;seq&#39;</span><span class=p>:</span> <span class=n>seq</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;ack&#39;</span><span class=p>:</span> <span class=n>ack</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;header_len&#39;</span><span class=p>:</span> <span class=n>header_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;flags&#39;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;SYN&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x02</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;ACK&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;FIN&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x01</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;RST&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x04</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;PSH&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x08</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;window&#39;</span><span class=p>:</span> <span class=n>window</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;checksum&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>checksum</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;payload_len&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시: SYN 세그먼트 (간략화)</span>
</span></span><span class=line><span class=cl><span class=c1># src=12345, dst=80, seq=1000, ack=0, flags=SYN, window=65535</span>
</span></span><span class=line><span class=cl><span class=n>example_tcp</span> <span class=o>=</span> <span class=nb>bytes</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=s1>&#39;30390050000003e8000000005002ffff0000&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 실제 사용 시: result = parse_tcp_segment(example_tcp)</span>
</span></span></code></pre></td></tr></table></div></div><p>TCP 세그먼트는 전송 계층 PDU 로, 포트 번호를 통해 응용 프로세스를 식별하고, 순서 번호와 확인 번호로 신뢰성 있는 데이터 전송을 구현한다.<br>Flags 필드는 연결 설정 (SYN), 확인 (ACK), 종료 (FIN), 재설정 (RST) 등 제어 기능을 담당하며, Window Size 는 TCP 흐름 제어를 위한 수신 버퍼 크기를 알린다. Options 필드는 MSS(Maximum Segment Size), Window Scale, SACK(Selective Acknowledgment) 등 성능 최적화 파라미터를 협상한다.</p><h3 id=대표-pdu-형식-빠르게-보기>대표 PDU 형식 빠르게 보기<a hidden class=anchor aria-hidden=true href=#대표-pdu-형식-빠르게-보기>#</a></h3><p><strong>표 4-1. 필수 필드 스냅샷</strong></p><table><thead><tr><th>프로토콜</th><th>핵심 필드 (일부)</th><th>체크섬/검증</th><th>특이점</th></tr></thead><tbody><tr><td>Ethernet II</td><td>DA/SA, EtherType, FCS</td><td>FCS(32-bit CRC)</td><td>최소 64B 프레임, 점보 가능</td></tr><tr><td>IPv4</td><td>Version/IHL, TotalLen, ID/Flags/FragOff, TTL, Proto, HdrChk</td><td>헤더 체크섬</td><td>중간 단편화 허용</td></tr><tr><td>IPv6</td><td>Version, Traffic Class, Flow Label, PayloadLen, NextHdr, HopLimit</td><td>무 (상위에서)</td><td>확장헤더 체인, MTU 최소 1280</td></tr><tr><td>TCP</td><td>Ports, Seq/Ack, Flags, Window, Checksum, Options</td><td>의무</td><td>신뢰·흐름·혼잡제어</td></tr><tr><td>UDP</td><td>Ports, Length, Checksum</td><td>IPv6 에서 의무</td><td>저오버헤드</td></tr><tr><td>TLS 1.3</td><td>ContentType, Length(+AEAD Tag)</td><td>AEAD</td><td>0-RTT/암호화 가시성 제한</td></tr><tr><td>QUIC</td><td>DCID/SCID, Pn, Frames(varint)</td><td>AEAD</td><td>사용자 공간, 연결이동/멀티플렉싱</td></tr><tr><td>SCTP</td><td>Verification Tag, TSN, Streams, Chunks</td><td>CRC32c</td><td>멀티스트림/멀티홈</td></tr></tbody></table><p>필드 존재와 검증 방식이 PDU 의 신뢰·오버헤드·가시성을 좌우한다. 예컨대 IPv6 는 헤더 체크섬을 제거해 라우터 처리 비용을 낮췄으며, QUIC/TLS 는 암호화로 중간 가시성을 줄여 상위 진단 기법이 요구된다.</p><p><strong>Python 스니펫 4-B—20 바이트 IPv4 고정헤더 파서 (학습용)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 목적: 바이트열에서 IPv4 고정 헤더(20B)를 파싱하여 핵심 필드 추출</span>
</span></span><span class=line><span class=cl><span class=c1># 입력: bytes(길이&gt;=20)</span>
</span></span><span class=line><span class=cl><span class=c1># 출력: dict</span>
</span></span><span class=line><span class=cl><span class=c1># 예외: 길이/버전 오류 발생 시 ValueError</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_ipv4_header</span><span class=p>(</span><span class=n>buf</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;short buffer&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vihl</span><span class=p>,</span> <span class=n>tos</span><span class=p>,</span> <span class=n>total_len</span><span class=p>,</span> <span class=n>ident</span><span class=p>,</span> <span class=n>flags_frag</span><span class=p>,</span> <span class=n>ttl</span><span class=p>,</span> <span class=n>proto</span><span class=p>,</span> <span class=n>hdr_chk</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>dst</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;!BBHHHBBHII&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>[:</span><span class=mi>20</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span> <span class=o>=</span> <span class=n>vihl</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=n>ihl</span> <span class=o>=</span> <span class=p>(</span><span class=n>vihl</span> <span class=o>&amp;</span> <span class=mh>0x0F</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>version</span> <span class=o>!=</span> <span class=mi>4</span> <span class=ow>or</span> <span class=n>ihl</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;invalid IPv4 header&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>flags</span> <span class=o>=</span> <span class=p>(</span><span class=n>flags_frag</span> <span class=o>&gt;&gt;</span> <span class=mi>13</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x7</span>
</span></span><span class=line><span class=cl>    <span class=n>frag_off</span> <span class=o>=</span> <span class=n>flags_frag</span> <span class=o>&amp;</span> <span class=mh>0x1FFF</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;version&#34;</span><span class=p>:</span> <span class=n>version</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ihl&#34;</span><span class=p>:</span> <span class=n>ihl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;total_len&#34;</span><span class=p>:</span> <span class=n>total_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=n>ident</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;flags&#34;</span><span class=p>:</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;frag_off&#34;</span><span class=p>:</span> <span class=n>frag_off</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ttl&#34;</span><span class=p>:</span> <span class=n>ttl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;proto&#34;</span><span class=p>:</span> <span class=n>proto</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;hdr_checksum&#34;</span><span class=p>:</span> <span class=n>hdr_chk</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;src&#34;</span><span class=p>:</span> <span class=n>src</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;dst&#34;</span><span class=p>:</span> <span class=n>dst</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>해설: 교육 목적의 최소 파서로, 옵션/확장 미처리·체크섬 재계산은 생략했다. 실제 구현은 경계검사, 옵션 파싱, 조각 재조립, 보안 처리까지 필요하다.</p><h2 id=캡슐화와-역캡슐화-메커니즘>캡슐화와 역캡슐화 메커니즘<a hidden class=anchor aria-hidden=true href=#캡슐화와-역캡슐화-메커니즘>#</a></h2><p>PDU 의 핵심 동작 원리인 캡슐화 (Encapsulation) 와 역캡슐화 (Decapsulation) 과정을 상세히 다룬다.<br>송·수신 측의 계층별 처리 흐름과 실무 네트워크 장비 (라우터, 스위치) 의 PDU 조작 방식을 설명한다.</p><h3 id=캡슐화-과정-encapsulation>캡슐화 과정 (Encapsulation)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-encapsulation>#</a></h3><p><strong>정의</strong>: 송신 측에서 상위 계층 PDU 를 페이로드로 받아, 각 계층의 헤더 (및 트레일러) 를 추가하여 하위 계층 PDU 를 생성하는 과정.</p><p><strong>단계별 흐름</strong>:</p><pre class=mermaid>graph LR
    A[응용 데이터&lt;br&gt;Application Data] --&gt;|전송 계층| B[TCP 세그먼트&lt;br&gt;TCP Header + Data]
    B --&gt;|네트워크 계층| C[IP 패킷&lt;br&gt;IP Header + Segment]
    C --&gt;|데이터링크 계층| D[이더넷 프레임&lt;br&gt;Ethernet Header + Packet + FCS]
    D --&gt;|물리 계층| E[비트 스트림&lt;br&gt;Bit Stream]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
    style E fill:#f5e1ff
</pre><p><strong>표: 계층별 캡슐화 단계</strong></p><table><thead><tr><th>계층</th><th>입력 (상위 PDU)</th><th>추가 정보</th><th>출력 (현 계층 PDU)</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>응용 (7)</td><td>사용자 데이터</td><td>HTTP 헤더</td><td>HTTP 요청/응답</td><td>HTTP, DNS</td></tr><tr><td>전송 (4)</td><td>HTTP 메시지</td><td>TCP 헤더 (포트, 순서 번호)</td><td>TCP 세그먼트</td><td>TCP</td></tr><tr><td>네트워크 (3)</td><td>TCP 세그먼트</td><td>IP 헤더 (출발지·목적지 IP)</td><td>IP 패킷</td><td>IPv4</td></tr><tr><td>데이터링크 (2)</td><td>IP 패킷</td><td>이더넷 헤더 (MAC 주소) + FCS</td><td>이더넷 프레임</td><td>Ethernet</td></tr><tr><td>물리 (1)</td><td>이더넷 프레임</td><td>전기·광 신호 변환</td><td>비트 스트림</td><td>1000BASE-T</td></tr></tbody></table><p><strong>코드 예시: Python 으로 간단한 캡슐화 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>encapsulate_data</span><span class=p>(</span><span class=n>app_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    응용 데이터를 계층별로 캡슐화하는 시뮬레이션
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: app_data (str) - 응용 계층 데이터
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 각 계층별 PDU
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 응용 계층 (예: HTTP GET 요청)</span>
</span></span><span class=line><span class=cl>    <span class=n>http_header</span> <span class=o>=</span> <span class=s2>&#34;GET /index.html HTTP/1.1</span><span class=se>\r\n</span><span class=s2>Host: example.com</span><span class=se>\r\n\r\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>http_pdu</span> <span class=o>=</span> <span class=n>http_header</span> <span class=o>+</span> <span class=n>app_data</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 전송 계층 (TCP 헤더 간략화: 포트 번호만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_PORT=12345|DST_PORT=80|SEQ=1000|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_segment</span> <span class=o>=</span> <span class=n>tcp_header</span> <span class=o>+</span> <span class=n>http_pdu</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 네트워크 계층 (IP 헤더 간략화: IP 주소만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_IP=192.168.1.100|DST_IP=93.184.216.34|TTL=64|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_packet</span> <span class=o>=</span> <span class=n>ip_header</span> <span class=o>+</span> <span class=n>tcp_segment</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 데이터링크 계층 (이더넷 헤더 간략화: MAC 주소만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_MAC=00:11:22:33:44:55|DST_MAC=AA:BB:CC:DD:EE:FF|TYPE=0x0800|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_trailer</span> <span class=o>=</span> <span class=s2>&#34;|FCS=0x12345678&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ethernet_frame</span> <span class=o>=</span> <span class=n>eth_header</span> <span class=o>+</span> <span class=n>ip_packet</span> <span class=o>+</span> <span class=n>eth_trailer</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;application&#39;</span><span class=p>:</span> <span class=n>http_pdu</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;transport&#39;</span><span class=p>:</span> <span class=n>tcp_segment</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;network&#39;</span><span class=p>:</span> <span class=n>ip_packet</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;data_link&#39;</span><span class=p>:</span> <span class=n>ethernet_frame</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 실행</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>encapsulate_data</span><span class=p>(</span><span class=s2>&#34;Hello, World!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 출력: result[&#39;data_link&#39;]에 전체 캡슐화된 프레임 포함</span>
</span></span></code></pre></td></tr></table></div></div><p>캡슐화는 상위→하위 방향으로 진행되며, 각 계층은 상위 PDU 전체를 " 불투명한 페이로드 " 로 취급한다. 예를 들어, 네트워크 계층 (IP) 은 TCP 세그먼트의 내부 구조를 알 필요 없이 헤더만 추가하여 패킷을 생성한다. 이는 계층 간 독립성과 확장성을 보장한다. 실무에서는 네트워크 스택 (예: Linux kernel 의 <code>sk_buff</code> 구조체) 이 각 계층에서 헤더를 prepend 하는 방식으로 구현된다.</p><h3 id=역캡슐화-과정-decapsulation>역캡슐화 과정 (Decapsulation)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-decapsulation>#</a></h3><p><strong>정의</strong>: 수신 측에서 하위 계층 PDU 로부터 헤더 (및 트레일러) 를 제거하여 상위 계층 PDU 를 복원하는 과정.</p><p><strong>단계별 흐름</strong>:</p><pre class=mermaid>graph LR
    A[비트 스트림&lt;br&gt;Bit Stream] --&gt;|물리 계층| B[이더넷 프레임&lt;br&gt;Ethernet Frame]
    B --&gt;|데이터링크 계층| C[IP 패킷&lt;br&gt;IP Packet]
    C --&gt;|네트워크 계층| D[TCP 세그먼트&lt;br&gt;TCP Segment]
    D --&gt;|전송 계층| E[응용 데이터&lt;br&gt;Application Data]
    
    style A fill:#f5e1ff
    style B fill:#e1ffe1
    style C fill:#ffe1f5
    style D fill:#fff4e1
    style E fill:#e1f5ff
</pre><p><strong>표: 계층별 역캡슐화 단계</strong></p><table><thead><tr><th>계층</th><th>입력 (하위 PDU)</th><th>제거 정보</th><th>출력 (상위 PDU)</th><th>검증 사항</th></tr></thead><tbody><tr><td>물리 (1)</td><td>비트 스트림</td><td>신호 복조</td><td>이더넷 프레임</td><td>프리앰블·SFD 확인</td></tr><tr><td>데이터링크 (2)</td><td>이더넷 프레임</td><td>이더넷 헤더 + FCS</td><td>IP 패킷</td><td>FCS 검증, MAC 주소 필터링</td></tr><tr><td>네트워크 (3)</td><td>IP 패킷</td><td>IP 헤더</td><td>TCP 세그먼트</td><td>Header Checksum, TTL 확인</td></tr><tr><td>전송 (4)</td><td>TCP 세그먼트</td><td>TCP 헤더</td><td>HTTP 메시지</td><td>TCP Checksum, 순서 번호 확인</td></tr><tr><td>응용 (7)</td><td>HTTP 메시지</td><td>HTTP 헤더</td><td>사용자 데이터</td><td>응용 프로토콜 규칙 검증</td></tr></tbody></table><p><strong>코드 예시: Python 으로 간단한 역캡슐화 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26>26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27>27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28>28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29>29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30>30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31>31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32>32</a>
</span><span class=lnt id=hl-9-33><a class=lnlinks href=#hl-9-33>33</a>
</span><span class=lnt id=hl-9-34><a class=lnlinks href=#hl-9-34>34</a>
</span><span class=lnt id=hl-9-35><a class=lnlinks href=#hl-9-35>35</a>
</span><span class=lnt id=hl-9-36><a class=lnlinks href=#hl-9-36>36</a>
</span><span class=lnt id=hl-9-37><a class=lnlinks href=#hl-9-37>37</a>
</span><span class=lnt id=hl-9-38><a class=lnlinks href=#hl-9-38>38</a>
</span><span class=lnt id=hl-9-39><a class=lnlinks href=#hl-9-39>39</a>
</span><span class=lnt id=hl-9-40><a class=lnlinks href=#hl-9-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>decapsulate_frame</span><span class=p>(</span><span class=n>ethernet_frame</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이더넷 프레임을 역캡슐화하여 응용 데이터 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: ethernet_frame (str) - 캡슐화된 이더넷 프레임
</span></span></span><span class=line><span class=cl><span class=s2>    출력: str - 응용 계층 데이터
</span></span></span><span class=line><span class=cl><span class=s2>    에러케이스: FCS 불일치 시 None 반환
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 데이터링크 계층: 이더넷 헤더·트레일러 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;|FCS=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>ethernet_frame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>  <span class=c1># FCS 없음 → 손상된 프레임</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># FCS 검증 (간략화: 단순 존재 확인)</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>ethernet_frame</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|TYPE=0x0800|&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>parts</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_packet</span> <span class=o>=</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|FCS=&#34;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 네트워크 계층: IP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;SRC_IP=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>ip_packet</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_segment</span> <span class=o>=</span> <span class=n>ip_packet</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|TTL=64|&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 전송 계층: TCP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;SRC_PORT=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tcp_segment</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>http_pdu</span> <span class=o>=</span> <span class=n>tcp_segment</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|SEQ=1000|&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 응용 계층: HTTP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;HTTP/1.1&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>http_pdu</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>app_data</span> <span class=o>=</span> <span class=n>http_pdu</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\r\n\r\n</span><span class=s2>&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>app_data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 실행 (캡슐화 결과를 역캡슐화)</span>
</span></span><span class=line><span class=cl><span class=n>original_data</span> <span class=o>=</span> <span class=s2>&#34;Hello, World!&#34;</span>
</span></span><span class=line><span class=cl><span class=n>encapsulated</span> <span class=o>=</span> <span class=n>encapsulate_data</span><span class=p>(</span><span class=n>original_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>recovered_data</span> <span class=o>=</span> <span class=n>decapsulate_frame</span><span class=p>(</span><span class=n>encapsulated</span><span class=p>[</span><span class=s1>&#39;data_link&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>recovered_data</span> <span class=o>==</span> <span class=n>original_data</span>  <span class=c1># 검증: 원본 데이터 복원 확인</span>
</span></span></code></pre></td></tr></table></div></div><p>역캡슐화는 하위→상위 방향으로 진행되며, 각 계층은 자신의 헤더를 제거하고 상위 계층으로 페이로드를 전달한다. 데이터링크 계층에서는 FCS 검증을 통해 프레임 무결성을 확인하고, 네트워크 계층에서는 Header Checksum 과 TTL 을 검사하며, 전송 계층에서는 TCP Checksum 과 순서 번호를 확인한다. 검증 실패 시 해당 PDU 는 폐기되고 상위 계층으로 전달되지 않는다.</p><h3 id=네트워크-장비의-pdu-처리>네트워크 장비의 PDU 처리<a hidden class=anchor aria-hidden=true href=#네트워크-장비의-pdu-처리>#</a></h3><table><thead><tr><th>장비</th><th>계층 (주요)</th><th>관찰/처리 PDU</th><th>핵심 동작</th><th>헤더/필드 처리</th><th>장점</th><th>주의/한계</th><th>대표 시나리오</th></tr></thead><tbody><tr><td><strong>라우터 (Router)</strong></td><td>L3</td><td>IP <strong>패킷</strong></td><td>목적지 IP 기준 라우팅 테이블 조회 후 <strong>다음 홉</strong> 결정, 역캡슐화→재캡슐화</td><td><strong>TTL/Hop Limit −1</strong>, <strong>IPv4 헤더 체크섬 재계산</strong>(IPv6 은 없음), <strong>새 L2 헤더</strong>(다음 홉 MAC) 부여</td><td>네트워크 분리/연결, 다양한 라우팅 프로토콜 (OSPF/BGP)</td><td>ICMP/PMTUD 차단 시 블랙홀, ACL/정책에 따른 처리 지연 가능</td><td>L3 경로 제어, 사이트 간 연결, 세그먼트 간 통신</td></tr><tr><td><strong>스위치 (Switch)</strong></td><td>L2</td><td>이더넷 <strong>프레임</strong></td><td>목적지 <strong>MAC</strong> 기반 <strong>CAM(MAC) 테이블</strong> 룩업 후 포트 포워딩, 브로드캐스트/플러딩</td><td>L2 헤더만 확인, <strong>상위 PDU(IPv4/IPv6/TCP/UDP) 는 미건드림</strong></td><td>선형 속도 처리, 지연·오버헤드 최소</td><td>루프 시 브로드캐스트 스톰 (→STP 필요), VLAN 설계 필요</td><td>액세스/엣지 스위칭, 서버 랙 내 고속 L2 스위칭</td></tr><tr><td><strong>Layer 3 스위치</strong></td><td>L3(하드웨어)</td><td>IP <strong>패킷</strong></td><td>라우터 기능을 <strong>ASIC</strong>로 가속, <strong>VLAN 간 라우팅 (Inter-VLAN)</strong>, 멀티캐스트</td><td>라우터와 동일 (IPv4 체크섬/TTL, 새 L2 헤더), 다만 하드웨어 경로</td><td>고속 L3 포워딩, 단일 섀시 내 간결 설계</td><td>고급 라우팅/보안 기능은 제한될 수 있음 (모델 의존)</td><td>데이터센터 코어/디스트리뷰션, 대규모 VLAN 간 트래픽</td></tr><tr><td><strong>방화벽 (Firewall)</strong></td><td>L4–L7</td><td>IP <strong>패킷</strong>/세션</td><td><strong>정책 기반 필터링</strong>(IP/포트/프로토콜), <strong>상태기반 (STATEFUL)</strong> 검사; <strong>NGFW</strong>는 <strong>DPI</strong>로 L7 페이로드 분석</td><td>세션 테이블 관리, NAT/ALG, 앱 시그니처·TLS 검사 (옵션)</td><td>보안 정책 일관 적용, 침해 차단</td><td>DPI/SSL 가시성 설정 시 지연·오버헤드↑, 오탐/미탐 이슈</td><td>경계 보안, 세그먼트 사이 North-South 트래픽 제어</td></tr><tr><td><strong>로드밸런서 (Load Balancer)</strong></td><td>L4 또는 L7</td><td>L4: TCP/UDP <strong>세그먼트/데이터그램</strong>; L7: <strong>HTTP 등 메시지</strong></td><td><strong>분산</strong>(해시/퍼시스턴스/헬스체크), <strong>L7 은 콘텐츠 기반 라우팅</strong>(URL/헤더/쿠키)</td><td>L4: 5- 튜플 기반, DSR/NAT/프록시; L7: HTTP 헤더 파싱, <strong>TLS 종료/오프로드</strong> 가능</td><td>탄력 확장, 장애 격리, 트래픽 정책 세분화</td><td>L7 은 처리비용↑(파싱/암복호), 세션 일관성 관리 필요</td><td>웹/API 트래픽 분산, 마이크로서비스 인그레스, TLS 오프로딩</td></tr></tbody></table><p>네트워크 장비는 특정 계층의 PDU 헤더를 분석·조작하여 패킷 전달, 필터링, 분산 등의 기능을 수행한다. 하위 계층 장비 (허브·스위치) 는 상위 PDU 를 투명하게 전달하는 반면, 상위 계층 장비 (방화벽·로드밸런서) 는 응용 데이터까지 분석할 수 있다. 이는 PDU 계층 구조가 네트워크 인프라의 기능 분리와 확장성을 가능하게 함을 보여준다.</p><h3 id=mtu-단편화-mss-협상>MTU, 단편화, MSS 협상<a hidden class=anchor aria-hidden=true href=#mtu-단편화-mss-협상>#</a></h3><ul><li><strong>MTU (Maximum Transmission Unit)</strong>: 경로에서 <strong>단편화 없이</strong> 보낼 수 있는 <strong>IP(L3) 패킷 최대 크기</strong>. 인터페이스 MTU(링크별) 와 **Path MTU(경로 최소값)**을 구분한다. MTU 는 상위 모든 PDU 크기의 상한을 규정한다.</li><li><strong>단편화 (Frag/Reassembly)</strong>: MTU 를 초과하는 IP 패킷을 <strong>여러 단편</strong>으로 나눠 전송/수신 측에서 재조립. <strong>IPv4</strong>는 라우터·송신자 모두 가능 (DF=0 일 때), <strong>IPv6</strong>는 <strong>송신자만</strong> 가능하며 라우터 단편화 금지 (Frag EH 사용). 원칙은 <strong>회피</strong>다.</li><li><strong>MSS 협상 (Maximum Segment Size)</strong>: TCP 가 핸드셰이크 (<strong>SYN/SYN‑ACK</strong>) 에서 합의하는 <strong>TCP 데이터 최대치</strong>(헤더 제외). 경계 장비의 <strong>MSS 클램핑</strong>은 경로 MTU 미스매치에 대한 보호장치다.</li></ul><blockquote><p>해설: 세 개념은 한 파이프라인에서 연결된다. <strong>MTU 가 상한을 정하고 → MSS 가 TCP 단위 크기를 결정 → 단편화는 실패 시 발생하는 예외 처리</strong>다. 운영 목표는 <em>단편화 없이</em> PMTUD/PLPMTUD·MSS 로 안전 크기를 유지하는 것이다.</p></blockquote><h4 id=정의특징역할기능>정의·특징·역할/기능<a hidden class=anchor aria-hidden=true href=#정의특징역할기능>#</a></h4><h5 id=mtu-maximum-transmission-unit>MTU (Maximum Transmission Unit)<a hidden class=anchor aria-hidden=true href=#mtu-maximum-transmission-unit>#</a></h5><ul><li><strong>정의</strong>: 단편화 없이 전송 가능한 <strong>IP 패킷 (L3) 최대 크기</strong>.</li><li><strong>특징</strong><ul><li>값의 기준은 <strong>IP MTU</strong>(L2 헤더/트레일러 제외). 이더넷 1500 이 흔함, IPv6 최소는 1280.</li><li><strong>헤더 누적</strong>(IPv6, TCP 옵션, TLS/QUIC, 터널/오버레이) 로 유효 L7 이 줄어든다.</li><li>MTU는 처리량·지연·CPU 효율성에 직접 영향</li></ul></li><li><strong>역할/기능</strong><ul><li><strong>크기 상한</strong> 제공 → 패킷화/세그먼트화 기준.</li><li><strong>경로 적합성</strong> 판단 (블랙홀/재전송 방지의 기준).</li></ul></li></ul><blockquote><p><strong>계산식</strong>: <code>Max L7 ≈ IP MTU − (IP + L4 + 보안/옵션/오버레이)</code> / <code>TCP MSS = IP MTU − (IP + TCP)</code>.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=err>┌────────────────────┐</span>
</span></span><span class=line><span class=cl><span class=err>│</span>     <span class=err>이더넷</span> <span class=err>프레임</span> <span class=p>(</span><span class=mi>1518</span><span class=err>바이트</span><span class=p>)</span>                  <span class=err>│</span>
</span></span><span class=line><span class=cl><span class=err>├─────┬─────────┬────┤</span>
</span></span><span class=line><span class=cl><span class=err>│</span>  <span class=n>Header</span>   <span class=err>│</span>   <span class=n>Payload</span> <span class=p>(</span><span class=n>MTU</span><span class=p>)</span>  <span class=err>│</span>    <span class=n>FCS</span>    <span class=err>│</span>
</span></span><span class=line><span class=cl><span class=err>│</span> <span class=mi>14</span><span class=err>바이트</span> <span class=err>│</span>    <span class=mi>1500</span><span class=err>바이트</span>       <span class=err>│</span> <span class=mi>4</span><span class=err>바이트</span> <span class=err>│</span>
</span></span><span class=line><span class=cl><span class=err>└─────┴─────────┴────┘</span>
</span></span><span class=line><span class=cl>            <span class=err>↑</span>                              <span class=err>↑</span>
</span></span><span class=line><span class=cl>           <span class=err>이</span> <span class=err>부분이</span> <span class=n>MTU</span> <span class=p>(</span><span class=err>헤더·트레일러</span> <span class=err>제외</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Path MTU</strong>: 경로상 링크 IP MTU 의 <strong>최소값</strong>.</p><ul><li><p><strong>예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>호스트A (MTU=9000) 
</span></span><span class=line><span class=cl>  → 스위치 (9000) 
</span></span><span class=line><span class=cl>  → 라우터1 (1500) ← Path MTU 병목!
</span></span><span class=line><span class=cl>  → 인터넷 (1500)
</span></span><span class=line><span class=cl>  → VPN 게이트웨이 (1400) ← 실제 Path MTU = 1400
</span></span><span class=line><span class=cl>  → 호스트B (1500)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>결과: 1400 초과 패킷은 단편화되거나 폐기됨
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>계층별 관계</strong></p><pre class=mermaid>flowchart TB
    subgraph L2[&#34;L2 프레임 (1518 B)&#34;]
        direction LR
        L2H[L2 헤더&lt;br/&gt;이더넷 14 B]
        subgraph MTU[&#34;MTU (1500 B)&#34;]
            direction LR
            IPH[IP 헤더&lt;br/&gt;20~60 B]
            subgraph IPP[&#34;IP 페이로드 (1440~1480 B)&#34;]
                direction TB
                TCP[TCP 헤더&lt;br/&gt;20 B]
                UDP[UDP 헤더&lt;br/&gt;8 B]
                subgraph MSS[&#34;MSS 영역&#34;]
                    DATA[TCP/UDP 데이터&lt;br/&gt;1380~1472 B]
                end
            end
        end
        FCS[FCS&lt;br/&gt;CRC 4 B]
        
        L2H --&gt; IPH
        IPH --&gt; IPP
        TCP -.-&gt; DATA
        UDP -.-&gt; DATA
        IPP --&gt; FCS
    end
    
    style L2 fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style MTU fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style IPP fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style MSS fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    style L2H fill:#bbdefb,stroke:#1565c0
    style IPH fill:#c8e6c9,stroke:#2e7d32
    style FCS fill:#bbdefb,stroke:#1565c0
    style DATA fill:#f8bbd0,stroke:#880e4f
</pre><h6 id=mtu와-밀접한-관련이-있는-기타-개념>MTU와 밀접한 관련이 있는 기타 개념<a hidden class=anchor aria-hidden=true href=#mtu와-밀접한-관련이-있는-기타-개념>#</a></h6><table><thead><tr><th>개념</th><th>관계</th><th>근거</th></tr></thead><tbody><tr><td><strong>PMTUD</strong> (Path MTU Discovery)</td><td>경로 상 최소 MTU를 동적 발견</td><td>RFC 1191</td></tr><tr><td><strong>PLPMTUD</strong> (Packetization Layer PMTUD)</td><td>ICMP 없이 MSS 기반 MTU 탐지</td><td>RFC 4821</td></tr><tr><td><strong>DF Flag</strong> (Don&rsquo;t Fragment)</td><td>단편화 금지 → PMTUD 활성화</td><td>RFC 791</td></tr><tr><td><strong>ICMP Type 3 Code 4</strong></td><td>&ldquo;Fragmentation Needed&rdquo; 메시지</td><td>RFC 792</td></tr><tr><td><strong>Jumbo Frame</strong></td><td>MTU를 9000바이트로 확장</td><td>IEEE 802.3</td></tr><tr><td><strong>GRE/IPsec Overhead</strong></td><td>터널 헤더로 인한 유효 MTU 감소</td><td>RFC 2784</td></tr></tbody></table><h5 id=단편화-fragmentation>단편화 (Fragmentation)<a hidden class=anchor aria-hidden=true href=#단편화-fragmentation>#</a></h5><ul><li><strong>정의</strong>: MTU 초과 패킷을 <strong>여러 조각</strong>으로 나눠 전송·수신측에서 재조립.</li><li><strong>특징</strong><ul><li><strong>IPv4</strong>: DF=0 이면 <strong>라우터/송신자 모두</strong> 가능, DF=1 이면 <strong>ICMP(Frag Needed)</strong>.</li><li><strong>IPv6</strong>: <strong>라우터 단편화 금지</strong>, 송신자만 가능 (PTB 로 크기 교정).</li><li>재조립 비용↑, 손실 민감↑, 방화벽/NAT 문제 (중간 단편에 포트없음) → <strong>회피가 원칙</strong>.</li></ul></li><li><strong>역할/기능</strong>: 최후의 안전망이지만 지연/손실/CPU 비용을 키우므로 <strong>PMTUD/PLPMTUD + MSS</strong>로 사전 회피.</li></ul><h5 id=mss-협상-maximum-segment-size>MSS 협상 (Maximum Segment Size)<a hidden class=anchor aria-hidden=true href=#mss-협상-maximum-segment-size>#</a></h5><ul><li><strong>정의</strong>: TCP 세그먼트 <strong>데이터부 최대 크기</strong>(헤더 제외). 3-way handshake 에서 <strong>서로 광고 → 더 작은 값</strong> 사용.</li><li><strong>특징</strong><ul><li><code>MSS = IP MTU − (IP + TCP)</code>(옵션 고려 시 더 작게). 일반 이더넷 IPv4 기준 <strong>1460B</strong>, IPv6 <strong>1440B</strong>(고정헤더만).</li><li><strong>MSS 클램핑</strong>: 중간장비가 SYN 의 MSS 를 낮춰 경로 MTU 에 맞춤 (터널/VPN 안정화).</li></ul></li><li><strong>역할/기능</strong>: <strong>세그먼트화 단계에서 MTU 초과를 예방</strong> → 단편화·재조립 회피, 재전송 감소.</li></ul><h4 id=적용-위치와-흐름>적용 위치와 흐름<a hidden class=anchor aria-hidden=true href=#적용-위치와-흐름>#</a></h4><ul><li><strong>MTU</strong>는 <strong>송신 호스트의 IP egress</strong>와 <strong>라우터 egress</strong>에서 <strong>실제 크기 검증</strong>이 이뤄지고, 터널 ingress 에서는 <strong>외부 헤더 가산</strong>을 고려해 <strong>내부 MTU 를 미리 낮추는 설계</strong>가 필수다.</li><li><strong>MSS</strong>는 <strong>양끝 TCP</strong>가 <strong>SYN 교환</strong>으로 결정하고, <strong>중간 장비</strong>가 클램핑으로 강제 축소해 <strong>단편화 사전 회피</strong>에 기여한다.</li><li><strong>단편화</strong>는 IPv4 에서 <strong>송신/라우터</strong> 모두 가능 (DF=0), IPv6 는 <strong>송신자만</strong> 가능하며, <strong>재조립은 항상 수신 호스트 IP</strong>가 담당한다. 가능하면 <strong>PMTUD/PLPMTUD+MSS</strong>로 회피하라.</li></ul><p><strong>적용흐름</strong></p><ol><li><strong>Host A / TCP</strong>: SYN 에 <strong>MSS 광고</strong>, 상대와 min 선택 → <strong>세그먼트화 한도 결정</strong>.</li><li><strong>Host A / IP</strong>: 라우팅 후 <strong>출구 MTU/PMTU</strong> 확인 → 크기 초과면 축소 (IPv6) 또는 (IPv4, DF=0) 자체 단편화.</li><li><strong>Routers / Forwarding</strong>: egress MTU 비교 → (IPv4, DF=0) 단편화 <strong>또는</strong> (IPv4 DF=1/IPv6) <strong>ICMP</strong> 통지.</li><li><strong>Host A / PLPMTUD</strong>: ICMP 또는 ACK 기반으로 <strong>PMTU 캐시 갱신</strong>, <strong>세그먼트/레코드 크기 추가 축소</strong>.</li><li><strong>Host B / IP</strong>: 도착한 조각 <strong>재조립</strong> 후 L4 로 인도.</li></ol><pre class=mermaid>flowchart LR
%% title: mtu-frag-mss-from-to
%% caption: From(캡슐화)→경로(MTU/ICMP)→To(역캡슐화/재조립) 흐름

subgraph HOST_A[&#34;Host A — 캡슐화&#34;]
  A1[앱 SDU]
  A2[&#34;TLS/QUIC (선택)&#34;]
  A3[&#34;TCP/UDP (세그먼트/데이터그램)&#34;]
  A4[&#34;IP (IPv4/IPv6)&#34;]
  A5[L2 프레임화]
  A1 --&gt; A2 --&gt; A3 --&gt; A4 --&gt; A5
end

A5 --&gt; R1

subgraph PATH[&#34;Routers — 전송 경로&#34;]
  R1{다음 홉 MTU ≥ 패킷?}
  R1 -- 예 --&gt; R2[포워딩]
  R1 -- 아니오 --&gt; R3{IPv4 &amp; DF=0?}
  R3 -- 예 --&gt; R4[IPv4 단편화 수행]
  R3 -- 아니오 --&gt; R5[ICMP Frag Needed / ICMPv6 PTB]
end

R2 --&gt; B1
R4 --&gt; B1

R5 --&gt; A2a[&#34;송신자: 크기 축소\n(MSS/레코드/PLPMTUD)&#34;]
A2a --&gt; A3

subgraph HOST_B[&#34;Host B — 역캡슐화/재조립&#34;]
  B1[L2 해제]
  B2[IPv4/IPv6 재조립]
  B3[TCP/UDP 전달]
  B4[TLS/앱 인도]
  B1 --&gt; B2 --&gt; B3 --&gt; B4
end
</pre><p>주: 캡슐화 (Host A, 송신) → 전송 경로 (Routers) → 역캡슐화 (Host B, 수신)</p><h5 id=mtu어디서-어떻게-적용되나>MTU—어디서, 어떻게 적용되나<a hidden class=anchor aria-hidden=true href=#mtu어디서-어떻게-적용되나>#</a></h5><h6 id=송신-호스트-host-aip-계층-egress-경로에서-mtu-적용>송신 호스트 (Host A)—<strong>IP 계층 Egress 경로에서 MTU 적용</strong><a hidden class=anchor aria-hidden=true href=#송신-호스트-host-aip-계층-egress-경로에서-mtu-적용>#</a></h6><ul><li><strong>주체</strong>: OS 커널의 IP 출력 경로 (IPv4/IPv6) + 라우팅/디바이스 MTU 테이블.</li><li><strong>어디서</strong>:<ol><li>라우팅 결정 (다음 홉/출구 인터페이스 선택) →</li><li><strong>출구 인터페이스의 IP MTU</strong>(또는 경로 MTU 캐시) 에 맞춰 <strong>IP 패킷 크기 검사</strong> →</li><li>초과하면: IPv4 는 DF=0 이면 자체 단편화, DF=1 이면 전송 금지/ICMP 의존. IPv6 은 <strong>라우터 단편화 금지</strong>이므로 <strong>자체 크기 축소 또는 (필요시) 송신자 단편화 헤더</strong>만 가능.</li></ol></li><li><strong>어떻게</strong>: 커널은 <code>dst_entry</code>/<code>route</code> 의 PMTU(경로 MTU) 캐시를 참조하고, GSO/TSO 가 켜져 있어도 <strong>온와이어 기준</strong>으로 MTU 를 지킨다 (오프로딩은 NIC 가 패킷을 쪼개 보냄).</li><li><strong>실무 포인트</strong>:<ul><li>Linux: <code>ip link show dev &lt;if></code>, <code>ip route get &lt;dst></code> 로 dev/route MTU 확인, <code>ip route change … mtu &lt;n></code> 가능.</li><li>PMTU 캐시는 ICMP(Frag Needed/PTB) 나 PLPMTUD 로 갱신된다.</li></ul></li></ul><h6 id=중간-라우터-routers출구-인터페이스에서-다음-홉-mtu-검사>중간 라우터 (Routers)—<strong>출구 인터페이스에서 다음 홉 MTU 검사</strong><a hidden class=anchor aria-hidden=true href=#중간-라우터-routers출구-인터페이스에서-다음-홉-mtu-검사>#</a></h6><ul><li><strong>주체</strong>: 라우터의 포워딩 평면 (하드웨어/소프트웨어) + egress 인터페이스 MTU.</li><li><strong>어디서</strong>: 라우팅 후 <strong>egress MTU 비교</strong>에서 패킷 크기>MTU 면 분기:<ul><li><strong>IPv4</strong>: DF=0 이면 <strong>라우터가 단편화</strong> 수행 (Identification/Fragment Offset/MF 조정). DF=1 이면 <strong>드롭 + ICMP Type3 Code4(Frag Needed)</strong> 전송.</li><li><strong>IPv6</strong>: <strong>항상 드롭 + ICMPv6 PTB(Type 2)</strong> 전송 (라우터 단편화 금지).</li></ul></li><li><strong>터널/오버레이</strong>: VXLAN/GRE/IPsec 같은 <strong>캡슐화 (ingress)</strong> 장비는 <strong>외부 헤더를 얹기 전</strong> 내부 패킷 + 외부 헤더 합계가 <strong>외부 링크 MTU</strong>를 넘지 않게 <strong>내부 MTU 를 낮춰야</strong> 한다 (장비가 내부 DF 취급을 따로 함). [RF:2,3,4]</li></ul><h6 id=수신-호스트-host-bip-계층-ingress-에서-재조립검사>수신 호스트 (Host B)—<strong>IP 계층 Ingress 에서 재조립/검사</strong><a hidden class=anchor aria-hidden=true href=#수신-호스트-host-bip-계층-ingress-에서-재조립검사>#</a></h6><ul><li><strong>주체</strong>: OS 커널의 IP 입력 경로 (IPv4 조각 재조립, IPv6 조각 재조립).</li><li><strong>어디서</strong>: 조각화된 IPv4/IPv6 패킷을 <strong>IP 계층에서 재조립</strong>한 뒤 L4(UDP/TCP) 로 전달. MTU 는 수신 시 강제 적용 대상이 아니며, 이미 경로에서 맞춰진다.</li></ul><h5 id=mss-협상어디서-어떻게-결정강제되나>MSS 협상—어디서, 어떻게 결정·강제되나<a hidden class=anchor aria-hidden=true href=#mss-협상어디서-어떻게-결정강제되나>#</a></h5><h6 id=송신수신-호스트tcp-3-way-handshake-에서-결정>송신/수신 호스트—<strong>TCP 3-way Handshake 에서 결정</strong><a hidden class=anchor aria-hidden=true href=#송신수신-호스트tcp-3-way-handshake-에서-결정>#</a></h6><ul><li><strong>주체</strong>: 양 끝단 <strong>TCP 스택</strong>.</li><li><strong>어디서</strong>: SYN/SYN-ACK 교환 시 <strong>TCP 옵션의 MSS 값</strong>을 서로 광고 → **더 작은 값 (min)**을 채택.</li><li><strong>어떻게</strong>: 채택된 MSS 를 기준으로 **세그먼트화 (송신 측 TCP)**가 이뤄진다. 이후 PMTU 가 줄면 커널이 세그먼트 크기를 더 줄인다 (PLPMTUD/PMTUD 반영).</li><li><strong>실무 포인트</strong>:<ul><li>Linux: <code>net.ipv4.tcp_mtu_probing=2</code>(PLPMTUD 항상), <code>tcp_base_mss</code>, <code>tcp_min_snd_mss</code> 로 하한 설정.</li><li>캡처로 SYN 옵션의 <code>MSS</code> 값 확인 (중간 장비 개입 여부 점검).</li></ul></li></ul><h6 id=중간-장비-라우터방화벽로드밸런서mss-클램핑>중간 장비 (라우터/방화벽/로드밸런서)—<strong>MSS 클램핑</strong><a hidden class=anchor aria-hidden=true href=#중간-장비-라우터방화벽로드밸런서mss-클램핑>#</a></h6><ul><li><strong>주체</strong>: L3/L4 장비의 <strong>정책 엔진</strong>.</li><li><strong>어디서</strong>: <strong>경계 구간</strong>에서 TCP SYN 패킷의 MSS 옵션 값을 <strong>강제로 낮춤</strong>(예: <code>--clamp-mss-to-pmtu</code> 혹은 고정값).</li><li><strong>어떻게</strong>: 이후 전 구간에서 <strong>더 작은 MSS</strong>로 세그먼트가 생성되어 <strong>단편화/블랙홀 사전 예방</strong>. 터널/VPN 환경 필수 관행.</li></ul><blockquote><p>요지: MSS 는 **TCP 세그먼트화 단계 (호스트 TCP)**에서 적용되고, <strong>중간 장비는 SYN 의 MSS 를 수정</strong>해 경로 제약을 강제한다.</p></blockquote><h5 id=단편화-fragmentation어디서-어떻게-발생해결되나>단편화 (Fragmentation)—어디서, 어떻게 발생·해결되나<a hidden class=anchor aria-hidden=true href=#단편화-fragmentation어디서-어떻게-발생해결되나>#</a></h5><h6 id=ipv4>IPv4<a hidden class=anchor aria-hidden=true href=#ipv4>#</a></h6><ul><li><strong>송신 호스트</strong>: DF=0 이면 <strong>자체 단편화 가능</strong>(IP 출력 경로). DF=1 이면 <strong>단편화 금지</strong> → 크기 축소 필요 (=MSS/레코드 사이즈 조정, PMTUD/PLPMTUD).</li><li><strong>중간 라우터</strong>: DF=0 & MTU 초과 시 <strong>라우터가 단편화</strong> 수행 (egress 에서). DF=1 이면 <strong>드롭 + ICMP Frag Needed</strong>.</li><li><strong>수신 호스트</strong>: <strong>재조립은 항상 수신 호스트</strong> IP 계층에서 수행.</li><li><strong>부작용</strong>: 조각 손실=전체 폐기, 방화벽/NAT 필터링 곤란 (중간 조각에 L4 포트 없음), CPU/버퍼 비용↑ → <strong>가능하면 회피</strong>.</li></ul><h6 id=ipv6>IPv6<a hidden class=anchor aria-hidden=true href=#ipv6>#</a></h6><ul><li><strong>송신 호스트만 단편화 가능</strong>: <strong>Fragment Extension Header</strong>를 송신자가 붙일 수 있으나, 권장 경로는 <strong>PTB 수신 → 크기 축소</strong>.</li><li><strong>라우터 단편화 금지</strong>: MTU 초과 시 <strong>항상 PTB</strong>로 통지.</li><li><strong>수신 호스트</strong>: <strong>재조립</strong> 수행.</li><li><strong>최소 MTU 1280B</strong>: 설계 시 안전 하한.</li></ul><blockquote><p>요지: 단편화는 <strong>IPv4 에서는 (송신/라우터) 둘 다</strong>, <strong>IPv6 에서는 송신자만</strong>. 운영상 <strong>회피가 원칙</strong>이며 PMTUD/PLPMTUD·MSS 로 사전 예방한다.</p></blockquote><h4 id=터널보안오프로딩과의-상호작용>터널·보안·오프로딩과의 상호작용<a hidden class=anchor aria-hidden=true href=#터널보안오프로딩과의-상호작용>#</a></h4><ul><li><strong>캡슐화 (From, 터널 ingress)</strong>: VXLAN/GRE/IPsec ESP 등 <strong>외부 헤더 추가 직전</strong>에 <strong>내부 MTU 를 낮춰</strong>야 외부 링크 MTU 를 넘지 않는다 (장비/OS 의 <strong>터널 인터페이스 MTU</strong> 설정이 핵심).</li><li><strong>전송 경로 (Routers)</strong>: 터널 <strong>외부 패킷</strong>이 egress MTU 를 넘으면 <strong>외부 패킷이 드롭/단편화</strong>된다 (특히 IPv4). PPTB/Frag Needed 신호가 <strong>내부 송신자까지 전달되지 못하면 블랙홀</strong>이 되므로 ICMP 정책과 터널의 PTB 처리 로직이 중요.</li><li><strong>역캡슐화 (To, 터널 egress)</strong>: 외부 헤더를 제거하고 <strong>내부 패킷을 원형대로</strong> 내보낸다. 이때 내부 패킷은 이미 <strong>작게 설계</strong>되어 있어야 한다.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: <strong>세그먼트화는 호스트 TCP</strong>, MTU 준수는 <strong>온와이어에서 NIC/드라이버</strong>가 보장. <strong>호스트 캡처는 &rsquo; 큰 가상 세그먼트 &rsquo; 로 보일 수 있어</strong> 경계 캡처와 교차 검증 필요.</li></ul><h4 id=주체지점동작>주체·지점·동작<a hidden class=anchor aria-hidden=true href=#주체지점동작>#</a></h4><table><thead><tr><th>항목</th><th>주체/지점</th><th>동작 요약</th><th>관찰 포인트</th></tr></thead><tbody><tr><td><strong>MTU 결정</strong></td><td>NIC/링크, 터널 인터페이스, 라우팅 엔트리</td><td>인터페이스 MTU 와 경로 최소값 (<strong>PMTUD/PLPMTUD</strong>) 으로 <strong>Path MTU</strong> 확정</td><td><code>tracepath</code>, ICMP PTB/FragNeeded 로그, <code>ip route get</code></td></tr><tr><td><strong>단편화 (IPv4)</strong></td><td><strong>라우터 (DF=0)</strong> 또는 <strong>송신 호스트</strong></td><td>중간/엔드에서 단편 생성 → 수신 호스트 재조립</td><td>IPv4 ID/Offset/MF, 재조립 드롭률</td></tr><tr><td><strong>단편화 (IPv6)</strong></td><td><strong>송신 호스트만</strong></td><td>Frag EH 로 분할, 라우터 단편화 금지</td><td>ICMPv6 PTB, EH 존재 시 장비 호환성</td></tr><tr><td><strong>MSS 협상</strong></td><td><strong>엔드포인트 TCP 스택</strong></td><td>SYN/SYN‑ACK 에서 min(MSS) 채택</td><td>캡처로 MSS 값, <code>tcp_base_mss</code>/<code>tcp_mtu_probing</code></td></tr><tr><td><strong>MSS 클램핑</strong></td><td><strong>경계 라우터/방화벽</strong></td><td>SYN 의 MSS 옵션을 <strong>강제 축소</strong></td><td><code>--clamp-mss-to-pmtu</code> 정책·룰 히트 카운터</td></tr></tbody></table><blockquote><p>해설: MTU/단편화는 <strong>IP 계층</strong>, MSS 는 <strong>TCP 계층</strong>의 일로서, 결정 지점이 다르다. 터널/오버레이가 끼면 <strong>외부 MTU</strong>에 맞춰 <strong>내부 MTU 하향 + 클램핑</strong>을 세트로 적용해야 블랙홀을 방지한다.</p></blockquote><h4 id=ip-mtu-기준-대표-조합-1500-기준>IP MTU 기준 대표 조합 (1500 기준)<a hidden class=anchor aria-hidden=true href=#ip-mtu-기준-대표-조합-1500-기준>#</a></h4><table><thead><tr><th>조합</th><th style=text-align:right>헤더 합계 (최소)</th><th style=text-align:right>최대 L7</th></tr></thead><tbody><tr><td>IPv4(20)+TCP(20)</td><td style=text-align:right>40B</td><td style=text-align:right>1460B</td></tr><tr><td>IPv6(40)+TCP(20)</td><td style=text-align:right>60B</td><td style=text-align:right>1440B</td></tr><tr><td>IPv4(20)+UDP(8)</td><td style=text-align:right>28B</td><td style=text-align:right>1472B</td></tr><tr><td>IPv6(40)+UDP(8)</td><td style=text-align:right>48B</td><td style=text-align:right>1452B</td></tr><tr><td>(TCP 조합)+TLS1.3(5+~16)</td><td style=text-align:right>+21B</td><td style=text-align:right>해당 TCP 행 −21B</td></tr><tr><td>점보 9001 + IPv6/TCP: 60B → 8941B. 옵션/오버레이·IPsec 등 가산 필요. [RF:8,9,10]</td><td style=text-align:right></td><td style=text-align:right></td></tr></tbody></table><h4 id=pmtudplpmtudmss-의사결정-송신-측-중심>PMTUD/PLPMTUD·MSS 의사결정 (송신 측 중심)<a hidden class=anchor aria-hidden=true href=#pmtudplpmtudmss-의사결정-송신-측-중심>#</a></h4><pre class=mermaid>flowchart TD
%% title: pmtud-plpmtud-mss-decision
S[송신 시작] --&gt; P{ICMP 신뢰 가능?}
P -- 예 --&gt; P1[&#34;PMTUD 사용\n(DF=1)&#34;]
P -- 아니오 --&gt; P2[&#34;PLPMTUD 사용\n(ACK/Probe 기반)&#34;]
P1 --&gt; C[&#34;MSS= min(양단 MSS, PMTU-헤더)&#34;]
P2 --&gt; C
C --&gt; T{터널/보안/옵션 추가?}
T -- 예 --&gt; T1[헤더 가산→내부 MTU/MSS 재계산]
T -- 아니오 --&gt; D[전송]
</pre><ul><li><strong>권장 조합</strong>: PMTUD(+ICMP 정책 정합) <strong>우선</strong>, 경로 불확실/차단 환경은 <strong>PLPMTUD 병행</strong> + <strong>MSS 클램핑</strong>.</li></ul><h2 id=웹-브라우징에서의-pdu-흐름>웹 브라우징에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#웹-브라우징에서의-pdu-흐름>#</a></h2><p>브라우저 URL 입력 후 <strong>이름 해석 (DNS/DoH/DoT) → 연결 수립 (HTTP/2 over TCP/TLS 1.3 또는 HTTP/3 over QUIC/UDP/TLS 1.3) → 요청/응답 → 리소스 병렬 로딩</strong>으로 진행되며, 상위 **SDU(Service Data Unit)**가 하위 <strong>PDU</strong>로 캡슐화되어 이동한다.<br>대표 PDU 는 <strong>DNS 메시지, TLS 레코드, QUIC 패킷, TCP 세그먼트, IP 패킷, L2 프레임</strong>이다.<br>HTTP/3 는 <strong>HTTP/3 를 QUIC 위에 매핑</strong>하고, HTTP/2 는 <strong>TCP 위에 HTTP/2 프레이밍</strong>을 둔다.</p><ul><li><strong>HTTP/3(하이퍼텍스트 전송 프로토콜 버전 3)</strong>: <strong>QUIC(Quick UDP Internet Connections)</strong> 위에서 HTTP 의미론을 운반. 스트림 단위 멀티플렉싱·흐름제어·저지연 수립을 QUIC 이 제공.</li><li><strong>HTTP/2</strong>: 단일 TCP 연결 내부에서 <strong>프레임 단위 멀티플렉싱 (헤더 압축 포함)</strong> 제공.</li><li><strong>DNS-over-HTTPS(DoH)</strong>/<strong>DNS-over-TLS(DoT)</strong>: 평문 DNS 를 각각 <strong>HTTPS</strong>/<strong>TLS</strong>로 감싸 전송.</li></ul><h3 id=단계별-캡슐화역캡슐화-요청응답>단계별 캡슐화·역캡슐화 (요청→응답)<a hidden class=anchor aria-hidden=true href=#단계별-캡슐화역캡슐화-요청응답>#</a></h3><ol><li><strong>이름 해석</strong><ul><li>전통 <strong>DNS(Domain Name System)</strong>: 일반적으로 <strong>UDP 포트 53</strong>, 필요 시 <strong>TCP</strong>로 폴백. (EDNS0 확장으로 UDP 응답 확장 가능—여기서는 개요만)</li><li><strong>DoH/DoT</strong>: DNS 메시지를 각각 <strong>HTTP/2·HTTP/3</strong> 또는 <strong>TLS</strong>로 보호해 전송 (암호화·인증 경로 확보).</li></ul></li><li><strong>연결 수립</strong><ul><li><strong>HTTP/3 over QUIC/UDP/TLS 1.3</strong>: <strong>QUIC 초기 (Initial) 패킷은 최소 1200 바이트</strong>로 전송해야 하며, TLS 1.3 핸드셰이크는 <strong>QUIC 의 CRYPTO/핸드셰이크 프레임</strong>으로 진행된다 (0-RTT/1-RTT 모드).</li><li><strong>HTTP/2 over TCP/TLS 1.3</strong>: <strong>TCP 3-way 핸드셰이크</strong>(MSS 협상) 후 <strong>TLS 1.3 핸드셰이크 (1-RTT)</strong>, 그 위에서 <strong>HTTP/2 프레임</strong> 교환.</li></ul></li><li><strong>요청/응답 교환</strong><ul><li><strong>HTTP/3</strong>: L7 요청/응답이 <strong>HTTP/3 프레임 → QUIC 패킷 → UDP 데이터그램 → IP → L2</strong>로. 스트림 독립 재전송·혼잡제어는 QUIC 담당.</li><li><strong>HTTP/2</strong>: L7 프레임이 <strong>TLS 레코드 → TCP 세그먼트 → IP → L2</strong>로. 손실 복구·혼잡제어는 TCP 담당.</li></ul></li><li><strong>리소스 병렬 로딩</strong><ul><li><strong>HTTP/3/HTTP/2</strong> 모두 단일 연결 (혹은 소수 연결) 에서 스트림/프레임 멀티플렉싱으로 CSS/JS/이미지를 병렬 전송.</li></ul></li></ol><p><strong>웹 브라우저에서 <code>https://example.com</code> 을 입력했을 때 일어나는 모든 과정</strong></p><pre class=mermaid>flowchart TD
    Start[브라우저에 URL 입력&lt;br/&gt;https\:\/\/example.com]
    
    DNS[DNS 조회&lt;br/&gt;도메인 → IP 주소]
    TCP[TCP 3-Way Handshake&lt;br/&gt;연결 설정]
    TLS[TLS 1.3 Handshake&lt;br/&gt;보안 채널 설정]
    HTTP[HTTP 요청/응답&lt;br/&gt;HTML, CSS, JS 다운로드]
    Render[브라우저 렌더링&lt;br/&gt;화면 표시]
    
    Start --&gt; DNS
    DNS --&gt; TCP
    TCP --&gt; TLS
    TLS --&gt; HTTP
    HTTP --&gt; Render
    
    style DNS fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style TCP fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style TLS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style HTTP fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style Render fill:#fce4ec,stroke:#c2185b,stroke-width:2px
</pre><h4 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h4><h5 id=캡슐화-과정-송신-하향>캡슐화 과정 (송신, 하향)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-송신-하향>#</a></h5><ol><li><strong>애플리케이션</strong> → DNS 쿼리, TCP SYN, TLS 핸드셰이크, HTTP 요청 생성</li><li><strong>전송 계층</strong> → UDP(DNS) 또는 TCP(웹) 헤더 추가 (8-60 B)</li><li><strong>네트워크 계층</strong> → IP 헤더 추가 (20-40 B), 라우팅 정보</li><li><strong>데이터링크</strong> → 이더넷 헤더 (14 B) + FCS(4 B) 추가</li><li><strong>물리 계층</strong> → 전기/광 신호로 변환, 네트워크 전송</li></ol><h5 id=역캡슐화-과정-수신-상향>역캡슐화 과정 (수신, 상향)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-수신-상향>#</a></h5><ol><li><strong>물리 계층</strong> → 신호 수신, 디지털 변환</li><li><strong>데이터링크</strong> → MAC 확인, FCS 검증, 헤더 제거</li><li><strong>네트워크 계층</strong> → 목적지 IP 확인, 헤더 제거</li><li><strong>전송 계층</strong> → 포트 확인, 재조립, 흐름 제어</li><li><strong>애플리케이션</strong> → TLS 복호화, HTTP 처리, 브라우저 렌더링</li></ol><h3 id=관찰-지점별로-실제-보이는-pdu>관찰 지점별로 실제 보이는 PDU<a hidden class=anchor aria-hidden=true href=#관찰-지점별로-실제-보이는-pdu>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3 경로에서 보이는 것</th><th>HTTP/2 경로에서 보이는 것</th><th>비고</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td><strong>HTTP/3 프레임 ↔ QUIC 패킷</strong> (TLS 1.3 내장)</td><td><strong>HTTP/2 프레임 ↔ TLS 레코드 ↔ TCP 세그먼트</strong></td><td>엔드포인트에서만 상위 구조 완전 관찰 가능.</td></tr><tr><td>L3(라우터/방화벽)</td><td><strong>IP 패킷 (UDP/IPv4·IPv6)</strong></td><td><strong>IP 패킷 (TCP/IPv4·IPv6)</strong></td><td>ECN/DSCP, PMTUD/PTB 이벤트 관찰.</td></tr><tr><td>L2(스위치/AP)</td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>온와이어 MTU 와만 상호작용 (상위 페이로드는 불투명).</td></tr></tbody></table><h3 id=mtumss단편화웹-특화-검증-포인트>MTU·MSS·단편화—웹 특화 검증 포인트<a hidden class=anchor aria-hidden=true href=#mtumss단편화웹-특화-검증-포인트>#</a></h3><ul><li>**MTU(Maximum Transmission Unit)**와 <strong>Path MTU</strong>: 경로의 <strong>최소소값</strong>이 상한을 결정. IPv4 는 <strong>ICMP &ldquo;Fragmentation Needed&rdquo;</strong>(RFC 1191) 로, IPv6 는 <strong>ICMPv6 &ldquo;Packet Too Big&rdquo;</strong>(RFC 8201) 로 송신자에게 축소를 알린다.</li><li><strong>PLPMTUD(Packetization Layer PMTUD)</strong>: ICMP 의존 없이 전송/애플리케이션 계층에서 <strong>증분 크기 탐색</strong>으로 안전 크기를 학습 (TCP/QUIC 에 적용).</li><li><strong>MSS(Maximum Segment Size) 협상</strong>: <strong>TCP SYN/SYN-ACK</strong>에서 양단이 알린 값의 <strong>최솟값</strong> 사용 (이후 PMTUD/PLPMTUD 에 의해 더 줄어들 수 있음). (표준은 TCP/IP 일반 규정·HTTP/2 사양 맥락에서 간접 확인)</li><li><strong>TLS 1.3 레코드 오버헤드</strong>: <strong>TLS 레코드 헤더 5 바이트</strong> + 선택된 <strong>AEAD(Authenticated Encryption with Associated Data) 태그</strong>(일반적으로 16 바이트: AES-GCM/ChaCha20-Poly1305). 레코드 크기를 <strong>MSS/Path MTU</strong>에 맞춰 쪼개야 불필요한 IP 단편화나 PMTUD 블랙홀을 예방.</li><li><strong>QUIC 초기 패킷 최소 크기 1200 바이트</strong>: 경로 검증·증폭 공격 완화 목적. 무선/터널 경로의 작은 Path MTU 와 충돌 시 <strong>PLPMTUD</strong> 정책이 중요.</li></ul><h3 id=http2-vs-http3pdu-관점의-차이>HTTP/2 Vs HTTP/3—PDU 관점의 차이<a hidden class=anchor aria-hidden=true href=#http2-vs-http3pdu-관점의-차이>#</a></h3><ul><li><strong>HTTP/2(TCP/TLS 1.3)</strong>: 전송 PDU 는 <strong>TCP 세그먼트</strong>, 보안 PDU 는 <strong>TLS 레코드</strong>. 위험 신호는 <strong>PMTUD 블랙홀</strong>(큰 객체가 특정 지점에서 멈춤) 로 나타나며 <strong>ICMP 허용 + PLPMTUD + MSS 클램핑</strong>으로 완화.</li><li><strong>HTTP/3(QUIC/UDP/TLS 1.3)</strong>: 전송 PDU 는 <strong>QUIC 패킷</strong>. 스트림별 재전송·혼잡제어로 <strong>HOL(Head-of-Line) 블로킹</strong>을 줄이고, <strong>0-RTT/1-RTT</strong> 수립을 지원. 초기 패킷은 1200 바이트 이상으로 <strong>Path MTU/방화벽 정책</strong>과의 상호작용을 반드시 점검.</li></ul><h4 id=http2tcp-웹-페이지-로딩의-pdu-흐름>HTTP/2(TCP) 웹 페이지 로딩의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#http2tcp-웹-페이지-로딩의-pdu-흐름>#</a></h4><pre class=mermaid>sequenceDiagram
%% title: web-h2-pdu
participant U as User Agent (Browser)
participant R as DNS/DoH Resolver
participant S as Web Server (H2)
U-&gt;&gt;R: DNS/DoH 질의 (DNS msg / HTTPS)
R--&gt;&gt;U: A/AAAA
U-&gt;&gt;S: TCP SYN [MSS]
S--&gt;&gt;U: SYN-ACK [MSS]
U-&gt;&gt;S: ACK  (연결 성립)
U--&gt;&gt;S: TLS1.3 ClientHello (TLS Record)
S--&gt;&gt;U: TLS1.3 ServerHello… (TLS Records)
U-&gt;&gt;S: GET / (HTTP/2 frames)
S--&gt;&gt;U: HTML/CSS/JS (HTTP/2 frames → TLS records → TCP segments)
Note over U,S: L7(HTTP/2) → TLS Record → TCP Segment → IP → L2
</pre><p>HTTP/2 는 <strong>TLS 레코드</strong>가 상위 PDU, <strong>TCP 세그먼트</strong>가 전송 PDU 다. <strong>MSS 협상</strong>과 <strong>PMTUD/PLPMTUD</strong>에 따라 세그먼트 크기가 결정되고, 손실 시 TCP 재전송이 수행된다.</p><h4 id=http3quic-웹-페이지-로딩의-pdu-흐름>HTTP/3(QUIC) 웹 페이지 로딩의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#http3quic-웹-페이지-로딩의-pdu-흐름>#</a></h4><pre class=mermaid>sequenceDiagram
%% title: web-h3-pdu
participant U as User Agent (Browser)
participant R as DNS/DoH Resolver
participant S as Web Server (H3)
U-&gt;&gt;R: DNS/DoH 질의 (DNS msg / HTTPS)
R--&gt;&gt;U: A/AAAA(또는 Alt-Svc)
U-&gt;&gt;S: QUIC Initial (TLS CH)  ~1200B
S--&gt;&gt;U: QUIC Initial (TLS SH/EE)
U-&gt;&gt;S: GET / (HTTP/3 frames)
S--&gt;&gt;U: HTML/CSS/JS (H3 frames → QUIC packets)
Note over U,S: L7(HTTP/3) → QUIC frame → QUIC packet → UDP → IP → L2
</pre><p>HTTP/3 은 <strong>QUIC 패킷</strong>이 전송 PDU 이고, 그 안에 <strong>HTTP/3 프레임</strong>과 <strong>TLS 핸드셰이크</strong>가 들어간다. 손실 시 QUIC 이 스트림 단위로 재전송/복구하며, 멀티플렉싱으로 HOL 지연을 줄인다.</p><h3 id=단계계층별-sdupdu-매핑>단계/계층별 SDU→PDU 매핑<a hidden class=anchor aria-hidden=true href=#단계계층별-sdupdu-매핑>#</a></h3><table><thead><tr><th>단계</th><th>상위 SDU(의미단위)</th><th>하위 전송 PDU</th><th>보안/제어 PDU</th><th>핵심 주의</th></tr></thead><tbody><tr><td>이름 해석</td><td>DNS 질의·응답</td><td><strong>UDP 데이터그램 / TCP 세그먼트</strong></td><td>(DoH) <strong>HTTP 요청/응답</strong>, (DoT) <strong>TLS 레코드</strong></td><td>크기↑ 시 TCP 폴백, DoH/DoT 는 암호화 경로 제공.</td></tr><tr><td>연결 수립 (H2)</td><td>TLS 핸드셰이크 메시지</td><td><strong>TCP 세그먼트</strong></td><td><strong>TLS 레코드 (1-RTT)</strong></td><td>MSS 협상 후 레코드 분할.</td></tr><tr><td>연결 수립 (H3)</td><td>TLS 핸드셰이크 메시지</td><td><strong>QUIC 패킷 (UDP)</strong></td><td><strong>QUIC 핸드셰이크/CRYPTO 프레임</strong></td><td><strong>초기 패킷 ≥1200B</strong>.</td></tr><tr><td>요청/응답 (H2)</td><td>HTTP/2 프레임</td><td><strong>TCP 세그먼트</strong></td><td><strong>TLS 레코드</strong></td><td>PMTUD/PLPMTUD 로 단편화 회피.</td></tr><tr><td>요청/응답 (H3)</td><td>HTTP/3 프레임</td><td><strong>QUIC 패킷 (UDP)</strong></td><td>(내장) TLS 1.3</td><td>스트림별 복구/혼잡제어.</td></tr></tbody></table><h3 id=관찰-지점별-pdu-맵-웹-브라우징>관찰 지점별 PDU 맵 (웹 브라우징)<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵-웹-브라우징>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3(QUIC/UDP) 보이는 PDU</th><th>HTTP/2(TCP) 보이는 PDU</th><th>DNS/DoH/DoT</th><th>관측 포인트</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td>H3 프레임 ↔ <strong>QUIC 패킷</strong></td><td>H2 프레임 ↔ <strong>TLS 레코드/TCP 세그먼트</strong></td><td><strong>DNS 메시지/TLS/HTTPS</strong></td><td>엔드 텔레메트리·브라우저 네트워크 패널</td></tr><tr><td>L3 장비 (라우터/방화벽)</td><td><strong>IP 패킷 (UDP/IPv6 가능)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP/TCP)</strong></td><td>ECN/DSCP, PTB/FragNeeded</td></tr><tr><td>L2(스위치/AP)</td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>MTU/무선 MAC 오버헤드</td></tr></tbody></table><h3 id=mtumss단편화웹-특화-포인트>MTU·MSS·단편화—웹 특화 포인트<a hidden class=anchor aria-hidden=true href=#mtumss단편화웹-특화-포인트>#</a></h3><ul><li><strong>MTU 기준</strong>: <code>Max L7 ≈ IP MTU − (IP + L4 + 보안/옵션/오버레이)</code>. H3 는 <strong>QUIC+UDP+AEAD</strong>, H2 는 <strong>TLS+TCP</strong> 오버헤드가 반영된다. 터널/VPN/모바일 경로는 추가 차감.</li><li><strong>MSS 협상 (H2)</strong>: 3-way 에서 min(MSS) 이 정해지고, 이후 PMTUD/PLPMTUD 로 더 줄어들 수 있다. <strong>클램핑</strong>으로 블랙홀 예방.</li><li><strong>단편화 회피</strong>: IPv4 DF=1, IPv6 라우터 단편화 금지. PMTUD/PLPMTUD 실패 시 대용량 객체에서 멈춤 현상 → MTU 하향/레코드 크기 축소.</li></ul><h4 id=mtu-별-전송-효율-비교>MTU 별 전송 효율 비교<a hidden class=anchor aria-hidden=true href=#mtu-별-전송-효율-비교>#</a></h4><table><thead><tr><th style=text-align:right>MTU</th><th style=text-align:right>TCP MSS</th><th style=text-align:right>HTTP 요청 (500 B)</th><th style=text-align:right>HTML 응답 (50 KB)</th><th style=text-align:right>총 세그먼트 수</th></tr></thead><tbody><tr><td style=text-align:right>1500</td><td style=text-align:right>1460</td><td style=text-align:right>1 개 (500 &lt; 1460)</td><td style=text-align:right>35 개 (50000÷1460)</td><td style=text-align:right>36 개</td></tr><tr><td style=text-align:right>1400</td><td style=text-align:right>1360</td><td style=text-align:right>1 개</td><td style=text-align:right>37 개 (50000÷1360)</td><td style=text-align:right>38 개</td></tr><tr><td style=text-align:right>1280</td><td style=text-align:right>1240</td><td style=text-align:right>1 개</td><td style=text-align:right>41 개 (50000÷1240)</td><td style=text-align:right>42 개</td></tr><tr><td style=text-align:right>576</td><td style=text-align:right>536</td><td style=text-align:right>1 개</td><td style=text-align:right>94 개 (50000÷536)</td><td style=text-align:right>95 개</td></tr></tbody></table><p><strong>오버헤드 비교</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MTU 1500:
</span></span><span class=line><span class=cl>- 세그먼트당 오버헤드: 54 B (IP 20 + TCP 20 + 이더넷 14)
</span></span><span class=line><span class=cl>- 총 오버헤드: 54 × 36 = 1944 B
</span></span><span class=line><span class=cl>- 효율: 50000 / (50000 + 1944) = 96.3%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>MTU 576 (최소):
</span></span><span class=line><span class=cl>- 세그먼트당 오버헤드: 54 B
</span></span><span class=line><span class=cl>- 총 오버헤드: 54 × 95 = 5130 B
</span></span><span class=line><span class=cl>- 효율: 50000 / (50000 + 5130) = 90.7%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>결론: 큰 MTU = 높은 효율
</span></span></code></pre></td></tr></table></div></div><h4 id=path-mtu-문제-시나리오>Path MTU 문제 시나리오<a hidden class=anchor aria-hidden=true href=#path-mtu-문제-시나리오>#</a></h4><pre class=mermaid>sequenceDiagram
    participant C as 클라이언트&lt;br/&gt;(MTU 1500)
    participant R as 라우터&lt;br/&gt;(MTU 1400)
    participant S as 서버&lt;br/&gt;(MTU 1500)
    
    Note over C,S: TCP 연결 성립 (MSS=1460)
    
    C-&gt;&gt;R: TCP 세그먼트 (1460 B 데이터)
    Note over R: MTU 1400 초과!&lt;br/&gt;DF=1 설정됨
    R-&gt;&gt;C: ICMP PTB (Next MTU=1400)
    
    Note over C: Path MTU 업데이트&lt;br/&gt;MSS 1360으로 조정
    
    C-&gt;&gt;R: TCP 세그먼트 (1360 B 데이터)
    R-&gt;&gt;S: 전달 성공
    S-&gt;&gt;R: TCP ACK
    R-&gt;&gt;C: ACK 전달
    
    Note over C,S: 이후 1360 B로 계속 전송
</pre><h4 id=tls-레코드-크기와-mtu>TLS 레코드 크기와 MTU<a hidden class=anchor aria-hidden=true href=#tls-레코드-크기와-mtu>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>TLS 레코드 최대 크기: 16 KB (RFC 8446)
</span></span><span class=line><span class=cl>실제 권장 크기: MTU 고려하여 설정
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>예시:
</span></span><span class=line><span class=cl>Path MTU = 1400
</span></span><span class=line><span class=cl>→ MSS = 1400 - 20(IP) - 20(TCP) = 1360 B
</span></span><span class=line><span class=cl>→ TLS 레코드 크기 = 1360 - 5(레코드 헤더) - 16(AEAD 태그) = 1339 B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>큰 HTTP 응답:
</span></span><span class=line><span class=cl>→ TLS가 자동으로 여러 레코드로 분할
</span></span><span class=line><span class=cl>→ 각 레코드는 MSS 이하로 유지
</span></span><span class=line><span class=cl>→ TCP 세그먼트 단편화 방지
</span></span></code></pre></td></tr></table></div></div><h2 id=실시간-동영상-스트리밍에서의-pdu-흐름>실시간 동영상 스트리밍에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#실시간-동영상-스트리밍에서의-pdu-흐름>#</a></h2><p>라이브/실시간 스트리밍의 일반 경로는 **캡처·인코딩 (Producer) → 인제스트 (Origin) → 패키징 (CMAF/HLS/DASH) → CDN 전송 (Edge) → 플레이어 (Client)**이다.<br>각 홉에서 상위 **SDU(Service Data Unit)**가 하위 계층의 **PDU(Protocol Data Unit)**로 <strong>캡슐화/역캡슐화</strong>되며, 사용 스택에 따라 PDU 이름·오버헤드·복구전략·지연 특성이 달라진다.</p><p><strong>라이브 영상은 L7 미디어 청크가 선택한 전송 스택 (HTTP/3/QUIC 또는 HTTP/2/TCP, 또는 SRTP) 에 따라 서로 다른 PDU(QUIC 패킷·TLS 레코드·TCP 세그먼트·RTP 패킷) 로 포장되어 IP/L2 위를 흐르고, MTU·손실·혼잡 제약 속에서 재전송·적응·버퍼링으로 품질을 유지한다.</strong></p><h3 id=대표-전송-스택>대표 전송 스택<a hidden class=anchor aria-hidden=true href=#대표-전송-스택>#</a></h3><table><thead><tr><th>구분</th><th>계층별 전송 경로</th><th>전송 단위 예시</th><th>보안 계층</th><th>손실/복구 방식</th><th>HOL(Head-of-Line) 블로킹</th><th>특이점</th></tr></thead><tbody><tr><td>LL-HLS/LL-DASH over HTTP/3(QUIC)</td><td>L7 오브젝트 (CMAF 청크) → HTTP/3 프레임 → QUIC 패킷 (가변 길이 +AEAD) → UDP 데이터그램 → IP 패킷 → L2 프레임</td><td>CMAF 청크 (초저지연, 작은 단위)</td><td>TLS 1.3 (QUIC 내장)</td><td>QUIC 재전송, 개별 스트림별 ACK Ranges (국지 복구, stream 단위)</td><td>없음 (QUIC 이 예방)</td><td>초저지연, 모바일 환경 최적화, 연결 이주 지원</td></tr><tr><td>HLS/DASH over HTTP/2(TCP)</td><td>L7 오브젝트 → HTTP/2 프레임 → TLS 레코드 → TCP 세그먼트 → IP 패킷 → L2 프레임</td><td>미디어 세그먼트</td><td>TLS 1.3</td><td>TCP 재전송 전체 연결 기준, 흐름제어</td><td>존재 (연결 단위 HOL)</td><td>기존 CDN 친화, 상대적으로 지연 크다</td></tr><tr><td>WebRTC(SRTP/UDP+DTLS+SCTP)</td><td>RTP 패킷 → SRTP → UDP 데이터그램 → IP 패킷 → L2 프레임 (데이터채널: SCTP→DTLS→UDP 등)</td><td>RTP 패킷 (오디오/비디오 Frame)</td><td>DTLS, SRTP</td><td>실시간 NACK/PLI/FIR 등 (어플리케이션 계층 복구)</td><td>없음 (단방향 패킷 손실은 허용)</td><td>실시간, 양방향 상호작용, 아주 낮은 지연</td></tr></tbody></table><h3 id=단계별-캡슐화역캡슐화>단계별 캡슐화·역캡슐화<a hidden class=anchor aria-hidden=true href=#단계별-캡슐화역캡슐화>#</a></h3><ol><li><p><strong>Producer → Origin(인제스트)</strong></p><ul><li><em>L7 SDU</em>: H.264/H.265/AV1 <strong>프레임/슬라이스</strong></li><li><em>전송 예</em>: <strong>RTMP(Real-Time Messaging Protocol)/TCP</strong>, <strong>SRT(Secure Reliable Transport)/UDP</strong>, <strong>WebRTC(SRTP/UDP)</strong></li><li><em>PDU</em>: RTMP 메시지↔<strong>TCP 세그먼트</strong> / SRT 패킷↔<strong>UDP 데이터그램</strong></li></ul></li><li><p><strong>Origin(패키징) → CDN Edge</strong></p><ul><li><em>L7 SDU</em>: <strong>CMAF(fMP4) 청크</strong>, HLS 세그먼트/파트, DASH 세그먼트, 매니페스트 (playlist/MPD)</li><li><em>PDU</em>: (A) <strong>HTTP/3 프레임 → QUIC 패킷 → UDP → IP → L2</strong> / (B) <strong>HTTP/2 프레임 → TLS 레코드 → TCP 세그먼트 → IP → L2</strong></li></ul></li><li><p><strong>Edge → Player(클라이언트)</strong></p><ul><li>매니페스트 갱신 → 파트/세그먼트 <strong>프리페치/우선순위</strong> 요청</li><li>역캡슐화: <strong>L2 → L3(IP) → L4(UDP/TCP) → (QUIC/TLS 해제) → L7 컨테이너 (fMP4) 파싱 → 디코더</strong></li></ul></li></ol><h4 id=요약-1>요약<a hidden class=anchor aria-hidden=true href=#요약-1>#</a></h4><h5 id=pdu-캡슐화-송신>PDU 캡슐화 (송신)<a hidden class=anchor aria-hidden=true href=#pdu-캡슐화-송신>#</a></h5><ol><li><strong>L7</strong>: 영상 데이터 → RTP 메시지 (1212 B)</li><li><strong>L4</strong>: UDP 헤더 추가 → 데이터그램 (1220 B)</li><li><strong>L3</strong>: IP 헤더 추가 → 패킷 (1240 B)</li><li><strong>L2</strong>: 이더넷 헤더 +FCS → 프레임 (1258 B)</li><li><strong>L1</strong>: 디지털 → 전기 신호 → 전송</li></ol><h5 id=pdu-역캡슐화-수신>PDU 역캡슐화 (수신)<a hidden class=anchor aria-hidden=true href=#pdu-역캡슐화-수신>#</a></h5><ol><li><strong>L1</strong>: 전기 신호 → 디지털 비트</li><li><strong>L2</strong>: 프레임 검증 → 헤더 제거 (1240 B)</li><li><strong>L3</strong>: IP 확인 → 헤더 제거 (1220 B)</li><li><strong>L4</strong>: UDP 확인 → 헤더 제거 (1212 B)</li><li><strong>L7</strong>: RTP 재조립 → 디코딩 → 화면 표시</li></ol><h5 id=각-계층의-역할>각 계층의 역할<a hidden class=anchor aria-hidden=true href=#각-계층의-역할>#</a></h5><ul><li><strong>L7</strong>: 비디오 인코딩/디코딩, 패킷화/재조립</li><li><strong>L4</strong>: 포트 기반 애플리케이션 식별</li><li><strong>L3</strong>: IP 주소 기반 라우팅</li><li><strong>L2</strong>: MAC 주소 기반 로컬 전달, 오류 검출</li><li><strong>L1</strong>: 물리적 신호 전송</li></ul><h3 id=관찰-지점별-pdu-맵>관찰 지점별 PDU 맵<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3(QUIC/UDP) 보이는 PDU</th><th>HTTP/2(TCP) 보이는 PDU</th><th>WebRTC(SRTP/UDP) 보이는 PDU</th><th>핵심 포인트</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td><strong>QUIC 패킷 / H3 프레임</strong></td><td><strong>TLS 레코드 / TCP 세그먼트</strong></td><td><strong>RTP/SRTP/DTLS/RTCP 패킷</strong></td><td>암호화로 중간 가시성↓, 엔드 텔레메트리 중요</td></tr><tr><td>라우터/방화벽 (L3)</td><td><strong>IP 패킷 (UDP)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP)</strong></td><td><strong>ECN(Explicit Congestion Notification)/DSCP</strong> 및 <strong>PMTUD(Path MTU Discovery)/PLPMTUD(Packetization-Layer PMTUD)</strong> 영향</td></tr><tr><td>스위치/무선 AP(L2)</td><td><strong>이더넷/802.11 프레임</strong></td><td>동일</td><td>동일</td><td>무선 MAC 오버헤드, 점보/패딩, 오프로딩 주의</td></tr></tbody></table><h3 id=시퀀스라이브-세그먼트-전달-http3-예시>시퀀스—라이브 세그먼트 전달 (HTTP/3 예시)<a hidden class=anchor aria-hidden=true href=#시퀀스라이브-세그먼트-전달-http3-예시>#</a></h3><pre class=mermaid>sequenceDiagram
%% title: live-h3-pdu
participant P as Player(Client)
participant E as CDN Edge
participant O as Origin
P-&gt;&gt;E: GET /playlist.m3u8 (HTTP/3)
E--&gt;&gt;P: playlist (QUIC packets)
P-&gt;&gt;E: GET /seg_101_part_1.m4s (HTTP/3)
E--&gt;&gt;P: part_1 (CMAF chunk in QUIC)
E-&gt;&gt;O: cache miss → fetch chunk (HTTP/3)
O--&gt;&gt;E: chunk (HTTP/3/QUIC)
Note over P,E: L7 chunk → H3 frame → QUIC packet → UDP → IP → L2
</pre><hr><h3 id=webrtc-경로-핵심-초저지연상호작용>WebRTC 경로 핵심 (초저지연·상호작용)<a hidden class=anchor aria-hidden=true href=#webrtc-경로-핵심-초저지연상호작용>#</a></h3><ul><li>**ICE(Interactive Connectivity Establishment)**가 **STUN(Session Traversal Utilities for NAT)/TURN(Traversal Using Relays around NAT)**으로 경로를 찾고, <strong>DTLS</strong>로 키 교환 후 <strong>SRTP</strong>로 미디어 보호.</li><li>수신 품질 피드백은 <strong>RTCP</strong>의 <strong>NACK(Negative Acknowledgement)/PLI(Picture Loss Indication)/FIR(Full Intra Request)</strong>.</li><li>손실 복구: <strong>RTX(RTP Retransmission)</strong>, <strong>FEC(Forward Error Correction)</strong>, <strong>SVC(Scalable Video Coding)</strong> 조합.</li></ul><pre class=mermaid>sequenceDiagram
%% title: webrtc-pdu
participant Pub as Publisher
participant SFU as SFU(Selective Forwarding Unit)
participant Sub as Subscriber(Player)
Pub-&gt;&gt;SFU: DTLS handshake (over UDP)
SFU--&gt;&gt;Pub: DTLS complete
Pub-&gt;&gt;SFU: SRTP media (RTP protected)
Sub--&gt;&gt;SFU: RTCP RR/NACK/PLI
SFU--&gt;&gt;Sub: SRTP media (forwarded)
Note over Pub,Sub: RTP → SRTP → UDP → IP → L2
</pre><h3 id=mtumss단편화스트리밍-맥락>MTU/MSS/단편화—스트리밍 맥락<a hidden class=anchor aria-hidden=true href=#mtumss단편화스트리밍-맥락>#</a></h3><ul><li><strong>IPv6 최소 MTU = 1280 바이트</strong>, <strong>QUIC Initial ≥ ≈1200 바이트</strong>: 초기 QUIC 핸드셰이크는 큰 패킷을 요구하므로, <strong>터널/VPN(예: VXLAN, IPsec)</strong> 오버헤드를 뺀 <strong>Path MTU</strong> 기준으로 <strong>UDP 페이로드 상한</strong>을 계산해야 합니다.</li><li><strong>MSS(Maximum Segment Size) 협상 (TCP)</strong>: SYN/SYN-ACK 에서 <strong>min(MSS)</strong> 채택 → 이후 <strong>PMTUD/PLPMTUD</strong>로 추가 축소 가능. 방화벽/경계에서 <strong>MSS 클램핑</strong>은 블랙홀 예방책.</li><li><strong>단편화 (Fragmentation) 회피</strong>가 원칙: IPv4 는 DF=0 에서 라우터 단편화 가능하지만 지양, <strong>IPv6 라우터 단편화 금지</strong>(송신자만 분할). 실패 시 <strong>ICMP PTB(Packet Too Big)/Frag Needed</strong>로 축소 유도.</li></ul><h4 id=mtu-와-pdu-의-관계>MTU 와 PDU 의 관계<a hidden class=anchor aria-hidden=true href=#mtu-와-pdu-의-관계>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MTU 1500 B = L3 패킷 최대 크기
</span></span><span class=line><span class=cl>→ L4 데이터 최대 = 1500 - 20(IP) = 1480 B
</span></span><span class=line><span class=cl>→ L7 메시지 최대 = 1480 - 8(UDP) = 1472 B
</span></span><span class=line><span class=cl>→ RTP 페이로드 최대 = 1472 - 12(RTP) = 1460 B
</span></span><span class=line><span class=cl>→ 실전 권장 = 1200 B (안전 마진)
</span></span></code></pre></td></tr></table></div></div><p>이 과정을 통해 영상 데이터는 송신자에서 수신자까지 각 계층의 PDU 로 변환되며 전달된다.</p><h3 id=손실혼잡-시-복구-비교-요점>손실·혼잡 시 복구 비교 (요점)<a hidden class=anchor aria-hidden=true href=#손실혼잡-시-복구-비교-요점>#</a></h3><table><thead><tr><th>스택</th><th>전송 PDU</th><th>복구 방식</th><th>HOL(Head-of-Line) 영향</th><th>비고</th></tr></thead><tbody><tr><td>HTTP/3(QUIC/UDP/TLS 1.3)</td><td><strong>QUIC 패킷</strong></td><td><strong>ACK Ranges</strong>, 손실 패킷만 재전송</td><td>스트림 독립 → HOL 완화</td><td>초기 패킷 ≥≈1200B 요구</td></tr><tr><td>HTTP/2(TCP/TLS 1.3)</td><td><strong>TCP 세그먼트</strong></td><td>빠른 재전송/타임아웃 기반</td><td>연결 단위 HOL</td><td>손실이 전 스트림 지연으로 전파</td></tr><tr><td>WebRTC(SRTP/UDP)</td><td><strong>RTP/SRTP 패킷</strong></td><td><strong>NACK/RTX</strong>, <strong>FEC</strong>, <strong>SVC</strong></td><td>애플리케이션 전략</td><td>초저지연은 ARQ 최소화</td></tr></tbody></table><h3 id=지연-예산-end-to-end-latency-budget-전형-가이드>지연 예산 (End-to-End Latency Budget, 전형 가이드)<a hidden class=anchor aria-hidden=true href=#지연-예산-end-to-end-latency-budget-전형-가이드>#</a></h3><table><thead><tr><th>단계</th><th>주체/지점</th><th>전형 범위</th><th>주의 포인트</th></tr></thead><tbody><tr><td>캡처/인코딩</td><td>카메라/인코더</td><td>5–60 ms</td><td>B- 프레임/긴 GOP 는 지연↑</td></tr><tr><td>인제스트</td><td>퍼블리셔→오리진</td><td>5–30 ms(RTT 의존)</td><td>RTMP(TCP) 는 재전송/혼잡 영향</td></tr><tr><td>패키징</td><td>오리진</td><td>≈0–30 ms</td><td>**CMAF 파트 길이 (200–500 ms)**가 LL 지연 바닥</td></tr><tr><td>CDN 전송</td><td>오리진↔엣지</td><td>1–20 ms</td><td>캐시 HIT/MISS 차이</td></tr><tr><td>플레이어 네트워크</td><td>엣지↔단말</td><td>10–150 ms</td><td><strong>ECN/AQM</strong>, 무선 변동성</td></tr><tr><td>지터 버퍼</td><td>플레이어</td><td>50–300 ms</td><td>손실/변동↑ → 버퍼↑</td></tr><tr><td>디코딩/렌더</td><td>단말</td><td>8–40 ms</td><td>HW 디코더/디스플레이 동기</td></tr></tbody></table><p><strong>전형 합계</strong>: WebRTC ≈ <strong>100–300 ms</strong>, LL-HLS/LL-DASH ≈ <strong>0.5–3 s</strong>, 전통 HLS/DASH(2–6 s 세그먼트) ≈ <strong>3–30 s</strong>.</p><h3 id=품질지연-최적화-체크리스트-수신자운영자-관점>품질·지연 최적화 체크리스트 (수신자/운영자 관점)<a hidden class=anchor aria-hidden=true href=#품질지연-최적화-체크리스트-수신자운영자-관점>#</a></h3><ul><li><strong>ABR(Adaptive Bitrate)</strong>: 목표 버퍼 (예: 2–6 s), 다운스위치 임계값을 <strong>RTT/손실률</strong>과 정합.</li><li><strong>ECN/DSCP(Differentiated Services Code Point)</strong>: 경로 지원 시 활성화, **AQM(Active Queue Management)**와 조합.</li><li><strong>QUIC 튜닝</strong>: 패킷 페이싱, 초기 윈도, 재전송 타이머, ACK 배송 정책 조정.</li><li><strong>Wi-Fi/5G</strong>: 변동 MTU/지연/손실 → <strong>작은 파트</strong>, 다중 연결/도메인 (shard) 병렬화.</li><li><strong>ICMP 정책</strong>: <strong>PTB/Frag Needed</strong> 허용 (레이트리밋), <strong>PLPMTUD</strong> 병행.</li><li><strong>오버헤드/터널</strong>: 터널 인터페이스 <strong>MTU 하향 + 내부 MSS 클램핑</strong> 동시 적용.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: 성능↑/가시성↓ → 경계 캡처로 온와이어 재검증.</li></ul><h4 id=부록-간단-산식-메모>(부록) 간단 산식 메모<a hidden class=anchor aria-hidden=true href=#부록-간단-산식-메모>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Max</span> <span class=n>L7</span> <span class=n>payload</span> <span class=err>≈</span> <span class=ne>Path</span> <span class=n>MTU</span> <span class=err>−</span> <span class=p>(</span><span class=ne>IP</span> <span class=err>헤더</span> <span class=o>+</span> <span class=n>L4</span> <span class=err>헤더</span> <span class=o>+</span> <span class=err>보안</span><span class=o>/</span><span class=err>옵션</span><span class=o>/</span><span class=err>오버레이</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>예</span><span class=p>:</span> <span class=n>IPv6</span><span class=o>/</span><span class=n>TCP</span> <span class=o>+</span> <span class=n>TLS1</span><span class=o>.</span><span class=mi>3</span> <span class=err>@</span> <span class=n>MTU</span> <span class=mi>1500</span> <span class=err>→</span> <span class=mi>1500</span> <span class=err>−</span> <span class=p>(</span><span class=mi>40</span> <span class=o>+</span> <span class=mi>20</span> <span class=o>+</span> <span class=o>~</span><span class=mi>21</span><span class=p>)</span> <span class=err>≈</span> <span class=mi>1419</span> <span class=n>B</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=pdu-크기-변화-요약>PDU 크기 변화 요약<a hidden class=anchor aria-hidden=true href=#pdu-크기-변화-요약>#</a></h3><pre class=mermaid>graph LR
    A[&#34;L7 메시지&lt;br/&gt;1212 B&#34;] 
    B[&#34;L4 데이터그램&lt;br/&gt;1220 B&lt;br/&gt;(+8)&#34;]
    C[&#34;L3 패킷&lt;br/&gt;1240 B&lt;br/&gt;(+20)&#34;]
    D[&#34;L2 프레임&lt;br/&gt;1258 B&lt;br/&gt;(+18)&#34;]
    E[&#34;L1 비트&lt;br/&gt;10064 bits&#34;]
    
    A --&gt;|UDP 캡슐화| B
    B --&gt;|IP 캡슐화| C
    C --&gt;|이더넷 캡슐화| D
    D --&gt;|물리 인코딩| E
    
    E -.-&gt;|물리 디코딩| D
    D -.-&gt;|이더넷 역캡슐화| C
    C -.-&gt;|IP 역캡슐화| B
    B -.-&gt;|UDP 역캡슐화| A
    
    style A fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style B fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style C fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style D fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style E fill:#fce4ec,stroke:#c2185b,stroke-width:2px
</pre><h4 id=캡슐화-과정-송신>캡슐화 과정 (송신)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-송신>#</a></h4><table><thead><tr><th>단계</th><th>PDU 이름</th><th style=text-align:right>크기</th><th>추가된 헤더</th><th>누적 오버헤드</th></tr></thead><tbody><tr><td>L7</td><td>RTP 메시지</td><td style=text-align:right>1212 B</td><td>-</td><td>0 B</td></tr><tr><td>L4</td><td>UDP 데이터그램</td><td style=text-align:right>1220 B</td><td>UDP(8)</td><td>8 B</td></tr><tr><td>L3</td><td>IP 패킷</td><td style=text-align:right>1240 B</td><td>IPv4(20)</td><td>28 B</td></tr><tr><td>L2</td><td>이더넷 프레임</td><td style=text-align:right>1258 B</td><td>Eth(14)+FCS(4)</td><td>46 B</td></tr><tr><td>L1</td><td>비트 스트림</td><td style=text-align:right>10064 bits</td><td>-</td><td>-</td></tr></tbody></table><p><strong>오버헤드 비율</strong>: 46 B / 1212 B = <strong>3.8%</strong></p><h4 id=역캡슐화-과정-수신>역캡슐화 과정 (수신)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-수신>#</a></h4><table><thead><tr><th>단계</th><th>PDU 이름</th><th style=text-align:right>크기</th><th>제거된 헤더</th><th>남은 데이터</th></tr></thead><tbody><tr><td>L1</td><td>비트 스트림</td><td style=text-align:right>10064 bits</td><td>-</td><td>1258 B</td></tr><tr><td>L2</td><td>이더넷 프레임</td><td style=text-align:right>1258 B</td><td>Eth(14)+FCS(4)</td><td>1240 B</td></tr><tr><td>L3</td><td>IP 패킷</td><td style=text-align:right>1240 B</td><td>IPv4(20)</td><td>1220 B</td></tr><tr><td>L4</td><td>UDP 데이터그램</td><td style=text-align:right>1220 B</td><td>UDP(8)</td><td>1212 B</td></tr><tr><td>L7</td><td>RTP 메시지</td><td style=text-align:right>1212 B</td><td>RTP(12)</td><td>1200 B</td></tr></tbody></table><h3 id=실전-예시-한-프레임의-전체-여정>실전 예시: 한 프레임의 전체 여정<a hidden class=anchor aria-hidden=true href=#실전-예시-한-프레임의-전체-여정>#</a></h3><h4 id=송신-측-타임라인>송신 측 타임라인<a hidden class=anchor aria-hidden=true href=#송신-측-타임라인>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1> 1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2> 2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3> 3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4> 4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5> 5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6> 6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7> 7</a>
</span><span class=lnt id=hl-26-8><a class=lnlinks href=#hl-26-8> 8</a>
</span><span class=lnt id=hl-26-9><a class=lnlinks href=#hl-26-9> 9</a>
</span><span class=lnt id=hl-26-10><a class=lnlinks href=#hl-26-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=0ms    : 카메라에서 원본 프레임 캡처 (1920×1080)
</span></span><span class=line><span class=cl>T=5ms    : H.264 인코딩 완료 (8 KB 압축)
</span></span><span class=line><span class=cl>T=6ms    : RTP 패킷화 (7개 패킷으로 분할)
</span></span><span class=line><span class=cl>T=7ms    : 첫 번째 RTP 패킷 전송 시작
</span></span><span class=line><span class=cl>           └─ L4 캡슐화 (UDP 헤더 추가)
</span></span><span class=line><span class=cl>           └─ L3 캡슐화 (IP 헤더 추가)
</span></span><span class=line><span class=cl>           └─ L2 캡슐화 (이더넷 프레임화)
</span></span><span class=line><span class=cl>           └─ L1 전송 (NIC로 전기 신호 송출)
</span></span><span class=line><span class=cl>T=8ms    : 두 번째 RTP 패킷 전송...
</span></span><span class=line><span class=cl>T=13ms   : 일곱 번째 RTP 패킷 전송 완료
</span></span></code></pre></td></tr></table></div></div><h4 id=네트워크-전송>네트워크 전송<a hidden class=anchor aria-hidden=true href=#네트워크-전송>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4>4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=14ms   : 패킷들이 네트워크를 통해 전파
</span></span><span class=line><span class=cl>           - 라우터 1 통과 (1 ms)
</span></span><span class=line><span class=cl>           - 라우터 2 통과 (1 ms)
</span></span><span class=line><span class=cl>           - 인터넷 백본 (20 ms)
</span></span><span class=line><span class=cl>           - ISP 라우터 (2 ms)
</span></span></code></pre></td></tr></table></div></div><h4 id=수신-측-타임라인>수신 측 타임라인<a hidden class=anchor aria-hidden=true href=#수신-측-타임라인>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1> 1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2> 2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3> 3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4> 4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5> 5</a>
</span><span class=lnt id=hl-28-6><a class=lnlinks href=#hl-28-6> 6</a>
</span><span class=lnt id=hl-28-7><a class=lnlinks href=#hl-28-7> 7</a>
</span><span class=lnt id=hl-28-8><a class=lnlinks href=#hl-28-8> 8</a>
</span><span class=lnt id=hl-28-9><a class=lnlinks href=#hl-28-9> 9</a>
</span><span class=lnt id=hl-28-10><a class=lnlinks href=#hl-28-10>10</a>
</span><span class=lnt id=hl-28-11><a class=lnlinks href=#hl-28-11>11</a>
</span><span class=lnt id=hl-28-12><a class=lnlinks href=#hl-28-12>12</a>
</span><span class=lnt id=hl-28-13><a class=lnlinks href=#hl-28-13>13</a>
</span><span class=lnt id=hl-28-14><a class=lnlinks href=#hl-28-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=38ms   : 첫 번째 패킷 도착
</span></span><span class=line><span class=cl>           └─ L1 수신 (NIC에서 비트 수신)
</span></span><span class=line><span class=cl>           └─ L2 역캡슐화 (이더넷 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L3 역캡슐화 (IP 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L4 역캡슐화 (UDP 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L7 처리 (RTP 버퍼에 저장)
</span></span><span class=line><span class=cl>T=39ms   : 두 번째 패킷 도착...
</span></span><span class=line><span class=cl>T=40ms   : 세 번째 패킷 손실! (네트워크 혼잡)
</span></span><span class=line><span class=cl>T=41ms   : 네 번째 패킷 도착...
</span></span><span class=line><span class=cl>T=45ms   : 일곱 번째 패킷 도착
</span></span><span class=line><span class=cl>T=46ms   : 손실 패킷 복구 (FEC 또는 재전송)
</span></span><span class=line><span class=cl>T=50ms   : 지터 버퍼에서 프레임 추출
</span></span><span class=line><span class=cl>T=55ms   : H.264 디코딩 완료
</span></span><span class=line><span class=cl>T=60ms   : GPU 렌더링 및 화면 표시
</span></span></code></pre></td></tr></table></div></div><p><strong>총 엔드투엔드 지연</strong>: 60 ms (캡처 → 화면)</p><h2 id=대용량-파일-다운로드에서의-pdu-흐름>대용량 파일 다운로드에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#대용량-파일-다운로드에서의-pdu-흐름>#</a></h2><p><strong>대용량 다운로드</strong>는 애플리케이션의 바이트 스트림이 전송 스택에서 <strong>TLS 1.3 레코드 (Transport Layer Security 1.3 Record) → TCP 세그먼트 (Transmission Control Protocol Segment) 또는 QUIC 패킷 (Quick UDP Internet Connections Packet) → IP 패킷 (Internet Protocol Packet) → L2 프레임</strong> 순으로 <strong>반복 캡슐화</strong>되어 흐르며, 실제 처리량은 **MSS(Maximum Segment Size)·PMTUD(Path MTU Discovery)/PLPMTUD(Packetization-Layer PMTUD)·혼잡 윈도 (cwnd)·수신 윈도 (rwnd/Window Scaling)·재전송 (SACK/ACK Ranges)·오프로딩 (TSO/GSO/GRO)**의 상호작용으로 결정된다.<br>목표는 <strong>단편화 없이 (Path MTU 이내)</strong> 꾸준히 흘려보내는 것이다.</p><h3 id=전체-경로와-단계-송신--경로--수신>전체 경로와 단계 (송신 → 경로 → 수신)<a hidden class=anchor aria-hidden=true href=#전체-경로와-단계-송신--경로--수신>#</a></h3><ol><li><p><strong>서버 (송신)</strong></p><ul><li>L7 SDU(Service Data Unit): 파일 바이트 스트림</li><li><strong>TLS 1.3</strong> 사용 시 수 KB~수십 KB 크기의 <strong>TLS 레코드</strong>로 잘라 암호화 (AEAD: Authenticated Encryption with Associated Data).</li><li>전송 계층이 <strong>MSS</strong>를 기준으로 <strong>TCP 세그먼트</strong>(HTTP/2/1.1) 또는 <strong>QUIC 패킷</strong>(HTTP/3) 으로 분할.</li><li><strong>TSO/GSO</strong>가 켜져 있으면 커널은 큰 청크를 NIC 가 온와이어 <strong>MSS 단위</strong>로 쪼개도록 위임.</li></ul></li><li><p><strong>네트워크 경로 (라우터/방화벽)</strong></p><ul><li>각 홉 egress 에서 <strong>다음 홉 MTU</strong>를 넘는지 판정.</li><li><strong>IPv4</strong>: DF=0 이면 (지양하지만) 라우터 단편화 가능, DF=1 이면 드롭 + <strong>ICMP Frag Needed</strong> 통지.</li><li><strong>IPv6</strong>: 라우터 단편화 금지 → <strong>ICMPv6 Packet Too Big</strong>로 송신자 축소 유도.</li><li>송신자는 <strong>PMTUD/PLPMTUD</strong>로 안전한 크기를 학습.</li></ul></li><li><p><strong>클라이언트 (수신)</strong></p><ul><li>IP 에서 재조립 (필요 시) → L4 로 인도.</li><li>TCP 는 <strong>순서 재정렬·SACK(Selective ACK) 기반 손실 복구·혼잡제어</strong> 수행 / QUIC 은 <strong>ACK Ranges</strong>로 손실 구간만 재전송.</li><li>TLS 복호화 후 <strong>HTTP 바디</strong>를 파일에 기록. <strong>rwnd(Receive Window)</strong> 및 <strong>Window Scaling</strong>이 작으면 BDP(대역폭×지연) 대비 병목.</li></ul></li></ol><h3 id=전송-스택별-pdu-흐름>전송 스택별 PDU 흐름<a hidden class=anchor aria-hidden=true href=#전송-스택별-pdu-흐름>#</a></h3><h4 id=http2tcp--tls-13-기반>HTTP/2(TCP / TLS 1.3) 기반<a hidden class=anchor aria-hidden=true href=#http2tcp--tls-13-기반>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>앱 바이트 → [TLS 레코드] → [TCP 세그먼트(MSS)] → [IP 패킷] → [L2 프레임]
</span></span><span class=line><span class=cl>손실: TCP 빠른재전송/타임아웃, SACK으로 결손 범위만 재전송 (그러나 연결 단위 HOL 영향)
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>sequenceDiagram
%% title: large-download-h2-tcp
participant C as Client
participant N as Network (Routers)
participant S as Server
C-&gt;&gt;S: TCP 3-way (MSS 협상)
S--&gt;&gt;C: TLS1.3 핸드셰이크(Records)
C-&gt;&gt;S: GET /big.iso (HTTP/2)
S--&gt;&gt;C: HTTP/2 DATA (연속) → TLS Records
Note over S,N: TLS 레코드 → TCP 세그먼트(MSS) → IP → L2
loop steady transfer
  S--&gt;&gt;C: [세그먼트 n..n+k]
  C--&gt;&gt;S: ACK/SACK (누락 범위 통지)
end
alt 손실 발생
  N--&gt;&gt;S: (드롭)
  C--&gt;&gt;S: SACK으로 결손 알림
  S--&gt;&gt;C: 손실 세그먼트만 재전송
end
</pre><p><strong>세그먼트 단위</strong>로 흐르고, <strong>cwnd/rwnd</strong>가 충족되면 파이프가 가득 차며, <strong>SACK</strong>이 부분 손실만 신속 복구한다. PMTUD/PLPMTUD 실패 시 특정 크기에서 멈춤 (블랙홀) 이 발생한다.</p><h4 id=http3quic--udp--tls-13-기반>HTTP/3(QUIC / UDP / TLS 1.3) 기반<a hidden class=anchor aria-hidden=true href=#http3quic--udp--tls-13-기반>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>앱 바이트 → [HTTP/3 프레임] → [QUIC 패킷(AEAD)] → [UDP 데이터그램] → [IP] → [L2]
</span></span><span class=line><span class=cl>손실: QUIC이 해당 패킷 번호 범위만 재전송, 스트림 단위로 HOL 완화
</span></span><span class=line><span class=cl>초기: QUIC Initial 패킷은 경로 안전성 위해 ≈1200B 이상(IPv6 1280B 최소 MTU와 호환 고려)
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>sequenceDiagram
%% title: large-download-h3-quic
participant C as Client
participant N as Network (Routers)
participant S as Server
C-&gt;&gt;S: QUIC Initial (~1200B)
S--&gt;&gt;C: QUIC Initial (1-RTT)
C-&gt;&gt;S: GET /big.iso (H3)
loop steady transfer
  S--&gt;&gt;C: H3 DATA frames → QUIC packets
  C--&gt;&gt;S: ACK Ranges (손실 범위 보고)
end
alt 손실 발생
  N--&gt;&gt;S: (드롭)
  S--&gt;&gt;C: 해당 패킷 번호 범위만 재전송 (스트림 HOL 완화)
end
</pre><p>QUIC 은 <strong>사용자 공간 전송 + ACK Ranges</strong>로 빠른 손실 국지화와 스트림 수준 복구가 가능하다. UDP 경로 특성, PTB 수신 및 PLPMTUD 정책이 안정성을 좌우한다.</p><h3 id=캡슐화역캡슐화한-번의-온와이어-예-ipv6tcptls>캡슐화·역캡슐화—한 번의 온와이어 예 (IPv6/TCP/TLS)<a hidden class=anchor aria-hidden=true href=#캡슐화역캡슐화한-번의-온와이어-예-ipv6tcptls>#</a></h3><ul><li>가정: <strong>MTU 1500B</strong>, IPv6(40B) + TCP(20B) + <strong>TLS 1.3 오버헤드 ≈21B</strong></li><li><strong>유효 TCP 페이로드 (=MSS)</strong> ≈ <code>1500 − 40 − 20 − 21 = 1419B</code></li><li>TLS 레코드가 8KB 라면 <strong>MSS 배수</strong>로 나뉘어 여러 세그먼트로 전송됨.</li><li>수신 측은 L2→L3→L4→L7 순으로 <strong>헤더 제거 (역캡슐화)</strong> 후 원본 바이트를 파일에 기록.</li></ul><blockquote><p>포인트: <strong>TLS 레코드 크기</strong>가 MSS 와 정렬되지 않으면 여분 세그먼트/패딩·작은 PDU 가 늘어 효율이 떨어질 수 있습니다.</p></blockquote><h4 id=요약-2>요약<a hidden class=anchor aria-hidden=true href=#요약-2>#</a></h4><h5 id=송신-측-캡슐화-7-단계>송신 측 캡슐화 (7 단계)<a hidden class=anchor aria-hidden=true href=#송신-측-캡슐화-7-단계>#</a></h5><ol><li><strong>TCP 연결 설정</strong> → 3-Way Handshake, MSS 협상</li><li><strong>HTTP 응답 생성</strong> → 헤더 + 파일 데이터</li><li><strong>TLS 암호화</strong> → 16 KB 레코드 단위 (HTTPS)</li><li><strong>TCP 세그먼트화</strong> → MSS 단위 분할 (1460 B)</li><li><strong>흐름/혼잡 제어</strong> → 윈도우, Slow Start, ACK</li><li><strong>IP 캡슐화</strong> → DF=1, PMTUD</li><li><strong>이더넷 프레임화</strong> → MAC, FCS</li></ol><h5 id=수신-측-역캡슐화-9-단계>수신 측 역캡슐화 (9 단계)<a hidden class=anchor aria-hidden=true href=#수신-측-역캡슐화-9-단계>#</a></h5><ol><li><strong>물리 신호 수신</strong> → 디지털 변환</li><li><strong>이더넷 검증</strong> → FCS 체크</li><li><strong>IP 처리</strong> → 목적지 확인</li><li><strong>TCP 재조립</strong> → 시퀀스 순서 보장</li><li><strong>ACK 전송</strong> → 흐름 제어</li><li><strong>TLS 복호화</strong> → 무결성 검증</li><li><strong>HTTP 파싱</strong> → 헤더/바디 분리</li><li><strong>파일 저장</strong> → 디스크 쓰기</li><li><strong>무결성 검증</strong> → MD5/SHA</li></ol><h3 id=mtumss단편화-동작>MTU·MSS·단편화 동작<a hidden class=anchor aria-hidden=true href=#mtumss단편화-동작>#</a></h3><ul><li><strong>MTU(Maximum Transmission Unit, L3 상한)</strong><ul><li>결정 지점: 인터페이스/NIC, 터널 인터페이스, 라우팅 경로 (최솟값이 Path MTU).</li><li>조치: 터널·VPN·오버레이가 있으면 <strong>외부 MTU 대비 내부 MTU 하향</strong> 필수.</li></ul></li><li><strong>MSS(Maximum Segment Size, TCP 데이터 상한)</strong><ul><li>결정 지점: <strong>SYN/SYN-ACK</strong> 옵션에서 <strong>min(MSS)</strong> 채택 (중간장비의 <strong>MSS 클램핑</strong>이 개입 가능).</li><li>운용: PMTUD/PLPMTUD 결과에 맞춰 송신자가 세그먼트/레코드 크기 추가 축소.</li></ul></li><li><strong>단편화 (Fragmentation)</strong><ul><li>원칙: <strong>회피</strong>. IPv4 는 DF=0 에서만 라우터 단편화 가능 (권장 X), IPv6 라우터 단편화 금지 (송신자만 분할).</li><li>실패 신호: <strong>ICMP Frag Needed/Packet Too Big</strong>. 필터링되면 <strong>PLPMTUD</strong>로 대체 학습.</li></ul></li></ul><h3 id=처리량을-좌우하는-6-요소>처리량을 좌우하는 6 요소<a hidden class=anchor aria-hidden=true href=#처리량을-좌우하는-6-요소>#</a></h3><ol><li><strong>cwnd(혼잡 윈도)</strong>: 혼잡제어 상태 (초기 슬로스타트→회피).</li><li><strong>rwnd(수신 윈도/Window Scaling)</strong>: BDP(대역폭×RTT) 에 맞게 충분히 커야 함.</li><li><strong>RTT(Round-Trip Time)</strong>: 지연이 클수록 같은 cwnd 로 덜 전송됨 → <strong>패이싱</strong> 유효.</li><li><strong>손실·재전송</strong>: TCP 는 <strong>SACK</strong>, QUIC 은 <strong>ACK Ranges</strong>로 손실 구간만 신속 복구.</li><li><strong>ECN(Explicit Congestion Notification)/DSCP</strong>: 드롭 없이 혼잡 신호, 클래스별 QoS.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: CPU/PPS 이득 크지만 <strong>캡처 착시</strong> 유발 → 경계 캡처로 교차검증.</li></ol><blockquote><p><strong>BDP 산식</strong>: <code>BDP(bytes) = Bandwidth(bytes/s) × RTT(s)</code> → rwnd·cwnd·버퍼가 <strong>BDP 이상</strong>이어야 라인을 채웁니다.</p></blockquote><h3 id=http-계층-특화-대용량-전송-튜닝>HTTP 계층 특화 (대용량 전송 튜닝)<a hidden class=anchor aria-hidden=true href=#http-계층-특화-대용량-전송-튜닝>#</a></h3><ul><li><strong>Range 요청 + 206 Partial Content</strong>: <strong>중단 지점 재개</strong>(Resume).</li><li><strong>병렬 범위 다운로드</strong>: 벽시계 단축 가능 (여러 TCP/QUIC 흐름) ↔ <strong>cwnd 공정성·서버/경로 부하</strong> 고려.</li><li><strong>캐시/CDN</strong>: 엣지 <strong>HIT</strong>면 경로 짧아지고 손실 위험↓, <strong>MISS</strong>면 <em>Origin↔Edge</em> 구간에도 동일 PDU 파이프라인이 한 번 더 생김.</li><li><strong>TLS 레코드 크기</strong>: 너무 작으면 헤더 비율↑, 너무 크면 손실 시 재전송 비용↑ → 보통 <strong>수 KB~수십 KB</strong> + <strong>MSS 배수 정렬</strong> 권장.</li></ul><h3 id=관찰-지점별-pdu-맵-1>관찰 지점별 PDU 맵<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵-1>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/2(TCP/TLS 1.3) 보이는 PDU</th><th>HTTP/3(QUIC/UDP/TLS 1.3) 보이는 PDU</th><th>공통</th></tr></thead><tbody><tr><td><strong>호스트 소켓 경계</strong></td><td><strong>TLS 레코드 ↔ TCP 세그먼트</strong></td><td><strong>HTTP/3 프레임 ↔ QUIC 패킷</strong></td><td>장기 세션, PDU 다량 생성</td></tr><tr><td><strong>L3 장비 (라우터/방화벽)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP)</strong></td><td>ECN/DSCP, <strong>PTB/FragNeeded</strong> 가시</td></tr><tr><td><strong>L2(스위치/AP)</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>점보/무선 MAC 오버헤드·오프로딩 주의</td></tr></tbody></table><h3 id=tcp-특성이-파일-전송에-미치는-영향>TCP 특성이 파일 전송에 미치는 영향<a hidden class=anchor aria-hidden=true href=#tcp-특성이-파일-전송에-미치는-영향>#</a></h3><h4 id=재전송-메커니즘>재전송 메커니즘<a hidden class=anchor aria-hidden=true href=#재전송-메커니즘>#</a></h4><pre class=mermaid>sequenceDiagram
    participant C as 클라이언트
    participant S as 서버
    
    S-&gt;&gt;C: SEQ=1000, DATA[1460B]
    C-&gt;&gt;S: ACK=2460
    
    S-&gt;&gt;C: SEQ=2460, DATA[1460B]
    Note over C: 패킷 손실!
    
    S-&gt;&gt;C: SEQ=3920, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 1)
    
    S-&gt;&gt;C: SEQ=5380, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 2)
    
    S-&gt;&gt;C: SEQ=6840, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 3)
    
    Note over S: 3 중복 ACK 감지&lt;br/&gt;Fast Retransmit
    
    S-&gt;&gt;C: SEQ=2460, DATA[1460B] (재전송)
    C-&gt;&gt;S: ACK=8300 (누적 ACK)
    
    Note over C,S: 정상 전송 재개
</pre><p><strong>재전송 시나리오 3 가지</strong>:</p><ol><li><strong>Fast Retransmit</strong> (빠른 재전송)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>3개 중복 ACK 수신 → 즉시 재전송
</span></span><span class=line><span class=cl>지연: 매우 낮음 (수 ms)
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>Timeout Retransmit</strong> (타임아웃 재전송)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2>2</a>
</span><span class=lnt id=hl-35-3><a class=lnlinks href=#hl-35-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>RTO (Retransmission Timeout) 초과 → 재전송
</span></span><span class=line><span class=cl>지연: 높음 (수백 ms ~ 초)
</span></span><span class=line><span class=cl>RTO = SRTT + 4 × RTTVAR
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>Selective Acknowledgment (SACK)</strong></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3>3</a>
</span><span class=lnt id=hl-36-4><a class=lnlinks href=#hl-36-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>정확한 손실 범위 통보:
</span></span><span class=line><span class=cl>SACK: 3920-8300 수신 완료
</span></span><span class=line><span class=cl>→ 서버는 2460-3919만 재전송
</span></span><span class=line><span class=cl>→ 효율적 (불필요한 재전송 방지)
</span></span></code></pre></td></tr></table></div></div><h4 id=혼잡-제어의-영향>혼잡 제어의 영향<a hidden class=anchor aria-hidden=true href=#혼잡-제어의-영향>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1> 1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2> 2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3> 3</a>
</span><span class=lnt id=hl-37-4><a class=lnlinks href=#hl-37-4> 4</a>
</span><span class=lnt id=hl-37-5><a class=lnlinks href=#hl-37-5> 5</a>
</span><span class=lnt id=hl-37-6><a class=lnlinks href=#hl-37-6> 6</a>
</span><span class=lnt id=hl-37-7><a class=lnlinks href=#hl-37-7> 7</a>
</span><span class=lnt id=hl-37-8><a class=lnlinks href=#hl-37-8> 8</a>
</span><span class=lnt id=hl-37-9><a class=lnlinks href=#hl-37-9> 9</a>
</span><span class=lnt id=hl-37-10><a class=lnlinks href=#hl-37-10>10</a>
</span><span class=lnt id=hl-37-11><a class=lnlinks href=#hl-37-11>11</a>
</span><span class=lnt id=hl-37-12><a class=lnlinks href=#hl-37-12>12</a>
</span><span class=lnt id=hl-37-13><a class=lnlinks href=#hl-37-13>13</a>
</span><span class=lnt id=hl-37-14><a class=lnlinks href=#hl-37-14>14</a>
</span><span class=lnt id=hl-37-15><a class=lnlinks href=#hl-37-15>15</a>
</span><span class=lnt id=hl-37-16><a class=lnlinks href=#hl-37-16>16</a>
</span><span class=lnt id=hl-37-17><a class=lnlinks href=#hl-37-17>17</a>
</span><span class=lnt id=hl-37-18><a class=lnlinks href=#hl-37-18>18</a>
</span><span class=lnt id=hl-37-19><a class=lnlinks href=#hl-37-19>19</a>
</span><span class=lnt id=hl-37-20><a class=lnlinks href=#hl-37-20>20</a>
</span><span class=lnt id=hl-37-21><a class=lnlinks href=#hl-37-21>21</a>
</span><span class=lnt id=hl-37-22><a class=lnlinks href=#hl-37-22>22</a>
</span><span class=lnt id=hl-37-23><a class=lnlinks href=#hl-37-23>23</a>
</span><span class=lnt id=hl-37-24><a class=lnlinks href=#hl-37-24>24</a>
</span><span class=lnt id=hl-37-25><a class=lnlinks href=#hl-37-25>25</a>
</span><span class=lnt id=hl-37-26><a class=lnlinks href=#hl-37-26>26</a>
</span><span class=lnt id=hl-37-27><a class=lnlinks href=#hl-37-27>27</a>
</span><span class=lnt id=hl-37-28><a class=lnlinks href=#hl-37-28>28</a>
</span><span class=lnt id=hl-37-29><a class=lnlinks href=#hl-37-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>다운로드 속도 변화:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>초기 (Slow Start):
</span></span><span class=line><span class=cl>┌─────────────────┐
</span></span><span class=line><span class=cl>│ 시간(초) │ cwnd    │ 속도(Mbps)  │
</span></span><span class=line><span class=cl>│   0-0.1  │  10 MSS │    1.2           │
</span></span><span class=line><span class=cl>│  0.1-0.2 │  20 MSS │    2.4          │
</span></span><span class=line><span class=cl>│  0.2-0.3 │  40 MSS │    4.8          │
</span></span><span class=line><span class=cl>│  0.3-0.5 │  80 MSS │    9.6          │
</span></span><span class=line><span class=cl>└─────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>혼잡 회피 (Congestion Avoidance):
</span></span><span class=line><span class=cl>┌────────────────┐
</span></span><span class=line><span class=cl>│   0.5-1  │ 160 MSS │   19.2     │
</span></span><span class=line><span class=cl>│    1-2   │ 240 MSS │   28.8      │
</span></span><span class=line><span class=cl>│    2-3   │ 320 MSS │   38.4      │
</span></span><span class=line><span class=cl>│    ...   │   ...   │    ...                   │
</span></span><span class=line><span class=cl>│   10-11  │ 800 MSS │   96.0    │
</span></span><span class=line><span class=cl>└────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>손실 발생 (시간 11초):
</span></span><span class=line><span class=cl>┌────────────────┐
</span></span><span class=line><span class=cl>│    11    │ 800 MSS │   96.0       │
</span></span><span class=line><span class=cl>│  11.001  │ 400 MSS │   48.0 ↓  │
</span></span><span class=line><span class=cl>│  11.1-12 │ 450 MSS │   54.0 ↑  │
</span></span><span class=line><span class=cl>│  12-13   │ 500 MSS │   60.0 ↑   │
</span></span><span class=line><span class=cl>└────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>→ 톱니 모양 속도 변화 (Sawtooth Pattern)
</span></span></code></pre></td></tr></table></div></div><h4 id=mtu-와-mss-의-실전-영향>MTU 와 MSS 의 실전 영향<a hidden class=anchor aria-hidden=true href=#mtu-와-mss-의-실전-영향>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1> 1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2> 2</a>
</span><span class=lnt id=hl-38-3><a class=lnlinks href=#hl-38-3> 3</a>
</span><span class=lnt id=hl-38-4><a class=lnlinks href=#hl-38-4> 4</a>
</span><span class=lnt id=hl-38-5><a class=lnlinks href=#hl-38-5> 5</a>
</span><span class=lnt id=hl-38-6><a class=lnlinks href=#hl-38-6> 6</a>
</span><span class=lnt id=hl-38-7><a class=lnlinks href=#hl-38-7> 7</a>
</span><span class=lnt id=hl-38-8><a class=lnlinks href=#hl-38-8> 8</a>
</span><span class=lnt id=hl-38-9><a class=lnlinks href=#hl-38-9> 9</a>
</span><span class=lnt id=hl-38-10><a class=lnlinks href=#hl-38-10>10</a>
</span><span class=lnt id=hl-38-11><a class=lnlinks href=#hl-38-11>11</a>
</span><span class=lnt id=hl-38-12><a class=lnlinks href=#hl-38-12>12</a>
</span><span class=lnt id=hl-38-13><a class=lnlinks href=#hl-38-13>13</a>
</span><span class=lnt id=hl-38-14><a class=lnlinks href=#hl-38-14>14</a>
</span><span class=lnt id=hl-38-15><a class=lnlinks href=#hl-38-15>15</a>
</span><span class=lnt id=hl-38-16><a class=lnlinks href=#hl-38-16>16</a>
</span><span class=lnt id=hl-38-17><a class=lnlinks href=#hl-38-17>17</a>
</span><span class=lnt id=hl-38-18><a class=lnlinks href=#hl-38-18>18</a>
</span><span class=lnt id=hl-38-19><a class=lnlinks href=#hl-38-19>19</a>
</span><span class=lnt id=hl-38-20><a class=lnlinks href=#hl-38-20>20</a>
</span><span class=lnt id=hl-38-21><a class=lnlinks href=#hl-38-21>21</a>
</span><span class=lnt id=hl-38-22><a class=lnlinks href=#hl-38-22>22</a>
</span><span class=lnt id=hl-38-23><a class=lnlinks href=#hl-38-23>23</a>
</span><span class=lnt id=hl-38-24><a class=lnlinks href=#hl-38-24>24</a>
</span><span class=lnt id=hl-38-25><a class=lnlinks href=#hl-38-25>25</a>
</span><span class=lnt id=hl-38-26><a class=lnlinks href=#hl-38-26>26</a>
</span><span class=lnt id=hl-38-27><a class=lnlinks href=#hl-38-27>27</a>
</span><span class=lnt id=hl-38-28><a class=lnlinks href=#hl-38-28>28</a>
</span><span class=lnt id=hl-38-29><a class=lnlinks href=#hl-38-29>29</a>
</span><span class=lnt id=hl-38-30><a class=lnlinks href=#hl-38-30>30</a>
</span><span class=lnt id=hl-38-31><a class=lnlinks href=#hl-38-31>31</a>
</span><span class=lnt id=hl-38-32><a class=lnlinks href=#hl-38-32>32</a>
</span><span class=lnt id=hl-38-33><a class=lnlinks href=#hl-38-33>33</a>
</span><span class=lnt id=hl-38-34><a class=lnlinks href=#hl-38-34>34</a>
</span><span class=lnt id=hl-38-35><a class=lnlinks href=#hl-38-35>35</a>
</span><span class=lnt id=hl-38-36><a class=lnlinks href=#hl-38-36>36</a>
</span><span class=lnt id=hl-38-37><a class=lnlinks href=#hl-38-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시나리오 1: 표준 환경 (MTU 1500)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 1460 B
</span></span><span class=line><span class=cl>1 GB 파일: 732,064 세그먼트
</span></span><span class=line><span class=cl>평균 RTT: 50 ms
</span></span><span class=line><span class=cl>이론 처리량: 1460 × 8 / 0.05 = 233.6 Kbps (1개 세그먼트/RTT)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 처리량 (윈도우 크기 고려):
</span></span><span class=line><span class=cl>윈도우: 64 KB = 44 세그먼트
</span></span><span class=line><span class=cl>처리량: 44 × 1460 × 8 / 0.05 = 10.3 Mbps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Large Window (256 KB):
</span></span><span class=line><span class=cl>처리량: 176 × 1460 × 8 / 0.05 = 41.2 Mbps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오 2: VPN 환경 (MTU 1400)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 1360 B (40 B 감소)
</span></span><span class=line><span class=cl>1 GB 파일: 786,432 세그먼트 (7.4% 증가)
</span></span><span class=line><span class=cl>오버헤드: 40 B × 786,432 = 30.1 MB (3% 증가)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 영향:
</span></span><span class=line><span class=cl>• 세그먼트 수 증가 → ACK 수 증가
</span></span><span class=line><span class=cl>• CPU 부담 증가 (패킷 처리)
</span></span><span class=line><span class=cl>• 혼잡 제어 영향 (더 많은 패킷 손실 기회)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오 3: 점보 프레임 (MTU 9000)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 8960 B (6.1배 증가)
</span></span><span class=line><span class=cl>1 GB 파일: 119,210 세그먼트 (6.1배 감소)
</span></span><span class=line><span class=cl>오버헤드: 40 B × 119,210 = 4.6 MB (0.4%)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 영향:
</span></span><span class=line><span class=cl>• 세그먼트 수 감소 → ACK 감소
</span></span><span class=line><span class=cl>• CPU 효율 향상
</span></span><span class=line><span class=cl>• 단편화 위험 (경로 MTU 불일치 시 치명적)
</span></span></code></pre></td></tr></table></div></div><h4 id=실전-시나리오>실전 시나리오<a hidden class=anchor aria-hidden=true href=#실전-시나리오>#</a></h4><h5 id=정상-다운로드>정상 다운로드<a hidden class=anchor aria-hidden=true href=#정상-다운로드>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1> 1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2> 2</a>
</span><span class=lnt id=hl-39-3><a class=lnlinks href=#hl-39-3> 3</a>
</span><span class=lnt id=hl-39-4><a class=lnlinks href=#hl-39-4> 4</a>
</span><span class=lnt id=hl-39-5><a class=lnlinks href=#hl-39-5> 5</a>
</span><span class=lnt id=hl-39-6><a class=lnlinks href=#hl-39-6> 6</a>
</span><span class=lnt id=hl-39-7><a class=lnlinks href=#hl-39-7> 7</a>
</span><span class=lnt id=hl-39-8><a class=lnlinks href=#hl-39-8> 8</a>
</span><span class=lnt id=hl-39-9><a class=lnlinks href=#hl-39-9> 9</a>
</span><span class=lnt id=hl-39-10><a class=lnlinks href=#hl-39-10>10</a>
</span><span class=lnt id=hl-39-11><a class=lnlinks href=#hl-39-11>11</a>
</span><span class=lnt id=hl-39-12><a class=lnlinks href=#hl-39-12>12</a>
</span><span class=lnt id=hl-39-13><a class=lnlinks href=#hl-39-13>13</a>
</span><span class=lnt id=hl-39-14><a class=lnlinks href=#hl-39-14>14</a>
</span><span class=lnt id=hl-39-15><a class=lnlinks href=#hl-39-15>15</a>
</span><span class=lnt id=hl-39-16><a class=lnlinks href=#hl-39-16>16</a>
</span><span class=lnt id=hl-39-17><a class=lnlinks href=#hl-39-17>17</a>
</span><span class=lnt id=hl-39-18><a class=lnlinks href=#hl-39-18>18</a>
</span><span class=lnt id=hl-39-19><a class=lnlinks href=#hl-39-19>19</a>
</span><span class=lnt id=hl-39-20><a class=lnlinks href=#hl-39-20>20</a>
</span><span class=lnt id=hl-39-21><a class=lnlinks href=#hl-39-21>21</a>
</span><span class=lnt id=hl-39-22><a class=lnlinks href=#hl-39-22>22</a>
</span><span class=lnt id=hl-39-23><a class=lnlinks href=#hl-39-23>23</a>
</span><span class=lnt id=hl-39-24><a class=lnlinks href=#hl-39-24>24</a>
</span><span class=lnt id=hl-39-25><a class=lnlinks href=#hl-39-25>25</a>
</span><span class=lnt id=hl-39-26><a class=lnlinks href=#hl-39-26>26</a>
</span><span class=lnt id=hl-39-27><a class=lnlinks href=#hl-39-27>27</a>
</span><span class=lnt id=hl-39-28><a class=lnlinks href=#hl-39-28>28</a>
</span><span class=lnt id=hl-39-29><a class=lnlinks href=#hl-39-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>타임라인 (1 GB 파일, 100 Mbps 회선):
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=0ms: TCP 연결 설정 (3-Way Handshake)
</span></span><span class=line><span class=cl>├─ SYN → (RTT/2)
</span></span><span class=line><span class=cl>├─ SYN-ACK ← (RTT/2)
</span></span><span class=line><span class=cl>└─ ACK → (RTT/2)
</span></span><span class=line><span class=cl>총 소요: 1.5 RTT (예: 75 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=75ms: TLS 핸드셰이크 (HTTPS)
</span></span><span class=line><span class=cl>├─ ClientHello →
</span></span><span class=line><span class=cl>├─ ServerHello, Certificate ←
</span></span><span class=line><span class=cl>├─ ClientKeyExchange, Finished →
</span></span><span class=line><span class=cl>└─ Finished ←
</span></span><span class=line><span class=cl>총 소요: 2 RTT (예: 100 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=175ms: HTTP 요청 전송
</span></span><span class=line><span class=cl>└─ GET /video.mp4 HTTP/1.1 →
</span></span><span class=line><span class=cl>소요: 0.5 RTT (예: 25 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=200ms: 데이터 전송 시작
</span></span><span class=line><span class=cl>├─ Slow Start: 0.5초 (10 MSS → 800 MSS)
</span></span><span class=line><span class=cl>├─ 안정 상태: 10초 (100 Mbps 지속)
</span></span><span class=line><span class=cl>└─ 완료: 총 10.7초
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=10.9초: 다운로드 완료
</span></span><span class=line><span class=cl>└─ 파일 검증 (MD5): 0.3초
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>총 소요 시간: 약 11.2초
</span></span><span class=line><span class=cl>실효 처리량: 1 GB / 11.2s = 89.3 MB/s = 714 Mbps
</span></span></code></pre></td></tr></table></div></div><h5 id=패킷-손실-복구>패킷 손실 복구<a hidden class=anchor aria-hidden=true href=#패킷-손실-복구>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1> 1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2> 2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3> 3</a>
</span><span class=lnt id=hl-40-4><a class=lnlinks href=#hl-40-4> 4</a>
</span><span class=lnt id=hl-40-5><a class=lnlinks href=#hl-40-5> 5</a>
</span><span class=lnt id=hl-40-6><a class=lnlinks href=#hl-40-6> 6</a>
</span><span class=lnt id=hl-40-7><a class=lnlinks href=#hl-40-7> 7</a>
</span><span class=lnt id=hl-40-8><a class=lnlinks href=#hl-40-8> 8</a>
</span><span class=lnt id=hl-40-9><a class=lnlinks href=#hl-40-9> 9</a>
</span><span class=lnt id=hl-40-10><a class=lnlinks href=#hl-40-10>10</a>
</span><span class=lnt id=hl-40-11><a class=lnlinks href=#hl-40-11>11</a>
</span><span class=lnt id=hl-40-12><a class=lnlinks href=#hl-40-12>12</a>
</span><span class=lnt id=hl-40-13><a class=lnlinks href=#hl-40-13>13</a>
</span><span class=lnt id=hl-40-14><a class=lnlinks href=#hl-40-14>14</a>
</span><span class=lnt id=hl-40-15><a class=lnlinks href=#hl-40-15>15</a>
</span><span class=lnt id=hl-40-16><a class=lnlinks href=#hl-40-16>16</a>
</span><span class=lnt id=hl-40-17><a class=lnlinks href=#hl-40-17>17</a>
</span><span class=lnt id=hl-40-18><a class=lnlinks href=#hl-40-18>18</a>
</span><span class=lnt id=hl-40-19><a class=lnlinks href=#hl-40-19>19</a>
</span><span class=lnt id=hl-40-20><a class=lnlinks href=#hl-40-20>20</a>
</span><span class=lnt id=hl-40-21><a class=lnlinks href=#hl-40-21>21</a>
</span><span class=lnt id=hl-40-22><a class=lnlinks href=#hl-40-22>22</a>
</span><span class=lnt id=hl-40-23><a class=lnlinks href=#hl-40-23>23</a>
</span><span class=lnt id=hl-40-24><a class=lnlinks href=#hl-40-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시나리오: 1% 패킷 손실률
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=5초: 정상 전송 중 (500 MB 다운로드)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>패킷 손실 발생 (SEQ=367,000,000)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.003초: 3 중복 ACK 수신
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>Fast Retransmit: SEQ=367,000,000 재전송
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.053초: 재전송 완료 (RTT 50 ms)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>혼잡 윈도우 감소: 800 MSS → 400 MSS
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>속도 일시 감소: 100 Mbps → 50 Mbps
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.1초: 회복 시작 (선형 증가)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.5초: 정상 속도 복구 (100 Mbps)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>손실 영향:
</span></span><span class=line><span class=cl>• 지연: 0.5초 추가
</span></span><span class=line><span class=cl>• 속도 저하: 0.4초 동안 50% 감소
</span></span><span class=line><span class=cl>• 총 영향: 약 0.2초 추가 소요
</span></span></code></pre></td></tr></table></div></div><h5 id=mtu-불일치-문제>MTU 불일치 문제<a hidden class=anchor aria-hidden=true href=#mtu-불일치-문제>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1> 1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2> 2</a>
</span><span class=lnt id=hl-41-3><a class=lnlinks href=#hl-41-3> 3</a>
</span><span class=lnt id=hl-41-4><a class=lnlinks href=#hl-41-4> 4</a>
</span><span class=lnt id=hl-41-5><a class=lnlinks href=#hl-41-5> 5</a>
</span><span class=lnt id=hl-41-6><a class=lnlinks href=#hl-41-6> 6</a>
</span><span class=lnt id=hl-41-7><a class=lnlinks href=#hl-41-7> 7</a>
</span><span class=lnt id=hl-41-8><a class=lnlinks href=#hl-41-8> 8</a>
</span><span class=lnt id=hl-41-9><a class=lnlinks href=#hl-41-9> 9</a>
</span><span class=lnt id=hl-41-10><a class=lnlinks href=#hl-41-10>10</a>
</span><span class=lnt id=hl-41-11><a class=lnlinks href=#hl-41-11>11</a>
</span><span class=lnt id=hl-41-12><a class=lnlinks href=#hl-41-12>12</a>
</span><span class=lnt id=hl-41-13><a class=lnlinks href=#hl-41-13>13</a>
</span><span class=lnt id=hl-41-14><a class=lnlinks href=#hl-41-14>14</a>
</span><span class=lnt id=hl-41-15><a class=lnlinks href=#hl-41-15>15</a>
</span><span class=lnt id=hl-41-16><a class=lnlinks href=#hl-41-16>16</a>
</span><span class=lnt id=hl-41-17><a class=lnlinks href=#hl-41-17>17</a>
</span><span class=lnt id=hl-41-18><a class=lnlinks href=#hl-41-18>18</a>
</span><span class=lnt id=hl-41-19><a class=lnlinks href=#hl-41-19>19</a>
</span><span class=lnt id=hl-41-20><a class=lnlinks href=#hl-41-20>20</a>
</span><span class=lnt id=hl-41-21><a class=lnlinks href=#hl-41-21>21</a>
</span><span class=lnt id=hl-41-22><a class=lnlinks href=#hl-41-22>22</a>
</span><span class=lnt id=hl-41-23><a class=lnlinks href=#hl-41-23>23</a>
</span><span class=lnt id=hl-41-24><a class=lnlinks href=#hl-41-24>24</a>
</span><span class=lnt id=hl-41-25><a class=lnlinks href=#hl-41-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상황: 클라이언트 MTU 1500, 중간 경로 MTU 1400
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=0: 연결 설정, MSS=1460 협상
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.2초: 데이터 전송 시작
</span></span><span class=line><span class=cl>├─ IP 패킷 (1500 B) 전송
</span></span><span class=line><span class=cl>└─ 중간 라우터 MTU 1400 초과
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>라우터: ICMP &#34;Fragmentation Needed, MTU=1400&#34;
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.25초: 클라이언트 ICMP 수신
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[PMTUD 조정]
</span></span><span class=line><span class=cl>Path MTU: 1400
</span></span><span class=line><span class=cl>MSS: 1400 - 20(IP) - 20(TCP) = 1360
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.26초: 재전송 (작은 세그먼트)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>이후 정상 전송 (MSS=1360)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>영향 분석:
</span></span><span class=line><span class=cl>• 초기 지연: 0.06초
</span></span><span class=line><span class=cl>• 세그먼트 수 증가: 7.4%
</span></span><span class=line><span class=cl>• 오버헤드 증가: 3%
</span></span><span class=line><span class=cl>• 실효 처리량 감소: 약 5%
</span></span></code></pre></td></tr></table></div></div><h3 id=스트리밍-vs-파일-다운로드-비교>스트리밍 vs. 파일 다운로드 비교<a hidden class=anchor aria-hidden=true href=#스트리밍-vs-파일-다운로드-비교>#</a></h3><p><strong>대용량 파일 다운로드는 TCP 의 신뢰성 메커니즘 (재전송, 순서 보장, 흐름/혼잡 제어) 을 통해 100% 완전성을 보장하며</strong>, MTU/MSS 최적화와 병렬 연결로 처리량을 극대화하되, <strong>실시간 스트리밍과 달리 지연보다 완전성을 우선</strong>하는 트레이드오프를 선택한다.</p><h4 id=핵심-차이점-요약>핵심 차이점 요약<a hidden class=anchor aria-hidden=true href=#핵심-차이점-요약>#</a></h4><table><thead><tr><th>특성</th><th>파일 다운로드 (TCP)</th><th>실시간 스트리밍 (UDP)</th></tr></thead><tbody><tr><td><strong>신뢰성</strong></td><td>100% 보장 (재전송)</td><td>손실 허용 (재전송 없음)</td></tr><tr><td><strong>순서</strong></td><td>엄격 보장</td><td>무시 가능</td></tr><tr><td><strong>지연</strong></td><td>높음 (수백 ms)</td><td>낮음 (&lt; 100 ms)</td></tr><tr><td><strong>버퍼링</strong></td><td>큰 버퍼 (64 KB~)</td><td>작은 지터 버퍼 (50 ms)</td></tr><tr><td><strong>패킷 크기</strong></td><td>MSS 최대 활용 (1460 B)</td><td>작게 유지 (1200 B)</td></tr><tr><td><strong>재전송</strong></td><td>자동 (TCP)</td><td>선택적 (NACK)</td></tr><tr><td><strong>흐름 제어</strong></td><td>윈도우 기반</td><td>없음 (앱 레벨)</td></tr><tr><td><strong>혼잡 제어</strong></td><td>필수 (Cubic 등)</td><td>선택적 (GCC)</td></tr><tr><td><strong>완전성</strong></td><td>100% (체크섬)</td><td>부분 허용 (FEC)</td></tr></tbody></table><h4 id=pdu-구조-비교>PDU 구조 비교<a hidden class=anchor aria-hidden=true href=#pdu-구조-비교>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-42-1><a class=lnlinks href=#hl-42-1> 1</a>
</span><span class=lnt id=hl-42-2><a class=lnlinks href=#hl-42-2> 2</a>
</span><span class=lnt id=hl-42-3><a class=lnlinks href=#hl-42-3> 3</a>
</span><span class=lnt id=hl-42-4><a class=lnlinks href=#hl-42-4> 4</a>
</span><span class=lnt id=hl-42-5><a class=lnlinks href=#hl-42-5> 5</a>
</span><span class=lnt id=hl-42-6><a class=lnlinks href=#hl-42-6> 6</a>
</span><span class=lnt id=hl-42-7><a class=lnlinks href=#hl-42-7> 7</a>
</span><span class=lnt id=hl-42-8><a class=lnlinks href=#hl-42-8> 8</a>
</span><span class=lnt id=hl-42-9><a class=lnlinks href=#hl-42-9> 9</a>
</span><span class=lnt id=hl-42-10><a class=lnlinks href=#hl-42-10>10</a>
</span><span class=lnt id=hl-42-11><a class=lnlinks href=#hl-42-11>11</a>
</span><span class=lnt id=hl-42-12><a class=lnlinks href=#hl-42-12>12</a>
</span><span class=lnt id=hl-42-13><a class=lnlinks href=#hl-42-13>13</a>
</span><span class=lnt id=hl-42-14><a class=lnlinks href=#hl-42-14>14</a>
</span><span class=lnt id=hl-42-15><a class=lnlinks href=#hl-42-15>15</a>
</span><span class=lnt id=hl-42-16><a class=lnlinks href=#hl-42-16>16</a>
</span><span class=lnt id=hl-42-17><a class=lnlinks href=#hl-42-17>17</a>
</span><span class=lnt id=hl-42-18><a class=lnlinks href=#hl-42-18>18</a>
</span><span class=lnt id=hl-42-19><a class=lnlinks href=#hl-42-19>19</a>
</span><span class=lnt id=hl-42-20><a class=lnlinks href=#hl-42-20>20</a>
</span><span class=lnt id=hl-42-21><a class=lnlinks href=#hl-42-21>21</a>
</span><span class=lnt id=hl-42-22><a class=lnlinks href=#hl-42-22>22</a>
</span><span class=lnt id=hl-42-23><a class=lnlinks href=#hl-42-23>23</a>
</span><span class=lnt id=hl-42-24><a class=lnlinks href=#hl-42-24>24</a>
</span><span class=lnt id=hl-42-25><a class=lnlinks href=#hl-42-25>25</a>
</span><span class=lnt id=hl-42-26><a class=lnlinks href=#hl-42-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>파일 다운로드 (TCP):
</span></span><span class=line><span class=cl>┌──────────────────┐
</span></span><span class=line><span class=cl>│ L7: HTTP(200B) + TLS(21B)              │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L4: TCP(20-60B) [순서, ACK, 흐름]    │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L3: IP(20-40B) [DF=1]                       │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L2: Ethernet(18B)                              │
</span></span><span class=line><span class=cl>└──────────────────┘
</span></span><span class=line><span class=cl>총 오버헤드: 259-339 B
</span></span><span class=line><span class=cl>특징: 신뢰성 우선, 오버헤드 높음
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>스트리밍 (UDP/RTP):
</span></span><span class=line><span class=cl>┌──────────────────┐
</span></span><span class=line><span class=cl>│ L7: RTP(12B) [시퀀스, 타임스탬프]     │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L4: UDP(8B) [포트만]                         │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L3: IP(20-40B)                                   │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L2: Ethernet(18B)                              │
</span></span><span class=line><span class=cl>└──────────────────┘
</span></span><span class=line><span class=cl>총 오버헤드: 58-78 B
</span></span><span class=line><span class=cl>특징: 저지연 우선, 오버헤드 낮음
</span></span></code></pre></td></tr></table></div></div><h4 id=네트워크-동작-비교>네트워크 동작 비교<a hidden class=anchor aria-hidden=true href=#네트워크-동작-비교>#</a></h4><pre class=mermaid>graph TD
    subgraph TCP[&#34;TCP (파일 다운로드)&#34;]
        T1[3-Way Handshake]
        T2[데이터 전송]
        T3[ACK 대기]
        T4[재전송]
        T5[흐름 제어]
        
        T1 --&gt; T2
        T2 --&gt; T3
        T3 --&gt;|손실| T4
        T4 --&gt; T2
        T3 --&gt;|성공| T5
        T5 --&gt; T2
    end
    
    subgraph UDP[&#34;UDP (스트리밍)&#34;]
        U1[즉시 전송]
        U2[순서 무시]
        U3[손실 무시]
        U4[지터 버퍼]
        
        U1 --&gt; U2
        U2 --&gt; U3
        U3 --&gt; U4
        U4 --&gt; U1
    end
    
    style TCP fill:#e3f2fd,stroke:#1976d2
    style UDP fill:#e8f5e9,stroke:#388e3c
</pre><h2 id=성능신뢰보안-트레이드오프와-튜닝-포인트>성능·신뢰·보안 트레이드오프와 튜닝 포인트<a hidden class=anchor aria-hidden=true href=#성능신뢰보안-트레이드오프와-튜닝-포인트>#</a></h2><p><strong>표 5-1. 설계/운영 트레이드오프</strong></p><table><thead><tr><th>축</th><th>선택</th><th>장점</th><th>단점</th><th>비고</th></tr></thead><tbody><tr><td>MTU</td><td>1500 vs Jumbo(9001)</td><td>헤더비율 ↓, PPS ↓</td><td>블랙홀 위험↑, 호환성 이슈</td><td>클라우드·DC 한정 권장</td></tr><tr><td>전송</td><td>TCP vs UDP vs QUIC</td><td>신뢰/혼잡 vs 저지연 vs 빠른수립/이동성</td><td>오버헤드/지연/복잡성 각기</td><td>워크로드 따라 선택</td></tr><tr><td>혼잡</td><td>ECN 사용</td><td>패킷드롭↓, RTT 안정</td><td>장비/경로 지원 필요</td><td>ECN++ 동향</td></tr><tr><td>오프로딩</td><td>TSO/GSO/GRO</td><td>CPU↓, PPS↑</td><td>가시성↓, NIC 의존</td><td>캡처 시 주의</td></tr><tr><td>보안</td><td>TLS/QUIC</td><td>기밀·무결성</td><td>중간 가시성 저하</td><td>E2E 원칙 강화</td></tr></tbody></table><p>해설: MTU 상향은 이득이 크지만 경로 호환성·PMTUD 가 관건이다. ECN 은 드롭 없는 혼잡신호로서 점진 확산 중이며, NIC 오프로딩은 성능 향상과 가시성 저하 (패킷 캡처 왜곡) 의 딜레마를 낳는다.</p><p><strong>MTU→MSS 계산 & 경계 체크 (교육용)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-44-1><a class=lnlinks href=#hl-44-1> 1</a>
</span><span class=lnt id=hl-44-2><a class=lnlinks href=#hl-44-2> 2</a>
</span><span class=lnt id=hl-44-3><a class=lnlinks href=#hl-44-3> 3</a>
</span><span class=lnt id=hl-44-4><a class=lnlinks href=#hl-44-4> 4</a>
</span><span class=lnt id=hl-44-5><a class=lnlinks href=#hl-44-5> 5</a>
</span><span class=lnt id=hl-44-6><a class=lnlinks href=#hl-44-6> 6</a>
</span><span class=lnt id=hl-44-7><a class=lnlinks href=#hl-44-7> 7</a>
</span><span class=lnt id=hl-44-8><a class=lnlinks href=#hl-44-8> 8</a>
</span><span class=lnt id=hl-44-9><a class=lnlinks href=#hl-44-9> 9</a>
</span><span class=lnt id=hl-44-10><a class=lnlinks href=#hl-44-10>10</a>
</span><span class=lnt id=hl-44-11><a class=lnlinks href=#hl-44-11>11</a>
</span><span class=lnt id=hl-44-12><a class=lnlinks href=#hl-44-12>12</a>
</span><span class=lnt id=hl-44-13><a class=lnlinks href=#hl-44-13>13</a>
</span><span class=lnt id=hl-44-14><a class=lnlinks href=#hl-44-14>14</a>
</span><span class=lnt id=hl-44-15><a class=lnlinks href=#hl-44-15>15</a>
</span><span class=lnt id=hl-44-16><a class=lnlinks href=#hl-44-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 목적: MTU와 IPv4/IPv6 여부로 MSS를 산출하고, 페이로드 초과 여부를 검사
</span></span></span><span class=line><span class=cl><span class=c1>// 입력: mtu(number), ipver(4|6), l4(&#39;tcp&#39;|&#39;udp&#39;), extraOverhead(number=0)
</span></span></span><span class=line><span class=cl><span class=c1>// 출력: {mss, maxPayload}
</span></span></span><span class=line><span class=cl><span class=c1>// 예외: 잘못된 입력 시 throw
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>mtuToMss</span><span class=p>(</span><span class=nx>mtu</span><span class=p>,</span> <span class=nx>ipver</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=nx>l4</span><span class=o>=</span><span class=s1>&#39;tcp&#39;</span><span class=p>,</span> <span class=nx>extraOverhead</span><span class=o>=</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=mi>6</span><span class=p>].</span><span class=nx>includes</span><span class=p>(</span><span class=nx>ipver</span><span class=p>))</span> <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;ipver must be 4 or 6&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>ip</span> <span class=o>=</span> <span class=nx>ipver</span> <span class=o>===</span> <span class=mi>4</span> <span class=o>?</span> <span class=mi>20</span> <span class=o>:</span> <span class=mi>40</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>l4h</span> <span class=o>=</span> <span class=nx>l4</span> <span class=o>===</span> <span class=s1>&#39;tcp&#39;</span> <span class=o>?</span> <span class=mi>20</span> <span class=o>:</span> <span class=p>(</span><span class=nx>l4</span> <span class=o>===</span> <span class=s1>&#39;udp&#39;</span> <span class=o>?</span> <span class=mi>8</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>base</span> <span class=o>=</span> <span class=nx>mtu</span> <span class=o>-</span> <span class=nx>ip</span> <span class=o>-</span> <span class=nx>l4h</span> <span class=o>-</span> <span class=nx>extraOverhead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>base</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=p>{</span> <span class=nx>mss</span><span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>maxPayload</span><span class=o>:</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span> <span class=nx>mss</span><span class=o>:</span> <span class=nx>base</span><span class=p>,</span> <span class=nx>maxPayload</span><span class=o>:</span> <span class=nx>base</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 예: IPv6/TCP + TLS(태그 16B + 레코드헤더 5B)
</span></span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>r</span> <span class=o>=</span> <span class=nx>mtuToMss</span><span class=p>(</span><span class=mi>1500</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=s1>&#39;tcp&#39;</span><span class=p>,</span> <span class=mi>21</span><span class=p>);</span> <span class=c1>// ≈142,2B 유효 페이로드
</span></span></span></code></pre></td></tr></table></div></div><p>실제 네트워크에서는 VLAN, 터널, 옵션, 보안태그를 <code>extraOverhead</code> 에 반영해 안전한 MSS 를 산출한다. 경계 장비의 MSS 클램핑/PMTUD 동작과 함께 검증해야 한다.</p><h2 id=pdu-기반-네트워크-문제-진단-및-최적화>PDU 기반 네트워크 문제 진단 및 최적화<a hidden class=anchor aria-hidden=true href=#pdu-기반-네트워크-문제-진단-및-최적화>#</a></h2><p>PDU 구조 이해를 활용한 실무 네트워크 트러블슈팅, 성능 최적화, 보안 정책 수립 사례를 다룬다. Wireshark, tcpdump 등 패킷 분석 도구 활용법을 포함한다.</p><h3 id=패킷-분석-도구-활용>패킷 분석 도구 활용<a hidden class=anchor aria-hidden=true href=#패킷-분석-도구-활용>#</a></h3><p><strong>Wireshark</strong>: GUI 기반 패킷 캡처·분석 도구. 계층별 PDU 헤더를 시각적으로 표시하고, 필터링·통계·플로우 추적 기능을 제공한다.<br><strong>tcpdump</strong>: CLI 기반 패킷 캡처 도구. 스크립트·자동화에 적합하며, 원격 서버에서 실시간 캡처·분석이 가능하다.</p><p><strong>표: 주요 패킷 분석 도구 비교</strong></p><table><thead><tr><th>도구</th><th style=text-align:center>인터페이스</th><th>주요 기능</th><th>용도</th><th style=text-align:center>라이선스</th></tr></thead><tbody><tr><td>Wireshark</td><td style=text-align:center>GUI</td><td>계층별 헤더 디코딩, 통계, 플로우 그래프</td><td>심층 분석, 교육</td><td style=text-align:center>GPL</td></tr><tr><td>tcpdump</td><td style=text-align:center>CLI</td><td>패킷 캡처·필터링, pcap 파일 생성</td><td>원격 트러블슈팅, 자동화</td><td style=text-align:center>BSD</td></tr><tr><td>tshark</td><td style=text-align:center>CLI</td><td>Wireshark 엔진 CLI 버전</td><td>스크립트·파이프라인</td><td style=text-align:center>GPL</td></tr><tr><td>Scapy</td><td style=text-align:center>Python</td><td>패킷 생성·조작·송수신</td><td>테스트, 보안 연구</td><td style=text-align:center>GPL</td></tr></tbody></table><p><strong>Wireshark 필터 예시</strong>:</p><ul><li><code>tcp.port == 80</code>: HTTP 트래픽만 표시</li><li><code>ip.addr == 192.168.1.1</code>: 특정 IP 주소 관련 패킷</li><li><code>tcp.flags.syn == 1 && tcp.flags.ack == 0</code>: SYN 패킷만 (3-way handshake 시작)</li><li><code>frame.len > 1514</code>: Jumbo Frame 탐지</li></ul><p><strong>tcpdump 필터 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-45-1><a class=lnlinks href=#hl-45-1> 1</a>
</span><span class=lnt id=hl-45-2><a class=lnlinks href=#hl-45-2> 2</a>
</span><span class=lnt id=hl-45-3><a class=lnlinks href=#hl-45-3> 3</a>
</span><span class=lnt id=hl-45-4><a class=lnlinks href=#hl-45-4> 4</a>
</span><span class=lnt id=hl-45-5><a class=lnlinks href=#hl-45-5> 5</a>
</span><span class=lnt id=hl-45-6><a class=lnlinks href=#hl-45-6> 6</a>
</span><span class=lnt id=hl-45-7><a class=lnlinks href=#hl-45-7> 7</a>
</span><span class=lnt id=hl-45-8><a class=lnlinks href=#hl-45-8> 8</a>
</span><span class=lnt id=hl-45-9><a class=lnlinks href=#hl-45-9> 9</a>
</span><span class=lnt id=hl-45-10><a class=lnlinks href=#hl-45-10>10</a>
</span><span class=lnt id=hl-45-11><a class=lnlinks href=#hl-45-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># HTTP 트래픽 캡처</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;tcp port 80&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 특정 IP로/부터 패킷 캡처</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;host 192.168.1.1&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># SYN 패킷만 캡처 (TCP 플래그 비트마스크)</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># MTU 초과 패킷 탐지 (프레임 길이 &gt; 1514)</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;greater 1514&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Scapy 로 최소 패킷 생성·송신 (오프라인 실습용 예시)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-46-1><a class=lnlinks href=#hl-46-1>1</a>
</span><span class=lnt id=hl-46-2><a class=lnlinks href=#hl-46-2>2</a>
</span><span class=lnt id=hl-46-3><a class=lnlinks href=#hl-46-3>3</a>
</span><span class=lnt id=hl-46-4><a class=lnlinks href=#hl-46-4>4</a>
</span><span class=lnt id=hl-46-5><a class=lnlinks href=#hl-46-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 목적: 로컬 환경에서 학습용으로 ICMP 에코 패킷을 구성</span>
</span></span><span class=line><span class=cl><span class=c1># 주의: 권한/환경에 따라 송신 금지. pcap 파일로만 저장하는 오프라인 흐름 예시</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=n>Ether</span><span class=p>,</span> <span class=n>IP</span><span class=p>,</span> <span class=n>ICMP</span><span class=p>,</span> <span class=n>wrpcap</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>Ether</span><span class=p>()</span><span class=o>/</span><span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=s2>&#34;198.51.100.1&#34;</span><span class=p>)</span><span class=o>/</span><span class=n>ICMP</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>wrpcap</span><span class=p>(</span><span class=s2>&#34;icmp_echo_min.pcap&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>pkt</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>해설: Scapy 는 계층을 &ldquo;/&rdquo; 로 쌓아 PDU 를 구성한다. 실제 송신·스캔은 법·정책·소유권을 준수해야 하며, 여기서는 파일로 저장해 오프라인 분석만 가정한다.</p><h3 id=일반적인-네트워크-문제와-pdu-진단>일반적인 네트워크 문제와 PDU 진단<a hidden class=anchor aria-hidden=true href=#일반적인-네트워크-문제와-pdu-진단>#</a></h3><h4 id=문제-1-패킷-손실-packet-loss>문제 1: 패킷 손실 (Packet Loss)<a hidden class=anchor aria-hidden=true href=#문제-1-패킷-손실-packet-loss>#</a></h4><p><strong>증상</strong>: 애플리케이션 지연, 재전송 증가, 연결 끊김<br><strong>PDU 진단 방법</strong>:</p><ul><li>Wireshark 에서 <code>tcp.analysis.retransmission</code> 필터로 재전송 패킷 확인</li><li><code>tcp.analysis.lost_segment</code> 필터로 누락된 세그먼트 탐지</li><li>TCP 순서 번호 (Sequence Number) 불연속성 확인<br><strong>원인 및 해결</strong>:</li><li><strong>네트워크 혼잡</strong>: QoS 정책 적용, 대역폭 증설</li><li><strong>FCS 오류</strong>: <code>ip.checksum_bad.expert</code> 필터로 체크섬 오류 확인 → 케이블·NIC 점검</li><li><strong>방화벽 정책</strong>: 특정 포트·프로토콜 차단 → ACL 검토</li></ul><h4 id=문제-2-높은-지연-high-latency>문제 2: 높은 지연 (High Latency)<a hidden class=anchor aria-hidden=true href=#문제-2-높은-지연-high-latency>#</a></h4><p><strong>증상</strong>: 응답 시간 증가, 실시간 서비스 (VoIP, 게임) 품질 저하<br><strong>PDU 진단 방법</strong>:</p><ul><li>Wireshark 의 &ldquo;Statistics > Flow Graph&rdquo; 로 RTT(Round-Trip Time) 측정</li><li><code>tcp.time_delta > 0.1</code> 필터로 100ms 이상 지연 패킷 찾기</li><li>ICMP Echo Request/Reply 의 타임스탬프 차이 확인<br><strong>원인 및 해결</strong>:</li><li><strong>라우팅 경로 비효율</strong>: <code>traceroute</code> 또는 <code>mtr</code> 로 경로 확인 → 라우팅 테이블 최적화</li><li><strong>대역폭 포화</strong>: <code>ip.len > 1400</code> 필터로 큰 패킷 탐지 → QoS·트래픽 셰이핑</li><li><strong>DNS 조회 지연</strong>: DNS 캐시 설정, 로컬 DNS 서버 사용</li></ul><h4 id=문제-3-mtu-불일치-black-hole>문제 3: MTU 불일치 (&ldquo;Black Hole&rdquo;)<a hidden class=anchor aria-hidden=true href=#문제-3-mtu-불일치-black-hole>#</a></h4><p><strong>증상</strong>: 작은 패킷은 전달되지만 큰 패킷 (예: 파일 전송) 은 실패<br><strong>PDU 진단 방법</strong>:</p><ul><li><code>ip.flags.df == 1 && icmp.type == 3 && icmp.code == 4</code> 필터로 &ldquo;Fragmentation Needed&rdquo; ICMP 메시지 확인</li><li>패킷 크기별 전송 성공률 비교 (<code>frame.len > 1400</code> vs <code>frame.len &lt; 1400</code>)<br><strong>원인 및 해결</strong>:</li><li><strong>PMTUD 차단</strong>: 방화벽이 ICMP Type 3 Code 4 를 차단 → ICMP 허용 규칙 추가</li><li><strong>VPN·PPPoE MTU</strong>: MTU 를 1400~1492 로 수동 설정 또는 MSS Clamping 적용</li><li><strong>Jumbo Frame 불일치</strong>: 경로 전체에서 Jumbo Frame 지원 확인 또는 MTU=1500 으로 통일</li></ul><h2 id=workshops>Workshops<a hidden class=anchor aria-hidden=true href=#workshops>#</a></h2><h3 id=osi-7-계층-캡슐화-실습>OSI 7 계층 캡슐화 실습<a hidden class=anchor aria-hidden=true href=#osi-7-계층-캡슐화-실습>#</a></h3><p><strong>시나리오</strong>: 실제 HTTP 메시지를 네트워크로 전송할 때, OSI 7 계층을 따라 SDU → PDU, 캡슐화/역캡슐화 과정과 PDU 명칭 변화, 헤더/페이로드 구조를 직접 분석한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th>단계</th><th>작업</th><th>담당</th><th>도구</th><th>소요 시간</th></tr></thead><tbody><tr><td>1</td><td>HTTP 메시지 송신</td><td>개발자</td><td>Python 코드</td><td>10 분</td></tr><tr><td>2</td><td>각 계층에서 PDU 구조 분석</td><td>개발자</td><td>Wireshark</td><td>20 분</td></tr><tr><td>3</td><td>캡슐화 단계별 헤더/데이터 검증</td><td>개발자</td><td>Notion/Excel</td><td>15 분</td></tr><tr><td>4</td><td>역캡슐화 결과 확인</td><td>개발자</td><td>Wireshark</td><td>15 분</td></tr><tr><td>5</td><td>용어 정리 보고서 작성</td><td>개발자</td><td>Notion</td><td>20 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>각 계층별 PDU 구조 해설 문서</li><li>Wireshark 캡처 파일</li><li>단계별 캡슐화/역캡슐화 서식 표</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> 각 계층의 PDU 명칭/구조 도출</li><li><input disabled type=checkbox> 캡슐화 흐름에 따른 헤더/페이로드 확인</li><li><input disabled type=checkbox> SDU→PDU 관계 해설 작성</li><li><input disabled type=checkbox> 용어/개념 혼동 없는 설명</li></ul><h3 id=tcpudp-프로토콜별-pdu-분석>TCP/UDP 프로토콜별 PDU 분석<a hidden class=anchor aria-hidden=true href=#tcpudp-프로토콜별-pdu-분석>#</a></h3><p><strong>시나리오</strong>: TCP 와 UDP 로 메시지를 각각 전송/수신할 때, 각 프로토콜별 PDU 구조 차이와 에러 검출 방식, 트러블슈팅 포인트를 코드로 실습한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th>단계</th><th>작업</th><th>담당</th><th>도구</th><th>소요 시간</th></tr></thead><tbody><tr><td>1</td><td>TCP/UDP 송수신 프로그램 구현</td><td>개발자</td><td>Python</td><td>20 분</td></tr><tr><td>2</td><td>각 PDU 필드 파싱/해석</td><td>개발자</td><td>Python, Wireshark</td><td>20 분</td></tr><tr><td>3</td><td>오류 검출/분석 케이스 작성</td><td>개발자</td><td>Wireshark</td><td>15 분</td></tr><tr><td>4</td><td>트러블슈팅 리포트 정리</td><td>개발자</td><td>Notion</td><td>15 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>TCP/UDP 송수신 예제 코드 (댓글 포함)</li><li>PDU 필드 비교 표</li><li>에러 검출/분석 사례 집합</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> TCP/UDP 별 PDU 명칭/구조 파악</li><li><input disabled type=checkbox> 오류 검출 기능 구현/설명</li><li><input disabled type=checkbox> 트러블슈팅 상황 정리/해설</li><li><input disabled type=checkbox> 코드 및 프로토콜 비교표 완성</li></ul><h3 id=wireshark-로-pdu-계층-읽기>Wireshark 로 PDU 계층 읽기<a hidden class=anchor aria-hidden=true href=#wireshark-로-pdu-계층-읽기>#</a></h3><p><strong>목표</strong>: L2→L7 캡슐화와 필드 관계를 눈으로 확인<br><strong>절차</strong>:</p><ol><li><code>tcpdump -s 0 -w trace.pcap</code> 로 캡처</li><li>Wireshark 로 열기</li><li>필터 <code>tcp.flags.syn==1 or icmp</code> 적용</li><li>프레임/패킷/세그먼트 길이와 헤더 구조 기록<br><strong>지표</strong>: 평균 헤더비율 (헤더/전체), PMTUD/ICMP 가시성, 재전송 비율<br><strong>산출물</strong>: 스크린샷 + 표 1 매 (헤더비율, MSS, MTU 추정)</li></ol><h3 id=wireshark-로-http-트래픽-분석-및-pdu-계층별-디코딩>Wireshark 로 HTTP 트래픽 분석 및 PDU 계층별 디코딩<a hidden class=anchor aria-hidden=true href=#wireshark-로-http-트래픽-분석-및-pdu-계층별-디코딩>#</a></h3><p><strong>시나리오</strong>: 사용자가 웹 브라우저로 <code>http://example.com/index.html</code> 에 접속할 때, PDU 계층별 헤더를 Wireshark 로 캡처·분석하여 캡슐화 과정을 시각적으로 확인한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th style=text-align:center>단계</th><th>작업</th><th style=text-align:center>담당</th><th style=text-align:center>도구</th><th style=text-align:center>소요 시간</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td>Wireshark 캡처 시작</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>2</td><td>웹 브라우저로 <code>http://example.com</code> 접속</td><td style=text-align:center>실습자</td><td style=text-align:center>Chrome/Firefox</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>3</td><td>Wireshark 캡처 중지 및 <code>http</code> 필터 적용</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>4</td><td>HTTP GET 요청 패킷 선택 및 계층별 확장</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>5</td><td>각 계층 (Ethernet → IP → TCP → HTTP) 헤더 필드 확인·기록</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark, 메모장</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>6</td><td>캡슐화 구조 도식화 (Ethernet 안에 IP, IP 안에 TCP, TCP 안에 HTTP)</td><td style=text-align:center>실습자</td><td style=text-align:center>그림 도구 또는 종이</td><td style=text-align:center>5 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>Wireshark 캡처 파일 (.pcap)</li><li>계층별 헤더 필드 기록 표 (예: Ethernet: src_mac=…, dst_mac=…, IP: src_ip=…, dst_ip=…, TCP: src_port=…, dst_port=…, HTTP: method=GET)</li><li>캡슐화 구조 도식 (Ethernet 프레임 → IP 패킷 → TCP 세그먼트 → HTTP 메시지)</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> HTTP GET 요청 패킷이 캡처되고 필터링되었는가?</li><li><input disabled type=checkbox> Ethernet, IP, TCP, HTTP 계층의 주요 헤더 필드 (MAC, IP, Port, Method) 가 정확히 기록되었는가?</li><li><input disabled type=checkbox> 각 계층이 상위 PDU 를 페이로드로 캡슐화하는 구조가 도식으로 표현되었는가?</li></ul><h3 id=tcpdump-로-mtu-초과-패킷-탐지-및-mss-clamping-시뮬레이션>Tcpdump 로 MTU 초과 패킷 탐지 및 MSS Clamping 시뮬레이션<a hidden class=anchor aria-hidden=true href=#tcpdump-로-mtu-초과-패킷-탐지-및-mss-clamping-시뮬레이션>#</a></h3><p><strong>시나리오</strong>: PPPoE(MTU=1492) 환경에서 표준 MSS(1460) 를 사용하면 IP 단편화가 발생한다. tcpdump 로 MTU 초과 패킷을 탐지하고, MSS Clamping 을 적용하여 단편화를 방지한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th style=text-align:center>단계</th><th>작업</th><th style=text-align:center>담당</th><th style=text-align:center>도구</th><th style=text-align:center>소요 시간</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td>PPPoE 인터페이스 MTU 확인 (<code>ip link show ppp0</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>Linux CLI</td><td style=text-align:center>2 분</td></tr><tr><td style=text-align:center>2</td><td>tcpdump 로 MTU 초과 패킷 캡처 (<code>tcpdump -i ppp0 'greater 1492'</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>3</td><td>큰 파일 전송 시도 (<code>scp large_file user@server</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>scp</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>4</td><td>캡처된 패킷 분석: IP 단편화 여부 확인 (Flags: MF=1)</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump, Wireshark</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>5</td><td>iptables 로 MSS Clamping 규칙 추가 (<code>iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>iptables</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>6</td><td>다시 파일 전송 후 tcpdump 로 단편화 제거 확인</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump, scp</td><td style=text-align:center>5 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>tcpdump 캡처 로그 (단편화 전/후 비교)</li><li>iptables MSS Clamping 규칙 스크립트</li><li>성능 비교 표 (전송 시간, 재전송 횟수)</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> MTU 초과 패킷이 tcpdump 로 탐지되었는가?</li><li><input disabled type=checkbox> MSS Clamping 적용 후 IP 단편화가 제거되었는가 (MF=0)?</li><li><input disabled type=checkbox> 파일 전송 시간이 단축되거나 재전송 횟수가 감소했는가?</li></ul><h3 id=mtumss-튜닝-실험-가상-환경>MTU·MSS 튜닝 실험 (가상 환경)<a hidden class=anchor aria-hidden=true href=#mtumss-튜닝-실험-가상-환경>#</a></h3><p><strong>목표</strong>: MTU 변화가 PDU 오버헤드·처리량에 미치는 영향 관찰<br><strong>절차</strong>:</p><ol><li>가상 네트워크에서 링크 MTU 를 1500↔9001 로 교체</li><li><code>iperf3</code> 로 TCP/UDP 측정</li><li><code>mtuToMss()</code>/<code>max_payload()</code> 로 이론값 산출</li><li>ICMP 필터링/허용 비교<br><strong>지표</strong>: 처리량 (Gbit/s), P90 지연 (ms), 재전송률, 블랙홀 발생률<br><strong>산출물</strong>: 실험노트 (그래프, 설정, 결론)</li></ol><hr><h2 id=final-summary>Final Summary<a hidden class=anchor aria-hidden=true href=#final-summary>#</a></h2><blockquote><p>PDU(Protocol Data Unit) 는 네트워크 프로토콜 스택의 각 계층에서 처리하는 데이터 블록으로, 계층별로 고유한 명칭 (비트·프레임·패킷·세그먼트·데이터) 과 헤더·트레일러 구조를 가지며, 캡슐화·역캡슐화를 통해 계층 간 역할 분리와 독립성을 구현하고, MTU·MSS 협상·PMTUD 등의 메커니즘을 통해 네트워크 성능 최적화와 문제 진단의 기초가 된다.</p></blockquote><p>PDU 는 OSI 7 계층 모델과 TCP/IP 모델에서 각 계층이 다루는 데이터 단위를 의미한다. 물리 계층 (비트), 데이터링크 계층 (프레임), 네트워크 계층 (패킷), 전송 계층 (세그먼트/데이터그램), 상위 계층 (데이터/메시지) 으로 구분되며, 각 계층은 상위 PDU 를 페이로드로 받아 자신의 헤더·트레일러를 추가하는 캡슐화를 수행한다. 이는 1970 년대 네트워크 상호운용성 문제를 해결하기 위해 등장했으며, 현대 네트워크 아키텍처의 근간이 되었다.</p><p>PDU 구조는 계층 간 독립성과 확장성을 제공하지만, MTU 제약·단편화·재조립 오버헤드 등의 성능 이슈를 동반한다. IP 단편화는 MTU 불일치를 해결하지만 재조립 부담과 단편 손실 리스크가 크며, PMTUD 는 ICMP 차단 시 Black Hole 문제를 일으킨다. 이를 해결하기 위해 TCP MSS 협상, MSS Clamping, Jumbo Frame, ECN 등의 최적화 기법이 사용되며, 각 기법은 환경 (데이터센터·인터넷·VPN) 에 따라 트레이드오프가 존재한다. 예를 들어, Jumbo Frame 은 데이터센터 내부에서는 효과적이지만 인터넷 구간에서는 사용할 수 없다.</p><p>PDU 개념은 전통적인 계층 모델을 기반으로 하지만, SDN(Software-Defined Networking), NFV(Network Functions Virtualization), 5G 네트워크, QUIC 프로토콜 등 새로운 네트워크 패러다임에서는 계층 경계가 모호해지고 있다. 예를 들어, QUIC 는 전송 계층과 응용 계층을 통합하여 UDP 위에서 동작하며, SDN 은 제어 평면과 데이터 평면을 분리하여 계층 간 조작을 동적으로 수행한다. 추가 학습 과제로는 MPLS·VXLAN 등 터널링 프로토콜의 PDU 구조, IPv6 확장 헤더, QUIC 의 프레임 구조, eBPF 를 이용한 커널 레벨 PDU 조작 등이 있다. 실무 프로젝트에서는 Wireshark·tcpdump 를 활용한 패킷 분석, 방화벽·로드밸런서의 Layer 7 PDU 검사, 클라우드 환경 (AWS VPC, Azure VNet) 의 MTU 설정 최적화 등에 PDU 지식을 적용할 수 있다.</p><hr><h2 id=learning-guide>Learning Guide<a hidden class=anchor aria-hidden=true href=#learning-guide>#</a></h2><table><thead><tr><th>단계</th><th>목표 (Outcome)</th><th>과제 (Task)</th><th>평가 기준 (Rubric)</th><th>실습 포함</th></tr></thead><tbody><tr><td><strong>기초</strong></td><td>PDU 정의, OSI·TCP/IP 계층별 명칭·헤더 구조 이해</td><td>- 각 계층 PDU 명칭과 주요 헤더 필드를 표로 정리<br>- 캡슐화·역캡슐화 개념을 그림으로 도식화</td><td>- 7 계층 PDU 명칭을 정확히 기술했는가?<br>- 이더넷·IP·TCP 헤더의 주요 필드를 나열할 수 있는가?</td><td>-</td></tr><tr><td><strong>응용</strong></td><td>Wireshark 로 패킷 캡처·분석, 계층별 PDU 디코딩 능력</td><td>- Workshop 1 수행: HTTP 트래픽 캡처 및 계층별 헤더 분석<br>- TCP 3-way handshake 패킷의 Flags 필드 해석</td><td>- Wireshark 필터 (<code>tcp.port</code>, <code>ip.addr</code>) 를 정확히 작성했는가?<br>- SYN, SYN-ACK, ACK 패킷을 식별하고 순서 번호를 추적했는가?</td><td><strong>실습 1</strong>: Wireshark HTTP 분석</td></tr><tr><td><strong>실무</strong></td><td>MTU·MSS·PMTUD 문제 해결, 네트워크 성능 최적화</td><td>- Workshop 2 수행: MSS Clamping 으로 단편화 방지<br>- 실제 프로젝트에서 Jumbo Frame 또는 Window Scaling 적용</td><td>- MTU 초과 패킷을 tcpdump 로 탐지했는가?<br>- MSS Clamping 적용 후 단편화가 제거되었는가?<br>- 성능 지표 (처리량, 지연) 가 측정·개선되었는가?</td><td><strong>실습 2</strong>: MSS Clamping 시뮬레이션</td></tr><tr><td><strong>심화</strong></td><td>SDN·NFV·QUIC 등 새로운 네트워크 패러다임의 PDU 구조 탐구</td><td>- QUIC 프레임 구조 분석 및 UDP 기반 전송 원리 이해<br>- eBPF 로 커널 레벨 PDU 조작 코드 작성<br>- MPLS·VXLAN 터널링 PDU 구조 연구</td><td>- QUIC 프레임과 TCP 세그먼트의 차이를 설명할 수 있는가?<br>- eBPF 로 패킷 필터링·헤더 수정을 구현했는가?<br>- 터널링 프로토콜의 캡슐화 오버헤드를 분석했는가?</td><td>-</td></tr></tbody></table><hr><h2 id=terminology>Terminology<a hidden class=anchor aria-hidden=true href=#terminology>#</a></h2><table><thead><tr><th>Term EN (ko, abbr)</th><th>정의</th><th>역할/맥락</th><th>관련 개념</th><th>Flags</th></tr></thead><tbody><tr><td>PDU (프로토콜 데이터 단위, Protocol Data Unit)</td><td>네트워크 프로토콜 스택의 각 계층에서 처리·전송하는 데이터 블록</td><td>계층별 역할 분리와 독립성 구현의 기초</td><td>Encapsulation, Decapsulation</td><td>-</td></tr><tr><td>Service Data Unit (서비스 데이터 단위, SDU)</td><td>하위 계층에 전달되는 상위 계층의 데이터</td><td>캡슐화 입력</td><td>PDU, PCI</td><td>core</td></tr><tr><td>Protocol Control Information (프로토콜 제어정보, PCI)</td><td>주소/길이/오류검출 등 제어 필드</td><td>헤더 구성</td><td>헤더, 트레일러</td><td>core</td></tr><tr><td>Bit (비트)</td><td>물리 계층 (Layer 1) PDU, 전기·광 신호로 표현</td><td>네트워크 전송의 최소 단위</td><td>Physical Layer, Signal</td><td>-</td></tr><tr><td>Frame (프레임)</td><td>데이터링크 계층 (Layer 2) PDU, MAC 주소와 FCS 포함</td><td>LAN 내 노드 간 데이터 전달</td><td>Ethernet, MAC Address, FCS</td><td>-</td></tr><tr><td>Packet (패킷)</td><td>네트워크 계층 (Layer 3) PDU, IP 주소와 TTL 포함</td><td>네트워크 간 라우팅의 기본 단위</td><td>IP, Routing, TTL</td><td>-</td></tr><tr><td>Segment (세그먼트)</td><td>전송 계층 (Layer 4) PDU(TCP), 포트 번호와 순서 번호 포함</td><td>종단 간 신뢰성 있는 데이터 전송</td><td>TCP, Port Number, Sequence Number</td><td>-</td></tr><tr><td>Datagram (데이터그램)</td><td>전송 계층 (Layer 4) PDU(UDP), 포트 번호 포함 (비연결형)</td><td>종단 간 비연결형 전송</td><td>UDP, Port Number</td><td>-</td></tr><tr><td>Encapsulation (캡슐화)</td><td>상위 PDU 를 페이로드로 받아 헤더·트레일러를 추가하는 과정</td><td>계층 간 데이터 전달의 핵심 메커니즘</td><td>PDU, Header, Trailer</td><td>-</td></tr><tr><td>Decapsulation (역캡슐화)</td><td>하위 PDU 로부터 헤더·트레일러를 제거하여 상위 PDU 복원</td><td>수신 측 데이터 처리 과정</td><td>PDU, Header Removal</td><td>-</td></tr><tr><td>Header (헤더)</td><td>PDU 앞부분에 추가되는 제어 정보 (주소, 플래그 등)</td><td>계층별 프로토콜 제어 기능 구현</td><td>PDU, Protocol</td><td>-</td></tr><tr><td>Trailer (트레일러)</td><td>PDU 뒷부분에 추가되는 제어 정보 (예: FCS)</td><td>데이터 무결성 검증</td><td>FCS, CRC</td><td>-</td></tr><tr><td>Payload (페이로드)</td><td>PDU 의 실제 데이터 부분 (상위 계층 PDU 또는 사용자 데이터)</td><td>전송 대상 정보</td><td>PDU, User Data</td><td>-</td></tr><tr><td>MTU (최대 전송 단위, Maximum Transmission Unit)</td><td>네트워크 계층이 데이터링크 계층으로 전달할 수 있는 최대 패킷 크기</td><td>네트워크 성능 최적화의 핵심 파라미터</td><td>Frame, Fragmentation, MSS</td><td>-</td></tr><tr><td>MSS (최대 세그먼트 크기, Maximum Segment Size)</td><td>TCP 세그먼트의 최대 페이로드 크기 (헤더 제외)</td><td>TCP 성능 최적화 및 단편화 방지</td><td>TCP, MTU, Encapsulation</td><td>-</td></tr><tr><td>Fragmentation (단편화)</td><td>IP 패킷 크기가 MTU 를 초과할 때 여러 단편으로 나누는 과정</td><td>MTU 불일치 해결 (성능 저하 가능성)</td><td>IP, MTU, Reassembly</td><td>Performance Impact</td></tr><tr><td>PMTUD (경로 MTU 발견, Path MTU Discovery)</td><td>경로 상 최소 MTU 를 동적으로 발견하는 메커니즘</td><td>단편화 없는 최대 패킷 크기 결정</td><td>MTU, ICMP, Fragmentation</td><td>ICMP Dependency</td></tr><tr><td>DF (단편화 금지, Don&rsquo;t Fragment)</td><td>IP 헤더 Flags 필드의 비트, 설정 시 단편화 금지</td><td>PMTUD 및 성능 최적화에 사용</td><td>IP, Fragmentation, PMTUD</td><td>-</td></tr><tr><td>FCS (프레임 체크 시퀀스, Frame Check Sequence)</td><td>이더넷 프레임 트레일러의 CRC-32 오류 검출 필드</td><td>데이터링크 계층 무결성 검증</td><td>Frame, CRC, Error Detection</td><td>-</td></tr><tr><td>TTL (수명, Time To Live)</td><td>IP 헤더 필드, 라우팅 홉마다 1 감소 (0 도달 시 폐기)</td><td>라우팅 루프 방지</td><td>IP, Routing, Hop</td><td>-</td></tr><tr><td>Checksum (체크섬)</td><td>IP·TCP·UDP 헤더의 오류 검출 필드</td><td>데이터 무결성 검증 (비암호화)</td><td>Header, Error Detection</td><td>Limited Security</td></tr><tr><td>Jumbo Frame (점보 프레임)</td><td>MTU 가 9000 바이트 이상인 이더넷 프레임</td><td>데이터센터 내부 성능 최적화</td><td>MTU, Ethernet, Performance</td><td>Compatibility</td></tr><tr><td>ECN (명시적 혼잡 통지, Explicit Congestion Notification)</td><td>IP·TCP 헤더의 혼잡 제어 필드, 패킷 손실 없이 혼잡 신호 전달</td><td>TCP 성능 향상 및 지연 감소</td><td>TCP, Congestion Control, QoS</td><td>-</td></tr><tr><td>Window Scaling (윈도우 스케일링)</td><td>TCP 윈도우 크기를 최대 1GB 까지 확장하는 옵션</td><td>고대역폭·고지연 네트워크 성능 최적화</td><td>TCP, Window Size, Performance</td><td>-</td></tr><tr><td>CAM Table (내용 주소화 메모리 테이블, Content Addressable Memory Table)</td><td>스위치가 MAC 주소와 포트를 매핑한 테이블</td><td>Layer 2 스위칭의 기초</td><td>Switch, MAC Address, Frame</td><td>-</td></tr><tr><td>VLAN (가상 랜, Virtual LAN)</td><td>물리적 네트워크를 논리적으로 분리하는 기술, 802.1Q 태그 사용</td><td>브로드캐스트 도메인 분리 및 보안</td><td>Frame, Tag, Switch</td><td>-</td></tr><tr><td>VXLAN (가상 확장 LAN, Virtual Extensible LAN)</td><td>Layer 2 프레임을 UDP 로 캡슐화하여 Layer 3 네트워크로 전송</td><td>데이터센터·클라우드 네트워크 가상화</td><td>Encapsulation, Tunneling, SDN</td><td>Overhead</td></tr><tr><td>MPLS (다중 프로토콜 라벨 스위칭, Multiprotocol Label Switching)</td><td>레이블 기반 패킷 포워딩, IP 라우팅보다 빠름</td><td>WAN·캐리어 네트워크 성능 최적화</td><td>Label, Routing, Tunneling</td><td>Vendor-Specific</td></tr><tr><td>QUIC (빠른 UDP 인터넷 연결, Quick UDP Internet Connections)</td><td>UDP 위에서 동작하는 전송 계층 프로토콜, HTTP/3 기반</td><td>저지연·고속 웹 통신</td><td>UDP, HTTP/3, Encryption</td><td>Emerging</td></tr><tr><td>Offload (오프로딩: TSO/GSO/GRO)</td><td>NIC 이 세그먼트/병합을 대행</td><td>성능 향상</td><td>캡처 가시성</td><td>perf</td></tr><tr><td>Display/Capture filter (디스플레이/캡처 필터)</td><td>분석·캡처 트래픽 선별</td><td>관찰성</td><td>BPF</td><td>tool</td></tr><tr><td>TLS Record (TLS 레코드)</td><td>TLS 1.3 의 전송 단위</td><td>보안·무결성</td><td>AEAD</td><td>L7</td></tr></tbody></table><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><h3 id=ietf-rfc--표준-스펙-1-차-근거>IETF RFC / 표준 스펙 (1 차 근거)<a hidden class=anchor aria-hidden=true href=#ietf-rfc--표준-스펙-1-차-근거>#</a></h3><ul><li><a href=https://www.rfc-editor.org/rfc/rfc8200.html>RFC 8200: Internet Protocol, Version 6 (IPv6) Specification</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc791.html>RFC 791: Internet Protocol (IPv4)</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc9293.html>RFC 9293: Transmission Control Protocol (TCP)</a></li><li><a href=https://www.ietf.org/rfc/rfc768.txt>RFC 768: User Datagram Protocol (UDP)</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc8446.html>RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3</a></li><li><a href=https://datatracker.ietf.org/doc/rfc9000/>RFC 9000: QUIC: A UDP-Based Multiplexed and Secure Transport</a></li><li><a href=https://datatracker.ietf.org/doc/rfc3168/>RFC 3168: Explicit Congestion Notification (ECN)</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc1191>RFC 1191: Path MTU Discovery for IPv4</a></li><li><a href=https://datatracker.ietf.org/doc/rfc8201/>RFC 8201: Path MTU Discovery for IPv6</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc4821>RFC 4821: Packetization Layer Path MTU Discovery</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc879>RFC 879: TCP Maximum Segment Size</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc7323>RFC 7323: TCP Extensions for High Performance</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc1122>RFC 1122: Requirements for Internet Hosts</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc7348>RFC 7348: VXLAN</a></li></ul><h3 id=ieeeiso-표준>IEEE/ISO 표준<a hidden class=anchor aria-hidden=true href=#ieeeiso-표준>#</a></h3><ul><li><a href=https://standards.ieee.org/ieee/802.3/10422/>IEEE 802.3-2022: Ethernet (overview)</a></li><li><a href=https://standards.ieee.org/ieee/802.11/10548/>IEEE 802.11-2024: WLAN MAC/PHY (overview)</a></li><li><a href=https://standards.ieee.org/ieee/802.1Q/6844/>IEEE 802.1Q: Virtual LANs</a></li><li><a href=https://www.iso.org/standard/20269.html>ISO/IEC 7498-1: OSI Reference Model</a></li></ul><h3 id=3gpp--etsi-모바일-스택-참조>3GPP / ETSI (모바일 스택 참조)<a hidden class=anchor aria-hidden=true href=#3gpp--etsi-모바일-스택-참조>#</a></h3><ul><li><a href=https://www.3gpp.org/dynareport/38321.htm>3GPP TS 38.321: NR MAC protocol specification</a></li><li><a href=https://www.3gpp.org/dynareport/38323.htm>3GPP TS 38.323: NR PDCP specification</a></li><li><a href=https://www.etsi.org/deliver/etsi_ts/138300_138399/138323/18.05.00_60/ts_138323v180500p.pdf>ETSI TS 138 323 V18.5.0 (2025-04)</a></li></ul><h3 id=운영체제플랫폼-가이드--클라우드-문서>운영체제/플랫폼 가이드 & 클라우드 문서<a hidden class=anchor aria-hidden=true href=#운영체제플랫폼-가이드--클라우드-문서>#</a></h3><ul><li><a href=https://docs.kernel.org/networking/segmentation-offloads.html>Linux kernel: Segmentation Offloads (TSO/GSO/GRO)</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setpmtudiscovery-method-in-class-win32-networkadapterconfiguration>Microsoft Learn: SetPMTUDiscovery</a></li><li><a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/network_mtu.html>AWS EC2: Network MTU & Jumbo Frames</a></li><li><a href=https://cloud.google.com/vpc/docs/mtu>Google Cloud VPC: MTU & MSS Clamping</a></li></ul><h3 id=도구-매뉴얼>도구 매뉴얼<a hidden class=anchor aria-hidden=true href=#도구-매뉴얼>#</a></h3><ul><li><a href=https://www.wireshark.org/docs/wsug_html_chunked/>Wireshark User’s Guide</a></li><li><a href=https://www.tcpdump.org/manpages/tcpdump.1.html>tcpdump man page</a></li></ul><h3 id=서적학술-1-차심화>서적/학술 (1 차·심화)<a hidden class=anchor aria-hidden=true href=#서적학술-1-차심화>#</a></h3><ul><li><a href=https://www.pearson.com/store/p/computer-networks/P100000101303>Computer Networks (Tanenbaum & Wetherall, 5th Edition)</a></li><li><a href=https://www.informit.com/store/tcp-ip-illustrated-volume-1-the-protocols-9780321336316>TCP/IP Illustrated, Vol. 1 (Stevens)</a></li><li><a href=https://dl.acm.org/doi/10.1145/52325.52336>The Design Philosophy of the DARPA Internet Protocols (Clark, 1988)</a></li><li><a href=https://dl.acm.org/doi/10.1145/1851182.1851192>DCTCP: Efficient Packet Transport for the Commoditized Data Center (Alizadeh et al., 2010)</a></li><li><a href=https://ieeexplore.ieee.org/document/6994333>Software-Defined Networking: A Comprehensive Survey (Kreutz et al., 2015)</a></li></ul><h3 id=벤더실무-아티클-보조>벤더/실무 아티클 (보조)<a hidden class=anchor aria-hidden=true href=#벤더실무-아티클-보조>#</a></h3><ul><li><a href=https://developers.cloudflare.com/magic-wan/reference/mtu-mss/>Cloudflare Developers: MTU and MSS</a></li></ul><h3 id=입문용어-해설-보조pdu-등>입문/용어 해설 (보조—PDU 등)<a hidden class=anchor aria-hidden=true href=#입문용어-해설-보조pdu-등>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Protocol_data_unit>Protocol data unit – Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/computer-networks/protocol-data-unit-pdu/>Protocol Data Unit (PDU) – GeeksforGeeks</a></li><li><a href=https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%8B%A8%EC%9C%84>프로토콜 데이터 단위(PDU) – 위키백과(한국어)</a></li><li><a href=https://www.lenovo.com/us/en/glossary/what-is-pdu/>Protocol Data Unit – Lenovo Glossary</a></li><li><a href=https://www.sciencedirect.com/topics/computer-science/protocol-data-unit>Protocol Data Unit — ScienceDirect Topic Overview</a></li><li><a href=https://www.techtarget.com/searchnetworking/definition/protocol-data-unit-PDU>What is a Protocol Data Unit (PDU)? – TechTarget</a></li></ul><h4 id=pdu-관련-블로그학습-글-모음>PDU 관련 블로그/학습 글 모음<a hidden class=anchor aria-hidden=true href=#pdu-관련-블로그학습-글-모음>#</a></h4><ul><li><a href=https://bkkhyunn.github.io/network/3_network/>https://bkkhyunn.github.io/network/3_network/</a></li><li><a href=https://hoonsb.tistory.com/70>https://hoonsb.tistory.com/70</a></li><li><a href=https://jh7722.tistory.com/94>https://jh7722.tistory.com/94</a></li><li><a href=https://coconuts.tistory.com/1415>https://coconuts.tistory.com/1415</a></li><li><a href=https://www.professormesser.com/professor-messer-archives/n10-007/protocol-data-units/>https://www.professormesser.com/professor-messer-archives/n10-007/protocol-data-units/</a></li><li><a href="http://www.ktword.co.kr/test/view/view.php?no=310">http://www.ktword.co.kr/test/view/view.php?no=310</a></li><li><a href=https://www.vpnunlimited.com/ko/help/cybersecurity/protocol-data-unit>https://www.vpnunlimited.com/ko/help/cybersecurity/protocol-data-unit</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SDU(Service Data Unit, 서비스 데이터 단위)</h2></header><div class=entry-content><p>SDU(Service Data Unit, 서비스 데이터 단위) SDU(Service Data Unit) 는 ISO/IEC 7498-1 에 정의된 OSI 참조 모델의 핵심 개념으로, 계층화된 네트워크 아키텍처에서 인접 계층 간 서비스 전달의 기본 단위를 나타낸다. 각 계층 (N-layer) 은 상위 계층 (N+1) 으로부터 N-SDU 를 받아 자신의 프로토콜 제어 정보 (PCI) 를 추가하여 N-PDU 를 생성하고, 이를 하위 계층 (N-1) 에 N-1-SDU 로 전달한다.
SDU 의 핵심은 계층 간 서비스 인터페이스의 명확한 분리다. 각 계층은 상위 계층에게 서비스를 제공하는 서비스 제공자 (service provider) 역할을 하며, 하위 계층의 서비스를 사용하는 서비스 사용자 (service user) 역할을 동시에 수행한다. 이러한 계층별 역할 분리는 프로토콜 독립성과 모듈화를 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2025-10-02 13:55:00 +0000 UTC'>October 2, 2025</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SDU(Service Data Unit, 서비스 데이터 단위)" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/sdu/></a></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>