<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PDU(Protocol Data Unit, 프로토콜 데이터 단위) | hyunyoun's Blog</title><meta name=keywords content="Networking-and-Protocols,Network-Fundamentals,Basic-Concepts,Data-Transmission,PDU,OSI-Model,protocol-data-unit,encapsulation,header-trailer"><meta name=description content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="PDU(Protocol Data Unit, 프로토콜 데이터 단위)"><meta property="og:description" content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="PDU(Protocol Data Unit, 프로토콜 데이터 단위)"><meta name=twitter:description content="PDU(Protocol Data Unit)는 각 계층이 *상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸* 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"PDU(Protocol Data Unit, 프로토콜 데이터 단위)","item":"https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/data-transmission/pdu/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>PDU(Protocol Data Unit, 프로토콜 데이터 단위)</h1><div class=post-description>PDU(Protocol Data Unit)는 각 계층이 <em>상위 계층의 SDU(Service Data Unit)를 자신의 제어정보(PCI: Protocol Control Information)로 감싸</em> 만들어 내는 전송 단위다. 계층마다 명칭·형식·오류제어가 달라지며, MTU/MSS, 단편화, 오프로딩(TSO/GRO) 등 성능·신뢰·보안 이슈와 직결된다.</div></header><div class=post-content><h2 id=pduprotocol-data-unit-프로토콜-데이터-단위>PDU(Protocol Data Unit, 프로토콜 데이터 단위)<a hidden class=anchor aria-hidden=true href=#pduprotocol-data-unit-프로토콜-데이터-단위>#</a></h2><p>PDU(Protocol Data Unit) 는 네트워크 통신에서 각 프로토콜 계층이 다루는 데이터 블록을 의미하며, 계층별로 서로 다른 명칭과 헤더 구조를 가진다.</p><p>OSI 참조 모델 (7 계층) 과 TCP/IP 모델 (4 계층) 은 모두 PDU 를 통해 계층 간 역할 분리와 독립성을 구현한다.<br>물리 계층 (Layer 1) 에서는 비트 (Bit) 스트림으로 표현되고,<br>데이터링크 계층 (Layer 2) 에서는 프레임 (Frame) 에 MAC 주소와 FCS 를 포함하며,<br>네트워크 계층 (Layer 3) 에서는 패킷 (Packet) 에 IP 주소를 담고,<br>전송 계층 (Layer 4) 에서는 세그먼트 (Segment, TCP) 또는 데이터그램 (Datagram, UDP) 에 포트 번호를 명시한다.<br>상위 계층 (5~7 계층) 은 통칭 데이터 (Data) 또는 메시지로 불린다.</p><p>각 계층은 상위 계층 PDU 를 페이로드로 받아들이고 고유 헤더를 추가하는 캡슐화 (Encapsulation) 를 수행하며, 수신 측은 역캡슐화 (Decapsulation) 를 통해 원본 데이터를 복원한다.</p><p>PDU 구조 이해는 패킷 분석, 방화벽 규칙 설정, QoS(Quality of Service) 정책, MTU(Maximum Transmission Unit) 최적화 등 실무 네트워크 운영의 핵심이다. 또한 SDN(Software-Defined Networking), NFV(Network Functions Virtualization) 환경에서 계층별 헤더 조작과 트래픽 제어를 위한 기초 지식으로 작용한다.</p><h2 id=기본-개념과-배경>기본 개념과 배경<a hidden class=anchor aria-hidden=true href=#기본-개념과-배경>#</a></h2><p>PDU 의 정의와 특징, 등장 배경, 해결하려는 문제, 흔한 오해, 핵심 용어 정합을 다룬다. 네트워크 계층 모델의 근간이 되는 개념을 명확히 이해하는 것이 목표다.</p><h3 id=정의-definition>정의 (Definition)<a hidden class=anchor aria-hidden=true href=#정의-definition>#</a></h3><p>PDU(Protocol Data Unit) 는 <strong>네트워크 프로토콜 스택의 각 계층에서 처리·전송하는 데이터 블록</strong>을 의미한다.<br>보통 <code>헤더(제어정보) + 페이로드(SDU)</code> 구조를 가지며 각 계층의 동작 규칙에 따라 다르게 이름을 가지며 네트워크 프로토콜 효율화에 중요한 역할을 한다.</p><p>OSI 참조 모델과 TCP/IP 모델에서 각 계층은 고유한 PDU 이름과 헤더·트레일러 구조를 정의하며, 이를 통해 계층 간 역할 분리와 독립적 프로토콜 설계를 구현한다.<br>예를 들어, TCP 세그먼트는 전송 계층 PDU 로, IP 패킷은 네트워크 계층 PDU 로, 이더넷 프레임은 데이터링크 계층 PDU 로 지칭된다.</p><h3 id=특징-characteristics>특징 (Characteristics)<a hidden class=anchor aria-hidden=true href=#특징-characteristics>#</a></h3><p>PDU 는 각 계층마다 별도의 명칭 (예: Bit, Frame, Packet, Segment 등) 을 가지며, 계층별 프로토콜에 따라 구조와 필드 구성이 달라진다. 캡슐화 과정을 거치며 이전 계층의 데이터 (SDU) 를 포함하고, 송수신 동작의 독립성을 유지한다.</p><ul><li><strong>계층별 고유 명칭</strong>: 물리 (비트), 데이터링크 (프레임), 네트워크 (패킷), 전송 (세그먼트/데이터그램), 상위 (데이터/메시지) 로 구분된다.</li><li><strong>헤더·트레일러 구조</strong>: 각 계층은 상위 PDU 를 페이로드로 받아 자신의 제어 정보 (헤더, 선택적 트레일러) 를 추가한다.</li><li><strong>캡슐화·역캡슐화</strong>: 송신 측은 상위→하위 순으로 헤더를 추가 (캡슐화), 수신 측은 하위→상위 순으로 헤더를 제거 (역캡슐화) 한다.</li><li><strong>독립성과 투명성</strong>: 각 계층은 상·하위 계층의 내부 구현을 알 필요 없이 PDU 인터페이스만 준수하면 된다.</li><li><strong>실무 도구 연계</strong>: 패킷 분석기 (Wireshark, tcpdump), 방화벽 (iptables, ACL), 로드밸런서가 PDU 헤더를 기반으로 동작한다.</li></ul><h4 id=pdu-의-12-가지-구조적-특징>PDU 의 12 가지 구조적 특징<a hidden class=anchor aria-hidden=true href=#pdu-의-12-가지-구조적-특징>#</a></h4><p>PDU 의 12 가지 특징은</p><ol><li>**구조/명명</li><li><strong>크기/경로 제약</strong></li><li><strong>신뢰/품질 제어</strong></li><li><strong>운영/가시성·성능</strong><br>의 4 가지 차원으로 묶인다. 이는 상호 의존적이다.<br>구조/옵션 결정이 곧바로 크기/경로 제약에 반영되고, 여기서의 실패는 신뢰/품질의 재전송·지연을 키운다. 암호화·오프로딩은 관찰성을 바꾸므로, 캡처 위치와 텔레메트리를 &rsquo; 이중화 &rsquo; 하는 것이 빠른 트러블슈팅의 핵심이다.</li></ol><p>실무에서는 이 4 가지 차원을 동시에 점검해야 헤더 예산·손실/지연·보안·관찰성이 균형을 이룬다.<br>핵심은 &ldquo;<strong>헤더가 쌓이면 MTU 는 줄고</strong>, 그 결과 <strong>분할/단편화·재전송</strong>이 증가하며, <strong>암호화/오프로딩/터널</strong>은 분석 난이도를 높인다 " 는 연쇄 효과를 이해하는 것이다.</p><h5 id=구조명명>구조/명명<a hidden class=anchor aria-hidden=true href=#구조명명>#</a></h5><ul><li><strong>계층 종속 명명</strong>—같은 " 데이터 덩어리 " 라도 관찰 지점에 따라 이름과 의미가 달라진다. 스위치 포트 미러는 L2 <em>Frame</em>을, 라우터/방화벽은 L3 <em>Packet</em>을, 호스트의 소켓 계층은 L4 <em>Segment/Datagram</em>을 본다. 명칭 혼동은 문제 위치 추적을 어렵게 하므로, 증상 보고·캡처·로그를 모두 동일 계층 기준으로 맞추는 것이 중요하다.</li><li><strong>헤더 구조 (고정 + 옵션/확장)</strong>—IPv4 IHL, TCP Options, IPv6 Extension Header, 802.1Q VLAN 처럼 <em>고정 필드 + 가변 옵션</em> 조합이다. 옵션은 확장성과 유연성을 주지만, 오버헤드 증가·미들박스 호환성·슬로패스 전환 위험이 따른다. 운영선에서는 필요 옵션만 최소화하고, 중간장비 호환성 목록을 유지한다.</li><li><strong>주소/식별/흐름 라벨</strong>—MAC/IP/Port 의 전통적 5- 튜플 외에도 IPv6 Flow Label, QUIC Connection ID(CID), VLAN ID, SPI(IPsec) 등 식별자가 있다. 해시 기반 로드밸런싱/ECMP 는 이들 필드를 키로 사용해 흐름을 분산한다. NAT/터널이 개입하면 키 구성이 바뀌므로, 트래픽 핑거프린팅과 경로 일관성을 재검증해야 한다.</li></ul><h5 id=크기경로-제약>크기/경로 제약<a hidden class=anchor aria-hidden=true href=#크기경로-제약>#</a></h5><ul><li><strong>길이 제약 (MTU/MSS/최소 프레임)</strong>—MTU 는 상위 모든 PDU 크기에 상한을 건다. 이더넷 최소 프레임 (패딩 포함) 과 무선 MAC 오버헤드, 터널/보안 헤더가 결합되면 유효 페이로드가 급감한다. MSS 는 TCP 협상 시 안전한 상한을 제공하지만, 실제 경로 MTU 와 불일치하면 재전송·블랙홀이 발생한다.</li><li><strong>단편화 정책 차이 (IPv4/IPv6)</strong>—IPv4 는 중간 라우터 단편화가 가능 (DF=0), IPv6 는 송신자만 단편화 가능하다. 단편화는 손실/지연·CPU 비용을 증가시키므로 <em>회피가 원칙</em>이다. 운영에서는 PMTUD/PLPMTUD 로 크기를 조정하고, 방화벽에서 조각 (Fragments) 처리를 신중히 설계한다.</li><li><strong>PMTUD/PLPMTUD</strong>—ICMP 신호에 의존하는 전통 PMTUD(IPv4 Frag Needed, IPv6 PTB) 는 필터링되면 실패한다. PLPMTUD 는 실제 데이터/프로브로 안전 크기를 탐색해 블랙홀을 줄인다. 경로가 자주 바뀌는 모바일/클라우드 환경에서 특히 중요하다.</li><li><strong>터널/오버레이 중첩</strong>—VLAN/QinQ/VXLAN/GRE/IPsec/GTP-U 는 새로운 헤더를 추가해 경계 밖의 L2/L3 를 가상화한다. 중첩 깊이가 증가하면 헤더 예산이 급격히 줄어 PMTUD 실패·단편화·성능 저하로 이어진다. 터널 종단에서 MTU 조정·MSS 클램핑·외부 단편화 방지 설정을 함께 적용한다.</li></ul><h5 id=신뢰품질-제어>신뢰/품질 제어<a hidden class=anchor aria-hidden=true href=#신뢰품질-제어>#</a></h5><ul><li><strong>오류 검출/복구</strong>—L2 FCS(CRC)·IPv4 헤더 체크섬·L4 체크섬·TLS/QUIC 의 AEAD 가 계층별로 무결성을 보장한다. 검출 범위와 비용이 달라 중복도 존재한다 (예: IPv6 은 라우터 성능을 위해 헤더 체크섬 제거). 체크섬/암호 검증 실패는 즉시 드롭되므로, 관찰 지표 (드롭 카운터, ICV 오류) 를 병행 모니터링해야 한다.</li><li><strong>순서/신뢰 의미</strong>—TCP 는 순서/재전송/흐름·혼잡제어를 제공해 <em>바이트 스트림</em>을 보장한다. UDP 는 비연결/무보장으로 지연 예측 가능성이 높고, QUIC 은 UDP 위에 <em>스트림 단위</em> 신뢰·복구를 제공해 HOL(Head-of-Line) 문제를 줄인다. 응용의 메시지 경계 보존 요구에 따라 적절한 전송을 선택해야 한다.</li><li><strong>혼잡/우선 신호 (ECN/DSCP)</strong>—ECN 의 ECT/CE 비트로 드롭 없이 혼잡 신호를 전달하고, DSCP/Traffic Class 로 클래스 기반 큐잉을 수행한다. ECN 이 비활성/표백 (bleach) 되는 경로에서는 이득이 제한되며, AQM(RED/CoDel/FQ-CoDel) 과의 조합에서 효과가 크다. 마킹/정책 일관성을 엔드·경계 장비에서 교차 검증한다.</li></ul><h5 id=운영가시성성능>운영/가시성·성능<a hidden class=anchor aria-hidden=true href=#운영가시성성능>#</a></h5><ul><li><strong>오프로딩 (TSO/GSO/GRO 등)</strong>—호스트는 큰 PDU 를 NIC 가 분할/병합하도록 위임하여 PPS/CPU 비용을 낮춘다. 이때 호스트 로컬 캡처에선 <em>큰 가상 세그먼트</em>로 보일 수 있어 온와이어 현실과 불일치한다. 분석은 미러 포트/경계 장비 캡처와 교차하고, ethtool/드라이버 카운터로 상태를 확인한다.</li><li><strong>보안과 가시성의 상호작용</strong>—TLS 1.3/QUIC 은 메타데이터까지 광범위하게 암호화하여 DPI/미들박스 의존 진단을 어렵게 한다. 대신 엔드포인트 텔레메트리 (연결 통계, 실패 코드) 와 패시브 지표 (QUIC 스핀 비트 등, 배포 정책에 따라) 로 관찰성을 보완한다. 암호화 태그/레코드로 헤더 오버헤드가 늘어나 MTU 예산을 소모한다.</li></ul><h5 id=pdu-의-12-가지-구조적-특징-요약>PDU 의 12 가지 구조적 특징 (요약)<a hidden class=anchor aria-hidden=true href=#pdu-의-12-가지-구조적-특징-요약>#</a></h5><table><thead><tr><th style=text-align:center>차원</th><th>특징</th><th>설명</th><th>대표 필드/메커니즘</th><th>영향 (성능/신뢰/보안)</th></tr></thead><tbody><tr><td style=text-align:center>구조/명명</td><td>계층 종속 명명</td><td>L2=Frame, L3=Packet, L4=Segment/Datagram 등 관찰 계층에 따라 명칭·의미 상이</td><td>802.3/802.11, IP, TCP/UDP</td><td>모델 정합·분석 정확도 ↑</td></tr><tr><td style=text-align:center>구조/명명</td><td>헤더 구조 (고정 + 옵션)</td><td>고정 필드 + 옵션/확장 (EH/옵션) 로 확장성·호환성·오버헤드 균형</td><td>IHL, Next Header, TCP Options</td><td>오버헤드·확장성 트레이드오프</td></tr><tr><td style=text-align:center>구조/명명</td><td>주소/식별/흐름 라벨</td><td>5- 튜플 외 CID/Flow Label/VLAN/SPI 등 식별자</td><td>SA/DA, Src/Dst, FlowLbl, DCID/SCID</td><td>로드밸런싱/추적성/정책</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>길이 제약 (MTU/MSS/최소 프레임)</td><td>MTU/MSS/패딩 규칙이 최대 페이로드를 결정</td><td>MTU, TotalLen, PayloadLen</td><td>블랙홀/재전송/지연 영향</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>단편화 정책</td><td>IPv4(중간 가능) vs IPv6(송신자만)</td><td>DF, FragOff, IPv6 Frag EH</td><td>재조립 비용/손실 민감</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>PMTUD/PLPMTUD</td><td>경로 MTU 탐색; ICMP 의존/프로빙 기반</td><td>ICMP FragNeeded/PTB</td><td>블랙홀 회피/적응성</td></tr><tr><td style=text-align:center>크기/경로 제약</td><td>터널/오버레이 중첩</td><td>VLAN/VXLAN/GRE/IPsec 등 헤더 중첩</td><td>EtherType, VNI, SPI</td><td>MTU 악화·성능 저하</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>오류 검출/복구</td><td>FCS/체크섬/AEAD 등 계층별 무결성·복구</td><td>FCS, HeaderChk, L4 Checksum, AEAD Tag</td><td>무결성/처리비용/드롭 패턴</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>순서/신뢰 의미</td><td>TCP(순서·재전송), UDP(비연결), QUIC(스트림 단위)</td><td>Seq/Ack, Stream ID</td><td>지연/손실/복원 전략 차이</td></tr><tr><td style=text-align:center>신뢰/품질 제어</td><td>혼잡/우선 신호</td><td>ECN/DSCP 로 혼잡·우선순위 신호화</td><td>ECT/CE, DSCP/Traffic Class</td><td>드롭률·품질 보장</td></tr><tr><td style=text-align:center>운영/가시성·성능</td><td>보안↔가시성</td><td>TLS/QUIC 암호화로 가시성↓·오버헤드↑</td><td>TLS Record, AEAD</td><td>DPI 난이도·MTU 예산</td></tr><tr><td style=text-align:center>운영/가시성·성능</td><td>오프로딩 (TSO/GSO/GRO)</td><td>NIC 분할/병합으로 PPS↑, 캡처 왜곡 우려</td><td>Linux Offloads</td><td>CPU↓/가시성 주의</td></tr></tbody></table><h3 id=등장-배경-background>등장 배경 (Background)<a hidden class=anchor aria-hidden=true href=#등장-배경-background>#</a></h3><p>계층화된 네트워크 모델 (OSI, TCP/IP) 은 시스템 간 통신을 표준화하고, 확장성과 신뢰성을 높이기 위해 개발되었다. 각 계층의 PDU 는 이러한 설계 원칙에 따라 독립적으로 정의되며, 계층 간 인터페이스 및 프로토콜 동작을 명확하게 한다.</p><ul><li>1970 년대 초기 네트워크는 단일 프로토콜 (예: ARPANET NCP) 로 구성되어 확장성과 상호운용성에 한계가 있었다.</li><li>1974 년 Vint Cerf 와 Bob Kahn 의 TCP/IP 설계</li><li>1984 년 ISO 의 OSI 참조 모델 표준화를 통해 <strong>계층화된 프로토콜 스택</strong> 개념이 정립되었다.</li></ul><p>각 계층이 독립적으로 PDU 를 정의함으로써, 하드웨어·소프트웨어 변경 시에도 상·하위 계층에 영향을 최소화하고, 이기종 네트워크 간 상호운용성을 확보할 수 있게 되었다.<br>이후 이더넷 (IEEE 802.3), Wi-Fi(IEEE 802.11), MPLS, VXLAN 등 다양한 프로토콜이 PDU 구조를 기반으로 발전했다.</p><h3 id=해결하려는-문제-problem>해결하려는 문제 (Problem)<a hidden class=anchor aria-hidden=true href=#해결하려는-문제-problem>#</a></h3><p>PDU 개념은 데이터 통신에서 계층 간 정보 전송의 불명확성, 데이터 포장 과정의 오류, 프로토콜 혼동 문제를 해결하고, 계층마다 일관된 데이터 단위 관리와 에러 검출/복구를 가능하게 한다.</p><p><strong>Before PDU 개념 도입</strong>:</p><ul><li>단일 프로토콜로 모든 기능 (주소 지정, 라우팅, 오류 제어, 흐름 제어) 을 처리 → 복잡도 증가, 변경 어려움</li><li>이기종 네트워크 연결 시 전체 프로토콜 재설계 필요</li><li>네트워크 문제 발생 시 원인 계층 파악 곤란</li></ul><p><strong>After PDU 개념 도입</strong>:</p><ul><li>각 계층이 명확한 PDU 와 인터페이스를 정의 → 역할 분리, 모듈화</li><li>새로운 프로토콜 추가·교체 시 해당 계층만 수정 → 유연성 향상</li><li>계층별 PDU 헤더 분석으로 문제 원인 계층 신속 식별 → 트러블슈팅 효율화</li><li>방화벽·QoS·SDN 등 네트워크 제어 정책을 계층별 헤더 기반으로 구현 가능</li></ul><h3 id=흔한-오해-misconceptions>흔한 오해 (Misconceptions)<a hidden class=anchor aria-hidden=true href=#흔한-오해-misconceptions>#</a></h3><h4 id=오해-1-pdu-는-모든-계층에서--패킷--으로-부른다>오해 1: PDU 는 모든 계층에서 &rsquo; 패킷 &rsquo; 으로 부른다<a hidden class=anchor aria-hidden=true href=#오해-1-pdu-는-모든-계층에서--패킷--으로-부른다>#</a></h4><p><strong>오해</strong>: 데이터 전송 단위를 모두 &rsquo; 패킷 &rsquo; 으로 지칭한다<br><strong>원인</strong>: 네트워크 용어의 일반화/간소화<br><strong>반례</strong>: 전송 계층은 &rsquo; 세그먼트 &lsquo;(TCP), 네트워크 계층 (Layer 3) 은 &rsquo; 패킷 &lsquo;, 프레임 (Layer 2), 세그먼트 (Layer 4) 이라 불린다<br><strong>올바른 개념</strong>: PDU 는 각 계층별 데이터 단위의 총칭이고, 패킷은 그 중 네트워크 계층 (IP) PDU 를 가리킨다.</p><h4 id=오해-2-pdu-는-원래-데이터와-별개로-존재한다>오해 2: PDU 는 원래 데이터와 별개로 존재한다<a hidden class=anchor aria-hidden=true href=#오해-2-pdu-는-원래-데이터와-별개로-존재한다>#</a></h4><p><strong>오해</strong>: PDU 와 원래 데이터가 별도의 단위로 간주된다<br><strong>원인</strong>: 헤더와 페이로드 구분 개념의 오해<br><strong>반례</strong>: PDU 는 항상 각각의 계층 데이터 (=SDU) 와 해당 계층 제어정보가 결합된 전체 메시지이다<br><strong>올바른 개념</strong>: PDU = 상위 계층 데이터 (SDU) + 현재 계층 제어정보</p><h4 id=오해-3-헤더만-추가하면-pdu-가-된다>오해 3: 헤더만 추가하면 PDU 가 된다<a hidden class=anchor aria-hidden=true href=#오해-3-헤더만-추가하면-pdu-가-된다>#</a></h4><p><strong>오해</strong>: 헤더만 있으면 PDU 구조가 완성된다고 이해<br><strong>원인</strong>: 캡슐화 개념 학습 시 헤더 추가에만 집중<br><strong>반례</strong>: 데이터링크 계층 (예: 이더넷) 은 헤더뿐 아니라 트레일러 (FCS, Frame Check Sequence) 도 추가하며, 일부 프로토콜은 페이로드 패딩도 포함<br><strong>올바른 개념</strong>: PDU 는 헤더 + 페이로드 + (선택적) 트레일러로 구성되며, 계층별로 트레일러 유무와 패딩 규칙이 다르다.</p><h4 id=오해-4-상위-계층-pdu-는-하위-계층과-무관하다>오해 4: 상위 계층 PDU 는 하위 계층과 무관하다<a hidden class=anchor aria-hidden=true href=#오해-4-상위-계층-pdu-는-하위-계층과-무관하다>#</a></h4><p><strong>오해</strong>: 각 계층 PDU 는 완전히 독립적이므로 상호 영향이 없다<br><strong>원인</strong>: 계층 독립성 원칙을 절대적으로 해석<br><strong>반례</strong>: MTU(Maximum Transmission Unit) 제약, IP 단편화 (Fragmentation), TCP MSS(Maximum Segment Size) 조정 등 하위 계층의 물리적 제약이 상위 계층 PDU 크기에 직접 영향을 미침<br><strong>올바른 개념</strong>: 계층 간 독립성은 인터페이스 수준의 추상화이며, 성능·효율성 측면에서는 상·하위 계층 간 PDU 크기 협상과 최적화가 필수다.</p><h3 id=핵심-개념-정의용어-정합>핵심 개념 정의·용어 정합<a hidden class=anchor aria-hidden=true href=#핵심-개념-정의용어-정합>#</a></h3><p>PDU(Protocol Data Unit), SDU(Service Data Unit) 는 계층화 모델에서 각각 &rsquo; 동일 계층 간 송수신 단위 &rsquo; 와 &rsquo; 인접 계층간 전달 단위 &rsquo; 로 정의된다.<br>각 계층의 PDU 명칭, 구조, 역할을 명확히 구분해야 하며, 용어 혼동을 방지하는 것이 중요하다.</p><p><strong>사전 지식 (Prerequisites)</strong>:</p><ul><li>OSI 7 계층 모델, TCP/IP 4 계층 모델</li><li>네트워크 주소 체계 (MAC, IP, Port)</li><li>기본 네트워킹 용어 (라우팅, 스위칭, 패킷 교환)</li></ul><p><strong>핵심 용어</strong>:</p><ul><li><strong>Encapsulation(캡슐화)</strong>: 상위 계층 PDU 를 페이로드로 받아 헤더·트레일러를 추가하는 과정</li><li><strong>Decapsulation(역캡슐화)</strong>: 수신 측에서 하위→상위 순으로 헤더·트레일러를 제거하여 원본 데이터 복원</li><li><strong>Header(헤더)</strong>: PDU 앞부분에 추가되는 제어 정보 (주소, 순서 번호, 플래그 등)</li><li><strong>Trailer(트레일러)</strong>: PDU 뒷부분에 추가되는 제어 정보 (예: FCS, CRC)</li><li><strong>Payload(페이로드)</strong>: 상위 계층 PDU 또는 실제 사용자 데이터</li><li><strong>MTU(Maximum Transmission Unit)</strong>: 데이터링크 계층이 전송할 수 있는 최대 프레임 크기</li><li><strong>MSS(Maximum Segment Size)</strong>: TCP 세그먼트의 최대 페이로드 크기</li></ul><h2 id=계층별-pdu-구조-및-명칭>계층별 PDU 구조 및 명칭<a hidden class=anchor aria-hidden=true href=#계층별-pdu-구조-및-명칭>#</a></h2><p>OSI 7 계층과 TCP/IP 모델의 각 계층별 PDU 명칭, 헤더 구조, 주요 필드를 상세히 다룬다. 실무에서 가장 많이 사용되는 이더넷 프레임, IP 패킷, TCP 세그먼트를 중심으로 설명한다.</p><h3 id=osi-7-계층-pdu-매핑>OSI 7 계층 PDU 매핑<a hidden class=anchor aria-hidden=true href=#osi-7-계층-pdu-매핑>#</a></h3><table><thead><tr><th>OSI 계층</th><th style=text-align:center>계층 번호</th><th>PDU 명칭</th><th>주요 헤더 정보</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>물리 (Physical)</td><td style=text-align:center>1</td><td>비트 (Bit)</td><td>없음 (전기·광 신호)</td><td>Ethernet PHY, RS-232</td></tr><tr><td>데이터링크 (Data Link)</td><td style=text-align:center>2</td><td>프레임 (Frame)</td><td>MAC 주소 (출발지·목적지), FCS</td><td>Ethernet, Wi-Fi(802.11), PPP</td></tr><tr><td>네트워크 (Network)</td><td style=text-align:center>3</td><td>패킷 (Packet)</td><td>IP 주소 (출발지·목적지), TTL, 프로토콜 ID</td><td>IPv4, IPv6, ICMP</td></tr><tr><td>전송 (Transport)</td><td style=text-align:center>4</td><td>세그먼트 (Segment) / 데이터그램 (Datagram)</td><td>포트 번호 (출발지·목적지), 순서 번호, 체크섬</td><td>TCP, UDP, SCTP</td></tr><tr><td>세션 (Session)</td><td style=text-align:center>5</td><td>데이터 (Data)</td><td>세션 ID, 동기화 포인트</td><td>NetBIOS, RPC</td></tr><tr><td>표현 (Presentation)</td><td style=text-align:center>6</td><td>데이터 (Data)</td><td>인코딩, 암호화 정보</td><td>TLS, JPEG, MPEG</td></tr><tr><td>응용 (Application)</td><td style=text-align:center>7</td><td>메시지 (Message) / 데이터 (Data)</td><td>응용 프로토콜별 헤더</td><td>HTTP, DNS, SMTP, FTP</td></tr></tbody></table><ul><li>하위 3 계층 (1~3) 은 네트워크 인프라 계층으로, 주소 지정과 라우팅을 담당하며 PDU 명칭이 명확히 구분된다.</li><li>전송 계층 (4) 은 종단 간 연결 제어를 담당하며, TCP 는 세그먼트, UDP 는 데이터그램으로 구분된다.</li><li>상위 3 계층 (5~7) 은 OSI 모델에서는 각각 정의되지만, TCP/IP 모델에서는 응용 계층으로 통합되어 " 데이터 " 또는 " 메시지 " 로 통칭된다.</li></ul><pre class=mermaid>flowchart TD
    application-layer[&#34;application-layer(Data)&#34;]
    transport-layer[&#34;transport-layer(Segment/Datagram)&#34;]
    network-layer[&#34;network-layer(Packet)&#34;]
    datalink-layer[&#34;datalink-layer(Frame)&#34;]
    physical-layer[&#34;physical-layer(Bit)&#34;]

    application-layer --&gt; transport-layer
    transport-layer --&gt; network-layer
    network-layer --&gt; datalink-layer
    datalink-layer --&gt; physical-layer
</pre><p>&lt;OSI 7 계층에서의 PDU 흐름><br>상위 계층 데이터가 하위 계층으로 내려갈 때, 각 계층에서 헤더가 추가되어 계층별로 새로운 PDU 가 생성된다.<br>실제 송신시에는 physical 계층의 신호 (Bit) 로 변환된다.</p><h3 id=tcpip-모델-pdu-매핑>TCP/IP 모델 PDU 매핑<a hidden class=anchor aria-hidden=true href=#tcpip-모델-pdu-매핑>#</a></h3><p>TCP/IP 프로토콜 스택 구성과 각 계층 PDU 의 특징, 구조를 병렬 비교한다.</p><table><thead><tr><th>TCP/IP 계층</th><th>PDU 명칭</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>응용 (Application)</td><td>데이터 (Data)</td><td>HTTP, FTP, DNS</td></tr><tr><td>전송 (Transport)</td><td>세그먼트 (Segment)/데이터그램 (Datagram)</td><td>TCP, UDP</td></tr><tr><td>인터넷 (Internet)</td><td>패킷 (Packet)</td><td>IP</td></tr><tr><td>네트워크 액세스 (Link)</td><td>프레임 (Frame)</td><td>Ethernet, Wi-Fi</td></tr></tbody></table><p>&lt;TCP/IP 모델 계층별 PDU 비교><br>TCP/IP 스택에서는 OSI 에 비해 계층 수가 적지만, 각 계층의 PDU 명칭과 실제 동작 방식은 OSI 와 거의 동일하다. 또한 네트워크 장비나 툴에서 각 PDU 명칭을 올바르게 사용하는 것이 중요하다.</p><pre class=mermaid>graph TD
    A[응용 계층&lt;br&gt;Application Layer] --&gt;|데이터/메시지&lt;br&gt;Data/Message| B[전송 계층&lt;br&gt;Transport Layer]
    B --&gt;|세그먼트Segment or 데이터그램Datagram| C[인터넷 계층&lt;br&gt;Internet Layer]
    C --&gt;|패킷Packet| D[네트워크 접근 계층&lt;br&gt;Network Access Layer]
    D --&gt;|프레임Frame| E[물리 매체&lt;br&gt;Physical Medium]
    E --&gt;|비트Bit| F[네트워크 전송]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
    style E fill:#f5e1ff
</pre><p>TCP/IP 4 계층 모델은 OSI 모델을 단순화하여, 응용 (5<del>7 계층 통합), 전송 (4 계층), 인터넷 (3 계층), 네트워크 접근 (1</del>2 계층 통합) 으로 구성된다.<br>각 계층은 상위 PDU 를 페이로드로 받아 자신의 헤더를 추가하며, 최하위 네트워크 접근 계층에서 프레임으로 캡슐화된 후 비트 스트림으로 전송된다. 이 도식은 실무에서 가장 많이 사용되는 모델로, 인터넷 프로토콜 스택의 핵심 구조를 나타낸다.</p><h3 id=이더넷-프레임-구조-layer-2-pdu>이더넷 프레임 구조 (Layer 2 PDU)<a hidden class=anchor aria-hidden=true href=#이더넷-프레임-구조-layer-2-pdu>#</a></h3><table><thead><tr><th>필드</th><th style=text-align:center>크기 (바이트)</th><th>설명</th></tr></thead><tbody><tr><td>Preamble</td><td style=text-align:center>7</td><td>프레임 시작 신호 (10101010 패턴)</td></tr><tr><td>SFD(Start Frame Delimiter)</td><td style=text-align:center>1</td><td>프레임 시작 (10101011)</td></tr><tr><td>Destination MAC</td><td style=text-align:center>6</td><td>목적지 MAC 주소</td></tr><tr><td>Source MAC</td><td style=text-align:center>6</td><td>출발지 MAC 주소</td></tr><tr><td>Type/Length</td><td style=text-align:center>2</td><td>상위 프로토콜 타입 (예: 0x0800=IPv4) 또는 페이로드 길이</td></tr><tr><td>Payload</td><td style=text-align:center>46~1500</td><td>상위 계층 PDU(IP 패킷 등)</td></tr><tr><td>FCS(Frame Check Sequence)</td><td style=text-align:center>4</td><td>CRC-32 오류 검출</td></tr></tbody></table><p><strong>코드 예시: Python 으로 이더넷 프레임 파싱</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_ethernet_frame</span><span class=p>(</span><span class=n>frame_bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이더넷 프레임을 파싱하여 주요 필드 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: frame_bytes (bytes) - 이더넷 프레임 바이트 스트림
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 파싱된 필드 딕셔너리
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 최소 길이 검증 (Preamble·SFD 제외 시 64바이트)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>frame_bytes</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>64</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Invalid frame length&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Preamble·SFD는 물리 계층에서 제거되므로 보통 Wireshark 등에서는 보이지 않음</span>
</span></span><span class=line><span class=cl>    <span class=c1># 여기서는 Destination MAC부터 시작한다고 가정</span>
</span></span><span class=line><span class=cl>    <span class=n>dst_mac</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>6</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>src_mac</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>6</span><span class=p>:</span><span class=mi>12</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_type</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!H&#39;</span><span class=p>,</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>12</span><span class=p>:</span><span class=mi>14</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Big-endian 2바이트</span>
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=mi>14</span><span class=p>:</span><span class=o>-</span><span class=mi>4</span><span class=p>]</span>  <span class=c1># FCS 4바이트 제외</span>
</span></span><span class=line><span class=cl>    <span class=n>fcs</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!I&#39;</span><span class=p>,</span> <span class=n>frame_bytes</span><span class=p>[</span><span class=o>-</span><span class=mi>4</span><span class=p>:])[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;dst_mac&#39;</span><span class=p>:</span> <span class=n>dst_mac</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;src_mac&#39;</span><span class=p>:</span> <span class=n>src_mac</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;type&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>eth_type</span><span class=p>),</span>  <span class=c1># 예: 0x0800 (IPv4), 0x86dd (IPv6)</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;payload_len&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>payload</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;fcs&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>fcs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 프레임 (간략화, 실제는 Wireshark 캡처 데이터 사용)</span>
</span></span><span class=line><span class=cl><span class=c1># 예: dst_mac=ff:ff:ff:ff:ff:ff, src_mac=00:11:22:33:44:55, type=0x0800, payload=46바이트, FCS=임의</span>
</span></span><span class=line><span class=cl><span class=n>example_frame</span> <span class=o>=</span> <span class=nb>bytes</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;ffffffffffff001122334455080000450000…&#39;</span> <span class=o>+</span> <span class=s1>&#39;12345678&#39;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 실제 사용 시: result = parse_ethernet_frame(example_frame)</span>
</span></span></code></pre></td></tr></table></div></div><p>이더넷 프레임은 데이터링크 계층 PDU 로, MAC 주소 기반 스위칭을 위한 헤더와 오류 검출을 위한 FCS 트레일러를 포함한다.<br>Type/Length 필드 (2 바이트) 는 상위 프로토콜 (예: IPv4=0x0800, ARP=0x0806) 을 식별하며, Payload 는 46~1500 바이트 범위를 가진다 (MTU=1518 바이트, Jumbo Frame 은 9000 바이트까지 확장 가능). FCS 는 CRC-32 알고리즘으로 프레임 전체의 무결성을 검증한다.</p><h3 id=ip-패킷-구조-layer-3-pdu>IP 패킷 구조 (Layer 3 PDU)<a hidden class=anchor aria-hidden=true href=#ip-패킷-구조-layer-3-pdu>#</a></h3><p><strong>IPv4 헤더 주요 필드</strong>:</p><table><thead><tr><th>필드</th><th style=text-align:center>크기 (비트)</th><th>설명</th></tr></thead><tbody><tr><td>Version</td><td style=text-align:center>4</td><td>IP 버전 (4)</td></tr><tr><td>IHL(Internet Header Length)</td><td style=text-align:center>4</td><td>헤더 길이 (4 바이트 단위, 최소 5=20 바이트)</td></tr><tr><td>DSCP/ECN</td><td style=text-align:center>8</td><td>서비스 품질 (QoS) 및 혼잡 제어</td></tr><tr><td>Total Length</td><td style=text-align:center>16</td><td>헤더 + 페이로드 전체 길이 (최대 65535 바이트)</td></tr><tr><td>Identification</td><td style=text-align:center>16</td><td>단편화 시 원본 패킷 식별자</td></tr><tr><td>Flags + Fragment Offset</td><td style=text-align:center>16</td><td>단편화 제어 (DF, MF 플래그 및 오프셋)</td></tr><tr><td>TTL(Time To Live)</td><td style=text-align:center>8</td><td>라우팅 홉 제한 (0 도달 시 패킷 폐기)</td></tr><tr><td>Protocol</td><td style=text-align:center>8</td><td>상위 프로토콜 (6=TCP, 17=UDP, 1=ICMP)</td></tr><tr><td>Header Checksum</td><td style=text-align:center>16</td><td>헤더 오류 검출 (페이로드 제외)</td></tr><tr><td>Source IP</td><td style=text-align:center>32</td><td>출발지 IPv4 주소</td></tr><tr><td>Destination IP</td><td style=text-align:center>32</td><td>목적지 IPv4 주소</td></tr><tr><td>Options</td><td style=text-align:center>가변</td><td>선택적 필드 (보안, 라우팅 기록 등)</td></tr></tbody></table><p><strong>IP 패킷 캡슐화 플로우</strong></p><pre class=mermaid>sequenceDiagram
    participant App as 응용 계층
    participant TCP as 전송 계층(TCP)
    participant IP as 네트워크 계층(IP)
    participant DL as 데이터링크 계층
    
    App-&gt;&gt;TCP: 데이터 전송 요청
    TCP-&gt;&gt;TCP: 세그먼트 생성&lt;br&gt;(헤더 추가: 출발지·목적지 포트)
    TCP-&gt;&gt;IP: 세그먼트 전달
    IP-&gt;&gt;IP: 패킷 생성&lt;br&gt;(헤더 추가: 출발지·목적지 IP, TTL)
    IP-&gt;&gt;DL: 패킷 전달
    DL-&gt;&gt;DL: 프레임 생성&lt;br&gt;(헤더·트레일러 추가: MAC 주소, FCS)
    DL-&gt;&gt;DL: 물리 매체로 비트 전송
</pre><p>IP 패킷은 네트워크 계층 PDU 로, 출발지·목적지 IP 주소, TTL, 프로토콜 ID 등을 포함한다.<br>TTL 은 라우팅 루프 방지를 위해 각 라우터를 거칠 때마다 1 씩 감소하며, 0 도달 시 패킷이 폐기된다.<br>Identification, Flags, Fragment Offset 필드는 MTU 초과 시 패킷 단편화와 재조립에 사용된다. Header Checksum 은 헤더만 검증하며, 페이로드 무결성은 상위 계층 (예: TCP 체크섬) 이 담당한다.</p><h3 id=tcp-세그먼트-구조-layer-4-pdu>TCP 세그먼트 구조 (Layer 4 PDU)<a hidden class=anchor aria-hidden=true href=#tcp-세그먼트-구조-layer-4-pdu>#</a></h3><p><strong>TCP 헤더 주요 필드</strong>:</p><table><thead><tr><th>필드</th><th style=text-align:center>크기 (비트)</th><th>설명</th></tr></thead><tbody><tr><td>Source Port</td><td style=text-align:center>16</td><td>출발지 포트 번호 (0~65535)</td></tr><tr><td>Destination Port</td><td style=text-align:center>16</td><td>목적지 포트 번호</td></tr><tr><td>Sequence Number</td><td style=text-align:center>32</td><td>세그먼트 순서 번호 (재조립용)</td></tr><tr><td>Acknowledgment Number</td><td style=text-align:center>32</td><td>수신 확인 번호 (다음 기대 순서)</td></tr><tr><td>Data Offset</td><td style=text-align:center>4</td><td>TCP 헤더 길이 (4 바이트 단위, 최소 5=20 바이트)</td></tr><tr><td>Flags</td><td style=text-align:center>9</td><td>제어 플래그 (SYN, ACK, FIN, RST, PSH, URG 등)</td></tr><tr><td>Window Size</td><td style=text-align:center>16</td><td>수신 윈도우 크기 (흐름 제어)</td></tr><tr><td>Checksum</td><td style=text-align:center>16</td><td>헤더 + 페이로드 + 의사 헤더 오류 검출</td></tr><tr><td>Urgent Pointer</td><td style=text-align:center>16</td><td>긴급 데이터 포인터 (URG 플래그 설정 시)</td></tr><tr><td>Options</td><td style=text-align:center>가변</td><td>선택적 필드 (MSS, Window Scale, SACK 등)</td></tr></tbody></table><p><strong>코드 예시: Python 으로 TCP 세그먼트 파싱</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_tcp_segment</span><span class=p>(</span><span class=n>segment_bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    TCP 세그먼트를 파싱하여 주요 필드 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: segment_bytes (bytes) - TCP 세그먼트 바이트 스트림
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 파싱된 필드 딕셔너리
</span></span></span><span class=line><span class=cl><span class=s2>    에러케이스: 최소 길이(20바이트) 미만 시 ValueError
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>segment_bytes</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;TCP segment too short&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Big-endian 형식으로 헤더 파싱</span>
</span></span><span class=line><span class=cl>    <span class=n>src_port</span><span class=p>,</span> <span class=n>dst_port</span><span class=p>,</span> <span class=n>seq</span><span class=p>,</span> <span class=n>ack</span><span class=p>,</span> <span class=n>offset_flags</span><span class=p>,</span> <span class=n>window</span><span class=p>,</span> <span class=n>checksum</span><span class=p>,</span> <span class=n>urg_ptr</span> <span class=o>=</span> \
</span></span><span class=line><span class=cl>        <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span><span class=s1>&#39;!HHIIHHH&#39;</span><span class=p>,</span> <span class=n>segment_bytes</span><span class=p>[:</span><span class=mi>20</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Data Offset은 상위 4비트(4바이트 단위)</span>
</span></span><span class=line><span class=cl>    <span class=n>header_len</span> <span class=o>=</span> <span class=p>(</span><span class=n>offset_flags</span> <span class=o>&gt;&gt;</span> <span class=mi>12</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=c1># Flags는 하위 9비트 (NS=1, CWR=1, ECE=1, URG=1, ACK=1, PSH=1, RST=1, SYN=1, FIN=1)</span>
</span></span><span class=line><span class=cl>    <span class=n>flags</span> <span class=o>=</span> <span class=n>offset_flags</span> <span class=o>&amp;</span> <span class=mh>0x01FF</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>payload</span> <span class=o>=</span> <span class=n>segment_bytes</span><span class=p>[</span><span class=n>header_len</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;src_port&#39;</span><span class=p>:</span> <span class=n>src_port</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;dst_port&#39;</span><span class=p>:</span> <span class=n>dst_port</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;seq&#39;</span><span class=p>:</span> <span class=n>seq</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;ack&#39;</span><span class=p>:</span> <span class=n>ack</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;header_len&#39;</span><span class=p>:</span> <span class=n>header_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;flags&#39;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;SYN&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x02</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;ACK&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;FIN&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x01</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;RST&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x04</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;PSH&#39;</span><span class=p>:</span> <span class=nb>bool</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=mh>0x08</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;window&#39;</span><span class=p>:</span> <span class=n>window</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;checksum&#39;</span><span class=p>:</span> <span class=nb>hex</span><span class=p>(</span><span class=n>checksum</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;payload_len&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시: SYN 세그먼트 (간략화)</span>
</span></span><span class=line><span class=cl><span class=c1># src=12345, dst=80, seq=1000, ack=0, flags=SYN, window=65535</span>
</span></span><span class=line><span class=cl><span class=n>example_tcp</span> <span class=o>=</span> <span class=nb>bytes</span><span class=o>.</span><span class=n>fromhex</span><span class=p>(</span><span class=s1>&#39;30390050000003e8000000005002ffff0000&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 실제 사용 시: result = parse_tcp_segment(example_tcp)</span>
</span></span></code></pre></td></tr></table></div></div><p>TCP 세그먼트는 전송 계층 PDU 로, 포트 번호를 통해 응용 프로세스를 식별하고, 순서 번호와 확인 번호로 신뢰성 있는 데이터 전송을 구현한다.<br>Flags 필드는 연결 설정 (SYN), 확인 (ACK), 종료 (FIN), 재설정 (RST) 등 제어 기능을 담당하며, Window Size 는 TCP 흐름 제어를 위한 수신 버퍼 크기를 알린다. Options 필드는 MSS(Maximum Segment Size), Window Scale, SACK(Selective Acknowledgment) 등 성능 최적화 파라미터를 협상한다.</p><h3 id=대표-pdu-형식-빠르게-보기>대표 PDU 형식 빠르게 보기<a hidden class=anchor aria-hidden=true href=#대표-pdu-형식-빠르게-보기>#</a></h3><p><strong>표 4-1. 필수 필드 스냅샷</strong></p><table><thead><tr><th>프로토콜</th><th>핵심 필드 (일부)</th><th>체크섬/검증</th><th>특이점</th></tr></thead><tbody><tr><td>Ethernet II</td><td>DA/SA, EtherType, FCS</td><td>FCS(32-bit CRC)</td><td>최소 64B 프레임, 점보 가능</td></tr><tr><td>IPv4</td><td>Version/IHL, TotalLen, ID/Flags/FragOff, TTL, Proto, HdrChk</td><td>헤더 체크섬</td><td>중간 단편화 허용</td></tr><tr><td>IPv6</td><td>Version, Traffic Class, Flow Label, PayloadLen, NextHdr, HopLimit</td><td>무 (상위에서)</td><td>확장헤더 체인, MTU 최소 1280</td></tr><tr><td>TCP</td><td>Ports, Seq/Ack, Flags, Window, Checksum, Options</td><td>의무</td><td>신뢰·흐름·혼잡제어</td></tr><tr><td>UDP</td><td>Ports, Length, Checksum</td><td>IPv6 에서 의무</td><td>저오버헤드</td></tr><tr><td>TLS 1.3</td><td>ContentType, Length(+AEAD Tag)</td><td>AEAD</td><td>0-RTT/암호화 가시성 제한</td></tr><tr><td>QUIC</td><td>DCID/SCID, Pn, Frames(varint)</td><td>AEAD</td><td>사용자 공간, 연결이동/멀티플렉싱</td></tr><tr><td>SCTP</td><td>Verification Tag, TSN, Streams, Chunks</td><td>CRC32c</td><td>멀티스트림/멀티홈</td></tr></tbody></table><p>필드 존재와 검증 방식이 PDU 의 신뢰·오버헤드·가시성을 좌우한다. 예컨대 IPv6 는 헤더 체크섬을 제거해 라우터 처리 비용을 낮췄으며, QUIC/TLS 는 암호화로 중간 가시성을 줄여 상위 진단 기법이 요구된다.</p><p><strong>Python 스니펫 4-B—20 바이트 IPv4 고정헤더 파서 (학습용)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 목적: 바이트열에서 IPv4 고정 헤더(20B)를 파싱하여 핵심 필드 추출</span>
</span></span><span class=line><span class=cl><span class=c1># 입력: bytes(길이&gt;=20)</span>
</span></span><span class=line><span class=cl><span class=c1># 출력: dict</span>
</span></span><span class=line><span class=cl><span class=c1># 예외: 길이/버전 오류 발생 시 ValueError</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>struct</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_ipv4_header</span><span class=p>(</span><span class=n>buf</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;short buffer&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vihl</span><span class=p>,</span> <span class=n>tos</span><span class=p>,</span> <span class=n>total_len</span><span class=p>,</span> <span class=n>ident</span><span class=p>,</span> <span class=n>flags_frag</span><span class=p>,</span> <span class=n>ttl</span><span class=p>,</span> <span class=n>proto</span><span class=p>,</span> <span class=n>hdr_chk</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>dst</span> <span class=o>=</span> <span class=n>struct</span><span class=o>.</span><span class=n>unpack</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;!BBHHHBBHII&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>[:</span><span class=mi>20</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span> <span class=o>=</span> <span class=n>vihl</span> <span class=o>&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=n>ihl</span> <span class=o>=</span> <span class=p>(</span><span class=n>vihl</span> <span class=o>&amp;</span> <span class=mh>0x0F</span><span class=p>)</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>version</span> <span class=o>!=</span> <span class=mi>4</span> <span class=ow>or</span> <span class=n>ihl</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;invalid IPv4 header&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>flags</span> <span class=o>=</span> <span class=p>(</span><span class=n>flags_frag</span> <span class=o>&gt;&gt;</span> <span class=mi>13</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0x7</span>
</span></span><span class=line><span class=cl>    <span class=n>frag_off</span> <span class=o>=</span> <span class=n>flags_frag</span> <span class=o>&amp;</span> <span class=mh>0x1FFF</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;version&#34;</span><span class=p>:</span> <span class=n>version</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ihl&#34;</span><span class=p>:</span> <span class=n>ihl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;total_len&#34;</span><span class=p>:</span> <span class=n>total_len</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=n>ident</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;flags&#34;</span><span class=p>:</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;frag_off&#34;</span><span class=p>:</span> <span class=n>frag_off</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ttl&#34;</span><span class=p>:</span> <span class=n>ttl</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;proto&#34;</span><span class=p>:</span> <span class=n>proto</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;hdr_checksum&#34;</span><span class=p>:</span> <span class=n>hdr_chk</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;src&#34;</span><span class=p>:</span> <span class=n>src</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;dst&#34;</span><span class=p>:</span> <span class=n>dst</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>해설: 교육 목적의 최소 파서로, 옵션/확장 미처리·체크섬 재계산은 생략했다. 실제 구현은 경계검사, 옵션 파싱, 조각 재조립, 보안 처리까지 필요하다.</p><h2 id=캡슐화와-역캡슐화-메커니즘>캡슐화와 역캡슐화 메커니즘<a hidden class=anchor aria-hidden=true href=#캡슐화와-역캡슐화-메커니즘>#</a></h2><p>PDU 의 핵심 동작 원리인 캡슐화 (Encapsulation) 와 역캡슐화 (Decapsulation) 과정을 상세히 다룬다.<br>송·수신 측의 계층별 처리 흐름과 실무 네트워크 장비 (라우터, 스위치) 의 PDU 조작 방식을 설명한다.</p><h3 id=캡슐화-과정-encapsulation>캡슐화 과정 (Encapsulation)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-encapsulation>#</a></h3><p><strong>정의</strong>: 송신 측에서 상위 계층 PDU 를 페이로드로 받아, 각 계층의 헤더 (및 트레일러) 를 추가하여 하위 계층 PDU 를 생성하는 과정.</p><p><strong>단계별 흐름</strong>:</p><pre class=mermaid>graph LR
    A[응용 데이터&lt;br&gt;Application Data] --&gt;|전송 계층| B[TCP 세그먼트&lt;br&gt;TCP Header + Data]
    B --&gt;|네트워크 계층| C[IP 패킷&lt;br&gt;IP Header + Segment]
    C --&gt;|데이터링크 계층| D[이더넷 프레임&lt;br&gt;Ethernet Header + Packet + FCS]
    D --&gt;|물리 계층| E[비트 스트림&lt;br&gt;Bit Stream]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#e1ffe1
    style E fill:#f5e1ff
</pre><p><strong>표: 계층별 캡슐화 단계</strong></p><table><thead><tr><th>계층</th><th>입력 (상위 PDU)</th><th>추가 정보</th><th>출력 (현 계층 PDU)</th><th>예시 프로토콜</th></tr></thead><tbody><tr><td>응용 (7)</td><td>사용자 데이터</td><td>HTTP 헤더</td><td>HTTP 요청/응답</td><td>HTTP, DNS</td></tr><tr><td>전송 (4)</td><td>HTTP 메시지</td><td>TCP 헤더 (포트, 순서 번호)</td><td>TCP 세그먼트</td><td>TCP</td></tr><tr><td>네트워크 (3)</td><td>TCP 세그먼트</td><td>IP 헤더 (출발지·목적지 IP)</td><td>IP 패킷</td><td>IPv4</td></tr><tr><td>데이터링크 (2)</td><td>IP 패킷</td><td>이더넷 헤더 (MAC 주소) + FCS</td><td>이더넷 프레임</td><td>Ethernet</td></tr><tr><td>물리 (1)</td><td>이더넷 프레임</td><td>전기·광 신호 변환</td><td>비트 스트림</td><td>1000BASE-T</td></tr></tbody></table><p><strong>코드 예시: Python 으로 간단한 캡슐화 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>encapsulate_data</span><span class=p>(</span><span class=n>app_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    응용 데이터를 계층별로 캡슐화하는 시뮬레이션
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: app_data (str) - 응용 계층 데이터
</span></span></span><span class=line><span class=cl><span class=s2>    출력: dict - 각 계층별 PDU
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 응용 계층 (예: HTTP GET 요청)</span>
</span></span><span class=line><span class=cl>    <span class=n>http_header</span> <span class=o>=</span> <span class=s2>&#34;GET /index.html HTTP/1.1</span><span class=se>\r\n</span><span class=s2>Host: example.com</span><span class=se>\r\n\r\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>http_pdu</span> <span class=o>=</span> <span class=n>http_header</span> <span class=o>+</span> <span class=n>app_data</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 전송 계층 (TCP 헤더 간략화: 포트 번호만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_PORT=12345|DST_PORT=80|SEQ=1000|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_segment</span> <span class=o>=</span> <span class=n>tcp_header</span> <span class=o>+</span> <span class=n>http_pdu</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 네트워크 계층 (IP 헤더 간략화: IP 주소만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_IP=192.168.1.100|DST_IP=93.184.216.34|TTL=64|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_packet</span> <span class=o>=</span> <span class=n>ip_header</span> <span class=o>+</span> <span class=n>tcp_segment</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 데이터링크 계층 (이더넷 헤더 간략화: MAC 주소만 표시)</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_header</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SRC_MAC=00:11:22:33:44:55|DST_MAC=AA:BB:CC:DD:EE:FF|TYPE=0x0800|&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>eth_trailer</span> <span class=o>=</span> <span class=s2>&#34;|FCS=0x12345678&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ethernet_frame</span> <span class=o>=</span> <span class=n>eth_header</span> <span class=o>+</span> <span class=n>ip_packet</span> <span class=o>+</span> <span class=n>eth_trailer</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;application&#39;</span><span class=p>:</span> <span class=n>http_pdu</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;transport&#39;</span><span class=p>:</span> <span class=n>tcp_segment</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;network&#39;</span><span class=p>:</span> <span class=n>ip_packet</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;data_link&#39;</span><span class=p>:</span> <span class=n>ethernet_frame</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 실행</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>encapsulate_data</span><span class=p>(</span><span class=s2>&#34;Hello, World!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 출력: result[&#39;data_link&#39;]에 전체 캡슐화된 프레임 포함</span>
</span></span></code></pre></td></tr></table></div></div><p>캡슐화는 상위→하위 방향으로 진행되며, 각 계층은 상위 PDU 전체를 " 불투명한 페이로드 " 로 취급한다. 예를 들어, 네트워크 계층 (IP) 은 TCP 세그먼트의 내부 구조를 알 필요 없이 헤더만 추가하여 패킷을 생성한다. 이는 계층 간 독립성과 확장성을 보장한다. 실무에서는 네트워크 스택 (예: Linux kernel 의 <code>sk_buff</code> 구조체) 이 각 계층에서 헤더를 prepend 하는 방식으로 구현된다.</p><h3 id=역캡슐화-과정-decapsulation>역캡슐화 과정 (Decapsulation)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-decapsulation>#</a></h3><p><strong>정의</strong>: 수신 측에서 하위 계층 PDU 로부터 헤더 (및 트레일러) 를 제거하여 상위 계층 PDU 를 복원하는 과정.</p><p><strong>단계별 흐름</strong>:</p><pre class=mermaid>graph LR
    A[비트 스트림&lt;br&gt;Bit Stream] --&gt;|물리 계층| B[이더넷 프레임&lt;br&gt;Ethernet Frame]
    B --&gt;|데이터링크 계층| C[IP 패킷&lt;br&gt;IP Packet]
    C --&gt;|네트워크 계층| D[TCP 세그먼트&lt;br&gt;TCP Segment]
    D --&gt;|전송 계층| E[응용 데이터&lt;br&gt;Application Data]
    
    style A fill:#f5e1ff
    style B fill:#e1ffe1
    style C fill:#ffe1f5
    style D fill:#fff4e1
    style E fill:#e1f5ff
</pre><p><strong>표: 계층별 역캡슐화 단계</strong></p><table><thead><tr><th>계층</th><th>입력 (하위 PDU)</th><th>제거 정보</th><th>출력 (상위 PDU)</th><th>검증 사항</th></tr></thead><tbody><tr><td>물리 (1)</td><td>비트 스트림</td><td>신호 복조</td><td>이더넷 프레임</td><td>프리앰블·SFD 확인</td></tr><tr><td>데이터링크 (2)</td><td>이더넷 프레임</td><td>이더넷 헤더 + FCS</td><td>IP 패킷</td><td>FCS 검증, MAC 주소 필터링</td></tr><tr><td>네트워크 (3)</td><td>IP 패킷</td><td>IP 헤더</td><td>TCP 세그먼트</td><td>Header Checksum, TTL 확인</td></tr><tr><td>전송 (4)</td><td>TCP 세그먼트</td><td>TCP 헤더</td><td>HTTP 메시지</td><td>TCP Checksum, 순서 번호 확인</td></tr><tr><td>응용 (7)</td><td>HTTP 메시지</td><td>HTTP 헤더</td><td>사용자 데이터</td><td>응용 프로토콜 규칙 검증</td></tr></tbody></table><p><strong>코드 예시: Python 으로 간단한 역캡슐화 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26>26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27>27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28>28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29>29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30>30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31>31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32>32</a>
</span><span class=lnt id=hl-9-33><a class=lnlinks href=#hl-9-33>33</a>
</span><span class=lnt id=hl-9-34><a class=lnlinks href=#hl-9-34>34</a>
</span><span class=lnt id=hl-9-35><a class=lnlinks href=#hl-9-35>35</a>
</span><span class=lnt id=hl-9-36><a class=lnlinks href=#hl-9-36>36</a>
</span><span class=lnt id=hl-9-37><a class=lnlinks href=#hl-9-37>37</a>
</span><span class=lnt id=hl-9-38><a class=lnlinks href=#hl-9-38>38</a>
</span><span class=lnt id=hl-9-39><a class=lnlinks href=#hl-9-39>39</a>
</span><span class=lnt id=hl-9-40><a class=lnlinks href=#hl-9-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>decapsulate_frame</span><span class=p>(</span><span class=n>ethernet_frame</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이더넷 프레임을 역캡슐화하여 응용 데이터 추출
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력: ethernet_frame (str) - 캡슐화된 이더넷 프레임
</span></span></span><span class=line><span class=cl><span class=s2>    출력: str - 응용 계층 데이터
</span></span></span><span class=line><span class=cl><span class=s2>    에러케이스: FCS 불일치 시 None 반환
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 데이터링크 계층: 이더넷 헤더·트레일러 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;|FCS=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>ethernet_frame</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>  <span class=c1># FCS 없음 → 손상된 프레임</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># FCS 검증 (간략화: 단순 존재 확인)</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>ethernet_frame</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|TYPE=0x0800|&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>parts</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>ip_packet</span> <span class=o>=</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|FCS=&#34;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 네트워크 계층: IP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;SRC_IP=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>ip_packet</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>tcp_segment</span> <span class=o>=</span> <span class=n>ip_packet</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|TTL=64|&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 전송 계층: TCP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;SRC_PORT=&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>tcp_segment</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>http_pdu</span> <span class=o>=</span> <span class=n>tcp_segment</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;|SEQ=1000|&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 응용 계층: HTTP 헤더 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;HTTP/1.1&#34;</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>http_pdu</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>app_data</span> <span class=o>=</span> <span class=n>http_pdu</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\r\n\r\n</span><span class=s2>&#34;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>app_data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 실행 (캡슐화 결과를 역캡슐화)</span>
</span></span><span class=line><span class=cl><span class=n>original_data</span> <span class=o>=</span> <span class=s2>&#34;Hello, World!&#34;</span>
</span></span><span class=line><span class=cl><span class=n>encapsulated</span> <span class=o>=</span> <span class=n>encapsulate_data</span><span class=p>(</span><span class=n>original_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>recovered_data</span> <span class=o>=</span> <span class=n>decapsulate_frame</span><span class=p>(</span><span class=n>encapsulated</span><span class=p>[</span><span class=s1>&#39;data_link&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>recovered_data</span> <span class=o>==</span> <span class=n>original_data</span>  <span class=c1># 검증: 원본 데이터 복원 확인</span>
</span></span></code></pre></td></tr></table></div></div><p>역캡슐화는 하위→상위 방향으로 진행되며, 각 계층은 자신의 헤더를 제거하고 상위 계층으로 페이로드를 전달한다. 데이터링크 계층에서는 FCS 검증을 통해 프레임 무결성을 확인하고, 네트워크 계층에서는 Header Checksum 과 TTL 을 검사하며, 전송 계층에서는 TCP Checksum 과 순서 번호를 확인한다. 검증 실패 시 해당 PDU 는 폐기되고 상위 계층으로 전달되지 않는다.</p><h3 id=네트워크-장비의-pdu-처리>네트워크 장비의 PDU 처리<a hidden class=anchor aria-hidden=true href=#네트워크-장비의-pdu-처리>#</a></h3><table><thead><tr><th>장비</th><th>계층 (주요)</th><th>관찰/처리 PDU</th><th>핵심 동작</th><th>헤더/필드 처리</th><th>장점</th><th>주의/한계</th><th>대표 시나리오</th></tr></thead><tbody><tr><td><strong>라우터 (Router)</strong></td><td>L3</td><td>IP <strong>패킷</strong></td><td>목적지 IP 기준 라우팅 테이블 조회 후 <strong>다음 홉</strong> 결정, 역캡슐화→재캡슐화</td><td><strong>TTL/Hop Limit −1</strong>, <strong>IPv4 헤더 체크섬 재계산</strong>(IPv6 은 없음), <strong>새 L2 헤더</strong>(다음 홉 MAC) 부여</td><td>네트워크 분리/연결, 다양한 라우팅 프로토콜 (OSPF/BGP)</td><td>ICMP/PMTUD 차단 시 블랙홀, ACL/정책에 따른 처리 지연 가능</td><td>L3 경로 제어, 사이트 간 연결, 세그먼트 간 통신</td></tr><tr><td><strong>스위치 (Switch)</strong></td><td>L2</td><td>이더넷 <strong>프레임</strong></td><td>목적지 <strong>MAC</strong> 기반 <strong>CAM(MAC) 테이블</strong> 룩업 후 포트 포워딩, 브로드캐스트/플러딩</td><td>L2 헤더만 확인, <strong>상위 PDU(IPv4/IPv6/TCP/UDP) 는 미건드림</strong></td><td>선형 속도 처리, 지연·오버헤드 최소</td><td>루프 시 브로드캐스트 스톰 (→STP 필요), VLAN 설계 필요</td><td>액세스/엣지 스위칭, 서버 랙 내 고속 L2 스위칭</td></tr><tr><td><strong>Layer 3 스위치</strong></td><td>L3(하드웨어)</td><td>IP <strong>패킷</strong></td><td>라우터 기능을 <strong>ASIC</strong>로 가속, <strong>VLAN 간 라우팅 (Inter-VLAN)</strong>, 멀티캐스트</td><td>라우터와 동일 (IPv4 체크섬/TTL, 새 L2 헤더), 다만 하드웨어 경로</td><td>고속 L3 포워딩, 단일 섀시 내 간결 설계</td><td>고급 라우팅/보안 기능은 제한될 수 있음 (모델 의존)</td><td>데이터센터 코어/디스트리뷰션, 대규모 VLAN 간 트래픽</td></tr><tr><td><strong>방화벽 (Firewall)</strong></td><td>L4–L7</td><td>IP <strong>패킷</strong>/세션</td><td><strong>정책 기반 필터링</strong>(IP/포트/프로토콜), <strong>상태기반 (STATEFUL)</strong> 검사; <strong>NGFW</strong>는 <strong>DPI</strong>로 L7 페이로드 분석</td><td>세션 테이블 관리, NAT/ALG, 앱 시그니처·TLS 검사 (옵션)</td><td>보안 정책 일관 적용, 침해 차단</td><td>DPI/SSL 가시성 설정 시 지연·오버헤드↑, 오탐/미탐 이슈</td><td>경계 보안, 세그먼트 사이 North-South 트래픽 제어</td></tr><tr><td><strong>로드밸런서 (Load Balancer)</strong></td><td>L4 또는 L7</td><td>L4: TCP/UDP <strong>세그먼트/데이터그램</strong>; L7: <strong>HTTP 등 메시지</strong></td><td><strong>분산</strong>(해시/퍼시스턴스/헬스체크), <strong>L7 은 콘텐츠 기반 라우팅</strong>(URL/헤더/쿠키)</td><td>L4: 5- 튜플 기반, DSR/NAT/프록시; L7: HTTP 헤더 파싱, <strong>TLS 종료/오프로드</strong> 가능</td><td>탄력 확장, 장애 격리, 트래픽 정책 세분화</td><td>L7 은 처리비용↑(파싱/암복호), 세션 일관성 관리 필요</td><td>웹/API 트래픽 분산, 마이크로서비스 인그레스, TLS 오프로딩</td></tr></tbody></table><p>네트워크 장비는 특정 계층의 PDU 헤더를 분석·조작하여 패킷 전달, 필터링, 분산 등의 기능을 수행한다. 하위 계층 장비 (허브·스위치) 는 상위 PDU 를 투명하게 전달하는 반면, 상위 계층 장비 (방화벽·로드밸런서) 는 응용 데이터까지 분석할 수 있다. 이는 PDU 계층 구조가 네트워크 인프라의 기능 분리와 확장성을 가능하게 함을 보여준다.</p><h3 id=mtu-단편화-mss-협상>MTU, 단편화, MSS 협상<a hidden class=anchor aria-hidden=true href=#mtu-단편화-mss-협상>#</a></h3><ul><li><strong>MTU (Maximum Transmission Unit)</strong>: 경로에서 <strong>단편화 없이</strong> 보낼 수 있는 <strong>IP(L3) 패킷 최대 크기</strong>. 인터페이스 MTU(링크별) 와 **Path MTU(경로 최소값)**을 구분한다. MTU 는 상위 모든 PDU 크기의 상한을 규정한다.</li><li><strong>단편화 (Frag/Reassembly)</strong>: MTU 를 초과하는 IP 패킷을 <strong>여러 단편</strong>으로 나눠 전송/수신 측에서 재조립. <strong>IPv4</strong>는 라우터·송신자 모두 가능 (DF=0 일 때), <strong>IPv6</strong>는 <strong>송신자만</strong> 가능하며 라우터 단편화 금지 (Frag EH 사용). 원칙은 <strong>회피</strong>다.</li><li><strong>MSS 협상 (Maximum Segment Size)</strong>: TCP 가 핸드셰이크 (<strong>SYN/SYN‑ACK</strong>) 에서 합의하는 <strong>TCP 데이터 최대치</strong>(헤더 제외). 경계 장비의 <strong>MSS 클램핑</strong>은 경로 MTU 미스매치에 대한 보호장치다.</li></ul><blockquote><p>해설: 세 개념은 한 파이프라인에서 연결된다. <strong>MTU 가 상한을 정하고 → MSS 가 TCP 단위 크기를 결정 → 단편화는 실패 시 발생하는 예외 처리</strong>다. 운영 목표는 <em>단편화 없이</em> PMTUD/PLPMTUD·MSS 로 안전 크기를 유지하는 것이다.</p></blockquote><h4 id=정의특징역할기능>정의·특징·역할/기능<a hidden class=anchor aria-hidden=true href=#정의특징역할기능>#</a></h4><h5 id=mtu-maximum-transmission-unit>MTU (Maximum Transmission Unit)<a hidden class=anchor aria-hidden=true href=#mtu-maximum-transmission-unit>#</a></h5><ul><li><strong>정의</strong>: 단편화 없이 전송 가능한 <strong>IP 패킷 (L3) 최대 크기</strong>.</li><li><strong>특징</strong><ul><li>값의 기준은 <strong>IP MTU</strong>(L2 헤더/트레일러 제외). 이더넷 1500 이 흔함, IPv6 최소는 1280.</li><li><strong>헤더 누적</strong>(IPv6, TCP 옵션, TLS/QUIC, 터널/오버레이) 로 유효 L7 이 줄어든다.</li></ul></li><li><strong>역할/기능</strong><ul><li><strong>크기 상한</strong> 제공 → 패킷화/세그먼트화 기준.</li><li><strong>경로 적합성</strong> 판단 (블랙홀/재전송 방지의 기준).</li></ul></li></ul><blockquote><p><strong>계산식</strong>: <code>Max L7 ≈ IP MTU − (IP + L4 + 보안/옵션/오버레이)</code> / <code>TCP MSS = IP MTU − (IP + TCP)</code>.</p></blockquote><p><strong>Path MTU</strong>: 경로상 링크 IP MTU 의 <strong>최소값</strong>.</p><ul><li><p><strong>예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>호스트A (MTU=9000) 
</span></span><span class=line><span class=cl>  → 스위치 (9000) 
</span></span><span class=line><span class=cl>  → 라우터1 (1500) ← Path MTU 병목!
</span></span><span class=line><span class=cl>  → 인터넷 (1500)
</span></span><span class=line><span class=cl>  → VPN 게이트웨이 (1400) ← 실제 Path MTU = 1400
</span></span><span class=line><span class=cl>  → 호스트B (1500)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>결과: 1400 초과 패킷은 단편화되거나 폐기됨
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>계층별 관계</strong></p><pre class=mermaid>flowchart TB
    subgraph L2[&#34;L2 프레임 (1518 B)&#34;]
        direction LR
        L2H[L2 헤더&lt;br/&gt;이더넷 14 B]
        subgraph MTU[&#34;MTU (1500 B)&#34;]
            direction LR
            IPH[IP 헤더&lt;br/&gt;20~60 B]
            subgraph IPP[&#34;IP 페이로드 (1440~1480 B)&#34;]
                direction TB
                TCP[TCP 헤더&lt;br/&gt;20 B]
                UDP[UDP 헤더&lt;br/&gt;8 B]
                subgraph MSS[&#34;MSS 영역&#34;]
                    DATA[TCP/UDP 데이터&lt;br/&gt;1380~1472 B]
                end
            end
        end
        FCS[FCS&lt;br/&gt;CRC 4 B]
        
        L2H --&gt; IPH
        IPH --&gt; IPP
        TCP -.-&gt; DATA
        UDP -.-&gt; DATA
        IPP --&gt; FCS
    end
    
    style L2 fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style MTU fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style IPP fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style MSS fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    style L2H fill:#bbdefb,stroke:#1565c0
    style IPH fill:#c8e6c9,stroke:#2e7d32
    style FCS fill:#bbdefb,stroke:#1565c0
    style DATA fill:#f8bbd0,stroke:#880e4f
</pre><h5 id=단편화-fragmentation>단편화 (Fragmentation)<a hidden class=anchor aria-hidden=true href=#단편화-fragmentation>#</a></h5><ul><li><strong>정의</strong>: MTU 초과 패킷을 <strong>여러 조각</strong>으로 나눠 전송·수신측에서 재조립.</li><li><strong>특징</strong><ul><li><strong>IPv4</strong>: DF=0 이면 <strong>라우터/송신자 모두</strong> 가능, DF=1 이면 <strong>ICMP(Frag Needed)</strong>.</li><li><strong>IPv6</strong>: <strong>라우터 단편화 금지</strong>, 송신자만 가능 (PTB 로 크기 교정).</li><li>재조립 비용↑, 손실 민감↑, 방화벽/NAT 문제 (중간 단편에 포트없음) → <strong>회피가 원칙</strong>.</li></ul></li><li><strong>역할/기능</strong>: 최후의 안전망이지만 지연/손실/CPU 비용을 키우므로 <strong>PMTUD/PLPMTUD + MSS</strong>로 사전 회피.</li></ul><h5 id=mss-협상-maximum-segment-size>MSS 협상 (Maximum Segment Size)<a hidden class=anchor aria-hidden=true href=#mss-협상-maximum-segment-size>#</a></h5><ul><li><strong>정의</strong>: TCP 세그먼트 <strong>데이터부 최대 크기</strong>(헤더 제외). 3-way handshake 에서 <strong>서로 광고 → 더 작은 값</strong> 사용.</li><li><strong>특징</strong><ul><li><code>MSS = IP MTU − (IP + TCP)</code>(옵션 고려 시 더 작게). 일반 이더넷 IPv4 기준 <strong>1460B</strong>, IPv6 <strong>1440B</strong>(고정헤더만).</li><li><strong>MSS 클램핑</strong>: 중간장비가 SYN 의 MSS 를 낮춰 경로 MTU 에 맞춤 (터널/VPN 안정화).</li></ul></li><li><strong>역할/기능</strong>: <strong>세그먼트화 단계에서 MTU 초과를 예방</strong> → 단편화·재조립 회피, 재전송 감소.</li></ul><h4 id=적용-위치와-흐름>적용 위치와 흐름<a hidden class=anchor aria-hidden=true href=#적용-위치와-흐름>#</a></h4><ul><li><strong>MTU</strong>는 <strong>송신 호스트의 IP egress</strong>와 <strong>라우터 egress</strong>에서 <strong>실제 크기 검증</strong>이 이뤄지고, 터널 ingress 에서는 <strong>외부 헤더 가산</strong>을 고려해 <strong>내부 MTU 를 미리 낮추는 설계</strong>가 필수다.</li><li><strong>MSS</strong>는 <strong>양끝 TCP</strong>가 <strong>SYN 교환</strong>으로 결정하고, <strong>중간 장비</strong>가 클램핑으로 강제 축소해 <strong>단편화 사전 회피</strong>에 기여한다.</li><li><strong>단편화</strong>는 IPv4 에서 <strong>송신/라우터</strong> 모두 가능 (DF=0), IPv6 는 <strong>송신자만</strong> 가능하며, <strong>재조립은 항상 수신 호스트 IP</strong>가 담당한다. 가능하면 <strong>PMTUD/PLPMTUD+MSS</strong>로 회피하라.</li></ul><p><strong>적용흐름</strong></p><ol><li><strong>Host A / TCP</strong>: SYN 에 <strong>MSS 광고</strong>, 상대와 min 선택 → <strong>세그먼트화 한도 결정</strong>.</li><li><strong>Host A / IP</strong>: 라우팅 후 <strong>출구 MTU/PMTU</strong> 확인 → 크기 초과면 축소 (IPv6) 또는 (IPv4, DF=0) 자체 단편화.</li><li><strong>Routers / Forwarding</strong>: egress MTU 비교 → (IPv4, DF=0) 단편화 <strong>또는</strong> (IPv4 DF=1/IPv6) <strong>ICMP</strong> 통지.</li><li><strong>Host A / PLPMTUD</strong>: ICMP 또는 ACK 기반으로 <strong>PMTU 캐시 갱신</strong>, <strong>세그먼트/레코드 크기 추가 축소</strong>.</li><li><strong>Host B / IP</strong>: 도착한 조각 <strong>재조립</strong> 후 L4 로 인도.</li></ol><pre class=mermaid>flowchart LR
%% title: mtu-frag-mss-from-to
%% caption: From(캡슐화)→경로(MTU/ICMP)→To(역캡슐화/재조립) 흐름

subgraph HOST_A[&#34;Host A — 캡슐화&#34;]
  A1[앱 SDU]
  A2[&#34;TLS/QUIC (선택)&#34;]
  A3[&#34;TCP/UDP (세그먼트/데이터그램)&#34;]
  A4[&#34;IP (IPv4/IPv6)&#34;]
  A5[L2 프레임화]
  A1 --&gt; A2 --&gt; A3 --&gt; A4 --&gt; A5
end

A5 --&gt; R1

subgraph PATH[&#34;Routers — 전송 경로&#34;]
  R1{다음 홉 MTU ≥ 패킷?}
  R1 -- 예 --&gt; R2[포워딩]
  R1 -- 아니오 --&gt; R3{IPv4 &amp; DF=0?}
  R3 -- 예 --&gt; R4[IPv4 단편화 수행]
  R3 -- 아니오 --&gt; R5[ICMP Frag Needed / ICMPv6 PTB]
end

R2 --&gt; B1
R4 --&gt; B1

R5 --&gt; A2a[&#34;송신자: 크기 축소\n(MSS/레코드/PLPMTUD)&#34;]
A2a --&gt; A3

subgraph HOST_B[&#34;Host B — 역캡슐화/재조립&#34;]
  B1[L2 해제]
  B2[IPv4/IPv6 재조립]
  B3[TCP/UDP 전달]
  B4[TLS/앱 인도]
  B1 --&gt; B2 --&gt; B3 --&gt; B4
end
</pre><p>주: 캡슐화 (Host A, 송신) → 전송 경로 (Routers) → 역캡슐화 (Host B, 수신)</p><h5 id=mtu어디서-어떻게-적용되나>MTU—어디서, 어떻게 적용되나<a hidden class=anchor aria-hidden=true href=#mtu어디서-어떻게-적용되나>#</a></h5><h6 id=송신-호스트-host-aip-계층-egress-경로에서-mtu-적용>송신 호스트 (Host A)—<strong>IP 계층 Egress 경로에서 MTU 적용</strong><a hidden class=anchor aria-hidden=true href=#송신-호스트-host-aip-계층-egress-경로에서-mtu-적용>#</a></h6><ul><li><strong>주체</strong>: OS 커널의 IP 출력 경로 (IPv4/IPv6) + 라우팅/디바이스 MTU 테이블.</li><li><strong>어디서</strong>:<ol><li>라우팅 결정 (다음 홉/출구 인터페이스 선택) →</li><li><strong>출구 인터페이스의 IP MTU</strong>(또는 경로 MTU 캐시) 에 맞춰 <strong>IP 패킷 크기 검사</strong> →</li><li>초과하면: IPv4 는 DF=0 이면 자체 단편화, DF=1 이면 전송 금지/ICMP 의존. IPv6 은 <strong>라우터 단편화 금지</strong>이므로 <strong>자체 크기 축소 또는 (필요시) 송신자 단편화 헤더</strong>만 가능.</li></ol></li><li><strong>어떻게</strong>: 커널은 <code>dst_entry</code>/<code>route</code> 의 PMTU(경로 MTU) 캐시를 참조하고, GSO/TSO 가 켜져 있어도 <strong>온와이어 기준</strong>으로 MTU 를 지킨다 (오프로딩은 NIC 가 패킷을 쪼개 보냄).</li><li><strong>실무 포인트</strong>:<ul><li>Linux: <code>ip link show dev &lt;if></code>, <code>ip route get &lt;dst></code> 로 dev/route MTU 확인, <code>ip route change … mtu &lt;n></code> 가능.</li><li>PMTU 캐시는 ICMP(Frag Needed/PTB) 나 PLPMTUD 로 갱신된다.</li></ul></li></ul><h6 id=중간-라우터-routers출구-인터페이스에서-다음-홉-mtu-검사>중간 라우터 (Routers)—<strong>출구 인터페이스에서 다음 홉 MTU 검사</strong><a hidden class=anchor aria-hidden=true href=#중간-라우터-routers출구-인터페이스에서-다음-홉-mtu-검사>#</a></h6><ul><li><strong>주체</strong>: 라우터의 포워딩 평면 (하드웨어/소프트웨어) + egress 인터페이스 MTU.</li><li><strong>어디서</strong>: 라우팅 후 <strong>egress MTU 비교</strong>에서 패킷 크기>MTU 면 분기:<ul><li><strong>IPv4</strong>: DF=0 이면 <strong>라우터가 단편화</strong> 수행 (Identification/Fragment Offset/MF 조정). DF=1 이면 <strong>드롭 + ICMP Type3 Code4(Frag Needed)</strong> 전송.</li><li><strong>IPv6</strong>: <strong>항상 드롭 + ICMPv6 PTB(Type 2)</strong> 전송 (라우터 단편화 금지).</li></ul></li><li><strong>터널/오버레이</strong>: VXLAN/GRE/IPsec 같은 <strong>캡슐화 (ingress)</strong> 장비는 <strong>외부 헤더를 얹기 전</strong> 내부 패킷 + 외부 헤더 합계가 <strong>외부 링크 MTU</strong>를 넘지 않게 <strong>내부 MTU 를 낮춰야</strong> 한다 (장비가 내부 DF 취급을 따로 함). [RF:2,3,4]</li></ul><h6 id=수신-호스트-host-bip-계층-ingress-에서-재조립검사>수신 호스트 (Host B)—<strong>IP 계층 Ingress 에서 재조립/검사</strong><a hidden class=anchor aria-hidden=true href=#수신-호스트-host-bip-계층-ingress-에서-재조립검사>#</a></h6><ul><li><strong>주체</strong>: OS 커널의 IP 입력 경로 (IPv4 조각 재조립, IPv6 조각 재조립).</li><li><strong>어디서</strong>: 조각화된 IPv4/IPv6 패킷을 <strong>IP 계층에서 재조립</strong>한 뒤 L4(UDP/TCP) 로 전달. MTU 는 수신 시 강제 적용 대상이 아니며, 이미 경로에서 맞춰진다.</li></ul><h5 id=mss-협상어디서-어떻게-결정강제되나>MSS 협상—어디서, 어떻게 결정·강제되나<a hidden class=anchor aria-hidden=true href=#mss-협상어디서-어떻게-결정강제되나>#</a></h5><h6 id=송신수신-호스트tcp-3-way-handshake-에서-결정>송신/수신 호스트—<strong>TCP 3-way Handshake 에서 결정</strong><a hidden class=anchor aria-hidden=true href=#송신수신-호스트tcp-3-way-handshake-에서-결정>#</a></h6><ul><li><strong>주체</strong>: 양 끝단 <strong>TCP 스택</strong>.</li><li><strong>어디서</strong>: SYN/SYN-ACK 교환 시 <strong>TCP 옵션의 MSS 값</strong>을 서로 광고 → **더 작은 값 (min)**을 채택.</li><li><strong>어떻게</strong>: 채택된 MSS 를 기준으로 **세그먼트화 (송신 측 TCP)**가 이뤄진다. 이후 PMTU 가 줄면 커널이 세그먼트 크기를 더 줄인다 (PLPMTUD/PMTUD 반영).</li><li><strong>실무 포인트</strong>:<ul><li>Linux: <code>net.ipv4.tcp_mtu_probing=2</code>(PLPMTUD 항상), <code>tcp_base_mss</code>, <code>tcp_min_snd_mss</code> 로 하한 설정.</li><li>캡처로 SYN 옵션의 <code>MSS</code> 값 확인 (중간 장비 개입 여부 점검).</li></ul></li></ul><h6 id=중간-장비-라우터방화벽로드밸런서mss-클램핑>중간 장비 (라우터/방화벽/로드밸런서)—<strong>MSS 클램핑</strong><a hidden class=anchor aria-hidden=true href=#중간-장비-라우터방화벽로드밸런서mss-클램핑>#</a></h6><ul><li><strong>주체</strong>: L3/L4 장비의 <strong>정책 엔진</strong>.</li><li><strong>어디서</strong>: <strong>경계 구간</strong>에서 TCP SYN 패킷의 MSS 옵션 값을 <strong>강제로 낮춤</strong>(예: <code>--clamp-mss-to-pmtu</code> 혹은 고정값).</li><li><strong>어떻게</strong>: 이후 전 구간에서 <strong>더 작은 MSS</strong>로 세그먼트가 생성되어 <strong>단편화/블랙홀 사전 예방</strong>. 터널/VPN 환경 필수 관행.</li></ul><blockquote><p>요지: MSS 는 **TCP 세그먼트화 단계 (호스트 TCP)**에서 적용되고, <strong>중간 장비는 SYN 의 MSS 를 수정</strong>해 경로 제약을 강제한다.</p></blockquote><h5 id=단편화-fragmentation어디서-어떻게-발생해결되나>단편화 (Fragmentation)—어디서, 어떻게 발생·해결되나<a hidden class=anchor aria-hidden=true href=#단편화-fragmentation어디서-어떻게-발생해결되나>#</a></h5><h6 id=ipv4>IPv4<a hidden class=anchor aria-hidden=true href=#ipv4>#</a></h6><ul><li><strong>송신 호스트</strong>: DF=0 이면 <strong>자체 단편화 가능</strong>(IP 출력 경로). DF=1 이면 <strong>단편화 금지</strong> → 크기 축소 필요 (=MSS/레코드 사이즈 조정, PMTUD/PLPMTUD).</li><li><strong>중간 라우터</strong>: DF=0 & MTU 초과 시 <strong>라우터가 단편화</strong> 수행 (egress 에서). DF=1 이면 <strong>드롭 + ICMP Frag Needed</strong>.</li><li><strong>수신 호스트</strong>: <strong>재조립은 항상 수신 호스트</strong> IP 계층에서 수행.</li><li><strong>부작용</strong>: 조각 손실=전체 폐기, 방화벽/NAT 필터링 곤란 (중간 조각에 L4 포트 없음), CPU/버퍼 비용↑ → <strong>가능하면 회피</strong>.</li></ul><h6 id=ipv6>IPv6<a hidden class=anchor aria-hidden=true href=#ipv6>#</a></h6><ul><li><strong>송신 호스트만 단편화 가능</strong>: <strong>Fragment Extension Header</strong>를 송신자가 붙일 수 있으나, 권장 경로는 <strong>PTB 수신 → 크기 축소</strong>.</li><li><strong>라우터 단편화 금지</strong>: MTU 초과 시 <strong>항상 PTB</strong>로 통지.</li><li><strong>수신 호스트</strong>: <strong>재조립</strong> 수행.</li><li><strong>최소 MTU 1280B</strong>: 설계 시 안전 하한.</li></ul><blockquote><p>요지: 단편화는 <strong>IPv4 에서는 (송신/라우터) 둘 다</strong>, <strong>IPv6 에서는 송신자만</strong>. 운영상 <strong>회피가 원칙</strong>이며 PMTUD/PLPMTUD·MSS 로 사전 예방한다.</p></blockquote><h4 id=터널보안오프로딩과의-상호작용>터널·보안·오프로딩과의 상호작용<a hidden class=anchor aria-hidden=true href=#터널보안오프로딩과의-상호작용>#</a></h4><ul><li><strong>캡슐화 (From, 터널 ingress)</strong>: VXLAN/GRE/IPsec ESP 등 <strong>외부 헤더 추가 직전</strong>에 <strong>내부 MTU 를 낮춰</strong>야 외부 링크 MTU 를 넘지 않는다 (장비/OS 의 <strong>터널 인터페이스 MTU</strong> 설정이 핵심).</li><li><strong>전송 경로 (Routers)</strong>: 터널 <strong>외부 패킷</strong>이 egress MTU 를 넘으면 <strong>외부 패킷이 드롭/단편화</strong>된다 (특히 IPv4). PPTB/Frag Needed 신호가 <strong>내부 송신자까지 전달되지 못하면 블랙홀</strong>이 되므로 ICMP 정책과 터널의 PTB 처리 로직이 중요.</li><li><strong>역캡슐화 (To, 터널 egress)</strong>: 외부 헤더를 제거하고 <strong>내부 패킷을 원형대로</strong> 내보낸다. 이때 내부 패킷은 이미 <strong>작게 설계</strong>되어 있어야 한다.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: <strong>세그먼트화는 호스트 TCP</strong>, MTU 준수는 <strong>온와이어에서 NIC/드라이버</strong>가 보장. <strong>호스트 캡처는 &rsquo; 큰 가상 세그먼트 &rsquo; 로 보일 수 있어</strong> 경계 캡처와 교차 검증 필요.</li></ul><h4 id=주체지점동작>주체·지점·동작<a hidden class=anchor aria-hidden=true href=#주체지점동작>#</a></h4><table><thead><tr><th>항목</th><th>주체/지점</th><th>동작 요약</th><th>관찰 포인트</th></tr></thead><tbody><tr><td><strong>MTU 결정</strong></td><td>NIC/링크, 터널 인터페이스, 라우팅 엔트리</td><td>인터페이스 MTU 와 경로 최소값 (<strong>PMTUD/PLPMTUD</strong>) 으로 <strong>Path MTU</strong> 확정</td><td><code>tracepath</code>, ICMP PTB/FragNeeded 로그, <code>ip route get</code></td></tr><tr><td><strong>단편화 (IPv4)</strong></td><td><strong>라우터 (DF=0)</strong> 또는 <strong>송신 호스트</strong></td><td>중간/엔드에서 단편 생성 → 수신 호스트 재조립</td><td>IPv4 ID/Offset/MF, 재조립 드롭률</td></tr><tr><td><strong>단편화 (IPv6)</strong></td><td><strong>송신 호스트만</strong></td><td>Frag EH 로 분할, 라우터 단편화 금지</td><td>ICMPv6 PTB, EH 존재 시 장비 호환성</td></tr><tr><td><strong>MSS 협상</strong></td><td><strong>엔드포인트 TCP 스택</strong></td><td>SYN/SYN‑ACK 에서 min(MSS) 채택</td><td>캡처로 MSS 값, <code>tcp_base_mss</code>/<code>tcp_mtu_probing</code></td></tr><tr><td><strong>MSS 클램핑</strong></td><td><strong>경계 라우터/방화벽</strong></td><td>SYN 의 MSS 옵션을 <strong>강제 축소</strong></td><td><code>--clamp-mss-to-pmtu</code> 정책·룰 히트 카운터</td></tr></tbody></table><blockquote><p>해설: MTU/단편화는 <strong>IP 계층</strong>, MSS 는 <strong>TCP 계층</strong>의 일로서, 결정 지점이 다르다. 터널/오버레이가 끼면 <strong>외부 MTU</strong>에 맞춰 <strong>내부 MTU 하향 + 클램핑</strong>을 세트로 적용해야 블랙홀을 방지한다.</p></blockquote><h4 id=ip-mtu-기준-대표-조합-1500-기준>IP MTU 기준 대표 조합 (1500 기준)<a hidden class=anchor aria-hidden=true href=#ip-mtu-기준-대표-조합-1500-기준>#</a></h4><table><thead><tr><th>조합</th><th style=text-align:right>헤더 합계 (최소)</th><th style=text-align:right>최대 L7</th></tr></thead><tbody><tr><td>IPv4(20)+TCP(20)</td><td style=text-align:right>40B</td><td style=text-align:right>1460B</td></tr><tr><td>IPv6(40)+TCP(20)</td><td style=text-align:right>60B</td><td style=text-align:right>1440B</td></tr><tr><td>IPv4(20)+UDP(8)</td><td style=text-align:right>28B</td><td style=text-align:right>1472B</td></tr><tr><td>IPv6(40)+UDP(8)</td><td style=text-align:right>48B</td><td style=text-align:right>1452B</td></tr><tr><td>(TCP 조합)+TLS1.3(5+~16)</td><td style=text-align:right>+21B</td><td style=text-align:right>해당 TCP 행 −21B</td></tr><tr><td>점보 9001 + IPv6/TCP: 60B → 8941B. 옵션/오버레이·IPsec 등 가산 필요. [RF:8,9,10]</td><td style=text-align:right></td><td style=text-align:right></td></tr></tbody></table><h4 id=pmtudplpmtudmss-의사결정-송신-측-중심>PMTUD/PLPMTUD·MSS 의사결정 (송신 측 중심)<a hidden class=anchor aria-hidden=true href=#pmtudplpmtudmss-의사결정-송신-측-중심>#</a></h4><pre class=mermaid>flowchart TD
%% title: pmtud-plpmtud-mss-decision
S[송신 시작] --&gt; P{ICMP 신뢰 가능?}
P -- 예 --&gt; P1[&#34;PMTUD 사용\n(DF=1)&#34;]
P -- 아니오 --&gt; P2[&#34;PLPMTUD 사용\n(ACK/Probe 기반)&#34;]
P1 --&gt; C[&#34;MSS= min(양단 MSS, PMTU-헤더)&#34;]
P2 --&gt; C
C --&gt; T{터널/보안/옵션 추가?}
T -- 예 --&gt; T1[헤더 가산→내부 MTU/MSS 재계산]
T -- 아니오 --&gt; D[전송]
</pre><ul><li><strong>권장 조합</strong>: PMTUD(+ICMP 정책 정합) <strong>우선</strong>, 경로 불확실/차단 환경은 <strong>PLPMTUD 병행</strong> + <strong>MSS 클램핑</strong>.</li></ul><h2 id=웹-브라우징에서의-pdu-흐름>웹 브라우징에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#웹-브라우징에서의-pdu-흐름>#</a></h2><p>브라우저 URL 입력 후 <strong>이름 해석 (DNS/DoH/DoT) → 연결 수립 (HTTP/2 over TCP/TLS 1.3 또는 HTTP/3 over QUIC/UDP/TLS 1.3) → 요청/응답 → 리소스 병렬 로딩</strong>으로 진행되며, 상위 **SDU(Service Data Unit)**가 하위 <strong>PDU</strong>로 캡슐화되어 이동한다.<br>대표 PDU 는 <strong>DNS 메시지, TLS 레코드, QUIC 패킷, TCP 세그먼트, IP 패킷, L2 프레임</strong>이다.<br>HTTP/3 는 <strong>HTTP/3 를 QUIC 위에 매핑</strong>하고, HTTP/2 는 <strong>TCP 위에 HTTP/2 프레이밍</strong>을 둔다.</p><ul><li><strong>HTTP/3(하이퍼텍스트 전송 프로토콜 버전 3)</strong>: <strong>QUIC(Quick UDP Internet Connections)</strong> 위에서 HTTP 의미론을 운반. 스트림 단위 멀티플렉싱·흐름제어·저지연 수립을 QUIC 이 제공.</li><li><strong>HTTP/2</strong>: 단일 TCP 연결 내부에서 <strong>프레임 단위 멀티플렉싱 (헤더 압축 포함)</strong> 제공.</li><li><strong>DNS-over-HTTPS(DoH)</strong>/<strong>DNS-over-TLS(DoT)</strong>: 평문 DNS 를 각각 <strong>HTTPS</strong>/<strong>TLS</strong>로 감싸 전송.</li></ul><h3 id=단계별-캡슐화역캡슐화-요청응답>단계별 캡슐화·역캡슐화 (요청→응답)<a hidden class=anchor aria-hidden=true href=#단계별-캡슐화역캡슐화-요청응답>#</a></h3><ol><li><strong>이름 해석</strong><ul><li>전통 <strong>DNS(Domain Name System)</strong>: 일반적으로 <strong>UDP 포트 53</strong>, 필요 시 <strong>TCP</strong>로 폴백. (EDNS0 확장으로 UDP 응답 확장 가능—여기서는 개요만)</li><li><strong>DoH/DoT</strong>: DNS 메시지를 각각 <strong>HTTP/2·HTTP/3</strong> 또는 <strong>TLS</strong>로 보호해 전송 (암호화·인증 경로 확보).</li></ul></li><li><strong>연결 수립</strong><ul><li><strong>HTTP/3 over QUIC/UDP/TLS 1.3</strong>: <strong>QUIC 초기 (Initial) 패킷은 최소 1200 바이트</strong>로 전송해야 하며, TLS 1.3 핸드셰이크는 <strong>QUIC 의 CRYPTO/핸드셰이크 프레임</strong>으로 진행된다 (0-RTT/1-RTT 모드).</li><li><strong>HTTP/2 over TCP/TLS 1.3</strong>: <strong>TCP 3-way 핸드셰이크</strong>(MSS 협상) 후 <strong>TLS 1.3 핸드셰이크 (1-RTT)</strong>, 그 위에서 <strong>HTTP/2 프레임</strong> 교환.</li></ul></li><li><strong>요청/응답 교환</strong><ul><li><strong>HTTP/3</strong>: L7 요청/응답이 <strong>HTTP/3 프레임 → QUIC 패킷 → UDP 데이터그램 → IP → L2</strong>로. 스트림 독립 재전송·혼잡제어는 QUIC 담당.</li><li><strong>HTTP/2</strong>: L7 프레임이 <strong>TLS 레코드 → TCP 세그먼트 → IP → L2</strong>로. 손실 복구·혼잡제어는 TCP 담당.</li></ul></li><li><strong>리소스 병렬 로딩</strong><ul><li><strong>HTTP/3/HTTP/2</strong> 모두 단일 연결 (혹은 소수 연결) 에서 스트림/프레임 멀티플렉싱으로 CSS/JS/이미지를 병렬 전송.</li></ul></li></ol><p><strong>웹 브라우저에서 <code>https://example.com</code> 을 입력했을 때 일어나는 모든 과정</strong></p><pre class=mermaid>flowchart TD
    Start[브라우저에 URL 입력&lt;br/&gt;https\:\/\/example.com]
    
    DNS[DNS 조회&lt;br/&gt;도메인 → IP 주소]
    TCP[TCP 3-Way Handshake&lt;br/&gt;연결 설정]
    TLS[TLS 1.3 Handshake&lt;br/&gt;보안 채널 설정]
    HTTP[HTTP 요청/응답&lt;br/&gt;HTML, CSS, JS 다운로드]
    Render[브라우저 렌더링&lt;br/&gt;화면 표시]
    
    Start --&gt; DNS
    DNS --&gt; TCP
    TCP --&gt; TLS
    TLS --&gt; HTTP
    HTTP --&gt; Render
    
    style DNS fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style TCP fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style TLS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style HTTP fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style Render fill:#fce4ec,stroke:#c2185b,stroke-width:2px
</pre><h4 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h4><h5 id=캡슐화-과정-송신-하향>캡슐화 과정 (송신, 하향)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-송신-하향>#</a></h5><ol><li><strong>애플리케이션</strong> → DNS 쿼리, TCP SYN, TLS 핸드셰이크, HTTP 요청 생성</li><li><strong>전송 계층</strong> → UDP(DNS) 또는 TCP(웹) 헤더 추가 (8-60 B)</li><li><strong>네트워크 계층</strong> → IP 헤더 추가 (20-40 B), 라우팅 정보</li><li><strong>데이터링크</strong> → 이더넷 헤더 (14 B) + FCS(4 B) 추가</li><li><strong>물리 계층</strong> → 전기/광 신호로 변환, 네트워크 전송</li></ol><h5 id=역캡슐화-과정-수신-상향>역캡슐화 과정 (수신, 상향)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-수신-상향>#</a></h5><ol><li><strong>물리 계층</strong> → 신호 수신, 디지털 변환</li><li><strong>데이터링크</strong> → MAC 확인, FCS 검증, 헤더 제거</li><li><strong>네트워크 계층</strong> → 목적지 IP 확인, 헤더 제거</li><li><strong>전송 계층</strong> → 포트 확인, 재조립, 흐름 제어</li><li><strong>애플리케이션</strong> → TLS 복호화, HTTP 처리, 브라우저 렌더링</li></ol><h3 id=관찰-지점별로-실제-보이는-pdu>관찰 지점별로 실제 보이는 PDU<a hidden class=anchor aria-hidden=true href=#관찰-지점별로-실제-보이는-pdu>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3 경로에서 보이는 것</th><th>HTTP/2 경로에서 보이는 것</th><th>비고</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td><strong>HTTP/3 프레임 ↔ QUIC 패킷</strong> (TLS 1.3 내장)</td><td><strong>HTTP/2 프레임 ↔ TLS 레코드 ↔ TCP 세그먼트</strong></td><td>엔드포인트에서만 상위 구조 완전 관찰 가능.</td></tr><tr><td>L3(라우터/방화벽)</td><td><strong>IP 패킷 (UDP/IPv4·IPv6)</strong></td><td><strong>IP 패킷 (TCP/IPv4·IPv6)</strong></td><td>ECN/DSCP, PMTUD/PTB 이벤트 관찰.</td></tr><tr><td>L2(스위치/AP)</td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>온와이어 MTU 와만 상호작용 (상위 페이로드는 불투명).</td></tr></tbody></table><h3 id=mtumss단편화웹-특화-검증-포인트>MTU·MSS·단편화—웹 특화 검증 포인트<a hidden class=anchor aria-hidden=true href=#mtumss단편화웹-특화-검증-포인트>#</a></h3><ul><li>**MTU(Maximum Transmission Unit)**와 <strong>Path MTU</strong>: 경로의 <strong>최소소값</strong>이 상한을 결정. IPv4 는 <strong>ICMP &ldquo;Fragmentation Needed&rdquo;</strong>(RFC 1191) 로, IPv6 는 <strong>ICMPv6 &ldquo;Packet Too Big&rdquo;</strong>(RFC 8201) 로 송신자에게 축소를 알린다.</li><li><strong>PLPMTUD(Packetization Layer PMTUD)</strong>: ICMP 의존 없이 전송/애플리케이션 계층에서 <strong>증분 크기 탐색</strong>으로 안전 크기를 학습 (TCP/QUIC 에 적용).</li><li><strong>MSS(Maximum Segment Size) 협상</strong>: <strong>TCP SYN/SYN-ACK</strong>에서 양단이 알린 값의 <strong>최솟값</strong> 사용 (이후 PMTUD/PLPMTUD 에 의해 더 줄어들 수 있음). (표준은 TCP/IP 일반 규정·HTTP/2 사양 맥락에서 간접 확인)</li><li><strong>TLS 1.3 레코드 오버헤드</strong>: <strong>TLS 레코드 헤더 5 바이트</strong> + 선택된 <strong>AEAD(Authenticated Encryption with Associated Data) 태그</strong>(일반적으로 16 바이트: AES-GCM/ChaCha20-Poly1305). 레코드 크기를 <strong>MSS/Path MTU</strong>에 맞춰 쪼개야 불필요한 IP 단편화나 PMTUD 블랙홀을 예방.</li><li><strong>QUIC 초기 패킷 최소 크기 1200 바이트</strong>: 경로 검증·증폭 공격 완화 목적. 무선/터널 경로의 작은 Path MTU 와 충돌 시 <strong>PLPMTUD</strong> 정책이 중요.</li></ul><h3 id=http2-vs-http3pdu-관점의-차이>HTTP/2 Vs HTTP/3—PDU 관점의 차이<a hidden class=anchor aria-hidden=true href=#http2-vs-http3pdu-관점의-차이>#</a></h3><ul><li><strong>HTTP/2(TCP/TLS 1.3)</strong>: 전송 PDU 는 <strong>TCP 세그먼트</strong>, 보안 PDU 는 <strong>TLS 레코드</strong>. 위험 신호는 <strong>PMTUD 블랙홀</strong>(큰 객체가 특정 지점에서 멈춤) 로 나타나며 <strong>ICMP 허용 + PLPMTUD + MSS 클램핑</strong>으로 완화.</li><li><strong>HTTP/3(QUIC/UDP/TLS 1.3)</strong>: 전송 PDU 는 <strong>QUIC 패킷</strong>. 스트림별 재전송·혼잡제어로 <strong>HOL(Head-of-Line) 블로킹</strong>을 줄이고, <strong>0-RTT/1-RTT</strong> 수립을 지원. 초기 패킷은 1200 바이트 이상으로 <strong>Path MTU/방화벽 정책</strong>과의 상호작용을 반드시 점검.</li></ul><h4 id=http2tcp-웹-페이지-로딩의-pdu-흐름>HTTP/2(TCP) 웹 페이지 로딩의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#http2tcp-웹-페이지-로딩의-pdu-흐름>#</a></h4><pre class=mermaid>sequenceDiagram
%% title: web-h2-pdu
participant U as User Agent (Browser)
participant R as DNS/DoH Resolver
participant S as Web Server (H2)
U-&gt;&gt;R: DNS/DoH 질의 (DNS msg / HTTPS)
R--&gt;&gt;U: A/AAAA
U-&gt;&gt;S: TCP SYN [MSS]
S--&gt;&gt;U: SYN-ACK [MSS]
U-&gt;&gt;S: ACK  (연결 성립)
U--&gt;&gt;S: TLS1.3 ClientHello (TLS Record)
S--&gt;&gt;U: TLS1.3 ServerHello… (TLS Records)
U-&gt;&gt;S: GET / (HTTP/2 frames)
S--&gt;&gt;U: HTML/CSS/JS (HTTP/2 frames → TLS records → TCP segments)
Note over U,S: L7(HTTP/2) → TLS Record → TCP Segment → IP → L2
</pre><p>HTTP/2 는 <strong>TLS 레코드</strong>가 상위 PDU, <strong>TCP 세그먼트</strong>가 전송 PDU 다. <strong>MSS 협상</strong>과 <strong>PMTUD/PLPMTUD</strong>에 따라 세그먼트 크기가 결정되고, 손실 시 TCP 재전송이 수행된다.</p><h4 id=http3quic-웹-페이지-로딩의-pdu-흐름>HTTP/3(QUIC) 웹 페이지 로딩의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#http3quic-웹-페이지-로딩의-pdu-흐름>#</a></h4><pre class=mermaid>sequenceDiagram
%% title: web-h3-pdu
participant U as User Agent (Browser)
participant R as DNS/DoH Resolver
participant S as Web Server (H3)
U-&gt;&gt;R: DNS/DoH 질의 (DNS msg / HTTPS)
R--&gt;&gt;U: A/AAAA(또는 Alt-Svc)
U-&gt;&gt;S: QUIC Initial (TLS CH)  ~1200B
S--&gt;&gt;U: QUIC Initial (TLS SH/EE)
U-&gt;&gt;S: GET / (HTTP/3 frames)
S--&gt;&gt;U: HTML/CSS/JS (H3 frames → QUIC packets)
Note over U,S: L7(HTTP/3) → QUIC frame → QUIC packet → UDP → IP → L2
</pre><p>HTTP/3 은 <strong>QUIC 패킷</strong>이 전송 PDU 이고, 그 안에 <strong>HTTP/3 프레임</strong>과 <strong>TLS 핸드셰이크</strong>가 들어간다. 손실 시 QUIC 이 스트림 단위로 재전송/복구하며, 멀티플렉싱으로 HOL 지연을 줄인다.</p><h3 id=단계계층별-sdupdu-매핑>단계/계층별 SDU→PDU 매핑<a hidden class=anchor aria-hidden=true href=#단계계층별-sdupdu-매핑>#</a></h3><table><thead><tr><th>단계</th><th>상위 SDU(의미단위)</th><th>하위 전송 PDU</th><th>보안/제어 PDU</th><th>핵심 주의</th></tr></thead><tbody><tr><td>이름 해석</td><td>DNS 질의·응답</td><td><strong>UDP 데이터그램 / TCP 세그먼트</strong></td><td>(DoH) <strong>HTTP 요청/응답</strong>, (DoT) <strong>TLS 레코드</strong></td><td>크기↑ 시 TCP 폴백, DoH/DoT 는 암호화 경로 제공.</td></tr><tr><td>연결 수립 (H2)</td><td>TLS 핸드셰이크 메시지</td><td><strong>TCP 세그먼트</strong></td><td><strong>TLS 레코드 (1-RTT)</strong></td><td>MSS 협상 후 레코드 분할.</td></tr><tr><td>연결 수립 (H3)</td><td>TLS 핸드셰이크 메시지</td><td><strong>QUIC 패킷 (UDP)</strong></td><td><strong>QUIC 핸드셰이크/CRYPTO 프레임</strong></td><td><strong>초기 패킷 ≥1200B</strong>.</td></tr><tr><td>요청/응답 (H2)</td><td>HTTP/2 프레임</td><td><strong>TCP 세그먼트</strong></td><td><strong>TLS 레코드</strong></td><td>PMTUD/PLPMTUD 로 단편화 회피.</td></tr><tr><td>요청/응답 (H3)</td><td>HTTP/3 프레임</td><td><strong>QUIC 패킷 (UDP)</strong></td><td>(내장) TLS 1.3</td><td>스트림별 복구/혼잡제어.</td></tr></tbody></table><h3 id=관찰-지점별-pdu-맵-웹-브라우징>관찰 지점별 PDU 맵 (웹 브라우징)<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵-웹-브라우징>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3(QUIC/UDP) 보이는 PDU</th><th>HTTP/2(TCP) 보이는 PDU</th><th>DNS/DoH/DoT</th><th>관측 포인트</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td>H3 프레임 ↔ <strong>QUIC 패킷</strong></td><td>H2 프레임 ↔ <strong>TLS 레코드/TCP 세그먼트</strong></td><td><strong>DNS 메시지/TLS/HTTPS</strong></td><td>엔드 텔레메트리·브라우저 네트워크 패널</td></tr><tr><td>L3 장비 (라우터/방화벽)</td><td><strong>IP 패킷 (UDP/IPv6 가능)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP/TCP)</strong></td><td>ECN/DSCP, PTB/FragNeeded</td></tr><tr><td>L2(스위치/AP)</td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>MTU/무선 MAC 오버헤드</td></tr></tbody></table><h3 id=mtumss단편화웹-특화-포인트>MTU·MSS·단편화—웹 특화 포인트<a hidden class=anchor aria-hidden=true href=#mtumss단편화웹-특화-포인트>#</a></h3><ul><li><strong>MTU 기준</strong>: <code>Max L7 ≈ IP MTU − (IP + L4 + 보안/옵션/오버레이)</code>. H3 는 <strong>QUIC+UDP+AEAD</strong>, H2 는 <strong>TLS+TCP</strong> 오버헤드가 반영된다. 터널/VPN/모바일 경로는 추가 차감.</li><li><strong>MSS 협상 (H2)</strong>: 3-way 에서 min(MSS) 이 정해지고, 이후 PMTUD/PLPMTUD 로 더 줄어들 수 있다. <strong>클램핑</strong>으로 블랙홀 예방.</li><li><strong>단편화 회피</strong>: IPv4 DF=1, IPv6 라우터 단편화 금지. PMTUD/PLPMTUD 실패 시 대용량 객체에서 멈춤 현상 → MTU 하향/레코드 크기 축소.</li></ul><h4 id=mtu-별-전송-효율-비교>MTU 별 전송 효율 비교<a hidden class=anchor aria-hidden=true href=#mtu-별-전송-효율-비교>#</a></h4><table><thead><tr><th style=text-align:right>MTU</th><th style=text-align:right>TCP MSS</th><th style=text-align:right>HTTP 요청 (500 B)</th><th style=text-align:right>HTML 응답 (50 KB)</th><th style=text-align:right>총 세그먼트 수</th></tr></thead><tbody><tr><td style=text-align:right>1500</td><td style=text-align:right>1460</td><td style=text-align:right>1 개 (500 &lt; 1460)</td><td style=text-align:right>35 개 (50000÷1460)</td><td style=text-align:right>36 개</td></tr><tr><td style=text-align:right>1400</td><td style=text-align:right>1360</td><td style=text-align:right>1 개</td><td style=text-align:right>37 개 (50000÷1360)</td><td style=text-align:right>38 개</td></tr><tr><td style=text-align:right>1280</td><td style=text-align:right>1240</td><td style=text-align:right>1 개</td><td style=text-align:right>41 개 (50000÷1240)</td><td style=text-align:right>42 개</td></tr><tr><td style=text-align:right>576</td><td style=text-align:right>536</td><td style=text-align:right>1 개</td><td style=text-align:right>94 개 (50000÷536)</td><td style=text-align:right>95 개</td></tr></tbody></table><p><strong>오버헤드 비교</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MTU 1500:
</span></span><span class=line><span class=cl>- 세그먼트당 오버헤드: 54 B (IP 20 + TCP 20 + 이더넷 14)
</span></span><span class=line><span class=cl>- 총 오버헤드: 54 × 36 = 1944 B
</span></span><span class=line><span class=cl>- 효율: 50000 / (50000 + 1944) = 96.3%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>MTU 576 (최소):
</span></span><span class=line><span class=cl>- 세그먼트당 오버헤드: 54 B
</span></span><span class=line><span class=cl>- 총 오버헤드: 54 × 95 = 5130 B
</span></span><span class=line><span class=cl>- 효율: 50000 / (50000 + 5130) = 90.7%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>결론: 큰 MTU = 높은 효율
</span></span></code></pre></td></tr></table></div></div><h4 id=path-mtu-문제-시나리오>Path MTU 문제 시나리오<a hidden class=anchor aria-hidden=true href=#path-mtu-문제-시나리오>#</a></h4><pre class=mermaid>sequenceDiagram
    participant C as 클라이언트&lt;br/&gt;(MTU 1500)
    participant R as 라우터&lt;br/&gt;(MTU 1400)
    participant S as 서버&lt;br/&gt;(MTU 1500)
    
    Note over C,S: TCP 연결 성립 (MSS=1460)
    
    C-&gt;&gt;R: TCP 세그먼트 (1460 B 데이터)
    Note over R: MTU 1400 초과!&lt;br/&gt;DF=1 설정됨
    R-&gt;&gt;C: ICMP PTB (Next MTU=1400)
    
    Note over C: Path MTU 업데이트&lt;br/&gt;MSS 1360으로 조정
    
    C-&gt;&gt;R: TCP 세그먼트 (1360 B 데이터)
    R-&gt;&gt;S: 전달 성공
    S-&gt;&gt;R: TCP ACK
    R-&gt;&gt;C: ACK 전달
    
    Note over C,S: 이후 1360 B로 계속 전송
</pre><h4 id=tls-레코드-크기와-mtu>TLS 레코드 크기와 MTU<a hidden class=anchor aria-hidden=true href=#tls-레코드-크기와-mtu>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>TLS 레코드 최대 크기: 16 KB (RFC 8446)
</span></span><span class=line><span class=cl>실제 권장 크기: MTU 고려하여 설정
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>예시:
</span></span><span class=line><span class=cl>Path MTU = 1400
</span></span><span class=line><span class=cl>→ MSS = 1400 - 20(IP) - 20(TCP) = 1360 B
</span></span><span class=line><span class=cl>→ TLS 레코드 크기 = 1360 - 5(레코드 헤더) - 16(AEAD 태그) = 1339 B
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>큰 HTTP 응답:
</span></span><span class=line><span class=cl>→ TLS가 자동으로 여러 레코드로 분할
</span></span><span class=line><span class=cl>→ 각 레코드는 MSS 이하로 유지
</span></span><span class=line><span class=cl>→ TCP 세그먼트 단편화 방지
</span></span></code></pre></td></tr></table></div></div><h2 id=실시간-동영상-스트리밍에서의-pdu-흐름>실시간 동영상 스트리밍에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#실시간-동영상-스트리밍에서의-pdu-흐름>#</a></h2><p>라이브/실시간 스트리밍의 일반 경로는 **캡처·인코딩 (Producer) → 인제스트 (Origin) → 패키징 (CMAF/HLS/DASH) → CDN 전송 (Edge) → 플레이어 (Client)**이다.<br>각 홉에서 상위 **SDU(Service Data Unit)**가 하위 계층의 **PDU(Protocol Data Unit)**로 <strong>캡슐화/역캡슐화</strong>되며, 사용 스택에 따라 PDU 이름·오버헤드·복구전략·지연 특성이 달라진다.</p><p><strong>라이브 영상은 L7 미디어 청크가 선택한 전송 스택 (HTTP/3/QUIC 또는 HTTP/2/TCP, 또는 SRTP) 에 따라 서로 다른 PDU(QUIC 패킷·TLS 레코드·TCP 세그먼트·RTP 패킷) 로 포장되어 IP/L2 위를 흐르고, MTU·손실·혼잡 제약 속에서 재전송·적응·버퍼링으로 품질을 유지한다.</strong></p><h3 id=대표-전송-스택>대표 전송 스택<a hidden class=anchor aria-hidden=true href=#대표-전송-스택>#</a></h3><table><thead><tr><th>구분</th><th>계층별 전송 경로</th><th>전송 단위 예시</th><th>보안 계층</th><th>손실/복구 방식</th><th>HOL(Head-of-Line) 블로킹</th><th>특이점</th></tr></thead><tbody><tr><td>LL-HLS/LL-DASH over HTTP/3(QUIC)</td><td>L7 오브젝트 (CMAF 청크) → HTTP/3 프레임 → QUIC 패킷 (가변 길이 +AEAD) → UDP 데이터그램 → IP 패킷 → L2 프레임</td><td>CMAF 청크 (초저지연, 작은 단위)</td><td>TLS 1.3 (QUIC 내장)</td><td>QUIC 재전송, 개별 스트림별 ACK Ranges (국지 복구, stream 단위)</td><td>없음 (QUIC 이 예방)</td><td>초저지연, 모바일 환경 최적화, 연결 이주 지원</td></tr><tr><td>HLS/DASH over HTTP/2(TCP)</td><td>L7 오브젝트 → HTTP/2 프레임 → TLS 레코드 → TCP 세그먼트 → IP 패킷 → L2 프레임</td><td>미디어 세그먼트</td><td>TLS 1.3</td><td>TCP 재전송 전체 연결 기준, 흐름제어</td><td>존재 (연결 단위 HOL)</td><td>기존 CDN 친화, 상대적으로 지연 크다</td></tr><tr><td>WebRTC(SRTP/UDP+DTLS+SCTP)</td><td>RTP 패킷 → SRTP → UDP 데이터그램 → IP 패킷 → L2 프레임 (데이터채널: SCTP→DTLS→UDP 등)</td><td>RTP 패킷 (오디오/비디오 Frame)</td><td>DTLS, SRTP</td><td>실시간 NACK/PLI/FIR 등 (어플리케이션 계층 복구)</td><td>없음 (단방향 패킷 손실은 허용)</td><td>실시간, 양방향 상호작용, 아주 낮은 지연</td></tr></tbody></table><h3 id=단계별-캡슐화역캡슐화>단계별 캡슐화·역캡슐화<a hidden class=anchor aria-hidden=true href=#단계별-캡슐화역캡슐화>#</a></h3><ol><li><p><strong>Producer → Origin(인제스트)</strong></p><ul><li><em>L7 SDU</em>: H.264/H.265/AV1 <strong>프레임/슬라이스</strong></li><li><em>전송 예</em>: <strong>RTMP(Real-Time Messaging Protocol)/TCP</strong>, <strong>SRT(Secure Reliable Transport)/UDP</strong>, <strong>WebRTC(SRTP/UDP)</strong></li><li><em>PDU</em>: RTMP 메시지↔<strong>TCP 세그먼트</strong> / SRT 패킷↔<strong>UDP 데이터그램</strong></li></ul></li><li><p><strong>Origin(패키징) → CDN Edge</strong></p><ul><li><em>L7 SDU</em>: <strong>CMAF(fMP4) 청크</strong>, HLS 세그먼트/파트, DASH 세그먼트, 매니페스트 (playlist/MPD)</li><li><em>PDU</em>: (A) <strong>HTTP/3 프레임 → QUIC 패킷 → UDP → IP → L2</strong> / (B) <strong>HTTP/2 프레임 → TLS 레코드 → TCP 세그먼트 → IP → L2</strong></li></ul></li><li><p><strong>Edge → Player(클라이언트)</strong></p><ul><li>매니페스트 갱신 → 파트/세그먼트 <strong>프리페치/우선순위</strong> 요청</li><li>역캡슐화: <strong>L2 → L3(IP) → L4(UDP/TCP) → (QUIC/TLS 해제) → L7 컨테이너 (fMP4) 파싱 → 디코더</strong></li></ul></li></ol><h4 id=요약-1>요약<a hidden class=anchor aria-hidden=true href=#요약-1>#</a></h4><h5 id=pdu-캡슐화-송신>PDU 캡슐화 (송신)<a hidden class=anchor aria-hidden=true href=#pdu-캡슐화-송신>#</a></h5><ol><li><strong>L7</strong>: 영상 데이터 → RTP 메시지 (1212 B)</li><li><strong>L4</strong>: UDP 헤더 추가 → 데이터그램 (1220 B)</li><li><strong>L3</strong>: IP 헤더 추가 → 패킷 (1240 B)</li><li><strong>L2</strong>: 이더넷 헤더 +FCS → 프레임 (1258 B)</li><li><strong>L1</strong>: 디지털 → 전기 신호 → 전송</li></ol><h5 id=pdu-역캡슐화-수신>PDU 역캡슐화 (수신)<a hidden class=anchor aria-hidden=true href=#pdu-역캡슐화-수신>#</a></h5><ol><li><strong>L1</strong>: 전기 신호 → 디지털 비트</li><li><strong>L2</strong>: 프레임 검증 → 헤더 제거 (1240 B)</li><li><strong>L3</strong>: IP 확인 → 헤더 제거 (1220 B)</li><li><strong>L4</strong>: UDP 확인 → 헤더 제거 (1212 B)</li><li><strong>L7</strong>: RTP 재조립 → 디코딩 → 화면 표시</li></ol><h5 id=각-계층의-역할>각 계층의 역할<a hidden class=anchor aria-hidden=true href=#각-계층의-역할>#</a></h5><ul><li><strong>L7</strong>: 비디오 인코딩/디코딩, 패킷화/재조립</li><li><strong>L4</strong>: 포트 기반 애플리케이션 식별</li><li><strong>L3</strong>: IP 주소 기반 라우팅</li><li><strong>L2</strong>: MAC 주소 기반 로컬 전달, 오류 검출</li><li><strong>L1</strong>: 물리적 신호 전송</li></ul><h3 id=관찰-지점별-pdu-맵>관찰 지점별 PDU 맵<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/3(QUIC/UDP) 보이는 PDU</th><th>HTTP/2(TCP) 보이는 PDU</th><th>WebRTC(SRTP/UDP) 보이는 PDU</th><th>핵심 포인트</th></tr></thead><tbody><tr><td>호스트 소켓 경계</td><td><strong>QUIC 패킷 / H3 프레임</strong></td><td><strong>TLS 레코드 / TCP 세그먼트</strong></td><td><strong>RTP/SRTP/DTLS/RTCP 패킷</strong></td><td>암호화로 중간 가시성↓, 엔드 텔레메트리 중요</td></tr><tr><td>라우터/방화벽 (L3)</td><td><strong>IP 패킷 (UDP)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP)</strong></td><td><strong>ECN(Explicit Congestion Notification)/DSCP</strong> 및 <strong>PMTUD(Path MTU Discovery)/PLPMTUD(Packetization-Layer PMTUD)</strong> 영향</td></tr><tr><td>스위치/무선 AP(L2)</td><td><strong>이더넷/802.11 프레임</strong></td><td>동일</td><td>동일</td><td>무선 MAC 오버헤드, 점보/패딩, 오프로딩 주의</td></tr></tbody></table><h3 id=시퀀스라이브-세그먼트-전달-http3-예시>시퀀스—라이브 세그먼트 전달 (HTTP/3 예시)<a hidden class=anchor aria-hidden=true href=#시퀀스라이브-세그먼트-전달-http3-예시>#</a></h3><pre class=mermaid>sequenceDiagram
%% title: live-h3-pdu
participant P as Player(Client)
participant E as CDN Edge
participant O as Origin
P-&gt;&gt;E: GET /playlist.m3u8 (HTTP/3)
E--&gt;&gt;P: playlist (QUIC packets)
P-&gt;&gt;E: GET /seg_101_part_1.m4s (HTTP/3)
E--&gt;&gt;P: part_1 (CMAF chunk in QUIC)
E-&gt;&gt;O: cache miss → fetch chunk (HTTP/3)
O--&gt;&gt;E: chunk (HTTP/3/QUIC)
Note over P,E: L7 chunk → H3 frame → QUIC packet → UDP → IP → L2
</pre><hr><h3 id=webrtc-경로-핵심-초저지연상호작용>WebRTC 경로 핵심 (초저지연·상호작용)<a hidden class=anchor aria-hidden=true href=#webrtc-경로-핵심-초저지연상호작용>#</a></h3><ul><li>**ICE(Interactive Connectivity Establishment)**가 **STUN(Session Traversal Utilities for NAT)/TURN(Traversal Using Relays around NAT)**으로 경로를 찾고, <strong>DTLS</strong>로 키 교환 후 <strong>SRTP</strong>로 미디어 보호.</li><li>수신 품질 피드백은 <strong>RTCP</strong>의 <strong>NACK(Negative Acknowledgement)/PLI(Picture Loss Indication)/FIR(Full Intra Request)</strong>.</li><li>손실 복구: <strong>RTX(RTP Retransmission)</strong>, <strong>FEC(Forward Error Correction)</strong>, <strong>SVC(Scalable Video Coding)</strong> 조합.</li></ul><pre class=mermaid>sequenceDiagram
%% title: webrtc-pdu
participant Pub as Publisher
participant SFU as SFU(Selective Forwarding Unit)
participant Sub as Subscriber(Player)
Pub-&gt;&gt;SFU: DTLS handshake (over UDP)
SFU--&gt;&gt;Pub: DTLS complete
Pub-&gt;&gt;SFU: SRTP media (RTP protected)
Sub--&gt;&gt;SFU: RTCP RR/NACK/PLI
SFU--&gt;&gt;Sub: SRTP media (forwarded)
Note over Pub,Sub: RTP → SRTP → UDP → IP → L2
</pre><h3 id=mtumss단편화스트리밍-맥락>MTU/MSS/단편화—스트리밍 맥락<a hidden class=anchor aria-hidden=true href=#mtumss단편화스트리밍-맥락>#</a></h3><ul><li><strong>IPv6 최소 MTU = 1280 바이트</strong>, <strong>QUIC Initial ≥ ≈1200 바이트</strong>: 초기 QUIC 핸드셰이크는 큰 패킷을 요구하므로, <strong>터널/VPN(예: VXLAN, IPsec)</strong> 오버헤드를 뺀 <strong>Path MTU</strong> 기준으로 <strong>UDP 페이로드 상한</strong>을 계산해야 합니다.</li><li><strong>MSS(Maximum Segment Size) 협상 (TCP)</strong>: SYN/SYN-ACK 에서 <strong>min(MSS)</strong> 채택 → 이후 <strong>PMTUD/PLPMTUD</strong>로 추가 축소 가능. 방화벽/경계에서 <strong>MSS 클램핑</strong>은 블랙홀 예방책.</li><li><strong>단편화 (Fragmentation) 회피</strong>가 원칙: IPv4 는 DF=0 에서 라우터 단편화 가능하지만 지양, <strong>IPv6 라우터 단편화 금지</strong>(송신자만 분할). 실패 시 <strong>ICMP PTB(Packet Too Big)/Frag Needed</strong>로 축소 유도.</li></ul><h4 id=mtu-와-pdu-의-관계>MTU 와 PDU 의 관계<a hidden class=anchor aria-hidden=true href=#mtu-와-pdu-의-관계>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MTU 1500 B = L3 패킷 최대 크기
</span></span><span class=line><span class=cl>→ L4 데이터 최대 = 1500 - 20(IP) = 1480 B
</span></span><span class=line><span class=cl>→ L7 메시지 최대 = 1480 - 8(UDP) = 1472 B
</span></span><span class=line><span class=cl>→ RTP 페이로드 최대 = 1472 - 12(RTP) = 1460 B
</span></span><span class=line><span class=cl>→ 실전 권장 = 1200 B (안전 마진)
</span></span></code></pre></td></tr></table></div></div><p>이 과정을 통해 영상 데이터는 송신자에서 수신자까지 각 계층의 PDU 로 변환되며 전달된다.</p><h3 id=손실혼잡-시-복구-비교-요점>손실·혼잡 시 복구 비교 (요점)<a hidden class=anchor aria-hidden=true href=#손실혼잡-시-복구-비교-요점>#</a></h3><table><thead><tr><th>스택</th><th>전송 PDU</th><th>복구 방식</th><th>HOL(Head-of-Line) 영향</th><th>비고</th></tr></thead><tbody><tr><td>HTTP/3(QUIC/UDP/TLS 1.3)</td><td><strong>QUIC 패킷</strong></td><td><strong>ACK Ranges</strong>, 손실 패킷만 재전송</td><td>스트림 독립 → HOL 완화</td><td>초기 패킷 ≥≈1200B 요구</td></tr><tr><td>HTTP/2(TCP/TLS 1.3)</td><td><strong>TCP 세그먼트</strong></td><td>빠른 재전송/타임아웃 기반</td><td>연결 단위 HOL</td><td>손실이 전 스트림 지연으로 전파</td></tr><tr><td>WebRTC(SRTP/UDP)</td><td><strong>RTP/SRTP 패킷</strong></td><td><strong>NACK/RTX</strong>, <strong>FEC</strong>, <strong>SVC</strong></td><td>애플리케이션 전략</td><td>초저지연은 ARQ 최소화</td></tr></tbody></table><h3 id=지연-예산-end-to-end-latency-budget-전형-가이드>지연 예산 (End-to-End Latency Budget, 전형 가이드)<a hidden class=anchor aria-hidden=true href=#지연-예산-end-to-end-latency-budget-전형-가이드>#</a></h3><table><thead><tr><th>단계</th><th>주체/지점</th><th>전형 범위</th><th>주의 포인트</th></tr></thead><tbody><tr><td>캡처/인코딩</td><td>카메라/인코더</td><td>5–60 ms</td><td>B- 프레임/긴 GOP 는 지연↑</td></tr><tr><td>인제스트</td><td>퍼블리셔→오리진</td><td>5–30 ms(RTT 의존)</td><td>RTMP(TCP) 는 재전송/혼잡 영향</td></tr><tr><td>패키징</td><td>오리진</td><td>≈0–30 ms</td><td>**CMAF 파트 길이 (200–500 ms)**가 LL 지연 바닥</td></tr><tr><td>CDN 전송</td><td>오리진↔엣지</td><td>1–20 ms</td><td>캐시 HIT/MISS 차이</td></tr><tr><td>플레이어 네트워크</td><td>엣지↔단말</td><td>10–150 ms</td><td><strong>ECN/AQM</strong>, 무선 변동성</td></tr><tr><td>지터 버퍼</td><td>플레이어</td><td>50–300 ms</td><td>손실/변동↑ → 버퍼↑</td></tr><tr><td>디코딩/렌더</td><td>단말</td><td>8–40 ms</td><td>HW 디코더/디스플레이 동기</td></tr></tbody></table><p><strong>전형 합계</strong>: WebRTC ≈ <strong>100–300 ms</strong>, LL-HLS/LL-DASH ≈ <strong>0.5–3 s</strong>, 전통 HLS/DASH(2–6 s 세그먼트) ≈ <strong>3–30 s</strong>.</p><h3 id=품질지연-최적화-체크리스트-수신자운영자-관점>품질·지연 최적화 체크리스트 (수신자/운영자 관점)<a hidden class=anchor aria-hidden=true href=#품질지연-최적화-체크리스트-수신자운영자-관점>#</a></h3><ul><li><strong>ABR(Adaptive Bitrate)</strong>: 목표 버퍼 (예: 2–6 s), 다운스위치 임계값을 <strong>RTT/손실률</strong>과 정합.</li><li><strong>ECN/DSCP(Differentiated Services Code Point)</strong>: 경로 지원 시 활성화, **AQM(Active Queue Management)**와 조합.</li><li><strong>QUIC 튜닝</strong>: 패킷 페이싱, 초기 윈도, 재전송 타이머, ACK 배송 정책 조정.</li><li><strong>Wi-Fi/5G</strong>: 변동 MTU/지연/손실 → <strong>작은 파트</strong>, 다중 연결/도메인 (shard) 병렬화.</li><li><strong>ICMP 정책</strong>: <strong>PTB/Frag Needed</strong> 허용 (레이트리밋), <strong>PLPMTUD</strong> 병행.</li><li><strong>오버헤드/터널</strong>: 터널 인터페이스 <strong>MTU 하향 + 내부 MSS 클램핑</strong> 동시 적용.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: 성능↑/가시성↓ → 경계 캡처로 온와이어 재검증.</li></ul><h4 id=부록-간단-산식-메모>(부록) 간단 산식 메모<a hidden class=anchor aria-hidden=true href=#부록-간단-산식-메모>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Max</span> <span class=n>L7</span> <span class=n>payload</span> <span class=err>≈</span> <span class=ne>Path</span> <span class=n>MTU</span> <span class=err>−</span> <span class=p>(</span><span class=ne>IP</span> <span class=err>헤더</span> <span class=o>+</span> <span class=n>L4</span> <span class=err>헤더</span> <span class=o>+</span> <span class=err>보안</span><span class=o>/</span><span class=err>옵션</span><span class=o>/</span><span class=err>오버레이</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>예</span><span class=p>:</span> <span class=n>IPv6</span><span class=o>/</span><span class=n>TCP</span> <span class=o>+</span> <span class=n>TLS1</span><span class=o>.</span><span class=mi>3</span> <span class=err>@</span> <span class=n>MTU</span> <span class=mi>1500</span> <span class=err>→</span> <span class=mi>1500</span> <span class=err>−</span> <span class=p>(</span><span class=mi>40</span> <span class=o>+</span> <span class=mi>20</span> <span class=o>+</span> <span class=o>~</span><span class=mi>21</span><span class=p>)</span> <span class=err>≈</span> <span class=mi>1419</span> <span class=n>B</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=pdu-크기-변화-요약>PDU 크기 변화 요약<a hidden class=anchor aria-hidden=true href=#pdu-크기-변화-요약>#</a></h3><pre class=mermaid>graph LR
    A[&#34;L7 메시지&lt;br/&gt;1212 B&#34;] 
    B[&#34;L4 데이터그램&lt;br/&gt;1220 B&lt;br/&gt;(+8)&#34;]
    C[&#34;L3 패킷&lt;br/&gt;1240 B&lt;br/&gt;(+20)&#34;]
    D[&#34;L2 프레임&lt;br/&gt;1258 B&lt;br/&gt;(+18)&#34;]
    E[&#34;L1 비트&lt;br/&gt;10064 bits&#34;]
    
    A --&gt;|UDP 캡슐화| B
    B --&gt;|IP 캡슐화| C
    C --&gt;|이더넷 캡슐화| D
    D --&gt;|물리 인코딩| E
    
    E -.-&gt;|물리 디코딩| D
    D -.-&gt;|이더넷 역캡슐화| C
    C -.-&gt;|IP 역캡슐화| B
    B -.-&gt;|UDP 역캡슐화| A
    
    style A fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style B fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style C fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style D fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style E fill:#fce4ec,stroke:#c2185b,stroke-width:2px
</pre><h4 id=캡슐화-과정-송신>캡슐화 과정 (송신)<a hidden class=anchor aria-hidden=true href=#캡슐화-과정-송신>#</a></h4><table><thead><tr><th>단계</th><th>PDU 이름</th><th style=text-align:right>크기</th><th>추가된 헤더</th><th>누적 오버헤드</th></tr></thead><tbody><tr><td>L7</td><td>RTP 메시지</td><td style=text-align:right>1212 B</td><td>-</td><td>0 B</td></tr><tr><td>L4</td><td>UDP 데이터그램</td><td style=text-align:right>1220 B</td><td>UDP(8)</td><td>8 B</td></tr><tr><td>L3</td><td>IP 패킷</td><td style=text-align:right>1240 B</td><td>IPv4(20)</td><td>28 B</td></tr><tr><td>L2</td><td>이더넷 프레임</td><td style=text-align:right>1258 B</td><td>Eth(14)+FCS(4)</td><td>46 B</td></tr><tr><td>L1</td><td>비트 스트림</td><td style=text-align:right>10064 bits</td><td>-</td><td>-</td></tr></tbody></table><p><strong>오버헤드 비율</strong>: 46 B / 1212 B = <strong>3.8%</strong></p><h4 id=역캡슐화-과정-수신>역캡슐화 과정 (수신)<a hidden class=anchor aria-hidden=true href=#역캡슐화-과정-수신>#</a></h4><table><thead><tr><th>단계</th><th>PDU 이름</th><th style=text-align:right>크기</th><th>제거된 헤더</th><th>남은 데이터</th></tr></thead><tbody><tr><td>L1</td><td>비트 스트림</td><td style=text-align:right>10064 bits</td><td>-</td><td>1258 B</td></tr><tr><td>L2</td><td>이더넷 프레임</td><td style=text-align:right>1258 B</td><td>Eth(14)+FCS(4)</td><td>1240 B</td></tr><tr><td>L3</td><td>IP 패킷</td><td style=text-align:right>1240 B</td><td>IPv4(20)</td><td>1220 B</td></tr><tr><td>L4</td><td>UDP 데이터그램</td><td style=text-align:right>1220 B</td><td>UDP(8)</td><td>1212 B</td></tr><tr><td>L7</td><td>RTP 메시지</td><td style=text-align:right>1212 B</td><td>RTP(12)</td><td>1200 B</td></tr></tbody></table><h3 id=실전-예시-한-프레임의-전체-여정>실전 예시: 한 프레임의 전체 여정<a hidden class=anchor aria-hidden=true href=#실전-예시-한-프레임의-전체-여정>#</a></h3><h4 id=송신-측-타임라인>송신 측 타임라인<a hidden class=anchor aria-hidden=true href=#송신-측-타임라인>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1> 1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2> 2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3> 3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4> 4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5> 5</a>
</span><span class=lnt id=hl-25-6><a class=lnlinks href=#hl-25-6> 6</a>
</span><span class=lnt id=hl-25-7><a class=lnlinks href=#hl-25-7> 7</a>
</span><span class=lnt id=hl-25-8><a class=lnlinks href=#hl-25-8> 8</a>
</span><span class=lnt id=hl-25-9><a class=lnlinks href=#hl-25-9> 9</a>
</span><span class=lnt id=hl-25-10><a class=lnlinks href=#hl-25-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=0ms    : 카메라에서 원본 프레임 캡처 (1920×1080)
</span></span><span class=line><span class=cl>T=5ms    : H.264 인코딩 완료 (8 KB 압축)
</span></span><span class=line><span class=cl>T=6ms    : RTP 패킷화 (7개 패킷으로 분할)
</span></span><span class=line><span class=cl>T=7ms    : 첫 번째 RTP 패킷 전송 시작
</span></span><span class=line><span class=cl>           └─ L4 캡슐화 (UDP 헤더 추가)
</span></span><span class=line><span class=cl>           └─ L3 캡슐화 (IP 헤더 추가)
</span></span><span class=line><span class=cl>           └─ L2 캡슐화 (이더넷 프레임화)
</span></span><span class=line><span class=cl>           └─ L1 전송 (NIC로 전기 신호 송출)
</span></span><span class=line><span class=cl>T=8ms    : 두 번째 RTP 패킷 전송...
</span></span><span class=line><span class=cl>T=13ms   : 일곱 번째 RTP 패킷 전송 완료
</span></span></code></pre></td></tr></table></div></div><h4 id=네트워크-전송>네트워크 전송<a hidden class=anchor aria-hidden=true href=#네트워크-전송>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=14ms   : 패킷들이 네트워크를 통해 전파
</span></span><span class=line><span class=cl>           - 라우터 1 통과 (1 ms)
</span></span><span class=line><span class=cl>           - 라우터 2 통과 (1 ms)
</span></span><span class=line><span class=cl>           - 인터넷 백본 (20 ms)
</span></span><span class=line><span class=cl>           - ISP 라우터 (2 ms)
</span></span></code></pre></td></tr></table></div></div><h4 id=수신-측-타임라인>수신 측 타임라인<a hidden class=anchor aria-hidden=true href=#수신-측-타임라인>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1> 1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2> 2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3> 3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4> 4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5> 5</a>
</span><span class=lnt id=hl-27-6><a class=lnlinks href=#hl-27-6> 6</a>
</span><span class=lnt id=hl-27-7><a class=lnlinks href=#hl-27-7> 7</a>
</span><span class=lnt id=hl-27-8><a class=lnlinks href=#hl-27-8> 8</a>
</span><span class=lnt id=hl-27-9><a class=lnlinks href=#hl-27-9> 9</a>
</span><span class=lnt id=hl-27-10><a class=lnlinks href=#hl-27-10>10</a>
</span><span class=lnt id=hl-27-11><a class=lnlinks href=#hl-27-11>11</a>
</span><span class=lnt id=hl-27-12><a class=lnlinks href=#hl-27-12>12</a>
</span><span class=lnt id=hl-27-13><a class=lnlinks href=#hl-27-13>13</a>
</span><span class=lnt id=hl-27-14><a class=lnlinks href=#hl-27-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>T=38ms   : 첫 번째 패킷 도착
</span></span><span class=line><span class=cl>           └─ L1 수신 (NIC에서 비트 수신)
</span></span><span class=line><span class=cl>           └─ L2 역캡슐화 (이더넷 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L3 역캡슐화 (IP 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L4 역캡슐화 (UDP 헤더 제거)
</span></span><span class=line><span class=cl>           └─ L7 처리 (RTP 버퍼에 저장)
</span></span><span class=line><span class=cl>T=39ms   : 두 번째 패킷 도착...
</span></span><span class=line><span class=cl>T=40ms   : 세 번째 패킷 손실! (네트워크 혼잡)
</span></span><span class=line><span class=cl>T=41ms   : 네 번째 패킷 도착...
</span></span><span class=line><span class=cl>T=45ms   : 일곱 번째 패킷 도착
</span></span><span class=line><span class=cl>T=46ms   : 손실 패킷 복구 (FEC 또는 재전송)
</span></span><span class=line><span class=cl>T=50ms   : 지터 버퍼에서 프레임 추출
</span></span><span class=line><span class=cl>T=55ms   : H.264 디코딩 완료
</span></span><span class=line><span class=cl>T=60ms   : GPU 렌더링 및 화면 표시
</span></span></code></pre></td></tr></table></div></div><p><strong>총 엔드투엔드 지연</strong>: 60 ms (캡처 → 화면)</p><h2 id=대용량-파일-다운로드에서의-pdu-흐름>대용량 파일 다운로드에서의 PDU 흐름<a hidden class=anchor aria-hidden=true href=#대용량-파일-다운로드에서의-pdu-흐름>#</a></h2><p><strong>대용량 다운로드</strong>는 애플리케이션의 바이트 스트림이 전송 스택에서 <strong>TLS 1.3 레코드 (Transport Layer Security 1.3 Record) → TCP 세그먼트 (Transmission Control Protocol Segment) 또는 QUIC 패킷 (Quick UDP Internet Connections Packet) → IP 패킷 (Internet Protocol Packet) → L2 프레임</strong> 순으로 <strong>반복 캡슐화</strong>되어 흐르며, 실제 처리량은 **MSS(Maximum Segment Size)·PMTUD(Path MTU Discovery)/PLPMTUD(Packetization-Layer PMTUD)·혼잡 윈도 (cwnd)·수신 윈도 (rwnd/Window Scaling)·재전송 (SACK/ACK Ranges)·오프로딩 (TSO/GSO/GRO)**의 상호작용으로 결정된다.<br>목표는 <strong>단편화 없이 (Path MTU 이내)</strong> 꾸준히 흘려보내는 것이다.</p><h3 id=전체-경로와-단계-송신--경로--수신>전체 경로와 단계 (송신 → 경로 → 수신)<a hidden class=anchor aria-hidden=true href=#전체-경로와-단계-송신--경로--수신>#</a></h3><ol><li><p><strong>서버 (송신)</strong></p><ul><li>L7 SDU(Service Data Unit): 파일 바이트 스트림</li><li><strong>TLS 1.3</strong> 사용 시 수 KB~수십 KB 크기의 <strong>TLS 레코드</strong>로 잘라 암호화 (AEAD: Authenticated Encryption with Associated Data).</li><li>전송 계층이 <strong>MSS</strong>를 기준으로 <strong>TCP 세그먼트</strong>(HTTP/2/1.1) 또는 <strong>QUIC 패킷</strong>(HTTP/3) 으로 분할.</li><li><strong>TSO/GSO</strong>가 켜져 있으면 커널은 큰 청크를 NIC 가 온와이어 <strong>MSS 단위</strong>로 쪼개도록 위임.</li></ul></li><li><p><strong>네트워크 경로 (라우터/방화벽)</strong></p><ul><li>각 홉 egress 에서 <strong>다음 홉 MTU</strong>를 넘는지 판정.</li><li><strong>IPv4</strong>: DF=0 이면 (지양하지만) 라우터 단편화 가능, DF=1 이면 드롭 + <strong>ICMP Frag Needed</strong> 통지.</li><li><strong>IPv6</strong>: 라우터 단편화 금지 → <strong>ICMPv6 Packet Too Big</strong>로 송신자 축소 유도.</li><li>송신자는 <strong>PMTUD/PLPMTUD</strong>로 안전한 크기를 학습.</li></ul></li><li><p><strong>클라이언트 (수신)</strong></p><ul><li>IP 에서 재조립 (필요 시) → L4 로 인도.</li><li>TCP 는 <strong>순서 재정렬·SACK(Selective ACK) 기반 손실 복구·혼잡제어</strong> 수행 / QUIC 은 <strong>ACK Ranges</strong>로 손실 구간만 재전송.</li><li>TLS 복호화 후 <strong>HTTP 바디</strong>를 파일에 기록. <strong>rwnd(Receive Window)</strong> 및 <strong>Window Scaling</strong>이 작으면 BDP(대역폭×지연) 대비 병목.</li></ul></li></ol><h3 id=전송-스택별-pdu-흐름>전송 스택별 PDU 흐름<a hidden class=anchor aria-hidden=true href=#전송-스택별-pdu-흐름>#</a></h3><h4 id=http2tcp--tls-13-기반>HTTP/2(TCP / TLS 1.3) 기반<a hidden class=anchor aria-hidden=true href=#http2tcp--tls-13-기반>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>앱 바이트 → [TLS 레코드] → [TCP 세그먼트(MSS)] → [IP 패킷] → [L2 프레임]
</span></span><span class=line><span class=cl>손실: TCP 빠른재전송/타임아웃, SACK으로 결손 범위만 재전송 (그러나 연결 단위 HOL 영향)
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>sequenceDiagram
%% title: large-download-h2-tcp
participant C as Client
participant N as Network (Routers)
participant S as Server
C-&gt;&gt;S: TCP 3-way (MSS 협상)
S--&gt;&gt;C: TLS1.3 핸드셰이크(Records)
C-&gt;&gt;S: GET /big.iso (HTTP/2)
S--&gt;&gt;C: HTTP/2 DATA (연속) → TLS Records
Note over S,N: TLS 레코드 → TCP 세그먼트(MSS) → IP → L2
loop steady transfer
  S--&gt;&gt;C: [세그먼트 n..n+k]
  C--&gt;&gt;S: ACK/SACK (누락 범위 통지)
end
alt 손실 발생
  N--&gt;&gt;S: (드롭)
  C--&gt;&gt;S: SACK으로 결손 알림
  S--&gt;&gt;C: 손실 세그먼트만 재전송
end
</pre><p><strong>세그먼트 단위</strong>로 흐르고, <strong>cwnd/rwnd</strong>가 충족되면 파이프가 가득 차며, <strong>SACK</strong>이 부분 손실만 신속 복구한다. PMTUD/PLPMTUD 실패 시 특정 크기에서 멈춤 (블랙홀) 이 발생한다.</p><h4 id=http3quic--udp--tls-13-기반>HTTP/3(QUIC / UDP / TLS 1.3) 기반<a hidden class=anchor aria-hidden=true href=#http3quic--udp--tls-13-기반>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>앱 바이트 → [HTTP/3 프레임] → [QUIC 패킷(AEAD)] → [UDP 데이터그램] → [IP] → [L2]
</span></span><span class=line><span class=cl>손실: QUIC이 해당 패킷 번호 범위만 재전송, 스트림 단위로 HOL 완화
</span></span><span class=line><span class=cl>초기: QUIC Initial 패킷은 경로 안전성 위해 ≈1200B 이상(IPv6 1280B 최소 MTU와 호환 고려)
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>sequenceDiagram
%% title: large-download-h3-quic
participant C as Client
participant N as Network (Routers)
participant S as Server
C-&gt;&gt;S: QUIC Initial (~1200B)
S--&gt;&gt;C: QUIC Initial (1-RTT)
C-&gt;&gt;S: GET /big.iso (H3)
loop steady transfer
  S--&gt;&gt;C: H3 DATA frames → QUIC packets
  C--&gt;&gt;S: ACK Ranges (손실 범위 보고)
end
alt 손실 발생
  N--&gt;&gt;S: (드롭)
  S--&gt;&gt;C: 해당 패킷 번호 범위만 재전송 (스트림 HOL 완화)
end
</pre><p>QUIC 은 <strong>사용자 공간 전송 + ACK Ranges</strong>로 빠른 손실 국지화와 스트림 수준 복구가 가능하다. UDP 경로 특성, PTB 수신 및 PLPMTUD 정책이 안정성을 좌우한다.</p><h3 id=캡슐화역캡슐화한-번의-온와이어-예-ipv6tcptls>캡슐화·역캡슐화—한 번의 온와이어 예 (IPv6/TCP/TLS)<a hidden class=anchor aria-hidden=true href=#캡슐화역캡슐화한-번의-온와이어-예-ipv6tcptls>#</a></h3><ul><li>가정: <strong>MTU 1500B</strong>, IPv6(40B) + TCP(20B) + <strong>TLS 1.3 오버헤드 ≈21B</strong></li><li><strong>유효 TCP 페이로드 (=MSS)</strong> ≈ <code>1500 − 40 − 20 − 21 = 1419B</code></li><li>TLS 레코드가 8KB 라면 <strong>MSS 배수</strong>로 나뉘어 여러 세그먼트로 전송됨.</li><li>수신 측은 L2→L3→L4→L7 순으로 <strong>헤더 제거 (역캡슐화)</strong> 후 원본 바이트를 파일에 기록.</li></ul><blockquote><p>포인트: <strong>TLS 레코드 크기</strong>가 MSS 와 정렬되지 않으면 여분 세그먼트/패딩·작은 PDU 가 늘어 효율이 떨어질 수 있습니다.</p></blockquote><h4 id=요약-2>요약<a hidden class=anchor aria-hidden=true href=#요약-2>#</a></h4><h5 id=송신-측-캡슐화-7-단계>송신 측 캡슐화 (7 단계)<a hidden class=anchor aria-hidden=true href=#송신-측-캡슐화-7-단계>#</a></h5><ol><li><strong>TCP 연결 설정</strong> → 3-Way Handshake, MSS 협상</li><li><strong>HTTP 응답 생성</strong> → 헤더 + 파일 데이터</li><li><strong>TLS 암호화</strong> → 16 KB 레코드 단위 (HTTPS)</li><li><strong>TCP 세그먼트화</strong> → MSS 단위 분할 (1460 B)</li><li><strong>흐름/혼잡 제어</strong> → 윈도우, Slow Start, ACK</li><li><strong>IP 캡슐화</strong> → DF=1, PMTUD</li><li><strong>이더넷 프레임화</strong> → MAC, FCS</li></ol><h5 id=수신-측-역캡슐화-9-단계>수신 측 역캡슐화 (9 단계)<a hidden class=anchor aria-hidden=true href=#수신-측-역캡슐화-9-단계>#</a></h5><ol><li><strong>물리 신호 수신</strong> → 디지털 변환</li><li><strong>이더넷 검증</strong> → FCS 체크</li><li><strong>IP 처리</strong> → 목적지 확인</li><li><strong>TCP 재조립</strong> → 시퀀스 순서 보장</li><li><strong>ACK 전송</strong> → 흐름 제어</li><li><strong>TLS 복호화</strong> → 무결성 검증</li><li><strong>HTTP 파싱</strong> → 헤더/바디 분리</li><li><strong>파일 저장</strong> → 디스크 쓰기</li><li><strong>무결성 검증</strong> → MD5/SHA</li></ol><h3 id=mtumss단편화-동작>MTU·MSS·단편화 동작<a hidden class=anchor aria-hidden=true href=#mtumss단편화-동작>#</a></h3><ul><li><strong>MTU(Maximum Transmission Unit, L3 상한)</strong><ul><li>결정 지점: 인터페이스/NIC, 터널 인터페이스, 라우팅 경로 (최솟값이 Path MTU).</li><li>조치: 터널·VPN·오버레이가 있으면 <strong>외부 MTU 대비 내부 MTU 하향</strong> 필수.</li></ul></li><li><strong>MSS(Maximum Segment Size, TCP 데이터 상한)</strong><ul><li>결정 지점: <strong>SYN/SYN-ACK</strong> 옵션에서 <strong>min(MSS)</strong> 채택 (중간장비의 <strong>MSS 클램핑</strong>이 개입 가능).</li><li>운용: PMTUD/PLPMTUD 결과에 맞춰 송신자가 세그먼트/레코드 크기 추가 축소.</li></ul></li><li><strong>단편화 (Fragmentation)</strong><ul><li>원칙: <strong>회피</strong>. IPv4 는 DF=0 에서만 라우터 단편화 가능 (권장 X), IPv6 라우터 단편화 금지 (송신자만 분할).</li><li>실패 신호: <strong>ICMP Frag Needed/Packet Too Big</strong>. 필터링되면 <strong>PLPMTUD</strong>로 대체 학습.</li></ul></li></ul><h3 id=처리량을-좌우하는-6-요소>처리량을 좌우하는 6 요소<a hidden class=anchor aria-hidden=true href=#처리량을-좌우하는-6-요소>#</a></h3><ol><li><strong>cwnd(혼잡 윈도)</strong>: 혼잡제어 상태 (초기 슬로스타트→회피).</li><li><strong>rwnd(수신 윈도/Window Scaling)</strong>: BDP(대역폭×RTT) 에 맞게 충분히 커야 함.</li><li><strong>RTT(Round-Trip Time)</strong>: 지연이 클수록 같은 cwnd 로 덜 전송됨 → <strong>패이싱</strong> 유효.</li><li><strong>손실·재전송</strong>: TCP 는 <strong>SACK</strong>, QUIC 은 <strong>ACK Ranges</strong>로 손실 구간만 신속 복구.</li><li><strong>ECN(Explicit Congestion Notification)/DSCP</strong>: 드롭 없이 혼잡 신호, 클래스별 QoS.</li><li><strong>오프로딩 (TSO/GSO/GRO)</strong>: CPU/PPS 이득 크지만 <strong>캡처 착시</strong> 유발 → 경계 캡처로 교차검증.</li></ol><blockquote><p><strong>BDP 산식</strong>: <code>BDP(bytes) = Bandwidth(bytes/s) × RTT(s)</code> → rwnd·cwnd·버퍼가 <strong>BDP 이상</strong>이어야 라인을 채웁니다.</p></blockquote><h3 id=http-계층-특화-대용량-전송-튜닝>HTTP 계층 특화 (대용량 전송 튜닝)<a hidden class=anchor aria-hidden=true href=#http-계층-특화-대용량-전송-튜닝>#</a></h3><ul><li><strong>Range 요청 + 206 Partial Content</strong>: <strong>중단 지점 재개</strong>(Resume).</li><li><strong>병렬 범위 다운로드</strong>: 벽시계 단축 가능 (여러 TCP/QUIC 흐름) ↔ <strong>cwnd 공정성·서버/경로 부하</strong> 고려.</li><li><strong>캐시/CDN</strong>: 엣지 <strong>HIT</strong>면 경로 짧아지고 손실 위험↓, <strong>MISS</strong>면 <em>Origin↔Edge</em> 구간에도 동일 PDU 파이프라인이 한 번 더 생김.</li><li><strong>TLS 레코드 크기</strong>: 너무 작으면 헤더 비율↑, 너무 크면 손실 시 재전송 비용↑ → 보통 <strong>수 KB~수십 KB</strong> + <strong>MSS 배수 정렬</strong> 권장.</li></ul><h3 id=관찰-지점별-pdu-맵-1>관찰 지점별 PDU 맵<a hidden class=anchor aria-hidden=true href=#관찰-지점별-pdu-맵-1>#</a></h3><table><thead><tr><th>관찰 지점</th><th>HTTP/2(TCP/TLS 1.3) 보이는 PDU</th><th>HTTP/3(QUIC/UDP/TLS 1.3) 보이는 PDU</th><th>공통</th></tr></thead><tbody><tr><td><strong>호스트 소켓 경계</strong></td><td><strong>TLS 레코드 ↔ TCP 세그먼트</strong></td><td><strong>HTTP/3 프레임 ↔ QUIC 패킷</strong></td><td>장기 세션, PDU 다량 생성</td></tr><tr><td><strong>L3 장비 (라우터/방화벽)</strong></td><td><strong>IP 패킷 (TCP)</strong></td><td><strong>IP 패킷 (UDP)</strong></td><td>ECN/DSCP, <strong>PTB/FragNeeded</strong> 가시</td></tr><tr><td><strong>L2(스위치/AP)</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td><strong>이더넷/802.11 프레임</strong></td><td>점보/무선 MAC 오버헤드·오프로딩 주의</td></tr></tbody></table><h3 id=tcp-특성이-파일-전송에-미치는-영향>TCP 특성이 파일 전송에 미치는 영향<a hidden class=anchor aria-hidden=true href=#tcp-특성이-파일-전송에-미치는-영향>#</a></h3><h4 id=재전송-메커니즘>재전송 메커니즘<a hidden class=anchor aria-hidden=true href=#재전송-메커니즘>#</a></h4><pre class=mermaid>sequenceDiagram
    participant C as 클라이언트
    participant S as 서버
    
    S-&gt;&gt;C: SEQ=1000, DATA[1460B]
    C-&gt;&gt;S: ACK=2460
    
    S-&gt;&gt;C: SEQ=2460, DATA[1460B]
    Note over C: 패킷 손실!
    
    S-&gt;&gt;C: SEQ=3920, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 1)
    
    S-&gt;&gt;C: SEQ=5380, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 2)
    
    S-&gt;&gt;C: SEQ=6840, DATA[1460B]
    C-&gt;&gt;S: ACK=2460 (중복 3)
    
    Note over S: 3 중복 ACK 감지&lt;br/&gt;Fast Retransmit
    
    S-&gt;&gt;C: SEQ=2460, DATA[1460B] (재전송)
    C-&gt;&gt;S: ACK=8300 (누적 ACK)
    
    Note over C,S: 정상 전송 재개
</pre><p><strong>재전송 시나리오 3 가지</strong>:</p><ol><li><strong>Fast Retransmit</strong> (빠른 재전송)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>3개 중복 ACK 수신 → 즉시 재전송
</span></span><span class=line><span class=cl>지연: 매우 낮음 (수 ms)
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>Timeout Retransmit</strong> (타임아웃 재전송)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>RTO (Retransmission Timeout) 초과 → 재전송
</span></span><span class=line><span class=cl>지연: 높음 (수백 ms ~ 초)
</span></span><span class=line><span class=cl>RTO = SRTT + 4 × RTTVAR
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>Selective Acknowledgment (SACK)</strong></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2>2</a>
</span><span class=lnt id=hl-35-3><a class=lnlinks href=#hl-35-3>3</a>
</span><span class=lnt id=hl-35-4><a class=lnlinks href=#hl-35-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>정확한 손실 범위 통보:
</span></span><span class=line><span class=cl>SACK: 3920-8300 수신 완료
</span></span><span class=line><span class=cl>→ 서버는 2460-3919만 재전송
</span></span><span class=line><span class=cl>→ 효율적 (불필요한 재전송 방지)
</span></span></code></pre></td></tr></table></div></div><h4 id=혼잡-제어의-영향>혼잡 제어의 영향<a hidden class=anchor aria-hidden=true href=#혼잡-제어의-영향>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1> 1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2> 2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3> 3</a>
</span><span class=lnt id=hl-36-4><a class=lnlinks href=#hl-36-4> 4</a>
</span><span class=lnt id=hl-36-5><a class=lnlinks href=#hl-36-5> 5</a>
</span><span class=lnt id=hl-36-6><a class=lnlinks href=#hl-36-6> 6</a>
</span><span class=lnt id=hl-36-7><a class=lnlinks href=#hl-36-7> 7</a>
</span><span class=lnt id=hl-36-8><a class=lnlinks href=#hl-36-8> 8</a>
</span><span class=lnt id=hl-36-9><a class=lnlinks href=#hl-36-9> 9</a>
</span><span class=lnt id=hl-36-10><a class=lnlinks href=#hl-36-10>10</a>
</span><span class=lnt id=hl-36-11><a class=lnlinks href=#hl-36-11>11</a>
</span><span class=lnt id=hl-36-12><a class=lnlinks href=#hl-36-12>12</a>
</span><span class=lnt id=hl-36-13><a class=lnlinks href=#hl-36-13>13</a>
</span><span class=lnt id=hl-36-14><a class=lnlinks href=#hl-36-14>14</a>
</span><span class=lnt id=hl-36-15><a class=lnlinks href=#hl-36-15>15</a>
</span><span class=lnt id=hl-36-16><a class=lnlinks href=#hl-36-16>16</a>
</span><span class=lnt id=hl-36-17><a class=lnlinks href=#hl-36-17>17</a>
</span><span class=lnt id=hl-36-18><a class=lnlinks href=#hl-36-18>18</a>
</span><span class=lnt id=hl-36-19><a class=lnlinks href=#hl-36-19>19</a>
</span><span class=lnt id=hl-36-20><a class=lnlinks href=#hl-36-20>20</a>
</span><span class=lnt id=hl-36-21><a class=lnlinks href=#hl-36-21>21</a>
</span><span class=lnt id=hl-36-22><a class=lnlinks href=#hl-36-22>22</a>
</span><span class=lnt id=hl-36-23><a class=lnlinks href=#hl-36-23>23</a>
</span><span class=lnt id=hl-36-24><a class=lnlinks href=#hl-36-24>24</a>
</span><span class=lnt id=hl-36-25><a class=lnlinks href=#hl-36-25>25</a>
</span><span class=lnt id=hl-36-26><a class=lnlinks href=#hl-36-26>26</a>
</span><span class=lnt id=hl-36-27><a class=lnlinks href=#hl-36-27>27</a>
</span><span class=lnt id=hl-36-28><a class=lnlinks href=#hl-36-28>28</a>
</span><span class=lnt id=hl-36-29><a class=lnlinks href=#hl-36-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>다운로드 속도 변화:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>초기 (Slow Start):
</span></span><span class=line><span class=cl>┌─────────────────┐
</span></span><span class=line><span class=cl>│ 시간(초) │ cwnd    │ 속도(Mbps)  │
</span></span><span class=line><span class=cl>│   0-0.1  │  10 MSS │    1.2           │
</span></span><span class=line><span class=cl>│  0.1-0.2 │  20 MSS │    2.4          │
</span></span><span class=line><span class=cl>│  0.2-0.3 │  40 MSS │    4.8          │
</span></span><span class=line><span class=cl>│  0.3-0.5 │  80 MSS │    9.6          │
</span></span><span class=line><span class=cl>└─────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>혼잡 회피 (Congestion Avoidance):
</span></span><span class=line><span class=cl>┌────────────────┐
</span></span><span class=line><span class=cl>│   0.5-1  │ 160 MSS │   19.2     │
</span></span><span class=line><span class=cl>│    1-2   │ 240 MSS │   28.8      │
</span></span><span class=line><span class=cl>│    2-3   │ 320 MSS │   38.4      │
</span></span><span class=line><span class=cl>│    ...   │   ...   │    ...                   │
</span></span><span class=line><span class=cl>│   10-11  │ 800 MSS │   96.0    │
</span></span><span class=line><span class=cl>└────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>손실 발생 (시간 11초):
</span></span><span class=line><span class=cl>┌────────────────┐
</span></span><span class=line><span class=cl>│    11    │ 800 MSS │   96.0       │
</span></span><span class=line><span class=cl>│  11.001  │ 400 MSS │   48.0 ↓  │
</span></span><span class=line><span class=cl>│  11.1-12 │ 450 MSS │   54.0 ↑  │
</span></span><span class=line><span class=cl>│  12-13   │ 500 MSS │   60.0 ↑   │
</span></span><span class=line><span class=cl>└────────────────┘
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>→ 톱니 모양 속도 변화 (Sawtooth Pattern)
</span></span></code></pre></td></tr></table></div></div><h4 id=mtu-와-mss-의-실전-영향>MTU 와 MSS 의 실전 영향<a hidden class=anchor aria-hidden=true href=#mtu-와-mss-의-실전-영향>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1> 1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2> 2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3> 3</a>
</span><span class=lnt id=hl-37-4><a class=lnlinks href=#hl-37-4> 4</a>
</span><span class=lnt id=hl-37-5><a class=lnlinks href=#hl-37-5> 5</a>
</span><span class=lnt id=hl-37-6><a class=lnlinks href=#hl-37-6> 6</a>
</span><span class=lnt id=hl-37-7><a class=lnlinks href=#hl-37-7> 7</a>
</span><span class=lnt id=hl-37-8><a class=lnlinks href=#hl-37-8> 8</a>
</span><span class=lnt id=hl-37-9><a class=lnlinks href=#hl-37-9> 9</a>
</span><span class=lnt id=hl-37-10><a class=lnlinks href=#hl-37-10>10</a>
</span><span class=lnt id=hl-37-11><a class=lnlinks href=#hl-37-11>11</a>
</span><span class=lnt id=hl-37-12><a class=lnlinks href=#hl-37-12>12</a>
</span><span class=lnt id=hl-37-13><a class=lnlinks href=#hl-37-13>13</a>
</span><span class=lnt id=hl-37-14><a class=lnlinks href=#hl-37-14>14</a>
</span><span class=lnt id=hl-37-15><a class=lnlinks href=#hl-37-15>15</a>
</span><span class=lnt id=hl-37-16><a class=lnlinks href=#hl-37-16>16</a>
</span><span class=lnt id=hl-37-17><a class=lnlinks href=#hl-37-17>17</a>
</span><span class=lnt id=hl-37-18><a class=lnlinks href=#hl-37-18>18</a>
</span><span class=lnt id=hl-37-19><a class=lnlinks href=#hl-37-19>19</a>
</span><span class=lnt id=hl-37-20><a class=lnlinks href=#hl-37-20>20</a>
</span><span class=lnt id=hl-37-21><a class=lnlinks href=#hl-37-21>21</a>
</span><span class=lnt id=hl-37-22><a class=lnlinks href=#hl-37-22>22</a>
</span><span class=lnt id=hl-37-23><a class=lnlinks href=#hl-37-23>23</a>
</span><span class=lnt id=hl-37-24><a class=lnlinks href=#hl-37-24>24</a>
</span><span class=lnt id=hl-37-25><a class=lnlinks href=#hl-37-25>25</a>
</span><span class=lnt id=hl-37-26><a class=lnlinks href=#hl-37-26>26</a>
</span><span class=lnt id=hl-37-27><a class=lnlinks href=#hl-37-27>27</a>
</span><span class=lnt id=hl-37-28><a class=lnlinks href=#hl-37-28>28</a>
</span><span class=lnt id=hl-37-29><a class=lnlinks href=#hl-37-29>29</a>
</span><span class=lnt id=hl-37-30><a class=lnlinks href=#hl-37-30>30</a>
</span><span class=lnt id=hl-37-31><a class=lnlinks href=#hl-37-31>31</a>
</span><span class=lnt id=hl-37-32><a class=lnlinks href=#hl-37-32>32</a>
</span><span class=lnt id=hl-37-33><a class=lnlinks href=#hl-37-33>33</a>
</span><span class=lnt id=hl-37-34><a class=lnlinks href=#hl-37-34>34</a>
</span><span class=lnt id=hl-37-35><a class=lnlinks href=#hl-37-35>35</a>
</span><span class=lnt id=hl-37-36><a class=lnlinks href=#hl-37-36>36</a>
</span><span class=lnt id=hl-37-37><a class=lnlinks href=#hl-37-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시나리오 1: 표준 환경 (MTU 1500)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 1460 B
</span></span><span class=line><span class=cl>1 GB 파일: 732,064 세그먼트
</span></span><span class=line><span class=cl>평균 RTT: 50 ms
</span></span><span class=line><span class=cl>이론 처리량: 1460 × 8 / 0.05 = 233.6 Kbps (1개 세그먼트/RTT)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 처리량 (윈도우 크기 고려):
</span></span><span class=line><span class=cl>윈도우: 64 KB = 44 세그먼트
</span></span><span class=line><span class=cl>처리량: 44 × 1460 × 8 / 0.05 = 10.3 Mbps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Large Window (256 KB):
</span></span><span class=line><span class=cl>처리량: 176 × 1460 × 8 / 0.05 = 41.2 Mbps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오 2: VPN 환경 (MTU 1400)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 1360 B (40 B 감소)
</span></span><span class=line><span class=cl>1 GB 파일: 786,432 세그먼트 (7.4% 증가)
</span></span><span class=line><span class=cl>오버헤드: 40 B × 786,432 = 30.1 MB (3% 증가)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 영향:
</span></span><span class=line><span class=cl>• 세그먼트 수 증가 → ACK 수 증가
</span></span><span class=line><span class=cl>• CPU 부담 증가 (패킷 처리)
</span></span><span class=line><span class=cl>• 혼잡 제어 영향 (더 많은 패킷 손실 기회)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오 3: 점보 프레임 (MTU 9000)
</span></span><span class=line><span class=cl>─────────────────────────────────
</span></span><span class=line><span class=cl>MSS: 8960 B (6.1배 증가)
</span></span><span class=line><span class=cl>1 GB 파일: 119,210 세그먼트 (6.1배 감소)
</span></span><span class=line><span class=cl>오버헤드: 40 B × 119,210 = 4.6 MB (0.4%)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>실제 영향:
</span></span><span class=line><span class=cl>• 세그먼트 수 감소 → ACK 감소
</span></span><span class=line><span class=cl>• CPU 효율 향상
</span></span><span class=line><span class=cl>• 단편화 위험 (경로 MTU 불일치 시 치명적)
</span></span></code></pre></td></tr></table></div></div><h4 id=실전-시나리오>실전 시나리오<a hidden class=anchor aria-hidden=true href=#실전-시나리오>#</a></h4><h5 id=정상-다운로드>정상 다운로드<a hidden class=anchor aria-hidden=true href=#정상-다운로드>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1> 1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2> 2</a>
</span><span class=lnt id=hl-38-3><a class=lnlinks href=#hl-38-3> 3</a>
</span><span class=lnt id=hl-38-4><a class=lnlinks href=#hl-38-4> 4</a>
</span><span class=lnt id=hl-38-5><a class=lnlinks href=#hl-38-5> 5</a>
</span><span class=lnt id=hl-38-6><a class=lnlinks href=#hl-38-6> 6</a>
</span><span class=lnt id=hl-38-7><a class=lnlinks href=#hl-38-7> 7</a>
</span><span class=lnt id=hl-38-8><a class=lnlinks href=#hl-38-8> 8</a>
</span><span class=lnt id=hl-38-9><a class=lnlinks href=#hl-38-9> 9</a>
</span><span class=lnt id=hl-38-10><a class=lnlinks href=#hl-38-10>10</a>
</span><span class=lnt id=hl-38-11><a class=lnlinks href=#hl-38-11>11</a>
</span><span class=lnt id=hl-38-12><a class=lnlinks href=#hl-38-12>12</a>
</span><span class=lnt id=hl-38-13><a class=lnlinks href=#hl-38-13>13</a>
</span><span class=lnt id=hl-38-14><a class=lnlinks href=#hl-38-14>14</a>
</span><span class=lnt id=hl-38-15><a class=lnlinks href=#hl-38-15>15</a>
</span><span class=lnt id=hl-38-16><a class=lnlinks href=#hl-38-16>16</a>
</span><span class=lnt id=hl-38-17><a class=lnlinks href=#hl-38-17>17</a>
</span><span class=lnt id=hl-38-18><a class=lnlinks href=#hl-38-18>18</a>
</span><span class=lnt id=hl-38-19><a class=lnlinks href=#hl-38-19>19</a>
</span><span class=lnt id=hl-38-20><a class=lnlinks href=#hl-38-20>20</a>
</span><span class=lnt id=hl-38-21><a class=lnlinks href=#hl-38-21>21</a>
</span><span class=lnt id=hl-38-22><a class=lnlinks href=#hl-38-22>22</a>
</span><span class=lnt id=hl-38-23><a class=lnlinks href=#hl-38-23>23</a>
</span><span class=lnt id=hl-38-24><a class=lnlinks href=#hl-38-24>24</a>
</span><span class=lnt id=hl-38-25><a class=lnlinks href=#hl-38-25>25</a>
</span><span class=lnt id=hl-38-26><a class=lnlinks href=#hl-38-26>26</a>
</span><span class=lnt id=hl-38-27><a class=lnlinks href=#hl-38-27>27</a>
</span><span class=lnt id=hl-38-28><a class=lnlinks href=#hl-38-28>28</a>
</span><span class=lnt id=hl-38-29><a class=lnlinks href=#hl-38-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>타임라인 (1 GB 파일, 100 Mbps 회선):
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=0ms: TCP 연결 설정 (3-Way Handshake)
</span></span><span class=line><span class=cl>├─ SYN → (RTT/2)
</span></span><span class=line><span class=cl>├─ SYN-ACK ← (RTT/2)
</span></span><span class=line><span class=cl>└─ ACK → (RTT/2)
</span></span><span class=line><span class=cl>총 소요: 1.5 RTT (예: 75 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=75ms: TLS 핸드셰이크 (HTTPS)
</span></span><span class=line><span class=cl>├─ ClientHello →
</span></span><span class=line><span class=cl>├─ ServerHello, Certificate ←
</span></span><span class=line><span class=cl>├─ ClientKeyExchange, Finished →
</span></span><span class=line><span class=cl>└─ Finished ←
</span></span><span class=line><span class=cl>총 소요: 2 RTT (예: 100 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=175ms: HTTP 요청 전송
</span></span><span class=line><span class=cl>└─ GET /video.mp4 HTTP/1.1 →
</span></span><span class=line><span class=cl>소요: 0.5 RTT (예: 25 ms)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=200ms: 데이터 전송 시작
</span></span><span class=line><span class=cl>├─ Slow Start: 0.5초 (10 MSS → 800 MSS)
</span></span><span class=line><span class=cl>├─ 안정 상태: 10초 (100 Mbps 지속)
</span></span><span class=line><span class=cl>└─ 완료: 총 10.7초
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=10.9초: 다운로드 완료
</span></span><span class=line><span class=cl>└─ 파일 검증 (MD5): 0.3초
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>총 소요 시간: 약 11.2초
</span></span><span class=line><span class=cl>실효 처리량: 1 GB / 11.2s = 89.3 MB/s = 714 Mbps
</span></span></code></pre></td></tr></table></div></div><h5 id=패킷-손실-복구>패킷 손실 복구<a hidden class=anchor aria-hidden=true href=#패킷-손실-복구>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1> 1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2> 2</a>
</span><span class=lnt id=hl-39-3><a class=lnlinks href=#hl-39-3> 3</a>
</span><span class=lnt id=hl-39-4><a class=lnlinks href=#hl-39-4> 4</a>
</span><span class=lnt id=hl-39-5><a class=lnlinks href=#hl-39-5> 5</a>
</span><span class=lnt id=hl-39-6><a class=lnlinks href=#hl-39-6> 6</a>
</span><span class=lnt id=hl-39-7><a class=lnlinks href=#hl-39-7> 7</a>
</span><span class=lnt id=hl-39-8><a class=lnlinks href=#hl-39-8> 8</a>
</span><span class=lnt id=hl-39-9><a class=lnlinks href=#hl-39-9> 9</a>
</span><span class=lnt id=hl-39-10><a class=lnlinks href=#hl-39-10>10</a>
</span><span class=lnt id=hl-39-11><a class=lnlinks href=#hl-39-11>11</a>
</span><span class=lnt id=hl-39-12><a class=lnlinks href=#hl-39-12>12</a>
</span><span class=lnt id=hl-39-13><a class=lnlinks href=#hl-39-13>13</a>
</span><span class=lnt id=hl-39-14><a class=lnlinks href=#hl-39-14>14</a>
</span><span class=lnt id=hl-39-15><a class=lnlinks href=#hl-39-15>15</a>
</span><span class=lnt id=hl-39-16><a class=lnlinks href=#hl-39-16>16</a>
</span><span class=lnt id=hl-39-17><a class=lnlinks href=#hl-39-17>17</a>
</span><span class=lnt id=hl-39-18><a class=lnlinks href=#hl-39-18>18</a>
</span><span class=lnt id=hl-39-19><a class=lnlinks href=#hl-39-19>19</a>
</span><span class=lnt id=hl-39-20><a class=lnlinks href=#hl-39-20>20</a>
</span><span class=lnt id=hl-39-21><a class=lnlinks href=#hl-39-21>21</a>
</span><span class=lnt id=hl-39-22><a class=lnlinks href=#hl-39-22>22</a>
</span><span class=lnt id=hl-39-23><a class=lnlinks href=#hl-39-23>23</a>
</span><span class=lnt id=hl-39-24><a class=lnlinks href=#hl-39-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시나리오: 1% 패킷 손실률
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=5초: 정상 전송 중 (500 MB 다운로드)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>패킷 손실 발생 (SEQ=367,000,000)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.003초: 3 중복 ACK 수신
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>Fast Retransmit: SEQ=367,000,000 재전송
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.053초: 재전송 완료 (RTT 50 ms)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>혼잡 윈도우 감소: 800 MSS → 400 MSS
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>속도 일시 감소: 100 Mbps → 50 Mbps
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.1초: 회복 시작 (선형 증가)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=5.5초: 정상 속도 복구 (100 Mbps)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>손실 영향:
</span></span><span class=line><span class=cl>• 지연: 0.5초 추가
</span></span><span class=line><span class=cl>• 속도 저하: 0.4초 동안 50% 감소
</span></span><span class=line><span class=cl>• 총 영향: 약 0.2초 추가 소요
</span></span></code></pre></td></tr></table></div></div><h5 id=mtu-불일치-문제>MTU 불일치 문제<a hidden class=anchor aria-hidden=true href=#mtu-불일치-문제>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1> 1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2> 2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3> 3</a>
</span><span class=lnt id=hl-40-4><a class=lnlinks href=#hl-40-4> 4</a>
</span><span class=lnt id=hl-40-5><a class=lnlinks href=#hl-40-5> 5</a>
</span><span class=lnt id=hl-40-6><a class=lnlinks href=#hl-40-6> 6</a>
</span><span class=lnt id=hl-40-7><a class=lnlinks href=#hl-40-7> 7</a>
</span><span class=lnt id=hl-40-8><a class=lnlinks href=#hl-40-8> 8</a>
</span><span class=lnt id=hl-40-9><a class=lnlinks href=#hl-40-9> 9</a>
</span><span class=lnt id=hl-40-10><a class=lnlinks href=#hl-40-10>10</a>
</span><span class=lnt id=hl-40-11><a class=lnlinks href=#hl-40-11>11</a>
</span><span class=lnt id=hl-40-12><a class=lnlinks href=#hl-40-12>12</a>
</span><span class=lnt id=hl-40-13><a class=lnlinks href=#hl-40-13>13</a>
</span><span class=lnt id=hl-40-14><a class=lnlinks href=#hl-40-14>14</a>
</span><span class=lnt id=hl-40-15><a class=lnlinks href=#hl-40-15>15</a>
</span><span class=lnt id=hl-40-16><a class=lnlinks href=#hl-40-16>16</a>
</span><span class=lnt id=hl-40-17><a class=lnlinks href=#hl-40-17>17</a>
</span><span class=lnt id=hl-40-18><a class=lnlinks href=#hl-40-18>18</a>
</span><span class=lnt id=hl-40-19><a class=lnlinks href=#hl-40-19>19</a>
</span><span class=lnt id=hl-40-20><a class=lnlinks href=#hl-40-20>20</a>
</span><span class=lnt id=hl-40-21><a class=lnlinks href=#hl-40-21>21</a>
</span><span class=lnt id=hl-40-22><a class=lnlinks href=#hl-40-22>22</a>
</span><span class=lnt id=hl-40-23><a class=lnlinks href=#hl-40-23>23</a>
</span><span class=lnt id=hl-40-24><a class=lnlinks href=#hl-40-24>24</a>
</span><span class=lnt id=hl-40-25><a class=lnlinks href=#hl-40-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상황: 클라이언트 MTU 1500, 중간 경로 MTU 1400
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>T=0: 연결 설정, MSS=1460 협상
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.2초: 데이터 전송 시작
</span></span><span class=line><span class=cl>├─ IP 패킷 (1500 B) 전송
</span></span><span class=line><span class=cl>└─ 중간 라우터 MTU 1400 초과
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>라우터: ICMP &#34;Fragmentation Needed, MTU=1400&#34;
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.25초: 클라이언트 ICMP 수신
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>[PMTUD 조정]
</span></span><span class=line><span class=cl>Path MTU: 1400
</span></span><span class=line><span class=cl>MSS: 1400 - 20(IP) - 20(TCP) = 1360
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>T=0.26초: 재전송 (작은 세그먼트)
</span></span><span class=line><span class=cl>   ↓
</span></span><span class=line><span class=cl>이후 정상 전송 (MSS=1360)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>영향 분석:
</span></span><span class=line><span class=cl>• 초기 지연: 0.06초
</span></span><span class=line><span class=cl>• 세그먼트 수 증가: 7.4%
</span></span><span class=line><span class=cl>• 오버헤드 증가: 3%
</span></span><span class=line><span class=cl>• 실효 처리량 감소: 약 5%
</span></span></code></pre></td></tr></table></div></div><h3 id=스트리밍-vs-파일-다운로드-비교>스트리밍 vs. 파일 다운로드 비교<a hidden class=anchor aria-hidden=true href=#스트리밍-vs-파일-다운로드-비교>#</a></h3><p><strong>대용량 파일 다운로드는 TCP 의 신뢰성 메커니즘 (재전송, 순서 보장, 흐름/혼잡 제어) 을 통해 100% 완전성을 보장하며</strong>, MTU/MSS 최적화와 병렬 연결로 처리량을 극대화하되, <strong>실시간 스트리밍과 달리 지연보다 완전성을 우선</strong>하는 트레이드오프를 선택한다.</p><h4 id=핵심-차이점-요약>핵심 차이점 요약<a hidden class=anchor aria-hidden=true href=#핵심-차이점-요약>#</a></h4><table><thead><tr><th>특성</th><th>파일 다운로드 (TCP)</th><th>실시간 스트리밍 (UDP)</th></tr></thead><tbody><tr><td><strong>신뢰성</strong></td><td>100% 보장 (재전송)</td><td>손실 허용 (재전송 없음)</td></tr><tr><td><strong>순서</strong></td><td>엄격 보장</td><td>무시 가능</td></tr><tr><td><strong>지연</strong></td><td>높음 (수백 ms)</td><td>낮음 (&lt; 100 ms)</td></tr><tr><td><strong>버퍼링</strong></td><td>큰 버퍼 (64 KB~)</td><td>작은 지터 버퍼 (50 ms)</td></tr><tr><td><strong>패킷 크기</strong></td><td>MSS 최대 활용 (1460 B)</td><td>작게 유지 (1200 B)</td></tr><tr><td><strong>재전송</strong></td><td>자동 (TCP)</td><td>선택적 (NACK)</td></tr><tr><td><strong>흐름 제어</strong></td><td>윈도우 기반</td><td>없음 (앱 레벨)</td></tr><tr><td><strong>혼잡 제어</strong></td><td>필수 (Cubic 등)</td><td>선택적 (GCC)</td></tr><tr><td><strong>완전성</strong></td><td>100% (체크섬)</td><td>부분 허용 (FEC)</td></tr></tbody></table><h4 id=pdu-구조-비교>PDU 구조 비교<a hidden class=anchor aria-hidden=true href=#pdu-구조-비교>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1> 1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2> 2</a>
</span><span class=lnt id=hl-41-3><a class=lnlinks href=#hl-41-3> 3</a>
</span><span class=lnt id=hl-41-4><a class=lnlinks href=#hl-41-4> 4</a>
</span><span class=lnt id=hl-41-5><a class=lnlinks href=#hl-41-5> 5</a>
</span><span class=lnt id=hl-41-6><a class=lnlinks href=#hl-41-6> 6</a>
</span><span class=lnt id=hl-41-7><a class=lnlinks href=#hl-41-7> 7</a>
</span><span class=lnt id=hl-41-8><a class=lnlinks href=#hl-41-8> 8</a>
</span><span class=lnt id=hl-41-9><a class=lnlinks href=#hl-41-9> 9</a>
</span><span class=lnt id=hl-41-10><a class=lnlinks href=#hl-41-10>10</a>
</span><span class=lnt id=hl-41-11><a class=lnlinks href=#hl-41-11>11</a>
</span><span class=lnt id=hl-41-12><a class=lnlinks href=#hl-41-12>12</a>
</span><span class=lnt id=hl-41-13><a class=lnlinks href=#hl-41-13>13</a>
</span><span class=lnt id=hl-41-14><a class=lnlinks href=#hl-41-14>14</a>
</span><span class=lnt id=hl-41-15><a class=lnlinks href=#hl-41-15>15</a>
</span><span class=lnt id=hl-41-16><a class=lnlinks href=#hl-41-16>16</a>
</span><span class=lnt id=hl-41-17><a class=lnlinks href=#hl-41-17>17</a>
</span><span class=lnt id=hl-41-18><a class=lnlinks href=#hl-41-18>18</a>
</span><span class=lnt id=hl-41-19><a class=lnlinks href=#hl-41-19>19</a>
</span><span class=lnt id=hl-41-20><a class=lnlinks href=#hl-41-20>20</a>
</span><span class=lnt id=hl-41-21><a class=lnlinks href=#hl-41-21>21</a>
</span><span class=lnt id=hl-41-22><a class=lnlinks href=#hl-41-22>22</a>
</span><span class=lnt id=hl-41-23><a class=lnlinks href=#hl-41-23>23</a>
</span><span class=lnt id=hl-41-24><a class=lnlinks href=#hl-41-24>24</a>
</span><span class=lnt id=hl-41-25><a class=lnlinks href=#hl-41-25>25</a>
</span><span class=lnt id=hl-41-26><a class=lnlinks href=#hl-41-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>파일 다운로드 (TCP):
</span></span><span class=line><span class=cl>┌──────────────────┐
</span></span><span class=line><span class=cl>│ L7: HTTP(200B) + TLS(21B)              │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L4: TCP(20-60B) [순서, ACK, 흐름]    │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L3: IP(20-40B) [DF=1]                       │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L2: Ethernet(18B)                              │
</span></span><span class=line><span class=cl>└──────────────────┘
</span></span><span class=line><span class=cl>총 오버헤드: 259-339 B
</span></span><span class=line><span class=cl>특징: 신뢰성 우선, 오버헤드 높음
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>스트리밍 (UDP/RTP):
</span></span><span class=line><span class=cl>┌──────────────────┐
</span></span><span class=line><span class=cl>│ L7: RTP(12B) [시퀀스, 타임스탬프]     │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L4: UDP(8B) [포트만]                         │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L3: IP(20-40B)                                   │
</span></span><span class=line><span class=cl>├──────────────────┤
</span></span><span class=line><span class=cl>│ L2: Ethernet(18B)                              │
</span></span><span class=line><span class=cl>└──────────────────┘
</span></span><span class=line><span class=cl>총 오버헤드: 58-78 B
</span></span><span class=line><span class=cl>특징: 저지연 우선, 오버헤드 낮음
</span></span></code></pre></td></tr></table></div></div><h4 id=네트워크-동작-비교>네트워크 동작 비교<a hidden class=anchor aria-hidden=true href=#네트워크-동작-비교>#</a></h4><pre class=mermaid>graph TD
    subgraph TCP[&#34;TCP (파일 다운로드)&#34;]
        T1[3-Way Handshake]
        T2[데이터 전송]
        T3[ACK 대기]
        T4[재전송]
        T5[흐름 제어]
        
        T1 --&gt; T2
        T2 --&gt; T3
        T3 --&gt;|손실| T4
        T4 --&gt; T2
        T3 --&gt;|성공| T5
        T5 --&gt; T2
    end
    
    subgraph UDP[&#34;UDP (스트리밍)&#34;]
        U1[즉시 전송]
        U2[순서 무시]
        U3[손실 무시]
        U4[지터 버퍼]
        
        U1 --&gt; U2
        U2 --&gt; U3
        U3 --&gt; U4
        U4 --&gt; U1
    end
    
    style TCP fill:#e3f2fd,stroke:#1976d2
    style UDP fill:#e8f5e9,stroke:#388e3c
</pre><h2 id=성능신뢰보안-트레이드오프와-튜닝-포인트>성능·신뢰·보안 트레이드오프와 튜닝 포인트<a hidden class=anchor aria-hidden=true href=#성능신뢰보안-트레이드오프와-튜닝-포인트>#</a></h2><p><strong>표 5-1. 설계/운영 트레이드오프</strong></p><table><thead><tr><th>축</th><th>선택</th><th>장점</th><th>단점</th><th>비고</th></tr></thead><tbody><tr><td>MTU</td><td>1500 vs Jumbo(9001)</td><td>헤더비율 ↓, PPS ↓</td><td>블랙홀 위험↑, 호환성 이슈</td><td>클라우드·DC 한정 권장</td></tr><tr><td>전송</td><td>TCP vs UDP vs QUIC</td><td>신뢰/혼잡 vs 저지연 vs 빠른수립/이동성</td><td>오버헤드/지연/복잡성 각기</td><td>워크로드 따라 선택</td></tr><tr><td>혼잡</td><td>ECN 사용</td><td>패킷드롭↓, RTT 안정</td><td>장비/경로 지원 필요</td><td>ECN++ 동향</td></tr><tr><td>오프로딩</td><td>TSO/GSO/GRO</td><td>CPU↓, PPS↑</td><td>가시성↓, NIC 의존</td><td>캡처 시 주의</td></tr><tr><td>보안</td><td>TLS/QUIC</td><td>기밀·무결성</td><td>중간 가시성 저하</td><td>E2E 원칙 강화</td></tr></tbody></table><p>해설: MTU 상향은 이득이 크지만 경로 호환성·PMTUD 가 관건이다. ECN 은 드롭 없는 혼잡신호로서 점진 확산 중이며, NIC 오프로딩은 성능 향상과 가시성 저하 (패킷 캡처 왜곡) 의 딜레마를 낳는다.</p><p><strong>MTU→MSS 계산 & 경계 체크 (교육용)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-43-1><a class=lnlinks href=#hl-43-1> 1</a>
</span><span class=lnt id=hl-43-2><a class=lnlinks href=#hl-43-2> 2</a>
</span><span class=lnt id=hl-43-3><a class=lnlinks href=#hl-43-3> 3</a>
</span><span class=lnt id=hl-43-4><a class=lnlinks href=#hl-43-4> 4</a>
</span><span class=lnt id=hl-43-5><a class=lnlinks href=#hl-43-5> 5</a>
</span><span class=lnt id=hl-43-6><a class=lnlinks href=#hl-43-6> 6</a>
</span><span class=lnt id=hl-43-7><a class=lnlinks href=#hl-43-7> 7</a>
</span><span class=lnt id=hl-43-8><a class=lnlinks href=#hl-43-8> 8</a>
</span><span class=lnt id=hl-43-9><a class=lnlinks href=#hl-43-9> 9</a>
</span><span class=lnt id=hl-43-10><a class=lnlinks href=#hl-43-10>10</a>
</span><span class=lnt id=hl-43-11><a class=lnlinks href=#hl-43-11>11</a>
</span><span class=lnt id=hl-43-12><a class=lnlinks href=#hl-43-12>12</a>
</span><span class=lnt id=hl-43-13><a class=lnlinks href=#hl-43-13>13</a>
</span><span class=lnt id=hl-43-14><a class=lnlinks href=#hl-43-14>14</a>
</span><span class=lnt id=hl-43-15><a class=lnlinks href=#hl-43-15>15</a>
</span><span class=lnt id=hl-43-16><a class=lnlinks href=#hl-43-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 목적: MTU와 IPv4/IPv6 여부로 MSS를 산출하고, 페이로드 초과 여부를 검사
</span></span></span><span class=line><span class=cl><span class=c1>// 입력: mtu(number), ipver(4|6), l4(&#39;tcp&#39;|&#39;udp&#39;), extraOverhead(number=0)
</span></span></span><span class=line><span class=cl><span class=c1>// 출력: {mss, maxPayload}
</span></span></span><span class=line><span class=cl><span class=c1>// 예외: 잘못된 입력 시 throw
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>mtuToMss</span><span class=p>(</span><span class=nx>mtu</span><span class=p>,</span> <span class=nx>ipver</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=nx>l4</span><span class=o>=</span><span class=s1>&#39;tcp&#39;</span><span class=p>,</span> <span class=nx>extraOverhead</span><span class=o>=</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=mi>6</span><span class=p>].</span><span class=nx>includes</span><span class=p>(</span><span class=nx>ipver</span><span class=p>))</span> <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;ipver must be 4 or 6&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>ip</span> <span class=o>=</span> <span class=nx>ipver</span> <span class=o>===</span> <span class=mi>4</span> <span class=o>?</span> <span class=mi>20</span> <span class=o>:</span> <span class=mi>40</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>l4h</span> <span class=o>=</span> <span class=nx>l4</span> <span class=o>===</span> <span class=s1>&#39;tcp&#39;</span> <span class=o>?</span> <span class=mi>20</span> <span class=o>:</span> <span class=p>(</span><span class=nx>l4</span> <span class=o>===</span> <span class=s1>&#39;udp&#39;</span> <span class=o>?</span> <span class=mi>8</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>base</span> <span class=o>=</span> <span class=nx>mtu</span> <span class=o>-</span> <span class=nx>ip</span> <span class=o>-</span> <span class=nx>l4h</span> <span class=o>-</span> <span class=nx>extraOverhead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>base</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=p>{</span> <span class=nx>mss</span><span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>maxPayload</span><span class=o>:</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span> <span class=nx>mss</span><span class=o>:</span> <span class=nx>base</span><span class=p>,</span> <span class=nx>maxPayload</span><span class=o>:</span> <span class=nx>base</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 예: IPv6/TCP + TLS(태그 16B + 레코드헤더 5B)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>r</span> <span class=o>=</span> <span class=nx>mtuToMss</span><span class=p>(</span><span class=mi>1500</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=s1>&#39;tcp&#39;</span><span class=p>,</span> <span class=mi>21</span><span class=p>);</span> <span class=c1>// ≈142,2B 유효 페이로드
</span></span></span></code></pre></td></tr></table></div></div><p>실제 네트워크에서는 VLAN, 터널, 옵션, 보안태그를 <code>extraOverhead</code> 에 반영해 안전한 MSS 를 산출한다. 경계 장비의 MSS 클램핑/PMTUD 동작과 함께 검증해야 한다.</p><h2 id=pdu-기반-네트워크-문제-진단-및-최적화>PDU 기반 네트워크 문제 진단 및 최적화<a hidden class=anchor aria-hidden=true href=#pdu-기반-네트워크-문제-진단-및-최적화>#</a></h2><p>PDU 구조 이해를 활용한 실무 네트워크 트러블슈팅, 성능 최적화, 보안 정책 수립 사례를 다룬다. Wireshark, tcpdump 등 패킷 분석 도구 활용법을 포함한다.</p><h3 id=패킷-분석-도구-활용>패킷 분석 도구 활용<a hidden class=anchor aria-hidden=true href=#패킷-분석-도구-활용>#</a></h3><p><strong>Wireshark</strong>: GUI 기반 패킷 캡처·분석 도구. 계층별 PDU 헤더를 시각적으로 표시하고, 필터링·통계·플로우 추적 기능을 제공한다.<br><strong>tcpdump</strong>: CLI 기반 패킷 캡처 도구. 스크립트·자동화에 적합하며, 원격 서버에서 실시간 캡처·분석이 가능하다.</p><p><strong>표: 주요 패킷 분석 도구 비교</strong></p><table><thead><tr><th>도구</th><th style=text-align:center>인터페이스</th><th>주요 기능</th><th>용도</th><th style=text-align:center>라이선스</th></tr></thead><tbody><tr><td>Wireshark</td><td style=text-align:center>GUI</td><td>계층별 헤더 디코딩, 통계, 플로우 그래프</td><td>심층 분석, 교육</td><td style=text-align:center>GPL</td></tr><tr><td>tcpdump</td><td style=text-align:center>CLI</td><td>패킷 캡처·필터링, pcap 파일 생성</td><td>원격 트러블슈팅, 자동화</td><td style=text-align:center>BSD</td></tr><tr><td>tshark</td><td style=text-align:center>CLI</td><td>Wireshark 엔진 CLI 버전</td><td>스크립트·파이프라인</td><td style=text-align:center>GPL</td></tr><tr><td>Scapy</td><td style=text-align:center>Python</td><td>패킷 생성·조작·송수신</td><td>테스트, 보안 연구</td><td style=text-align:center>GPL</td></tr></tbody></table><p><strong>Wireshark 필터 예시</strong>:</p><ul><li><code>tcp.port == 80</code>: HTTP 트래픽만 표시</li><li><code>ip.addr == 192.168.1.1</code>: 특정 IP 주소 관련 패킷</li><li><code>tcp.flags.syn == 1 && tcp.flags.ack == 0</code>: SYN 패킷만 (3-way handshake 시작)</li><li><code>frame.len > 1514</code>: Jumbo Frame 탐지</li></ul><p><strong>tcpdump 필터 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-44-1><a class=lnlinks href=#hl-44-1> 1</a>
</span><span class=lnt id=hl-44-2><a class=lnlinks href=#hl-44-2> 2</a>
</span><span class=lnt id=hl-44-3><a class=lnlinks href=#hl-44-3> 3</a>
</span><span class=lnt id=hl-44-4><a class=lnlinks href=#hl-44-4> 4</a>
</span><span class=lnt id=hl-44-5><a class=lnlinks href=#hl-44-5> 5</a>
</span><span class=lnt id=hl-44-6><a class=lnlinks href=#hl-44-6> 6</a>
</span><span class=lnt id=hl-44-7><a class=lnlinks href=#hl-44-7> 7</a>
</span><span class=lnt id=hl-44-8><a class=lnlinks href=#hl-44-8> 8</a>
</span><span class=lnt id=hl-44-9><a class=lnlinks href=#hl-44-9> 9</a>
</span><span class=lnt id=hl-44-10><a class=lnlinks href=#hl-44-10>10</a>
</span><span class=lnt id=hl-44-11><a class=lnlinks href=#hl-44-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># HTTP 트래픽 캡처</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;tcp port 80&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 특정 IP로/부터 패킷 캡처</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;host 192.168.1.1&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># SYN 패킷만 캡처 (TCP 플래그 비트마스크)</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># MTU 초과 패킷 탐지 (프레임 길이 &gt; 1514)</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 <span class=s1>&#39;greater 1514&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Scapy 로 최소 패킷 생성·송신 (오프라인 실습용 예시)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-45-1><a class=lnlinks href=#hl-45-1>1</a>
</span><span class=lnt id=hl-45-2><a class=lnlinks href=#hl-45-2>2</a>
</span><span class=lnt id=hl-45-3><a class=lnlinks href=#hl-45-3>3</a>
</span><span class=lnt id=hl-45-4><a class=lnlinks href=#hl-45-4>4</a>
</span><span class=lnt id=hl-45-5><a class=lnlinks href=#hl-45-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 목적: 로컬 환경에서 학습용으로 ICMP 에코 패킷을 구성</span>
</span></span><span class=line><span class=cl><span class=c1># 주의: 권한/환경에 따라 송신 금지. pcap 파일로만 저장하는 오프라인 흐름 예시</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=n>Ether</span><span class=p>,</span> <span class=n>IP</span><span class=p>,</span> <span class=n>ICMP</span><span class=p>,</span> <span class=n>wrpcap</span>
</span></span><span class=line><span class=cl><span class=n>pkt</span> <span class=o>=</span> <span class=n>Ether</span><span class=p>()</span><span class=o>/</span><span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=s2>&#34;198.51.100.1&#34;</span><span class=p>)</span><span class=o>/</span><span class=n>ICMP</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>wrpcap</span><span class=p>(</span><span class=s2>&#34;icmp_echo_min.pcap&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>pkt</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>해설: Scapy 는 계층을 &ldquo;/&rdquo; 로 쌓아 PDU 를 구성한다. 실제 송신·스캔은 법·정책·소유권을 준수해야 하며, 여기서는 파일로 저장해 오프라인 분석만 가정한다.</p><h3 id=일반적인-네트워크-문제와-pdu-진단>일반적인 네트워크 문제와 PDU 진단<a hidden class=anchor aria-hidden=true href=#일반적인-네트워크-문제와-pdu-진단>#</a></h3><h4 id=문제-1-패킷-손실-packet-loss>문제 1: 패킷 손실 (Packet Loss)<a hidden class=anchor aria-hidden=true href=#문제-1-패킷-손실-packet-loss>#</a></h4><p><strong>증상</strong>: 애플리케이션 지연, 재전송 증가, 연결 끊김<br><strong>PDU 진단 방법</strong>:</p><ul><li>Wireshark 에서 <code>tcp.analysis.retransmission</code> 필터로 재전송 패킷 확인</li><li><code>tcp.analysis.lost_segment</code> 필터로 누락된 세그먼트 탐지</li><li>TCP 순서 번호 (Sequence Number) 불연속성 확인<br><strong>원인 및 해결</strong>:</li><li><strong>네트워크 혼잡</strong>: QoS 정책 적용, 대역폭 증설</li><li><strong>FCS 오류</strong>: <code>ip.checksum_bad.expert</code> 필터로 체크섬 오류 확인 → 케이블·NIC 점검</li><li><strong>방화벽 정책</strong>: 특정 포트·프로토콜 차단 → ACL 검토</li></ul><h4 id=문제-2-높은-지연-high-latency>문제 2: 높은 지연 (High Latency)<a hidden class=anchor aria-hidden=true href=#문제-2-높은-지연-high-latency>#</a></h4><p><strong>증상</strong>: 응답 시간 증가, 실시간 서비스 (VoIP, 게임) 품질 저하<br><strong>PDU 진단 방법</strong>:</p><ul><li>Wireshark 의 &ldquo;Statistics > Flow Graph&rdquo; 로 RTT(Round-Trip Time) 측정</li><li><code>tcp.time_delta > 0.1</code> 필터로 100ms 이상 지연 패킷 찾기</li><li>ICMP Echo Request/Reply 의 타임스탬프 차이 확인<br><strong>원인 및 해결</strong>:</li><li><strong>라우팅 경로 비효율</strong>: <code>traceroute</code> 또는 <code>mtr</code> 로 경로 확인 → 라우팅 테이블 최적화</li><li><strong>대역폭 포화</strong>: <code>ip.len > 1400</code> 필터로 큰 패킷 탐지 → QoS·트래픽 셰이핑</li><li><strong>DNS 조회 지연</strong>: DNS 캐시 설정, 로컬 DNS 서버 사용</li></ul><h4 id=문제-3-mtu-불일치-black-hole>문제 3: MTU 불일치 (&ldquo;Black Hole&rdquo;)<a hidden class=anchor aria-hidden=true href=#문제-3-mtu-불일치-black-hole>#</a></h4><p><strong>증상</strong>: 작은 패킷은 전달되지만 큰 패킷 (예: 파일 전송) 은 실패<br><strong>PDU 진단 방법</strong>:</p><ul><li><code>ip.flags.df == 1 && icmp.type == 3 && icmp.code == 4</code> 필터로 &ldquo;Fragmentation Needed&rdquo; ICMP 메시지 확인</li><li>패킷 크기별 전송 성공률 비교 (<code>frame.len > 1400</code> vs <code>frame.len &lt; 1400</code>)<br><strong>원인 및 해결</strong>:</li><li><strong>PMTUD 차단</strong>: 방화벽이 ICMP Type 3 Code 4 를 차단 → ICMP 허용 규칙 추가</li><li><strong>VPN·PPPoE MTU</strong>: MTU 를 1400~1492 로 수동 설정 또는 MSS Clamping 적용</li><li><strong>Jumbo Frame 불일치</strong>: 경로 전체에서 Jumbo Frame 지원 확인 또는 MTU=1500 으로 통일</li></ul><h2 id=workshops>Workshops<a hidden class=anchor aria-hidden=true href=#workshops>#</a></h2><h3 id=osi-7-계층-캡슐화-실습>OSI 7 계층 캡슐화 실습<a hidden class=anchor aria-hidden=true href=#osi-7-계층-캡슐화-실습>#</a></h3><p><strong>시나리오</strong>: 실제 HTTP 메시지를 네트워크로 전송할 때, OSI 7 계층을 따라 SDU → PDU, 캡슐화/역캡슐화 과정과 PDU 명칭 변화, 헤더/페이로드 구조를 직접 분석한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th>단계</th><th>작업</th><th>담당</th><th>도구</th><th>소요 시간</th></tr></thead><tbody><tr><td>1</td><td>HTTP 메시지 송신</td><td>개발자</td><td>Python 코드</td><td>10 분</td></tr><tr><td>2</td><td>각 계층에서 PDU 구조 분석</td><td>개발자</td><td>Wireshark</td><td>20 분</td></tr><tr><td>3</td><td>캡슐화 단계별 헤더/데이터 검증</td><td>개발자</td><td>Notion/Excel</td><td>15 분</td></tr><tr><td>4</td><td>역캡슐화 결과 확인</td><td>개발자</td><td>Wireshark</td><td>15 분</td></tr><tr><td>5</td><td>용어 정리 보고서 작성</td><td>개발자</td><td>Notion</td><td>20 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>각 계층별 PDU 구조 해설 문서</li><li>Wireshark 캡처 파일</li><li>단계별 캡슐화/역캡슐화 서식 표</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> 각 계층의 PDU 명칭/구조 도출</li><li><input disabled type=checkbox> 캡슐화 흐름에 따른 헤더/페이로드 확인</li><li><input disabled type=checkbox> SDU→PDU 관계 해설 작성</li><li><input disabled type=checkbox> 용어/개념 혼동 없는 설명</li></ul><h3 id=tcpudp-프로토콜별-pdu-분석>TCP/UDP 프로토콜별 PDU 분석<a hidden class=anchor aria-hidden=true href=#tcpudp-프로토콜별-pdu-분석>#</a></h3><p><strong>시나리오</strong>: TCP 와 UDP 로 메시지를 각각 전송/수신할 때, 각 프로토콜별 PDU 구조 차이와 에러 검출 방식, 트러블슈팅 포인트를 코드로 실습한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th>단계</th><th>작업</th><th>담당</th><th>도구</th><th>소요 시간</th></tr></thead><tbody><tr><td>1</td><td>TCP/UDP 송수신 프로그램 구현</td><td>개발자</td><td>Python</td><td>20 분</td></tr><tr><td>2</td><td>각 PDU 필드 파싱/해석</td><td>개발자</td><td>Python, Wireshark</td><td>20 분</td></tr><tr><td>3</td><td>오류 검출/분석 케이스 작성</td><td>개발자</td><td>Wireshark</td><td>15 분</td></tr><tr><td>4</td><td>트러블슈팅 리포트 정리</td><td>개발자</td><td>Notion</td><td>15 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>TCP/UDP 송수신 예제 코드 (댓글 포함)</li><li>PDU 필드 비교 표</li><li>에러 검출/분석 사례 집합</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> TCP/UDP 별 PDU 명칭/구조 파악</li><li><input disabled type=checkbox> 오류 검출 기능 구현/설명</li><li><input disabled type=checkbox> 트러블슈팅 상황 정리/해설</li><li><input disabled type=checkbox> 코드 및 프로토콜 비교표 완성</li></ul><h3 id=wireshark-로-pdu-계층-읽기>Wireshark 로 PDU 계층 읽기<a hidden class=anchor aria-hidden=true href=#wireshark-로-pdu-계층-읽기>#</a></h3><p><strong>목표</strong>: L2→L7 캡슐화와 필드 관계를 눈으로 확인<br><strong>절차</strong>:</p><ol><li><code>tcpdump -s 0 -w trace.pcap</code> 로 캡처</li><li>Wireshark 로 열기</li><li>필터 <code>tcp.flags.syn==1 or icmp</code> 적용</li><li>프레임/패킷/세그먼트 길이와 헤더 구조 기록<br><strong>지표</strong>: 평균 헤더비율 (헤더/전체), PMTUD/ICMP 가시성, 재전송 비율<br><strong>산출물</strong>: 스크린샷 + 표 1 매 (헤더비율, MSS, MTU 추정)</li></ol><h3 id=wireshark-로-http-트래픽-분석-및-pdu-계층별-디코딩>Wireshark 로 HTTP 트래픽 분석 및 PDU 계층별 디코딩<a hidden class=anchor aria-hidden=true href=#wireshark-로-http-트래픽-분석-및-pdu-계층별-디코딩>#</a></h3><p><strong>시나리오</strong>: 사용자가 웹 브라우저로 <code>http://example.com/index.html</code> 에 접속할 때, PDU 계층별 헤더를 Wireshark 로 캡처·분석하여 캡슐화 과정을 시각적으로 확인한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th style=text-align:center>단계</th><th>작업</th><th style=text-align:center>담당</th><th style=text-align:center>도구</th><th style=text-align:center>소요 시간</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td>Wireshark 캡처 시작</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>2</td><td>웹 브라우저로 <code>http://example.com</code> 접속</td><td style=text-align:center>실습자</td><td style=text-align:center>Chrome/Firefox</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>3</td><td>Wireshark 캡처 중지 및 <code>http</code> 필터 적용</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>1 분</td></tr><tr><td style=text-align:center>4</td><td>HTTP GET 요청 패킷 선택 및 계층별 확장</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>5</td><td>각 계층 (Ethernet → IP → TCP → HTTP) 헤더 필드 확인·기록</td><td style=text-align:center>실습자</td><td style=text-align:center>Wireshark, 메모장</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>6</td><td>캡슐화 구조 도식화 (Ethernet 안에 IP, IP 안에 TCP, TCP 안에 HTTP)</td><td style=text-align:center>실습자</td><td style=text-align:center>그림 도구 또는 종이</td><td style=text-align:center>5 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>Wireshark 캡처 파일 (.pcap)</li><li>계층별 헤더 필드 기록 표 (예: Ethernet: src_mac=…, dst_mac=…, IP: src_ip=…, dst_ip=…, TCP: src_port=…, dst_port=…, HTTP: method=GET)</li><li>캡슐화 구조 도식 (Ethernet 프레임 → IP 패킷 → TCP 세그먼트 → HTTP 메시지)</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> HTTP GET 요청 패킷이 캡처되고 필터링되었는가?</li><li><input disabled type=checkbox> Ethernet, IP, TCP, HTTP 계층의 주요 헤더 필드 (MAC, IP, Port, Method) 가 정확히 기록되었는가?</li><li><input disabled type=checkbox> 각 계층이 상위 PDU 를 페이로드로 캡슐화하는 구조가 도식으로 표현되었는가?</li></ul><h3 id=tcpdump-로-mtu-초과-패킷-탐지-및-mss-clamping-시뮬레이션>Tcpdump 로 MTU 초과 패킷 탐지 및 MSS Clamping 시뮬레이션<a hidden class=anchor aria-hidden=true href=#tcpdump-로-mtu-초과-패킷-탐지-및-mss-clamping-시뮬레이션>#</a></h3><p><strong>시나리오</strong>: PPPoE(MTU=1492) 환경에서 표준 MSS(1460) 를 사용하면 IP 단편화가 발생한다. tcpdump 로 MTU 초과 패킷을 탐지하고, MSS Clamping 을 적용하여 단편화를 방지한다.</p><p><strong>수행 절차</strong>:</p><table><thead><tr><th style=text-align:center>단계</th><th>작업</th><th style=text-align:center>담당</th><th style=text-align:center>도구</th><th style=text-align:center>소요 시간</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td>PPPoE 인터페이스 MTU 확인 (<code>ip link show ppp0</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>Linux CLI</td><td style=text-align:center>2 분</td></tr><tr><td style=text-align:center>2</td><td>tcpdump 로 MTU 초과 패킷 캡처 (<code>tcpdump -i ppp0 'greater 1492'</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>3</td><td>큰 파일 전송 시도 (<code>scp large_file user@server</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>scp</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>4</td><td>캡처된 패킷 분석: IP 단편화 여부 확인 (Flags: MF=1)</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump, Wireshark</td><td style=text-align:center>5 분</td></tr><tr><td style=text-align:center>5</td><td>iptables 로 MSS Clamping 규칙 추가 (<code>iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu</code>)</td><td style=text-align:center>실습자</td><td style=text-align:center>iptables</td><td style=text-align:center>3 분</td></tr><tr><td style=text-align:center>6</td><td>다시 파일 전송 후 tcpdump 로 단편화 제거 확인</td><td style=text-align:center>실습자</td><td style=text-align:center>tcpdump, scp</td><td style=text-align:center>5 분</td></tr></tbody></table><p><strong>산출물</strong>:</p><ul><li>tcpdump 캡처 로그 (단편화 전/후 비교)</li><li>iptables MSS Clamping 규칙 스크립트</li><li>성능 비교 표 (전송 시간, 재전송 횟수)</li></ul><p><strong>수용 기준 (AC)</strong>:</p><ul><li><input disabled type=checkbox> MTU 초과 패킷이 tcpdump 로 탐지되었는가?</li><li><input disabled type=checkbox> MSS Clamping 적용 후 IP 단편화가 제거되었는가 (MF=0)?</li><li><input disabled type=checkbox> 파일 전송 시간이 단축되거나 재전송 횟수가 감소했는가?</li></ul><h3 id=mtumss-튜닝-실험-가상-환경>MTU·MSS 튜닝 실험 (가상 환경)<a hidden class=anchor aria-hidden=true href=#mtumss-튜닝-실험-가상-환경>#</a></h3><p><strong>목표</strong>: MTU 변화가 PDU 오버헤드·처리량에 미치는 영향 관찰<br><strong>절차</strong>:</p><ol><li>가상 네트워크에서 링크 MTU 를 1500↔9001 로 교체</li><li><code>iperf3</code> 로 TCP/UDP 측정</li><li><code>mtuToMss()</code>/<code>max_payload()</code> 로 이론값 산출</li><li>ICMP 필터링/허용 비교<br><strong>지표</strong>: 처리량 (Gbit/s), P90 지연 (ms), 재전송률, 블랙홀 발생률<br><strong>산출물</strong>: 실험노트 (그래프, 설정, 결론)</li></ol><hr><h2 id=final-summary>Final Summary<a hidden class=anchor aria-hidden=true href=#final-summary>#</a></h2><blockquote><p>PDU(Protocol Data Unit) 는 네트워크 프로토콜 스택의 각 계층에서 처리하는 데이터 블록으로, 계층별로 고유한 명칭 (비트·프레임·패킷·세그먼트·데이터) 과 헤더·트레일러 구조를 가지며, 캡슐화·역캡슐화를 통해 계층 간 역할 분리와 독립성을 구현하고, MTU·MSS 협상·PMTUD 등의 메커니즘을 통해 네트워크 성능 최적화와 문제 진단의 기초가 된다.</p></blockquote><p>PDU 는 OSI 7 계층 모델과 TCP/IP 모델에서 각 계층이 다루는 데이터 단위를 의미한다. 물리 계층 (비트), 데이터링크 계층 (프레임), 네트워크 계층 (패킷), 전송 계층 (세그먼트/데이터그램), 상위 계층 (데이터/메시지) 으로 구분되며, 각 계층은 상위 PDU 를 페이로드로 받아 자신의 헤더·트레일러를 추가하는 캡슐화를 수행한다. 이는 1970 년대 네트워크 상호운용성 문제를 해결하기 위해 등장했으며, 현대 네트워크 아키텍처의 근간이 되었다.</p><p>PDU 구조는 계층 간 독립성과 확장성을 제공하지만, MTU 제약·단편화·재조립 오버헤드 등의 성능 이슈를 동반한다. IP 단편화는 MTU 불일치를 해결하지만 재조립 부담과 단편 손실 리스크가 크며, PMTUD 는 ICMP 차단 시 Black Hole 문제를 일으킨다. 이를 해결하기 위해 TCP MSS 협상, MSS Clamping, Jumbo Frame, ECN 등의 최적화 기법이 사용되며, 각 기법은 환경 (데이터센터·인터넷·VPN) 에 따라 트레이드오프가 존재한다. 예를 들어, Jumbo Frame 은 데이터센터 내부에서는 효과적이지만 인터넷 구간에서는 사용할 수 없다.</p><p>PDU 개념은 전통적인 계층 모델을 기반으로 하지만, SDN(Software-Defined Networking), NFV(Network Functions Virtualization), 5G 네트워크, QUIC 프로토콜 등 새로운 네트워크 패러다임에서는 계층 경계가 모호해지고 있다. 예를 들어, QUIC 는 전송 계층과 응용 계층을 통합하여 UDP 위에서 동작하며, SDN 은 제어 평면과 데이터 평면을 분리하여 계층 간 조작을 동적으로 수행한다. 추가 학습 과제로는 MPLS·VXLAN 등 터널링 프로토콜의 PDU 구조, IPv6 확장 헤더, QUIC 의 프레임 구조, eBPF 를 이용한 커널 레벨 PDU 조작 등이 있다. 실무 프로젝트에서는 Wireshark·tcpdump 를 활용한 패킷 분석, 방화벽·로드밸런서의 Layer 7 PDU 검사, 클라우드 환경 (AWS VPC, Azure VNet) 의 MTU 설정 최적화 등에 PDU 지식을 적용할 수 있다.</p><hr><h2 id=learning-guide>Learning Guide<a hidden class=anchor aria-hidden=true href=#learning-guide>#</a></h2><table><thead><tr><th>단계</th><th>목표 (Outcome)</th><th>과제 (Task)</th><th>평가 기준 (Rubric)</th><th>실습 포함</th></tr></thead><tbody><tr><td><strong>기초</strong></td><td>PDU 정의, OSI·TCP/IP 계층별 명칭·헤더 구조 이해</td><td>- 각 계층 PDU 명칭과 주요 헤더 필드를 표로 정리<br>- 캡슐화·역캡슐화 개념을 그림으로 도식화</td><td>- 7 계층 PDU 명칭을 정확히 기술했는가?<br>- 이더넷·IP·TCP 헤더의 주요 필드를 나열할 수 있는가?</td><td>-</td></tr><tr><td><strong>응용</strong></td><td>Wireshark 로 패킷 캡처·분석, 계층별 PDU 디코딩 능력</td><td>- Workshop 1 수행: HTTP 트래픽 캡처 및 계층별 헤더 분석<br>- TCP 3-way handshake 패킷의 Flags 필드 해석</td><td>- Wireshark 필터 (<code>tcp.port</code>, <code>ip.addr</code>) 를 정확히 작성했는가?<br>- SYN, SYN-ACK, ACK 패킷을 식별하고 순서 번호를 추적했는가?</td><td><strong>실습 1</strong>: Wireshark HTTP 분석</td></tr><tr><td><strong>실무</strong></td><td>MTU·MSS·PMTUD 문제 해결, 네트워크 성능 최적화</td><td>- Workshop 2 수행: MSS Clamping 으로 단편화 방지<br>- 실제 프로젝트에서 Jumbo Frame 또는 Window Scaling 적용</td><td>- MTU 초과 패킷을 tcpdump 로 탐지했는가?<br>- MSS Clamping 적용 후 단편화가 제거되었는가?<br>- 성능 지표 (처리량, 지연) 가 측정·개선되었는가?</td><td><strong>실습 2</strong>: MSS Clamping 시뮬레이션</td></tr><tr><td><strong>심화</strong></td><td>SDN·NFV·QUIC 등 새로운 네트워크 패러다임의 PDU 구조 탐구</td><td>- QUIC 프레임 구조 분석 및 UDP 기반 전송 원리 이해<br>- eBPF 로 커널 레벨 PDU 조작 코드 작성<br>- MPLS·VXLAN 터널링 PDU 구조 연구</td><td>- QUIC 프레임과 TCP 세그먼트의 차이를 설명할 수 있는가?<br>- eBPF 로 패킷 필터링·헤더 수정을 구현했는가?<br>- 터널링 프로토콜의 캡슐화 오버헤드를 분석했는가?</td><td>-</td></tr></tbody></table><hr><h2 id=terminology>Terminology<a hidden class=anchor aria-hidden=true href=#terminology>#</a></h2><table><thead><tr><th>Term EN (ko, abbr)</th><th>정의</th><th>역할/맥락</th><th>관련 개념</th><th>Flags</th></tr></thead><tbody><tr><td>PDU (프로토콜 데이터 단위, Protocol Data Unit)</td><td>네트워크 프로토콜 스택의 각 계층에서 처리·전송하는 데이터 블록</td><td>계층별 역할 분리와 독립성 구현의 기초</td><td>Encapsulation, Decapsulation</td><td>-</td></tr><tr><td>Service Data Unit (서비스 데이터 단위, SDU)</td><td>하위 계층에 전달되는 상위 계층의 데이터</td><td>캡슐화 입력</td><td>PDU, PCI</td><td>core</td></tr><tr><td>Protocol Control Information (프로토콜 제어정보, PCI)</td><td>주소/길이/오류검출 등 제어 필드</td><td>헤더 구성</td><td>헤더, 트레일러</td><td>core</td></tr><tr><td>Bit (비트)</td><td>물리 계층 (Layer 1) PDU, 전기·광 신호로 표현</td><td>네트워크 전송의 최소 단위</td><td>Physical Layer, Signal</td><td>-</td></tr><tr><td>Frame (프레임)</td><td>데이터링크 계층 (Layer 2) PDU, MAC 주소와 FCS 포함</td><td>LAN 내 노드 간 데이터 전달</td><td>Ethernet, MAC Address, FCS</td><td>-</td></tr><tr><td>Packet (패킷)</td><td>네트워크 계층 (Layer 3) PDU, IP 주소와 TTL 포함</td><td>네트워크 간 라우팅의 기본 단위</td><td>IP, Routing, TTL</td><td>-</td></tr><tr><td>Segment (세그먼트)</td><td>전송 계층 (Layer 4) PDU(TCP), 포트 번호와 순서 번호 포함</td><td>종단 간 신뢰성 있는 데이터 전송</td><td>TCP, Port Number, Sequence Number</td><td>-</td></tr><tr><td>Datagram (데이터그램)</td><td>전송 계층 (Layer 4) PDU(UDP), 포트 번호 포함 (비연결형)</td><td>종단 간 비연결형 전송</td><td>UDP, Port Number</td><td>-</td></tr><tr><td>Encapsulation (캡슐화)</td><td>상위 PDU 를 페이로드로 받아 헤더·트레일러를 추가하는 과정</td><td>계층 간 데이터 전달의 핵심 메커니즘</td><td>PDU, Header, Trailer</td><td>-</td></tr><tr><td>Decapsulation (역캡슐화)</td><td>하위 PDU 로부터 헤더·트레일러를 제거하여 상위 PDU 복원</td><td>수신 측 데이터 처리 과정</td><td>PDU, Header Removal</td><td>-</td></tr><tr><td>Header (헤더)</td><td>PDU 앞부분에 추가되는 제어 정보 (주소, 플래그 등)</td><td>계층별 프로토콜 제어 기능 구현</td><td>PDU, Protocol</td><td>-</td></tr><tr><td>Trailer (트레일러)</td><td>PDU 뒷부분에 추가되는 제어 정보 (예: FCS)</td><td>데이터 무결성 검증</td><td>FCS, CRC</td><td>-</td></tr><tr><td>Payload (페이로드)</td><td>PDU 의 실제 데이터 부분 (상위 계층 PDU 또는 사용자 데이터)</td><td>전송 대상 정보</td><td>PDU, User Data</td><td>-</td></tr><tr><td>MTU (최대 전송 단위, Maximum Transmission Unit)</td><td>데이터링크 계층이 하나의 프레임으로 전송할 수 있는 최대 크기</td><td>네트워크 성능 최적화의 핵심 파라미터</td><td>Frame, Fragmentation, MSS</td><td>-</td></tr><tr><td>MSS (최대 세그먼트 크기, Maximum Segment Size)</td><td>TCP 세그먼트의 최대 페이로드 크기 (헤더 제외)</td><td>TCP 성능 최적화 및 단편화 방지</td><td>TCP, MTU, Encapsulation</td><td>-</td></tr><tr><td>Fragmentation (단편화)</td><td>IP 패킷 크기가 MTU 를 초과할 때 여러 단편으로 나누는 과정</td><td>MTU 불일치 해결 (성능 저하 가능성)</td><td>IP, MTU, Reassembly</td><td>Performance Impact</td></tr><tr><td>PMTUD (경로 MTU 발견, Path MTU Discovery)</td><td>경로 상 최소 MTU 를 동적으로 발견하는 메커니즘</td><td>단편화 없는 최대 패킷 크기 결정</td><td>MTU, ICMP, Fragmentation</td><td>ICMP Dependency</td></tr><tr><td>DF (단편화 금지, Don&rsquo;t Fragment)</td><td>IP 헤더 Flags 필드의 비트, 설정 시 단편화 금지</td><td>PMTUD 및 성능 최적화에 사용</td><td>IP, Fragmentation, PMTUD</td><td>-</td></tr><tr><td>FCS (프레임 체크 시퀀스, Frame Check Sequence)</td><td>이더넷 프레임 트레일러의 CRC-32 오류 검출 필드</td><td>데이터링크 계층 무결성 검증</td><td>Frame, CRC, Error Detection</td><td>-</td></tr><tr><td>TTL (수명, Time To Live)</td><td>IP 헤더 필드, 라우팅 홉마다 1 감소 (0 도달 시 폐기)</td><td>라우팅 루프 방지</td><td>IP, Routing, Hop</td><td>-</td></tr><tr><td>Checksum (체크섬)</td><td>IP·TCP·UDP 헤더의 오류 검출 필드</td><td>데이터 무결성 검증 (비암호화)</td><td>Header, Error Detection</td><td>Limited Security</td></tr><tr><td>Jumbo Frame (점보 프레임)</td><td>MTU 가 9000 바이트 이상인 이더넷 프레임</td><td>데이터센터 내부 성능 최적화</td><td>MTU, Ethernet, Performance</td><td>Compatibility</td></tr><tr><td>ECN (명시적 혼잡 통지, Explicit Congestion Notification)</td><td>IP·TCP 헤더의 혼잡 제어 필드, 패킷 손실 없이 혼잡 신호 전달</td><td>TCP 성능 향상 및 지연 감소</td><td>TCP, Congestion Control, QoS</td><td>-</td></tr><tr><td>Window Scaling (윈도우 스케일링)</td><td>TCP 윈도우 크기를 최대 1GB 까지 확장하는 옵션</td><td>고대역폭·고지연 네트워크 성능 최적화</td><td>TCP, Window Size, Performance</td><td>-</td></tr><tr><td>CAM Table (내용 주소화 메모리 테이블, Content Addressable Memory Table)</td><td>스위치가 MAC 주소와 포트를 매핑한 테이블</td><td>Layer 2 스위칭의 기초</td><td>Switch, MAC Address, Frame</td><td>-</td></tr><tr><td>VLAN (가상 랜, Virtual LAN)</td><td>물리적 네트워크를 논리적으로 분리하는 기술, 802.1Q 태그 사용</td><td>브로드캐스트 도메인 분리 및 보안</td><td>Frame, Tag, Switch</td><td>-</td></tr><tr><td>VXLAN (가상 확장 LAN, Virtual Extensible LAN)</td><td>Layer 2 프레임을 UDP 로 캡슐화하여 Layer 3 네트워크로 전송</td><td>데이터센터·클라우드 네트워크 가상화</td><td>Encapsulation, Tunneling, SDN</td><td>Overhead</td></tr><tr><td>MPLS (다중 프로토콜 라벨 스위칭, Multiprotocol Label Switching)</td><td>레이블 기반 패킷 포워딩, IP 라우팅보다 빠름</td><td>WAN·캐리어 네트워크 성능 최적화</td><td>Label, Routing, Tunneling</td><td>Vendor-Specific</td></tr><tr><td>QUIC (빠른 UDP 인터넷 연결, Quick UDP Internet Connections)</td><td>UDP 위에서 동작하는 전송 계층 프로토콜, HTTP/3 기반</td><td>저지연·고속 웹 통신</td><td>UDP, HTTP/3, Encryption</td><td>Emerging</td></tr><tr><td>Offload (오프로딩: TSO/GSO/GRO)</td><td>NIC 이 세그먼트/병합을 대행</td><td>성능 향상</td><td>캡처 가시성</td><td>perf</td></tr><tr><td>Display/Capture filter (디스플레이/캡처 필터)</td><td>분석·캡처 트래픽 선별</td><td>관찰성</td><td>BPF</td><td>tool</td></tr><tr><td>TLS Record (TLS 레코드)</td><td>TLS 1.3 의 전송 단위</td><td>보안·무결성</td><td>AEAD</td><td>L7</td></tr></tbody></table><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><h3 id=ietf-rfc--표준-스펙-1-차-근거>IETF RFC / 표준 스펙 (1 차 근거)<a hidden class=anchor aria-hidden=true href=#ietf-rfc--표준-스펙-1-차-근거>#</a></h3><ul><li><a href=https://www.rfc-editor.org/rfc/rfc8200.html>RFC 8200: Internet Protocol, Version 6 (IPv6) Specification</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc791.html>RFC 791: Internet Protocol (IPv4)</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc9293.html>RFC 9293: Transmission Control Protocol (TCP)</a></li><li><a href=https://www.ietf.org/rfc/rfc768.txt>RFC 768: User Datagram Protocol (UDP)</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc8446.html>RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3</a></li><li><a href=https://datatracker.ietf.org/doc/rfc9000/>RFC 9000: QUIC: A UDP-Based Multiplexed and Secure Transport</a></li><li><a href=https://datatracker.ietf.org/doc/rfc3168/>RFC 3168: Explicit Congestion Notification (ECN)</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc1191>RFC 1191: Path MTU Discovery for IPv4</a></li><li><a href=https://datatracker.ietf.org/doc/rfc8201/>RFC 8201: Path MTU Discovery for IPv6</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc4821>RFC 4821: Packetization Layer Path MTU Discovery</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc879>RFC 879: TCP Maximum Segment Size</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc7323>RFC 7323: TCP Extensions for High Performance</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc1122>RFC 1122: Requirements for Internet Hosts</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc7348>RFC 7348: VXLAN</a></li></ul><h3 id=ieeeiso-표준>IEEE/ISO 표준<a hidden class=anchor aria-hidden=true href=#ieeeiso-표준>#</a></h3><ul><li><a href=https://standards.ieee.org/ieee/802.3/10422/>IEEE 802.3-2022: Ethernet (overview)</a></li><li><a href=https://standards.ieee.org/ieee/802.11/10548/>IEEE 802.11-2024: WLAN MAC/PHY (overview)</a></li><li><a href=https://standards.ieee.org/ieee/802.1Q/6844/>IEEE 802.1Q: Virtual LANs</a></li><li><a href=https://www.iso.org/standard/20269.html>ISO/IEC 7498-1: OSI Reference Model</a></li></ul><h3 id=3gpp--etsi-모바일-스택-참조>3GPP / ETSI (모바일 스택 참조)<a hidden class=anchor aria-hidden=true href=#3gpp--etsi-모바일-스택-참조>#</a></h3><ul><li><a href=https://www.3gpp.org/dynareport/38321.htm>3GPP TS 38.321: NR MAC protocol specification</a></li><li><a href=https://www.3gpp.org/dynareport/38323.htm>3GPP TS 38.323: NR PDCP specification</a></li><li><a href=https://www.etsi.org/deliver/etsi_ts/138300_138399/138323/18.05.00_60/ts_138323v180500p.pdf>ETSI TS 138 323 V18.5.0 (2025-04)</a></li></ul><h3 id=운영체제플랫폼-가이드--클라우드-문서>운영체제/플랫폼 가이드 & 클라우드 문서<a hidden class=anchor aria-hidden=true href=#운영체제플랫폼-가이드--클라우드-문서>#</a></h3><ul><li><a href=https://docs.kernel.org/networking/segmentation-offloads.html>Linux kernel: Segmentation Offloads (TSO/GSO/GRO)</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/setpmtudiscovery-method-in-class-win32-networkadapterconfiguration>Microsoft Learn: SetPMTUDiscovery</a></li><li><a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/network_mtu.html>AWS EC2: Network MTU & Jumbo Frames</a></li><li><a href=https://cloud.google.com/vpc/docs/mtu>Google Cloud VPC: MTU & MSS Clamping</a></li></ul><h3 id=도구-매뉴얼>도구 매뉴얼<a hidden class=anchor aria-hidden=true href=#도구-매뉴얼>#</a></h3><ul><li><a href=https://www.wireshark.org/docs/wsug_html_chunked/>Wireshark User’s Guide</a></li><li><a href=https://www.tcpdump.org/manpages/tcpdump.1.html>tcpdump man page</a></li></ul><h3 id=서적학술-1-차심화>서적/학술 (1 차·심화)<a hidden class=anchor aria-hidden=true href=#서적학술-1-차심화>#</a></h3><ul><li><a href=https://www.pearson.com/store/p/computer-networks/P100000101303>Computer Networks (Tanenbaum & Wetherall, 5th Edition)</a></li><li><a href=https://www.informit.com/store/tcp-ip-illustrated-volume-1-the-protocols-9780321336316>TCP/IP Illustrated, Vol. 1 (Stevens)</a></li><li><a href=https://dl.acm.org/doi/10.1145/52325.52336>The Design Philosophy of the DARPA Internet Protocols (Clark, 1988)</a></li><li><a href=https://dl.acm.org/doi/10.1145/1851182.1851192>DCTCP: Efficient Packet Transport for the Commoditized Data Center (Alizadeh et al., 2010)</a></li><li><a href=https://ieeexplore.ieee.org/document/6994333>Software-Defined Networking: A Comprehensive Survey (Kreutz et al., 2015)</a></li></ul><h3 id=벤더실무-아티클-보조>벤더/실무 아티클 (보조)<a hidden class=anchor aria-hidden=true href=#벤더실무-아티클-보조>#</a></h3><ul><li><a href=https://developers.cloudflare.com/magic-wan/reference/mtu-mss/>Cloudflare Developers: MTU and MSS</a></li></ul><h3 id=입문용어-해설-보조pdu-등>입문/용어 해설 (보조—PDU 등)<a hidden class=anchor aria-hidden=true href=#입문용어-해설-보조pdu-등>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Protocol_data_unit>Protocol data unit – Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/computer-networks/protocol-data-unit-pdu/>Protocol Data Unit (PDU) – GeeksforGeeks</a></li><li><a href=https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%8B%A8%EC%9C%84>프로토콜 데이터 단위(PDU) – 위키백과(한국어)</a></li><li><a href=https://www.lenovo.com/us/en/glossary/what-is-pdu/>Protocol Data Unit – Lenovo Glossary</a></li><li><a href=https://www.sciencedirect.com/topics/computer-science/protocol-data-unit>Protocol Data Unit — ScienceDirect Topic Overview</a></li><li><a href=https://www.techtarget.com/searchnetworking/definition/protocol-data-unit-PDU>What is a Protocol Data Unit (PDU)? – TechTarget</a></li></ul><h4 id=pdu-관련-블로그학습-글-모음>PDU 관련 블로그/학습 글 모음<a hidden class=anchor aria-hidden=true href=#pdu-관련-블로그학습-글-모음>#</a></h4><ul><li><a href=https://bkkhyunn.github.io/network/3_network/>https://bkkhyunn.github.io/network/3_network/</a></li><li><a href=https://hoonsb.tistory.com/70>https://hoonsb.tistory.com/70</a></li><li><a href=https://jh7722.tistory.com/94>https://jh7722.tistory.com/94</a></li><li><a href=https://coconuts.tistory.com/1415>https://coconuts.tistory.com/1415</a></li><li><a href=https://www.professormesser.com/professor-messer-archives/n10-007/protocol-data-units/>https://www.professormesser.com/professor-messer-archives/n10-007/protocol-data-units/</a></li><li><a href="http://www.ktword.co.kr/test/view/view.php?no=310">http://www.ktword.co.kr/test/view/view.php?no=310</a></li><li><a href=https://www.vpnunlimited.com/ko/help/cybersecurity/protocol-data-unit>https://www.vpnunlimited.com/ko/help/cybersecurity/protocol-data-unit</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>