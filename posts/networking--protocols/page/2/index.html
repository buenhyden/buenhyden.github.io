<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking & Protocols | hyunyoun's Blog</title><meta name=keywords content="Networking-and-Protocols"><meta name=description content="Networking & Protocols - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking--protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking & Protocols"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking & Protocols"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Networking \u0026 Protocols","item":"https://buenhyden.github.io/posts/networking--protocols/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Networking & Protocols</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events 서버 전송 이벤트(Server-Sent Events, SSE)는 웹 서버가 클라이언트 브라우저로 데이터를 자동으로 푸시할 수 있게 해주는 웹 기술이다. 전통적인 HTTP 통신에서는 클라이언트가 요청을 보내고 서버가 응답하는 방식이었지만, SSE는 서버가 필요할 때마다 자발적으로 데이터를 전송할 수 있는 단방향 통신 채널을 제공한다.
SSE는 HTML5 표준의 일부로, EventSource API를 통해 구현된다. 이 기술은 기존 HTTP 프로토콜 위에서 작동하며, 특별한 프로토콜 전환 없이 실시간 통신이 가능하다는 장점이 있다.
SSE의 핵심 특징 서버 전송 이벤트는 다음과 같은 주요 특징을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:31:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Polling</h2></header><div class=entry-content><p>Polling 폴링(Polling)은 API 통합 패턴 중 가장 기본적이면서도 널리 사용되는 방식이다. 이 패턴은 단순하지만 다양한 상황에서 효과적으로 활용될 수 있으며, 올바르게 구현하면 강력한 통합 메커니즘이 될 수 있다.
폴링의 기본 개념 폴링은 클라이언트가 주기적으로 서버에 요청을 보내 새로운 정보나 상태 변화를 확인하는 통신 방식이다. 이는 ‘끌어오기(Pull)’ 방식의 대표적인 예로, 클라이언트가 능동적으로 서버에서 정보를 요청한다.
폴링의 작동 원리 폴링의 기본 작동 과정은 다음과 같다:
클라이언트가 서버에 정보 요청을 보낸다. 서버는 현재 상태나 데이터를 응답으로 반환한다. 클라이언트는 일정 시간(폴링 간격) 동안 대기한다. 대기 시간이 끝나면 클라이언트는 다시 1단계로 돌아가 요청을 반복한다. 이 과정은 클라이언트가 중단하거나 다른 통신 방식으로 전환할 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2025-03-08 15:53:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polling" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Webhooks</h2></header><div class=entry-content><p>Webhook Webhook은 API 통합 패턴 중 하나로, 실시간 데이터 전송과 시스템 간 효율적인 통신을 가능하게 하는 중요한 메커니즘이다.
Webhook은 현대 API 통합 패턴에서 핵심적인 요소로, 실시간 이벤트 기반 아키텍처를 구현하는 데 효과적인 방법이다. 적절한 설계, 구현, 보안 조치를 통해 시스템 간의 효율적이고 안전한 통신을 가능하게 한다.
하지만 복잡성, 보안 문제, 신뢰성 등의 문제를 고려해야 하므로, 사용 사례에 따라 폴링, WebSocket, SSE 등 다른 통합 패턴과 적절히 조합하여 사용하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 15:52:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Webhooks" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/webhooks/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Content Delivery Networks</h2></header><div class=entry-content><p>Content Delivery Networks Content Delivery Network(CDN) 은 이미지, 동영상, JS/CSS 파일, API 응답 등의 정적/동적 콘텐츠를 전 세계 사용자에게 빠르게 전달하기 위해 서버를 분산 배치한 네트워크이다. CDN 은 사용자의 위치에 따라 가장 가까운 엣지 서버 (Edge Server) 에서 콘텐츠를 제공하여 지연 시간을 줄이고, 원본 서버의 부하를 감소시킨다. Push/Pull 방식, 캐싱 정책, TLS 종료, 보안 제어, DDoS 대응 등 다양한 기능을 통해 성능과 안정성을 동시에 확보할 수 있으며, 글로벌 서비스 운영에 필수적인 인프라이다.
...</p></div><footer class=entry-footer><span title='2025-02-17 04:55:00 +0000 UTC'>February 17, 2025</span>&nbsp;·&nbsp;41 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Content Delivery Networks" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/cdn/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Balancing</h2></header><div class=entry-content><p>Load Balancing API 로드 밸런싱은 현대 웹 아키텍처와 분산 시스템의 필수적인 구성 요소로, 트래픽을 여러 서버에 효율적으로 분산하여 성능, 가용성, 안정성을 극대화한다.
API 로드 밸런싱의 기본 개념 로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 분산하는 프로세스로, 단일 서버의 과부하를 방지하고 애플리케이션의 응답성과 가용성을 향상시킨다. API 컨텍스트에서 로드 밸런싱은 특히 중요한데, API가 종종 높은 동시 요청 수와 일관된 응답 시간을 유지해야 하는 미션 크리티컬한 애플리케이션의 기반이 되기 때문이다.
로드 밸런싱이 필요한 이유 성능 최적화: 여러 서버에 부하를 분산하여 응답 시간을 최소화한다. 고가용성: 서버 장애 시에도 서비스 중단 없이 트래픽을 다른 정상 서버로 리디렉션한다. 확장성: 수요 증가에 따라 서버를 추가하고 부하 분산 풀에 통합할 수 있다. 유연성: 서버 유지보수를 위해 일부 서버를 오프라인으로 전환하고 나머지 서버로 트래픽을 라우팅할 수 있다. 효율성: 자원 활용도를 최적화하여 비용을 절감한다. 로드 밸런싱의 유형 API 로드 밸런싱은 여러 수준에서 구현될 수 있다:
...</p></div><footer class=entry-footer><span title='2025-02-13 01:30:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Balancing" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-balancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture</h2></header><div class=entry-content><p>Event-Driven Architecture Event‑Driven Architecture(EDA) 는 시스템 내 이벤트 (예: 주문 생성, 결제 완료) 가 브로커/채널을 통해 퍼블리시되고, 이를 구독한 다양한 서비스들이 독립적으로 반응하는 패턴이다. 이 구조는 Pub/Sub 기반 메시지 전송, 이벤트 라우팅, 비동기 처리, 이벤트 저장소, Eventual Consistency 등을 활용해 서비스 간 느슨한 결합과 독립적 확장성을 확보한다. 또한, 복잡한 업무 흐름 (Orchestration vs Choreography) 및 CQRS/Event Sourcing 패턴도 지원하며, 이기종 시스템 통합, IoT, 마이크로서비스, 실시간 분석 등에서 널리 사용된다.
배경 Event-Driven Architecture 는 전통적인 모놀리식 아키텍처의 한계를 극복하기 위해 등장했다. 2000 년대 초반 SOA(Service-Oriented Architecture) 의 발전과 함께 비동기 메시징의 중요성이 대두되었고, 클라우드 컴퓨팅과 마이크로서비스 아키텍처의 확산으로 EDA 가 주목받게 되었다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:23:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;58 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/event-driven/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dead Letter Queue</h2></header><div class=entry-content><p>Dead Letter Queue Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.
Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.
Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.
데드 레터 큐에 메시지가 전달되는 일반적인 상황 존재하지 않는 큐로의 메시지 전송: 메시지가 존재하지 않는 큐로 전송될 때. 큐의 최대 길이 초과: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때. 메시지 크기 제한 초과: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때. 메시지 만료: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때. 메시지 거부: 다른 큐나 교환기에 의해 메시지가 거부되었을 때. 과도한 재시도 실패: 메시지가 여러 번 처리되었지만 계속해서 실패할 때. DLQ의 주요 특징 분리 저장: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다. 재처리 가능성: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다. 시스템 안정성 향상: 문제가 있는 메시지로 인한 시스템 장애를 방지한다. 모니터링 및 알림: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다. DLQ 구현 방법 큐 생성: 일반 큐와 별도로 DLQ를 생성한다. 재시도 정책 설정: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다. DLQ 연결: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다. DLQ 활용 전략 분석 및 디버깅: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다. 자동 재처리: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다. 알림 설정: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다. 로깅 및 모니터링: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다. 주의사항 보존 기간 설정: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다. 보안: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다. 성능 영향: DLQ 처리로 인한 시스템 부하를 고려해야 한다. 데드 레터 큐를 지원하는 주요 메시징 시스템 Amazon SQS: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다. Apache Kafka: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다. RabbitMQ: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다. 구현 예시 Node.js와 RabbitMQ를 사용
...</p></div><footer class=entry-footer><span title='2024-11-15 12:10:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dead Letter Queue" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-reliability/dead-letter-queue-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Competing Consumers</h2></header><div class=entry-content><p>Competing Consumers Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.
Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.
작동 원리 메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다. 메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다. 경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다. 동작 방식 메시지 생산자(Producer): 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다. 메시지 큐(Message Queue): 게시된 메시지는 큐에 저장되어 대기한다. 메시지 소비자(Consumer): 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다. 이러한 구조를 통해 시스템은 작업 부하를 여러 소비자 인스턴스에 분산시켜 병목 현상을 방지하고, 동시 처리 능력을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Competing Consumers" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-endpoints/competing-consumers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud Networking</h2></header><div class=entry-content><p>Cloud Networking 클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.
기존의 물리적 네트워크와 달리, 가상화 기술을 기반으로 하여 더욱 유연하고 확장성 있는 네트워크 구성이 가능하다.
클라우드 서비스의 안정적인 제공과 효율적인 리소스 관리를 위해서는 견고한 네트워크 인프라가 필수적이다.
기본 개념 클라우드 네트워킹은 클라우드 기반 서비스를 사용하여 조직의 직원, 리소스 및 애플리케이션을 연결하는 기업 네트워크를 배포하는 것.
이는 가상 라우터, 방화벽, 네트워크 관리 소프트웨어 등으로 구성된 WAN(Wide Area Network)이다.
...</p></div><footer class=entry-footer><span title='2024-10-20 17:39:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud Networking" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/modern-networking/cloud-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>네트워크 기능 가상화(Network Functions Virtualization, NFV)</h2></header><div class=entry-content><p>네트워크 기능 가상화(Network Functions Virtualization, NFV) NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.
이를 통해 범용 서버에서 가상 네트워크 기능(VNF)을 실행할 수 있게 된다.
주요 구성요소 가상화된 네트워크 기능(VNF): 소프트웨어로 구현된 네트워크 기능 NFV 인프라(NFVI): VNF를 실행하기 위한 하드웨어 및 소프트웨어 환경 NFV 관리 및 오케스트레이션(MANO): VNF와 NFVI를 관리하고 조율하는 프레임워크 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class NFVArchitecture: def __init__(self): # NFVI (NFV Infrastructure) self.compute_resources = VirtualCompute() self.network_resources = VirtualNetwork() self.storage_resources = VirtualStorage() # VNF (Virtual Network Functions) self.network_functions = { "firewall": VirtualFirewall(), "load_balancer": VirtualLoadBalancer(), "router": VirtualRouter() } # MANO (Management and Orchestration) self.orchestrator = NFVOrchestrator() self.vnf_manager = VNFManager() self.infrastructure_manager = InfrastructureManager() class VirtualNetworkFunction: def __init__(self, function_type): self.type = function_type self.status = "initialized" self.resources = {} def deploy(self, resources): """가상 네트워크 기능 배포""" self.resources = resources self.status = "deployed" def scale(self, factor): """자원 스케일링""" self.resources = { k: v * factor for k, v in self.resources.items() } 장점 하드웨어 비용 절감 유연성과 확장성 향상 신규 서비스 출시 시간 단축 운영 효율성 증대 자동화를 통한 관리 간소화 구현 과제와 해결 방안 성능 최적화
가상화로 인한 성능 저하를 최소화하기 위한 전략들:
...</p></div><footer class=entry-footer><span title='2024-10-20 02:06:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 기능 가상화(Network Functions Virtualization, NFV)" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/modern-networking/network-virtualization/nfv/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/networking--protocols/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/networking--protocols/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>