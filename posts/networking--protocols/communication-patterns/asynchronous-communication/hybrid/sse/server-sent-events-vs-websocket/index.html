<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Server-sent Events vs. Websocket | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,Real-time-APIs,Types,Server-sent-Events"><meta name=description content="전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Server-sent Events vs. Websocket"><meta property="og:description" content="전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-03T05:41:00+00:00"><meta property="article:modified_time" content="2025-03-03T05:41:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="API-Design-and-Implementation"><meta property="article:tag" content="Real-Time-APIs"><meta property="article:tag" content="Types"><meta property="article:tag" content="Server-Sent-Events"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Server-sent Events vs. Websocket"><meta name=twitter:description content="전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Server-sent Events vs. Websocket","item":"https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Server-sent Events vs. Websocket","name":"Server-sent Events vs. Websocket","description":"전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다.","keywords":["Backend-Development","API-Design-and-Implementation","Real-time-APIs","Types","Server-sent-Events"],"articleBody":"Server-sent Events vs. Websocket 웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.\n서버 전송 이벤트(SSE) 개념과 작동 원리 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, EventSource API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.\nSSE의 작동 과정은 다음과 같다:\n클라이언트는 EventSource 객체를 생성하여 서버와 연결을 수립한다. 서버는 text/event-stream 콘텐츠 유형으로 응답하며, 연결을 열린 상태로 유지한다. 서버는 필요할 때마다 정해진 형식으로 데이터를 전송한다. 클라이언트는 이벤트 리스너를 통해 서버에서 오는 메시지를 처리한다. 연결이 끊어지면 클라이언트는 기본적으로 자동 재연결을 시도한다. 코드 예시 클라이언트 측 (JavaScript):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // EventSource 객체 생성 const eventSource = new EventSource('/api/events'); // 기본 메시지 처리 eventSource.onmessage = function(event) { const data = JSON.parse(event.data); console.log('새 데이터 수신:', data); updateUI(data); }; // 특정 이벤트 유형 처리 eventSource.addEventListener('update', function(event) { const updateData = JSON.parse(event.data); console.log('업데이트 이벤트:', updateData); handleUpdate(updateData); }); // 연결 열림 이벤트 eventSource.onopen = function() { console.log('SSE 연결이 수립되었습니다.'); }; // 오류 처리 eventSource.onerror = function(error) { console.error('SSE 연결 오류:', error); }; // 필요시 연결 종료 function closeConnection() { eventSource.close(); } 서버 측 (Node.js with Express):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const express = require('express'); const app = express(); // SSE 엔드포인트 app.get('/api/events', (req, res) =\u003e { // SSE 헤더 설정 res.writeHead(200, { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' }); // 초기 연결 메시지 res.write('data: ' + JSON.stringify({ message: '연결 수립됨' }) + '\\n\\n'); // 주기적으로 데이터 전송 const intervalId = setInterval(() =\u003e { const data = { timestamp: Date.now(), value: Math.random() * 100 }; // 일반 메시지 res.write('data: ' + JSON.stringify(data) + '\\n\\n'); // 특정 이벤트 타입 res.write('event: update\\n'); res.write('data: ' + JSON.stringify(data) + '\\n\\n'); }, 5000); // 클라이언트 연결 종료 시 정리 req.on('close', () =\u003e { clearInterval(intervalId); console.log('클라이언트 연결 종료'); }); }); app.listen(3000, () =\u003e { console.log('SSE 서버가 포트 3000에서 실행 중입니다.'); }); 웹소켓(WebSocket) 개념과 작동 원리 웹소켓(WebSocket)은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 프로토콜이다. HTML5와 함께 도입된 웹소켓은 HTTP와는 별개의 프로토콜(ws:// 또는 wss://)을 사용하며, 초기 핸드셰이크는 HTTP를 통해 이루어지지만 이후 연결이 성공하면 프로토콜이 업그레이드된다.\n웹소켓의 작동 과정은 다음과 같다:\n클라이언트는 WebSocket 객체를 생성하여 서버에 연결을 요청한다. 서버와 클라이언트는 HTTP 프로토콜을 통해 핸드셰이크를 수행한다. 핸드셰이크가 성공하면 연결은 HTTP에서 웹소켓 프로토콜로 업그레이드된다. 이후 클라이언트와 서버는 동일한 연결을 통해 양방향으로 메시지를 주고받을 수 있다. 연결은 어느 한쪽에서 명시적으로 종료할 때까지 유지된다. 코드 예시 클라이언트 측 (JavaScript):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // WebSocket 객체 생성 const socket = new WebSocket('ws://localhost:8080'); // 연결 수립 이벤트 socket.onopen = function(event) { console.log('웹소켓 연결이 수립되었습니다.'); // 서버로 메시지 전송 socket.send(JSON.stringify({ type: 'greeting', content: '안녕하세요, 서버!' })); }; // 메시지 수신 이벤트 socket.onmessage = function(event) { const data = JSON.parse(event.data); console.log('서버로부터 메시지 수신:', data); handleServerMessage(data); }; // 오류 처리 socket.onerror = function(error) { console.error('웹소켓 오류:', error); }; // 연결 종료 이벤트 socket.onclose = function(event) { console.log('웹소켓 연결이 종료되었습니다. 코드:', event.code); }; // 메시지 전송 함수 function sendMessage(message) { if (socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify(message)); } else { console.error('웹소켓이 열려있지 않습니다.'); } } // 연결 종료 function closeConnection() { socket.close(); } 서버 측 (Node.js with ws):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const WebSocket = require('ws'); // WebSocket 서버 생성 const wss = new WebSocket.Server({ port: 8080 }); // 연결 이벤트 처리 wss.on('connection', function connection(ws) { console.log('새 클라이언트가 연결되었습니다.'); // 환영 메시지 전송 ws.send(JSON.stringify({ type: 'welcome', content: '웹소켓 서버에 연결되었습니다!' })); // 메시지 수신 이벤트 ws.on('message', function incoming(message) { const data = JSON.parse(message); console.log('클라이언트로부터 메시지 수신:', data); // 메시지 처리 및 응답 if (data.type === 'greeting') { ws.send(JSON.stringify({ type: 'response', content: '반갑습니다, 클라이언트!' })); } }); // 연결 종료 이벤트 ws.on('close', function() { console.log('클라이언트 연결이 종료되었습니다.'); }); // 오류 처리 ws.on('error', function(error) { console.error('웹소켓 오류:', error); }); }); console.log('웹소켓 서버가 포트 8080에서 실행 중입니다.'); SSE와 WebSocket의 비교 분석 핵심 차이점 SSE와 WebSocket의 가장 근본적인 차이점은 통신 방향과 프로토콜에 있다:\nSSE는 HTTP 프로토콜을 사용하는 단방향(서버 → 클라이언트) 통신 기술이다. WebSocket은 독립적인 프로토콜을 사용하는 양방향(서버 ↔ 클라이언트) 통신 기술이다. 상세 비교 특성 서버 전송 이벤트(SSE) 웹소켓(WebSocket) 통신 방향 단방향 (서버 → 클라이언트) 양방향 (서버 ↔ 클라이언트) 프로토콜 HTTP/HTTPS WebSocket (ws:// 또는 wss://) 연결 수립 표준 HTTP 요청 HTTP 업그레이드를 통한 프로토콜 전환 메시지 형식 텍스트 기반 (text/event-stream) 텍스트 또는 바이너리 데이터 최대 연결 수 브라우저별 HTTP 연결 제한 적용 일반적으로 더 많은 동시 연결 가능 자동 재연결 기본 내장 직접 구현 필요 이벤트 ID 지원 지원 (Last-Event-ID 헤더) 직접 구현 필요 이벤트 유형 구분 네이티브 지원 메시지 내용으로 구현 필요 복잡성 상대적으로 단순 상대적으로 복잡 오버헤드 HTTP 헤더로 인한 오버헤드 초기 설정 후 최소 오버헤드 브라우저 지원 IE를 제외한 대부분 지원 모든 현대 브라우저 지원 프록시 처리 일반 HTTP 프록시 통과 가능 일부 프록시에서 문제 발생 가능 방화벽 통과 일반적으로 쉬움 (HTTP 80/443 포트) 일부 환경에서 차단될 수 있음 서버 구현 대부분의 웹 서버에서 쉽게 구현 전용 WebSocket 서버 또는 라이브러리 필요 확장성 다수의 연결 시 서버 부하 증가 효율적인 양방향 통신으로 확장성 우수 데이터 크기 텍스트 기반으로 제한적 대용량 바이너리 데이터 전송 가능 보안 표준 HTTP 보안 (HTTPS) TLS를 통한 보안 (WSS) 사용 사례 알림, 피드, 업데이트 등 단방향 통신 채팅, 게임, 협업 도구 등 양방향 통신 세부 비교 분석 통신 방식과 프로토콜 SSE는 기존 HTTP 프로토콜을 사용하여 서버에서 클라이언트로 데이터를 푸시한다. 클라이언트가 서버로 데이터를 보내려면 별도의 HTTP 요청이 필요하다. 이는 구현이 단순하고 기존 웹 인프라와 호환성이 좋다는 장점이 있다.\nWebSocket은 HTTP를 통해 초기 핸드셰이크를 수행한 후, 독립적인 양방향 통신 채널로 전환된다. 이후에는 클라이언트와 서버가 동일한 연결을 통해 자유롭게 메시지를 주고받을 수 있다. 이러한 방식은 더 효율적인 통신이 가능하지만, 구현 복잡성이 증가한다.\n연결 관리와 재연결 SSE는 연결이 끊어졌을 때 자동으로 재연결을 시도하는 메커니즘이 기본적으로 내장되어 있다. 또한 Last-Event-ID 헤더를 사용하여 재연결 시 마지막으로 수신한 이벤트 이후의 데이터만 요청할 수 있다.\nWebSocket은 연결 관리와 재연결 로직을 직접 구현해야 한다. 연결이 끊어지면 클라이언트는 이를 감지하고 명시적으로 재연결을 시도해야 한다. 또한 마지막 상태를 복구하기 위한 메커니즘도 직접 구현해야 한다.\n메시지 형식과 크기 SSE는 텍스트 기반 프로토콜로, 메시지는 ‘data:’, ’event:’, ‘id:’ 등의 접두사가 있는 줄로 구성된다. 이는 구조화된 이벤트 전송에 적합하지만, 바이너리 데이터 전송에는 제한이 있다.\nWebSocket은 텍스트와 바이너리 데이터를 모두 효율적으로 전송할 수 있다. 이는 이미지, 오디오, 비디오 등 다양한 유형의 데이터를 처리하는 데 더 유연하다.\n오버헤드와 성능 SSE는 HTTP 프로토콜을 사용하므로, 각 메시지에 HTTP 헤더가 포함되어 일정한 오버헤드가 발생한다. 또한 텍스트 기반 메시지는 효율성 측면에서 제한이 있을 수 있다.\nWebSocket은 초기 연결 이후에는 최소한의 오버헤드로 통신이 가능하다. 프레임 헤더는 매우 작고, 바이너리 데이터 전송이 효율적이다. 따라서 고성능 실시간 애플리케이션에 더 적합하다.\n브라우저 호환성과 인프라 지원 SSE는 Internet Explorer를 제외한 대부분의 현대 브라우저에서 지원된다. HTTP 기반이므로 기존 프록시, 로드 밸런서, 방화벽 등과 호환성이 좋다.\nWebSocket은 모든 현대 브라우저에서 지원되지만, 일부 네트워크 인프라(특히 오래된 프록시 서버)에서는 WebSocket 연결이 차단되거나 제대로 작동하지 않을 수 있다.\n적합한 사용 사례 SSE에 적합한 사용 사례 실시간 업데이트 피드: 뉴스 피드, 소셜 미디어 타임라인, 주식 시세 등 공지사항과 알림: 사용자에게 전달해야 하는 시스템 알림, 이벤트 알림 대시보드 모니터링: 서버 상태, 시스템 성능, 트래픽 정보 등의 실시간 표시 이벤트 로그 스트리밍: 서버 로그, 사용자 활동 로그 등의 실시간 스트리밍 진행 상황 업데이트: 파일 업로드, 다운로드, 처리 작업 등의 진행 상황 표시 WebSocket에 적합한 사용 사례 채팅 애플리케이션: 실시간 메시징, 그룹 채팅, 화상 통화 등 멀티플레이어 게임: 실시간 게임 상태 동기화, 플레이어 간 상호작용 협업 도구: 실시간 문서 편집, 화이트보드, 프레젠테이션 등 IoT 장치 제어: 장치 상태 모니터링 및 실시간 제어 트레이딩 플랫폼: 실시간 주문, 거래 실행, 시장 데이터 업데이트 라이브 스트리밍: 낮은 지연 시간이 필요한 미디어 스트리밍 하이브리드 접근법 많은 현대적인 웹 애플리케이션은 SSE와 WebSocket을 상황에 따라 적절히 조합하여 사용한다:\n리소스 효율성: SSE는 서버에서 클라이언트로의 단방향 통신만 필요한 경우에 사용하고, WebSocket은 양방향 통신이 필요한 기능에만 사용 점진적 향상: SSE를 기본으로 구현하고, WebSocket을 지원하는 환경에서는 WebSocket으로 업그레이드 기능별 선택: 알림과 업데이트는 SSE로, 채팅과 실시간 상호작용은 WebSocket으로 구현 구현 시 고려사항 SSE 구현 시 고려사항 연결 제한: 브라우저당 도메인별 HTTP 연결 수 제한을 고려해야 함 메시지 크기: 대용량 데이터 전송 시 성능 이슈가 발생할 수 있음 IE 지원: Internet Explorer는 SSE를 지원하지 않으므로 폴리필이 필요 시간 초과 처리: 일부 프록시는 오랜 시간 유지되는 연결을 종료할 수 있음 확장성: 많은 수의 동시 연결 처리를 위한 서버 아키텍처 설계 필요 WebSocket 구현 시 고려사항 프록시 및 방화벽: 일부 네트워크 환경에서는 WebSocket 연결이 차단될 수 있음 인증 및 보안: 연결 수립 후에도 지속적인 인증 및 권한 검증 필요 상태 관리: 연결 상태를 모니터링하고 연결 끊김을 처리하는 로직 필요 메시지 형식: 구조화된 메시지 형식 및 프로토콜 설계 필요 확장성: 대규모 동시 연결을 처리하기 위한 서버 인프라 설계 필요 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1560","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-03-03T05:41:00Z","dateModified":"2025-03-03T05:41:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Server-sent Events vs. Websocket</h1><div class=post-description>전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다.</div><div class=post-meta><span title='2025-03-03 05:41:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Networking%20&%20Protocols/Communication%20Patterns/Asynchronous%20Communication/Hybrid/SSE/server-sent-events-vs-websocket.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#server-sent-events-vs-websocket>Server-sent Events vs. Websocket</a><ul><li><a href=#서버-전송-이벤트sse>서버 전송 이벤트(SSE)</a></li><li><a href=#웹소켓websocket>웹소켓(WebSocket)</a></li><li><a href=#sse와-websocket의-비교-분석>SSE와 WebSocket의 비교 분석</a></li><li><a href=#적합한-사용-사례>적합한 사용 사례</a></li><li><a href=#하이브리드-접근법>하이브리드 접근법</a></li><li><a href=#구현-시-고려사항>구현 시 고려사항</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=server-sent-events-vs-websocket>Server-sent Events vs. Websocket<a hidden class=anchor aria-hidden=true href=#server-sent-events-vs-websocket>#</a></h2><p>웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.</p><h3 id=서버-전송-이벤트sse>서버 전송 이벤트(SSE)<a hidden class=anchor aria-hidden=true href=#서버-전송-이벤트sse>#</a></h3><h4 id=개념과-작동-원리>개념과 작동 원리<a hidden class=anchor aria-hidden=true href=#개념과-작동-원리>#</a></h4><p>서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, <code>EventSource</code> API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.</p><p>SSE의 작동 과정은 다음과 같다:</p><ol><li>클라이언트는 <code>EventSource</code> 객체를 생성하여 서버와 연결을 수립한다.</li><li>서버는 <code>text/event-stream</code> 콘텐츠 유형으로 응답하며, 연결을 열린 상태로 유지한다.</li><li>서버는 필요할 때마다 정해진 형식으로 데이터를 전송한다.</li><li>클라이언트는 이벤트 리스너를 통해 서버에서 오는 메시지를 처리한다.</li><li>연결이 끊어지면 클라이언트는 기본적으로 자동 재연결을 시도한다.</li></ol><h4 id=코드-예시>코드 예시<a hidden class=anchor aria-hidden=true href=#코드-예시>#</a></h4><p><strong>클라이언트 측 (JavaScript):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// EventSource 객체 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>eventSource</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>EventSource</span><span class=p>(</span><span class=s1>&#39;/api/events&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 기본 메시지 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>eventSource</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;새 데이터 수신:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>updateUI</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 특정 이벤트 유형 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>eventSource</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;update&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>updateData</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;업데이트 이벤트:&#39;</span><span class=p>,</span> <span class=nx>updateData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>handleUpdate</span><span class=p>(</span><span class=nx>updateData</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 연결 열림 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>eventSource</span><span class=p>.</span><span class=nx>onopen</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;SSE 연결이 수립되었습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 오류 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>eventSource</span><span class=p>.</span><span class=nx>onerror</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;SSE 연결 오류:&#39;</span><span class=p>,</span> <span class=nx>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 필요시 연결 종료
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>closeConnection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>eventSource</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>서버 측 (Node.js with Express):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>express</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;express&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>app</span> <span class=o>=</span> <span class=nx>express</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// SSE 엔드포인트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>app</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;/api/events&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SSE 헤더 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>res</span><span class=p>.</span><span class=nx>writeHead</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Content-Type&#39;</span><span class=o>:</span> <span class=s1>&#39;text/event-stream&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Cache-Control&#39;</span><span class=o>:</span> <span class=s1>&#39;no-cache&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;Connection&#39;</span><span class=o>:</span> <span class=s1>&#39;keep-alive&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 초기 연결 메시지
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>res</span><span class=p>.</span><span class=nx>write</span><span class=p>(</span><span class=s1>&#39;data: &#39;</span> <span class=o>+</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;연결 수립됨&#39;</span> <span class=p>})</span> <span class=o>+</span> <span class=s1>&#39;\n\n&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 주기적으로 데이터 전송
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>intervalId</span> <span class=o>=</span> <span class=nx>setInterval</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>timestamp</span><span class=o>:</span> <span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=nx>value</span><span class=o>:</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>random</span><span class=p>()</span> <span class=o>*</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 일반 메시지
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span><span class=p>.</span><span class=nx>write</span><span class=p>(</span><span class=s1>&#39;data: &#39;</span> <span class=o>+</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=o>+</span> <span class=s1>&#39;\n\n&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 특정 이벤트 타입
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span><span class=p>.</span><span class=nx>write</span><span class=p>(</span><span class=s1>&#39;event: update\n&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span><span class=p>.</span><span class=nx>write</span><span class=p>(</span><span class=s1>&#39;data: &#39;</span> <span class=o>+</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=o>+</span> <span class=s1>&#39;\n\n&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>5000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 클라이언트 연결 종료 시 정리
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>req</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>clearInterval</span><span class=p>(</span><span class=nx>intervalId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;클라이언트 연결 종료&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>app</span><span class=p>.</span><span class=nx>listen</span><span class=p>(</span><span class=mi>3000</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;SSE 서버가 포트 3000에서 실행 중입니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=웹소켓websocket>웹소켓(WebSocket)<a hidden class=anchor aria-hidden=true href=#웹소켓websocket>#</a></h3><h4 id=개념과-작동-원리-1>개념과 작동 원리<a hidden class=anchor aria-hidden=true href=#개념과-작동-원리-1>#</a></h4><p>웹소켓(WebSocket)은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 프로토콜이다. HTML5와 함께 도입된 웹소켓은 HTTP와는 별개의 프로토콜(ws:// 또는 wss://)을 사용하며, 초기 핸드셰이크는 HTTP를 통해 이루어지지만 이후 연결이 성공하면 프로토콜이 업그레이드된다.</p><p>웹소켓의 작동 과정은 다음과 같다:</p><ol><li>클라이언트는 <code>WebSocket</code> 객체를 생성하여 서버에 연결을 요청한다.</li><li>서버와 클라이언트는 HTTP 프로토콜을 통해 핸드셰이크를 수행한다.</li><li>핸드셰이크가 성공하면 연결은 HTTP에서 웹소켓 프로토콜로 업그레이드된다.</li><li>이후 클라이언트와 서버는 동일한 연결을 통해 양방향으로 메시지를 주고받을 수 있다.</li><li>연결은 어느 한쪽에서 명시적으로 종료할 때까지 유지된다.</li></ol><h4 id=코드-예시-1>코드 예시<a hidden class=anchor aria-hidden=true href=#코드-예시-1>#</a></h4><p><strong>클라이언트 측 (JavaScript):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span><span class=lnt id=hl-2-41><a class=lnlinks href=#hl-2-41>41</a>
</span><span class=lnt id=hl-2-42><a class=lnlinks href=#hl-2-42>42</a>
</span><span class=lnt id=hl-2-43><a class=lnlinks href=#hl-2-43>43</a>
</span><span class=lnt id=hl-2-44><a class=lnlinks href=#hl-2-44>44</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// WebSocket 객체 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>socket</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WebSocket</span><span class=p>(</span><span class=s1>&#39;ws://localhost:8080&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 연결 수립 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>onopen</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;웹소켓 연결이 수립되었습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 서버로 메시지 전송
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>socket</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=nx>type</span><span class=o>:</span> <span class=s1>&#39;greeting&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>content</span><span class=o>:</span> <span class=s1>&#39;안녕하세요, 서버!&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>}));</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 수신 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;서버로부터 메시지 수신:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>handleServerMessage</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 오류 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>onerror</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;웹소켓 오류:&#39;</span><span class=p>,</span> <span class=nx>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 연결 종료 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>onclose</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;웹소켓 연결이 종료되었습니다. 코드:&#39;</span><span class=p>,</span> <span class=nx>event</span><span class=p>.</span><span class=nx>code</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 전송 함수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>sendMessage</span><span class=p>(</span><span class=nx>message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>socket</span><span class=p>.</span><span class=nx>readyState</span> <span class=o>===</span> <span class=nx>WebSocket</span><span class=p>.</span><span class=nx>OPEN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>socket</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>(</span><span class=nx>message</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;웹소켓이 열려있지 않습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 연결 종료
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>closeConnection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>socket</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>서버 측 (Node.js with ws):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>WebSocket</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;ws&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WebSocket 서버 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>wss</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WebSocket</span><span class=p>.</span><span class=nx>Server</span><span class=p>({</span> <span class=nx>port</span><span class=o>:</span> <span class=mi>8080</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 연결 이벤트 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>wss</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=nx>connection</span><span class=p>(</span><span class=nx>ws</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;새 클라이언트가 연결되었습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 환영 메시지 전송
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ws</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span>
</span></span><span class=line><span class=cl>        <span class=nx>type</span><span class=o>:</span> <span class=s1>&#39;welcome&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>content</span><span class=o>:</span> <span class=s1>&#39;웹소켓 서버에 연결되었습니다!&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>}));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 메시지 수신 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ws</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=nx>incoming</span><span class=p>(</span><span class=nx>message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;클라이언트로부터 메시지 수신:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 메시지 처리 및 응답
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>type</span> <span class=o>===</span> <span class=s1>&#39;greeting&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>ws</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span>
</span></span><span class=line><span class=cl>                <span class=nx>type</span><span class=o>:</span> <span class=s1>&#39;response&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>content</span><span class=o>:</span> <span class=s1>&#39;반갑습니다, 클라이언트!&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>}));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 연결 종료 이벤트
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ws</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;클라이언트 연결이 종료되었습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 오류 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ws</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;error&#39;</span><span class=p>,</span> <span class=kd>function</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;웹소켓 오류:&#39;</span><span class=p>,</span> <span class=nx>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;웹소켓 서버가 포트 8080에서 실행 중입니다.&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=sse와-websocket의-비교-분석>SSE와 WebSocket의 비교 분석<a hidden class=anchor aria-hidden=true href=#sse와-websocket의-비교-분석>#</a></h3><h4 id=핵심-차이점>핵심 차이점<a hidden class=anchor aria-hidden=true href=#핵심-차이점>#</a></h4><p>SSE와 WebSocket의 가장 근본적인 차이점은 통신 방향과 프로토콜에 있다:</p><ul><li><strong>SSE</strong>는 HTTP 프로토콜을 사용하는 단방향(서버 → 클라이언트) 통신 기술이다.</li><li><strong>WebSocket</strong>은 독립적인 프로토콜을 사용하는 양방향(서버 ↔ 클라이언트) 통신 기술이다.</li></ul><h4 id=상세-비교>상세 비교<a hidden class=anchor aria-hidden=true href=#상세-비교>#</a></h4><table><thead><tr><th>특성</th><th>서버 전송 이벤트(SSE)</th><th>웹소켓(WebSocket)</th></tr></thead><tbody><tr><td><strong>통신 방향</strong></td><td>단방향 (서버 → 클라이언트)</td><td>양방향 (서버 ↔ 클라이언트)</td></tr><tr><td><strong>프로토콜</strong></td><td>HTTP/HTTPS</td><td>WebSocket (ws:// 또는 wss://)</td></tr><tr><td><strong>연결 수립</strong></td><td>표준 HTTP 요청</td><td>HTTP 업그레이드를 통한 프로토콜 전환</td></tr><tr><td><strong>메시지 형식</strong></td><td>텍스트 기반 (text/event-stream)</td><td>텍스트 또는 바이너리 데이터</td></tr><tr><td><strong>최대 연결 수</strong></td><td>브라우저별 HTTP 연결 제한 적용</td><td>일반적으로 더 많은 동시 연결 가능</td></tr><tr><td><strong>자동 재연결</strong></td><td>기본 내장</td><td>직접 구현 필요</td></tr><tr><td><strong>이벤트 ID 지원</strong></td><td>지원 (Last-Event-ID 헤더)</td><td>직접 구현 필요</td></tr><tr><td><strong>이벤트 유형 구분</strong></td><td>네이티브 지원</td><td>메시지 내용으로 구현 필요</td></tr><tr><td><strong>복잡성</strong></td><td>상대적으로 단순</td><td>상대적으로 복잡</td></tr><tr><td><strong>오버헤드</strong></td><td>HTTP 헤더로 인한 오버헤드</td><td>초기 설정 후 최소 오버헤드</td></tr><tr><td><strong>브라우저 지원</strong></td><td>IE를 제외한 대부분 지원</td><td>모든 현대 브라우저 지원</td></tr><tr><td><strong>프록시 처리</strong></td><td>일반 HTTP 프록시 통과 가능</td><td>일부 프록시에서 문제 발생 가능</td></tr><tr><td><strong>방화벽 통과</strong></td><td>일반적으로 쉬움 (HTTP 80/443 포트)</td><td>일부 환경에서 차단될 수 있음</td></tr><tr><td><strong>서버 구현</strong></td><td>대부분의 웹 서버에서 쉽게 구현</td><td>전용 WebSocket 서버 또는 라이브러리 필요</td></tr><tr><td><strong>확장성</strong></td><td>다수의 연결 시 서버 부하 증가</td><td>효율적인 양방향 통신으로 확장성 우수</td></tr><tr><td><strong>데이터 크기</strong></td><td>텍스트 기반으로 제한적</td><td>대용량 바이너리 데이터 전송 가능</td></tr><tr><td><strong>보안</strong></td><td>표준 HTTP 보안 (HTTPS)</td><td>TLS를 통한 보안 (WSS)</td></tr><tr><td><strong>사용 사례</strong></td><td>알림, 피드, 업데이트 등 단방향 통신</td><td>채팅, 게임, 협업 도구 등 양방향 통신</td></tr></tbody></table><h4 id=세부-비교-분석>세부 비교 분석<a hidden class=anchor aria-hidden=true href=#세부-비교-분석>#</a></h4><h5 id=통신-방식과-프로토콜>통신 방식과 프로토콜<a hidden class=anchor aria-hidden=true href=#통신-방식과-프로토콜>#</a></h5><p><strong>SSE</strong>는 기존 HTTP 프로토콜을 사용하여 서버에서 클라이언트로 데이터를 푸시한다. 클라이언트가 서버로 데이터를 보내려면 별도의 HTTP 요청이 필요하다. 이는 구현이 단순하고 기존 웹 인프라와 호환성이 좋다는 장점이 있다.</p><p><strong>WebSocket</strong>은 HTTP를 통해 초기 핸드셰이크를 수행한 후, 독립적인 양방향 통신 채널로 전환된다. 이후에는 클라이언트와 서버가 동일한 연결을 통해 자유롭게 메시지를 주고받을 수 있다. 이러한 방식은 더 효율적인 통신이 가능하지만, 구현 복잡성이 증가한다.</p><h5 id=연결-관리와-재연결>연결 관리와 재연결<a hidden class=anchor aria-hidden=true href=#연결-관리와-재연결>#</a></h5><p><strong>SSE</strong>는 연결이 끊어졌을 때 자동으로 재연결을 시도하는 메커니즘이 기본적으로 내장되어 있다. 또한 <code>Last-Event-ID</code> 헤더를 사용하여 재연결 시 마지막으로 수신한 이벤트 이후의 데이터만 요청할 수 있다.</p><p><strong>WebSocket</strong>은 연결 관리와 재연결 로직을 직접 구현해야 한다. 연결이 끊어지면 클라이언트는 이를 감지하고 명시적으로 재연결을 시도해야 한다. 또한 마지막 상태를 복구하기 위한 메커니즘도 직접 구현해야 한다.</p><h5 id=메시지-형식과-크기>메시지 형식과 크기<a hidden class=anchor aria-hidden=true href=#메시지-형식과-크기>#</a></h5><p><strong>SSE</strong>는 텍스트 기반 프로토콜로, 메시지는 &lsquo;data:&rsquo;, &rsquo;event:&rsquo;, &lsquo;id:&rsquo; 등의 접두사가 있는 줄로 구성된다. 이는 구조화된 이벤트 전송에 적합하지만, 바이너리 데이터 전송에는 제한이 있다.</p><p><strong>WebSocket</strong>은 텍스트와 바이너리 데이터를 모두 효율적으로 전송할 수 있다. 이는 이미지, 오디오, 비디오 등 다양한 유형의 데이터를 처리하는 데 더 유연하다.</p><h5 id=오버헤드와-성능>오버헤드와 성능<a hidden class=anchor aria-hidden=true href=#오버헤드와-성능>#</a></h5><p><strong>SSE</strong>는 HTTP 프로토콜을 사용하므로, 각 메시지에 HTTP 헤더가 포함되어 일정한 오버헤드가 발생한다. 또한 텍스트 기반 메시지는 효율성 측면에서 제한이 있을 수 있다.</p><p><strong>WebSocket</strong>은 초기 연결 이후에는 최소한의 오버헤드로 통신이 가능하다. 프레임 헤더는 매우 작고, 바이너리 데이터 전송이 효율적이다. 따라서 고성능 실시간 애플리케이션에 더 적합하다.</p><h5 id=브라우저-호환성과-인프라-지원>브라우저 호환성과 인프라 지원<a hidden class=anchor aria-hidden=true href=#브라우저-호환성과-인프라-지원>#</a></h5><p><strong>SSE</strong>는 Internet Explorer를 제외한 대부분의 현대 브라우저에서 지원된다. HTTP 기반이므로 기존 프록시, 로드 밸런서, 방화벽 등과 호환성이 좋다.</p><p><strong>WebSocket</strong>은 모든 현대 브라우저에서 지원되지만, 일부 네트워크 인프라(특히 오래된 프록시 서버)에서는 WebSocket 연결이 차단되거나 제대로 작동하지 않을 수 있다.</p><h3 id=적합한-사용-사례>적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#적합한-사용-사례>#</a></h3><h4 id=sse에-적합한-사용-사례>SSE에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#sse에-적합한-사용-사례>#</a></h4><ol><li><strong>실시간 업데이트 피드</strong>: 뉴스 피드, 소셜 미디어 타임라인, 주식 시세 등</li><li><strong>공지사항과 알림</strong>: 사용자에게 전달해야 하는 시스템 알림, 이벤트 알림</li><li><strong>대시보드 모니터링</strong>: 서버 상태, 시스템 성능, 트래픽 정보 등의 실시간 표시</li><li><strong>이벤트 로그 스트리밍</strong>: 서버 로그, 사용자 활동 로그 등의 실시간 스트리밍</li><li><strong>진행 상황 업데이트</strong>: 파일 업로드, 다운로드, 처리 작업 등의 진행 상황 표시</li></ol><h4 id=websocket에-적합한-사용-사례>WebSocket에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#websocket에-적합한-사용-사례>#</a></h4><ol><li><strong>채팅 애플리케이션</strong>: 실시간 메시징, 그룹 채팅, 화상 통화 등</li><li><strong>멀티플레이어 게임</strong>: 실시간 게임 상태 동기화, 플레이어 간 상호작용</li><li><strong>협업 도구</strong>: 실시간 문서 편집, 화이트보드, 프레젠테이션 등</li><li><strong>IoT 장치 제어</strong>: 장치 상태 모니터링 및 실시간 제어</li><li><strong>트레이딩 플랫폼</strong>: 실시간 주문, 거래 실행, 시장 데이터 업데이트</li><li><strong>라이브 스트리밍</strong>: 낮은 지연 시간이 필요한 미디어 스트리밍</li></ol><h3 id=하이브리드-접근법>하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#하이브리드-접근법>#</a></h3><p>많은 현대적인 웹 애플리케이션은 SSE와 WebSocket을 상황에 따라 적절히 조합하여 사용한다:</p><ol><li><strong>리소스 효율성</strong>: SSE는 서버에서 클라이언트로의 단방향 통신만 필요한 경우에 사용하고, WebSocket은 양방향 통신이 필요한 기능에만 사용</li><li><strong>점진적 향상</strong>: SSE를 기본으로 구현하고, WebSocket을 지원하는 환경에서는 WebSocket으로 업그레이드</li><li><strong>기능별 선택</strong>: 알림과 업데이트는 SSE로, 채팅과 실시간 상호작용은 WebSocket으로 구현</li></ol><h3 id=구현-시-고려사항>구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#구현-시-고려사항>#</a></h3><h4 id=sse-구현-시-고려사항>SSE 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#sse-구현-시-고려사항>#</a></h4><ol><li><strong>연결 제한</strong>: 브라우저당 도메인별 HTTP 연결 수 제한을 고려해야 함</li><li><strong>메시지 크기</strong>: 대용량 데이터 전송 시 성능 이슈가 발생할 수 있음</li><li><strong>IE 지원</strong>: Internet Explorer는 SSE를 지원하지 않으므로 폴리필이 필요</li><li><strong>시간 초과 처리</strong>: 일부 프록시는 오랜 시간 유지되는 연결을 종료할 수 있음</li><li><strong>확장성</strong>: 많은 수의 동시 연결 처리를 위한 서버 아키텍처 설계 필요</li></ol><h4 id=websocket-구현-시-고려사항>WebSocket 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#websocket-구현-시-고려사항>#</a></h4><ol><li><strong>프록시 및 방화벽</strong>: 일부 네트워크 환경에서는 WebSocket 연결이 차단될 수 있음</li><li><strong>인증 및 보안</strong>: 연결 수립 후에도 지속적인 인증 및 권한 검증 필요</li><li><strong>상태 관리</strong>: 연결 상태를 모니터링하고 연결 끊김을 처리하는 로직 필요</li><li><strong>메시지 형식</strong>: 구조화된 메시지 형식 및 프로토콜 설계 필요</li><li><strong>확장성</strong>: 대규모 동시 연결을 처리하기 위한 서버 인프라 설계 필요</li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design-and-implementation/>API-Design-and-Implementation</a></li><li><a href=https://buenhyden.github.io/tags/real-time-apis/>Real-Time-APIs</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/server-sent-events/>Server-Sent-Events</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-protocols/web-protocols/websocket/websocket/><span class=title>« Prev</span><br><span>WebSocket</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/authentication-implementation/oauth-2.0/rfc-6749/><span class=title>Next »</span><br><span>RFC 6749</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>