<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Token Authentication vs. JWT | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design,Authentication-Methods,Token-Authentication"><meta name=description content="토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Token Authentication vs. JWT"><meta property="og:description" content="토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-03T07:22:00+00:00"><meta property="article:modified_time" content="2025-04-03T07:22:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Authentication-Methods"><meta property="article:tag" content="Token-Authentication"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Token Authentication vs. JWT"><meta name=twitter:description content="토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Security","item":""},{"@type":"ListItem","position":3,"name":"Access Control","item":""},{"@type":"ListItem","position":6,"name":"Token Authentication","item":"https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/"},{"@type":"ListItem","position":7,"name":"Token Authentication vs. JWT","item":"https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Token Authentication vs. JWT","name":"Token Authentication vs. JWT","description":"토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다.","keywords":["Backend-Development","API-Design","Authentication-Methods","Token-Authentication"],"articleBody":"Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.\n토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.\n기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.\n기본 개념 및 특징 구조: 헤더(Header): 토큰 유형과 사용된 서명 알고리즘 정보 페이로드(Payload): 클레임(사용자 정보, 권한 등) 서명(Signature): 토큰의 무결성을 보장하는 서명 형식: xxxxx.yyyyy.zzzzz 형태의 점으로 구분된 세 부분으로 구성 Base64Url로 인코딩된 JSON 객체 자체 포함성: JWT는 사용자 식별에 필요한 모든 정보를 토큰 내에 포함한다. 서버 측 세션 저장소가 필요 없다(무상태 인증). 서명 검증: 비밀 키(HMAC) 또는 공개/개인 키 쌍(RSA, ECDSA)을 사용하여 토큰에 서명한다. 서버는 토큰의 서명을 검증하여 내용이 변조되지 않았는지 확인한다. 토큰 인증 vs. JWT 비교 특성 일반 토큰 인증 JWT 정의 토큰을 통한 인증 패러다임 토큰 인증의 특정 구현 형태 관계 상위 개념(일반적 접근법) 하위 개념(특정 기술) 구조 다양함(구현에 따라 다름) 표준화된 형식(헤더.페이로드.서명) 정보 포함 일반적으로 식별자만 포함 사용자 정보, 권한 등 다양한 클레임 포함 서버 저장소 대부분 필요함 필요 없음(자체 포함적) 상태 관리 주로 상태 유지(Stateful) 무상태(Stateless) 크기 작음(보통 단순 문자열) 상대적으로 큼(포함된 정보에 따라) 검증 방식 서버 측 데이터베이스 조회 암호화 서명 검증 유연성 구현에 따라 다양한 방식 가능 표준화된 구조와 작동 방식 폐기(Revocation) 용이함(서버에서 삭제) 어려움(블랙리스트 필요) 보안 메커니즘 구현에 따라 다양함 암호화 서명 기반 표준화 표준화되지 않음 RFC 7519로 표준화됨 투명성 토큰 내용이 불투명함 디코딩 가능(내용 확인 가능) 확장성 서버 측 저장소에 의존 높음(무상태 특성) 마이크로서비스 적합성 낮음 높음(자체 포함적 특성) 구현 복잡성 다양함(구현에 따라) 라이브러리를 통해 단순화 심층 분석 개념적 관계\n토큰 인증은 JWT를 포함하는 상위 개념이다. 토큰 인증이라는 큰 범주 안에 JWT, 단순 문자열 토큰, OAuth 토큰 등 다양한 구현 방식이 존재한다. 즉, “토큰 인증 vs JWT\"라는 구도는 정확히는 “일반 범주 vs 특정 구현\"의 비교이다.\n전통적인 토큰 인증 방식\n전통적인 토큰 인증에서는 서버가 무작위 문자열(예: UUID)을 생성하고, 이 토큰을 키로 사용하여 사용자 정보를 데이터베이스나 캐시에 저장한다. 클라이언트가 요청할 때마다 이 토큰을 제시하면, 서버는 데이터베이스에서 이 토큰에 해당하는 사용자 정보를 조회하여 인증을 처리한다.\n1 2 3 4 1. 클라이언트: 로그인 요청(username + password) 2. 서버: 자격 증명 검증 → 무작위 토큰 생성 → 데이터베이스에 토큰과 사용자 정보 저장 → 토큰 반환 3. 클라이언트: 요청 + 토큰 4. 서버: 데이터베이스에서 토큰 조회 → 사용자 정보 확인 → 요청 처리 JWT의 작동 방식\nJWT에서는 서버가 사용자 정보, 권한, 만료 시간 등을 포함한 JSON 객체를 생성하고, 이를 비밀 키로 서명한 후 Base64Url로 인코딩하여 클라이언트에 전송한다. 클라이언트가 이후 요청 시 이 JWT를 제시하면, 서버는 서명을 검증하고 토큰 내부의 정보를 사용하여 인증을 처리한다.\n1 2 3 4 1. 클라이언트: 로그인 요청(username + password) 2. 서버: 자격 증명 검증 → JWT 생성(사용자 정보 포함) → 비밀 키로 서명 → JWT 반환 3. 클라이언트: 요청 + JWT 4. 서버: JWT 서명 검증 → 토큰 내 포함된 사용자 정보 추출 → 요청 처리 장단점 일반 토큰 인증의 장단점 장점:\n토큰 폐기(revocation)가 쉽다(데이터베이스에서 삭제만 하면 됨). 토큰 크기가 작아 네트워크 오버헤드가 낮다. 토큰 내용이 클라이언트에게 불투명하여 민감한 정보를 포함할 수 있다. 세션 데이터를 동적으로 갱신할 수 있다. 단점:\n서버 측 저장소가 필요하여 확장성이 제한된다. 다중 서버 환경에서는 토큰 데이터 동기화가 필요하다. 모든 인증 요청마다 데이터베이스 조회가 필요하다. 마이크로서비스 아키텍처에 적용하기 어렵다. JWT의 장단점 장점:\n무상태(Stateless) 특성으로 서버 확장성이 우수하다. 서버 측 저장소가 필요하지 않아 데이터베이스 부하가 줄어든다. 마이크로서비스 환경에 적합하다. 토큰 자체에 사용자 정보를 포함하여 추가 조회가 필요 없다. 표준화된 형식으로 다양한 언어와 플랫폼에서 지원된다. 단점:\n토큰 폐기가 어렵다(발급된 토큰은 만료 시간까지 유효). 토큰 크기가 커 네트워크 오버헤드가 발생할 수 있다. 민감한 정보를 포함하기 어렵다(서명은 되어 있지만 내용은 디코딩 가능). 토큰 갱신 메커니즘 구현이 복잡할 수 있다. 비밀 키 관리가 중요한 보안 요소이다. 사용 시나리오 및 선택 가이드 일반 토큰 인증이 적합한 경우 토큰 즉시 폐기 기능이 중요한 애플리케이션 사용자 세션 데이터를 동적으로 업데이트해야 하는 경우 토큰 크기를 최소화해야 하는 경우 단일 서버 환경 또는 세션 클러스터링이 구현된 환경 JWT가 적합한 경우 마이크로서비스 아키텍처 서버리스 함수 높은 확장성이 요구되는 애플리케이션 다중 서버/도메인 간 인증이 필요한 경우 데이터베이스 조회를 최소화해야 하는 경우 최신 동향 및 하이브리드 접근법 최근에는 두 방식의 장점을 결합한 하이브리드 접근법이 증가하고 있다:\nJWT + 토큰 블랙리스트: JWT의 확장성을 유지하면서 Redis와 같은 인메모리 데이터베이스에 폐기된 토큰 목록을 관리한다. 짧은 수명 JWT + 리프레시 토큰: 짧은 수명의 JWT와 더 긴 수명의 리프레시 토큰을 함께 사용하여 보안과 사용자 경험을 개선한다. JWT 서비스 계층: 전용 인증 서비스에서만 JWT를 처리하고, 다른 서비스는 이 서비스의 결정을 신뢰하는 아키텍처를 구축한다. 기술적 구현 예시 일반 토큰 인증 구현 (Node.js) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 토큰 생성 (로그인 시) function generateToken(user) { const token = crypto.randomBytes(32).toString('hex'); // 토큰을 데이터베이스나 Redis에 저장 tokenStore.set(token, { userId: user.id, permissions: user.permissions, createdAt: new Date() }); return token; } // 토큰 검증 (요청 시) function verifyToken(token) { // 데이터베이스에서 토큰 조회 const tokenData = tokenStore.get(token); if (!tokenData) { throw new Error('Invalid token'); } // 선택적으로 만료 검사 if (isExpired(tokenData.createdAt)) { tokenStore.delete(token); throw new Error('Token expired'); } return tokenData; } JWT 구현 (Node.js) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // JWT 생성 (로그인 시) function generateJWT(user) { const payload = { sub: user.id, name: user.name, permissions: user.permissions, iat: Math.floor(Date.now() / 1000), exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1시간 후 만료 }; return jwt.sign(payload, SECRET_KEY); } // JWT 검증 (요청 시) function verifyJWT(token) { try { const decoded = jwt.verify(token, SECRET_KEY); return decoded; } catch (err) { throw new Error('Invalid token'); } } 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1021","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-03T07:22:00Z","dateModified":"2025-04-03T07:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href>Security</a>&nbsp;»&nbsp;<a href>Access Control</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/>Token Authentication</a></div><h1 class="post-title entry-hint-parent">Token Authentication vs. JWT</h1><div class=post-description>토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다.</div><div class=post-meta><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Security%20Engineering/Access%20Control/Authentication/Implementations/Token-Based%20Authentication/Token-Based-authentication-vs-jwt.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#token-authentication-vs-jwt>Token Authentication vs. JWT</a><ul><li><a href=#토큰-인증token-authentication>토큰 인증(Token Authentication)</a></li><li><a href=#jwtjson-web-token>JWT(JSON Web Token)</a></li><li><a href=#토큰-인증-vs-jwt-비교>토큰 인증 vs. JWT 비교</a></li><li><a href=#심층-분석>심층 분석</a></li><li><a href=#사용-시나리오-및-선택-가이드>사용 시나리오 및 선택 가이드</a></li><li><a href=#최신-동향-및-하이브리드-접근법>최신 동향 및 하이브리드 접근법</a></li><li><a href=#기술적-구현-예시>기술적 구현 예시</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=token-authentication-vs-jwt>Token Authentication vs. JWT<a hidden class=anchor aria-hidden=true href=#token-authentication-vs-jwt>#</a></h2><p>토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.</p><h3 id=토큰-인증token-authentication>토큰 인증(Token Authentication)<a hidden class=anchor aria-hidden=true href=#토큰-인증token-authentication>#</a></h3><p>토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.</p><h4 id=기본-개념-및-특징>기본 개념 및 특징<a hidden class=anchor aria-hidden=true href=#기본-개념-및-특징>#</a></h4><ol><li><strong>일반적 작동 방식</strong>:<ul><li>사용자가 자격 증명(username/password)을 제출한다.</li><li>서버는 이를 검증하고 고유한 토큰을 생성한다.</li><li>클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다.</li><li>서버는 토큰을 검증하여 사용자를 식별한다.</li></ul></li><li><strong>토큰 형태</strong>:<ul><li>단순 무작위 문자열(UUID 등)</li><li>해시된 값</li><li>인코딩된 데이터 구조(JWT, SAML 등)</li><li>암호화된 페이로드</li></ul></li><li><strong>서버 측 저장</strong>:<ul><li>대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다.</li><li>토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다.</li></ul></li><li><strong>토큰 관리</strong>:<ul><li>서버가 발급한 토큰의 유효성을 관리한다.</li><li>만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다.</li></ul></li></ol><h3 id=jwtjson-web-token>JWT(JSON Web Token)<a hidden class=anchor aria-hidden=true href=#jwtjson-web-token>#</a></h3><p>JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.</p><h4 id=기본-개념-및-특징-1>기본 개념 및 특징<a hidden class=anchor aria-hidden=true href=#기본-개념-및-특징-1>#</a></h4><ol><li><strong>구조</strong>:<ul><li>헤더(Header): 토큰 유형과 사용된 서명 알고리즘 정보</li><li>페이로드(Payload): 클레임(사용자 정보, 권한 등)</li><li>서명(Signature): 토큰의 무결성을 보장하는 서명</li></ul></li><li><strong>형식</strong>:<ul><li><code>xxxxx.yyyyy.zzzzz</code> 형태의 점으로 구분된 세 부분으로 구성</li><li>Base64Url로 인코딩된 JSON 객체</li></ul></li><li><strong>자체 포함성</strong>:<ul><li>JWT는 사용자 식별에 필요한 모든 정보를 토큰 내에 포함한다.</li><li>서버 측 세션 저장소가 필요 없다(무상태 인증).</li></ul></li><li><strong>서명 검증</strong>:<ul><li>비밀 키(HMAC) 또는 공개/개인 키 쌍(RSA, ECDSA)을 사용하여 토큰에 서명한다.</li><li>서버는 토큰의 서명을 검증하여 내용이 변조되지 않았는지 확인한다.</li></ul></li></ol><h3 id=토큰-인증-vs-jwt-비교>토큰 인증 vs. JWT 비교<a hidden class=anchor aria-hidden=true href=#토큰-인증-vs-jwt-비교>#</a></h3><table><thead><tr><th>특성</th><th>일반 토큰 인증</th><th>JWT</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>토큰을 통한 인증 패러다임</td><td>토큰 인증의 특정 구현 형태</td></tr><tr><td><strong>관계</strong></td><td>상위 개념(일반적 접근법)</td><td>하위 개념(특정 기술)</td></tr><tr><td><strong>구조</strong></td><td>다양함(구현에 따라 다름)</td><td>표준화된 형식(헤더.페이로드.서명)</td></tr><tr><td><strong>정보 포함</strong></td><td>일반적으로 식별자만 포함</td><td>사용자 정보, 권한 등 다양한 클레임 포함</td></tr><tr><td><strong>서버 저장소</strong></td><td>대부분 필요함</td><td>필요 없음(자체 포함적)</td></tr><tr><td><strong>상태 관리</strong></td><td>주로 상태 유지(Stateful)</td><td>무상태(Stateless)</td></tr><tr><td><strong>크기</strong></td><td>작음(보통 단순 문자열)</td><td>상대적으로 큼(포함된 정보에 따라)</td></tr><tr><td><strong>검증 방식</strong></td><td>서버 측 데이터베이스 조회</td><td>암호화 서명 검증</td></tr><tr><td><strong>유연성</strong></td><td>구현에 따라 다양한 방식 가능</td><td>표준화된 구조와 작동 방식</td></tr><tr><td><strong>폐기(Revocation)</strong></td><td>용이함(서버에서 삭제)</td><td>어려움(블랙리스트 필요)</td></tr><tr><td><strong>보안 메커니즘</strong></td><td>구현에 따라 다양함</td><td>암호화 서명 기반</td></tr><tr><td><strong>표준화</strong></td><td>표준화되지 않음</td><td>RFC 7519로 표준화됨</td></tr><tr><td><strong>투명성</strong></td><td>토큰 내용이 불투명함</td><td>디코딩 가능(내용 확인 가능)</td></tr><tr><td><strong>확장성</strong></td><td>서버 측 저장소에 의존</td><td>높음(무상태 특성)</td></tr><tr><td><strong>마이크로서비스 적합성</strong></td><td>낮음</td><td>높음(자체 포함적 특성)</td></tr><tr><td><strong>구현 복잡성</strong></td><td>다양함(구현에 따라)</td><td>라이브러리를 통해 단순화</td></tr></tbody></table><h3 id=심층-분석>심층 분석<a hidden class=anchor aria-hidden=true href=#심층-분석>#</a></h3><ol><li><p>개념적 관계<br>토큰 인증은 JWT를 포함하는 상위 개념이다. 토큰 인증이라는 큰 범주 안에 JWT, 단순 문자열 토큰, OAuth 토큰 등 다양한 구현 방식이 존재한다. 즉, &ldquo;토큰 인증 vs JWT"라는 구도는 정확히는 &ldquo;일반 범주 vs 특정 구현"의 비교이다.</p></li><li><p>전통적인 토큰 인증 방식<br>전통적인 토큰 인증에서는 서버가 무작위 문자열(예: UUID)을 생성하고, 이 토큰을 키로 사용하여 사용자 정보를 데이터베이스나 캐시에 저장한다. 클라이언트가 요청할 때마다 이 토큰을 제시하면, 서버는 데이터베이스에서 이 토큰에 해당하는 사용자 정보를 조회하여 인증을 처리한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 클라이언트: 로그인 요청(username + password)
</span></span><span class=line><span class=cl>2. 서버: 자격 증명 검증 → 무작위 토큰 생성 → 데이터베이스에 토큰과 사용자 정보 저장 → 토큰 반환
</span></span><span class=line><span class=cl>3. 클라이언트: 요청 + 토큰
</span></span><span class=line><span class=cl>4. 서버: 데이터베이스에서 토큰 조회 → 사용자 정보 확인 → 요청 처리
</span></span></code></pre></td></tr></table></div></div></li><li><p>JWT의 작동 방식<br>JWT에서는 서버가 사용자 정보, 권한, 만료 시간 등을 포함한 JSON 객체를 생성하고, 이를 비밀 키로 서명한 후 Base64Url로 인코딩하여 클라이언트에 전송한다. 클라이언트가 이후 요청 시 이 JWT를 제시하면, 서버는 서명을 검증하고 토큰 내부의 정보를 사용하여 인증을 처리한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 클라이언트: 로그인 요청(username + password)
</span></span><span class=line><span class=cl>2. 서버: 자격 증명 검증 → JWT 생성(사용자 정보 포함) → 비밀 키로 서명 → JWT 반환
</span></span><span class=line><span class=cl>3. 클라이언트: 요청 + JWT
</span></span><span class=line><span class=cl>4. 서버: JWT 서명 검증 → 토큰 내 포함된 사용자 정보 추출 → 요청 처리
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h4><h5 id=일반-토큰-인증의-장단점>일반 토큰 인증의 장단점<a hidden class=anchor aria-hidden=true href=#일반-토큰-인증의-장단점>#</a></h5><p><strong>장점:</strong></p><ul><li>토큰 폐기(revocation)가 쉽다(데이터베이스에서 삭제만 하면 됨).</li><li>토큰 크기가 작아 네트워크 오버헤드가 낮다.</li><li>토큰 내용이 클라이언트에게 불투명하여 민감한 정보를 포함할 수 있다.</li><li>세션 데이터를 동적으로 갱신할 수 있다.</li></ul><p><strong>단점:</strong></p><ul><li>서버 측 저장소가 필요하여 확장성이 제한된다.</li><li>다중 서버 환경에서는 토큰 데이터 동기화가 필요하다.</li><li>모든 인증 요청마다 데이터베이스 조회가 필요하다.</li><li>마이크로서비스 아키텍처에 적용하기 어렵다.</li></ul><h5 id=jwt의-장단점>JWT의 장단점<a hidden class=anchor aria-hidden=true href=#jwt의-장단점>#</a></h5><p><strong>장점:</strong></p><ul><li>무상태(Stateless) 특성으로 서버 확장성이 우수하다.</li><li>서버 측 저장소가 필요하지 않아 데이터베이스 부하가 줄어든다.</li><li>마이크로서비스 환경에 적합하다.</li><li>토큰 자체에 사용자 정보를 포함하여 추가 조회가 필요 없다.</li><li>표준화된 형식으로 다양한 언어와 플랫폼에서 지원된다.</li></ul><p><strong>단점:</strong></p><ul><li>토큰 폐기가 어렵다(발급된 토큰은 만료 시간까지 유효).</li><li>토큰 크기가 커 네트워크 오버헤드가 발생할 수 있다.</li><li>민감한 정보를 포함하기 어렵다(서명은 되어 있지만 내용은 디코딩 가능).</li><li>토큰 갱신 메커니즘 구현이 복잡할 수 있다.</li><li>비밀 키 관리가 중요한 보안 요소이다.</li></ul><h3 id=사용-시나리오-및-선택-가이드>사용 시나리오 및 선택 가이드<a hidden class=anchor aria-hidden=true href=#사용-시나리오-및-선택-가이드>#</a></h3><h4 id=일반-토큰-인증이-적합한-경우>일반 토큰 인증이 적합한 경우<a hidden class=anchor aria-hidden=true href=#일반-토큰-인증이-적합한-경우>#</a></h4><ul><li>토큰 즉시 폐기 기능이 중요한 애플리케이션</li><li>사용자 세션 데이터를 동적으로 업데이트해야 하는 경우</li><li>토큰 크기를 최소화해야 하는 경우</li><li>단일 서버 환경 또는 세션 클러스터링이 구현된 환경</li></ul><h4 id=jwt가-적합한-경우>JWT가 적합한 경우<a hidden class=anchor aria-hidden=true href=#jwt가-적합한-경우>#</a></h4><ul><li>마이크로서비스 아키텍처</li><li>서버리스 함수</li><li>높은 확장성이 요구되는 애플리케이션</li><li>다중 서버/도메인 간 인증이 필요한 경우</li><li>데이터베이스 조회를 최소화해야 하는 경우</li></ul><h3 id=최신-동향-및-하이브리드-접근법>최신 동향 및 하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#최신-동향-및-하이브리드-접근법>#</a></h3><p>최근에는 두 방식의 장점을 결합한 하이브리드 접근법이 증가하고 있다:</p><ol><li><strong>JWT + 토큰 블랙리스트</strong>: JWT의 확장성을 유지하면서 Redis와 같은 인메모리 데이터베이스에 폐기된 토큰 목록을 관리한다.</li><li><strong>짧은 수명 JWT + 리프레시 토큰</strong>: 짧은 수명의 JWT와 더 긴 수명의 리프레시 토큰을 함께 사용하여 보안과 사용자 경험을 개선한다.</li><li><strong>JWT 서비스 계층</strong>: 전용 인증 서비스에서만 JWT를 처리하고, 다른 서비스는 이 서비스의 결정을 신뢰하는 아키텍처를 구축한다.</li></ol><h3 id=기술적-구현-예시>기술적 구현 예시<a hidden class=anchor aria-hidden=true href=#기술적-구현-예시>#</a></h3><h4 id=일반-토큰-인증-구현-nodejs>일반 토큰 인증 구현 (Node.js)<a hidden class=anchor aria-hidden=true href=#일반-토큰-인증-구현-nodejs>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 토큰 생성 (로그인 시)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>generateToken</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>randomBytes</span><span class=p>(</span><span class=mi>32</span><span class=p>).</span><span class=nx>toString</span><span class=p>(</span><span class=s1>&#39;hex&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 토큰을 데이터베이스나 Redis에 저장
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>tokenStore</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>token</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>userId</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>permissions</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>permissions</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>createdAt</span><span class=o>:</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>token</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 토큰 검증 (요청 시)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>verifyToken</span><span class=p>(</span><span class=nx>token</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 데이터베이스에서 토큰 조회
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>tokenData</span> <span class=o>=</span> <span class=nx>tokenStore</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>tokenData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Invalid token&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 선택적으로 만료 검사
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>isExpired</span><span class=p>(</span><span class=nx>tokenData</span><span class=p>.</span><span class=nx>createdAt</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tokenStore</span><span class=p>.</span><span class=k>delete</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Token expired&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>tokenData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=jwt-구현-nodejs>JWT 구현 (Node.js)<a hidden class=anchor aria-hidden=true href=#jwt-구현-nodejs>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// JWT 생성 (로그인 시)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>generateJWT</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>payload</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sub</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>permissions</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>permissions</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>iat</span><span class=o>:</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>exp</span><span class=o>:</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>60</span> <span class=o>*</span> <span class=mi>60</span><span class=p>)</span> <span class=c1>// 1시간 후 만료
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>jwt</span><span class=p>.</span><span class=nx>sign</span><span class=p>(</span><span class=nx>payload</span><span class=p>,</span> <span class=nx>SECRET_KEY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// JWT 검증 (요청 시)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>verifyJWT</span><span class=p>(</span><span class=nx>token</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>decoded</span> <span class=o>=</span> <span class=nx>jwt</span><span class=p>.</span><span class=nx>verify</span><span class=p>(</span><span class=nx>token</span><span class=p>,</span> <span class=nx>SECRET_KEY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>decoded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Invalid token&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/authentication-methods/>Authentication-Methods</a></li><li><a href=https://buenhyden.github.io/tags/token-authentication/>Token-Authentication</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-saml/><span class=title>« Prev</span><br><span>Token Authentication vs. SAML</span>
</a><a class=next href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-oauth-20/><span class=title>Next »</span><br><span>Token Authentication vs. OAuth</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>