<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Design Principles | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Design Principles - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Design Principles"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Design Principles"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Design Principles","item":"https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Design Principles</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Clean Code</h2></header><div class=entry-content><p>클린 코드 (Clean Code) 클린 코드는 단순히 작동하는 코드를 넘어, 이해하기 쉽고, 유지보수가 용이하며, 오류가 적고, 확장 가능한 코드를 의미한다.
로버트 C. 마틴(Robert C. Martin)의 저서 “Clean Code: A Handbook of Agile Software Craftsmanship"에서 체계적으로 정리된 이 개념은 오늘날 소프트웨어 개발의 핵심 가치로 자리 잡았다.
코드는 컴퓨터뿐만 아니라 다른 개발자들이 읽고 이해해야 하는 것이기 때문에, 클린 코드는 소프트웨어 개발 조직과 프로젝트의 장기적 성공에 중요한 역할을 한다.
클린 코드는 단순한 미학적 선호가 아니라 소프트웨어의 유지보수성, 확장성, 신뢰성을 위한 실질적인 접근 방식이다.
의미 있는 이름, 작고 집중된 함수, 적절한 주석, 일관된 형식, 적절한 추상화 등의 원칙을 따르면 더 나은 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 05:44:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Clean Code" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/clean-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hollywood Principle</h2></header><div class=entry-content><p>Hollywood Principle 할리우드 원칙은 “먼저 연락하지 마세요. 저희가 연락드리겠습니다(Don’t call us, we’ll call you)“라는 문구에서 이름을 따온 소프트웨어 설계 원칙이다.
이 표현은 할리우드 오디션에서 배우들에게 자주 하던 말에서 유래했다. 소프트웨어 설계에서 이 원칙은 제어 흐름의 역전을 의미하며, 고수준 컴포넌트가 저수준 컴포넌트를 직접 호출하는 대신, 상위 수준의 컴포넌트가 하위 수준의 컴포넌트를 직접 호출하지 않고, 추상화된 인터페이스를 통해 상호작용하도록 하는 구조를 만드는 것을 권장한다.
이 원칙은 템플릿 메서드, 옵저버, 의존성 주입과 같은 다양한 디자인 패턴의 기반이 되며, 현대적인 프레임워크와 리액티브 프로그래밍, 함수형 프로그래밍에서도 널리 활용된다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hollywood Principle" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/hollywood-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Program Against Abstractions</h2></header><div class=entry-content><p>Program Against Abstractions “추상화에 대한 프로그래밍”(Program Against Abstractions)은 소프트웨어 설계의 핵심 원칙으로, 구체적인 구현보다는 추상적인 인터페이스나 기본 타입에 의존하여 코드를 작성해야 한다는 개념이다.
이 원칙은 “구현이 아닌 인터페이스에 대해 프로그래밍하라”(Program to an Interface, Not an Implementation)라는 표현으로도 널리 알려져 있다.
이 원칙의 핵심은 코드가 특정 구현의 세부 사항에 의존하는 대신 더 일반적이고 안정적인 추상화에 의존해야 한다는 것이다. 이를 통해 시스템은 더 유연해지고, 변경에 더 견고해지며, 재사용성이 향상된다.
“추상화에 대한 프로그래밍"은 소프트웨어 설계에서 중요한 원칙이다.
이 원칙을 따르면 코드의 결합도가 낮아지고, 유연성이 증가하며, 테스트와 유지 관리가 더 쉬워진다. 이 원칙은 SOLID 원칙, 디자인 패턴, 그리고 현대적인 소프트웨어 아키텍처의 많은 측면과 밀접하게 연관되어 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Program Against Abstractions" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/program-against-abstractions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Composition Over Inheritance</h2></header><div class=entry-content><p>Composition Over Inheritance 객체지향 프로그래밍에서 코드 재사용과 모듈화를 위한 두 가지 주요 방법이 있다: 상속(inheritance)과 합성(composition).
‘합성 우선 상속’ 원칙은 많은 경우에 상속보다 객체 합성을 선호해야 한다는 설계 지침이다. 이 원칙은 객체지향 설계의 유연성, 유지보수성, 확장성을 높이는 데 중요한 역할을 한다.
Composition Over Inheritance는 객체지향 설계에서 유연성과 유지보수성을 극대화할 수 있다.
상속 대신 객체 조합(Composition)을 우선시함으로써, 시스템의 복잡성을 관리하고 변화에 대응하기 용이한 설계를 가능하게 한다.
그러나 모든 설계 결정과 마찬가지로, 합성과 상속 중 어떤 것을 선택할지는 특정 맥락과 요구사항에 따라 달라진다. 진정한 “is-a” 관계가 있거나 다형성이 주요 목표인 경우에는 상속이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composition Over Inheritance" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/composition-over-inheritance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Encapsulate What Varies</h2></header><div class=entry-content><p>Encapsulate What Varies 소프트웨어 설계에서 “가변성 캡슐화(Encapsulate What Varies)” 원칙은 변경 가능성이 높은 부분을 식별하고 이를 캡슐화하여 나머지 코드에 미치는 영향을 최소화하는 접근 방식이다. 이 원칙은 객체지향 설계의 기본 개념 중 하나로, 유지보수성, 확장성, 재사용성을 높이는 데 중요한 역할을 한다.
원칙의 정의와 목적 “가변성 캡슐화” 원칙은 간단히 말해 “변화하는 것을 캡슐화하라"는 지침입니다. 이는 소프트웨어에서 변경될 가능성이 높은 부분을 식별하고, 그것을 나머지 시스템으로부터 분리하여 향후 변경이 시스템 전체에 미치는 영향을 최소화하는 것을 의미한다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulate What Varies" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/encapsulate-what-varies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Law of Demeter</h2></header><div class=entry-content><p>Law of Demeter 데메테르 법칙은 객체 지향 프로그래밍에서 중요한 소프트웨어 설계 원칙으로, “최소 지식 원칙”(Principle of Least Knowledge)이라고도 불린다. 이 원칙은 객체 간의 결합도를 낮추고 소프트웨어의 유지보수성을 향상시키는 것을 목표로 한다.
데메테르 법칙은 객체 지향 설계에서 결합도를 낮추고 캡슐화를 강화하는 중요한 원칙이다.
모든 상황에서 엄격하게 적용하기보다는 소프트웨어의 유지보수성, 가독성, 그리고 견고성을 향상시키는 방향으로 지침으로 활용하는 것이 좋다. 복잡한 객체 그래프를 통한 탐색을 피하고 객체에게 직접 책임을 부여함으로써 더 모듈화되고 유연한 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:25:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Law of Demeter" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/law-of-demeter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 KISS 원칙은 “Keep It Simple, Stupid"의 약자로, 때로는 “Keep It Short and Simple” 또는 “Keep It Simple and Straightforward"로도 해석된다. 이 원칙은 시스템 설계에서 단순함을 추구해야 한다는 기본 철학을 담고 있다.
KISS 원칙은 1960년대 미 해군의 항공기 엔지니어인 켈리 존슨(Kelly Johnson)이 처음 제안했다고 알려져 있다. 그는 항공기 설계와 관련하여 “어떤 항공기든 평균적인 기술자가 기본적인 도구만으로 현장에서 수리할 수 있을 만큼 단순해야 한다"고 주장했다. 이 철학은 소프트웨어 개발을 포함한 다양한 엔지니어링 분야로 확장되었다.
...</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/kiss/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle YAGNI(You Ain’t Gonna Need It)는 소프트웨어 개발에서 중요한 원칙으로, “당신은 그것이 필요하지 않을 것이다"라는 의미를 담고 있다. 이 원칙은 개발자가 현재 필요하지 않은 기능이나 코드를 미리 구현하지 말아야 한다고 제안한다.
YAGNI 원칙은 익스트림 프로그래밍(XP, Extreme Programming)의 창시자인 론 제프리스(Ron Jeffries)와 다른 XP 선구자들에 의해 1990년대에 공식화되었다. 이들은 미래에 필요할지도 모른다는 예측에 기반하여 기능을 구현하는 것이 종종 낭비가 된다는 점을 깨달았다.
현재 요구사항에 집중하고 미래에 대한 과도한 예측을 피함으로써, 개발자는 더 단순하고, 유지보수하기 쉬우며, 실제 가치를 제공하는 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/yagni/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle DRY(Don’t Repeat Yourself) 원칙은 소프트웨어 개발의 기본 지침으로, 중복을 제거하고 코드의 유지보수성, 가독성, 신뢰성을 향상시키는 데 중요한 역할을 한다.
이 원칙은 “모든 지식은 시스템 내에서 단 한 번만, 단 한 곳에서만 표현되어야 한다” 는 개념을 중심으로 한다.
그러나 DRY 원칙은 맹목적으로 적용해서는 안 된다. 과도한 추상화, 조기 추상화, 불필요한 의존성 등의 위험을 고려해야 한다. DRY를 효과적으로 적용하려면 맥락을 고려하고, 점진적으로 리팩토링하며, 테스트로 변경 사항을 뒷받침하고, 공통점과 차이점을 명확히 식별해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/dry/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles SOLID 원칙은 객체 지향 프로그래밍(OOP)에서 가장 중요한 설계 원칙 모음으로, 유지보수가 용이하고 확장 가능한 소프트웨어를 만들기 위한 지침이다.
이 원칙들은 로버트 C. 마틴(Robert C. Martin, ‘Uncle Bob’으로도 알려진)이 2000년대 초반에 제안했으며, 마이클 페더스(Michael Feathers)가 SOLID라는 약어로 정리했다.
SOLID는 다음 다섯 가지 원칙의 첫 글자를 따서 만들어졌다:
Single Responsibility Principle (단일 책임 원칙) Open/Closed Principle (개방/폐쇄 원칙) Liskov Substitution Principle (리스코프 치환 원칙) Interface Segregation Principle (인터페이스 분리 원칙) Dependency Inversion Principle (의존성 역전 원칙) 단일 책임 원칙 (Single Responsibility Principle, SRP) 핵심 개념 “하나의 클래스는 오직 하나의 책임만 가져야 한다.”
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/architecture-knowledge/design-patterns-and-principles/design-principles/solid/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>