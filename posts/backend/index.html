<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Backend"><meta name=description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a></div><h1>Backend</h1><div class=post-description>웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역</div></header><div class=post-content><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>백엔드는 사용자가 직접 보거나 상호작용하지 않는 서버 측(Server-side) 기술과 인프라를 의미한다.<br>웹사이트나 애플리케이션의 데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리 등을 담당하는 시스템의 뒷단이라고 할 수 있다.<br>프런트엔드가 사용자 인터페이스를 제공한다면, 백엔드는 이러한 인터페이스가 실제로 작동하는 데 필요한 모든 로직과 데이터 처리를 담당한다.</p><h3 id=백엔드의-정의와-역할>백엔드의 정의와 역할<a hidden class=anchor aria-hidden=true href=#백엔드의-정의와-역할>#</a></h3><p>백엔드는 다음과 같은 주요 역할을 수행한다:</p><ol><li>서버 관리: 웹 서버를 설정하고 관리하여 클라이언트 요청을 처리한다.</li><li>데이터 처리: 데이터베이스와 상호작용하여 데이터를 저장, 검색, 관리한다.</li><li>비즈니스 로직 구현: 애플리케이션의 핵심 기능과 프로세스를 개발한다.</li><li>API 개발: 프론트엔드와 백엔드 간의 통신을 위한 API를 설계하고 구현한다.</li><li>보안 관리: 사용자 인증, 데이터 암호화 등 보안 관련 기능을 구현한다.</li></ol><h3 id=백엔드가-포함하는-주요-분야>백엔드가 포함하는 주요 분야<a hidden class=anchor aria-hidden=true href=#백엔드가-포함하는-주요-분야>#</a></h3><ol><li>서버 사이드 프로그래밍: Java, Python, Ruby, PHP, Node.js 등의 언어를 사용하여 서버 로직을 개발한다.</li><li>데이터베이스 관리: MySQL, PostgreSQL, MongoDB 등의 데이터베이스 시스템을 사용하여 데이터를 관리한다.</li><li>웹 서버 관리: Apache, Nginx 등의 웹 서버를 설정하고 최적화한다.</li><li>클라우드 컴퓨팅: AWS, Azure, Google Cloud 등의 클라우드 플랫폼을 활용하여 서비스를 배포하고 관리한다.</li><li>시스템 아키텍처 설계: 확장 가능하고 효율적인 시스템 구조를 설계한다.</li><li>DevOps: 지속적 통합 및 배포(CI/CD) 파이프라인을 구축하고 관리한다.</li><li>성능 최적화: 대규모 트래픽을 처리할 수 있도록 시스템을 최적화한다.</li></ol><hr><h2 id=roadmap>Roadmap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h2><p><a href=https://roadmap.sh/backend>Roadmap - Backend</a></p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><p>백엔드 개발은 웹 애플리케이션의 서버 측 로직 및 데이터 처리를 담당하는 영역입니다. 이 섹션에서는 DNS, 웹 서버, API 설계, 이벤트 처리 시스템 등 백엔드 개발의 핵심 기술과 개념을 다룹니다. RESTful API, GraphQL 등 다양한 API 설계 방식과 인증, 권한 관리, 성능 최적화 등 실제 개발에 필요한 주제를 포함합니다. 이벤트 기반 아키텍처, 메시지 브로커, 검색 엔진 통합 등 현대적인 백엔드 시스템 구성에 필요한 지식도 제공합니다.</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fundamentals of Backend</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fundamentals of Backend" href=https://buenhyden.github.io/posts/backend/fundamentals/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>APIs</h2></header><div class=entry-content><p>API(Application Programming Interface)s 두 애플리케이션이 서로 통신할 수 있게 해주는 소프트웨어 중개자.
이는 데이터와 기능을 안전하고 제어된 방식으로 공유할 수 있게 해주는 메커니즘이다.
1 2 3 4 레스토랑에서… - 손님(클라이언트) = API를 사용하는 프로그램 - 웨이터(API) = 주문을 주방에 전달하고 음식을 가져오는 인터페이스 - 주방(서버) = 실제 서비스를 제공하는 시스템 주요 특징 추상화: API는 복잡한 내부 로직을 숨기고 간단한 인터페이스를 제공한다. 표준화: API는 일관된 방식으로 데이터를 주고받을 수 있게 한다. 모듈성: API를 통해 애플리케이션을 독립적인 모듈로 분리할 수 있다. 확장성: API를 사용하면 기존 시스템에 새로운 기능을 쉽게 추가할 수 있다. API 설계할 때 원칙 일관성: API 구조, 명명 규칙, 오류 처리 등에서 일관성을 유지해야 한다.
- 명명 규칙 통일
- 응답 형식 통일
- 에러 처리 방식 통일
잘된 예)
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to APIs" href=https://buenhyden.github.io/posts/backend/api-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Search Engines</h2></header><div class=entry-content><p>Search Engine Search engines는 인터넷과 데이터베이스에 저장된 정보를 검색하고 사용자에게 관련 결과를 제공하는 소프트웨어 시스템이다. 이들은 현대 디지털 환경에서 필수적인 도구로, 정보를 효율적으로 찾고, 분석하며, 정리하는 데 도움을 준다. Google, Bing, Yahoo와 같은 대중적인 웹 검색 엔진뿐만 아니라 Elasticsearch와 같은 특화된 검색 엔진도 존재한다.
검색 엔진은 현대 데이터 관리 생태계의 핵심 구성 요소로서, 방대한 양의 정보에서 필요한 데이터를 효율적으로 찾아내는 특화된 시스템이다. 단순한 키워드 매칭을 넘어서, 오늘날의 검색 엔진은 복잡한 데이터 분석과 실시간 처리를 위한 고도화된 기술을 구현하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-21 05:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Search Engines" href=https://buenhyden.github.io/posts/backend/search-engines/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event and Message Brokers</h2></header><div class=entry-content><p>Event and Message Brokers 분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다.
메시지 브로커(Message Broker)의 이해 메시지 브로커는 애플리케이션 간의 메시지 교환을 중재하며, 시스템 구성 요소 간의 결합도를 낮추는 역할을 합니다. 메시지 브로커는 주로 ‘수행할 작업’에 초점을 맞추며, 명령(Command)이나 요청(Request)을 전달하는 데 사용됩니다.
메시지 브로커의 주요 특징 포인트-투-포인트 통신: 특정 메시지가 하나의 생산자(producer)에서 하나의 소비자(consumer)로 직접 전달된다. 메시지 큐: 메시지는 큐(queue)에 저장되며, 각 메시지는 일반적으로 하나의 소비자에 의해서만 처리된다. 한 번 처리되면 큐에서 제거된다. 동기 또는 비동기 통신: 두 가지 모드 모두 지원할 수 있으나, 주로 비동기 통신에 사용된다. 목적 지향적: 메시지는 특정 목적지 또는 수신자를 대상으로 한다. 신뢰성 있는 전달: 메시지가 적어도 한 번은 성공적으로 전달되도록 보장하는 메커니즘을 제공한다. 일반적인 사용 사례 작업 분배 및 로드 밸런싱 비동기 처리 및 백그라운드 작업 마이크로서비스 간 통신 시스템 간 안정적인 데이터 전송 대표적인 메시지 브로커 RabbitMQ: AMQP(Advanced Message Queuing Protocol)를 구현한 견고한 메시지 브로커로, 다양한 메시징 패턴을 지원한다. ActiveMQ: Apache에서 개발한 오픈 소스 메시지 브로커로, JMS(Java Message Service) API를 지원한다. IBM MQ: 엔터프라이즈급 메시징 솔루션으로 높은 보안성과 안정성을 제공한다. 이벤트 브로커(Event Broker)의 이해 이벤트 브로커는 이벤트 주도 아키텍처(Event-Driven Architecture)의 핵심 구성 요소로, 이벤트 생산자(Producer)와 소비자(Consumer) 간의 비동기 통신을 지원한다. 이벤트 브로커는 주로 ‘발생한 일’에 초점을 맞추며, 시스템 내의 상태 변화나 중요한 비즈니스 사건을 이벤트로 전파한다.
...</p></div><footer class=entry-footer><span title='2025-03-10 02:55:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event and Message Brokers" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backend Performance Best Practices</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-02-13 01:40:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend Performance Best Practices" href=https://buenhyden.github.io/posts/backend/best-practices/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GraphQL</h2></header><div class=entry-content><p>GraphQL GraphQL은 API를 위한 쿼리 언어이자 서버 측에서 데이터를 효율적으로 가져오기 위한 런타임 환경이다. 2012년 Facebook에서 내부적으로 개발되었고, 2015년에 공개적으로 출시되었다.
주요 특징:
클라이언트가 필요한 데이터만 정확히 요청할 수 있음 여러 리소스를 하나의 요청으로 가져올 수 있음 강력한 타입 시스템으로 API의 안정성 보장 자체 문서화(Self-documenting) 기능 제공 GraphQL Vs REST REST API와 비교했을 때 GraphQL의 주요 차이점:
특성 GraphQL REST 엔드포인트 단일 엔드포인트 다중 엔드포인트 데이터 가져오기 필요한 것만 정확히 요청 과도하거나 부족한 데이터 전송 가능 버전 관리 점진적 진화 가능 일반적으로 명시적 버전 필요 상태 코드 항상 200 OK (오류는 응답 내에) 다양한 HTTP 상태 코드 캐싱 복잡함 (별도 솔루션 필요) HTTP 캐싱 활용 GraphQL의 핵심 개념 스키마와 타입 시스템 GraphQL API는 스키마를 통해 정의된다. 스키마는 사용 가능한 모든 데이터 타입과 관계, 작업을 설명한다.
...</p></div><footer class=entry-footer><span title='2024-10-19 03:22:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL" href=https://buenhyden.github.io/posts/backend/graphql/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>