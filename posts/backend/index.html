<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content="Backend"><meta name=description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>Backend</h1><div class=post-description>웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역</div></header><div class=post-content><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>백엔드는 사용자가 직접 보거나 상호작용하지 않는 서버 측(Server-side) 기술과 인프라를 의미한다.<br>웹사이트나 애플리케이션의 데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리 등을 담당하는 시스템의 뒷단이라고 할 수 있다.<br>프런트엔드가 사용자 인터페이스를 제공한다면, 백엔드는 이러한 인터페이스가 실제로 작동하는 데 필요한 모든 로직과 데이터 처리를 담당한다.</p><h3 id=백엔드의-정의와-역할>백엔드의 정의와 역할<a hidden class=anchor aria-hidden=true href=#백엔드의-정의와-역할>#</a></h3><p>백엔드는 다음과 같은 주요 역할을 수행한다:</p><ol><li>서버 관리: 웹 서버를 설정하고 관리하여 클라이언트 요청을 처리한다.</li><li>데이터 처리: 데이터베이스와 상호작용하여 데이터를 저장, 검색, 관리한다.</li><li>비즈니스 로직 구현: 애플리케이션의 핵심 기능과 프로세스를 개발한다.</li><li>API 개발: 프론트엔드와 백엔드 간의 통신을 위한 API를 설계하고 구현한다.</li><li>보안 관리: 사용자 인증, 데이터 암호화 등 보안 관련 기능을 구현한다.</li></ol><h3 id=백엔드가-포함하는-주요-분야>백엔드가 포함하는 주요 분야<a hidden class=anchor aria-hidden=true href=#백엔드가-포함하는-주요-분야>#</a></h3><ol><li>서버 사이드 프로그래밍: Java, Python, Ruby, PHP, Node.js 등의 언어를 사용하여 서버 로직을 개발한다.</li><li>데이터베이스 관리: MySQL, PostgreSQL, MongoDB 등의 데이터베이스 시스템을 사용하여 데이터를 관리한다.</li><li>웹 서버 관리: Apache, Nginx 등의 웹 서버를 설정하고 최적화한다.</li><li>클라우드 컴퓨팅: AWS, Azure, Google Cloud 등의 클라우드 플랫폼을 활용하여 서비스를 배포하고 관리한다.</li><li>시스템 아키텍처 설계: 확장 가능하고 효율적인 시스템 구조를 설계한다.</li><li>DevOps: 지속적 통합 및 배포(CI/CD) 파이프라인을 구축하고 관리한다.</li><li>성능 최적화: 대규모 트래픽을 처리할 수 있도록 시스템을 최적화한다.</li></ol><hr><h2 id=roadmap>Roadmap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h2><h2 id=roadmap---backend><a href=https://roadmap.sh/backend>Roadmap - Backend</a><a hidden class=anchor aria-hidden=true href=#roadmap---backend>#</a></h2><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka Vs RabbitMQ Kafka와 RabbitMQ는 모두 메시지 브로커 시스템으로, 분산 시스템에서 데이터를 효율적으로 전송하고 처리하는 역할을 한다.
Apache Kafka:
분산 스트리밍 플랫폼 대용량 실시간 데이터 처리에 최적화 높은 처리량과 확장성 제공 데이터 스트림의 발행/구독, 저장, 처리 기능 제공 RabbitMQ:
메시지 지향 미들웨어 AMQP(Advanced Message Queuing Protocol) 구현 다양한 메시징 패턴 지원 신뢰성 있는 메시지 전달과 라우팅 기능 제공 Kafka Vs RabbitMQ 비교 분석 특성 Apache Kafka RabbitMQ 아키텍처 분산 로그 메시지 브로커 주요 용도 대용량 실시간 데이터 스트리밍 일반적인 메시징 시나리오 성능 매우 높은 처리량 중간 수준의 처리량 메시지 순서 파티션 내에서 보장 FIFO 큐로 보장 메시지 보존 장기간 보존 가능 일반적으로 단기 보존 확장성 수평적 확장 용이 클러스터링 지원 프로토콜 자체 프로토콜 AMQP, MQTT 등 다양한 프로토콜 지원 라우팅 복잡성 상대적으로 단순 복잡한 라우팅 가능 클라이언트 지원 제한적 다양한 언어 지원 관리 용이성 상대적으로 복잡 사용자 친화적 관리 도구 Kafka 선택이 좋은 경우: 대용량 데이터 처리가 필요할 때 실시간 스트림 처리가 중요할 때 높은 처리량이 요구될 때 장기간의 데이터 보존이 필요할 때 RabbitMQ 선택이 좋은 경우: 복잡한 라우팅이 필요할 때 전통적인 메시징 패턴을 사용할 때 낮은 지연시간이 중요할 때 관리의 용이성이 중요할 때 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;187 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/kafka-vs-rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>마이그레이션 (Migration)</h2></header><div class=entry-content><p>마이그레이션 (Migration) 마이그레이션(Migration)은 IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정을 의미한다.
마이그레이션은 기존 시스템 환경에서 새로운 환경으로 전환하는 것을 의미한다.
주요 목적은 비즈니스 선진화와 비용 절감, 시스템 성능 향상, 보안 강화 등이다.
마이그레이션의 유형 데이터 마이그레이션: 데이터를 한 스토리지에서 다른 스토리지로 이동. 애플리케이션 마이그레이션: 소프트웨어를 새로운 환경으로 이동. 클라우드 마이그레이션: 온프레미스에서 클라우드로, 또는 클라우드 간 이동. 비즈니스 프로세스 마이그레이션: 비즈니스 운영 방식 최적화를 위한 이동. 마이그레이션 전략 (6R) Rehost (리호스팅): 애플리케이션 구조 변경 없이 클라우드로 전환 Replatform (리플랫폼): 클라우드 환경의 일부 서비스를 활용하여 전환 Refactor (리팩터): 클라우드 환경에 적합하게 애플리케이션 구조 변경 Repurchase (리퍼체이스): 기존 시스템을 SaaS로 대체 Retire (리타이어): 기존 시스템 폐기 Retain (리테인): 현 상태 유지 마이그레이션 과정 계획: 요구사항 분석, 목표 설정, 전략 수립 실행: 데이터 또는 시스템 이전 검증: 이전된 데이터나 시스템의 정확성 및 성능 확인 주의사항 데이터 손실 위험: 마이그레이션 중 데이터 손실 가능성 고려 보안: 데이터 암호화 및 보안 조치 필요 호환성: 새 환경과의 호환성 확인 성능: 마이그레이션 후 성능 저하 가능성 고려 비용: 예상치 못한 추가 비용 발생 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-19 15:05:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;174 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 마이그레이션 (Migration)" href=https://buenhyden.github.io/posts/backend/scalability/migration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) and Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) and Web Server 비교 항목 Web Application Server (WAS) Web Server 기본 개념 동적 컨텐츠를 처리하고 생성하는 미들웨어로, 애플리케이션의 로직을 실행하고 데이터베이스와 상호작용 클라이언트의 HTTP 요청을 처리하고 정적 컨텐츠(HTML, 이미지 등)를 제공하는 서버 주요 기능 - 동적 컨텐츠 생성
- 비즈니스 로직 처리
- 데이터베이스 연동
- 트랜잭션 관리
- 세션 관리 - 정적 파일 제공
- 리버스 프록시
- 로드 밸런싱
- 캐싱
- 보안 설정 처리 방식 요청을 받아 서버 내부에서 프로그램을 실행하고 결과를 동적으로 생성하여 응답 클라이언트 요청에 대해 이미 존재하는 정적 파일을 직접 전송 리소스 사용 CPU와 메모리를 많이 사용하며, 동적 처리로 인한 부하가 높음 상대적으로 적은 리소스를 사용하며, 정적 파일 처리에 최적화 성능 특성 - 동적 처리로 인한 지연 발생
- 복잡한 연산 가능
- 상대적으로 느린 응답 시간 - 빠른 응답 속도
- 높은 동시성 처리
- 단순한 요청 처리에 최적화 확장성 - 수직적/수평적 확장 가능
- 로드 밸런싱 필요
- 세션 클러스터링 고려 필요 - 쉬운 수평적 확장
- 단순한 로드 밸런싱
- 상태를 유지하지 않음 보안 - 애플리케이션 레벨 보안
- 인증/인가 처리
SQL 인젝션 방어
XSS 방어 - 네트워크 레벨 보안
SSL/TLS 처리
DDoS 방어
IP 기반 접근 제어 대표적 제품 - Apache Tomcat
JBoss/WildFly
WebLogic
WebSphere - Apache HTTP Server
Nginx
IIS
LiteSpeed 사용 사례 - 전자상거래 시스템
- 온라인 뱅킹
CRM 시스템
ERP 시스템 - 기업 웹사이트
- 블로그
- 포트폴리오 사이트
- 정적 문서 호스팅 프로그래밍 지원 Java, Python, PHP,.NET 등 다양한 프로그래밍 언어와 프레임워크 지원 제한된 스크립팅 기능만 제공 (주로 설정 파일을 통한 제어) 세션 관리 세션 생성, 유지, 만료 처리 등 복잡한 세션 관리 기능 제공 세션 관리 기능 없음 데이터베이스 연동 데이터베이스 커넥션 풀 관리 및 트랜잭션 처리 데이터베이스 연동 기능 없음 모니터링 - 애플리케이션 성능 모니터링
- 메모리 사용량
- 쓰레드 상태
DB 커넥션 상태 - HTTP 요청/응답 모니터링
- 네트워크 트래픽
- 리소스 사용량 장애 대응 - 애플리케이션 레벨 장애 복구
- 트랜잭션 롤백
- 세션 복구 - 서버 레벨 장애 복구
- 정적 파일 백업
- 서버 이중화 구성 복잡도 복잡한 설정과 최적화 필요 상대적으로 단순한 설정 운영 비용 높은 하드웨어 요구사항과 관리 비용 상대적으로 낮은 운영 비용 캐싱 메커니즘 - 동적 컨텐츠 캐싱
- 데이터베이스 쿼리 캐싱
- 세션 데이터 캐싱 - 정적 파일 캐싱
HTTP 응답 캐싱
- 리버스 프록시 캐싱 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;378 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) and Web Server" href=https://buenhyden.github.io/posts/backend/web-application-server-and-web-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue vs Message Broker vs Event Broker</h2></header><div class=entry-content><p>Message Queue Vs Message Broker Vs Event Broker Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:
특성 Message Queue Message Broker Event Broker 주요 기능 메시지 저장 및 전달 메시지 라우팅, 변환, 저장 이벤트 라우팅, 스트리밍, 저장 통신 모델 주로 점대점(Point-to-Point) 점대점 및 발행-구독(Pub/Sub) 주로 발행-구독(Pub/Sub) 메시지 보존 소비 후 일반적으로 삭제 구성에 따라 다름 장기간 보존 가능 확장성 제한적 중간 높음 복잡성 낮음 중간 높음 주요 사용 사례 작업 큐잉, 비동기 처리 시스템 통합, 프로토콜 변환 실시간 데이터 스트리밍, 이벤트 소싱 메시지 순서 보장 일반적으로 보장 보장 가능 재생 기능 제한적 구성에 따라 다름 일반적으로 지원 프로토콜 지원 제한적 다양한 프로토콜 지원 다양한 프로토콜 지원 대표적 제품 RabbitMQ, Redis Apache Kafka, RabbitMQ Apache Kafka, Amazon Kinesis Message Queue Vs Message Broker Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-10-22 07:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;760 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue vs Message Broker vs Event Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Portainer</h2></header><div class=entry-content><p>Portainer란? 컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구
개요 Docker, Kubernetes 등 다양한 컨테이너 플랫폼을 지원하는 범용 컨테이너 관리 솔루션 직관적인 웹 인터페이스를 통해 컨테이너 환경의 복잡성을 단순화 100만 명 이상의 사용자와 30,000개 이상의 GitHub 스타를 보유한 인기 있는 도구 주요 특징과 기능 컨테이너 관리: 컨테이너의 배포, 시작, 중지, 로그 확인 등을 GUI로 수행 스택 배포: Docker Compose를 사용한 멀티 컨테이너 애플리케이션 배포 지원 볼륨 및 네트워크 관리: 데이터 저장소와 네트워크 구성 관리 이미지 관리: Docker 레지스트리 연동 및 이미지 관리 리소스 모니터링: CPU, 메모리 사용량 등 컨테이너 성능 모니터링 템플릿: 미리 정의된 애플리케이션 템플릿을 통한 간편한 배포 장점 사용 편의성: 명령줄 지식 없이도 컨테이너 관리 가능 중앙 집중식 관리: 여러 Docker 환경을 단일 인터페이스에서 관리 보안 강화: 사용자 및 팀 단위의 접근 제어 기능 제공 확장성: 소규모 프로젝트부터 대규모 엔터프라이즈 환경까지 지원 버전 Community Edition (CE): 무료 오픈소스 버전 Business Edition (BE): 기업용 고급 기능(보안, 감사 등) 제공 버전 Portainer 설치 Host간 볼륨 매칭을 위한 디렉토리 생성 1 mkdir -p /kubernetes/portainer_data Portainerdmf docker run 명령어를 통해 docker에 설치
위에서 생성한 폴더와 마운트 1 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /kubernetes/portainer_data:/data portainer/portainer-ce:latest Portainer 로그인
웹브라우저 Portainer 서버(예: http://서버IP:9000)에 접근
[처음 접속시]
username과 password 입력
Source: hyunyoun
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;247 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Portainer" href=https://buenhyden.github.io/posts/backend/containerization-and-virtualization/containerization/tools/portainer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Container</h2></header><div class=entry-content><p>Container 애플리케이션 코드, 라이브러리, 설정 파일 등을 하나의 실행 가능한 패키지로 묶어 다양한 컴퓨팅 환경에서 일관되게 실행할 수 있게 해주는 기술.
컨테이너는 호스트 운영 체제의 커널을 공유하면서 격리된 사용자 공간에서 실행된다.
컨테이너 기술은 Docker, Kubernetes 등의 도구를 통해 구현되며, 현대적인 애플리케이션 개발 및 배포 환경에서 중요한 역할을 하고 있다.
특히 클라우드 네이티브 애플리케이션 개발과 마이크로서비스 아키텍처 구현에 널리 사용되고 있다.
컨테이너의 정의와 작동 방식 컨테이너는 애플리케이션 코드, 라이브러리, 설정 파일 등을 하나의 실행 가능한 패키지로 묶어 다양한 컴퓨팅 환경에서 일관되게 실행할 수 있게 해주는 기술.
컨테이너는 호스트 운영 체제의 커널을 공유하면서 격리된 사용자 공간에서 실행된다.
...</p></div><footer class=entry-footer><span title='2024-11-11 06:14:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Container" href=https://buenhyden.github.io/posts/backend/containerization-and-virtualization/containerization/container/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Content Security Policy</h2></header><div class=entry-content><p>Content Security Policy (CSP) 웹 애플리케이션의 보안을 강화하기 위한 중요한 보안 메커니즘
개념과 목적:
웹 애플리케이션에서 콘텐츠 주입 공격(XSS, 클릭재킹 등)을 방지하기 위한 보안 표준 웹사이트 소유자가 리소스 로딩을 제어할 수 있게 해주는 추가적인 보안 계층 브라우저가 신뢰할 수 있는 콘텐츠 소스를 명시적으로 선언 주요 특징:
HTTP 응답 헤더를 통해 구현 브라우저 레벨에서 정책 강제 화이트리스트 기반의 콘텐츠 제어 위반 사항에 대한 보고 메커니즘 제공 CSP 구현 방법 HTTP 헤더를 통한 구현 1 Content-Security-Policy: default-src 'self'; img-src *; script-src 'self' trusted-scripts.com; HTML 메타 태그를 통한 구현 1 2 &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src *; script-src 'self' trusted-scripts.com;"> CSP 주요 디렉티브 CSP는 다양한 리소스 유형별로 정책을 설정할 수 있습니다:
...</p></div><footer class=entry-footer><span title='2024-11-09 19:58:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;365 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Content Security Policy" href=https://buenhyden.github.io/posts/backend/web-security/content-security-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server Security</h2></header><div class=entry-content><p>Server Security 서버 보안(Server Security)은 서버를 무단 액세스, 데이터 유출 및 기타 보안 위협으로부터 보호하기 위한 프로세스와 도구를 의미한다.
서버는 기업과 개인의 중요한 정보를 저장하고 관리하는 핵심 시스템이므로, 서버 보안은 매우 중요하다.
특징:
다층적 방어: 물리적 보안, 네트워크 보안, 운영 체제 보안 등 여러 계층에서 보안 조치를 구현합니다. 지속적인 모니터링: 서버 활동을 실시간으로 감시하여 이상 징후를 탐지합니다. 정기적인 업데이트: 보안 패치와 소프트웨어 업데이트를 통해 알려진 취약점을 해결합니다. 접근 제어: 인증 및 권한 부여를 통해 서버 접근을 엄격히 관리합니다. 중요성:
...</p></div><footer class=entry-footer><span title='2024-11-09 07:40:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;601 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server Security" href=https://buenhyden.github.io/posts/backend/web-security/server-security/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker</h2></header><div class=entry-content><p>Event Broker Event Broker는 이벤트 기반 아키텍처(Event-Driven Architecture, EDA)의 핵심 구성 요소로, 이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다.
Source: https://developer.confluent.io/patterns/event-stream/event-broker/
주요 기능 이벤트 수집 및 라우팅: 이벤트 생성자로부터 이벤트를 수집하고, 적절한 이벤트 소비자에게 전달한다. 이벤트 저장: 수신한 이벤트를 영구적으로 저장하여, 필요시 재처리나 분석이 가능하도록 한다. 실시간 처리: 대규모의 이벤트 데이터를 실시간으로 처리할 수 있는 능력을 제공한다. 순서 보장: 이벤트의 발생 순서를 유지하여 처리할 수 있도록 지원한다. 확장성 제공: 시스템의 확장에 따라 유연하게 대응할 수 있는 구조를 제공한다. Event Broker의 장점 시스템 분리 (Decoupling)
...</p></div><footer class=entry-footer><span title='2024-10-21 06:28:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker Message Broker는 소프트웨어 애플리케이션, 시스템 및 서비스 간의 통신을 가능하게 하는 중간 소프트웨어 모듈.
애플리케이션 간 통신을 중재하여 상호 의존성을 최소화한다.
Message Broker는 현대적인 분산 시스템과 마이크로서비스 아키텍처에서 중요한 역할을 하며, 시스템 간 효율적인 통신과 데이터 교환을 가능하게 한다.
Source: https://ademcatamak.medium.com/what-is-message-broker-4f6698c73089
주요 기능 메시지 라우팅: 하나 이상의 목적지로 메시지를 전달합니다. 메시지 변환: 다른 형식으로 메시지를 변환합니다. 메시지 집계 및 분해: 여러 메시지를 하나로 결합하거나 하나의 메시지를 여러 개로 분할합니다. 외부 저장소와 상호 작용: 메시지 저장 또는 보강을 위해 외부 저장소를 사용합니다. 웹 서비스 호출: 데이터 검색을 위해 웹 서비스를 호출합니다. 이벤트 및 오류 응답: 특정 이벤트나 오류에 대응합니다. 장점 서비스 간 결합도 감소: 애플리케이션 간 직접적인 의존성을 줄입니다. 확장성 향상: 새로운 서비스나 기능을 쉽게 추가할 수 있습니다. 신뢰성 제공: 메시지 지속성과 보장된 전달을 제공합니다. 비동기 통신 지원: 송신자가 수신자의 응답을 기다릴 필요가 없습니다. 유형 점대점(Point-to-Point) 브로커 메시지가 하나의 생산자에서 하나의 소비자로 직접 전달되는 방식
...</p></div><footer class=entry-footer><span title='2024-10-21 05:38:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1096 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-broker/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/backend/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>