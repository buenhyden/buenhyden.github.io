<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Backend"><meta name=description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a></div><h1>Backend</h1><div class=post-description>웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역</div></header><div class=post-content><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>백엔드는 사용자가 직접 보거나 상호작용하지 않는 서버 측(Server-side) 기술과 인프라를 의미한다.<br>웹사이트나 애플리케이션의 데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리 등을 담당하는 시스템의 뒷단이라고 할 수 있다.<br>프런트엔드가 사용자 인터페이스를 제공한다면, 백엔드는 이러한 인터페이스가 실제로 작동하는 데 필요한 모든 로직과 데이터 처리를 담당한다.</p><h3 id=백엔드의-정의와-역할>백엔드의 정의와 역할<a hidden class=anchor aria-hidden=true href=#백엔드의-정의와-역할>#</a></h3><p>백엔드는 다음과 같은 주요 역할을 수행한다:</p><ol><li>서버 관리: 웹 서버를 설정하고 관리하여 클라이언트 요청을 처리한다.</li><li>데이터 처리: 데이터베이스와 상호작용하여 데이터를 저장, 검색, 관리한다.</li><li>비즈니스 로직 구현: 애플리케이션의 핵심 기능과 프로세스를 개발한다.</li><li>API 개발: 프론트엔드와 백엔드 간의 통신을 위한 API를 설계하고 구현한다.</li><li>보안 관리: 사용자 인증, 데이터 암호화 등 보안 관련 기능을 구현한다.</li></ol><h3 id=백엔드가-포함하는-주요-분야>백엔드가 포함하는 주요 분야<a hidden class=anchor aria-hidden=true href=#백엔드가-포함하는-주요-분야>#</a></h3><ol><li>서버 사이드 프로그래밍: Java, Python, Ruby, PHP, Node.js 등의 언어를 사용하여 서버 로직을 개발한다.</li><li>데이터베이스 관리: MySQL, PostgreSQL, MongoDB 등의 데이터베이스 시스템을 사용하여 데이터를 관리한다.</li><li>웹 서버 관리: Apache, Nginx 등의 웹 서버를 설정하고 최적화한다.</li><li>클라우드 컴퓨팅: AWS, Azure, Google Cloud 등의 클라우드 플랫폼을 활용하여 서비스를 배포하고 관리한다.</li><li>시스템 아키텍처 설계: 확장 가능하고 효율적인 시스템 구조를 설계한다.</li><li>DevOps: 지속적 통합 및 배포(CI/CD) 파이프라인을 구축하고 관리한다.</li><li>성능 최적화: 대규모 트래픽을 처리할 수 있도록 시스템을 최적화한다.</li></ol><hr><h2 id=roadmap>Roadmap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h2><p><a href=https://roadmap.sh/backend>Roadmap - Backend</a></p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><p>백엔드 개발은 웹 애플리케이션의 서버 측 로직 및 데이터 처리를 담당하는 영역입니다. 이 섹션에서는 DNS, 웹 서버, API 설계, 이벤트 처리 시스템 등 백엔드 개발의 핵심 기술과 개념을 다룹니다. RESTful API, GraphQL 등 다양한 API 설계 방식과 인증, 권한 관리, 성능 최적화 등 실제 개발에 필요한 주제를 포함합니다. 이벤트 기반 아키텍처, 메시지 브로커, 검색 엔진 통합 등 현대적인 백엔드 시스템 구성에 필요한 지식도 제공합니다.</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend/event-driven-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fundamentals of Backend</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-04-26 10:20:00 +0000 UTC'>April 26, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fundamentals of Backend" href=https://buenhyden.github.io/posts/backend/fundamentals/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Design</h2></header><div class=entry-content><p>API(Application Programming Interface) Design API(응용 프로그램 프로그래밍 인터페이스, Application Programming Interface)는 소프트웨어 컴포넌트 간의 데이터 교환과 통신을 위한 표준화된 규약 및 인터페이스이다.
API는 현대 소프트웨어 개발의 핵심 요소로, 개발자가 기존 코드와 서비스를 활용하여 새로운 애플리케이션을 빠르게 구축할 수 있게 해준다. 또한, 백엔드 시스템, 서드파티 서비스, 내부 시스템 간의 연결을 가능하게 하며, 데이터와 기능을 안전하게 공유할 수 있는 표준화된 방법을 제공한다.
API는 클라이언트-서버 모델을 기반으로 작동하며, 요청과 응답 메커니즘을 통해 데이터를 교환한다. 웹 API, 운영체제 API, 데이터베이스 API 등 다양한 유형이 있으며, REST, SOAP, GraphQL 등 다양한 아키텍처 스타일로 구현된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Design" href=https://buenhyden.github.io/posts/backend/api-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Search Engines</h2></header><div class=entry-content><p>Search Engine Search engines는 인터넷과 데이터베이스에 저장된 정보를 검색하고 사용자에게 관련 결과를 제공하는 소프트웨어 시스템이다. 이들은 현대 디지털 환경에서 필수적인 도구로, 정보를 효율적으로 찾고, 분석하며, 정리하는 데 도움을 준다. Google, Bing, Yahoo와 같은 대중적인 웹 검색 엔진뿐만 아니라 Elasticsearch와 같은 특화된 검색 엔진도 존재한다.
검색 엔진은 현대 데이터 관리 생태계의 핵심 구성 요소로서, 방대한 양의 정보에서 필요한 데이터를 효율적으로 찾아내는 특화된 시스템이다. 단순한 키워드 매칭을 넘어서, 오늘날의 검색 엔진은 복잡한 데이터 분석과 실시간 처리를 위한 고도화된 기술을 구현하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-21 05:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Search Engines" href=https://buenhyden.github.io/posts/backend/search-engines/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event and Message Brokers</h2></header><div class=entry-content><p>Event and Message Brokers 분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다.
메시지 브로커(Message Broker)의 이해 메시지 브로커는 애플리케이션 간의 메시지 교환을 중재하며, 시스템 구성 요소 간의 결합도를 낮추는 역할을 합니다. 메시지 브로커는 주로 ‘수행할 작업’에 초점을 맞추며, 명령(Command)이나 요청(Request)을 전달하는 데 사용됩니다.
메시지 브로커의 주요 특징 포인트-투-포인트 통신: 특정 메시지가 하나의 생산자(producer)에서 하나의 소비자(consumer)로 직접 전달된다. 메시지 큐: 메시지는 큐(queue)에 저장되며, 각 메시지는 일반적으로 하나의 소비자에 의해서만 처리된다. 한 번 처리되면 큐에서 제거된다. 동기 또는 비동기 통신: 두 가지 모드 모두 지원할 수 있으나, 주로 비동기 통신에 사용된다. 목적 지향적: 메시지는 특정 목적지 또는 수신자를 대상으로 한다. 신뢰성 있는 전달: 메시지가 적어도 한 번은 성공적으로 전달되도록 보장하는 메커니즘을 제공한다. 일반적인 사용 사례 작업 분배 및 로드 밸런싱 비동기 처리 및 백그라운드 작업 마이크로서비스 간 통신 시스템 간 안정적인 데이터 전송 대표적인 메시지 브로커 RabbitMQ: AMQP(Advanced Message Queuing Protocol)를 구현한 견고한 메시지 브로커로, 다양한 메시징 패턴을 지원한다. ActiveMQ: Apache에서 개발한 오픈 소스 메시지 브로커로, JMS(Java Message Service) API를 지원한다. IBM MQ: 엔터프라이즈급 메시징 솔루션으로 높은 보안성과 안정성을 제공한다. 이벤트 브로커(Event Broker)의 이해 이벤트 브로커는 이벤트 주도 아키텍처(Event-Driven Architecture)의 핵심 구성 요소로, 이벤트 생산자(Producer)와 소비자(Consumer) 간의 비동기 통신을 지원한다. 이벤트 브로커는 주로 ‘발생한 일’에 초점을 맞추며, 시스템 내의 상태 변화나 중요한 비즈니스 사건을 이벤트로 전파한다.
...</p></div><footer class=entry-footer><span title='2025-03-10 02:55:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event and Message Brokers" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Security</h2></header><div class=entry-content><p>Security Maintaining Updated Dependencies 의존성 관리는 백엔드 시스템의 보안과 성능을 모두 좌우하는 핵심 요소이다. 최신 버전의 라이브러리와 패키지는 보안 취약점 해결뿐만 아니라 성능 최적화가 적용된 경우가 많다.
의존성 관리의 주요 측면 성능 영향 오래된 패키지는 최신 버전보다 효율성이 떨어지는 경우가 많다. 개발자들은 지속적으로 코드를 개선하고 최적화하기 때문에, 최신 버전일수록 더 나은 성능을 제공하는 경향이 있다. 예를 들어, Node.js 자체의 주요 버전 업데이트는 V8 엔진 개선을 통해 상당한 성능 향상을 가져온다.
...</p></div><footer class=entry-footer><span title='2025-02-13 01:40:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Security" href=https://buenhyden.github.io/posts/backend/security/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Object-Relational Mapping</h2></header><div class=entry-content><p>Object-Relational Mapping (ORM) 객체 지향 프로그래밍 언어와 관계형 데이터베이스 사이의 불일치를 해결하기 위한 기술
특징:
객체와 데이터베이스 테이블 간의 매핑 SQL 쿼리 대신 객체 지향적 방식으로 데이터베이스 조작 데이터베이스 독립성 제공 장점:
직관적이고 가독성 좋은 코드 작성 가능 생산성 향상: 개발자가 비즈니스 로직에 집중 가능 재사용성과 유지보수성 증가 데이터베이스 종속성 감소 단점:
성능 저하 가능성: 복잡한 쿼리의 경우 최적화가 어려울 수 있음 학습 곡선: ORM 사용법을 익히는 데 시간이 필요 복잡한 쿼리 처리의 한계: 매우 복잡한 쿼리는 직접 SQL 작성이 필요할 수 있음 ORM과 raw query 사이에는 성능 차이가 존재한다.
일반적으로 raw SQL이 ORM보다 더 나은 성능을 보인다.
주요 차이점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-12-16 12:59:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Object-Relational Mapping" href=https://buenhyden.github.io/posts/backend/orms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backend Architecture</h2></header><div class=entry-content><p>Backend Architecture 백엔드 아키텍처는 사용자에게 직접 보이지 않는 서버 측 애플리케이션 구조와 설계를 의미한다.
데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리, 외부 서비스 통합, API 제공 등의 핵심 기능을 담당한다. 효율적인 백엔드 아키텍처는 애플리케이션의 성능, 확장성, 유지보수성, 보안성을 결정하는 중요한 요소로, 시스템 요구사항과 비즈니스 목표에 맞게 설계되어야 한다. 현대 백엔드 아키텍처는 모놀리식에서 마이크로서비스, 서버리스로 진화하고 있으며, 클라우드 기술과 컨테이너화를 활용한 분산 시스템 설계가 주류를 이루고 있다.
핵심 개념 백엔드 아키텍처는 다음과 같은 핵심 개념을 포함한다:
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend Architecture" href=https://buenhyden.github.io/posts/backend/backend-architecture/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>