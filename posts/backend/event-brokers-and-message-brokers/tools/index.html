<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tools of Event Broker and Message Broker | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Event-Brokers-and-Message-Brokers,Tools"><meta name=description content="메시지 브로커와 이벤트 브로커는 분산 시스템에서 애플리케이션 간 통신을 효율적으로 관리하는 중요한 도구이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Tools of Event Broker and Message Broker"><meta property="og:description" content="메시지 브로커와 이벤트 브로커는 분산 시스템에서 애플리케이션 간 통신을 효율적으로 관리하는 중요한 도구이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Tools of Event Broker and Message Broker"><meta name=twitter:description content="메시지 브로커와 이벤트 브로커는 분산 시스템에서 애플리케이션 간 통신을 효율적으로 관리하는 중요한 도구이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Event Brokers and Message Brokers","item":"https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/"},{"@type":"ListItem","position":4,"name":"Tools of Event Broker and Message Broker","item":"https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/>Event Brokers and Message Brokers</a></div><h1>Tools of Event Broker and Message Broker</h1><div class=post-description>메시지 브로커와 이벤트 브로커는 분산 시스템에서 애플리케이션 간 통신을 효율적으로 관리하는 중요한 도구이다.</div></header><div class=post-content><h2 id=메시지-브로커와-이벤트-브로커-비교-kafka-rabbitmq-apache-pulsar>메시지 브로커와 이벤트 브로커 비교: Kafka, RabbitMQ, Apache Pulsar<a hidden class=anchor aria-hidden=true href=#메시지-브로커와-이벤트-브로커-비교-kafka-rabbitmq-apache-pulsar>#</a></h2><p>메시지 브로커와 이벤트 브로커는 분산 시스템에서 애플리케이션 간 통신을 효율적으로 관리하는 중요한 도구이다.</p><h3 id=apache-kafka>Apache Kafka<a hidden class=anchor aria-hidden=true href=#apache-kafka>#</a></h3><h4 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h4><p>Apache Kafka는 LinkedIn에서 개발한 오픈소스 분산 이벤트 스트리밍 플랫폼으로, 대용량 실시간 데이터 처리에 특화되어 있다. 메시지를 영구 저장하고 처리하는 데 중점을 둔 설계로, 특히 빅데이터 환경에서 높은 성능을 발휘한다.</p><h4 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h4><ul><li><strong>분산 아키텍처</strong>: 수평적 확장이 가능한 분산 시스템</li><li><strong>내구성</strong>: 데이터를 디스크에 영구 저장하여 내구성 보장</li><li><strong>높은 처리량</strong>: 초당 수백만 개의 메시지를 처리 가능</li><li><strong>순서 보장</strong>: 파티션 내에서 메시지 순서 보장</li><li><strong>복제 기능</strong>: 고가용성을 위한 데이터 복제 기능 제공</li><li><strong>장기 데이터 보존</strong>: 메시지를 장기간 보존 가능</li></ul><h4 id=사용-사례>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h4><ul><li>대용량 로그 수집 및 분석</li><li>실시간 스트리밍 처리</li><li>이벤트 소싱 및 CQRS 아키텍처</li><li>실시간 모니터링 및 알림 시스템</li></ul><h3 id=rabbitmq>RabbitMQ<a hidden class=anchor aria-hidden=true href=#rabbitmq>#</a></h3><h4 id=개요-1>개요<a hidden class=anchor aria-hidden=true href=#개요-1>#</a></h4><p>RabbitMQ는 Erlang으로 구현된 전통적인 메시지 브로커로, AMQP(Advanced Message Queuing Protocol)를 구현하고 있다. 메시지 라우팅에 중점을 두며, 유연한 메시지 패턴을 제공한다.</p><h4 id=주요-특징-1>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징-1>#</a></h4><ul><li><strong>다양한 메시지 패턴</strong>: 직접 교환, 팬아웃, 토픽, 헤더 등 다양한 교환 타입 지원</li><li><strong>유연한 라우팅</strong>: 복잡한 라우팅 로직 구현 가능</li><li><strong>플러그인 아키텍처</strong>: 다양한 플러그인으로 기능 확장</li><li><strong>다중 프로토콜 지원</strong>: AMQP, MQTT, STOMP 등 여러 프로토콜 지원</li><li><strong>관리 도구</strong>: 사용하기 쉬운 웹 기반 관리 인터페이스 제공</li><li><strong>클러스터링</strong>: 고가용성을 위한 클러스터링 지원</li></ul><h4 id=사용-사례-1>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례-1>#</a></h4><ul><li>마이크로서비스 간 통신</li><li>작업 큐 및 분산 처리</li><li>비동기 처리 및 백그라운드 작업</li><li>RPC(원격 프로시저 호출) 시스템</li></ul><h3 id=apache-pulsar>Apache Pulsar<a hidden class=anchor aria-hidden=true href=#apache-pulsar>#</a></h3><h4 id=개요-2>개요<a hidden class=anchor aria-hidden=true href=#개요-2>#</a></h4><p>Apache Pulsar는 Yahoo에서 개발한 차세대 분산 메시징 및 스트리밍 플랫폼으로, Kafka와 RabbitMQ의 장점을 결합한 시스템이. 스토리지와 브로커 계층을 분리한 아키텍처가 특징이다.</p><h4 id=주요-특징-2>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징-2>#</a></h4><ul><li><strong>계층적 아키텍처</strong>: 스토리지와 브로커 계층 분리</li><li><strong>다중 테넌트</strong>: 기본적으로 다중 테넌트 지원</li><li><strong>네임스페이스와 토픽</strong>: 계층적 토픽 구조 제공</li><li><strong>지리적 복제</strong>: 여러 지역에 걸친 복제 지원</li><li><strong>정확히 한 번 처리</strong>: 메시지 처리 보장</li><li><strong>스트리밍 및 큐잉</strong>: 두 가지 모델 모두 지원</li><li><strong>함수 지원</strong>: 서버리스 함수 컴퓨팅 기능 제공</li></ul><h4 id=사용-사례-2>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례-2>#</a></h4><ul><li>하이브리드 클라우드 환경</li><li>멀티 리전 메시징 서비스</li><li>스트리밍과 큐잉이 모두 필요한 애플리케이션</li><li>실시간 데이터 분석 및 처리</li></ul><h3 id=세-플랫폼의-성능-비교>세 플랫폼의 성능 비교<a hidden class=anchor aria-hidden=true href=#세-플랫폼의-성능-비교>#</a></h3><h4 id=처리량>처리량<a hidden class=anchor aria-hidden=true href=#처리량>#</a></h4><ul><li><strong>Kafka</strong>: 매우 높은 처리량, 초당 수백만 메시지 처리 가능</li><li><strong>RabbitMQ</strong>: 중간 수준의 처리량, 초당 수십만 메시지 처리</li><li><strong>Pulsar</strong>: Kafka에 준하는 높은 처리량, 일부 시나리오에서는 더 우수한 성능</li></ul><h4 id=지연-시간>지연 시간<a hidden class=anchor aria-hidden=true href=#지연-시간>#</a></h4><ul><li><strong>Kafka</strong>: 밀리초 수준의 지연 시간</li><li><strong>RabbitMQ</strong>: 서브밀리초 수준의 지연 시간 (소규모 메시지에 최적화)</li><li><strong>Pulsar</strong>: BookKeeper를 사용하여 일관된 낮은 지연 시간 제공</li></ul><h4 id=확장성>확장성<a hidden class=anchor aria-hidden=true href=#확장성>#</a></h4><ul><li><strong>Kafka</strong>: 수평적 확장 가능, 파티션 수에 비례하여 처리량 확장</li><li><strong>RabbitMQ</strong>: 클러스터링 지원, 하지만 대규모 확장에 제한 있음</li><li><strong>Pulsar</strong>: 스토리지와 브로커를 독립적으로 확장 가능한 우수한 확장성</li></ul><h3 id=아키텍처-비교>아키텍처 비교<a hidden class=anchor aria-hidden=true href=#아키텍처-비교>#</a></h3><h4 id=메시지-저장-방식>메시지 저장 방식<a hidden class=anchor aria-hidden=true href=#메시지-저장-방식>#</a></h4><ul><li><strong>Kafka</strong>: 로그 중심 저장 방식, 파티션별로 순차적 저장</li><li><strong>RabbitMQ</strong>: 메모리 또는 디스크에 저장, 소비 후 메시지 삭제</li><li><strong>Pulsar</strong>: Apache BookKeeper를 사용한 분산 로그 저장 방식</li></ul><h4 id=메시지-소비-모델>메시지 소비 모델<a hidden class=anchor aria-hidden=true href=#메시지-소비-모델>#</a></h4><ul><li><strong>Kafka</strong>: 풀(Pull) 모델, 소비자가 브로커에서 메시지를 가져옴</li><li><strong>RabbitMQ</strong>: 푸시(Push) 모델, 브로커가 소비자에게 메시지를 전달</li><li><strong>Pulsar</strong>: 풀과 푸시 모델 모두 지원</li></ul><h4 id=토픽-구조>토픽 구조<a hidden class=anchor aria-hidden=true href=#토픽-구조>#</a></h4><ul><li><strong>Kafka</strong>: 파티셔닝된 플랫 토픽 구조</li><li><strong>RabbitMQ</strong>: 교환-큐 바인딩 구조</li><li><strong>Pulsar</strong>: 계층적 네임스페이스 및 토픽 구조</li></ul><h3 id=운영-측면-비교>운영 측면 비교<a hidden class=anchor aria-hidden=true href=#운영-측면-비교>#</a></h3><h4 id=관리-복잡성>관리 복잡성<a hidden class=anchor aria-hidden=true href=#관리-복잡성>#</a></h4><ul><li><strong>Kafka</strong>: ZooKeeper 의존성이 있으며(최신 버전에서는 KRaft로 대체), 운영이 다소 복잡</li><li><strong>RabbitMQ</strong>: 상대적으로 간단한 설정과 운영</li><li><strong>Pulsar</strong>: 다양한 컴포넌트(BookKeeper, ZooKeeper 등)로 인해 복잡한 설정</li></ul><h4 id=모니터링-및-관리-도구>모니터링 및 관리 도구<a hidden class=anchor aria-hidden=true href=#모니터링-및-관리-도구>#</a></h4><ul><li><strong>Kafka</strong>: Confluent Control Center, Kafka Manager 등 다양한 도구</li><li><strong>RabbitMQ</strong>: 내장 관리 UI와 다양한 플러그인</li><li><strong>Pulsar</strong>: Pulsar Manager, 내장 모니터링 도구</li></ul><h4 id=커뮤니티-및-생태계>커뮤니티 및 생태계<a hidden class=anchor aria-hidden=true href=#커뮤니티-및-생태계>#</a></h4><ul><li><strong>Kafka</strong>: 매우 활발한 커뮤니티와 풍부한 생태계</li><li><strong>RabbitMQ</strong>: 성숙한 커뮤니티와 안정적인 생태계</li><li><strong>Pulsar</strong>: 빠르게 성장 중인 커뮤니티, 상대적으로 신생 생태계</li></ul><h3 id=실제-사용-시-고려-사항>실제 사용 시 고려 사항<a hidden class=anchor aria-hidden=true href=#실제-사용-시-고려-사항>#</a></h3><h4 id=배포-및-유지-관리>배포 및 유지 관리<a hidden class=anchor aria-hidden=true href=#배포-및-유지-관리>#</a></h4><ul><li><strong>Kafka</strong>: 확장성이 높지만 ZooKeeper 관리 필요(KRaft 도입으로 변화 중)</li><li><strong>RabbitMQ</strong>: 간단한 배포, 상대적으로 쉬운 유지 관리</li><li><strong>Pulsar</strong>: 여러 컴포넌트로 인한 복잡한 배포와 유지 관리</li></ul><h4 id=개발자-경험>개발자 경험<a hidden class=anchor aria-hidden=true href=#개발자-경험>#</a></h4><ul><li><strong>Kafka</strong>: 강력하지만 상대적으로 학습 곡선이 있음</li><li><strong>RabbitMQ</strong>: 직관적인 모델과 간단한 학습 곡선</li><li><strong>Pulsar</strong>: 풍부한 기능으로 학습이 필요하지만 통합된 API 제공</li></ul><h4 id=비용-효율성>비용 효율성<a hidden class=anchor aria-hidden=true href=#비용-효율성>#</a></h4><ul><li><strong>Kafka</strong>: 대용량 처리에 효율적, 적은 리소스로 높은 처리량 달성</li><li><strong>RabbitMQ</strong>: 중소 규모 시스템에 적합, 적은 리소스로 시작 가능</li><li><strong>Pulsar</strong>: 스토리지-컴퓨팅 분리로 장기적 비용 효율성 높음</li></ul><h3 id=비교-표>비교 표<a hidden class=anchor aria-hidden=true href=#비교-표>#</a></h3><table><thead><tr><th>기준</th><th>Apache Kafka</th><th>RabbitMQ</th><th>Apache Pulsar</th></tr></thead><tbody><tr><td><strong>개발 회사</strong></td><td>LinkedIn (현 Apache)</td><td>Pivotal Software</td><td>Yahoo (현 Apache)</td></tr><tr><td><strong>언어</strong></td><td>Scala/Java</td><td>Erlang</td><td>Java</td></tr><tr><td><strong>프로토콜</strong></td><td>자체 프로토콜</td><td>AMQP, MQTT, STOMP</td><td>자체 프로토콜, Kafka, AMQP(지원 예정)</td></tr><tr><td><strong>아키텍처</strong></td><td>분산 로그 스트림</td><td>메시지 브로커</td><td>계층 분리형 메시지/스트림</td></tr><tr><td><strong>스토리지</strong></td><td>로그 기반 영구 저장</td><td>메모리/디스크(선택적)</td><td>BookKeeper 기반 영구 저장</td></tr><tr><td><strong>메시지 순서</strong></td><td>파티션 내 보장</td><td>큐 내 보장</td><td>파티션 내 보장</td></tr><tr><td><strong>메시지 전달 방식</strong></td><td>풀(Pull)</td><td>푸시(Push)</td><td>풀(Pull)/푸시(Push)</td></tr><tr><td><strong>처리량</strong></td><td>매우 높음</td><td>중간</td><td>매우 높음</td></tr><tr><td><strong>지연 시간</strong></td><td>낮음(밀리초)</td><td>매우 낮음(서브밀리초)</td><td>낮음(밀리초)</td></tr><tr><td><strong>확장성</strong></td><td>높음(수평적)</td><td>중간</td><td>매우 높음(분리 아키텍처)</td></tr><tr><td><strong>메시지 보존</strong></td><td>구성 가능한 장기 보존</td><td>주로 단기 보존</td><td>구성 가능한 장기 보존</td></tr><tr><td><strong>멀티 테넌시</strong></td><td>제한적</td><td>제한적</td><td>기본 내장</td></tr><tr><td><strong>지리적 복제</strong></td><td>미러메이커 도구 필요</td><td>제한적</td><td>내장 기능</td></tr><tr><td><strong>관리 UI</strong></td><td>서드파티/Confluent</td><td>내장 관리 UI</td><td>Pulsar Manager</td></tr><tr><td><strong>클라이언트</strong></td><td>다양한 언어 지원</td><td>매우 다양한 언어 지원</td><td>다양한 언어 지원</td></tr><tr><td><strong>프로그래밍 용이성</strong></td><td>중간</td><td>쉬움</td><td>중간</td></tr><tr><td><strong>운영 복잡성</strong></td><td>중간-높음</td><td>낮음-중간</td><td>높음</td></tr><tr><td><strong>사용 사례</strong></td><td>대규모 스트리밍, 로그</td><td>작업 큐, 마이크로서비스</td><td>하이브리드 스트리밍/큐잉</td></tr><tr><td><strong>커뮤니티 활성도</strong></td><td>매우 활발함</td><td>활발함</td><td>성장 중</td></tr><tr><td><strong>추가 기능</strong></td><td>Kafka Streams, Connect</td><td>플러그인 생태계</td><td>함수, SQL, 스키마 레지스트리</td></tr></tbody></table><h3 id=결론-및-선택-가이드>결론 및 선택 가이드<a hidden class=anchor aria-hidden=true href=#결론-및-선택-가이드>#</a></h3><h4 id=kafka가-적합한-경우>Kafka가 적합한 경우<a hidden class=anchor aria-hidden=true href=#kafka가-적합한-경우>#</a></h4><ul><li>대용량 데이터 스트리밍이 필요할 때</li><li>높은 처리량이 중요한 경우</li><li>이벤트 소싱 아키텍처를 구현할 때</li><li>장기간 데이터 저장이 필요한 경우</li></ul><h4 id=rabbitmq가-적합한-경우>RabbitMQ가 적합한 경우<a hidden class=anchor aria-hidden=true href=#rabbitmq가-적합한-경우>#</a></h4><ul><li>유연한 라우팅 패턴이 필요할 때</li><li>낮은 지연 시간이 중요한 경우</li><li>다양한 메시징 프로토콜을 지원해야 할 때</li><li>간단한 설정과 운영이 필요한 경우</li></ul><h4 id=pulsar가-적합한-경우>Pulsar가 적합한 경우<a hidden class=anchor aria-hidden=true href=#pulsar가-적합한-경우>#</a></h4><ul><li>스트리밍과 큐잉을 모두 지원해야 할 때</li><li>독립적인 스토리지와 컴퓨팅 확장이 필요한 경우</li><li>멀티 테넌트 환경에서 운영할 때</li><li>지리적으로 분산된 배포가 필요한 경우</li></ul><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar</h2></header><div class=entry-content><p>Apache Pulsar Apache Pulsar는 Yahoo에서 개발하고 Apache Software Foundation에서 관리하는 분산형 메시징 및 스트리밍 플랫폼이다. Pulsar는 기존의 메시지 큐와 스트리밍 시스템의 장점을 결합하여 높은 성능, 낮은 지연 시간, 그리고 강력한 내구성을 제공한다.
주요 특징 멀티 테넌시(Multi-tenancy): 다양한 팀이나 애플리케이션이 같은 클러스터를 공유할 수 있다. 스트리밍과 큐잉의 통합: 전통적인 메시징과 스트리밍 패러다임을 동시에 지원한다. 지역 간 복제(Geo-replication): 여러 데이터센터나 지역에 걸쳐 데이터를 복제할 수 있다. 계층형 스토리지: 핫 데이터는 메모리나 SSD에, 콜드 데이터는 HDD나 객체 스토리지에 저장한다. Functions와 IO 커넥터: 서버리스 컴퓨팅과 데이터 통합 기능을 제공한다. 트랜잭션 지원: 정확히 한 번(exactly-once) 메시지 처리를 보장한다. 스키마 레지스트리: 메시지의 스키마와 버전 관리를 지원한다. 아키텍처 개요 Pulsar의 아키텍처는 크게 세 가지 주요 컴포넌트로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-02-06 04:33:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar" href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/apache-pulsar/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka</h2></header><div class=entry-content><p>Kafka Apache Kafka는 LinkedIn에서 개발되어 나중에 Apache Software Foundation에 기부된 분산 이벤트 스트리밍 플랫폼입니다. Kafka는 높은 처리량, 낮은 지연 시간, 내결함성을 갖춘 실시간 데이터 파이프라인과 스트리밍 애플리케이션을 구축하기 위한 기반을 제공한다.
주요 특징 높은 처리량: 초당 수백만 개의 메시지를 처리할 수 있다. 낮은 지연 시간: 밀리초 단위의 지연 시간으로 메시지를 전달한다. 내구성: 메시지는 디스크에 저장되고 복제되어 데이터 손실을 방지한다. 확장성: 클러스터를 수평적으로 확장하여 처리량을 높일 수 있다. 내결함성: 브로커 장애 시에도 계속 작동할 수 있다. 분산 아키텍처: 여러 서버에 걸쳐 작업을 분산한다. 아키텍처 개요 Kafka의 아키텍처는 다음과 같은 주요 구성 요소로 이루어져 있다:
...</p></div><footer class=entry-footer><span title='2024-10-21 00:54:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka" href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ</h2></header><div class=entry-content><p>RabbitMQ RabbitMQ는 Erlang 언어로 작성된 오픈 소스 메시지 브로커 시스템으로, AMQP(Advanced Message Queuing Protocol)를 구현하고 있다. 2007년에 처음 출시되었으며, 현재는 VMware의 자회사인 Pivotal Software에서 관리하고 있다. RabbitMQ는 안정성, 확장성, 다양한 메시징 패턴 지원 등으로 인해 많은 기업들이 메시지 기반 아키텍처의 핵심 컴포넌트로 채택하고 있다.
주요 특징 표준 프로토콜 지원: AMQP 0-9-1을 기본으로 하며, STOMP, MQTT, HTTP 등 다양한 프로토콜을 플러그인을 통해 지원한다. 유연한 라우팅: Exchange와 바인딩을 통한 강력하고 유연한 메시지 라우팅 기능을 제공한다. 클러스터링: 높은 가용성과 처리량을 위한 내장 클러스터링 기능을 제공한다. 관리 인터페이스: 직관적인 웹 기반 관리 UI와 HTTP API를 제공한다. 플러그인 아키텍처: 기능을 확장할 수 있는 다양한 플러그인을 지원한다. 다양한 언어 지원: Java, Python, Ruby, PHP, C#, JavaScript 등 다양한 언어의 클라이언트 라이브러리를 제공한다. RabbitMQ의 주요 사용 사례 비동기 처리: 시간이 오래 걸리는 작업을 비동기적으로 처리할 수 있다. 서비스 간 통신: 마이크로서비스 아키텍처에서 서비스 간 통신 채널로 활용된다. 부하 분산: 작업을 여러 워커에게 분산시켜 시스템의 부하를 균등하게 분배한다. 이벤트 기반 아키텍처: 이벤트를 생성하고 소비하는 이벤트 기반 시스템의 기반이 된다. 데이터 스트리밍: 실시간 데이터 스트림을 처리하는 데 사용된다. RabbitMQ의 핵심 개념 AMQP 프로토콜
AMQP(Advanced Message Queuing Protocol)는 메시지 지향 미들웨어를 위한 개방형 표준 프로토콜이다. AMQP의 주요 개념을 이해하는 것은 RabbitMQ를 효과적으로 사용하기 위한 기본이다.
...</p></div><footer class=entry-footer><span title='2024-10-21 00:54:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/rabbitmq/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>