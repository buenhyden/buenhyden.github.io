<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals of Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="Fundamentals of Backend - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals of Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals of Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Backend","item":"https://buenhyden.github.io/posts/backend/fundamentals/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a></div><h1>Fundamentals of Backend</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Synchronous vs Asynchronous APIs</h2></header><div class=entry-content><p>Synchronous vs. Asynchronous APIs API 설계에서 동기식(Synchronous)과 비동기식(Asynchronous) 패턴 중 어떤 것을 선택할지는 시스템 아키텍처와 사용자 경험에 중대한 영향을 미치는 결정이다. 각 패턴은 고유한 장단점을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
동기식 API(Synchronous API) 동기식 API는 클라이언트가 요청을 보내고 서버의 응답을 받을 때까지 대기하는 방식으로 작동한다. 이는 요청-응답 주기가 완료될 때까지 클라이언트가 다른 작업을 수행하지 않는 “차단(blocking)” 방식을 의미한다.
동기식 API의 작동 원리 동기식 API의 기본 흐름은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous vs Asynchronous APIs" href=https://buenhyden.github.io/posts/backend/fundamentals/backend-basics/request-response-cycle/synchronous-vs-asynchronous-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</h2></header><div class=entry-content><p>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet 데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.
세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:
JSON은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다. XML은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다. Protobuf는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다. 선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet" href=https://buenhyden.github.io/posts/backend/fundamentals/data-exchange/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Polling</h2></header><div class=entry-content><p>Polling 폴링(Polling)은 API 통합 패턴 중 가장 기본적이면서도 널리 사용되는 방식이다. 이 패턴은 단순하지만 다양한 상황에서 효과적으로 활용될 수 있으며, 올바르게 구현하면 강력한 통합 메커니즘이 될 수 있다.
폴링의 기본 개념 폴링은 클라이언트가 주기적으로 서버에 요청을 보내 새로운 정보나 상태 변화를 확인하는 통신 방식이다. 이는 ‘끌어오기(Pull)’ 방식의 대표적인 예로, 클라이언트가 능동적으로 서버에서 정보를 요청한다.
폴링의 작동 원리 폴링의 기본 작동 과정은 다음과 같다:
클라이언트가 서버에 정보 요청을 보낸다. 서버는 현재 상태나 데이터를 응답으로 반환한다. 클라이언트는 일정 시간(폴링 간격) 동안 대기한다. 대기 시간이 끝나면 클라이언트는 다시 1단계로 돌아가 요청을 반복한다. 이 과정은 클라이언트가 중단하거나 다른 통신 방식으로 전환할 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2025-03-08 15:53:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polling" href=https://buenhyden.github.io/posts/backend/fundamentals/polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Asynchronous APIs</h2></header><div class=entry-content><p>Asynchronous APIs 비동기식 API는 현대 소프트웨어 아키텍처에서 중요한 통신 패턴으로, 특히 확장성, 성능, 그리고 복원력이 중요한 시스템에서 핵심적인 역할을 한다.
비동기식 API의 기본 원리 비동기식 API의 핵심은 요청과 응답 사이의 시간적 분리이다. 이 패턴에서는 클라이언트가 요청을 보낸 후 즉각적인 응답을 기다리지 않고, 다른 작업을 계속 진행할 수 있다. 서버는 요청을 처리한 후, 다양한 메커니즘을 통해 결과를 클라이언트에게 전달한다.
동기식 vs. 비동기식 통신 모델 동기식 API에서는 클라이언트가 요청을 보내고 서버의 처리가 완료될 때까지 차단(blocking)되는 반면, 비동기식 API에서는 클라이언트가 요청 후 즉시 제어권을 돌려받아 다른 작업을 수행할 수 있다. 서버는 백그라운드에서 요청을 처리하고, 처리가 완료되면 결과를 알린다.
...</p></div><footer class=entry-footer><span title='2025-03-06 15:43:00 +0000 UTC'>March 6, 2025</span>&nbsp;·&nbsp;58 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asynchronous APIs" href=https://buenhyden.github.io/posts/backend/fundamentals/backend-basics/request-response-cycle/asynchronous/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Synchronous APIs</h2></header><div class=entry-content><p>Synchronous APIs 동기식 API(Synchronous API)는 현대 소프트웨어 통합의 기본적인 패턴으로, 시스템 간 통신에서 가장 직관적이고 널리 사용되는 방식이다. 이 패턴은 클라이언트가 요청을 보내고 서버가 해당 요청을 처리한 후 즉시 응답을 반환하는 방식으로 작동한다. 이러한 동기식 통신의 본질은 “요청-응답” 주기가 완료될 때까지 클라이언트가 다른 작업으로 진행하지 않고 대기한다는 점이다.
동기식 API는 직관적인 요청-응답 모델, 즉각적인 피드백, 데이터 일관성 보장 등의 장점으로 인해 여전히 많은 애플리케이션에서 중요한 역할을 담당하고 있다. 특히 사용자 인터페이스와 직접 상호작용하는 API, 트랜잭션이 중요한 작업, 데이터 일관성이 중요한 조회 작업에 적합하다.
...</p></div><footer class=entry-footer><span title='2025-03-06 15:43:00 +0000 UTC'>March 6, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous APIs" href=https://buenhyden.github.io/posts/backend/fundamentals/backend-basics/request-response-cycle/synchronous/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Client-Server Pattern</h2></header><div class=entry-content><p>Client-Server Pattern 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나눈다:
서비스를 제공하는 서버 서비스를 요청하는 클라이언트.
이들은 네트워크를 통해 서로 통신하며, 각자 명확한 역할과 책임을 가지고 있다. 클라이언트-서버 패턴 (Client-Server Pattern) 클라이언트-서버 패턴은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴이다.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나뉜다:
서비스를 제공하는 서버와 서비스를 요청하는 클라이언트이다.
주요 구성 요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
클라이언트 (Client):
...</p></div><footer class=entry-footer><span title='2024-09-26 08:27:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-Server Pattern" href=https://buenhyden.github.io/posts/backend/fundamentals/backend-basics/client-server-architecture/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>