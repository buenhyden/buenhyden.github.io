<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – 분산 데이터베이스 (Distributed Database)</title><link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/</link><description>Recent content in 분산 데이터베이스 (Distributed Database) on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 06 Dec 2024 06:19:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/posts/backend/database-systems/distributed-database/index.xml" rel="self" type="application/rss+xml"/><item><title>분산 쿼리 (distributed query)</title><link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-query/</link><pubDate>Fri, 06 Dec 2024 09:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-query/</guid><description>
&lt;h2>분산 쿼리 (distributed query)&lt;/h2>&lt;p>여러 노드에 분산된 데이터를 대상으로 쿼리를 실행하고 결과를 얻는 과정.&lt;/p>
&lt;p>분산 쿼리 처리의 핵심 단계:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>쿼리 분석 및 최적화&lt;br>
사용자가 쿼리를 요청하면, 시스템은 먼저 전체 데이터베이스 시스템에서 가장 효율적인 실행 계획을 수립한다.&lt;br>
이 과정에서 다음과 같은 요소들을 고려한다:&lt;/p>
&lt;ul>
&lt;li>데이터의 물리적 위치&lt;/li>
&lt;li>네트워크 대역폭과 지연 시간&lt;/li>
&lt;li>각 노드의 처리 능력&lt;/li>
&lt;li>데이터 전송 비용&lt;br>
예를 들어, 다음과 같은 쿼리가 있다고 가정해보면,&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">customers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">order_date&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">customers&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">customers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">customer_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="p">;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 쿼리가 서울과 부산에 분산된 데이터베이스에서 실행된다면, 시스템은 다음과 같은 실행 계획을 수립할 수 있다:&lt;/p>
&lt;ol>
&lt;li>부산 노드에서 orders 테이블의 필터링을 먼저 수행&lt;/li>
&lt;li>필터링된 결과를 서울 노드로 전송&lt;/li>
&lt;li>서울 노드에서 최종 조인 연산 수행&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>병렬 처리 전략&lt;br>
분산 환경에서는 여러 노드가 동시에 작업을 수행할 수 있다.&lt;br>
주요 병렬 처리 전략은 다음과 같다:&lt;br>
1. 인트라-연산 병렬성(Intra-operation parallelism):&lt;br>
하나의 연산을 여러 노드에서 동시에 처리한다.&lt;br>
예를 들어, 테이블 스캔을 여러 노드에서 동시에 수행할 수 있다.&lt;br>
2. 인터-연산 병렬성(Inter-operation parallelism):&lt;br>
서로 다른 연산들을 파이프라인 형태로 동시에 처리한다.&lt;br>
예를 들어, 한 노드에서 조인을 수행하는 동안 다른 노드에서는 정렬을 수행할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터 전송 최적화&lt;br>
분산 환경에서 가장 큰 병목은 보통 네트워크 통신.&lt;br>
따라서 다음과 같은 최적화 기법들이 사용된다:&lt;br>
1. 세미조인(Semijoin):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 원래 쿼리
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableB&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- 세미조인을 사용한 최적화
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 1단계: TableB에서 필요한 id만 추출
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DISTINCT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- 2단계: 추출된 id와 매칭되는 TableA 데이터만 가져옴
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableA&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DISTINCT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TableB&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>데이터 복제(Replication):&lt;br>
자주 사용되는 데이터는 여러 노드에 복제하여 네트워크 전송을 최소화한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>트랜잭션 관리&lt;br>
분산 환경에서의 트랜잭션 관리는 2단계 커밋(Two-Phase Commit) 프로토콜을 주로 사용한다:&lt;br>
1. 준비 단계(Prepare Phase):&lt;br>
모든 참여 노드들에게 트랜잭션 커밋 준비를 요청한다.&lt;br>
2. 커밋 단계(Commit Phase):&lt;br>
모든 노드가 준비되었다고 응답하면 최종 커밋을 수행한다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 의사 코드로 표현한 2단계 커밋&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">two_phase_commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 준비 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ready&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">prepare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">ready&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">rollback_all&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 커밋 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">success&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">success&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">rollback_all&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>장애 처리&lt;br>
분산 환경에서는 다양한 장애가 발생할 수 있다.&lt;br>
주요 장애 처리 전략은 다음과 같다:&lt;/p>
&lt;ul>
&lt;li>노드 실패: 다른 노드로 작업을 재할당&lt;/li>
&lt;li>네트워크 지연: 타임아웃 설정 및 재시도 메커니즘 구현&lt;/li>
&lt;li>부분 실패: 트랜잭션 롤백 및 복구 절차 수행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>분산 트랜잭션 (Distributed transaction)</title><link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-transaction/</link><pubDate>Fri, 06 Dec 2024 09:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-transaction/</guid><description>
&lt;h2>분산 트랜잭션 (Distributed transaction)&lt;/h2>&lt;p>분산 트랜잭션은 두 개 이상의 데이터 저장소(특히 데이터베이스)에 걸쳐 수행되는 일련의 데이터 작업이다.&lt;br>
이는 일반적으로 네트워크로 연결된 별도의 노드에서 조정되며, 단일 서버의 여러 데이터베이스에 걸쳐 있을 수도 있다.&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ol>
&lt;li>ACID 속성 준수: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장한다.&lt;/li>
&lt;li>일관성 유지: 모든 분산 데이터베이스가 최신 정보로 동일하게 업데이트되어야 한다.&lt;/li>
&lt;li>종료 보장: 분산 트랜잭션은 완전히 실행되거나 전혀 실행되지 않아야 한다.&lt;/li>
&lt;/ol>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>데이터 일관성 보장&lt;/li>
&lt;li>복잡한 비즈니스 프로세스 지원&lt;/li>
&lt;li>시스템 신뢰성 향상&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>성능 오버헤드 발생 가능&lt;/li>
&lt;li>구현 및 관리의 복잡성&lt;/li>
&lt;li>네트워크 지연으로 인한 성능 저하 가능성&lt;/li>
&lt;/ul>
&lt;h3>분산 트랜잭션 처리 방식&lt;/h3>&lt;h4>2단계 커밋 프로토콜 (Two-Phase Commit Protocol, 2PC)&lt;/h4>&lt;p>가장 널리 사용되는 방식으로, 다음 두 단계로 구성된다:&lt;/p>
&lt;ol>
&lt;li>준비 단계: 트랜잭션 코디네이터가 모든 참여 노드에 커밋 준비 요청을 보낸다.&lt;/li>
&lt;li>커밋 단계: 모든 노드가 준비되면 코디네이터가 커밋 요청을 보내고, 그렇지 않으면 롤백을 요청한다.&lt;/li>
&lt;/ol>
&lt;p>장점은 데이터 일관성을 완벽하게 보장한다는 것이지만, 단점은 모든 노드가 응답할 때까지 기다려야 하므로 성능이 저하될 수 있다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TransactionCoordinator&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">execute_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 1단계: 준비 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prepare_responses&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">prepare&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">response&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s2">&amp;#34;READY&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">abort_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;Transaction Failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prepare_responses&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2단계: 커밋 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">all&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">response&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;READY&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">response&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">prepare_responses&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;Transaction Committed&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>3단계 커밋 프로토콜 (Three-Phase Commit Protocol, 3PC)&lt;/h4>&lt;p>2PC의 확장 버전으로, 추가적인 &amp;ldquo;사전 커밋&amp;rdquo; 단계를 포함하여 일부 실패 시나리오를 개선한다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ThreePhaseCoordinator&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">execute_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 1단계: 투표 요청&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">can_commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">abort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2단계: 사전 커밋&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pre_commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">abort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 3단계: 최종 커밋&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">do_commit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>보상 트랜잭션 (Compensating Transactions)&lt;/h4>&lt;p>장기 실행 트랜잭션의 경우, 각 단계를 개별적으로 커밋하고 실패 시 보상 트랜잭션을 실행하여 변경사항을 취소한다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">CompensatingTransaction&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">execute_with_compensation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">steps&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">executed_steps&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">step&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">steps&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">step&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">executed_steps&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">step&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">except&lt;/span> &lt;span class="ne">Exception&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 문제 발생 시 역순으로 보상 트랜잭션 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">step&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">reversed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">executed_steps&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">step&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">compensate&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>분산 타임스탬프 기법&lt;/h4>&lt;p>트랜잭션에 고유한 타임스탬프를 부여하여 순서를 보장한다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DistributedTimestampManager&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">logical_clock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">get_timestamp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node_id&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">logical_clock&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">logical_clock&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">_&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">node_id&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">order_transactions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transactions&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">sorted&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transactions&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>분산 락킹 메커니즘&lt;/h4>&lt;p>데이터 일관성을 보장하기 위해 분산 환경에서의 락 관리가 필요하다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DistributedLockManager&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">acquire_locks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">resources&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">locked_resources&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">resource&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">resources&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">try_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resource&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">locked_resources&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resource&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">release_locks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">locked_resources&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">except&lt;/span> &lt;span class="ne">Exception&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">release_locks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">locked_resources&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="n">e&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>고려사항&lt;/h3>&lt;ol>
&lt;li>
&lt;p>데드락 감지 및 해결&lt;br>
분산 환경에서의 데드락은 더욱 복잡하다.&lt;br>
전역적인 대기 그래프를 유지하고 주기적으로 검사해야 한다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DeadlockDetector&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">detect_deadlocks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">wait_for_graph&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">set&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">set&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">has_cycle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">neighbor&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">wait_for_graph&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">has_cycle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">neighbor&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">wait_for_graph&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">has_cycle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>복구 관리 장애 발생 시 일관된 상태로 복구하기 위한 메커니즘이 필요하다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">RecoveryManager&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">recover_from_failure&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">log_records&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># REDO 단계: 커밋된 트랜잭션 재실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">committed_transactions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get_committed_transactions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">log_records&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">committed_transactions&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">redo_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># UNDO 단계: 미완료 트랜잭션 롤백&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">incomplete_transactions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get_incomplete_transactions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">log_records&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">transaction&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">incomplete_transactions&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">undo_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">transaction&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>성능 최적화 트랜잭션 처리 성능을 향상시키기 위한 여러 기법들:&lt;/p>
&lt;ul>
&lt;li>트랜잭션 분할: 큰 트랜잭션을 작은 단위로 분할&lt;/li>
&lt;li>비동기 복제: 성능을 위해 일부 노드는 비동기적으로 업데이트&lt;/li>
&lt;li>캐싱 전략: 자주 사용되는 데이터는 로컬에 캐시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>분산 트랜잭션 처리의 과제&lt;/h3>&lt;ol>
&lt;li>네트워크 파티션 처리&lt;/li>
&lt;li>노드 장애 대응&lt;/li>
&lt;li>데이터 일관성 유지&lt;/li>
&lt;li>성능 최적화&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>데이터베이스 클러스터링(Database Clustering)</title><link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/database-clustering/</link><pubDate>Tue, 03 Dec 2024 06:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/database-clustering/</guid><description>
&lt;h2>데이터베이스 클러스터링(Database Clustering)&lt;/h2>&lt;p>하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술.&lt;br>
이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다..&lt;/p>
&lt;p>데이터베이스 클러스터링(Database Clustering)은 하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술이다.
이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다.&lt;/p>
&lt;h2>클러스터링의 목적&lt;/h2>&lt;ol>
&lt;li>고가용성(High Availability) 확보: 하나의 서버가 실패하더라도 다른 서버가 작업을 계속할 수 있어 서비스 중단을 최소화한다.&lt;/li>
&lt;li>부하 분산(Load Balancing): 여러 서버로 작업을 분산시켜 전체적인 성능을 향상시킵니다[3].&lt;/li>
&lt;li>확장성(Scalability) 개선: 필요에 따라 서버를 추가하여 시스템의 처리 능력을 증가시킬 수 있습니다[2].&lt;/li>
&lt;/ol>
&lt;p>구성 방식:&lt;br>
데이터베이스 클러스터링은 주로 두 가지 방식으로 구성된다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Active-Active 클러스터링&lt;br>
모든 데이터베이스 서버가 동시에 활성 상태로 운영된다.&lt;br>
장점:&lt;/p>
&lt;ul>
&lt;li>서버 한 대가 다운되어도 나머지 서버들이 계속 작동하여 무중단 서비스가 가능하다.&lt;/li>
&lt;li>CPU와 메모리 사용률을 최적화할 수 있어 전체적인 성능이 향상된다.&lt;br>
단점:&lt;/li>
&lt;li>여러 서버가 하나의 스토리지를 공유하므로 병목 현상이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Active-Standby 클러스터링
하나의 서버는 Active(작동) 상태로, 나머지 서버는 Standby(대기) 상태로 운영된다.
장점:&lt;/p>
&lt;ul>
&lt;li>운영 비용을 절감할 수 있다.&lt;/li>
&lt;li>Active 서버에 문제가 발생하면 Standby 서버가 자동으로 Active 상태로 전환된다.
단점:&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Standby 서버를 Active 상태로 전환하는 데 시간이 소요될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>작동 방식:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>데이터 동기화:&lt;br>
클러스터 내의 모든 서버는 동일한 데이터를 유지해야 한다.&lt;br>
이를 위해 동기 또는 비동기 방식의 데이터 복제가 이루어진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>부하 분산:&lt;br>
로드 밸런서를 통해 클라이언트의 요청을 여러 서버로 분산시킨다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>장애 감지 및 복구:&lt;br>
서버의 상태를 지속적으로 모니터링하고, 장애 발생 시 자동으로 다른 서버로 작업을 전환한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>고가용성: 단일 장애점(Single Point of Failure)을 제거하여 시스템의 안정성을 높인다.&lt;/li>
&lt;li>성능 향상: 여러 서버로 부하를 분산시켜 전체적인 처리 능력이 향상된다.&lt;/li>
&lt;li>확장성: 필요에 따라 서버를 추가하여 시스템을 확장할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>복잡성: 여러 서버를 관리해야 하므로 시스템 구성과 유지보수가 복잡해질 수 있다.&lt;/li>
&lt;li>비용: 여러 대의 서버와 관련 인프라를 구축해야 하므로 초기 비용이 높을 수 있다.&lt;/li>
&lt;li>데이터 일관성: 여러 서버 간의 데이터 동기화에 따른 지연이 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>샤딩 (sharding)</title><link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/sharding/</link><pubDate>Tue, 03 Dec 2024 06:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/sharding/</guid><description>
&lt;h2>샤딩 (sharding)&lt;/h2>&lt;p>대규모 데이터베이스 시스템에서 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 기술.&lt;br>
각각의 분할된 데이터 조각을 &amp;lsquo;샤드(shard)&amp;lsquo;라고 부른다.&lt;br>
이 기술은 데이터베이스의 성능, 확장성, 가용성을 향상시키는 데 중요한 역할을 한다.&lt;/p>
&lt;p>예를 들어 전자상거래 사이트의 사용자 데이터를 지역별로 나누어 관리한다고 가정해보자.&lt;br>
서울 지역 사용자의 데이터는 샤드 A에, 부산 지역 사용자의 데이터는 샤드 B에 저장하는 식. 이렇게 하면 각 지역의 서버가 해당 지역 사용자의 데이터만 처리하면 되므로 시스템 부하를 분산할 수 있다.&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ol>
&lt;li>수평 분할: 샤딩은 데이터를 동일한 스키마를 가진 여러 개의 작은 데이터베이스(샤드)로 나눈다.&lt;/li>
&lt;li>분산 저장: 각 샤드는 독립적인 서버에 저장되어 운영된다.&lt;/li>
&lt;li>샤드 키: 데이터를 분할하고 분산 저장하는 기준이 되는 키를 사용한다.
&lt;ul>
&lt;li>사용자 ID, 지역 코드, 시간대 등이 샤딩 키로 자주 사용된다.&lt;/li>
&lt;li>이 키의 선택은 시스템의 성능과 확장성에 직접적인 영향을 미친다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>라우팅: 샤드 서버에는 각 샤드에 작업을 분배하는 라우팅 기능이 있다.&lt;/li>
&lt;/ol>
&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>성능 향상: 데이터를 여러 서버에 분산함으로써 처리 속도가 향상된다.&lt;/li>
&lt;li>확장성: 데이터 양이 증가해도 새로운 샤드를 추가하여 시스템을 확장할 수 있다.&lt;/li>
&lt;li>가용성: 한 샤드에 문제가 발생해도 다른 샤드는 정상 작동하여 전체 시스템의 가용성이 향상된다.&lt;/li>
&lt;li>부하 분산: 데이터와 트래픽이 여러 샤드에 균등하게 분산되어 처리된다.&lt;/li>
&lt;li>비용 효율성: 고성능 하드웨어 대신 여러 대의 저렴한 서버를 사용할 수 있다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>복잡성: 데이터가 여러 곳에 분산되어 있어 관리와 조회가 복잡해질 수 있다.&lt;/li>
&lt;li>데이터 일관성: 여러 샤드에 걸친 데이터의 일관성을 유지하기 어려울 수 있다.&lt;/li>
&lt;li>조인 연산의 어려움: 여러 샤드에 걸친 데이터를 조인하는 것이 어렵다.&lt;/li>
&lt;li>데이터 불균형: 특정 샤드에 데이터가 집중될 경우 성능 저하가 발생할 수 있다.&lt;/li>
&lt;li>관리 복잡성: 여러 샤드를 관리하고 모니터링하는 것이 단일 데이터베이스보다 복잡하다.&lt;/li>
&lt;/ol>
&lt;h3>샤딩 방식&lt;/h3>&lt;ol>
&lt;li>
&lt;p>범위 기반 샤딩 (Range Based Sharding)&lt;br>
범위 기반 샤딩은 데이터를 연속된 범위로 나누어 각 샤드에 할당하는 방식.&lt;br>
예를 들어, 고객 ID가 1-1000번까지는 첫 번째 샤드에, 1001-2000번까지는 두 번째 샤드에 저장하는 식.&lt;/p>
&lt;p>이 방식은 구현이 비교적 간단하고 이해하기 쉽다.&lt;br>
특정 범위의 데이터가 다른 범위보다 더 자주 접근되는 경우, 해당 샤드에 과도한 부하가 발생할 수 있다.&lt;br>
예를 들어 최근에 가입한 사용자들의 활동이 더 많다면, 높은 ID 범위를 담당하는 샤드에 트래픽이 집중될 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>해시 기반 샤딩 (Hash Based Sharding)&lt;br>
해시 기반 샤딩은 샤딩 키를 해시 함수에 통과시켜 나온 값을 기준으로 데이터를 분산하는 방식.&lt;/p>
&lt;p>해시 함수는 입력값을 고르게 분산시키는 특성이 있어, 데이터를 여러 샤드에 균등하게 분배할 수 있다.&lt;br>
예를 들어, 사용자 ID를 해시 함수에 넣어 나온 값을 샤드 수로 나눈 나머지를 기준으로 샤드를 결정할 수 있다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">shard_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">number_of_shards&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 방식의 장점은 데이터가 고르게 분산된다.&lt;/p>
&lt;p>하지만 샤드의 수를 변경하면 대부분의 데이터가 재배치되어야 하는 단점이 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>디렉토리 기반 샤딩 (Directory Based Sharding)&lt;br>
디렉토리 기반 샤딩은 별도의 조회 테이블을 사용하여 각 데이터가 어느 샤드에 있는지를 추적하는 방식.&lt;br>
이 방식은 가장 유연한 샤딩 방식으로, 동적으로 샤드 매핑을 변경할 수 있다.&lt;/p>
&lt;p>예를 들어, 다음과 같은 매핑 테이블을 유지할 수 있습니다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">shard_directory&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">key_range&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">50&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">shard_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">shard_location&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">VARCHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 방식의 장점은 매우 세밀한 제어가 가능하다.&lt;br>
특정 데이터를 다른 샤드로 이동시키기 쉽고, 샤드 간의 데이터 균형을 동적으로 조정할 수 있다.&lt;/p>
&lt;p>하지만 조회 테이블이 단일 실패 지점이 될 수 있으며, 모든 쿼리가 이 테이블을 먼저 조회해야 하므로 약간의 성능 오버헤드가 발생한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>지리적 샤딩 (Geographic Sharding)&lt;br>
지리적 샤딩은 사용자의 물리적 위치를 기준으로 데이터를 분산하는 방식.&lt;br>
예를 들어, 아시아 지역 사용자의 데이터는 아시아에 위치한 서버에, 유럽 사용자의 데이터는 유럽 서버에 저장하는 식.&lt;/p>
&lt;p>이 방식의 큰 장점은 사용자와 가까운 곳에서 데이터를 제공할 수 있어 지연 시간을 크게 줄일 수 있다는 것.&lt;br>
또한 데이터 관련 규제(예: GDPR)를 준수하기 쉽다.&lt;/p>
&lt;p>하지만 사용자가 여행을 가는 등 위치가 변경될 때 성능이 저하될 수 있으며, 지역 간 데이터 동기화가 필요한 경우 복잡성이 증가한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>기능 기반 샤딩 (Feature Based Sharding)&lt;br>
기능 기반 샤딩은 애플리케이션의 특정 기능이나 모듈별로 데이터를 분리하는 방식.&lt;br>
예를 들어, 전자상거래 플랫폼에서 주문 관련 데이터는 한 샤드 그룹에, 제품 카탈로그는 다른 샤드 그룹에 저장하는 식.&lt;/p>
&lt;p>이 방식은 각 기능별로 최적화된 데이터베이스 구성을 사용할 수 있다.&lt;br>
또한 특정 기능의 트래픽 증가가 다른 기능에 영향을 미치지 않는다.&lt;/p>
&lt;p>하지만 기능 간의 데이터 조인이 필요한 경우 복잡성이 크게 증가할 수 있다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>샤딩 방식을 선택할 때는 다음과 같은 요소들을 고려해야 한다.&lt;/p>
&lt;ul>
&lt;li>데이터의 성격과 접근 패턴&lt;/li>
&lt;li>확장성 요구사항&lt;/li>
&lt;li>데이터 일관성 요구사항&lt;/li>
&lt;li>운영 복잡성 관리 능력&lt;/li>
&lt;li>애플리케이션의 쿼리 패턴&lt;/li>
&lt;li>데이터 지역성 요구사항&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item></channel></rss>