<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend Performance Best Practices | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="Backend Performance Best Practices - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/best-practices/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/best-practices/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/best-practices/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/best-practices/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend Performance Best Practices"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend Performance Best Practices"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Backend Performance Best Practices","item":"https://buenhyden.github.io/posts/backend/best-practices/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a></div><h1>Backend Performance Best Practices</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Security</h2></header><div class=entry-content><p>Security Maintaining Updated Dependencies 의존성 관리는 백엔드 시스템의 보안과 성능을 모두 좌우하는 핵심 요소이다. 최신 버전의 라이브러리와 패키지는 보안 취약점 해결뿐만 아니라 성능 최적화가 적용된 경우가 많다.
의존성 관리의 주요 측면 성능 영향 오래된 패키지는 최신 버전보다 효율성이 떨어지는 경우가 많다. 개발자들은 지속적으로 코드를 개선하고 최적화하기 때문에, 최신 버전일수록 더 나은 성능을 제공하는 경향이 있다. 예를 들어, Node.js 자체의 주요 버전 업데이트는 V8 엔진 개선을 통해 상당한 성능 향상을 가져온다.
...</p></div><footer class=entry-footer><span title='2025-02-13 01:40:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Security" href=https://buenhyden.github.io/posts/backend/best-practices/security/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Performance Testing</h2></header><div class=entry-content><p>Performance Testing 성능 테스팅의 기본 원리 성능 테스팅은 시스템이 예상된 부하 조건에서 어떻게 작동하는지 측정하고 평가하는 과정이다. 이는 단순히 ‘시스템이 작동하는가?‘를 넘어 ‘얼마나 효율적으로 작동하는가?‘를 확인하는 것이다.
성능 테스팅의 주요 목적 성능 병목 현상 식별: 시스템의 어떤 부분이 전체 성능을 저하시키는지 파악한다. 확장성 평가: 시스템이 증가하는 부하에 어떻게 대응하는지 측정한다. 사용자 경험 예측: 실제 환경에서 사용자가 경험할 성능 수준을 추정한다. 최적화 효과 검증: 성능 개선 작업의 효과를 객관적으로 평가한다. 안정성 확인: 지속적인 부하 하에서 시스템의 안정성을 확인한다. 성능 테스팅의 주요 유형 백엔드 성능을 평가하기 위해 다양한 유형의 테스트가 필요하다. 각 테스트는 특정 측면에 초점을 맞추고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:40:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Performance Testing" href=https://buenhyden.github.io/posts/backend/best-practices/performance-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network</h2></header><div class=entry-content><p>Network 네트워크 최적화는 백엔드 성능을 향상시키는 핵심 요소 중 하나이다. 사용자 경험에 직접적인 영향을 미치는 지연 시간과 처리량을 개선함으로써 웹 애플리케이션의 전반적인 성능을 크게 향상시킬 수 있다.
Hosting Backend Close to Users to Minimize Network Latency 네트워크 지연 시간은 데이터가 출발지에서 목적지까지 이동하는 데 걸리는 시간을 의미한다. 물리적 거리는 이 지연 시간에 직접적인 영향을 미치는 요소이다.
지연 시간의 영향 지연 시간이 사용자 경험에 미치는 영향은 상당하다:
1초 이상의 로딩 시간: 사용자의 사고 흐름 중단 3초 이상의 로딩 시간: 이탈률 40% 증가 5초 이상의 로딩 시간: 전환율 70% 감소 지역 분산 배포 전략 사용자와 서버 간의 물리적 거리를 줄이기 위한 전략은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2025-02-12 01:39:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network" href=https://buenhyden.github.io/posts/backend/best-practices/network/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Optimize API Response</h2></header><div class=entry-content><p>Optimize API Response API 응답 최적화는 현대 웹 애플리케이션의 성능, 사용자 경험 및 자원 효율성을 크게 향상시키는 핵심 요소이다.
Enforcing Reasonable Payload Size Limits 페이로드 크기는 API 성능에 직접적인 영향을 미친다. 대용량 데이터 전송은 네트워크 대역폭을 소모하고 서버 처리 시간을 증가시킨다.
페이로드 제한의 중요성 네트워크 효율성: 작은 페이로드는 더 빠른 전송 시간을 의미한다. 연구에 따르면 모바일 환경에서 5MB 이상의 페이로드는 평균 응답 시간을 3-4초 증가시킨다. 서버 리소스 관리: 대형 페이로드를 처리할 때 서버의 메모리 사용량이 급증할 수 있다. 이는 특히 동시 요청이 많을 때 서버 과부하로 이어질 수 있다. 데이터베이스 효율성: 대형 데이터를 저장하고 검색하는 것은 데이터베이스 성능에 부담을 준다. 구현 전략 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Express.js에서 페이로드 크기 제한 설정 예제 const express = require('express'); const app = express(); // JSON 페이로드 크기를 1MB로 제한 app.use(express.json({ limit: '1mb' })); // 폼 데이터 크기를 5MB로 제한 app.use(express.urlencoded({ extended: true, limit: '5mb' })); // 특정 라우트에 대해 다른 제한 적용 app.post('/upload-profile-image', express.json({ limit: '2mb' }), (req, res) => { // 프로필 이미지 처리 로직 }); 모범 사례 컨텐츠 유형별 제한: 이미지, 비디오, 텍스트 데이터에 대해 각기 다른 제한을 설정한다. 클라이언트 측 검증: 서버에 보내기 전에 클라이언트에서 파일 크기를 확인한다. 점진적 업로드: 대용량 파일은 청크(chunk) 단위로 분할하여 전송한다. 압축 권장: 가능한 경우 클라이언트 측에서 데이터 압축을 권장한다. Enabling Compression for Responses 데이터 압축은 전송되는 바이트 수를 감소시켜 네트워크 대역폭을 절약하고 응답 시간을 단축시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:39:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Optimize API Response" href=https://buenhyden.github.io/posts/backend/best-practices/optimize-api-response/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Monitoring and Logging</h2></header><div class=entry-content><p>Monitoring and Logging 모니터링과 로깅은 현대 백엔드 시스템의 건강 상태를 파악하고 성능을 최적화하는 데 필수적인 요소이다. 이러한 도구와 전략을 통해 시스템의 병목 현상을 식별하고, 문제가 발생하기 전에 예방적 조치를 취할 수 있으며, 사용자 경험을 크게 향상시킬 수 있다.
모니터링의 기본 원칙과 중요성 모니터링은 백엔드 시스템의 상태와 성능을 실시간으로 관찰하는 과정이다. 효과적인 모니터링은 다음과 같은 이점을 제공합니다:
핵심 모니터링 지표 리소스 사용률: CPU, 메모리, 디스크 I/O, 네트워크 대역폭 응답 시간: 요청 처리에 걸리는 시간 처리량: 초당 처리되는 요청 수 오류율: 실패한 요청의 비율 포화도: 리소스가 얼마나 가득 차 있는지를 나타내는 지표 가용성: 시스템이 정상적으로 작동하는 시간의 비율 RED 방법론 RED 방법론은 서비스 모니터링을 위한 간단하고 효과적인 접근 방식이다:
...</p></div><footer class=entry-footer><span title='2025-02-12 01:37:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monitoring and Logging" href=https://buenhyden.github.io/posts/backend/best-practices/monitoring-and-logging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Balancing and Scaling</h2></header><div class=entry-content><p>Load Balancing and Scaling 로드 밸런싱은 네트워크 트래픽을 여러 서버에 효율적으로 분산시켜 시스템의 안정성, 가용성, 응답 시간을 개선하는 기술이다. 웹 애플리케이션의 규모가 커질수록 단일 서버로는 모든 요청을 처리하기 어려워진다. 이때 로드 밸런서가 ‘교통 경찰’처럼 작동하여 들어오는 요청을 여러 서버로 분산시켜 과부하를 방지한다.
로드 밸런싱 알고리즘 로드 밸런싱의 효율성은 사용하는 알고리즘에 크게 좌우된다:
라운드 로빈 (Round Robin): 가장 단순한 방식으로, 순차적으로 각 서버에 요청을 배분한다. 모든 서버가 동일한 사양일 때 효과적이다. 최소 연결 (Least Connection): 현재 가장 적은 연결을 처리 중인 서버에 새 요청을 할당한다. 요청 처리 시간이 다양할 때 유용하다. IP 해시 (IP Hash): 사용자의 IP 주소를 기반으로 특정 서버에 요청을 라우팅한다. 세션 지속성이 필요할 때 적합하다. 가중치 기반 (Weighted): 서버의 처리 능력에 따라 가중치를 부여하여 더 강력한 서버가 더 많은 요청을 처리하도록 한다. 응답 시간 기반 (Response Time): 응답 시간이 가장 빠른 서버에 요청을 보낸다. 실시간 성능 모니터링이 필요하다. 스케일링 전략: 수직적 vs. 수평적 스케일링은 시스템의 용량을 증가시키는 방법으로, 두 가지 주요 접근 방식이 있다:
...</p></div><footer class=entry-footer><span title='2025-02-12 01:36:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Balancing and Scaling" href=https://buenhyden.github.io/posts/backend/best-practices/load-balancing-and-scaling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Databases</h2></header><div class=entry-content><p>Databases Connection Pooling: Reducing Connection Overhead 커넥션 풀링의 개념과 중요성 데이터베이스 연결은 상당한 리소스를 소모하는 작업이다.
각 연결을 설정할 때마다 다음과 같은 과정이 필요하다:
네트워크 소켓 생성 데이터베이스 서버와의 TCP 핸드셰이크 사용자 인증 및 권한 확인 세션 변수 설정 트랜잭션 상태 초기화 이러한 과정은 수 밀리초에서 수백 밀리초까지 시간이 소요될 수 있다. 따라서 사용자 요청마다 새로운 연결을 생성하고 종료하는 것은 상당한 오버헤드를 발생시킨다.
커넥션 풀링은 이러한 문제를 해결하기 위한 기술로, 미리 여러 데이터베이스 연결을 생성하고 이를 풀(pool)에 보관하여 필요할 때 재사용한다. 이는 새로운 연결 설정에 드는 시간과 리소스를 크게 절약한다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:35:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Databases" href=https://buenhyden.github.io/posts/backend/best-practices/databases/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Optimization</h2></header><div class=entry-content><p>Code Optimization 백엔드 성능 최적화는 현대 웹 애플리케이션 개발에서 필수적인 요소이다. 사용자 경험을 향상시키고, 서버 자원을 효율적으로 활용하며, 확장성을 보장하기 위해서는 다양한 코드 최적화 기법을 적절히 적용해야 한다.
Streaming of Large Requests/Responses 스트리밍의 중요성 대용량 데이터를 처리할 때 전통적인 방식은 전체 데이터를 메모리에 로드한 후 처리하는 것이다.
이 방식은 다음과 같은 문제점을 갖고 있다:
메모리 사용량 급증으로 인한 서버 부하 증가 응답 지연 시간 증가 타임아웃 발생 가능성 클라이언트 대기 시간 증가 스트리밍 방식은 데이터를 작은 청크(chunk)로 나누어 순차적으로 처리함으로써 이러한 문제를 해결한다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:33:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Optimization" href=https://buenhyden.github.io/posts/backend/best-practices/code-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Asynchronism</h2></header><div class=entry-content><p>Asynchronism 백엔드 시스템의 성능을 최적화하는 것은 현대 애플리케이션 개발에서 핵심적인 과제이다. 특히 비동기 처리(Asynchronism)는 시스템의 응답성과 확장성을 크게 향상시킬 수 있는 강력한 패러다임이다.
Offloading Heavy Tasks to Background Jobs or Queues 기본 개념 백그라운드 작업 처리는 시간이 오래 걸리거나 리소스를 많이 소모하는 작업을 주 실행 스레드에서 분리하여 별도의 프로세스나 스레드에서 비동기적으로 실행하는 기법이다. 이를 통해 사용자 요청에 대한 응답 시간을 크게 개선할 수 있다.
구현 방법 작업 큐 시스템 활용 작업 큐 시스템은 백그라운드 작업 처리의 가장 일반적인 구현 방법이다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:32:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asynchronism" href=https://buenhyden.github.io/posts/backend/best-practices/asynchronism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caching</h2></header><div class=entry-content><p>Caching Utilizing Caching Mechanisms 캐싱은 데이터 접근 시간을 크게 단축시켜주는 기술이다.
HTTP 캐싱 HTTP 캐싱은 웹 브라우저와 서버 사이에서 이루어지는 가장 기본적인 캐싱 형태이다.
Cache-Control: max-age=3600, public ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4" Last-Modified: Wed, 03 Apr 2025 13:22:05 GMT 위와 같은 HTTP 헤더를 통해 캐싱 정책을 제어할 수 있다. max-age는 리소스가 유효한 시간(초)을 지정하며, public은 모든 캐시가 응답을 저장할 수 있다는 의미이다. ETag와 Last-Modified는 리소스의 변경 여부를 판단하는 데 사용된다.
서버 사이드 캐싱 서버 측에서 이루어지는 캐싱으로, 요청 처리 시간을 단축시켜 준다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:32:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching" href=https://buenhyden.github.io/posts/backend/best-practices/caching/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>