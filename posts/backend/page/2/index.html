<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content="Backend"><meta name=description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>Backend</h1><div class=post-description>웹 애플리케이션이나 소프트웨어의 서버 측 개발을 담당하는 영역</div></header><div class=post-content><h2 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h2><p>백엔드는 사용자가 직접 보거나 상호작용하지 않는 서버 측(Server-side) 기술과 인프라를 의미한다.<br>웹사이트나 애플리케이션의 데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리 등을 담당하는 시스템의 뒷단이라고 할 수 있다.<br>프런트엔드가 사용자 인터페이스를 제공한다면, 백엔드는 이러한 인터페이스가 실제로 작동하는 데 필요한 모든 로직과 데이터 처리를 담당한다.</p><h3 id=백엔드의-정의와-역할>백엔드의 정의와 역할<a hidden class=anchor aria-hidden=true href=#백엔드의-정의와-역할>#</a></h3><p>백엔드는 다음과 같은 주요 역할을 수행한다:</p><ol><li>서버 관리: 웹 서버를 설정하고 관리하여 클라이언트 요청을 처리한다.</li><li>데이터 처리: 데이터베이스와 상호작용하여 데이터를 저장, 검색, 관리한다.</li><li>비즈니스 로직 구현: 애플리케이션의 핵심 기능과 프로세스를 개발한다.</li><li>API 개발: 프론트엔드와 백엔드 간의 통신을 위한 API를 설계하고 구현한다.</li><li>보안 관리: 사용자 인증, 데이터 암호화 등 보안 관련 기능을 구현한다.</li></ol><h3 id=백엔드가-포함하는-주요-분야>백엔드가 포함하는 주요 분야<a hidden class=anchor aria-hidden=true href=#백엔드가-포함하는-주요-분야>#</a></h3><ol><li>서버 사이드 프로그래밍: Java, Python, Ruby, PHP, Node.js 등의 언어를 사용하여 서버 로직을 개발한다.</li><li>데이터베이스 관리: MySQL, PostgreSQL, MongoDB 등의 데이터베이스 시스템을 사용하여 데이터를 관리한다.</li><li>웹 서버 관리: Apache, Nginx 등의 웹 서버를 설정하고 최적화한다.</li><li>클라우드 컴퓨팅: AWS, Azure, Google Cloud 등의 클라우드 플랫폼을 활용하여 서비스를 배포하고 관리한다.</li><li>시스템 아키텍처 설계: 확장 가능하고 효율적인 시스템 구조를 설계한다.</li><li>DevOps: 지속적 통합 및 배포(CI/CD) 파이프라인을 구축하고 관리한다.</li><li>성능 최적화: 대규모 트래픽을 처리할 수 있도록 시스템을 최적화한다.</li></ol><hr><h2 id=roadmap>Roadmap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h2><h2 id=roadmap---backend><a href=https://roadmap.sh/backend>Roadmap - Backend</a><a hidden class=anchor aria-hidden=true href=#roadmap---backend>#</a></h2><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSL and TLS</h2></header><div class=entry-content><p>SSL(Secure Sockets Layer)과 TLS(Transport Layer Security) 인터넷 상에서 데이터를 안전하게 전송하기 위한 암호화 프로토콜.
TLS는 SSL의 후속 버전으로, 보안성과 성능이 향상되었다.
SSL의 역사와 개념 SSL은 1995년 Netscape에 의해 개발되었다.
주요 목적은 웹 브라우징 시 데이터의 기밀성과 무결성을 보장하는 것.
SSL은 다음과 같은 버전으로 발전했다:
SSL 1.0 (내부적으로만 사용) SSL 2.0 (1995년 공개) SSL 3.0 (1996년 공개) TLS의 등장과 발전 TLS는 SSL 3.0을 기반으로 1999년 IETF(Internet Engineering Task Force)에 의해 개발되었다.
TLS는 SSL의 보안 취약점을 개선하고 더 강력한 암호화 알고리즘을 도입했다.
TLS의 주요 버전은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-18 08:48:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SSL and TLS" href=https://buenhyden.github.io/posts/backend/web-security/ssl-and-tls/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Server</h2></header><div class=entry-content><p>Web Server 인터넷을 통해 클라이언트의 요청을 처리하고 웹 콘텐츠를 제공하는 소프트웨어와 하드웨어 시스템.
웹 서버는 HTTP 프로토콜을 사용하여 클라이언트(주로 웹 브라우저)의 요청을 받아 HTML 문서, 이미지, CSS, JavaScript 등의 웹 리소스를 응답으로 전송한다.
동작 방식 클라이언트 요청 수신 웹 브라우저가 특정 URL로 요청을 보내면, 웹 서버는 이 요청을 받아들인다. 예를 들어, 사용자가 www.example.com을 방문하면, 해당 도메인의 웹 서버로 HTTP 요청이 전송된다. 요청 처리 서버는 받은 요청을 분석하여 클라이언트가 어떤 리소스를 요청했는지 파악한다. 이때 URL, HTTP 메소드(GET, POST 등), 헤더 정보 등을 확인한다. 리소스 검색 요청된 리소스를 서버의 파일 시스템에서 찾거나, 필요한 경우 동적으로 생성한다. 예를 들어, HTML 파일을 찾거나 데이터베이스에서 정보를 조회한다. 응답 생성 및 전송 찾은 리소스를 HTTP 응답 형태로 변환하여 클라이언트에게 전송한다. 응답에는 상태 코드, 헤더 정보, 실제 컨텐츠가 포함된다. 클라이언트의 웹 브라우저는 받은 데이터를 해석하여 사용자에게 표시한다. 웹 서버의 특징과 기능 요청 처리: HTTP/HTTPS를 통한 클라이언트 요청 처리 콘텐츠 저장: 웹사이트 파일, 문서, 이미지 등 리소스 저장 및 제공 보안: 암호화, 접근 제어 등 보안 기능 제공 확장성: 트래픽 변화에 따른 확장 가능 데이터 보호: 중요 웹사이트 데이터 저장 및 보호 대역폭 제어: 네트워크 트래픽 조절 서버 사이드 스크립팅: 동적 웹페이지 생성 지원 가상 호스팅: 여러 웹사이트 동시 호스팅 웹 서버의 종류와 특징 1. Apache HTTP Server 오픈소스, 유연성과 확장성이 뛰어남 다양한 운영체제 지원 모듈을 통한 기능 확장 용이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Apache 설정 예시 &lt;VirtualHost *:80> ServerName www.example.com DocumentRoot /var/www/html &lt;Directory /var/www/html> Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory> ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined &lt;/VirtualHost> 2. Nginx 고성능, 동시 연결 처리에 강점 리소스 사용 효율성이 높음 로드 밸런싱, 리버스 프록시 기능 제공 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Nginx 설정 예시 http { upstream backend { server backend1.example.com:8080; server backend2.example.com:8080; } server { listen 80; server_name example.com; location / { proxy_pass http://backend; proxy_set_header Host $host; } location /static/ { root /var/www; expires 30d; } } } 3. Microsoft IIS (Internet Information Services) Windows 환경에 최적화 Microsoft 제품과의 통합성 우수 애플리케이션 캐싱, 보안 기능 강화 1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;!-- IIS 웹 설정 예시 --> &lt;configuration> &lt;system.webServer> &lt;security> &lt;requestFiltering> &lt;requestLimits maxAllowedContentLength="30000000" /> &lt;/requestFiltering> &lt;/security> &lt;handlers> &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" /> &lt;/handlers> &lt;/system.webServer> &lt;/configuration> 4. LiteSpeed 경량화된 웹 서버로 성능과 보안에 중점 Apache 설정과 호환성 제공 리소스 사용 효율성이 높음 5. Lighttpd 저용량 메모리 사용, CPU 부하 최소화 병렬 연결 처리에 최적화 FastCGI, 출력 압축 등 다양한 기능 지원 각 웹 서버는 고유한 특징과 장단점을 가지고 있어, 사용 목적과 환경에 따라 적절한 선택이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-10-21 05:34:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;440 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Server" href=https://buenhyden.github.io/posts/backend/web-servers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server</h2></header><div class=entry-content><p>Web Application Server 웹 애플리케이션 서버(Web Application Server, WAS)는 웹 애플리케이션의 실행 환경을 제공하고, 동적인 콘텐츠를 처리하며, 데이터베이스와의 연동을 지원하는 소프트웨어 프레임워크이다.
WAS는 웹 서버와 함께 사용되며, 주로 HTTP 프로토콜을 통해 클라이언트 요청을 처리한다.
WAS는 현대적인 웹 애플리케이션 개발과 운영에서 필수적인 요소이다. 특히 데이터베이스와 연동하여 동적인 콘텐츠를 생성하고 복잡한 비즈니스 로직을 처리하는 데 강점을 가진다. 효율적인 시스템 설계를 위해 일반적으로 웹 서버와 함께 사용되며, 이를 통해 성능 최적화와 보안 강화가 가능하다.
...</p></div><footer class=entry-footer><span title='2024-10-21 15:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;751 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server" href=https://buenhyden.github.io/posts/backend/was/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>APIs</h2></header><div class=entry-content><p>API(Application Programming Interface)s 두 애플리케이션이 서로 통신할 수 있게 해주는 소프트웨어 중개자.
이는 데이터와 기능을 안전하고 제어된 방식으로 공유할 수 있게 해주는 메커니즘이다.
1 2 3 4 레스토랑에서… - 손님(클라이언트) = API를 사용하는 프로그램 - 웨이터(API) = 주문을 주방에 전달하고 음식을 가져오는 인터페이스 - 주방(서버) = 실제 서비스를 제공하는 시스템 주요 특징 추상화: API는 복잡한 내부 로직을 숨기고 간단한 인터페이스를 제공한다. 표준화: API는 일관된 방식으로 데이터를 주고받을 수 있게 한다. 모듈성: API를 통해 애플리케이션을 독립적인 모듈로 분리할 수 있다. 확장성: API를 사용하면 기존 시스템에 새로운 기능을 쉽게 추가할 수 있다. API 설계할 때 원칙 일관성: API 구조, 명명 규칙, 오류 처리 등에서 일관성을 유지해야 한다.
- 명명 규칙 통일
- 응답 형식 통일
- 에러 처리 방식 통일
잘된 예)
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2500 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to APIs" href=https://buenhyden.github.io/posts/backend/api-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Search Engines</h2></header><div class=entry-content><p>Search Engine 대형 도서관을 예로 들어 보면, 수백만 권의 책 중에서 원하는 책을 빠르게 찾으려면 체계적인 분류 시스템이 필요하다.
책의 제목, 저자, 주제별로 정리된 카드 카탈로그가 있어야 한다. 검색 엔진도 이와 비슷한 원리로 작동한다. 방대한 데이터를 효율적으로 찾을 수 있도록 데이터를 분석하고, 색인을 만들어 관리한다.
검색 엔진의 기본 개념을 살펴보면, 크게 세 가지 핵심 과정이 있다:
크롤링(Crawling).
도서관 사서가 새로운 책을 수집하는 것처럼, 검색 엔진은 데이터를 수집한다.
웹 검색 엔진의 경우 웹페이지를 탐색하고, 기업용 검색 엔진은 내부 문서나 데이터베이스의 정보를 수집한다. 인덱싱(Indexing).
수집한 데이터를 분석하고 검색하기 쉽게 정리하는 과정.
책의 색인처럼, 중요한 키워드와 그 위치 정보를 저장한다.
이 과정에서 다양한 텍스트 분석 기술이 사용된다. 검색과 순위화(Searching and Ranking).
사용자의 검색어를 분석하고, 가장 관련성 높은 결과를 찾아 보여준다.
마치 도서관 사서가 이용자의 요구를 정확히 이해하고 가장 적절한 책을 추천하는 것과 같다. 주요 종류 웹 검색 엔진:
Google, Bing과 같은 웹 검색 엔진은 인터넷의 모든 웹페이지를 대상으로 검색 서비스를 제공합니다.
이들은 매우 복잡한 알고리즘을 사용하여 웹페이지의 관련성과 신뢰성을 평가합니다. 엔터프라이즈 검색 엔진:
Elasticsearch, Solr와 같은 엔터프라이즈 검색 엔진은 기업 내부의 문서, 데이터베이스, 애플리케이션 데이터를 검색할 수 있게 해줍니다.
이들은 높은 확장성과 커스터마이징 가능성을 제공합니다. 데스크톱 검색 엔진:
Windows Search나 macOS Spotlight와 같은 데스크톱 검색 엔진은 개인 컴퓨터 내의 파일과 문서를 검색하는 데 사용됩니다. 이들은 실시간 인덱싱과 빠른 검색 속도에 중점을 둡니다. 특수 목적 검색 엔진:
학술 검색 엔진(Google Scholar), 상품 검색 엔진(Amazon), 부동산 검색 엔진 등 특정 도메인에 특화된 검색 엔진들이 있습니다.
이들은 해당 분야의 특수한 요구사항을 반영한 기능을 제공합니다. 주요 특징 텍스트 분석 기능:
검색 엔진은 다양한 텍스트 처리 기술을 사용합니다.
형태소 분석으로 단어를 정확히 인식하고, 동의어 처리로 검색의 정확도를 높이며, 철자 오류도 보정할 수 있습니다. 확장성과 성능:
대규모 데이터를 처리할 수 있도록 분산 처리 기능을 제공합니다.
데이터가 증가해도 빠른 검색 속도를 유지할 수 있도록 설계되어 있습니다. 고급 검색 기능:
필터링, 패싯 검색, 지리적 검색 등 다양한 고급 검색 기능을 제공합니다.
사용자가 원하는 결과를 정확히 찾을 수 있도록 도와줍니다. 실시간 처리:
새로운 데이터가 추가되면 즉시 검색 가능하도록 실시간 인덱싱을 지원합니다.
최신 정보를 빠르게 검색할 수 있습니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-21 05:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;328 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Search Engines" href=https://buenhyden.github.io/posts/backend/search-engines/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes</h2></header><div class=entry-content><p>Kubernetes 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈소스 컨테이너 오케스트레이션 플랫폼
2014년 Google이 개발하고 2015년 Cloud Native Computing Foundation(CNCF)에 기부한 이 플랫폼은 현재 컨테이너 기반 인프라의 de facto 표준으로 자리잡음.
Source: https://kubernetes.io/ko/docs/concepts/overview/components/
주요 특징 컨테이너 오케스트레이션: Kubernetes는 다수의 컨테이너를 효율적으로 관리하고 조정합니다. 자동화된 배포 및 확장: 애플리케이션의 수요에 따라 자동으로 컨테이너를 배포하고 확장할 수 있습니다. 자가 회복(Self-healing): 장애가 발생한 컨테이너를 자동으로 감지하고 교체하여 서비스의 연속성을 보장합니다. 로드 밸런싱: 트래픽을 여러 컨테이너에 균등하게 분산시켜 서비스 안정성을 유지합니다. 플랫폼 독립성: 온-프레미스, 퍼블릭 클라우드, 하이브리드 환경 등 다양한 인프라에서 실행 가능합니다. 주요 컴포넌트 컨트롤 플레인 컴포넌트 클러스터의 전반적인 관리를 담당합니다.
...</p></div><footer class=entry-footer><span title='2024-11-11 15:44:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1162 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes" href=https://buenhyden.github.io/posts/backend/containerization-and-virtualization/containerization/orchestration/tools/kubernetes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker</h2></header><div class=entry-content><p>Docker 애플리케이션과 그 실행 환경을 컨테이너라는 독립된 단위로 패키징하여 어디서나 일관되게 실행할 수 있게 해주는 플랫폼.
컨테이너는 애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 등 필요한 모든 것을 포함하는 경량화된 가상화 환경.
Source: &lt;https://www.docker.com/resources/what-container/
특징 포터빌리티: Docker 컨테이너는 어떤 환경에서도 동일하게 실행될 수 있어 개발, 테스트, 운영 환경 간 일관성을 제공합니다. 경량화: 컨테이너는 호스트 OS의 커널을 공유하여 가상 머신보다 더 가볍고 효율적입니다. 격리: 각 컨테이너는 독립적으로 실행되어 다른 컨테이너나 호스트 시스템에 영향을 주지 않습니다. 버전 관리: Docker 이미지는 버전 관리가 가능하며, Docker Hub를 통해 쉽게 공유할 수 있습니다. 장점 일관된 개발 환경: 개발자들이 동일한 환경에서 작업할 수 있어 “내 컴퓨터에서는 작동합니다” 문제를 해결합니다. 빠른 배포: 컨테이너화된 애플리케이션은 빠르게 배포되고 확장될 수 있습니다. 리소스 효율성: 컨테이너는 가상 머신보다 적은 리소스를 사용합니다. 마이크로서비스 아키텍처 지원: Docker는 독립적인 서비스 구현에 이상적입니다. 단점 보안 이슈: 컨테이너 간 격리가 완벽하지 않아 보안 취약점이 발생할 수 있습니다. 복잡성: Docker의 학습 곡선이 가파를 수 있으며, 관리가 복잡해질 수 있습니다. 제한된 오케스트레이션: 다중 컨테이너 관리를 위해서는 추가 도구가 필요할 수 있습니다. 역할 개발 환경 표준화: 모든 개발자가 동일한 환경에서 작업할 수 있게 합니다. 애플리케이션 격리: 각 애플리케이션을 독립적인 환경에서 실행합니다. CI/CD 파이프라인 지원: 지속적 통합 및 배포 프로세스를 간소화합니다. 마이크로서비스 구현: 복잡한 애플리케이션을 작은 독립 서비스로 분리하는 데 도움을 줍니다. 주요 명령어 이미지 관리:
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;367 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Docker" href=https://buenhyden.github.io/posts/backend/containerization-and-virtualization/containerization/tools/docker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Virtualization</h2></header><div class=entry-content><p>가상화 (virtualization) 컴퓨터 리소스의 추상화를 가능하게 하는 기술
​가상화는 하나의 물리적 컴퓨팅 자원(예: 서버, 운영 체제, 애플리케이션, 스토리지)을 여러 개의 가상 리소스로 나누거나, 여러 개의 물리적 리소스를 하나의 가상 리소스로 통합하는 기술이다. 이를 통해 하드웨어의 활용도를 높이고, 유연성과 확장성을 제공한다.
가상화의 유형 서버 가상화
서버 가상화는 하나의 물리적 서버를 여러 개의 가상 서버로 분할하는 기술.
이를 통해 각 가상 서버는 독립적인 운영 체제와 애플리케이션을 실행할 수 있다.
데스크톱 가상화
데스크톱 가상화는 사용자의 데스크톱 환경을 중앙 서버에서 가상화하여 제공하는 기술.
이를 통해 사용자는 어떤 장치에서든 자신의 가상 데스크톱에 접근할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-11 13:00:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1478 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Virtualization" href=https://buenhyden.github.io/posts/backend/containerization-and-virtualization/virtualization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka</h2></header><div class=entry-content><p>Kafka Kafka는 LinkedIn에서 개발되어 현재는 Apache Software Foundation에서 관리하는 오픈소스 프로젝트입니다.
금융 서비스, IoT, 로그 집계, 실시간 분석 등 다양한 산업 분야에서 활용되고 있으며, 대규모 데이터 처리와 실시간 스트리밍이 필요한 현대적인 데이터 아키텍처에서 중요한 역할을 하고 있다.
데이터 파이프라인을 구축하기 위한 분산 메시징 시스템으로, 실시간 데이터 파이프라인과 스트리밍 애플리케이션을 구축하는 데 사용된다.
다음은 Python을 사용한 기본적인 Kafka 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from kafka import KafkaProducer, KafkaConsumer import json # 프로듀서 구현 class MessageProducer: def __init__(self, bootstrap_servers): self.producer = KafkaProducer( bootstrap_servers=bootstrap_servers, value_serializer=lambda v: json.dumps(v).encode('utf-8') ) def send_message(self, topic, message): future = self.producer.send(topic, message) try: future.get(timeout=10) # 메시지 전송 확인 print(f"Message sent successfully to {topic}") except Exception as e: print(f"Failed to send message: {e}") def close(self): self.producer.close() # 컨슈머 구현 class MessageConsumer: def __init__(self, bootstrap_servers, topic, group_id): self.consumer = KafkaConsumer( topic, bootstrap_servers=bootstrap_servers, group_id=group_id, value_deserializer=lambda x: json.loads(x.decode('utf-8')) ) def start_consuming(self): try: for message in self.consumer: print(f"Received: {message.value}") # 메시지 처리 로직 구현 except Exception as e: print(f"Error while consuming: {e}") 특징 분산 아키텍처:
...</p></div><footer class=entry-footer><span title='2024-10-21 00:54:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;823 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ</h2></header><div class=entry-content><p>RabbitMQ RabbitMQ는 메시지 브로커(Message Broker) 또는 메시지 큐 관리자로, AMQP(Advanced Message Queuing Protocol)를 구현한 오픈소스 소프트웨어이다.
애플리케이션 간에 메시지를 안전하게 전달하고 관리한다.
Python을 사용한 기본적인 RabbitMQ 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import pika # 연결 설정 connection = pika.BlockingConnection( pika.ConnectionParameters('localhost') ) channel = connection.channel() # 큐 선언 channel.queue_declare(queue='hello') # 메시지 발행 channel.basic_publish( exchange='', routing_key='hello', body='Hello World!' ) print(" [x] Sent 'Hello World!'") connection.close() 핵심 기능 메시지 큐잉: 생산자(sender)와 소비자(receiver) 간의 메시지 전달을 위한 큐 제공 비동기 통신: 서비스 간 비동기 상호작용을 가능하게 하여 확장성과 복원력 향상 내구성과 신뢰성: 메시지 지속성과 승인 메커니즘을 통한 메시지 손실 방지 다양한 교환 유형: direct, fanout, topic, headers 등 다양한 라우팅 옵션 제공 다중 언어 지원: Java, Python, JavaScript 등 다양한 프로그래밍 언어 지원 클러스터링과 고가용성: 부하 분산과 고가용성을 위한 클러스터 배포 가능 아키텍처 RabbitMQ의 아키텍처는 다음 주요 구성 요소로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-10-21 00:54:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;407 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/rabbitmq/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/backend/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/backend/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>