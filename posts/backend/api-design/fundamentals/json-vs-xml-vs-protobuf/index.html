<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JSON vs. XML vs. Protobuf | hyunyoun's Blog</title>
<meta name=keywords content="Backend,API-Design,Fundamentals,Format,Json,XML,protobuf"><meta name=description content="데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="JSON vs. XML vs. Protobuf"><meta property="og:description" content="데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-26T11:42:00+00:00"><meta property="article:modified_time" content="2024-10-26T11:42:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Format"><meta property="article:tag" content="Json"><meta property="article:tag" content="XML"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="JSON vs. XML vs. Protobuf"><meta name=twitter:description content="데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"APIs","item":"https://buenhyden.github.io/posts/backend/api-design/"},{"@type":"ListItem","position":4,"name":"Fundamentals of API","item":"https://buenhyden.github.io/posts/backend/api-design/fundamentals/"},{"@type":"ListItem","position":5,"name":"JSON vs. XML vs. Protobuf","item":"https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JSON vs. XML vs. Protobuf","name":"JSON vs. XML vs. Protobuf","description":"데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.","keywords":["Backend","API-Design","Fundamentals","Format","Json","XML","protobuf"],"articleBody":"JSON vs. XML vs. Protobuf 데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.\n세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:\nJSON은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다. XML은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다. Protobuf는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다. 선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.\n개요 및 역사 JSON (JavaScript Object Notation) JSON은 2001년 Douglas Crockford가 개발한 경량 데이터 교환 형식이다.\nJavaScript에서 파생되었지만 현재는 언어 독립적인 형식으로 사용된다. 사람이 읽고 쓰기 쉬우며, 기계가 파싱하고 생성하기 쉽다.\nXML (eXtensible Markup Language) XML은 1996년에 W3C에서 개발한 마크업 언어로, SGML(Standard Generalized Markup Language)에서 파생되었다. 문서 구조화와 데이터 표현을 위해 설계되었으며, 확장성과 유연성이 특징이다.\nProtobuf (Protocol Buffers) Protobuf는 2008년 Google에서 개발한 이진 직렬화 형식이다. 구조화된 데이터를 직렬화하기 위한 효율적이고 플랫폼 중립적인 메커니즘으로 설계되었다. 다양한 프로그래밍 언어에서 사용할 수 있다.\n구문과 구조 JSON 1 2 3 4 5 6 7 8 9 10 11 12 { \"person\": { \"name\": \"홍길동\", \"age\": 30, \"isStudent\": false, \"courses\": [\"수학\", \"과학\", \"역사\"], \"address\": { \"city\": \"서울\", \"zipcode\": \"12345\" } } } JSON은 키-값 쌍으로 구성되며, 객체, 배열, 문자열, 숫자, 불리언, null 값을 지원한다.\n구문이 단순하고 중첩 구조를 쉽게 표현할 수 있다.\nXML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 홍길동 30 false 수학 과학 역사 서울 12345 XML은 태그와 속성을 사용하여 데이터를 구조화한다. 문서 유형 정의(DTD)나 XML 스키마(XSD)를 통해 엄격한 유효성 검사가 가능하다. 또한 네임스페이스를 지원하여 이름 충돌 문제를 해결한다.\nProtobuf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 syntax = \"proto3\"; message Person { string name = 1; int32 age = 2; bool is_student = 3; repeated string courses = 4; Address address = 5; message Address { string city = 1; string zipcode = 2; } } Protobuf는 .proto 파일에 스키마를 정의한 후, 컴파일러를 통해 다양한 언어의 코드로 생성된다.\n필드 번호를 사용하여 데이터를 식별하며, 이진 형식으로 직렬화되어 텍스트로는 직접 읽을 수 없다.\n성능 비교 파일 크기 Protobuf: 가장 작은 파일 크기 (이진 형식) JSON: 중간 크기 (간결한 텍스트 형식) XML: 가장 큰 파일 크기 (태그 중복 및 메타데이터로 인해) Google의 내부 테스트에 따르면, 동일한 데이터를 표현할 때 Protobuf는 XML보다 약 310배 작고, JSON보다 약 1.53배 작다.\n처리 속도 Protobuf: 가장 빠른 처리 속도 (이진 형식, 정적 타입) JSON: 중간 처리 속도 (간단한 파싱) XML: 가장 느린 처리 속도 (복잡한 DOM 파싱) 특히 대규모 데이터셋에서 Protobuf는 XML보다 약 20100배, JSON보다 약 210배 빠른 처리 속도를 보인다. 이는 네트워크 대역폭과 CPU 사용량 감소로 이어진다.\n유연성 및 확장성 스키마 정의 JSON: 스키마 선택적 (JSON Schema 이용 가능) XML: 강력한 스키마 지원 (DTD, XSD) Protobuf: 필수 스키마 정의 (.proto 파일) 버전 관리 JSON: 명시적 버전 관리 메커니즘 없음 XML: 네임스페이스를 통한 버전 관리 가능 Protobuf: 내장된 버전 관리 메커니즘 (필드 번호 보존) Protobuf는 필드 번호를 통해 하위 호환성을 유지하며 새 필드를 추가하거나 기존 필드를 삭제할 수 있다. 이는 진화하는 API에 이상적이다.\n사용 편의성 가독성 JSON: 높은 가독성 (간결한 구문) XML: 중간 가독성 (태그 구조가 복잡할 수 있음) Protobuf: 낮은 가독성 (이진 형식) 디버깅 JSON: 쉬운 디버깅 (텍스트 기반) XML: 중간 디버깅 난이도 (복잡한 구조) Protobuf: 어려운 디버깅 (이진 형식, 도구 필요) 학습 곡선 JSON: 낮은 학습 곡선 (간단한 구문) XML: 중간 학습 곡선 (태그, 속성, 네임스페이스) Protobuf: 높은 학습 곡선 (스키마 정의, 컴파일 단계) 생태계 및 지원 언어 지원 JSON: 거의 모든 프로그래밍 언어 지원 XML: 광범위한 언어 지원 Protobuf: 주요 언어 지원 (C++, Java, Python, Go 등) 도구 JSON: 풍부한 도구 (파서, 검증기, 편집기) XML: 광범위한 도구 (DOM/SAX 파서, XSLT, XPath) Protobuf: 제한된 도구 (주로 Google 제공) 표준화 JSON: ECMA-404, RFC 8259 표준 XML: W3C 표준 Protobuf: 공식 표준 아님 (Google 명세) 적합한 사용 사례 JSON 웹 API (REST, GraphQL) 프론트엔드 데이터 교환 구성 파일 사람이 읽을 수 있어야 하는 데이터 XML 문서 중심 애플리케이션 (DOCX, SVG) 엔터프라이즈 시스템 (SOAP, WSDL) 복잡한 스키마와 네임스페이스가 필요한 경우 메타데이터가 중요한 경우 Protobuf 마이크로서비스 간 통신 (gRPC) 고성능 데이터 스토리지 대규모 데이터셋 처리 대역폭이나 처리 시간이 중요한 경우 주요 비교 요약 특성 JSON XML Protobuf 형식 텍스트 텍스트 이진 개발 Douglas Crockford, 2001 W3C, 1996 Google, 2008 구문 간결한 키-값 태그 기반 스키마 정의 파일 크기 중간 큼 작음 처리 속도 중간 느림 빠름 가독성 높음 중간 낮음 스키마 선택적 지원 (DTD, XSD) 필수 (.proto) 버전 관리 제한적 네임스페이스 이용 내장 지원 언어 독립성 높음 높음 높음 학습 곡선 낮음 중간 높음 표준화 ECMA, RFC W3C 비공식 주요 사용 사례 웹 API, 구성 문서, 엔터프라이즈 마이크로서비스, 빅데이터 데이터 검증 JSON Schema XSD, DTD 컴파일 시점 네임스페이스 미지원 지원 패키지 개념 지원 주석 미지원 지원 .proto 파일에만 지원 인코딩 UTF-8 일반적 다양한 인코딩 지원 이진 참고 및 출처 ","wordCount":"799","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-26T11:42:00Z","dateModified":"2024-10-26T11:42:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/>APIs</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/fundamentals/>Fundamentals of API</a></div><h1 class="post-title entry-hint-parent">JSON vs. XML vs. Protobuf</h1><div class=post-description>데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.</div><div class=post-meta><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend/API%20Design/Fundamentals/JSON-vs-XML-vs-Protobuf.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#json-vs-xml-vs-protobuf>JSON vs. XML vs. Protobuf</a><ul><li><a href=#개요-및-역사>개요 및 역사</a></li><li><a href=#구문과-구조>구문과 구조</a></li><li><a href=#성능-비교>성능 비교</a></li><li><a href=#유연성-및-확장성>유연성 및 확장성</a></li><li><a href=#사용-편의성>사용 편의성</a></li><li><a href=#생태계-및-지원>생태계 및 지원</a></li><li><a href=#적합한-사용-사례>적합한 사용 사례</a></li><li><a href=#주요-비교-요약>주요 비교 요약</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=json-vs-xml-vs-protobuf>JSON vs. XML vs. Protobuf<a hidden class=anchor aria-hidden=true href=#json-vs-xml-vs-protobuf>#</a></h2><p>데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.</p><p>세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:</p><ul><li><strong>JSON</strong>은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다.</li><li><strong>XML</strong>은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다.</li><li><strong>Protobuf</strong>는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다.</li></ul><p>선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.</p><h3 id=개요-및-역사>개요 및 역사<a hidden class=anchor aria-hidden=true href=#개요-및-역사>#</a></h3><h4 id=json-javascript-object-notation>JSON (JavaScript Object Notation)<a hidden class=anchor aria-hidden=true href=#json-javascript-object-notation>#</a></h4><p>JSON은 2001년 Douglas Crockford가 개발한 경량 데이터 교환 형식이다.<br>JavaScript에서 파생되었지만 현재는 언어 독립적인 형식으로 사용된다. 사람이 읽고 쓰기 쉬우며, 기계가 파싱하고 생성하기 쉽다.</p><h4 id=xml-extensible-markup-language>XML (eXtensible Markup Language)<a hidden class=anchor aria-hidden=true href=#xml-extensible-markup-language>#</a></h4><p>XML은 1996년에 W3C에서 개발한 마크업 언어로, SGML(Standard Generalized Markup Language)에서 파생되었다. 문서 구조화와 데이터 표현을 위해 설계되었으며, 확장성과 유연성이 특징이다.</p><h4 id=protobuf-protocol-buffers>Protobuf (Protocol Buffers)<a hidden class=anchor aria-hidden=true href=#protobuf-protocol-buffers>#</a></h4><p>Protobuf는 2008년 Google에서 개발한 이진 직렬화 형식이다. 구조화된 데이터를 직렬화하기 위한 효율적이고 플랫폼 중립적인 메커니즘으로 설계되었다. 다양한 프로그래밍 언어에서 사용할 수 있다.</p><h3 id=구문과-구조>구문과 구조<a hidden class=anchor aria-hidden=true href=#구문과-구조>#</a></h3><h4 id=json>JSON<a hidden class=anchor aria-hidden=true href=#json>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;person&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;홍길동&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;age&#34;</span><span class=p>:</span> <span class=mi>30</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;isStudent&#34;</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;courses&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;수학&#34;</span><span class=p>,</span> <span class=s2>&#34;과학&#34;</span><span class=p>,</span> <span class=s2>&#34;역사&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;address&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;city&#34;</span><span class=p>:</span> <span class=s2>&#34;서울&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;zipcode&#34;</span><span class=p>:</span> <span class=s2>&#34;12345&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>JSON은 키-값 쌍으로 구성되며, 객체, 배열, 문자열, 숫자, 불리언, null 값을 지원한다.<br>구문이 단순하고 중첩 구조를 쉽게 표현할 수 있다.</p><h4 id=xml>XML<a hidden class=anchor aria-hidden=true href=#xml>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;person&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;name&gt;</span>홍길동<span class=nt>&lt;/name&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;age&gt;</span>30<span class=nt>&lt;/age&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;isStudent&gt;</span>false<span class=nt>&lt;/isStudent&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;courses&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;course&gt;</span>수학<span class=nt>&lt;/course&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;course&gt;</span>과학<span class=nt>&lt;/course&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;course&gt;</span>역사<span class=nt>&lt;/course&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/courses&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;address&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;city&gt;</span>서울<span class=nt>&lt;/city&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;zipcode&gt;</span>12345<span class=nt>&lt;/zipcode&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/address&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/person&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>XML은 태그와 속성을 사용하여 데이터를 구조화한다. 문서 유형 정의(DTD)나 XML 스키마(XSD)를 통해 엄격한 유효성 검사가 가능하다. 또한 네임스페이스를 지원하여 이름 충돌 문제를 해결한다.</p><h4 id=protobuf>Protobuf<a hidden class=anchor aria-hidden=true href=#protobuf>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>Person</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>int32</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>bool</span> <span class=n>is_student</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>repeated</span> <span class=kt>string</span> <span class=n>courses</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=n>Address</span> <span class=n>address</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kd>message</span> <span class=nc>Address</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>city</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>zipcode</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>Protobuf는 <code>.proto</code> 파일에 스키마를 정의한 후, 컴파일러를 통해 다양한 언어의 코드로 생성된다.<br>필드 번호를 사용하여 데이터를 식별하며, 이진 형식으로 직렬화되어 텍스트로는 직접 읽을 수 없다.</p><h3 id=성능-비교>성능 비교<a hidden class=anchor aria-hidden=true href=#성능-비교>#</a></h3><h4 id=파일-크기>파일 크기<a hidden class=anchor aria-hidden=true href=#파일-크기>#</a></h4><ul><li><strong>Protobuf</strong>: 가장 작은 파일 크기 (이진 형식)</li><li><strong>JSON</strong>: 중간 크기 (간결한 텍스트 형식)</li><li><strong>XML</strong>: 가장 큰 파일 크기 (태그 중복 및 메타데이터로 인해)</li></ul><p>Google의 내부 테스트에 따르면, 동일한 데이터를 표현할 때 Protobuf는 XML보다 약 3<del>10배 작고, JSON보다 약 1.5</del>3배 작다.</p><h4 id=처리-속도>처리 속도<a hidden class=anchor aria-hidden=true href=#처리-속도>#</a></h4><ul><li><strong>Protobuf</strong>: 가장 빠른 처리 속도 (이진 형식, 정적 타입)</li><li><strong>JSON</strong>: 중간 처리 속도 (간단한 파싱)</li><li><strong>XML</strong>: 가장 느린 처리 속도 (복잡한 DOM 파싱)</li></ul><p>특히 대규모 데이터셋에서 Protobuf는 XML보다 약 20<del>100배, JSON보다 약 2</del>10배 빠른 처리 속도를 보인다. 이는 네트워크 대역폭과 CPU 사용량 감소로 이어진다.</p><h3 id=유연성-및-확장성>유연성 및 확장성<a hidden class=anchor aria-hidden=true href=#유연성-및-확장성>#</a></h3><h4 id=스키마-정의>스키마 정의<a hidden class=anchor aria-hidden=true href=#스키마-정의>#</a></h4><ul><li><strong>JSON</strong>: 스키마 선택적 (JSON Schema 이용 가능)</li><li><strong>XML</strong>: 강력한 스키마 지원 (DTD, XSD)</li><li><strong>Protobuf</strong>: 필수 스키마 정의 (.proto 파일)</li></ul><h4 id=버전-관리>버전 관리<a hidden class=anchor aria-hidden=true href=#버전-관리>#</a></h4><ul><li><strong>JSON</strong>: 명시적 버전 관리 메커니즘 없음</li><li><strong>XML</strong>: 네임스페이스를 통한 버전 관리 가능</li><li><strong>Protobuf</strong>: 내장된 버전 관리 메커니즘 (필드 번호 보존)</li></ul><p>Protobuf는 필드 번호를 통해 하위 호환성을 유지하며 새 필드를 추가하거나 기존 필드를 삭제할 수 있다. 이는 진화하는 API에 이상적이다.</p><h3 id=사용-편의성>사용 편의성<a hidden class=anchor aria-hidden=true href=#사용-편의성>#</a></h3><h4 id=가독성>가독성<a hidden class=anchor aria-hidden=true href=#가독성>#</a></h4><ul><li><strong>JSON</strong>: 높은 가독성 (간결한 구문)</li><li><strong>XML</strong>: 중간 가독성 (태그 구조가 복잡할 수 있음)</li><li><strong>Protobuf</strong>: 낮은 가독성 (이진 형식)</li></ul><h4 id=디버깅>디버깅<a hidden class=anchor aria-hidden=true href=#디버깅>#</a></h4><ul><li><strong>JSON</strong>: 쉬운 디버깅 (텍스트 기반)</li><li><strong>XML</strong>: 중간 디버깅 난이도 (복잡한 구조)</li><li><strong>Protobuf</strong>: 어려운 디버깅 (이진 형식, 도구 필요)</li></ul><h4 id=학습-곡선>학습 곡선<a hidden class=anchor aria-hidden=true href=#학습-곡선>#</a></h4><ul><li><strong>JSON</strong>: 낮은 학습 곡선 (간단한 구문)</li><li><strong>XML</strong>: 중간 학습 곡선 (태그, 속성, 네임스페이스)</li><li><strong>Protobuf</strong>: 높은 학습 곡선 (스키마 정의, 컴파일 단계)</li></ul><h3 id=생태계-및-지원>생태계 및 지원<a hidden class=anchor aria-hidden=true href=#생태계-및-지원>#</a></h3><h4 id=언어-지원>언어 지원<a hidden class=anchor aria-hidden=true href=#언어-지원>#</a></h4><ul><li><strong>JSON</strong>: 거의 모든 프로그래밍 언어 지원</li><li><strong>XML</strong>: 광범위한 언어 지원</li><li><strong>Protobuf</strong>: 주요 언어 지원 (C++, Java, Python, Go 등)</li></ul><h4 id=도구>도구<a hidden class=anchor aria-hidden=true href=#도구>#</a></h4><ul><li><strong>JSON</strong>: 풍부한 도구 (파서, 검증기, 편집기)</li><li><strong>XML</strong>: 광범위한 도구 (DOM/SAX 파서, XSLT, XPath)</li><li><strong>Protobuf</strong>: 제한된 도구 (주로 Google 제공)</li></ul><h4 id=표준화>표준화<a hidden class=anchor aria-hidden=true href=#표준화>#</a></h4><ul><li><strong>JSON</strong>: ECMA-404, RFC 8259 표준</li><li><strong>XML</strong>: W3C 표준</li><li><strong>Protobuf</strong>: 공식 표준 아님 (Google 명세)</li></ul><h3 id=적합한-사용-사례>적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#적합한-사용-사례>#</a></h3><h4 id=json-1>JSON<a hidden class=anchor aria-hidden=true href=#json-1>#</a></h4><ul><li>웹 API (REST, GraphQL)</li><li>프론트엔드 데이터 교환</li><li>구성 파일</li><li>사람이 읽을 수 있어야 하는 데이터</li></ul><h4 id=xml-1>XML<a hidden class=anchor aria-hidden=true href=#xml-1>#</a></h4><ul><li>문서 중심 애플리케이션 (DOCX, SVG)</li><li>엔터프라이즈 시스템 (SOAP, WSDL)</li><li>복잡한 스키마와 네임스페이스가 필요한 경우</li><li>메타데이터가 중요한 경우</li></ul><h4 id=protobuf-1>Protobuf<a hidden class=anchor aria-hidden=true href=#protobuf-1>#</a></h4><ul><li>마이크로서비스 간 통신 (gRPC)</li><li>고성능 데이터 스토리지</li><li>대규모 데이터셋 처리</li><li>대역폭이나 처리 시간이 중요한 경우</li></ul><h3 id=주요-비교-요약>주요 비교 요약<a hidden class=anchor aria-hidden=true href=#주요-비교-요약>#</a></h3><table><thead><tr><th>특성</th><th>JSON</th><th>XML</th><th>Protobuf</th></tr></thead><tbody><tr><td><strong>형식</strong></td><td>텍스트</td><td>텍스트</td><td>이진</td></tr><tr><td><strong>개발</strong></td><td>Douglas Crockford, 2001</td><td>W3C, 1996</td><td>Google, 2008</td></tr><tr><td><strong>구문</strong></td><td>간결한 키-값</td><td>태그 기반</td><td>스키마 정의</td></tr><tr><td><strong>파일 크기</strong></td><td>중간</td><td>큼</td><td>작음</td></tr><tr><td><strong>처리 속도</strong></td><td>중간</td><td>느림</td><td>빠름</td></tr><tr><td><strong>가독성</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr><tr><td><strong>스키마</strong></td><td>선택적</td><td>지원 (DTD, XSD)</td><td>필수 (.proto)</td></tr><tr><td><strong>버전 관리</strong></td><td>제한적</td><td>네임스페이스 이용</td><td>내장 지원</td></tr><tr><td><strong>언어 독립성</strong></td><td>높음</td><td>높음</td><td>높음</td></tr><tr><td><strong>학습 곡선</strong></td><td>낮음</td><td>중간</td><td>높음</td></tr><tr><td><strong>표준화</strong></td><td>ECMA, RFC</td><td>W3C</td><td>비공식</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>웹 API, 구성</td><td>문서, 엔터프라이즈</td><td>마이크로서비스, 빅데이터</td></tr><tr><td><strong>데이터 검증</strong></td><td>JSON Schema</td><td>XSD, DTD</td><td>컴파일 시점</td></tr><tr><td><strong>네임스페이스</strong></td><td>미지원</td><td>지원</td><td>패키지 개념 지원</td></tr><tr><td><strong>주석</strong></td><td>미지원</td><td>지원</td><td>.proto 파일에만 지원</td></tr><tr><td><strong>인코딩</strong></td><td>UTF-8 일반적</td><td>다양한 인코딩 지원</td><td>이진</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/format/>Format</a></li><li><a href=https://buenhyden.github.io/tags/json/>Json</a></li><li><a href=https://buenhyden.github.io/tags/xml/>XML</a></li><li><a href=https://buenhyden.github.io/tags/protobuf/>Protobuf</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/qa/fundamentals/sdlc/7-maintenance/><span class=title>« Prev</span><br><span>7. 유지보수 (Maintenance)</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/fundamentals/blocking-vs-non-blocking/><span class=title>Next »</span><br><span>Blocking vs Non-Blocking</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>