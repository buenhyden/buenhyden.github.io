<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API Styles | hyunyoun's Blog</title>
<meta name=keywords content="Backend,API-Design,API-Styles"><meta name=description content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/api-design/api-styles-and-types/api-styles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/api-design/api-styles-and-types/api-styles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/api-design/api-styles-and-types/api-styles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API Styles"><meta property="og:description" content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-26T06:08:00+00:00"><meta property="article:modified_time" content="2025-02-26T06:08:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="API-Styles"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API Styles"><meta name=twitter:description content="API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"APIs","item":"https://buenhyden.github.io/posts/backend/api-design/"},{"@type":"ListItem","position":4,"name":"API Styles","item":"https://buenhyden.github.io/posts/backend/api-design/api-styles-and-types/api-styles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"API Styles","name":"API Styles","description":"API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다.","keywords":["Backend","API-Design","API-Styles"],"articleBody":"API Styles API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다.\n새로운 API를 구축할 때 개발자는 API 설계와 API가 외부 세계와 상호 작용하는 방식을 API 스타일과 기술을 선택하여 고려한다.\nResource style Hypermedia style Query style Tunnel style Event-based style Resource Style (리소스 스타일) Resource style (리소스 스타일)은 리소스 지향적이다.\n오늘날 많은 API가 리소스 스타일을 사용하며, 이는 리소스 지향적 API를 설명하는 가장 일반적인 방법인 OpenAPI의 인기로 쉽게 확인할 수 있다.\n이 스타일에서 주요 초점은 소비자가 이러한 리소스와 상호 작용할 수 있도록 어떤 리소스를 노출할 것인지에 있다.\n이 컨텍스트에서 “리소스\"는 웹 사이트를 설계할 때 웹 페이지와 같은 리소스에 있는 범위와 유사하다.\n리소스의 개념은 API 기능의 관련 측면을 노출하는 훌륭한 방법을 제공하는 동시에 리소스 뒤에 구현 세부 정보를 숨길 수 있다. 제품, 제품 카테고리 및 고객 정보와 같은 영구적인 개념에 대한 리소스가 있을 수 있다. 또한 제품 주문 또는 배송 옵션 선택과 같은 프로세스 지향적인 개념에 대한 리소스도 있을 수 있다.\nREST(Representational state transfer)는 리소스 스타일에 대한 아키텍처 패턴이지만 REST가 구체적인 기술을 제공한다는 의미는 아니다.\nREST의 경우 HTTP가 선호되는 프로토콜이다.\n표현 형식의 경우 JSON이 다른 표현(예: JSON 이전의 XML)보다 훨씬 더 많이 사용된다고 말하는 것이 안전할 것입니다. 클라이언트 요청이 RESTful API를 통해 이루어지면 리소스 상태의 표현을 엔드포인트로 전송한다.\n백엔드 HTTP 엔드포인트와 통합된 많은 리소스 컬렉션으로 REST API를 개발할 때 Apache APISIX와 같은 API 게이트웨이의 기능을 사용하여 생성부터 프로덕션 API 모니터링까지 API 수명 주기를 지원할 수 있다. API 게이트웨이 REST API는 클라이언트가 서비스에 요청을 보내고 서비스가 동기적으로 응답하는 요청/응답 모델을 사용한다.\n이 리소스 스타일에는 이러한 리소스 전반에 걸쳐 워크플로를 더 잘 나타내는 기능이 없다. 하이퍼미디어 스타일은 리소스 연결 문제를 해결하기 위해 리소스 스타일에 핵심 구성 요소를 추가한다.\nHypermedia Style (하이퍼미디어 스타일) 웹에서와 마찬가지로 각 리소스를 개별적으로 알고 브라우저의 주소 표시줄에 URI를 입력하는 대신 리소스 간의 링크를 사용하여 리소스 간의 가장 중요한 경로를 탐색할 수 있다.\n하이퍼미디어 스타일은 API의 리소스에 대해 동일한 작업을 수행한다.\n웹에서 사람은 페이지를 읽고 따라갈 링크를 결정한다.\n하이퍼미디어 API의 경우 일반적으로 컴퓨터가 이 결정을 내린다. 즉, 컴퓨터가 사용 가능한 옵션을 식별하고 선택할 수 있도록 링크에 컴퓨터가 읽을 수 있는 레이블이 필요하다. 이러한 레이블은 웹 페이지에서 사람이 클릭하는 링크의 텍스트와 개념적으로 유사하지만 레이블은 리소스의 컴퓨터가 읽을 수 있는 표현(종종 JSON)으로 표현된다. 하이퍼미디어 API에서는 리소스 간의 링크를 사용하여 리소스를 “탐색\"할 수 있다.\n이 리소스 스타일에는 때때로 HATEOAS가 필요하며, 이는 Hypermedia As The Engine Of Application State의 약자이다. HATEOAS는 동적 리소스 라우팅을 허용하는 REST의 측면이다.\n리소스 스타일 API에 비해 하이퍼미디어 API에는 두 가지 주요 이점이 있다.\n다음 단계에서 사용 가능한 리소스를 선택하는 데 필요한 모든 링크를 제공한다. 링크는 리소스에 걸쳐 있으며 하나 이상의 API가 이러한 리소스를 제공하는지 여부는 중요하지 않다. 하이퍼미디어 스타일은 API 소비자가 API와 제공하는 리소스를 검색하는 데 필요한 지식을 제공하므로 이 모든 것이 매우 긍정적으로 들린다. 스택에서 사용되는 프로그래밍 언어와 프레임워크를 사용하여 하이퍼미디어 기반 REST 서비스를 구축할 수 있다.\n그러나 탐색의 용이성으로 인해 독자가 자료를 건너뛰고 파편화된 정보를 얻을 위험이 증가할 수 있다. 또한 클라이언트와 서버가 데이터를 공유하므로 클라이언트가 필요한 모든 정보에 액세스하려면 여러 번 상호 작용해야 하는 “수다스러운” API가 될 수 있다.\nAPI 엔드포인트가 여러 백엔드 서비스(마이크로서비스 및 서버리스 API)에 의해 노출되면 어떻게 될까? 응답 집계기/작성기(response aggregator/composer) 기능이 있는 API 게이트웨이를 활용하여 이 문제를 해결할 수 있다.\nQuery Style (쿼리 스타일) 쿼리 스타일은 잠재적으로 많은 리소스 세트에 액세스하기 위한 단일 진입점을 제공하므로 리소스 및 하이퍼미디어 스타일과 다르다.\n쿼리 스타일의 아이디어는 이러한 리소스가 API 공급자가 구조화된 형태로 관리한다는 것이다. 이 구조를 쿼리할 수 있으며 응답에는 쿼리 결과가 포함된다. 어느 수준에서는 이것이 데이터베이스가 작동하는 방식과 유사하다. 데이터베이스는 저장하는 데이터에 대한 기본 데이터 모델과 해당 데이터의 일부를 선택하고 검색할 수 있는 쿼리 언어를 가지고 있다.\n쿼리 스타일의 한 가지 이점은 각 소비자가 원하는 것을 정확히 요청할 수 있다는 것이다. 즉, 잘 구성된 쿼리를 사용하면 리소스/하이퍼미디어 API에서 수많은 요청이 필요했을 결과를 결합할 수 있다. 예를 들어 여러 HTTP 요청을 다른 엔드포인트로 보내는 대신 필요한 모든 것에 대한 단일 “쿼리\"를 POST할 수 있다.\n쿼리 스타일의 경우 GraphQL이 SPA(단일 페이지 응용 프로그램)를 구축하는 데 가장 많이 사용되는 선택이다. 클라이언트 측 응용 프로그램에서 데이터베이스를 쿼리하기 위한 언어이다. GraphQL의 가장 큰 장점은 JSON 기반 에코 시스템에 연결된다는 것이다. GraphQL은 쿼리에 JSON을 사용하지 않지만 JSON으로 결과를 반환하므로 JSON 중심 환경에서 쉽게 처리할 수 있다.\n쿼리 스타일에는 장점에 비해 무시할 만한 단점이 있지만 쿼리 복잡성은 그 중 하나이다. API 소비자는 기본 데이터 및 쿼리 모델에 대한 좋은 이해가 필요하다(쿼리 API를 올바르게 사용하는 방법과 재귀를 피하거나 너무 많은 중첩된 리소스를 가져오지 않도록 효율적인 요청을 수행하는 방법을 알 수 있도록). 또한 REST API에는 여러 엔드포인트가 있기 때문에 리소스 스타일보다 GraphQL로 단순화된 캐시를 구현하는 것이 더 복잡하다. 네이티브 HTTP 캐싱을 활용하여 리소스를 다시 가져오는 것을 피할 수 있다. GraphQL의 또 다른 문제는 “이 요청 수만 허용된다\"고 말하는 속도 제한이다.\n그럼에도 불구하고 마지막 두 가지 단점(캐싱 및 속도 제한)은 클라이언트와 데이터 저장소 사이에 API 게이트웨이를 도입하여 해결할 수 있다. 예를 들어 오픈 소스 Apache APISIX API 게이트웨이는 GraphQL 구문을 인식할 수 있다. 요청에 전달된 GraphQL 문을 효율적으로 일치시킴으로써 비정상적인 트래픽을 필터링하여 속도 제한 정책을 추가로 적용하고 캐싱 기능을 통해 시스템 성능을 향상시킬 수 있다.\nTunnel Style (터널 스타일) 터널 스타일에서 API는 원격으로 호출되는 함수 모음이다.\nAPI는 노출된 모든 프로시저를 API로 사용할 수 있는 로컬 프로그래밍 시나리오의 단순한 확장 프로그램이 된다. 터널 스타일은 API를 만드는 데 최소한의 노력을 기울일 수 있으므로 개발자에게 편리하다.\n이 스타일에서 사용되는 일반적인 기술은 RPC(원격 프로시저 호출) 방법이다.\nRPC는 클라이언트가 특정 프로시저를 실행하기 위해 원격 서버에 요청을 보내고 클라이언트가 응답을 수신하는 요청-응답 프로토콜이다. 그러나 RPC API는 REST API보다 유지 관리하고 업데이트하기가 훨씬 더 어렵기 때문에 RPC API는 최신 API 개발에서 그다지 많이 사용되지 않는다.\ngRPC는 효율적인 터널 스타일(RPC) 구현이며 분산 시스템에 적합하다. 많은 언어와 플랫폼에 대한 SDK가 있으므로 플랫폼과 언어 간 통신에 광범위하게 사용할 수 있다. gRPC는 최적화된 이진 전송을 위한 HTTP/2 표준인 프로토콜 버퍼(protobufs)를 사용하여 직렬화 및 역직렬화하고 (긴) 폴링 및 차단 HTTP 호출을 방지하기 위해 양방향 스트리밍을 사용하기 때문에 빠르고 효율적이다.\n도구는 API로 프로시저를 노출할 수 있으며, 여기서 “API 생성” 작업의 대부분을 자동화할 수 있다. API를 보호하기 위한 일부 관리 계층이 여전히 있어야 한다. 서로 다른 API 프로토콜이 시스템에서 사용되는 경우 API 게이트웨이와 gRPC 프록시 기능과 같은 구성 요소를 사용하여 페이로드를 동일한 전송(REST에서 gRPC 또는 그 반대로)을 통해 한 형식에서 다른 형식으로 변환하여 해결할 수 있다.\nEvent-based Style (이벤트 기반 스타일) 이벤트 기반 스타일에서는 API 제공자가 API 소비자에게 요청하는 대신 API 소비자에게 전달되는 이벤트를 만든다.\n소비 응용 프로그램은 API의 특정 기록 또는 기록의 상태 변경에 대한 정보를 받을 것으로 예상한다.\n이벤트 기반 API를 구현할 때 고려해야 할 많은 방법과 기술 옵션이 있다.\n또 다른 접근 방식은 이벤트 소비자가 이벤트 생산자와 분리하는 메시지 브로커에 연결하는 것이다. 메시지 브로커는 이벤트를 관리하고 소비자는 브로커가 이 유형의 이벤트가 구독자에게 전달되도록 특정 이벤트 유형을 구독해야 한다. 이 경우 아키텍처는 전달 브로커를 중심으로 하며 모든 이벤트 생산자와 소비자가 브로커에 연결된다.\n이 경우 고려해야 할 좋은 기술은 확장성이 뛰어나고 탄력적인 Apache Kafka이다.\n이벤트 기반 스타일을 선택할 때의 몇 가지 단점은 다른 스타일에 비해 구현하는 데 시간이 더 오래 걸리고 스타일이 올바르게 적용되지 않으면 다른 서비스에서 여러 개의 중복 메시지를 트리거할 수 있으며 이벤트 흐름을 효과적으로 모니터링하기 위해 타사 도구를 추가하지 않으면 오류 처리 및 문제 해결이 어려울 수 있다는 것이다.\n그러나 여러 모니터링 플랫폼에 대한 간단한 기본 제공 통합을 통해 최신 응용 프로그램을 관찰할 때 이벤트 기반 API 앞에 API 게이트웨이를 배치할 수 있다.\nRESTful API vs. GraphQL API vs. gRPC API vs. SOAP API API(Application Programming Interface)는 서로 다른 소프트웨어 시스템 간의 통신을 가능하게 하는 중요한 도구이다.\nRESTful API REST(Representational State Transfer)는 2000년 Roy Fielding이 그의 박사 논문에서 제안한 아키텍처 스타일이다.\n핵심 특징 상태가 없음(Stateless): 각 요청은 독립적이며 서버는 클라이언트의 상태를 저장하지 않는다. 자원 기반(Resource-based): 모든 것이 자원으로 간주되며 고유한 URI로 식별된다. HTTP 메서드 활용: GET, POST, PUT, DELETE 등의 표준 HTTP 메서드를 사용한다. 표현(Representation): 자원은 JSON, XML 등 다양한 형식으로 표현될 수 있다. 작동 방식 RESTful API는 HTTP 프로토콜을 기반으로 작동한다.\n클라이언트가 HTTP 요청을 보내면 서버는 요청된 자원의 상태 표현을 반환한다.\n1 2 3 4 // 사용자 정보를 가져오는 RESTful API 호출 예시 fetch('https://api.example.com/users/123') .then(response =\u003e response.json()) .then(data =\u003e console.log(data)); GraphQL API GraphQL은 2015년 Facebook에서 개발한 쿼리 언어이자 런타임으로, 클라이언트가 필요한 데이터를 정확히 명시할 수 있게 해준다.\n핵심 특징 단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 전송된다. 클라이언트 주도 데이터 요청: 클라이언트가 정확히 필요한 데이터만 요청할 수 있다. 강력한。타입 시스템: 스키마를 통해 API의 가능한 모든 데이터를 정의한다. 실시간 기능: 구독(Subscription)을 통한 실시간 데이터 업데이트가 가능하다. 작동 방식 GraphQL은 클라이언트가 쿼리를 정의하여 필요한 데이터의 구조를 명시하고, 서버는 정확히 그 구조대로 데이터를 반환한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // GraphQL 쿼리 예시 const query = ` query { user(id: \"123\") { name email posts { title } } } `; fetch('https://api.example.com/graphql', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ query }) }) .then(response =\u003e response.json()) .then(data =\u003e console.log(data)); gRPC API gRPC는 2015년 Google이 개발한 고성능 오픈소스 RPC(Remote Procedure Call) 프레임워크이다.\n핵심 특징 Protocol Buffers: 효율적인 바이너리 직렬화 형식을 사용한다. 강력한 타입 체크: 서비스와 메시지 구조를.proto 파일로 정의한다. 다양한 언어 지원: 다양한 프로그래밍 언어로 클라이언트와 서버를 구현할 수 있다. 양방향 스트리밍: 클라이언트-서버 간 양방향 스트리밍을 지원한다. 작동 방식 gRPC는 HTTP/2 프로토콜을 기반으로 하며, Protocol Buffers를 사용하여 데이터를 직렬화한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # gRPC Python 클라이언트 예시 import grpc import user_pb2 import user_pb2_grpc # 채널 생성 channel = grpc.insecure_channel('localhost:50051') # 스텁 생성 stub = user_pb2_grpc.UserServiceStub(channel) # 요청 생성 request = user_pb2.UserRequest(id='123') # RPC 호출 response = stub.GetUser(request) print(response) SOAP API SOAP(Simple Object Access Protocol)은 1998년 Microsoft에서 개발한 XML 기반 메시징 프로토콜이다.\n핵심 특징 프로토콜 독립적: HTTP, SMTP, TCP 등 다양한 프로토콜 위에서 작동 가능하다. 강력한 표준화: WS-Security, WS-ReliableMessaging 등 다양한 확장 표준을 지원한다. 엄격한 계약: WSDL(Web Services Description Language)을 통해 서비스를 정의한다. 내장된 오류 처리: SOAP 메시지 구조에 오류 처리 메커니즘이 포함되어 있다. 작동 방식 SOAP는 XML 형식의 메시지를 교환하며, 엔벨로프, 헤더, 본문으로 구성된 구조를 가진다.\n1 2 3 4 5 6 7 8 9 10 11 ","wordCount":"2170","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-26T06:08:00Z","dateModified":"2025-02-26T06:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend/api-design/api-styles-and-types/api-styles/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/>APIs</a></div><h1 class="post-title entry-hint-parent">API Styles</h1><div class=post-description>API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다.</div><div class=post-meta><span title='2025-02-26 06:08:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend/API%20Design/API%20Styles%20and%20Types/API-Styles.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#api-styles>API Styles</a><ul><li><a href=#resource-style-리소스-스타일>Resource Style (리소스 스타일)</a></li><li><a href=#hypermedia-style-하이퍼미디어-스타일>Hypermedia Style (하이퍼미디어 스타일)</a></li><li><a href=#query-style-쿼리-스타일>Query Style (쿼리 스타일)</a></li><li><a href=#tunnel-style-터널-스타일>Tunnel Style (터널 스타일)</a></li><li><a href=#event-based-style-이벤트-기반-스타일>Event-based Style (이벤트 기반 스타일)</a></li></ul></li><li><a href=#restful-api-vs-graphql-api-vs-grpc-api-vs-soap-api>RESTful API vs. GraphQL API vs. gRPC API vs. SOAP API</a><ul><li><a href=#restful-api>RESTful API</a></li><li><a href=#graphql-api>GraphQL API</a></li><li><a href=#grpc-api>gRPC API</a></li><li><a href=#soap-api>SOAP API</a></li><li><a href=#api-유형별-비교-분석>API 유형별 비교 분석</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=api-styles>API Styles<a hidden class=anchor aria-hidden=true href=#api-styles>#</a></h2><p>API 스타일은 소프트웨어 아키텍처에서 중요한 설계 요소로, 다양한 시스템과 장치가 서로 쉽게 통신할 수 있도록 디지털 방식으로 연결하는 역할을 한다.<br>새로운 API를 구축할 때 개발자는 API 설계와 API가 외부 세계와 상호 작용하는 방식을 API 스타일과 기술을 선택하여 고려한다.</p><ul><li>Resource style</li><li>Hypermedia style</li><li>Query style</li><li>Tunnel style</li><li>Event-based style</li></ul><h3 id=resource-style-리소스-스타일>Resource Style (리소스 스타일)<a hidden class=anchor aria-hidden=true href=#resource-style-리소스-스타일>#</a></h3><p>Resource style (리소스 스타일)은 리소스 지향적이다.<br>오늘날 많은 API가 리소스 스타일을 사용하며, 이는 리소스 지향적 API를 설명하는 가장 일반적인 방법인 OpenAPI의 인기로 쉽게 확인할 수 있다.<br>이 스타일에서 주요 초점은 소비자가 이러한 리소스와 상호 작용할 수 있도록 어떤 리소스를 노출할 것인지에 있다.</p><p>이 컨텍스트에서 &ldquo;리소스"는 웹 사이트를 설계할 때 웹 페이지와 같은 리소스에 있는 범위와 유사하다.<br>리소스의 개념은 API 기능의 관련 측면을 노출하는 훌륭한 방법을 제공하는 동시에 리소스 뒤에 구현 세부 정보를 숨길 수 있다. 제품, 제품 카테고리 및 고객 정보와 같은 영구적인 개념에 대한 리소스가 있을 수 있다. 또한 제품 주문 또는 배송 옵션 선택과 같은 프로세스 지향적인 개념에 대한 리소스도 있을 수 있다.</p><p>REST(Representational state transfer)는 리소스 스타일에 대한 아키텍처 패턴이지만 REST가 구체적인 기술을 제공한다는 의미는 아니다.<br>REST의 경우 HTTP가 선호되는 프로토콜이다.<br>표현 형식의 경우 JSON이 다른 표현(예: JSON 이전의 XML)보다 훨씬 더 많이 사용된다고 말하는 것이 안전할 것입니다. 클라이언트 요청이 RESTful API를 통해 이루어지면 리소스 상태의 표현을 엔드포인트로 전송한다.</p><p>백엔드 HTTP 엔드포인트와 통합된 많은 리소스 컬렉션으로 REST API를 개발할 때 Apache APISIX와 같은 API 게이트웨이의 기능을 사용하여 생성부터 프로덕션 API 모니터링까지 API 수명 주기를 지원할 수 있다. API 게이트웨이 REST API는 클라이언트가 서비스에 요청을 보내고 서비스가 동기적으로 응답하는 요청/응답 모델을 사용한다.</p><p>이 리소스 스타일에는 이러한 리소스 전반에 걸쳐 워크플로를 더 잘 나타내는 기능이 없다. 하이퍼미디어 스타일은 리소스 연결 문제를 해결하기 위해 리소스 스타일에 핵심 구성 요소를 추가한다.</p><h3 id=hypermedia-style-하이퍼미디어-스타일>Hypermedia Style (하이퍼미디어 스타일)<a hidden class=anchor aria-hidden=true href=#hypermedia-style-하이퍼미디어-스타일>#</a></h3><p>웹에서와 마찬가지로 각 리소스를 개별적으로 알고 브라우저의 주소 표시줄에 URI를 입력하는 대신 리소스 간의 링크를 사용하여 리소스 간의 가장 중요한 경로를 탐색할 수 있다.<br>하이퍼미디어 스타일은 API의 리소스에 대해 동일한 작업을 수행한다.</p><p>웹에서 사람은 페이지를 읽고 따라갈 링크를 결정한다.<br>하이퍼미디어 API의 경우 일반적으로 컴퓨터가 이 결정을 내린다. 즉, 컴퓨터가 사용 가능한 옵션을 식별하고 선택할 수 있도록 링크에 컴퓨터가 읽을 수 있는 레이블이 필요하다. 이러한 레이블은 웹 페이지에서 사람이 클릭하는 링크의 텍스트와 개념적으로 유사하지만 레이블은 리소스의 컴퓨터가 읽을 수 있는 표현(종종 JSON)으로 표현된다. 하이퍼미디어 API에서는 리소스 간의 링크를 사용하여 리소스를 &ldquo;탐색"할 수 있다.</p><p>이 리소스 스타일에는 때때로 HATEOAS가 필요하며, 이는 Hypermedia As The Engine Of Application State의 약자이다. HATEOAS는 동적 리소스 라우팅을 허용하는 REST의 측면이다.</p><p>리소스 스타일 API에 비해 하이퍼미디어 API에는 두 가지 주요 이점이 있다.</p><ul><li>다음 단계에서 사용 가능한 리소스를 선택하는 데 필요한 모든 링크를 제공한다.</li><li>링크는 리소스에 걸쳐 있으며 하나 이상의 API가 이러한 리소스를 제공하는지 여부는 중요하지 않다.</li></ul><p>하이퍼미디어 스타일은 API 소비자가 API와 제공하는 리소스를 검색하는 데 필요한 지식을 제공하므로 이 모든 것이 매우 긍정적으로 들린다. 스택에서 사용되는 프로그래밍 언어와 프레임워크를 사용하여 하이퍼미디어 기반 REST 서비스를 구축할 수 있다.</p><p>그러나 탐색의 용이성으로 인해 독자가 자료를 건너뛰고 파편화된 정보를 얻을 위험이 증가할 수 있다. 또한 클라이언트와 서버가 데이터를 공유하므로 클라이언트가 필요한 모든 정보에 액세스하려면 여러 번 상호 작용해야 하는 &ldquo;수다스러운&rdquo; API가 될 수 있다.<br>API 엔드포인트가 여러 백엔드 서비스(마이크로서비스 및 서버리스 API)에 의해 노출되면 어떻게 될까? 응답 집계기/작성기(response aggregator/composer) 기능이 있는 API 게이트웨이를 활용하여 이 문제를 해결할 수 있다.</p><h3 id=query-style-쿼리-스타일>Query Style (쿼리 스타일)<a hidden class=anchor aria-hidden=true href=#query-style-쿼리-스타일>#</a></h3><p>쿼리 스타일은 잠재적으로 많은 리소스 세트에 액세스하기 위한 단일 진입점을 제공하므로 리소스 및 하이퍼미디어 스타일과 다르다.<br>쿼리 스타일의 아이디어는 이러한 리소스가 API 공급자가 구조화된 형태로 관리한다는 것이다. 이 구조를 쿼리할 수 있으며 응답에는 쿼리 결과가 포함된다. 어느 수준에서는 이것이 데이터베이스가 작동하는 방식과 유사하다. 데이터베이스는 저장하는 데이터에 대한 기본 데이터 모델과 해당 데이터의 일부를 선택하고 검색할 수 있는 쿼리 언어를 가지고 있다.</p><p>쿼리 스타일의 한 가지 이점은 각 소비자가 원하는 것을 정확히 요청할 수 있다는 것이다. 즉, 잘 구성된 쿼리를 사용하면 리소스/하이퍼미디어 API에서 수많은 요청이 필요했을 결과를 결합할 수 있다. 예를 들어 여러 HTTP 요청을 다른 엔드포인트로 보내는 대신 필요한 모든 것에 대한 단일 &ldquo;쿼리"를 POST할 수 있다.</p><p>쿼리 스타일의 경우 GraphQL이 SPA(단일 페이지 응용 프로그램)를 구축하는 데 가장 많이 사용되는 선택이다. 클라이언트 측 응용 프로그램에서 데이터베이스를 쿼리하기 위한 언어이다. GraphQL의 가장 큰 장점은 JSON 기반 에코 시스템에 연결된다는 것이다. GraphQL은 쿼리에 JSON을 사용하지 않지만 JSON으로 결과를 반환하므로 JSON 중심 환경에서 쉽게 처리할 수 있다.</p><p>쿼리 스타일에는 장점에 비해 무시할 만한 단점이 있지만 쿼리 복잡성은 그 중 하나이다. API 소비자는 기본 데이터 및 쿼리 모델에 대한 좋은 이해가 필요하다(쿼리 API를 올바르게 사용하는 방법과 재귀를 피하거나 너무 많은 중첩된 리소스를 가져오지 않도록 효율적인 요청을 수행하는 방법을 알 수 있도록). 또한 REST API에는 여러 엔드포인트가 있기 때문에 리소스 스타일보다 GraphQL로 단순화된 캐시를 구현하는 것이 더 복잡하다. 네이티브 HTTP 캐싱을 활용하여 리소스를 다시 가져오는 것을 피할 수 있다. GraphQL의 또 다른 문제는 &ldquo;이 요청 수만 허용된다"고 말하는 속도 제한이다.</p><p>그럼에도 불구하고 마지막 두 가지 단점(캐싱 및 속도 제한)은 클라이언트와 데이터 저장소 사이에 API 게이트웨이를 도입하여 해결할 수 있다. 예를 들어 오픈 소스 Apache APISIX API 게이트웨이는 GraphQL 구문을 인식할 수 있다. 요청에 전달된 GraphQL 문을 효율적으로 일치시킴으로써 비정상적인 트래픽을 필터링하여 속도 제한 정책을 추가로 적용하고 캐싱 기능을 통해 시스템 성능을 향상시킬 수 있다.</p><h3 id=tunnel-style-터널-스타일>Tunnel Style (터널 스타일)<a hidden class=anchor aria-hidden=true href=#tunnel-style-터널-스타일>#</a></h3><p>터널 스타일에서 API는 원격으로 호출되는 함수 모음이다.<br>API는 노출된 모든 프로시저를 API로 사용할 수 있는 로컬 프로그래밍 시나리오의 단순한 확장 프로그램이 된다. 터널 스타일은 API를 만드는 데 최소한의 노력을 기울일 수 있으므로 개발자에게 편리하다.</p><p>이 스타일에서 사용되는 일반적인 기술은 RPC(원격 프로시저 호출) 방법이다.<br>RPC는 클라이언트가 특정 프로시저를 실행하기 위해 원격 서버에 요청을 보내고 클라이언트가 응답을 수신하는 요청-응답 프로토콜이다. 그러나 RPC API는 REST API보다 유지 관리하고 업데이트하기가 훨씬 더 어렵기 때문에 RPC API는 최신 API 개발에서 그다지 많이 사용되지 않는다.</p><p>gRPC는 효율적인 터널 스타일(RPC) 구현이며 분산 시스템에 적합하다. 많은 언어와 플랫폼에 대한 SDK가 있으므로 플랫폼과 언어 간 통신에 광범위하게 사용할 수 있다. gRPC는 최적화된 이진 전송을 위한 HTTP/2 표준인 프로토콜 버퍼(protobufs)를 사용하여 직렬화 및 역직렬화하고 (긴) 폴링 및 차단 HTTP 호출을 방지하기 위해 양방향 스트리밍을 사용하기 때문에 빠르고 효율적이다.</p><p>도구는 API로 프로시저를 노출할 수 있으며, 여기서 &ldquo;API 생성&rdquo; 작업의 대부분을 자동화할 수 있다. API를 보호하기 위한 일부 관리 계층이 여전히 있어야 한다. 서로 다른 API 프로토콜이 시스템에서 사용되는 경우 API 게이트웨이와 gRPC 프록시 기능과 같은 구성 요소를 사용하여 페이로드를 동일한 전송(REST에서 gRPC 또는 그 반대로)을 통해 한 형식에서 다른 형식으로 변환하여 해결할 수 있다.</p><h3 id=event-based-style-이벤트-기반-스타일>Event-based Style (이벤트 기반 스타일)<a hidden class=anchor aria-hidden=true href=#event-based-style-이벤트-기반-스타일>#</a></h3><p>이벤트 기반 스타일에서는 API 제공자가 API 소비자에게 요청하는 대신 API 소비자에게 전달되는 이벤트를 만든다.<br>소비 응용 프로그램은 API의 특정 기록 또는 기록의 상태 변경에 대한 정보를 받을 것으로 예상한다.<br>이벤트 기반 API를 구현할 때 고려해야 할 많은 방법과 기술 옵션이 있다.</p><p>또 다른 접근 방식은 이벤트 소비자가 이벤트 생산자와 분리하는 메시지 브로커에 연결하는 것이다. 메시지 브로커는 이벤트를 관리하고 소비자는 브로커가 이 유형의 이벤트가 구독자에게 전달되도록 특정 이벤트 유형을 구독해야 한다. 이 경우 아키텍처는 전달 브로커를 중심으로 하며 모든 이벤트 생산자와 소비자가 브로커에 연결된다.<br>이 경우 고려해야 할 좋은 기술은 확장성이 뛰어나고 탄력적인 Apache Kafka이다.</p><p>이벤트 기반 스타일을 선택할 때의 몇 가지 단점은 다른 스타일에 비해 구현하는 데 시간이 더 오래 걸리고 스타일이 올바르게 적용되지 않으면 다른 서비스에서 여러 개의 중복 메시지를 트리거할 수 있으며 이벤트 흐름을 효과적으로 모니터링하기 위해 타사 도구를 추가하지 않으면 오류 처리 및 문제 해결이 어려울 수 있다는 것이다.<br>그러나 여러 모니터링 플랫폼에 대한 간단한 기본 제공 통합을 통해 최신 응용 프로그램을 관찰할 때 이벤트 기반 API 앞에 API 게이트웨이를 배치할 수 있다.</p><h2 id=restful-api-vs-graphql-api-vs-grpc-api-vs-soap-api>RESTful API vs. GraphQL API vs. gRPC API vs. SOAP API<a hidden class=anchor aria-hidden=true href=#restful-api-vs-graphql-api-vs-grpc-api-vs-soap-api>#</a></h2><p>API(Application Programming Interface)는 서로 다른 소프트웨어 시스템 간의 통신을 가능하게 하는 중요한 도구이다.</p><h3 id=restful-api>RESTful API<a hidden class=anchor aria-hidden=true href=#restful-api>#</a></h3><p>REST(Representational State Transfer)는 2000년 Roy Fielding이 그의 박사 논문에서 제안한 아키텍처 스타일이다.</p><h4 id=핵심-특징>핵심 특징<a hidden class=anchor aria-hidden=true href=#핵심-특징>#</a></h4><ul><li><strong>상태가 없음(Stateless)</strong>: 각 요청은 독립적이며 서버는 클라이언트의 상태를 저장하지 않는다.</li><li><strong>자원 기반(Resource-based)</strong>: 모든 것이 자원으로 간주되며 고유한 URI로 식별된다.</li><li><strong>HTTP 메서드 활용</strong>: GET, POST, PUT, DELETE 등의 표준 HTTP 메서드를 사용한다.</li><li><strong>표현(Representation)</strong>: 자원은 JSON, XML 등 다양한 형식으로 표현될 수 있다.</li></ul><h4 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h4><p>RESTful API는 HTTP 프로토콜을 기반으로 작동한다.<br>클라이언트가 HTTP 요청을 보내면 서버는 요청된 자원의 상태 표현을 반환한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 사용자 정보를 가져오는 RESTful API 호출 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;https://api.example.com/users/123&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>data</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=graphql-api>GraphQL API<a hidden class=anchor aria-hidden=true href=#graphql-api>#</a></h3><p>GraphQL은 2015년 Facebook에서 개발한 쿼리 언어이자 런타임으로, 클라이언트가 필요한 데이터를 정확히 명시할 수 있게 해준다.</p><h4 id=핵심-특징-1>핵심 특징<a hidden class=anchor aria-hidden=true href=#핵심-특징-1>#</a></h4><ul><li><strong>단일 엔드포인트</strong>: 모든 요청이 하나의 엔드포인트로 전송된다.</li><li><strong>클라이언트 주도 데이터 요청</strong>: 클라이언트가 정확히 필요한 데이터만 요청할 수 있다.</li><li><strong>강력한。타입 시스템</strong>: 스키마를 통해 API의 가능한 모든 데이터를 정의한다.</li><li><strong>실시간 기능</strong>: 구독(Subscription)을 통한 실시간 데이터 업데이트가 가능하다.</li></ul><h4 id=작동-방식-1>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식-1>#</a></h4><p>GraphQL은 클라이언트가 쿼리를 정의하여 필요한 데이터의 구조를 명시하고, 서버는 정확히 그 구조대로 데이터를 반환한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// GraphQL 쿼리 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>query</span> <span class=o>=</span> <span class=sb>`
</span></span></span><span class=line><span class=cl><span class=sb>  query {
</span></span></span><span class=line><span class=cl><span class=sb>    user(id: &#34;123&#34;) {
</span></span></span><span class=line><span class=cl><span class=sb>      name
</span></span></span><span class=line><span class=cl><span class=sb>      email
</span></span></span><span class=line><span class=cl><span class=sb>      posts {
</span></span></span><span class=line><span class=cl><span class=sb>        title
</span></span></span><span class=line><span class=cl><span class=sb>      }
</span></span></span><span class=line><span class=cl><span class=sb>    }
</span></span></span><span class=line><span class=cl><span class=sb>  }
</span></span></span><span class=line><span class=cl><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;https://api.example.com/graphql&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>method</span><span class=o>:</span> <span class=s1>&#39;POST&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>headers</span><span class=o>:</span> <span class=p>{</span> <span class=s1>&#39;Content-Type&#39;</span><span class=o>:</span> <span class=s1>&#39;application/json&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>body</span><span class=o>:</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span> <span class=nx>query</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>data</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=grpc-api>gRPC API<a hidden class=anchor aria-hidden=true href=#grpc-api>#</a></h3><p>gRPC는 2015년 Google이 개발한 고성능 오픈소스 RPC(Remote Procedure Call) 프레임워크이다.</p><h4 id=핵심-특징-2>핵심 특징<a hidden class=anchor aria-hidden=true href=#핵심-특징-2>#</a></h4><ul><li><strong>Protocol Buffers</strong>: 효율적인 바이너리 직렬화 형식을 사용한다.</li><li><strong>강력한 타입 체크</strong>: 서비스와 메시지 구조를.proto 파일로 정의한다.</li><li><strong>다양한 언어 지원</strong>: 다양한 프로그래밍 언어로 클라이언트와 서버를 구현할 수 있다.</li><li><strong>양방향 스트리밍</strong>: 클라이언트-서버 간 양방향 스트리밍을 지원한다.</li></ul><h4 id=작동-방식-2>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식-2>#</a></h4><p>gRPC는 HTTP/2 프로토콜을 기반으로 하며, Protocol Buffers를 사용하여 데이터를 직렬화한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># gRPC Python 클라이언트 예시</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>grpc</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>user_pb2</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>user_pb2_grpc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 채널 생성</span>
</span></span><span class=line><span class=cl><span class=n>channel</span> <span class=o>=</span> <span class=n>grpc</span><span class=o>.</span><span class=n>insecure_channel</span><span class=p>(</span><span class=s1>&#39;localhost:50051&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 스텁 생성</span>
</span></span><span class=line><span class=cl><span class=n>stub</span> <span class=o>=</span> <span class=n>user_pb2_grpc</span><span class=o>.</span><span class=n>UserServiceStub</span><span class=p>(</span><span class=n>channel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 요청 생성</span>
</span></span><span class=line><span class=cl><span class=n>request</span> <span class=o>=</span> <span class=n>user_pb2</span><span class=o>.</span><span class=n>UserRequest</span><span class=p>(</span><span class=nb>id</span><span class=o>=</span><span class=s1>&#39;123&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># RPC 호출</span>
</span></span><span class=line><span class=cl><span class=n>response</span> <span class=o>=</span> <span class=n>stub</span><span class=o>.</span><span class=n>GetUser</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>response</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=soap-api>SOAP API<a hidden class=anchor aria-hidden=true href=#soap-api>#</a></h3><p>SOAP(Simple Object Access Protocol)은 1998년 Microsoft에서 개발한 XML 기반 메시징 프로토콜이다.</p><h4 id=핵심-특징-3>핵심 특징<a hidden class=anchor aria-hidden=true href=#핵심-특징-3>#</a></h4><ul><li><strong>프로토콜 독립적</strong>: HTTP, SMTP, TCP 등 다양한 프로토콜 위에서 작동 가능하다.</li><li><strong>강력한 표준화</strong>: WS-Security, WS-ReliableMessaging 등 다양한 확장 표준을 지원한다.</li><li><strong>엄격한 계약</strong>: WSDL(Web Services Description Language)을 통해 서비스를 정의한다.</li><li><strong>내장된 오류 처리</strong>: SOAP 메시지 구조에 오류 처리 메커니즘이 포함되어 있다.</li></ul><h4 id=작동-방식-3>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식-3>#</a></h4><p>SOAP는 XML 형식의 메시지를 교환하며, 엔벨로프, 헤더, 본문으로 구성된 구조를 가진다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=c>&lt;!-- SOAP 요청 예시 --&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;soap:Envelope</span> <span class=na>xmlns:soap=</span><span class=s>&#34;http://www.w3.org/2003/05/soap-envelope&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;soap:Header&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c>&lt;!-- 인증 정보 등 --&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/soap:Header&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;soap:Body&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;GetUser</span> <span class=na>xmlns=</span><span class=s>&#34;http://api.example.com/users&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nt>&lt;id&gt;</span>123<span class=nt>&lt;/id&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/GetUser&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/soap:Body&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/soap:Envelope&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=api-유형별-비교-분석>API 유형별 비교 분석<a hidden class=anchor aria-hidden=true href=#api-유형별-비교-분석>#</a></h3><h4 id=기본-개념-및-특징>기본 개념 및 특징<a hidden class=anchor aria-hidden=true href=#기본-개념-및-특징>#</a></h4><table><thead><tr><th>항목</th><th>RESTful API</th><th>GraphQL API</th><th>gRPC API</th><th>SOAP API</th></tr></thead><tbody><tr><td><strong>출시 연도</strong></td><td>2000년대 초반</td><td>2015년 (Facebook)</td><td>2016년 (Google)</td><td>1998년 (Microsoft)</td></tr><tr><td><strong>프로토콜</strong></td><td>HTTP/1.1</td><td>HTTP</td><td>HTTP/2</td><td>HTTP, SMTP, TCP</td></tr><tr><td><strong>데이터 형식</strong></td><td>JSON, XML</td><td>JSON</td><td>Protocol Buffers (Binary)</td><td>XML</td></tr><tr><td><strong>통신 모델</strong></td><td>요청-응답</td><td>쿼리/뮤테이션/서브스크립션</td><td>단방향/양방향 스트리밍</td><td>요청-응답</td></tr><tr><td><strong>상태 관리</strong></td><td>무상태 (Stateless)</td><td>무상태</td><td>무상태 또는 상태 유지</td><td>상태 유지 또는 무상태</td></tr><tr><td><strong>엔드포인트</strong></td><td>다수의 엔드포인트</td><td>단일 엔드포인트</td><td>서비스 정의 기반</td><td>단일 엔드포인트</td></tr><tr><td><strong>문서화</strong></td><td>OpenAPI/Swagger</td><td>GraphQL 스키마/Introspection</td><td>Protobuf 파일</td><td>WSDL</td></tr><tr><td><strong>커뮤니티/생태계</strong></td><td>매우 활발함</td><td>활발하게 성장 중</td><td>성장 중</td><td>감소 추세</td></tr><tr><td><strong>구현 복잡성</strong></td><td>낮음</td><td>중간</td><td>중간</td><td>높음</td></tr></tbody></table><h4 id=기술적-차이점>기술적 차이점<a hidden class=anchor aria-hidden=true href=#기술적-차이점>#</a></h4><table><thead><tr><th>항목</th><th>RESTful API</th><th>GraphQL API</th><th>gRPC API</th><th>SOAP API</th></tr></thead><tbody><tr><td><strong>성능</strong></td><td>중간 (JSON 처리 오버헤드)</td><td>높음 (필요한 데이터만 요청)</td><td>매우 높음 (이진 직렬화 + HTTP/2)</td><td>낮음 (XML 처리 오버헤드)</td></tr><tr><td><strong>보안</strong></td><td>HTTPS + OAuth/JWT</td><td>HTTPS + 사용자 정의 인증</td><td>TLS 1.3 + mTLS</td><td>WS-Security (XML 암호화)</td></tr><tr><td><strong>스트리밍 지원</strong></td><td>제한적 (SSE/WebSocket 필요)</td><td>서버 푸시 가능 (서브스크립션)</td><td>네이티브 지원 (양방향 스트리밍)</td><td>지원하지 않음</td></tr><tr><td><strong>스키마 관리</strong></td><td>없음 (OpenAPI/Swagger로 문서화)</td><td>강력한 타입 시스템 (Schema 정의 필수)</td><td>.proto 파일로 명시적 정의</td><td>WSDL로 엄격한 정의</td></tr><tr><td><strong>에러 처리</strong></td><td>HTTP 상태 코드 (200, 404 등)</td><td>사용자 정의 오류 메시지</td><td>상태 코드 + 상세 오류 메타데이터</td><td>SOAP Fault 요소</td></tr></tbody></table><h4 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h4><table><thead><tr><th>항목</th><th>RESTful API</th><th>GraphQL API</th><th>gRPC API</th><th>SOAP API</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>- 간단하고 널리 지원<br>- 캐싱 가능<br>- 유연한 데이터 형식</td><td>- 필요한 데이터만 요청<br>- 단일 엔드포인트<br>- 실시간 업데이트</td><td>- 초고속 성능<br>- 코드 생성 지원<br>- 스트리밍 최적화</td><td>- 강력한 보안 (WS-Security)<br>- 트랜잭션 지원 (ACID)<br>- 엔터프라이즈 호환성</td></tr><tr><td><strong>단점</strong></td><td>- 과도한 데이터 요청 (Over/Under-fetching)<br>- 버전 관리 복잡</td><td>- 학습 곡선 가파름<br>- 캐싱 어려움<br>- 복잡한 쿼리 최적화 필요</td><td>- 브라우저 지원 제한<br>- 디버깅 어려움<br>- 유연성 부족</td><td>- 복잡한 XML 구조<br>- 높은 대역폭 사용<br>- 느린 처리 속도</td></tr></tbody></table><h4 id=사용-사례>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h4><table><thead><tr><th>API 유형</th><th>주요 사용 사례</th></tr></thead><tbody><tr><td><strong>RESTful API</strong></td><td>- 일반적인 웹 서비스 (CRUD 중심)<br>- 모바일 앱 백엔드<br>- 공개 API (GitHub, Twitter)</td></tr><tr><td><strong>GraphQL API</strong></td><td>- 복잡한 데이터 요청 (SNS 피드)<br>- 실시간 대시보드<br>- 프론트엔드 주도 개발</td></tr><tr><td><strong>gRPC API</strong></td><td>- 마이크로서비스 통신<br>IoT 디바이스<br>- 고성능 분산 시스템 (금융 거래)</td></tr><tr><td><strong>SOAP API</strong></td><td>- 은행/의료 시스템<br>- 엔터프라이즈 애플리케이션 통합<br>- 레거시 시스템 연동</td></tr></tbody></table><h4 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h4><pre class=mermaid>1. **RESTful API 선택 시**:
   - 빠른 개발이 필요할 때
   - 간단한 CRUD 작업이 주인 경우
   - 브라우저 호환성이 중요할 때

2. **GraphQL 선택 시**:
   - 클라이언트가 데이터 요구사항이 복잡할 때
   - 실시간 업데이트가 필요한 경우 (채팅, 알림)
   - 단일 엔드포인트로 여러 리소스를 통합해야 할 때

3. **gRPC 선택 시**:
   - 마이크로서비스 간 고속 통신이 필요할 때
   - 양방향 스트리밍이 필요한 경우 (예: 실시간 주가)
   - 언어 중립적인 환경에서 작업할 때

4. **SOAP 선택 시**:
   - 엄격한 보안과 트랜잭션이 필요한 경우
   - 레거시 시스템과 통합해야 할 때
   - WS-* 표준을 준수해야 할 때
</pre><table><thead><tr><th>API 유형</th><th>강점 영역</th><th>약점 영역</th></tr></thead><tbody><tr><td><strong>RESTful API</strong></td><td>유연성, 넓은 생태계</td><td>성능, 복잡한 쿼리 처리</td></tr><tr><td><strong>GraphQL API</strong></td><td>데이터 효율성, 실시간 기능</td><td>학습 비용, 스키마 관리</td></tr><tr><td><strong>gRPC API</strong></td><td>성능, 마이크로서비스 통신</td><td>브라우저 지원, 유연성 부족</td></tr><tr><td><strong>SOAP API</strong></td><td>보안, 엔터프라이즈 호환성</td><td>복잡성, 성능 저하</td></tr></tbody></table><p><strong>최적의 선택</strong>은 프로젝트의 요구사항(성능, 보안, 통신 유형)과 팀의 기술 스택에 따라 달라진다. REST는 범용성, GraphQL은 유연성, gRPC는 성능, SOAP는 엔터프라이즈 요구사항에 각각 최적화되어 있다.</p><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><p><a href=https://www.redhat.com/en/blog/api-styles>How to choose the right API style and technology for your software architecture</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/api-styles/>API-Styles</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/><span class=title>« Prev</span><br><span>Clean Code</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/fundamentals/encoding-and-decoding/character/types/ansi/><span class=title>Next »</span><br><span>ANSI</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>