<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>jwt vs. Basic Authentication | hyunyoun's Blog</title>
<meta name=keywords content="Backend,API-Design,Authentication-Methods,JWT"><meta name=description content="JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다. Basic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-basic-authentication/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-basic-authentication/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-basic-authentication/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="jwt vs. Basic Authentication"><meta property="og:description" content="JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다. Basic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-02T02:49:00+00:00"><meta property="article:modified_time" content="2025-04-02T02:49:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Authentication-Methods"><meta property="article:tag" content="JWT"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="jwt vs. Basic Authentication"><meta name=twitter:description content="JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다. Basic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"APIs","item":"https://buenhyden.github.io/posts/backend/api-design/"},{"@type":"ListItem","position":4,"name":"Authentication Methods","item":"https://buenhyden.github.io/posts/backend/api-design/authentication-methods/"},{"@type":"ListItem","position":5,"name":"JWT","item":"https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/"},{"@type":"ListItem","position":6,"name":"jwt vs. Basic Authentication","item":"https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-basic-authentication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"jwt vs. Basic Authentication","name":"jwt vs. Basic Authentication","description":"JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다. \r\rBasic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다.","keywords":["Backend","API-Design","Authentication-Methods","JWT"],"articleBody":"Jwt vs. Basic Authentication JWT(JSON Web Token) 개요 JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA를 사용한 공개/개인 키 쌍으로 서명될 수 있다.\n구조 JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분된다:\n헤더(Header): 토큰 유형과 사용된 서명 알고리즘을 지정한다. 페이로드(Payload): 클레임(claim)이라고 불리는 엔티티와 추가 데이터를 포함한다. 서명(Signature): 헤더와 페이로드를 인코딩한 값과 비밀 키를 사용하여 생성된 서명이다. 결과적으로 JWT는 다음과 같은 형태를 가진다:\nxxxxx.yyyyy.zzzzz 작동 방식 사용자가 자격 증명(보통 사용자 이름과 비밀번호)으로 로그인한다. 서버는 자격 증명을 검증하고, 비밀 키를 사용하여 JWT를 생성한다. 서버는 JWT를 클라이언트에게 반환한다. 클라이언트는 JWT를 로컬 스토리지나 쿠키에 저장하고, 이후의 요청에 이 토큰을 Authorization 헤더에 포함시킨다. 서버는 토큰의 서명을 검증하고, 요청을 처리한다. 토큰이 만료되면 사용자는 다시 로그인하거나 리프레시 토큰을 사용해야 한다. 장점 무상태(Stateless): 서버가 사용자 세션 정보를 저장할 필요가 없어 확장성이 좋다. 자급자족(Self-contained): 토큰 자체에 필요한 모든 정보를 포함한다. 크로스 도메인: 다른 도메인 간에도 쉽게 사용할 수 있다. 유연성: 다양한 정보를 페이로드에 포함할 수 있다. 확장성: 분산 시스템과 마이크로서비스 아키텍처에 적합하다. 모바일 호환성: 모바일 애플리케이션에서도 쉽게 사용 가능하다. 단점 토큰 크기: 페이로드에 많은 정보를 포함하면 크기가 커질 수 있다. 보안 관리: 토큰이 탈취되면 만료될 때까지 액세스를 차단하기 어렵다. 키 관리: 서명 키의 보안 유지가 중요하다. 구현 복잡성: 기본 인증보다 구현이 복잡할 수 있다. 클라이언트 저장소: 토큰을 클라이언트 측에 안전하게 저장하는 메커니즘이 필요하다. 기본 인증(Basic Authentication) 개요 기본 인증은 HTTP 프로토콜의 일부로, RFC 7617에 정의되어 있다. 이는 HTTP 요청에 사용자 자격 증명을 직접 포함시키는 가장 단순한 인증 방식 중 하나이다.\n구조 기본 인증은 “Authorization” HTTP 헤더를 사용하며, 다음과 같은 형식을 가진다:\nAuthorization: Basic 여기서 는 “사용자 이름:비밀번호” 문자열을 Base64로 인코딩한 값이다.\n작동 방식 클라이언트가 보호된 리소스에 접근을 시도한다. 서버는 401 Unauthorized 응답과 함께 “WWW-Authenticate: Basic” 헤더를 반환한다. 브라우저는 사용자에게 자격 증명을 요청하는 팝업을 표시한다. 사용자가 자격 증명을 입력하면, 브라우저는 사용자 이름과 비밀번호를 콜론으로 결합하고 Base64로 인코딩한다. 브라우저는 “Authorization: Basic [인코딩된 자격 증명]” 헤더와 함께 요청을 재전송한다. 서버는 자격 증명을 확인하고 유효하면 요청된 리소스에 접근을 허용한다. 장점 단순성: 구현이 매우 간단하다. 표준 호환성: HTTP 프로토콜에 내장되어 있어 대부분의 클라이언트가 지원한다. 무상태: 서버 측에서 상태를 유지할 필요가 없다. 빠른 설정: 개발 환경이나 간단한 시스템에서 빠르게 설정할 수 있다. 직관적: 이해하기 쉽고 디버깅이 간단하다. 단점 보안 취약점: 자격 증명이 단순히 Base64로 인코딩되므로, HTTPS 없이는 매우 취약하다. 자격 증명 노출: 모든 요청마다 자격 증명이 전송된다. 제한된 기능: 추가 정보나 권한을 전달하는 메커니즘이 없다. 로그아웃 메커니즘 부재: 표준화된 로그아웃 방법이 없다. 사용자 경험: 브라우저의 기본 팝업은 사용자 경험이 좋지 않다. 자격 증명 변경: 자격 증명이 변경되면 모든 클라이언트를 업데이트해야 한다. 성능 및 확장성 비교 JWT 네트워크 오버헤드: 토큰 크기가 클 수 있어 네트워크 오버헤드가 발생할 수 있다. 처리 속도: 서명 검증에 약간의 CPU 리소스가 필요하다. 확장성: 서버 측 상태를 저장하지 않아 수평적 확장이 용이하다. 캐싱 효율: 토큰이 클라이언트 측에 저장되므로 서버 캐시 부담이 감소한다. 기본 인증 네트워크 오버헤드: 상대적으로 작은 헤더 크기로 네트워크 오버헤드가 적다. 처리 속도: 단순한 Base64 디코딩만 필요하므로 빠르다. 확장성: 무상태 특성으로 확장이 용이하지만, 사용자 DB 조회가 필요하다. 캐싱 효율: 매 요청마다 자격 증명을 검증해야 한다. 보안 비교 JWT 전송 중 보안: HTTPS와 함께 사용하면 안전하다. 저장 보안: 클라이언트 측 저장소(로컬 스토리지, 쿠키)의 보안에 의존한다. 토큰 탈취: 토큰이 탈취되면 만료될 때까지 악용될 수 있다. 키 관리: 서명 키의 보안이 중요하다. 취약점: XSS(Cross-Site Scripting) 공격에 취약할 수 있다. 기본 인증 전송 중 보안: 반드시 HTTPS와 함께 사용해야 한다. 저장 보안: 사용자 자격 증명이 서버에 안전하게 저장되어야 한다. 취약점: 중간자 공격, 네트워크 스니핑에 매우 취약하다. 사용 사례 비교 JWT에 적합한 사례 단일 페이지 애플리케이션(SPA): 프론트엔드와 백엔드가 분리된 아키텍처 마이크로서비스: 분산된 서비스 간 인증 모바일 애플리케이션: 네이티브 모바일 앱과 서버 간 통신 API 게이트웨이: API 관리 및 액세스 제어 크로스 도메인 인증: 여러 도메인 간의 인증 공유 기본 인증에 적합한 사례 내부 도구 및 관리 인터페이스: 제한된 사용자가 접근하는 내부 시스템 개발 환경: 빠른 설정이 필요한 개발 및 테스트 환경 API 디버깅: 간단한 API 테스트 및 디버깅 단순한 B2B API: 비즈니스 간 통합을 위한 단순한 API 레거시 시스템 통합: 기존 기본 인증을 사용하는 시스템과의 호환성 구현 복잡성 JWT\nJWT 구현은 일반적으로 다음과 같은 단계를 포함한다: JWT 라이브러리 선택 및 통합 생성 및 서명 로직 구현 검증 및 파싱 로직 구현 갱신 메커니즘 설계 언트 측 토큰 저장 및 전송 구현 기본 인증\n기본 인증 구현은 매우 간단하다: 인코딩/디코딩 로직 구현 (대부분의 라이브러리에 내장) 증명 검증 로직 구현 언트에 Authorization 헤더 추가 표준 및 호환성 JWT\nRFC 7519에 정의된 표준 대부분의 현대적인 웹 프레임워크 및 라이브러리에서 지원 OAuth 2.0 및 OpenID Connect와 잘 통합됨 기본 인증\nRFC 7617에 정의된 HTTP 표준의 일부 거의 모든 HTTP 클라이언트 및 서버에서 지원됨 레거시 시스템과의 호환성이 높음 Jwt vs. Basic Authentication 특성 JWT 기본 인증 작동 방식 서명된 JSON 토큰 Base64로 인코딩된 자격 증명 상태 관리 무상태(Stateless) 무상태(Stateless) 전송 방법 Authorization 헤더(Bearer) 또는 쿠키 Authorization 헤더(Basic) 데이터 포맷 헤더.페이로드.서명 사용자 이름:비밀번호 (Base64 인코딩) 보안 수준 중간~높음(서명 알고리즘에 따라) 낮음(HTTPS 필수) 암호화 서명됨(필요시 암호화 가능) 단순 인코딩(암호화 아님) 자격 증명 노출 직접 노출 없음(서버 측 검증) 매 요청마다 자격 증명 전송 구현 복잡성 중간~높음 매우 낮음 사용자 경험 원활함(배경에서 처리) 제한적(브라우저 기본 팝업) 로그아웃 메커니즘 클라이언트 측 토큰 삭제 미지원(표준 메커니즘 없음) 토큰 크기 중간~큼(페이로드에 따라) 작음(자격 증명 길이에 따라) 확장성 매우 좋음(완전 무상태) 좋음(DB 조회 필요) 처리 오버헤드 중간(서명 검증 필요) 낮음(간단한 디코딩) 크로스 도메인 쉬움 가능하지만 제한적 만료 관리 내장 기능(exp 클레임) 미지원(표준 메커니즘 없음) 권한 포함 가능(페이로드에 권한 정보 포함) 불가능(자격 증명만 전달) 토큰 취소 어려움(블랙리스트 필요) 자격 증명 변경으로 가능 리프레시 메커니즘 지원(리프레시 토큰 사용) 미지원 적합한 용도 SPA, 모바일 앱, 마이크로서비스 내부 도구, 개발 환경, 간단한 API 모바일 앱 지원 좋음 가능하지만 제한적 표준 준수 RFC 7519 RFC 7617 브라우저 지원 모든 현대 브라우저 거의 모든 브라우저 개발자 생태계 활발함(많은 라이브러리) 기본 지원(특별한 라이브러리 불필요) 디버깅 용이성 복잡함(디코딩 도구 필요) 매우 간단(Base64 디코딩) XSS 취약성 있음(로컬 스토리지 사용 시) 낮음(브라우저 관리) CSRF 취약성 낮음(Authorization 헤더 사용 시) 낮음(Authorization 헤더) 현대적인 인증 아키텍처와의 통합 현대 웹 애플리케이션은 종종 다양한 인증 방식을 조합하여 사용한다:\nOAuth 2.0 + JWT\nOAuth 2.0은 권한 부여 프레임워크로, JWT는 액세스 토큰 포맷으로 사용 소셜 로그인, 타사 API 통합 등에 적합 복잡한 권한 관리가 필요한 시스템에 유용 JWT + 세션 하이브리드\nJWT를 서버 측 세션 ID로 사용 토큰 무효화 등의 세션 관리와 JWT의 풍부한 페이로드 장점 결합 중간 규모 애플리케이션에 좋은 균형 제공 다층 인증 전략\n민감한 API는 추가 인증 레이어 적용 공개 API에는, 기본 인증이나 API 키 사용 사용자 인증에는 JWT 사용 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1044","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-02T02:49:00Z","dateModified":"2025-04-02T02:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-basic-authentication/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/>APIs</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/>Authentication Methods</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/>JWT</a></div><h1 class="post-title entry-hint-parent">jwt vs. Basic Authentication</h1><div class=post-description>JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다.
Basic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다.</div><div class=post-meta><span title='2025-04-02 02:49:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend/API%20Design/Authentication%20Methods/JWT/jwt-vs-basic-authentication.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#jwt-vs-basic-authentication>Jwt vs. Basic Authentication</a><ul><li><a href=#jwtjson-web-token>JWT(JSON Web Token)</a></li><li><a href=#기본-인증basic-authentication>기본 인증(Basic Authentication)</a></li><li><a href=#성능-및-확장성-비교>성능 및 확장성 비교</a></li><li><a href=#보안-비교>보안 비교</a></li><li><a href=#사용-사례-비교>사용 사례 비교</a></li><li><a href=#구현-복잡성>구현 복잡성</a></li><li><a href=#표준-및-호환성>표준 및 호환성</a></li><li><a href=#jwt-vs-basic-authentication-1>Jwt vs. Basic Authentication</a></li><li><a href=#현대적인-인증-아키텍처와의-통합>현대적인 인증 아키텍처와의 통합</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=jwt-vs-basic-authentication>Jwt vs. Basic Authentication<a hidden class=anchor aria-hidden=true href=#jwt-vs-basic-authentication>#</a></h2><h3 id=jwtjson-web-token>JWT(JSON Web Token)<a hidden class=anchor aria-hidden=true href=#jwtjson-web-token>#</a></h3><h4 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h4><p>JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA를 사용한 공개/개인 키 쌍으로 서명될 수 있다.</p><h4 id=구조>구조<a hidden class=anchor aria-hidden=true href=#구조>#</a></h4><p>JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분된다:</p><ol><li><strong>헤더(Header)</strong>: 토큰 유형과 사용된 서명 알고리즘을 지정한다.</li><li><strong>페이로드(Payload)</strong>: 클레임(claim)이라고 불리는 엔티티와 추가 데이터를 포함한다.</li><li><strong>서명(Signature)</strong>: 헤더와 페이로드를 인코딩한 값과 비밀 키를 사용하여 생성된 서명이다.</li></ol><p>결과적으로 JWT는 다음과 같은 형태를 가진다:</p><pre class=mermaid>xxxxx.yyyyy.zzzzz
</pre><h4 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h4><ol><li>사용자가 자격 증명(보통 사용자 이름과 비밀번호)으로 로그인한다.</li><li>서버는 자격 증명을 검증하고, 비밀 키를 사용하여 JWT를 생성한다.</li><li>서버는 JWT를 클라이언트에게 반환한다.</li><li>클라이언트는 JWT를 로컬 스토리지나 쿠키에 저장하고, 이후의 요청에 이 토큰을 Authorization 헤더에 포함시킨다.</li><li>서버는 토큰의 서명을 검증하고, 요청을 처리한다.</li><li>토큰이 만료되면 사용자는 다시 로그인하거나 리프레시 토큰을 사용해야 한다.</li></ol><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li><strong>무상태(Stateless)</strong>: 서버가 사용자 세션 정보를 저장할 필요가 없어 확장성이 좋다.</li><li><strong>자급자족(Self-contained)</strong>: 토큰 자체에 필요한 모든 정보를 포함한다.</li><li><strong>크로스 도메인</strong>: 다른 도메인 간에도 쉽게 사용할 수 있다.</li><li><strong>유연성</strong>: 다양한 정보를 페이로드에 포함할 수 있다.</li><li><strong>확장성</strong>: 분산 시스템과 마이크로서비스 아키텍처에 적합하다.</li><li><strong>모바일 호환성</strong>: 모바일 애플리케이션에서도 쉽게 사용 가능하다.</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>토큰 크기</strong>: 페이로드에 많은 정보를 포함하면 크기가 커질 수 있다.</li><li><strong>보안 관리</strong>: 토큰이 탈취되면 만료될 때까지 액세스를 차단하기 어렵다.</li><li><strong>키 관리</strong>: 서명 키의 보안 유지가 중요하다.</li><li><strong>구현 복잡성</strong>: 기본 인증보다 구현이 복잡할 수 있다.</li><li><strong>클라이언트 저장소</strong>: 토큰을 클라이언트 측에 안전하게 저장하는 메커니즘이 필요하다.</li></ul><h3 id=기본-인증basic-authentication>기본 인증(Basic Authentication)<a hidden class=anchor aria-hidden=true href=#기본-인증basic-authentication>#</a></h3><h4 id=개요-1>개요<a hidden class=anchor aria-hidden=true href=#개요-1>#</a></h4><p>기본 인증은 HTTP 프로토콜의 일부로, RFC 7617에 정의되어 있다. 이는 HTTP 요청에 사용자 자격 증명을 직접 포함시키는 가장 단순한 인증 방식 중 하나이다.</p><h4 id=구조-1>구조<a hidden class=anchor aria-hidden=true href=#구조-1>#</a></h4><p>기본 인증은 &ldquo;Authorization&rdquo; HTTP 헤더를 사용하며, 다음과 같은 형식을 가진다:</p><pre class=mermaid>Authorization: Basic &lt;credentials&gt;
</pre><p>여기서 <code>&lt;credentials></code>는 &ldquo;사용자 이름:비밀번호&rdquo; 문자열을 Base64로 인코딩한 값이다.</p><h4 id=작동-방식-1>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식-1>#</a></h4><ol><li>클라이언트가 보호된 리소스에 접근을 시도한다.</li><li>서버는 401 Unauthorized 응답과 함께 &ldquo;WWW-Authenticate: Basic&rdquo; 헤더를 반환한다.</li><li>브라우저는 사용자에게 자격 증명을 요청하는 팝업을 표시한다.</li><li>사용자가 자격 증명을 입력하면, 브라우저는 사용자 이름과 비밀번호를 콜론으로 결합하고 Base64로 인코딩한다.</li><li>브라우저는 &ldquo;Authorization: Basic [인코딩된 자격 증명]&rdquo; 헤더와 함께 요청을 재전송한다.</li><li>서버는 자격 증명을 확인하고 유효하면 요청된 리소스에 접근을 허용한다.</li></ol><h4 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h4><ul><li><strong>단순성</strong>: 구현이 매우 간단하다.</li><li><strong>표준 호환성</strong>: HTTP 프로토콜에 내장되어 있어 대부분의 클라이언트가 지원한다.</li><li><strong>무상태</strong>: 서버 측에서 상태를 유지할 필요가 없다.</li><li><strong>빠른 설정</strong>: 개발 환경이나 간단한 시스템에서 빠르게 설정할 수 있다.</li><li><strong>직관적</strong>: 이해하기 쉽고 디버깅이 간단하다.</li></ul><h4 id=단점-1>단점<a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h4><ul><li><strong>보안 취약점</strong>: 자격 증명이 단순히 Base64로 인코딩되므로, HTTPS 없이는 매우 취약하다.</li><li><strong>자격 증명 노출</strong>: 모든 요청마다 자격 증명이 전송된다.</li><li><strong>제한된 기능</strong>: 추가 정보나 권한을 전달하는 메커니즘이 없다.</li><li><strong>로그아웃 메커니즘 부재</strong>: 표준화된 로그아웃 방법이 없다.</li><li><strong>사용자 경험</strong>: 브라우저의 기본 팝업은 사용자 경험이 좋지 않다.</li><li><strong>자격 증명 변경</strong>: 자격 증명이 변경되면 모든 클라이언트를 업데이트해야 한다.</li></ul><h3 id=성능-및-확장성-비교>성능 및 확장성 비교<a hidden class=anchor aria-hidden=true href=#성능-및-확장성-비교>#</a></h3><ul><li>JWT<ul><li><strong>네트워크 오버헤드</strong>: 토큰 크기가 클 수 있어 네트워크 오버헤드가 발생할 수 있다.</li><li><strong>처리 속도</strong>: 서명 검증에 약간의 CPU 리소스가 필요하다.</li><li><strong>확장성</strong>: 서버 측 상태를 저장하지 않아 수평적 확장이 용이하다.</li><li><strong>캐싱 효율</strong>: 토큰이 클라이언트 측에 저장되므로 서버 캐시 부담이 감소한다.</li></ul></li><li>기본 인증<ul><li><strong>네트워크 오버헤드</strong>: 상대적으로 작은 헤더 크기로 네트워크 오버헤드가 적다.</li><li><strong>처리 속도</strong>: 단순한 Base64 디코딩만 필요하므로 빠르다.</li><li><strong>확장성</strong>: 무상태 특성으로 확장이 용이하지만, 사용자 DB 조회가 필요하다.</li><li><strong>캐싱 효율</strong>: 매 요청마다 자격 증명을 검증해야 한다.</li></ul></li></ul><h3 id=보안-비교>보안 비교<a hidden class=anchor aria-hidden=true href=#보안-비교>#</a></h3><ul><li>JWT<ul><li><strong>전송 중 보안</strong>: HTTPS와 함께 사용하면 안전하다.</li><li><strong>저장 보안</strong>: 클라이언트 측 저장소(로컬 스토리지, 쿠키)의 보안에 의존한다.</li><li><strong>토큰 탈취</strong>: 토큰이 탈취되면 만료될 때까지 악용될 수 있다.</li><li><strong>키 관리</strong>: 서명 키의 보안이 중요하다.</li><li><strong>취약점</strong>: XSS(Cross-Site Scripting) 공격에 취약할 수 있다.</li></ul></li><li>기본 인증<ul><li><strong>전송 중 보안</strong>: 반드시 HTTPS와 함께 사용해야 한다.</li><li><strong>저장 보안</strong>: 사용자 자격 증명이 서버에 안전하게 저장되어야 한다.</li><li><strong>취약점</strong>: 중간자 공격, 네트워크 스니핑에 매우 취약하다.</li></ul></li></ul><h3 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h3><ul><li>JWT에 적합한 사례<ul><li><strong>단일 페이지 애플리케이션(SPA)</strong>: 프론트엔드와 백엔드가 분리된 아키텍처</li><li><strong>마이크로서비스</strong>: 분산된 서비스 간 인증</li><li><strong>모바일 애플리케이션</strong>: 네이티브 모바일 앱과 서버 간 통신</li><li><strong>API 게이트웨이</strong>: API 관리 및 액세스 제어</li><li><strong>크로스 도메인 인증</strong>: 여러 도메인 간의 인증 공유</li></ul></li><li>기본 인증에 적합한 사례<ul><li><strong>내부 도구 및 관리 인터페이스</strong>: 제한된 사용자가 접근하는 내부 시스템</li><li><strong>개발 환경</strong>: 빠른 설정이 필요한 개발 및 테스트 환경</li><li><strong>API 디버깅</strong>: 간단한 API 테스트 및 디버깅</li><li><strong>단순한 B2B API</strong>: 비즈니스 간 통합을 위한 단순한 API</li><li><strong>레거시 시스템 통합</strong>: 기존 기본 인증을 사용하는 시스템과의 호환성</li></ul></li></ul><h3 id=구현-복잡성>구현 복잡성<a hidden class=anchor aria-hidden=true href=#구현-복잡성>#</a></h3><ul><li>JWT<br>JWT 구현은 일반적으로 다음과 같은 단계를 포함한다:<ol><li>JWT 라이브러리 선택 및 통합</li><li><ol start=2><li>생성 및 서명 로직 구현</li></ol></li><li><ol start=3><li>검증 및 파싱 로직 구현</li></ol></li><li><ol start=4><li>갱신 메커니즘 설계</li></ol></li><li><ol start=5><li>언트 측 토큰 저장 및 전송 구현</li></ol></li></ol></li><li>기본 인증<br>기본 인증 구현은 매우 간단하다:<ol><li>인코딩/디코딩 로직 구현 (대부분의 라이브러리에 내장)</li><li><ol start=2><li>증명 검증 로직 구현</li></ol></li><li><ol start=3><li>언트에 Authorization 헤더 추가</li></ol></li></ol></li></ul><h3 id=표준-및-호환성>표준 및 호환성<a hidden class=anchor aria-hidden=true href=#표준-및-호환성>#</a></h3><ol><li><p>JWT</p><ul><li>RFC 7519에 정의된 표준</li><li>대부분의 현대적인 웹 프레임워크 및 라이브러리에서 지원</li><li>OAuth 2.0 및 OpenID Connect와 잘 통합됨</li></ul></li><li><p>기본 인증</p><ul><li>RFC 7617에 정의된 HTTP 표준의 일부</li><li>거의 모든 HTTP 클라이언트 및 서버에서 지원됨</li><li>레거시 시스템과의 호환성이 높음</li></ul></li></ol><h3 id=jwt-vs-basic-authentication-1>Jwt vs. Basic Authentication<a hidden class=anchor aria-hidden=true href=#jwt-vs-basic-authentication-1>#</a></h3><table><thead><tr><th>특성</th><th>JWT</th><th>기본 인증</th></tr></thead><tbody><tr><td><strong>작동 방식</strong></td><td>서명된 JSON 토큰</td><td>Base64로 인코딩된 자격 증명</td></tr><tr><td><strong>상태 관리</strong></td><td>무상태(Stateless)</td><td>무상태(Stateless)</td></tr><tr><td><strong>전송 방법</strong></td><td>Authorization 헤더(Bearer) 또는 쿠키</td><td>Authorization 헤더(Basic)</td></tr><tr><td><strong>데이터 포맷</strong></td><td>헤더.페이로드.서명</td><td>사용자 이름:비밀번호 (Base64 인코딩)</td></tr><tr><td><strong>보안 수준</strong></td><td>중간~높음(서명 알고리즘에 따라)</td><td>낮음(HTTPS 필수)</td></tr><tr><td><strong>암호화</strong></td><td>서명됨(필요시 암호화 가능)</td><td>단순 인코딩(암호화 아님)</td></tr><tr><td><strong>자격 증명 노출</strong></td><td>직접 노출 없음(서버 측 검증)</td><td>매 요청마다 자격 증명 전송</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간~높음</td><td>매우 낮음</td></tr><tr><td><strong>사용자 경험</strong></td><td>원활함(배경에서 처리)</td><td>제한적(브라우저 기본 팝업)</td></tr><tr><td><strong>로그아웃 메커니즘</strong></td><td>클라이언트 측 토큰 삭제</td><td>미지원(표준 메커니즘 없음)</td></tr><tr><td><strong>토큰 크기</strong></td><td>중간~큼(페이로드에 따라)</td><td>작음(자격 증명 길이에 따라)</td></tr><tr><td><strong>확장성</strong></td><td>매우 좋음(완전 무상태)</td><td>좋음(DB 조회 필요)</td></tr><tr><td><strong>처리 오버헤드</strong></td><td>중간(서명 검증 필요)</td><td>낮음(간단한 디코딩)</td></tr><tr><td><strong>크로스 도메인</strong></td><td>쉬움</td><td>가능하지만 제한적</td></tr><tr><td><strong>만료 관리</strong></td><td>내장 기능(exp 클레임)</td><td>미지원(표준 메커니즘 없음)</td></tr><tr><td><strong>권한 포함</strong></td><td>가능(페이로드에 권한 정보 포함)</td><td>불가능(자격 증명만 전달)</td></tr><tr><td><strong>토큰 취소</strong></td><td>어려움(블랙리스트 필요)</td><td>자격 증명 변경으로 가능</td></tr><tr><td><strong>리프레시 메커니즘</strong></td><td>지원(리프레시 토큰 사용)</td><td>미지원</td></tr><tr><td><strong>적합한 용도</strong></td><td>SPA, 모바일 앱, 마이크로서비스</td><td>내부 도구, 개발 환경, 간단한 API</td></tr><tr><td><strong>모바일 앱 지원</strong></td><td>좋음</td><td>가능하지만 제한적</td></tr><tr><td><strong>표준 준수</strong></td><td>RFC 7519</td><td>RFC 7617</td></tr><tr><td><strong>브라우저 지원</strong></td><td>모든 현대 브라우저</td><td>거의 모든 브라우저</td></tr><tr><td><strong>개발자 생태계</strong></td><td>활발함(많은 라이브러리)</td><td>기본 지원(특별한 라이브러리 불필요)</td></tr><tr><td><strong>디버깅 용이성</strong></td><td>복잡함(디코딩 도구 필요)</td><td>매우 간단(Base64 디코딩)</td></tr><tr><td><strong>XSS 취약성</strong></td><td>있음(로컬 스토리지 사용 시)</td><td>낮음(브라우저 관리)</td></tr><tr><td><strong>CSRF 취약성</strong></td><td>낮음(Authorization 헤더 사용 시)</td><td>낮음(Authorization 헤더)</td></tr></tbody></table><h3 id=현대적인-인증-아키텍처와의-통합>현대적인 인증 아키텍처와의 통합<a hidden class=anchor aria-hidden=true href=#현대적인-인증-아키텍처와의-통합>#</a></h3><p>현대 웹 애플리케이션은 종종 다양한 인증 방식을 조합하여 사용한다:</p><ol><li><p>OAuth 2.0 + JWT</p><ul><li>OAuth 2.0은 권한 부여 프레임워크로, JWT는 액세스 토큰 포맷으로 사용</li><li>소셜 로그인, 타사 API 통합 등에 적합</li><li>복잡한 권한 관리가 필요한 시스템에 유용</li></ul></li><li><p>JWT + 세션 하이브리드</p><ul><li>JWT를 서버 측 세션 ID로 사용</li><li>토큰 무효화 등의 세션 관리와 JWT의 풍부한 페이로드 장점 결합</li><li>중간 규모 애플리케이션에 좋은 균형 제공</li></ul></li><li><p>다층 인증 전략</p><ul><li>민감한 API는 추가 인증 레이어 적용</li><li>공개 API에는, 기본 인증이나 API 키 사용</li><li>사용자 인증에는 JWT 사용</li></ul></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/authentication-methods/>Authentication-Methods</a></li><li><a href=https://buenhyden.github.io/tags/jwt/>JWT</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend/event-brokers-and-message-brokers/tools/apache-pulsar/apache-pulsar-vs-rabbitmq/><span class=title>« Prev</span><br><span>Apache Pulsar vs. RabbitMQ</span>
</a><a class=next href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/session-based-auth/session-based-auth-vs-basic-authentication/><span class=title>Next »</span><br><span>Session-Based Auth vs. Basic Authentication</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>