<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types of Real-time APIs | hyunyoun's Blog</title>
<meta name=keywords content="Backend,API-Design,Real-time-APIs,Types"><meta name=description content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types of Real-time APIs"><meta property="og:description" content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types of Real-time APIs"><meta name=twitter:description content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"APIs","item":"https://buenhyden.github.io/posts/backend/api-design/"},{"@type":"ListItem","position":4,"name":"Real-time APIs","item":"https://buenhyden.github.io/posts/backend/api-design/real-time-apis/"},{"@type":"ListItem","position":5,"name":"Types of Real-time APIs","item":"https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/>APIs</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/>Real-time APIs</a></div><h1>Types of Real-time APIs</h1><div class=post-description>Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다.</div></header><div class=post-content><h2 id=types-of-real-time-apis>Types of Real-time APIs<a hidden class=anchor aria-hidden=true href=#types-of-real-time-apis>#</a></h2><p>Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다. 이는 사용자 경험을 향상시키고, 데이터 정확성과 응답성을 높이는 데 중요한 역할을 한다.</p><h3 id=real-time-api의-주요-유형><strong>Real-time API의 주요 유형</strong><a hidden class=anchor aria-hidden=true href=#real-time-api의-주요-유형>#</a></h3><h4 id=websocket-api>WebSocket API<a hidden class=anchor aria-hidden=true href=#websocket-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>단일 TCP 연결을 통해 양방향 통신을 지원.</li><li>클라이언트와 서버가 모두 데이터를 주고받을 수 있음.</li><li>낮은 지연 시간과 효율적인 데이터 전송 가능.</li></ul></li><li><strong>사용 사례</strong>: 채팅 애플리케이션, 온라인 게임, 협업 도구.</li></ul><h4 id=server-sent-events-sse-api>Server-Sent Events (SSE) API<a hidden class=anchor aria-hidden=true href=#server-sent-events-sse-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>HTTP 기반 단방향 통신(서버 → 클라이언트).</li><li>지속적인 연결 유지 및 자동 재연결 지원.</li><li>텍스트 기반 데이터 전송(UTF-8).</li></ul></li><li><strong>사용 사례</strong>: 실시간 알림, 뉴스 피드, 주식 가격 업데이트.</li></ul><h4 id=streaming-api>Streaming API<a hidden class=anchor aria-hidden=true href=#streaming-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>서버에서 클라이언트로 지속적인 데이터 스트림 제공.</li><li>대규모 데이터 처리에 적합(예: 비디오, 오디오 스트리밍).</li><li>WebSocket 또는 SSE를 기반으로 구현 가능.</li></ul></li><li><strong>사용 사례</strong>: 라이브 비디오 스트리밍, 소셜 미디어 피드, IoT 센서 데이터.</li></ul><h4 id=pubsub-api>Pub/Sub API<a hidden class=anchor aria-hidden=true href=#pubsub-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>Publish-Subscribe 패턴 기반.</li><li>발행자(Publisher)가 특정 주제(Topic)에 메시지를 게시하면 구독자(Subscriber)가 이를 수신.</li><li>데이터 생산자와 소비자를 분리하여 확장성과 효율성 제공.</li></ul></li><li><strong>사용 사례</strong>: 메시징 시스템(Kafka, PubNub), IoT 장치 간 통신.</li></ul><h4 id=push-api>Push API<a hidden class=anchor aria-hidden=true href=#push-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>서버에서 클라이언트로 푸시 알림 전송.</li><li>클라이언트가 활성화되지 않아도 메시지 수신 가능.</li><li>모바일 애플리케이션에서 주로 사용됨.</li><li><strong>사용 사례</strong>: 모바일 푸시 알림(Firebase Cloud Messaging), 이메일 알림.</li></ul></li></ul><h4 id=event-driven-api>Event-Driven API<a hidden class=anchor aria-hidden=true href=#event-driven-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>이벤트 중심 설계로 상태 변화나 특정 이벤트 발생 시 데이터를 전달.</li><li>이벤트 구독 및 처리에 최적화됨.</li><li><strong>사용 사례</strong>: IoT 애플리케이션, 실시간 모니터링 시스템.</li></ul></li></ul><h3 id=real-time-api-기술-비교>Real-Time API 기술 비교<a hidden class=anchor aria-hidden=true href=#real-time-api-기술-비교>#</a></h3><h4 id=기본-특성-비교>기본 특성 비교<a hidden class=anchor aria-hidden=true href=#기본-특성-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>통신 방향</strong></td><td>양방향(전이중)</td><td>단방향(서버→클라이언트)</td><td>단방향/양방향 가능</td><td>다방향(다대다)</td><td>단방향(서버→클라이언트)</td><td>이벤트 기반</td></tr><tr><td><strong>프로토콜</strong></td><td>WS/WSS</td><td>HTTP/HTTPS</td><td>HTTP/HTTPS</td><td>다양(MQTT, AMQP 등)</td><td>HTTP/HTTPS</td><td>다양</td></tr><tr><td><strong>연결 유지</strong></td><td>지속 연결</td><td>지속 연결</td><td>지속 연결</td><td>지속/비지속 가능</td><td>비연결성</td><td>이벤트 발생 시</td></tr><tr><td><strong>자동 재연결</strong></td><td>수동 구현 필요</td><td>내장 지원</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td></tr><tr><td><strong>메시지 포맷</strong></td><td>텍스트/바이너리</td><td>텍스트(UTF-8)</td><td>다양(JSON, XML 등)</td><td>다양</td><td>JSON</td><td>다양</td></tr><tr><td><strong>데이터 크기</strong></td><td>프레임 크기 제한</td><td>제한 없음</td><td>청크 단위 전송</td><td>일반적으로 작은 메시지</td><td>작은 메시지</td><td>이벤트 크기</td></tr></tbody></table><h4 id=기술적-특성-및-구현-비교>기술적 특성 및 구현 비교<a hidden class=anchor aria-hidden=true href=#기술적-특성-및-구현-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>연결 설정</strong></td><td>HTTP 업그레이드 후 WS 프로토콜</td><td>일반 HTTP 연결</td><td>HTTP 연결</td><td>다양한 연결 방식</td><td>서비스 워커 등록</td><td>이벤트 리스너 등록</td></tr><tr><td><strong>클라이언트 API</strong></td><td>WebSocket</td><td>EventSource</td><td>HTTP/Fetch</td><td>라이브러리별 다양</td><td>Push API, Service Worker</td><td>이벤트 리스너</td></tr><tr><td><strong>서버 구현</strong></td><td>WebSocket 서버 필요</td><td>일반 HTTP 서버</td><td>일반 HTTP 서버</td><td>메시지 브로커 서버</td><td>푸시 서비스</td><td>이벤트 처리 시스템</td></tr><tr><td><strong>확장성</strong></td><td>연결 유지 부담</td><td>상대적으로 가벼움</td><td>리소스 집약적</td><td>높은 확장성</td><td>높은 확장성</td><td>높은 확장성</td></tr><tr><td><strong>헤더 오버헤드</strong></td><td>낮음(최초 연결 후)</td><td>중간</td><td>중간</td><td>낮음</td><td>중간</td><td>구현에 따라 다름</td></tr><tr><td><strong>통합 난이도</strong></td><td>중간</td><td>쉬움</td><td>중간</td><td>중간~어려움</td><td>어려움</td><td>중간~어려움</td></tr></tbody></table><h4 id=활용-사례-및-지원-비교>활용 사례 및 지원 비교<a hidden class=anchor aria-hidden=true href=#활용-사례-및-지원-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>즉시성</strong></td><td>매우 높음</td><td>높음</td><td>중간~높음</td><td>중간~높음</td><td>중간</td><td>중간~높음</td></tr><tr><td><strong>브라우저 지원</strong></td><td>대부분 지원</td><td>대부분 지원(IE 제외)</td><td>모두 지원</td><td>라이브러리 필요</td><td>대부분 지원</td><td>구현에 따라 다름</td></tr><tr><td><strong>보안 고려사항</strong></td><td>WSS 필수, 인증 필요</td><td>HTTPS 권장, 인증 필요</td><td>HTTPS 권장, 인증 필요</td><td>인증/권한 관리 중요</td><td>인증 키/토큰 관리</td><td>이벤트 검증 중요</td></tr><tr><td><strong>리소스 사용량</strong></td><td>중간~높음</td><td>낮음~중간</td><td>중간~높음</td><td>중간</td><td>낮음</td><td>중간</td></tr><tr><td><strong>최적 사용 사례</strong></td><td>채팅, 게임, 협업 도구</td><td>알림, 뉴스 피드, 실시간 데이터</td><td>대용량 데이터 전송</td><td>분산 메시징, IoT</td><td>알림, 백그라운드 메시지</td><td>마이크로서비스, 이벤트 기록</td></tr></tbody></table><h4 id=성능-및-구현-고려사항>성능 및 구현 고려사항<a hidden class=anchor aria-hidden=true href=#성능-및-구현-고려사항>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>지연 시간</strong></td><td>매우 낮음(~100ms)</td><td>낮음(~500ms)</td><td>중간(~1s)</td><td>중간</td><td>높음(몇 초~몇 분)</td><td>구현에 따라 다름</td></tr><tr><td><strong>처리량</strong></td><td>높음</td><td>중간</td><td>매우 높음</td><td>매우 높음</td><td>낮음</td><td>구현에 따라 다름</td></tr><tr><td><strong>배터리 영향</strong></td><td>중간~높음</td><td>낮음~중간</td><td>중간~높음</td><td>구현에 따라 다름</td><td>낮음(백그라운드)</td><td>구현에 따라 다름</td></tr><tr><td><strong>방화벽 통과</strong></td><td>일부 제한 가능</td><td>대부분 허용</td><td>대부분 허용</td><td>혼합</td><td>대부분 허용</td><td>구현에 따라 다름</td></tr><tr><td><strong>저대역폭 환경</strong></td><td>적합하지 않음</td><td>적합함</td><td>적합하지 않음</td><td>구현에 따라 다름</td><td>적합함</td><td>구현에 따라 다름</td></tr><tr><td><strong>오프라인 지원</strong></td><td>미지원</td><td>미지원</td><td>미지원</td><td>일부 지원 가능</td><td>지원(백그라운드)</td><td>일부 지원 가능</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebSocket API</h2></header><div class=entry-content><p>WebSocket API 웹 소켓은 클라이언트와 서버 간에 지속적인 양방향 통신 채널을 제공하는 프로토콜이다. 전통적인 HTTP 통신과 달리, 웹 소켓은 한 번 연결이 수립되면 지속적으로 유지되어 실시간으로 데이터를 주고받을 수 있다.
웹 소켓 연결은 다음과 같은 특징적인 프로세스를 따른다:
핸드셰이크: 일반적인 HTTP 요청으로 시작하여 웹 소켓 연결로 ‘업그레이드’된다. 양방향 통신: 연결이 수립된 후, 클라이언트와 서버는 독립적으로 메시지를 주고받을 수 있다. 전이중(Full-duplex) 통신: 동시에 데이터를 송수신할 수 있다. HTTP vs. 웹 소켓 전통적인 HTTP와 웹 소켓의 주요 차이점을 이해하는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:32:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket API" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/websocket-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events 서버 전송 이벤트(Server-Sent Events, SSE)는 웹 서버가 클라이언트 브라우저로 데이터를 자동으로 푸시할 수 있게 해주는 웹 기술이다. 전통적인 HTTP 통신에서는 클라이언트가 요청을 보내고 서버가 응답하는 방식이었지만, SSE는 서버가 필요할 때마다 자발적으로 데이터를 전송할 수 있는 단방향 통신 채널을 제공한다.
SSE는 HTML5 표준의 일부로, EventSource API를 통해 구현된다. 이 기술은 기존 HTTP 프로토콜 위에서 작동하며, 특별한 프로토콜 전환 없이 실시간 통신이 가능하다는 장점이 있다.
SSE의 핵심 특징 서버 전송 이벤트는 다음과 같은 주요 특징을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:31:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/server-sent-events/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Streaming APIs</h2></header><div class=entry-content><p>Streaming APIs 스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다. 전통적인 RESTful API가 요청-응답 패턴을 기반으로 하는 반면, 스트리밍 API는 지속적인 연결을 통해 실시간 데이터를 제공한다. 이러한 접근 방식은 데이터가 생성되는 즉시 클라이언트에게 전달할 수 있어 실시간성이 중요한 애플리케이션에 적합하다.
스트리밍 API의 기본 원리는 클라이언트와 서버 간에 한 번 연결을 수립한 후, 서버가 필요에 따라 데이터를 푸시하는 방식으로 동작하다. 이는 폴링(polling) 방식의 단점인 불필요한 요청과 네트워크 오버헤드를 극복할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:41:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming APIs" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/streaming-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/event-driven-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pub and Sub APIs</h2></header><div class=entry-content><p>Pub/Sub APIs Pub/Sub 패턴의 기본 개념 Pub/Sub(Publish-Subscribe) 패턴은 메시지 기반 아키텍처의 핵심 패러다임으로, 데이터를 생성하는 발행자(Publisher)와 데이터를 소비하는 구독자(Subscriber) 사이의 느슨한 결합(loose coupling)을 제공한다. 이 패턴에서 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 자동으로 그 메시지를 수신한다.
Pub/Sub 패턴의 가장 중요한 특징은 발행자와 구독자가 서로에 대해 직접적인 지식이 필요 없다는 점이다. 발행자는 단순히 주제에 메시지를 보내고, 시스템이 해당 주제의 모든 구독자에게 메시지를 전달한다. 이러한 분리는 시스템 구성 요소 간의 의존성을 줄이고 확장성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/pub-and-sub-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Push APIs</h2></header><div class=entry-content><p>Push APIs Push API는 서버가 클라이언트의 요청 없이도 능동적으로 데이터나 알림을 클라이언트에게 전송할 수 있게 해주는 통신 메커니즘이다. 전통적인 Pull 방식의 API와 달리, Push API는 새로운 정보나 이벤트가 발생할 때 서버가 즉시 관련 클라이언트에게 알림을 ‘푸시’한다. 이러한 접근 방식은 실시간 데이터 전송이 필요한 현대 애플리케이션에서 중요한 역할을 한다.
Push API의 핵심 가치는 실시간성과 효율성에 있다. 클라이언트가 새로운 데이터를 확인하기 위해 주기적으로 서버에 요청을 보내는 폴링(polling) 방식과 달리, Push API는 실제로 업데이트가 있을 때만 통신이 이루어지므로 네트워크 리소스를 효율적으로 사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Push APIs" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/push-apis/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>