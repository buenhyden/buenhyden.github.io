<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kafka vs RabbitMQ | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Event-Brokers-and-Message-Brokers,Tools,Kafka,RabbitMQ"><meta name=description content="Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Kafka vs RabbitMQ"><meta property="og:description" content="Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T11:41:00+00:00"><meta property="article:modified_time" content="2024-10-22T11:41:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="Event-Brokers-and-Message-Brokers"><meta property="article:tag" content="Tools"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="RabbitMQ"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Kafka vs RabbitMQ"><meta name=twitter:description content="Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Event and Message Brokers","item":"https://buenhyden.github.io/posts/backend/event-and-message-brokers/"},{"@type":"ListItem","position":4,"name":"Tools of Event Broker and Message Broker","item":"https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/"},{"@type":"ListItem","position":5,"name":"Kafka","item":"https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/"},{"@type":"ListItem","position":6,"name":"Kafka vs RabbitMQ","item":"https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kafka vs RabbitMQ","name":"Kafka vs RabbitMQ","description":"Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다.","keywords":["Backend","Event-Brokers-and-Message-Brokers","Tools","Kafka","RabbitMQ"],"articleBody":"Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.\n기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.\n핵심 구성 요소:\n브로커(Broker): Kafka 서버로, 메시지를 저장하고 관리한다. 토픽(Topic): 메시지가 게시되는 카테고리이다. 파티션(Partition): 토픽을 여러 파티션으로 나누어 병렬 처리한다. 프로듀서(Producer): 토픽에 메시지를 게시하는 애플리케이션이다. 컨슈머(Consumer): 토픽의 메시지를 구독하는 애플리케이션이다. 주키퍼(ZooKeeper): 브로커 클러스터 관리를 위한 코디네이션 서비스이다. 컨슈머 그룹(Consumer Group): 토픽을 구독하는 컨슈머들의 집합이다. Kafka는 토픽을 파티션으로 분할하여 여러 브로커에 분산 저장함으로써 높은 처리량과 확장성을 제공한다. 각 파티션은 순서가 보장된 불변의 메시지 시퀀스로, 디스크에 저장된다.\nRabbitMQ는 Erlang으로 구현된 오픈 소스 메시지 브로커로, AMQP(Advanced Message Queuing Protocol)를 기반으로 한다. 메시지의 안정적인 전달과 라우팅에 중점을 둔다.\n핵심 구성 요소:\nExchange: 프로듀서로부터 받은 메시지를 큐로 라우팅한다. Queue: 메시지가 저장되는 버퍼이다. Binding: Exchange와 Queue 사이의 관계를 정의한다. Virtual Host: 여러 애플리케이션이 같은 RabbitMQ 인스턴스를 공유할 수 있도록 격리된 환경을 제공한다. Connection: 클라이언트와 브로커 간의 TCP 연결이다. Channel: 하나의 TCP 연결 내에서 여러 통신 채널을 제공한다. RabbitMQ는 다양한 Exchange 타입(Direct, Topic, Fanout, Headers)을 제공하여 유연한 라우팅 패턴을 지원한다. 메시지는 컨슈머가 처리할 때까지 큐에 저장된다.\n아키텍처 및 핵심 기능 항목 Kafka RabbitMQ 메시지 모델 Pub/Sub + 분산 로그 (토픽과 파티션) Pub/Sub, Point-to-Point, Request-Reply 등 다양한 패턴 지원 메시지 저장 지정된 보존 기간 동안 디스크에 지속 저장 (재생 가능) 소비 확인(ACK) 후 삭제 (Dead-Letter Exchange로 예외 처리 가능) 라우팅 토픽 기반 (파티션 내 순서 보장) Exchange 유형 (Direct, Fanout, Topic, Header)에 따른 복잡한 라우팅 지원 확장성 수평 확장 용이 (파티션 추가로 처리량 증가) 클러스터링 가능하지만 Kafka에 비해 확장성 제한적 소비 모델 Pull 기반 (컨슈머가 오프셋 관리) Push 기반 (브로커가 메시지 전달) Kafka는 발행-구독(Pub-Sub) 모델을 기반으로 하지만, 일반적인 메시징 시스템과는 다른 접근 방식을 취한다:\n로그 중심(Log-Centric): 메시지는 추가만 가능한(append-only) 로그로 저장된다. 컨슈머 풀 모델(Consumer Pull Model): 컨슈머가 브로커로부터 메시지를 가져온다. 오프셋 기반(Offset-Based): 각 컨슈머는 자신이 읽은 메시지의 오프셋(위치)를 추적한다. 다중 구독자(Multi-Subscriber): 여러 컨슈머 그룹이 독립적으로 동일한 토픽을 소비할 수 있다. 이 모델은 대용량 스트림 처리와 이벤트 소싱에 적합하다. 컨슈머는 자신의 속도로 메시지를 처리하고, 필요에 따라 과거 메시지를 다시 소비할 수 있다.\nRabbitMQ는 보다 전통적인 메시징 패러다임을 따른다:\n메시지 큐잉(Message Queuing): 메시지는 컨슈머에게 전달될 때까지 큐에 저장된다. 푸시 모델(Push Model): 브로커가 컨슈머에게 메시지를 전달한다. 확인 기반(Acknowledgement-Based): 컨슈머는 메시지 처리 후 확인을 보낸다. 메시지 라우팅(Message Routing): 다양한 Exchange 타입을 통해 메시지 라우팅 패턴을 지원한다. 이 모델은 작업 분배와 RPC(Remote Procedure Call) 패턴에 적합하다. 메시지는 일반적으로 한 번만 처리되며, 확인 후 큐에서 제거된다.\n성능 및 처리량 항목 Kafka RabbitMQ 처리량 초당 수백만 ~ 수십억 메시지 초당 수천 ~ 수십만 메시지 지연 시간 밀리초 단위 (배치 처리 영향) 밀리초 단위 (낮은 부하 시 더 빠름) 데이터 크기 기본 1MB 제한 (설정 조정 가능) 제한 없음 성능 및 확장성 Kafka는 매우 높은 처리량을 제공하도록 설계되었다:\n순차적 디스크 I/O: 디스크 기반의 데이터 저장소에서도 높은 성능을 제공한다. 제로 카피(Zero-Copy): 메시지를 네트워크로 전송할 때 불필요한 복사를 방지한다. 배치 처리(Batching): 다수의 작은 I/O 작업을 하나의 큰 작업으로 묶어 효율성을 높인다. 수평적 확장(Horizontal Scaling): 파티션을 여러 브로커에 분산하여 처리량을 선형적으로 확장한다. Kafka는 수백만 메시지/초의 처리량을 지원할 수 있으며, 대형 데이터 파이프라인에 적합하다.\nRabbitMQ는 낮은 지연 시간과 안정적인 메시지 전달에 초점을 맞추고 있다:\n메모리 기반(Memory-Based): 메시지는 주로 메모리에 저장된다(필요한 경우 디스크로 이동). 발행자 확인(Publisher Confirms): 메시지가 안전하게 저장되었는지 확인한다. 클러스터링(Clustering): 여러 노드에 큐를 미러링하여 고가용성을 제공한다. 플러그인 시스템(Plugin System): 기능을 확장하기 위한 다양한 플러그인을 지원한다. RabbitMQ는 일반적으로 Kafka보다 낮은 처리량을 제공하지만, 더 낮은 지연 시간과 더 높은 안정성을 제공한다.\n내구성 및 가용성 Kafka는 높은 내구성과 분산 복제를 제공한다:\n복제 팩터(Replication Factor): 파티션은 여러 브로커에 복제된다. 리더-팔로워 모델(Leader-Follower Model): 각 파티션은 하나의 리더와 여러 팔로워를 가진다. 장기 보존(Long-Term Retention): 메시지는 설정된 기간 또는 크기 제한까지 유지된다. 장애 복구(Fault Tolerance): 브로커 장애 시 파티션 리더십이 자동으로 재할당된다. Kafka는 데이터 손실 위험이 매우 낮으며, 높은 가용성을 제공한다.\nRabbitMQ도 높은 가용성을 위한 메커니즘을 제공한다:\n지속성(Persistence): 메시지와 큐를 디스크에 저장할 수 있다. 미러링 큐(Mirrored Queues): 큐를 여러 노드에 복제하여 노드 장애에 대비한다. 퀴럼 큐(Quorum Queues): Raft 합의 알고리즘을 사용하여 더 강력한 복제를 제공한다. 클러스터 파티션 처리(Cluster Partition Handling): 네트워크 파티션 상황을 감지하고 처리한다. RabbitMQ는 적절히 구성된 경우 매우 안정적인 메시지 전달을 제공한다.\n주요 사용 사례 항목 Kafka RabbitMQ 적합한 시나리오 - 실시간 분석\n- 로그 집계\n- 이벤트 소싱\n- 대규모 데이터 파이프라인 - 작업 큐\n- 복잡한 라우팅\n- 마이크로서비스 통신\n- RPC 부적합한 시나리오 복잡한 메시지 라우팅 필요 시 초고속 대량 데이터 스트리밍 필요 시 실제 적용 예시 - Netflix: 사용자 활동 추적\n- Goldman Sachs: 실시간 보안 모니터링 - 채팅 애플리케이션\n- IoT 장치 제어 Kafka에 적합한 사용 사례 로그 집계(Log Aggregation): 다양한 소스의 로그를 중앙 집중화 스트림 처리(Stream Processing): 실시간 데이터 스트림 분석 이벤트 소싱(Event Sourcing): 상태 변경을 이벤트로 저장 활동 추적(Activity Tracking): 사용자 활동이나 시스템 메트릭 추적 ETL 파이프라인(ETL Pipelines): 데이터 변환 및 적재 프로세스 Kafka는 고성능, 내구성, 확장성이 중요한 대용량 데이터 처리 시나리오에 이상적이다.\nRabbitMQ에 적합한 사용 사례 작업 큐(Task Queues): 백그라운드 작업 처리 및 부하 분산 마이크로서비스 통신(Microservice Communication): 서비스 간 비동기 통신 요청-응답 패턴(Request-Response Pattern): RPC와 같은 양방향 통신 복잡한 라우팅(Complex Routing): 다양한 조건에 따른 메시지 라우팅 우선순위 큐(Priority Queues): 중요한 메시지를 먼저 처리 RabbitMQ는 메시지 라우팅 유연성과 신뢰성이 중요한 시나리오에 적합하다.\n기타 특징 비교 항목 Kafka RabbitMQ 메시지 우선순위 미지원 우선순위 큐 지원 보안 TLS, JAAS 기반 인증/암호화 SSL/TLS, 플러그인 기반 보안 프로토콜 자체 바이너리 프로토콜 AMQP, MQTT, STOMP 등 다중 프로토콜 지원 커뮤니티 대규모 오픈소스 생태계 (Confluent 지원) 활발한 커뮤니티 및 엔터프라이즈 지원 운영 및 관리 Kafka는\n의존성: 주키퍼(ZooKeeper) 필요 (최신 버전에서는 KRaft 모드 지원으로 의존성 제거 중) 리소스 요구사항: 상대적으로 높은 메모리 및 디스크 공간 필요 모니터링: JMX 기반 메트릭스 클라이언트 언어: 다양한 언어 지원(Java, Python, Go,.NET 등) 관리 도구: 커맨드 라인 도구와 오픈 소스 UI(Kafka Manager, Confluent Control Center 등) Kafka는 설정이 복잡할 수 있으나, 큰 규모의 데이터 파이프라인에서 안정적으로 운영된다.\nRabbitMQ는\n의존성: 독립적인 운영 가능 리소스 요구사항: 상대적으로 낮은 리소스 요구 모니터링: 내장 관리 UI와 HTTP API 클라이언트 언어: 다양한 언어 지원(Java, Python, Ruby, PHP,.NET 등) 관리 도구: 포괄적인 웹 기반 관리 인터페이스 내장 RabbitMQ는 설정이 직관적이고 관리 도구가 잘 갖추어져 있어 운영이 상대적으로 용이하다.\n선택 기준 기준 Kafka 선택 시 RabbitMQ 선택 시 데이터 볼륨 초당 10만 건 이상의 메시지 처리 필요 비교적 낮은 트래픽 (초당 수천 건 이하) 데이터 보존 장기 저장 및 재처리 필요 즉시 삭제되는 메시지 흐름 시스템 복잡도 분산 스트림 처리 아키텍처 구축 목적 단순한 메시지 큐 또는 RPC 구현 필요 유연성 고정된 토픽 구조 동적 라우팅 및 교환기 규칙 필요 언제 Kafka를 선택해야 하는가?\n대용량 데이터 처리: 초당 수백만 메시지를 처리해야 하는 경우 데이터 스트림 분석: 실시간 데이터 파이프라인이 필요한 경우 이벤트 소싱: 이벤트 기록을 장기간 저장해야 하는 경우 로그 집계: 분산 시스템의 로그를 중앙화해야 하는 경우 내구성: 메시지 손실을 최소화해야 하는 경우 다중 소비: 같은 데이터를 여러 시스템에서 소비해야 하는 경우 언제 RabbitMQ를 선택해야 하는가?\n복잡한 라우팅: 다양한 라우팅 패턴이 필요한 경우 낮은 지연 시간: 메시지의 빠른 전달이 중요한 경우 우선순위 큐: 메시지 우선순위를 지정해야 하는 경우 플러그인 필요: 다양한 프로토콜 지원이 필요한 경우 작업 분배: 백그라운드 작업을 분산 처리해야 하는 경우 간편한 관리: 직관적인 관리 도구가 필요한 경우 하이브리드 접근 방식\n많은 기업들은 두 시스템의 장점을 모두 활용하기 위해 하이브리드 아키텍처를 채택한다:\nKafka는 대용량 데이터 수집과 장기 저장에 사용 RabbitMQ는 세분화된 작업 처리와 복잡한 라우팅에 사용 두 시스템 간의 브리지를 통해 데이터 흐름 유지\n이러한 접근 방식은 각 시스템의 강점을 최대한 활용할 수 있게 해준다. Kafka vs. RabbitMQ 비교 특성 Apache Kafka RabbitMQ 아키텍처 분산 로그 시스템 메시지 브로커 시스템 개발 언어 Scala/Java Erlang 프로토콜 자체 프로토콜 AMQP, MQTT, STOMP 등 메시징 모델 발행-구독, 로그 중심 발행-구독, 메시지 큐잉 데이터 보존 장기 보존 가능 일반적으로 즉시 소비 주요 특징 높은 처리량, 파티셔닝, 복제 다양한 교환 유형, 라우팅 유연성 성능 최적화 순차적 I/O, 배치 처리 메모리 최적화, 낮은 지연 시간 최대 처리량 수백만 메시지/초 수십만 메시지/초 지연 시간 밀리초 단위 (상대적으로 높음) 마이크로초 단위 (낮음) 확장성 수평적 확장 우수 클러스터링 지원 (제한적) 내구성 파티션 복제, 디스크 저장 미러링 큐, 퀴럼 큐 메시지 순서 파티션 내에서 보장 큐 내에서 보장 메시지 크기 제한 없음 (기본 1MB) 제한 없음 (권장 ~128MB) 메시지 형식 바이너리 (스키마 지원) 바이너리 (헤더와 속성 지원) 소비 모델 풀(Pull) 모델 푸시(Push) 모델 라우팅 기능 기본적인 라우팅 풍부한 라우팅 패턴 관리 인터페이스 제한적 (오픈소스 도구 필요) 포괄적인 웹 UI 내장 의존성 ZooKeeper (또는 KRaft) 독립적 리소스 사용량 비교적 높음 비교적 낮음 생태계 풍부한 데이터 처리 도구 다양한 플러그인 학습 곡선 가파름 완만함 주요 사용 사례 빅데이터, 로그 집계, 스트림 처리 작업 큐, 마이크로서비스 통신, RPC 기업 지원 Confluent VMware(구 Pivotal) 커뮤니티 활성도 매우 활발함 활발함 초기 릴리스 2011년 2007년 참고 및 출처 ","wordCount":"1429","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-22T11:41:00Z","dateModified":"2024-10-22T11:41:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/>Event and Message Brokers</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/>Tools of Event Broker and Message Broker</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/>Kafka</a></div><h1 class="post-title entry-hint-parent">Kafka vs RabbitMQ</h1><div class=post-description>Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다.</div><div class=post-meta><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend/Event%20and%20Message%20Brokers/Tools/Kafka/Kafka-vs-RabbitMQ.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kafka-vs-rabbitmq>Kafka vs. RabbitMQ</a><ul><li><a href=#기본-개념>기본 개념</a></li><li><a href=#아키텍처-및-핵심-기능>아키텍처 및 핵심 기능</a></li><li><a href=#성능-및-처리량>성능 및 처리량</a></li><li><a href=#주요-사용-사례>주요 사용 사례</a></li><li><a href=#기타-특징-비교>기타 특징 비교</a></li><li><a href=#선택-기준>선택 기준</a></li><li><a href=#kafka-vs-rabbitmq-비교>Kafka vs. RabbitMQ 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=kafka-vs-rabbitmq>Kafka vs. RabbitMQ<a hidden class=anchor aria-hidden=true href=#kafka-vs-rabbitmq>#</a></h2><p><strong>Apache Kafka</strong>와 <strong>RabbitMQ</strong>는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.</p><h3 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>Apache Kafka</strong></th><th><strong>RabbitMQ</strong></th></tr></thead><tbody><tr><td><strong>유형</strong></td><td>분산 이벤트 스트리밍 플랫폼</td><td>메시지 브로커 (AMQP 구현)</td></tr><tr><td><strong>주요 목적</strong></td><td>대규모 실시간 데이터 스트리밍 및 처리</td><td>유연한 메시지 라우팅과 비동기 통신 지원</td></tr><tr><td><strong>데이터 처리</strong></td><td>로그 기반 스트림 (메시지 재생 가능)</td><td>큐 기반 메시지 (소비 후 삭제)</td></tr></tbody></table><p>Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.</p><p><strong>핵심 구성 요소:</strong></p><ul><li><strong>브로커(Broker)</strong>: Kafka 서버로, 메시지를 저장하고 관리한다.</li><li><strong>토픽(Topic)</strong>: 메시지가 게시되는 카테고리이다.</li><li><strong>파티션(Partition)</strong>: 토픽을 여러 파티션으로 나누어 병렬 처리한다.</li><li><strong>프로듀서(Producer)</strong>: 토픽에 메시지를 게시하는 애플리케이션이다.</li><li><strong>컨슈머(Consumer)</strong>: 토픽의 메시지를 구독하는 애플리케이션이다.</li><li><strong>주키퍼(ZooKeeper)</strong>: 브로커 클러스터 관리를 위한 코디네이션 서비스이다.</li><li><strong>컨슈머 그룹(Consumer Group)</strong>: 토픽을 구독하는 컨슈머들의 집합이다.</li></ul><p>Kafka는 토픽을 파티션으로 분할하여 여러 브로커에 분산 저장함으로써 높은 처리량과 확장성을 제공한다. 각 파티션은 순서가 보장된 불변의 메시지 시퀀스로, 디스크에 저장된다.</p><p>RabbitMQ는 Erlang으로 구현된 오픈 소스 메시지 브로커로, AMQP(Advanced Message Queuing Protocol)를 기반으로 한다. 메시지의 안정적인 전달과 라우팅에 중점을 둔다.</p><p><strong>핵심 구성 요소:</strong></p><ul><li><strong>Exchange</strong>: 프로듀서로부터 받은 메시지를 큐로 라우팅한다.</li><li><strong>Queue</strong>: 메시지가 저장되는 버퍼이다.</li><li><strong>Binding</strong>: Exchange와 Queue 사이의 관계를 정의한다.</li><li><strong>Virtual Host</strong>: 여러 애플리케이션이 같은 RabbitMQ 인스턴스를 공유할 수 있도록 격리된 환경을 제공한다.</li><li><strong>Connection</strong>: 클라이언트와 브로커 간의 TCP 연결이다.</li><li><strong>Channel</strong>: 하나의 TCP 연결 내에서 여러 통신 채널을 제공한다.</li></ul><p>RabbitMQ는 다양한 Exchange 타입(Direct, Topic, Fanout, Headers)을 제공하여 유연한 라우팅 패턴을 지원한다. 메시지는 컨슈머가 처리할 때까지 큐에 저장된다.</p><h3 id=아키텍처-및-핵심-기능>아키텍처 및 핵심 기능<a hidden class=anchor aria-hidden=true href=#아키텍처-및-핵심-기능>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>Kafka</strong></th><th><strong>RabbitMQ</strong></th></tr></thead><tbody><tr><td><strong>메시지 모델</strong></td><td>Pub/Sub + 분산 로그 (토픽과 파티션)</td><td>Pub/Sub, Point-to-Point, Request-Reply 등 다양한 패턴 지원</td></tr><tr><td><strong>메시지 저장</strong></td><td>지정된 보존 기간 동안 디스크에 지속 저장 (재생 가능)</td><td>소비 확인(ACK) 후 삭제 (Dead-Letter Exchange로 예외 처리 가능)</td></tr><tr><td><strong>라우팅</strong></td><td>토픽 기반 (파티션 내 순서 보장)</td><td>Exchange 유형 (Direct, Fanout, Topic, Header)에 따른 복잡한 라우팅 지원</td></tr><tr><td><strong>확장성</strong></td><td>수평 확장 용이 (파티션 추가로 처리량 증가)</td><td>클러스터링 가능하지만 Kafka에 비해 확장성 제한적</td></tr><tr><td><strong>소비 모델</strong></td><td>Pull 기반 (컨슈머가 오프셋 관리)</td><td>Push 기반 (브로커가 메시지 전달)</td></tr></tbody></table><p>Kafka는 <strong>발행-구독(Pub-Sub)</strong> 모델을 기반으로 하지만, 일반적인 메시징 시스템과는 다른 접근 방식을 취한다:</p><ul><li><strong>로그 중심(Log-Centric)</strong>: 메시지는 추가만 가능한(append-only) 로그로 저장된다.</li><li><strong>컨슈머 풀 모델(Consumer Pull Model)</strong>: 컨슈머가 브로커로부터 메시지를 가져온다.</li><li><strong>오프셋 기반(Offset-Based)</strong>: 각 컨슈머는 자신이 읽은 메시지의 오프셋(위치)를 추적한다.</li><li><strong>다중 구독자(Multi-Subscriber)</strong>: 여러 컨슈머 그룹이 독립적으로 동일한 토픽을 소비할 수 있다.</li></ul><p>이 모델은 대용량 스트림 처리와 이벤트 소싱에 적합하다. 컨슈머는 자신의 속도로 메시지를 처리하고, 필요에 따라 과거 메시지를 다시 소비할 수 있다.</p><p>RabbitMQ는 보다 전통적인 메시징 패러다임을 따른다:</p><ul><li><strong>메시지 큐잉(Message Queuing)</strong>: 메시지는 컨슈머에게 전달될 때까지 큐에 저장된다.</li><li><strong>푸시 모델(Push Model)</strong>: 브로커가 컨슈머에게 메시지를 전달한다.</li><li><strong>확인 기반(Acknowledgement-Based)</strong>: 컨슈머는 메시지 처리 후 확인을 보낸다.</li><li><strong>메시지 라우팅(Message Routing)</strong>: 다양한 Exchange 타입을 통해 메시지 라우팅 패턴을 지원한다.</li></ul><p>이 모델은 작업 분배와 RPC(Remote Procedure Call) 패턴에 적합하다. 메시지는 일반적으로 한 번만 처리되며, 확인 후 큐에서 제거된다.</p><h3 id=성능-및-처리량>성능 및 처리량<a hidden class=anchor aria-hidden=true href=#성능-및-처리량>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>Kafka</strong></th><th><strong>RabbitMQ</strong></th></tr></thead><tbody><tr><td><strong>처리량</strong></td><td>초당 수백만 ~ 수십억 메시지</td><td>초당 수천 ~ 수십만 메시지</td></tr><tr><td><strong>지연 시간</strong></td><td>밀리초 단위 (배치 처리 영향)</td><td>밀리초 단위 (낮은 부하 시 더 빠름)</td></tr><tr><td><strong>데이터 크기</strong></td><td>기본 1MB 제한 (설정 조정 가능)</td><td>제한 없음</td></tr></tbody></table><h4 id=성능-및-확장성>성능 및 확장성<a hidden class=anchor aria-hidden=true href=#성능-및-확장성>#</a></h4><p>Kafka는 <strong>매우 높은 처리량</strong>을 제공하도록 설계되었다:</p><ul><li><strong>순차적 디스크 I/O</strong>: 디스크 기반의 데이터 저장소에서도 높은 성능을 제공한다.</li><li><strong>제로 카피(Zero-Copy)</strong>: 메시지를 네트워크로 전송할 때 불필요한 복사를 방지한다.</li><li><strong>배치 처리(Batching)</strong>: 다수의 작은 I/O 작업을 하나의 큰 작업으로 묶어 효율성을 높인다.</li><li><strong>수평적 확장(Horizontal Scaling)</strong>: 파티션을 여러 브로커에 분산하여 처리량을 선형적으로 확장한다.</li></ul><p>Kafka는 수백만 메시지/초의 처리량을 지원할 수 있으며, 대형 데이터 파이프라인에 적합하다.</p><p>RabbitMQ는 <strong>낮은 지연 시간</strong>과 <strong>안정적인 메시지 전달</strong>에 초점을 맞추고 있다:</p><ul><li><strong>메모리 기반(Memory-Based)</strong>: 메시지는 주로 메모리에 저장된다(필요한 경우 디스크로 이동).</li><li><strong>발행자 확인(Publisher Confirms)</strong>: 메시지가 안전하게 저장되었는지 확인한다.</li><li><strong>클러스터링(Clustering)</strong>: 여러 노드에 큐를 미러링하여 고가용성을 제공한다.</li><li><strong>플러그인 시스템(Plugin System)</strong>: 기능을 확장하기 위한 다양한 플러그인을 지원한다.</li></ul><p>RabbitMQ는 일반적으로 Kafka보다 낮은 처리량을 제공하지만, 더 낮은 지연 시간과 더 높은 안정성을 제공한다.</p><h4 id=내구성-및-가용성>내구성 및 가용성<a hidden class=anchor aria-hidden=true href=#내구성-및-가용성>#</a></h4><p>Kafka는 <strong>높은 내구성</strong>과 <strong>분산 복제</strong>를 제공한다:</p><ul><li><strong>복제 팩터(Replication Factor)</strong>: 파티션은 여러 브로커에 복제된다.</li><li><strong>리더-팔로워 모델(Leader-Follower Model)</strong>: 각 파티션은 하나의 리더와 여러 팔로워를 가진다.</li><li><strong>장기 보존(Long-Term Retention)</strong>: 메시지는 설정된 기간 또는 크기 제한까지 유지된다.</li><li><strong>장애 복구(Fault Tolerance)</strong>: 브로커 장애 시 파티션 리더십이 자동으로 재할당된다.</li></ul><p>Kafka는 데이터 손실 위험이 매우 낮으며, 높은 가용성을 제공한다.</p><p>RabbitMQ도 <strong>높은 가용성</strong>을 위한 메커니즘을 제공한다:</p><ul><li><strong>지속성(Persistence)</strong>: 메시지와 큐를 디스크에 저장할 수 있다.</li><li><strong>미러링 큐(Mirrored Queues)</strong>: 큐를 여러 노드에 복제하여 노드 장애에 대비한다.</li><li><strong>퀴럼 큐(Quorum Queues)</strong>: Raft 합의 알고리즘을 사용하여 더 강력한 복제를 제공한다.</li><li><strong>클러스터 파티션 처리(Cluster Partition Handling)</strong>: 네트워크 파티션 상황을 감지하고 처리한다.</li></ul><p>RabbitMQ는 적절히 구성된 경우 매우 안정적인 메시지 전달을 제공한다.</p><h3 id=주요-사용-사례>주요 사용 사례<a hidden class=anchor aria-hidden=true href=#주요-사용-사례>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>Kafka</strong></th><th><strong>RabbitMQ</strong></th></tr></thead><tbody><tr><td><strong>적합한 시나리오</strong></td><td>- 실시간 분석<br>- 로그 집계<br>- 이벤트 소싱<br>- 대규모 데이터 파이프라인</td><td>- 작업 큐<br>- 복잡한 라우팅<br>- 마이크로서비스 통신<br>- RPC</td></tr><tr><td><strong>부적합한 시나리오</strong></td><td>복잡한 메시지 라우팅 필요 시</td><td>초고속 대량 데이터 스트리밍 필요 시</td></tr><tr><td><strong>실제 적용 예시</strong></td><td>- Netflix: 사용자 활동 추적<br>- Goldman Sachs: 실시간 보안 모니터링</td><td>- 채팅 애플리케이션<br>- IoT 장치 제어</td></tr></tbody></table><h4 id=kafka에-적합한-사용-사례>Kafka에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#kafka에-적합한-사용-사례>#</a></h4><ul><li><strong>로그 집계(Log Aggregation)</strong>: 다양한 소스의 로그를 중앙 집중화</li><li><strong>스트림 처리(Stream Processing)</strong>: 실시간 데이터 스트림 분석</li><li><strong>이벤트 소싱(Event Sourcing)</strong>: 상태 변경을 이벤트로 저장</li><li><strong>활동 추적(Activity Tracking)</strong>: 사용자 활동이나 시스템 메트릭 추적</li><li><strong>ETL 파이프라인(ETL Pipelines)</strong>: 데이터 변환 및 적재 프로세스</li></ul><p>Kafka는 고성능, 내구성, 확장성이 중요한 대용량 데이터 처리 시나리오에 이상적이다.</p><h4 id=rabbitmq에-적합한-사용-사례>RabbitMQ에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#rabbitmq에-적합한-사용-사례>#</a></h4><ul><li><strong>작업 큐(Task Queues)</strong>: 백그라운드 작업 처리 및 부하 분산</li><li><strong>마이크로서비스 통신(Microservice Communication)</strong>: 서비스 간 비동기 통신</li><li><strong>요청-응답 패턴(Request-Response Pattern)</strong>: RPC와 같은 양방향 통신</li><li><strong>복잡한 라우팅(Complex Routing)</strong>: 다양한 조건에 따른 메시지 라우팅</li><li><strong>우선순위 큐(Priority Queues)</strong>: 중요한 메시지를 먼저 처리</li></ul><p>RabbitMQ는 메시지 라우팅 유연성과 신뢰성이 중요한 시나리오에 적합하다.</p><h3 id=기타-특징-비교>기타 특징 비교<a hidden class=anchor aria-hidden=true href=#기타-특징-비교>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>Kafka</strong></th><th><strong>RabbitMQ</strong></th></tr></thead><tbody><tr><td><strong>메시지 우선순위</strong></td><td>미지원</td><td>우선순위 큐 지원</td></tr><tr><td><strong>보안</strong></td><td>TLS, JAAS 기반 인증/암호화</td><td>SSL/TLS, 플러그인 기반 보안</td></tr><tr><td><strong>프로토콜</strong></td><td>자체 바이너리 프로토콜</td><td>AMQP, MQTT, STOMP 등 다중 프로토콜 지원</td></tr><tr><td><strong>커뮤니티</strong></td><td>대규모 오픈소스 생태계 (Confluent 지원)</td><td>활발한 커뮤니티 및 엔터프라이즈 지원</td></tr></tbody></table><h4 id=운영-및-관리>운영 및 관리<a hidden class=anchor aria-hidden=true href=#운영-및-관리>#</a></h4><p>Kafka는</p><ul><li><strong>의존성</strong>: 주키퍼(ZooKeeper) 필요 (최신 버전에서는 KRaft 모드 지원으로 의존성 제거 중)</li><li><strong>리소스 요구사항</strong>: 상대적으로 높은 메모리 및 디스크 공간 필요</li><li><strong>모니터링</strong>: JMX 기반 메트릭스</li><li><strong>클라이언트 언어</strong>: 다양한 언어 지원(Java, Python, Go,.NET 등)</li><li><strong>관리 도구</strong>: 커맨드 라인 도구와 오픈 소스 UI(Kafka Manager, Confluent Control Center 등)</li></ul><p>Kafka는 설정이 복잡할 수 있으나, 큰 규모의 데이터 파이프라인에서 안정적으로 운영된다.</p><p>RabbitMQ는</p><ul><li><strong>의존성</strong>: 독립적인 운영 가능</li><li><strong>리소스 요구사항</strong>: 상대적으로 낮은 리소스 요구</li><li><strong>모니터링</strong>: 내장 관리 UI와 HTTP API</li><li><strong>클라이언트 언어</strong>: 다양한 언어 지원(Java, Python, Ruby, PHP,.NET 등)</li><li><strong>관리 도구</strong>: 포괄적인 웹 기반 관리 인터페이스 내장</li></ul><p>RabbitMQ는 설정이 직관적이고 관리 도구가 잘 갖추어져 있어 운영이 상대적으로 용이하다.</p><h3 id=선택-기준>선택 기준<a hidden class=anchor aria-hidden=true href=#선택-기준>#</a></h3><table><thead><tr><th><strong>기준</strong></th><th><strong>Kafka 선택 시</strong></th><th><strong>RabbitMQ 선택 시</strong></th></tr></thead><tbody><tr><td><strong>데이터 볼륨</strong></td><td>초당 10만 건 이상의 메시지 처리 필요</td><td>비교적 낮은 트래픽 (초당 수천 건 이하)</td></tr><tr><td><strong>데이터 보존</strong></td><td>장기 저장 및 재처리 필요</td><td>즉시 삭제되는 메시지 흐름</td></tr><tr><td><strong>시스템 복잡도</strong></td><td>분산 스트림 처리 아키텍처 구축 목적</td><td>단순한 메시지 큐 또는 RPC 구현 필요</td></tr><tr><td><strong>유연성</strong></td><td>고정된 토픽 구조</td><td>동적 라우팅 및 교환기 규칙 필요</td></tr></tbody></table><ol><li><p>언제 Kafka를 선택해야 하는가?</p><ul><li><strong>대용량 데이터 처리</strong>: 초당 수백만 메시지를 처리해야 하는 경우</li><li><strong>데이터 스트림 분석</strong>: 실시간 데이터 파이프라인이 필요한 경우</li><li><strong>이벤트 소싱</strong>: 이벤트 기록을 장기간 저장해야 하는 경우</li><li><strong>로그 집계</strong>: 분산 시스템의 로그를 중앙화해야 하는 경우</li><li><strong>내구성</strong>: 메시지 손실을 최소화해야 하는 경우</li><li><strong>다중 소비</strong>: 같은 데이터를 여러 시스템에서 소비해야 하는 경우</li></ul></li><li><p>언제 RabbitMQ를 선택해야 하는가?</p><ul><li><strong>복잡한 라우팅</strong>: 다양한 라우팅 패턴이 필요한 경우</li><li><strong>낮은 지연 시간</strong>: 메시지의 빠른 전달이 중요한 경우</li><li><strong>우선순위 큐</strong>: 메시지 우선순위를 지정해야 하는 경우</li><li><strong>플러그인 필요</strong>: 다양한 프로토콜 지원이 필요한 경우</li><li><strong>작업 분배</strong>: 백그라운드 작업을 분산 처리해야 하는 경우</li><li><strong>간편한 관리</strong>: 직관적인 관리 도구가 필요한 경우</li></ul></li><li><p>하이브리드 접근 방식<br>많은 기업들은 두 시스템의 장점을 모두 활용하기 위해 하이브리드 아키텍처를 채택한다:</p><ul><li>Kafka는 대용량 데이터 수집과 장기 저장에 사용</li><li>RabbitMQ는 세분화된 작업 처리와 복잡한 라우팅에 사용</li><li>두 시스템 간의 브리지를 통해 데이터 흐름 유지<br>이러한 접근 방식은 각 시스템의 강점을 최대한 활용할 수 있게 해준다.</li></ul></li></ol><h3 id=kafka-vs-rabbitmq-비교>Kafka vs. RabbitMQ 비교<a hidden class=anchor aria-hidden=true href=#kafka-vs-rabbitmq-비교>#</a></h3><table><thead><tr><th>특성</th><th>Apache Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td><strong>아키텍처</strong></td><td>분산 로그 시스템</td><td>메시지 브로커 시스템</td></tr><tr><td><strong>개발 언어</strong></td><td>Scala/Java</td><td>Erlang</td></tr><tr><td><strong>프로토콜</strong></td><td>자체 프로토콜</td><td>AMQP, MQTT, STOMP 등</td></tr><tr><td><strong>메시징 모델</strong></td><td>발행-구독, 로그 중심</td><td>발행-구독, 메시지 큐잉</td></tr><tr><td><strong>데이터 보존</strong></td><td>장기 보존 가능</td><td>일반적으로 즉시 소비</td></tr><tr><td><strong>주요 특징</strong></td><td>높은 처리량, 파티셔닝, 복제</td><td>다양한 교환 유형, 라우팅 유연성</td></tr><tr><td><strong>성능 최적화</strong></td><td>순차적 I/O, 배치 처리</td><td>메모리 최적화, 낮은 지연 시간</td></tr><tr><td><strong>최대 처리량</strong></td><td>수백만 메시지/초</td><td>수십만 메시지/초</td></tr><tr><td><strong>지연 시간</strong></td><td>밀리초 단위 (상대적으로 높음)</td><td>마이크로초 단위 (낮음)</td></tr><tr><td><strong>확장성</strong></td><td>수평적 확장 우수</td><td>클러스터링 지원 (제한적)</td></tr><tr><td><strong>내구성</strong></td><td>파티션 복제, 디스크 저장</td><td>미러링 큐, 퀴럼 큐</td></tr><tr><td><strong>메시지 순서</strong></td><td>파티션 내에서 보장</td><td>큐 내에서 보장</td></tr><tr><td><strong>메시지 크기</strong></td><td>제한 없음 (기본 1MB)</td><td>제한 없음 (권장 ~128MB)</td></tr><tr><td><strong>메시지 형식</strong></td><td>바이너리 (스키마 지원)</td><td>바이너리 (헤더와 속성 지원)</td></tr><tr><td><strong>소비 모델</strong></td><td>풀(Pull) 모델</td><td>푸시(Push) 모델</td></tr><tr><td><strong>라우팅 기능</strong></td><td>기본적인 라우팅</td><td>풍부한 라우팅 패턴</td></tr><tr><td><strong>관리 인터페이스</strong></td><td>제한적 (오픈소스 도구 필요)</td><td>포괄적인 웹 UI 내장</td></tr><tr><td><strong>의존성</strong></td><td>ZooKeeper (또는 KRaft)</td><td>독립적</td></tr><tr><td><strong>리소스 사용량</strong></td><td>비교적 높음</td><td>비교적 낮음</td></tr><tr><td><strong>생태계</strong></td><td>풍부한 데이터 처리 도구</td><td>다양한 플러그인</td></tr><tr><td><strong>학습 곡선</strong></td><td>가파름</td><td>완만함</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>빅데이터, 로그 집계, 스트림 처리</td><td>작업 큐, 마이크로서비스 통신, RPC</td></tr><tr><td><strong>기업 지원</strong></td><td>Confluent</td><td>VMware(구 Pivotal)</td></tr><tr><td><strong>커뮤니티 활성도</strong></td><td>매우 활발함</td><td>활발함</td></tr><tr><td><strong>초기 릴리스</strong></td><td>2011년</td><td>2007년</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/event-brokers-and-message-brokers/>Event-Brokers-and-Message-Brokers</a></li><li><a href=https://buenhyden.github.io/tags/tools/>Tools</a></li><li><a href=https://buenhyden.github.io/tags/kafka/>Kafka</a></li><li><a href=https://buenhyden.github.io/tags/rabbitmq/>RabbitMQ</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/test-cases-and-scenarios/scenario-testing-vs-use-case-testing/><span class=title>« Prev</span><br><span>Scenario Testing vs Use Case Testing</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/operating-system/components/kernel/memory-management/techniques/paging-vs-segmentation/><span class=title>Next »</span><br><span>Paging vs Segmentation</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>