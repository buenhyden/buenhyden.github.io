<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Message Queue vs Message Broker vs Event Broker | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Event-Broker-and-Message-Broker,Message-Queue,Message-Broker,Event-Broker"><meta name=description content="Message Queue의 Event Broker와 Message Broker를 비교한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Message Queue vs Message Broker vs Event Broker"><meta property="og:description" content="Message Queue의 Event Broker와 Message Broker를 비교한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Message Queue vs Message Broker vs Event Broker"><meta name=twitter:description content="Message Queue의 Event Broker와 Message Broker를 비교한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Message Queue vs Message Broker vs Event Broker","item":"https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a></div><h1>Message Queue vs Message Broker vs Event Broker</h1><div class=post-description>Message Queue의 Event Broker와 Message Broker를 비교한다.</div></header><div class=post-content><h2 id=message-queue-vs-message-broker-vs-event-broker>Message Queue Vs Message Broker Vs Event Broker<a hidden class=anchor aria-hidden=true href=#message-queue-vs-message-broker-vs-event-broker>#</a></h2><p>Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:</p><table><thead><tr><th>특성</th><th>Message Queue</th><th>Message Broker</th><th>Event Broker</th></tr></thead><tbody><tr><td>주요 기능</td><td>메시지 저장 및 전달</td><td>메시지 라우팅, 변환, 저장</td><td>이벤트 라우팅, 스트리밍, 저장</td></tr><tr><td>통신 모델</td><td>주로 점대점(Point-to-Point)</td><td>점대점 및 발행-구독(Pub/Sub)</td><td>주로 발행-구독(Pub/Sub)</td></tr><tr><td>메시지 보존</td><td>소비 후 일반적으로 삭제</td><td>구성에 따라 다름</td><td>장기간 보존 가능</td></tr><tr><td>확장성</td><td>제한적</td><td>중간</td><td>높음</td></tr><tr><td>복잡성</td><td>낮음</td><td>중간</td><td>높음</td></tr><tr><td>주요 사용 사례</td><td>작업 큐잉, 비동기 처리</td><td>시스템 통합, 프로토콜 변환</td><td>실시간 데이터 스트리밍, 이벤트 소싱</td></tr><tr><td>메시지 순서</td><td>보장</td><td>일반적으로 보장</td><td>보장 가능</td></tr><tr><td>재생 기능</td><td>제한적</td><td>구성에 따라 다름</td><td>일반적으로 지원</td></tr><tr><td>프로토콜 지원</td><td>제한적</td><td>다양한 프로토콜 지원</td><td>다양한 프로토콜 지원</td></tr><tr><td>대표적 제품</td><td>RabbitMQ, Redis</td><td>Apache Kafka, RabbitMQ</td><td>Apache Kafka, Amazon Kinesis</td></tr></tbody></table><h3 id=message-queue-vs-message-broker>Message Queue Vs Message Broker<a hidden class=anchor aria-hidden=true href=#message-queue-vs-message-broker>#</a></h3><p>Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:</p><table><thead><tr><th>특성</th><th>Message Queue</th><th>Message Broker</th></tr></thead><tbody><tr><td>정의</td><td>메시지를 임시로 저장하고 전달하는 데이터 구조</td><td>메시지의 유효성 검사, 변환, 라우팅을 담당하는 중개 소프트웨어</td></tr><tr><td>주요 기능</td><td>메시지 저장 및 전달</td><td>메시지 라우팅, 변환, 프로토콜 변환, 저장</td></tr><tr><td>통신 모델</td><td>주로 점대점(Point-to-Point)</td><td>점대점 및 발행-구독(Pub/Sub) 지원</td></tr><tr><td>복잡성</td><td>상대적으로 단순</td><td>더 복잡하고 고급 기능 제공</td></tr><tr><td>확장성</td><td>제한적</td><td>높음 (클러스터링 지원)</td></tr><tr><td>메시지 보존</td><td>일반적으로 소비 후 삭제</td><td>구성에 따라 다름 (장기 보존 가능)</td></tr><tr><td>라우팅</td><td>기본적인 라우팅</td><td>복잡한 라우팅 규칙 지원</td></tr><tr><td>변환 기능</td><td>제한적</td><td>메시지 형식 변환 지원</td></tr><tr><td>프로토콜 지원</td><td>제한적</td><td>다양한 메시징 프로토콜 지원</td></tr><tr><td>사용 사례</td><td>간단한 비동기 작업 처리, 작업 분배</td><td>복잡한 엔터프라이즈 통합, 다중 시스템 연동</td></tr><tr><td>대표적 제품</td><td>RabbitMQ, ActiveMQ</td><td>Apache Kafka, IBM MQ, RabbitMQ</td></tr><tr><td>성능</td><td>중간</td><td>높음 (대용량 처리에 적합)</td></tr><tr><td>관리 복잡성</td><td>낮음</td><td>높음 (더 많은 구성 옵션)</td></tr><tr><td>신뢰성</td><td>기본적인 신뢰성 보장</td><td>고급 신뢰성 및 내구성 기능 제공</td></tr></tbody></table><p>Message Queue는 메시지를 임시로 저장하고 전달하는 간단한 데이터 구조이며, Message Broker는 메시지의 유효성 검사, 변환, 라우팅 등 더 복잡하고 고급 기능을 제공한다.</p><p>Message Queue: 주로 점대점(Point-to-Point) 통신 모델을 사용하며, Message Broker는 점대점 및 발행-구독(Pub/Sub) 모델을 모두 지원한다.</p><p>Message Queue는 메시지를 순차적으로 처리하며, 일반적으로 소비 후 삭제되지만, Message Broker는 복잡한 라우팅 규칙을 지원하고, 메시지 변환 기능을 제공한다.</p><p>Message Queue는 간단한 비동기 작업 처리, 작업 분배에 적합하며, Message Broker는 복잡한 엔터프라이즈 통합, 다중 시스템 연동에 적합한다.</p><p>결론적으로, Message Queue는 Message Broker의 일부로 볼 수 있으며, Message Broker는 Message Queue의 기능을 포함하면서 더 확장된 기능을 제공하는 더 포괄적인 시스템이다.</p><h3 id=message-broker-vs-event-broker>Message Broker Vs Event Broker<a hidden class=anchor aria-hidden=true href=#message-broker-vs-event-broker>#</a></h3><table><thead><tr><th>비교 항목</th><th>Event Broker</th><th>Message Broker</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>이벤트 중심 아키텍처를 지원하며, 이벤트의 발행과 구독을 관리</td><td>메시지 큐를 통해 시스템 간 메시지 전달을 관리</td></tr><tr><td><strong>통신 패턴</strong></td><td>발행-구독(Pub/Sub) 패턴이 주요 통신 방식</td><td>점대점(Point-to-Point) 통신이 주된 방식이며, Pub/Sub도 지원</td></tr><tr><td><strong>데이터 지속성</strong></td><td>이벤트 로그를 유지하며 과거 이벤트 재생 가능</td><td>메시지는 소비되면 일반적으로 큐에서 제거됨</td></tr><tr><td><strong>메시지 소비</strong></td><td>여러 소비자가 동일한 이벤트를 동시에 소비 가능</td><td>일반적으로 하나의 메시지는 하나의 소비자만 처리</td></tr><tr><td><strong>순서 보장</strong></td><td>이벤트 스트림 내에서 순서 보장 중시</td><td>메시지 순서는 선택적으로 보장</td></tr><tr><td><strong>확장성</strong></td><td>높은 처리량과 수평적 확장성에 최적화</td><td>중간 규모의 처리량에 적합</td></tr><tr><td><strong>사용 사례</strong></td><td>- 실시간 데이터 스트리밍<br>- 이벤트 소싱<br>- 분산 시스템 모니터링<br>- 실시간 분석</td><td>- 작업 큐<br>- 비동기 처리<br>- 부하 분산<br>- 시스템 간 통신</td></tr><tr><td><strong>대표적 구현체</strong></td><td>- Apache Kafka<br>Apache Pulsar<br>AWS EventBridge</td><td>- RabbitMQ<br>ActiveMQ<br>AWS SQS</td></tr><tr><td><strong>메시지 유형</strong></td><td>이벤트(상태 변경을 나타내는 알림)</td><td>명령, 문서, 질의 등 다양한 유형의 메시지</td></tr><tr><td><strong>데이터 접근</strong></td><td>이벤트 스트림을 통한 시간 기반 접근</td><td>큐 기반의 순차적 접근</td></tr><tr><td><strong>재처리</strong></td><td>과거 이벤트의 재생과 재처리가 용이</td><td>일반적으로 한 번 처리된 메시지는 재처리가 어려움</td></tr><tr><td><strong>성능 특성</strong></td><td>- 높은 처리량<br>- 낮은 지연시간<br>- 대규모 확장성</td><td>- 중간 수준의 처리량<br>- 신뢰성 있는 전달<br>- 트랜잭션 지원</td></tr><tr><td><strong>복잡성</strong></td><td>상대적으로 복잡한 구현과 관리 필요</td><td>비교적 단순한 구현과 관리</td></tr><tr><td><strong>모니터링</strong></td><td>이벤트 흐름과 처리 현황의 실시간 모니터링 중요</td><td>큐의 길이와 처리 상태 모니터링</td></tr><tr><td><strong>장애 복구</strong></td><td>- 이벤트 로그를 통한 복구<br>- 분산 시스템의 복원력</td><td>- 메시지 재전송<br>- 트랜잭션 롤백</td></tr><tr><td><strong>통합 패턴</strong></td><td>- 이벤트 기반 통합<br>- 비동기 통신<br>- 느슨한 결합</td><td>- 포인트-투-포인트 통합<br>- 요청-응답 패턴<br>- 메시지 라우팅</td></tr><tr><td><strong>보안</strong></td><td>- 이벤트 수준의 접근 제어<br>- 스트림 암호화</td><td>- 메시지 수준의 보안<br>- 큐 접근 제어</td></tr><tr><td><strong>리소스 사용</strong></td><td>높은 처리량을 위해 더 많은 리소스 필요</td><td>상대적으로 적은 리소스로 운영 가능</td></tr><tr><td><strong>개발 복잡도</strong></td><td>이벤트 스키마 관리와 버전 관리가 더 복잡</td><td>비교적 단순한 메시지 구조와 관리</td></tr></tbody></table><p>Message Broker와 Event Broker의 가장 큰 차이점은 데이터 처리 방식과 보존 기간이다.<br>Message Broker는 일회성 메시지 전달에 초점을 맞추고 있어 메시지가 처리되면 삭제되는 반면, Event Broker는 이벤트를 지속적으로 보관하고 여러 서비스에서 재사용할 수 있도록 한다.</p><p>또한 확장성 측면에서도 차이가 있다.<br>Event Broker는 느슨한 결합을 제공하여 시스템을 쉽게 확장할 수 있지만, Message Broker는 상대적으로 강한 결합으로 인해 확장이 더 복잡할 수 있다.</p><p>두 시스템은 각각의 장단점이 있으며, 시스템의 요구사항과 사용 목적에 따라 적절한 선택이 필요하다.<br>예를 들어, 단순한 작업 큐가 필요하다면 Message Broker가, 실시간 데이터 분석이 필요하다면 Event Broker가 더 적합할 것이다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka</h2></header><div class=entry-content><p>Kafka Kafka는 LinkedIn에서 개발되어 현재는 Apache Software Foundation에서 관리하는 오픈소스 프로젝트입니다.
금융 서비스, IoT, 로그 집계, 실시간 분석 등 다양한 산업 분야에서 활용되고 있으며, 대규모 데이터 처리와 실시간 스트리밍이 필요한 현대적인 데이터 아키텍처에서 중요한 역할을 하고 있다.
데이터 파이프라인을 구축하기 위한 분산 메시징 시스템으로, 실시간 데이터 파이프라인과 스트리밍 애플리케이션을 구축하는 데 사용된다.
다음은 Python을 사용한 기본적인 Kafka 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from kafka import KafkaProducer, KafkaConsumer import json # 프로듀서 구현 class MessageProducer: def __init__(self, bootstrap_servers): self.producer = KafkaProducer( bootstrap_servers=bootstrap_servers, value_serializer=lambda v: json.dumps(v).encode('utf-8') ) def send_message(self, topic, message): future = self.producer.send(topic, message) try: future.get(timeout=10) # 메시지 전송 확인 print(f"Message sent successfully to {topic}") except Exception as e: print(f"Failed to send message: {e}") def close(self): self.producer.close() # 컨슈머 구현 class MessageConsumer: def __init__(self, bootstrap_servers, topic, group_id): self.consumer = KafkaConsumer( topic, bootstrap_servers=bootstrap_servers, group_id=group_id, value_deserializer=lambda x: json.loads(x.decode('utf-8')) ) def start_consuming(self): try: for message in self.consumer: print(f"Received: {message.value}") # 메시지 처리 로직 구현 except Exception as e: print(f"Error while consuming: {e}") 특징 분산 아키텍처:
...</p></div><footer class=entry-footer><span title='2025-01-16 00:54:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;823 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ</h2></header><div class=entry-content><p>RabbitMQ RabbitMQ는 메시지 브로커(Message Broker) 또는 메시지 큐 관리자로, AMQP(Advanced Message Queuing Protocol)를 구현한 오픈소스 소프트웨어이다.
애플리케이션 간에 메시지를 안전하게 전달하고 관리한다.
Python을 사용한 기본적인 RabbitMQ 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import pika # 연결 설정 connection = pika.BlockingConnection( pika.ConnectionParameters('localhost') ) channel = connection.channel() # 큐 선언 channel.queue_declare(queue='hello') # 메시지 발행 channel.basic_publish( exchange='', routing_key='hello', body='Hello World!' ) print(" [x] Sent 'Hello World!'") connection.close() 핵심 기능 메시지 큐잉: 생산자(sender)와 소비자(receiver) 간의 메시지 전달을 위한 큐 제공 비동기 통신: 서비스 간 비동기 상호작용을 가능하게 하여 확장성과 복원력 향상 내구성과 신뢰성: 메시지 지속성과 승인 메커니즘을 통한 메시지 손실 방지 다양한 교환 유형: direct, fanout, topic, headers 등 다양한 라우팅 옵션 제공 다중 언어 지원: Java, Python, JavaScript 등 다양한 프로그래밍 언어 지원 클러스터링과 고가용성: 부하 분산과 고가용성을 위한 클러스터 배포 가능 아키텍처 RabbitMQ의 아키텍처는 다음 주요 구성 요소로 이루어진다:
...</p></div><footer class=entry-footer><span title='2025-01-16 00:54:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;407 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>Message Queue 메시지 큐는 프로그램, 네트워크, 서비스 간에 데이터를 주고받을 때 사용하는 비동기 통신 방법.
Message Queue는 메시지를 임시로 저장하고 전달하는 중개자 역할을 한다.
Producer가 메시지를 큐에 전송하면, Consumer가 이를 처리할 준비가 될 때까지 메시지를 보관한다.
이는 시스템 컴포넌트 간의 결합도를 낮추고 확장성을 높이는 데 도움이 된다.
주요 특징 비동기 통신: Producer와 Consumer 간 직접적인 연결 없이 메시지를 교환할 수 있다. 내결함성: 메시지는 Consumer가 처리할 때까지 큐에 안전하게 저장된다. 시스템 장애 시에도 데이터 손실을 방지한다. 확장성: 트래픽 증가에 따라 Consumer를 쉽게 추가할 수 있어 시스템 확장이 용이하다. 부하 분산: 여러 Consumer가 메시지를 병렬로 처리하여 작업 부하를 분산시킬 수 있다. 순서 보장: FIFO(First-In-First-Out) 큐를 사용하여 메시지의 처리 순서를 보장할 수 있다. 메시지 큐의 장점 비동기 처리 시스템 간 느슨한 결합(Loose Coupling)을 제공합니다 생산자는 소비자의 처리 여부를 기다리지 않고 다음 작업을 진행할 수 있습니다 부하 분산 여러 소비자가 메시지를 나누어 처리할 수 있습니다 시스템의 부하를 효율적으로 분산시킬 수 있습니다 안정성 메시지가 유실되지 않고 안전하게 전달됩니다 시스템 장애 시에도 메시지가 보존됩니다 메시지 큐의 주요 구성요소 Producer (생산자)
...</p></div><footer class=entry-footer><span title='2024-10-28 06:56:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;467 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker</h2></header><div class=entry-content><p>Event Broker Event Broker는 이벤트 기반 아키텍처(Event-Driven Architecture, EDA)의 핵심 구성 요소로, 이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다.
Source: https://developer.confluent.io/patterns/event-stream/event-broker/
주요 기능 이벤트 수집 및 라우팅: 이벤트 생성자로부터 이벤트를 수집하고, 적절한 이벤트 소비자에게 전달한다. 이벤트 저장: 수신한 이벤트를 영구적으로 저장하여, 필요시 재처리나 분석이 가능하도록 한다. 실시간 처리: 대규모의 이벤트 데이터를 실시간으로 처리할 수 있는 능력을 제공한다. 순서 보장: 이벤트의 발생 순서를 유지하여 처리할 수 있도록 지원한다. 확장성 제공: 시스템의 확장에 따라 유연하게 대응할 수 있는 구조를 제공한다. Event Broker의 장점 시스템 분리 (Decoupling)
...</p></div><footer class=entry-footer><span title='2024-10-28 06:28:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker Message Broker는 소프트웨어 애플리케이션, 시스템 및 서비스 간의 통신을 가능하게 하는 중간 소프트웨어 모듈.
애플리케이션 간 통신을 중재하여 상호 의존성을 최소화한다.
Message Broker는 현대적인 분산 시스템과 마이크로서비스 아키텍처에서 중요한 역할을 하며, 시스템 간 효율적인 통신과 데이터 교환을 가능하게 한다.
Source: https://ademcatamak.medium.com/what-is-message-broker-4f6698c73089
주요 기능 메시지 라우팅: 하나 이상의 목적지로 메시지를 전달합니다. 메시지 변환: 다른 형식으로 메시지를 변환합니다. 메시지 집계 및 분해: 여러 메시지를 하나로 결합하거나 하나의 메시지를 여러 개로 분할합니다. 외부 저장소와 상호 작용: 메시지 저장 또는 보강을 위해 외부 저장소를 사용합니다. 웹 서비스 호출: 데이터 검색을 위해 웹 서비스를 호출합니다. 이벤트 및 오류 응답: 특정 이벤트나 오류에 대응합니다. 장점 서비스 간 결합도 감소: 애플리케이션 간 직접적인 의존성을 줄입니다. 확장성 향상: 새로운 서비스나 기능을 쉽게 추가할 수 있습니다. 신뢰성 제공: 메시지 지속성과 보장된 전달을 제공합니다. 비동기 통신 지원: 송신자가 수신자의 응답을 기다릴 필요가 없습니다. 유형 점대점(Point-to-Point) 브로커 메시지가 하나의 생산자에서 하나의 소비자로 직접 전달되는 방식
...</p></div><footer class=entry-footer><span title='2024-10-28 05:38:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1096 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-broker/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>