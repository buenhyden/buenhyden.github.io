<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Message Queue vs Message Broker vs Event Broker | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Event-Broker-and-Message-Broker,Message-Queue,Message-Broker,Event-Broker"><meta name=description content="Message Queue의 Event Broker와 Message Broker를 비교한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Message Queue vs Message Broker vs Event Broker"><meta property="og:description" content="Message Queue의 Event Broker와 Message Broker를 비교한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T07:27:00+00:00"><meta property="article:modified_time" content="2024-10-22T07:27:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="Event Broker-and-Message-Broker"><meta property="article:tag" content="Message-Queue"><meta property="article:tag" content="Message-Broker"><meta property="article:tag" content="Event-Broker"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Message Queue vs Message Broker vs Event Broker"><meta name=twitter:description content="Message Queue의 Event Broker와 Message Broker를 비교한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend","item":"https://buenhyden.github.io/posts/backend/"},{"@type":"ListItem","position":3,"name":"Message Queue vs Message Broker vs Event Broker","item":"https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Message Queue vs Message Broker vs Event Broker","name":"Message Queue vs Message Broker vs Event Broker","description":"Message Queue의 Event Broker와 Message Broker를 비교한다.","keywords":["Backend","Event-Broker-and-Message-Broker","Message-Queue","Message-Broker","Event-Broker"],"articleBody":"Message Queue Vs Message Broker Vs Event Broker Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:\n특성 Message Queue Message Broker Event Broker 주요 기능 메시지 저장 및 전달 메시지 라우팅, 변환, 저장 이벤트 라우팅, 스트리밍, 저장 통신 모델 주로 점대점(Point-to-Point) 점대점 및 발행-구독(Pub/Sub) 주로 발행-구독(Pub/Sub) 메시지 보존 소비 후 일반적으로 삭제 구성에 따라 다름 장기간 보존 가능 확장성 제한적 중간 높음 복잡성 낮음 중간 높음 주요 사용 사례 작업 큐잉, 비동기 처리 시스템 통합, 프로토콜 변환 실시간 데이터 스트리밍, 이벤트 소싱 메시지 순서 보장 일반적으로 보장 보장 가능 재생 기능 제한적 구성에 따라 다름 일반적으로 지원 프로토콜 지원 제한적 다양한 프로토콜 지원 다양한 프로토콜 지원 대표적 제품 RabbitMQ, Redis Apache Kafka, RabbitMQ Apache Kafka, Amazon Kinesis Message Queue Vs Message Broker Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:\n특성 Message Queue Message Broker 정의 메시지를 임시로 저장하고 전달하는 데이터 구조 메시지의 유효성 검사, 변환, 라우팅을 담당하는 중개 소프트웨어 주요 기능 메시지 저장 및 전달 메시지 라우팅, 변환, 프로토콜 변환, 저장 통신 모델 주로 점대점(Point-to-Point) 점대점 및 발행-구독(Pub/Sub) 지원 복잡성 상대적으로 단순 더 복잡하고 고급 기능 제공 확장성 제한적 높음 (클러스터링 지원) 메시지 보존 일반적으로 소비 후 삭제 구성에 따라 다름 (장기 보존 가능) 라우팅 기본적인 라우팅 복잡한 라우팅 규칙 지원 변환 기능 제한적 메시지 형식 변환 지원 프로토콜 지원 제한적 다양한 메시징 프로토콜 지원 사용 사례 간단한 비동기 작업 처리, 작업 분배 복잡한 엔터프라이즈 통합, 다중 시스템 연동 대표적 제품 RabbitMQ, ActiveMQ Apache Kafka, IBM MQ, RabbitMQ 성능 중간 높음 (대용량 처리에 적합) 관리 복잡성 낮음 높음 (더 많은 구성 옵션) 신뢰성 기본적인 신뢰성 보장 고급 신뢰성 및 내구성 기능 제공 Message Queue는 메시지를 임시로 저장하고 전달하는 간단한 데이터 구조이며, Message Broker는 메시지의 유효성 검사, 변환, 라우팅 등 더 복잡하고 고급 기능을 제공한다.\nMessage Queue: 주로 점대점(Point-to-Point) 통신 모델을 사용하며, Message Broker는 점대점 및 발행-구독(Pub/Sub) 모델을 모두 지원한다.\nMessage Queue는 메시지를 순차적으로 처리하며, 일반적으로 소비 후 삭제되지만, Message Broker는 복잡한 라우팅 규칙을 지원하고, 메시지 변환 기능을 제공한다.\nMessage Queue는 간단한 비동기 작업 처리, 작업 분배에 적합하며, Message Broker는 복잡한 엔터프라이즈 통합, 다중 시스템 연동에 적합한다.\n결론적으로, Message Queue는 Message Broker의 일부로 볼 수 있으며, Message Broker는 Message Queue의 기능을 포함하면서 더 확장된 기능을 제공하는 더 포괄적인 시스템이다.\nMessage Broker Vs Event Broker 비교 항목 Event Broker Message Broker 기본 개념 이벤트 중심 아키텍처를 지원하며, 이벤트의 발행과 구독을 관리 메시지 큐를 통해 시스템 간 메시지 전달을 관리 통신 패턴 발행-구독(Pub/Sub) 패턴이 주요 통신 방식 점대점(Point-to-Point) 통신이 주된 방식이며, Pub/Sub도 지원 데이터 지속성 이벤트 로그를 유지하며 과거 이벤트 재생 가능 메시지는 소비되면 일반적으로 큐에서 제거됨 메시지 소비 여러 소비자가 동일한 이벤트를 동시에 소비 가능 일반적으로 하나의 메시지는 하나의 소비자만 처리 순서 보장 이벤트 스트림 내에서 순서 보장 중시 메시지 순서는 선택적으로 보장 확장성 높은 처리량과 수평적 확장성에 최적화 중간 규모의 처리량에 적합 사용 사례 - 실시간 데이터 스트리밍\n- 이벤트 소싱\n- 분산 시스템 모니터링\n- 실시간 분석 - 작업 큐\n- 비동기 처리\n- 부하 분산\n- 시스템 간 통신 대표적 구현체 - Apache Kafka\nApache Pulsar\nAWS EventBridge - RabbitMQ\nActiveMQ\nAWS SQS 메시지 유형 이벤트(상태 변경을 나타내는 알림) 명령, 문서, 질의 등 다양한 유형의 메시지 데이터 접근 이벤트 스트림을 통한 시간 기반 접근 큐 기반의 순차적 접근 재처리 과거 이벤트의 재생과 재처리가 용이 일반적으로 한 번 처리된 메시지는 재처리가 어려움 성능 특성 - 높은 처리량\n- 낮은 지연시간\n- 대규모 확장성 - 중간 수준의 처리량\n- 신뢰성 있는 전달\n- 트랜잭션 지원 복잡성 상대적으로 복잡한 구현과 관리 필요 비교적 단순한 구현과 관리 모니터링 이벤트 흐름과 처리 현황의 실시간 모니터링 중요 큐의 길이와 처리 상태 모니터링 장애 복구 - 이벤트 로그를 통한 복구\n- 분산 시스템의 복원력 - 메시지 재전송\n- 트랜잭션 롤백 통합 패턴 - 이벤트 기반 통합\n- 비동기 통신\n- 느슨한 결합 - 포인트-투-포인트 통합\n- 요청-응답 패턴\n- 메시지 라우팅 보안 - 이벤트 수준의 접근 제어\n- 스트림 암호화 - 메시지 수준의 보안\n- 큐 접근 제어 리소스 사용 높은 처리량을 위해 더 많은 리소스 필요 상대적으로 적은 리소스로 운영 가능 개발 복잡도 이벤트 스키마 관리와 버전 관리가 더 복잡 비교적 단순한 메시지 구조와 관리 Message Broker와 Event Broker의 가장 큰 차이점은 데이터 처리 방식과 보존 기간이다.\nMessage Broker는 일회성 메시지 전달에 초점을 맞추고 있어 메시지가 처리되면 삭제되는 반면, Event Broker는 이벤트를 지속적으로 보관하고 여러 서비스에서 재사용할 수 있도록 한다.\n또한 확장성 측면에서도 차이가 있다.\nEvent Broker는 느슨한 결합을 제공하여 시스템을 쉽게 확장할 수 있지만, Message Broker는 상대적으로 강한 결합으로 인해 확장이 더 복잡할 수 있다.\n두 시스템은 각각의 장단점이 있으며, 시스템의 요구사항과 사용 목적에 따라 적절한 선택이 필요하다.\n예를 들어, 단순한 작업 큐가 필요하다면 Message Broker가, 실시간 데이터 분석이 필요하다면 Event Broker가 더 적합할 것이다.\n참고 및 출처 ","wordCount":"760","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-22T07:27:00Z","dateModified":"2024-10-22T07:27:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend/>Backend</a></div><h1 class="post-title entry-hint-parent">Message Queue vs Message Broker vs Event Broker</h1><div class=post-description>Message Queue의 Event Broker와 Message Broker를 비교한다.</div><div class=post-meta><span title='2024-10-22 07:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;760 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend/Event%20Broker%20and%20Message%20Broker/Message-Queue-vs-Message-Broker-vs-Event-Broker.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#message-queue-vs-message-broker-vs-event-broker>Message Queue Vs Message Broker Vs Event Broker</a><ul><li><a href=#message-queue-vs-message-broker>Message Queue Vs Message Broker</a></li><li><a href=#message-broker-vs-event-broker>Message Broker Vs Event Broker</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=message-queue-vs-message-broker-vs-event-broker>Message Queue Vs Message Broker Vs Event Broker<a hidden class=anchor aria-hidden=true href=#message-queue-vs-message-broker-vs-event-broker>#</a></h2><p>Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:</p><table><thead><tr><th>특성</th><th>Message Queue</th><th>Message Broker</th><th>Event Broker</th></tr></thead><tbody><tr><td>주요 기능</td><td>메시지 저장 및 전달</td><td>메시지 라우팅, 변환, 저장</td><td>이벤트 라우팅, 스트리밍, 저장</td></tr><tr><td>통신 모델</td><td>주로 점대점(Point-to-Point)</td><td>점대점 및 발행-구독(Pub/Sub)</td><td>주로 발행-구독(Pub/Sub)</td></tr><tr><td>메시지 보존</td><td>소비 후 일반적으로 삭제</td><td>구성에 따라 다름</td><td>장기간 보존 가능</td></tr><tr><td>확장성</td><td>제한적</td><td>중간</td><td>높음</td></tr><tr><td>복잡성</td><td>낮음</td><td>중간</td><td>높음</td></tr><tr><td>주요 사용 사례</td><td>작업 큐잉, 비동기 처리</td><td>시스템 통합, 프로토콜 변환</td><td>실시간 데이터 스트리밍, 이벤트 소싱</td></tr><tr><td>메시지 순서</td><td>보장</td><td>일반적으로 보장</td><td>보장 가능</td></tr><tr><td>재생 기능</td><td>제한적</td><td>구성에 따라 다름</td><td>일반적으로 지원</td></tr><tr><td>프로토콜 지원</td><td>제한적</td><td>다양한 프로토콜 지원</td><td>다양한 프로토콜 지원</td></tr><tr><td>대표적 제품</td><td>RabbitMQ, Redis</td><td>Apache Kafka, RabbitMQ</td><td>Apache Kafka, Amazon Kinesis</td></tr></tbody></table><h3 id=message-queue-vs-message-broker>Message Queue Vs Message Broker<a hidden class=anchor aria-hidden=true href=#message-queue-vs-message-broker>#</a></h3><p>Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:</p><table><thead><tr><th>특성</th><th>Message Queue</th><th>Message Broker</th></tr></thead><tbody><tr><td>정의</td><td>메시지를 임시로 저장하고 전달하는 데이터 구조</td><td>메시지의 유효성 검사, 변환, 라우팅을 담당하는 중개 소프트웨어</td></tr><tr><td>주요 기능</td><td>메시지 저장 및 전달</td><td>메시지 라우팅, 변환, 프로토콜 변환, 저장</td></tr><tr><td>통신 모델</td><td>주로 점대점(Point-to-Point)</td><td>점대점 및 발행-구독(Pub/Sub) 지원</td></tr><tr><td>복잡성</td><td>상대적으로 단순</td><td>더 복잡하고 고급 기능 제공</td></tr><tr><td>확장성</td><td>제한적</td><td>높음 (클러스터링 지원)</td></tr><tr><td>메시지 보존</td><td>일반적으로 소비 후 삭제</td><td>구성에 따라 다름 (장기 보존 가능)</td></tr><tr><td>라우팅</td><td>기본적인 라우팅</td><td>복잡한 라우팅 규칙 지원</td></tr><tr><td>변환 기능</td><td>제한적</td><td>메시지 형식 변환 지원</td></tr><tr><td>프로토콜 지원</td><td>제한적</td><td>다양한 메시징 프로토콜 지원</td></tr><tr><td>사용 사례</td><td>간단한 비동기 작업 처리, 작업 분배</td><td>복잡한 엔터프라이즈 통합, 다중 시스템 연동</td></tr><tr><td>대표적 제품</td><td>RabbitMQ, ActiveMQ</td><td>Apache Kafka, IBM MQ, RabbitMQ</td></tr><tr><td>성능</td><td>중간</td><td>높음 (대용량 처리에 적합)</td></tr><tr><td>관리 복잡성</td><td>낮음</td><td>높음 (더 많은 구성 옵션)</td></tr><tr><td>신뢰성</td><td>기본적인 신뢰성 보장</td><td>고급 신뢰성 및 내구성 기능 제공</td></tr></tbody></table><p>Message Queue는 메시지를 임시로 저장하고 전달하는 간단한 데이터 구조이며, Message Broker는 메시지의 유효성 검사, 변환, 라우팅 등 더 복잡하고 고급 기능을 제공한다.</p><p>Message Queue: 주로 점대점(Point-to-Point) 통신 모델을 사용하며, Message Broker는 점대점 및 발행-구독(Pub/Sub) 모델을 모두 지원한다.</p><p>Message Queue는 메시지를 순차적으로 처리하며, 일반적으로 소비 후 삭제되지만, Message Broker는 복잡한 라우팅 규칙을 지원하고, 메시지 변환 기능을 제공한다.</p><p>Message Queue는 간단한 비동기 작업 처리, 작업 분배에 적합하며, Message Broker는 복잡한 엔터프라이즈 통합, 다중 시스템 연동에 적합한다.</p><p>결론적으로, Message Queue는 Message Broker의 일부로 볼 수 있으며, Message Broker는 Message Queue의 기능을 포함하면서 더 확장된 기능을 제공하는 더 포괄적인 시스템이다.</p><h3 id=message-broker-vs-event-broker>Message Broker Vs Event Broker<a hidden class=anchor aria-hidden=true href=#message-broker-vs-event-broker>#</a></h3><table><thead><tr><th>비교 항목</th><th>Event Broker</th><th>Message Broker</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>이벤트 중심 아키텍처를 지원하며, 이벤트의 발행과 구독을 관리</td><td>메시지 큐를 통해 시스템 간 메시지 전달을 관리</td></tr><tr><td><strong>통신 패턴</strong></td><td>발행-구독(Pub/Sub) 패턴이 주요 통신 방식</td><td>점대점(Point-to-Point) 통신이 주된 방식이며, Pub/Sub도 지원</td></tr><tr><td><strong>데이터 지속성</strong></td><td>이벤트 로그를 유지하며 과거 이벤트 재생 가능</td><td>메시지는 소비되면 일반적으로 큐에서 제거됨</td></tr><tr><td><strong>메시지 소비</strong></td><td>여러 소비자가 동일한 이벤트를 동시에 소비 가능</td><td>일반적으로 하나의 메시지는 하나의 소비자만 처리</td></tr><tr><td><strong>순서 보장</strong></td><td>이벤트 스트림 내에서 순서 보장 중시</td><td>메시지 순서는 선택적으로 보장</td></tr><tr><td><strong>확장성</strong></td><td>높은 처리량과 수평적 확장성에 최적화</td><td>중간 규모의 처리량에 적합</td></tr><tr><td><strong>사용 사례</strong></td><td>- 실시간 데이터 스트리밍<br>- 이벤트 소싱<br>- 분산 시스템 모니터링<br>- 실시간 분석</td><td>- 작업 큐<br>- 비동기 처리<br>- 부하 분산<br>- 시스템 간 통신</td></tr><tr><td><strong>대표적 구현체</strong></td><td>- Apache Kafka<br>Apache Pulsar<br>AWS EventBridge</td><td>- RabbitMQ<br>ActiveMQ<br>AWS SQS</td></tr><tr><td><strong>메시지 유형</strong></td><td>이벤트(상태 변경을 나타내는 알림)</td><td>명령, 문서, 질의 등 다양한 유형의 메시지</td></tr><tr><td><strong>데이터 접근</strong></td><td>이벤트 스트림을 통한 시간 기반 접근</td><td>큐 기반의 순차적 접근</td></tr><tr><td><strong>재처리</strong></td><td>과거 이벤트의 재생과 재처리가 용이</td><td>일반적으로 한 번 처리된 메시지는 재처리가 어려움</td></tr><tr><td><strong>성능 특성</strong></td><td>- 높은 처리량<br>- 낮은 지연시간<br>- 대규모 확장성</td><td>- 중간 수준의 처리량<br>- 신뢰성 있는 전달<br>- 트랜잭션 지원</td></tr><tr><td><strong>복잡성</strong></td><td>상대적으로 복잡한 구현과 관리 필요</td><td>비교적 단순한 구현과 관리</td></tr><tr><td><strong>모니터링</strong></td><td>이벤트 흐름과 처리 현황의 실시간 모니터링 중요</td><td>큐의 길이와 처리 상태 모니터링</td></tr><tr><td><strong>장애 복구</strong></td><td>- 이벤트 로그를 통한 복구<br>- 분산 시스템의 복원력</td><td>- 메시지 재전송<br>- 트랜잭션 롤백</td></tr><tr><td><strong>통합 패턴</strong></td><td>- 이벤트 기반 통합<br>- 비동기 통신<br>- 느슨한 결합</td><td>- 포인트-투-포인트 통합<br>- 요청-응답 패턴<br>- 메시지 라우팅</td></tr><tr><td><strong>보안</strong></td><td>- 이벤트 수준의 접근 제어<br>- 스트림 암호화</td><td>- 메시지 수준의 보안<br>- 큐 접근 제어</td></tr><tr><td><strong>리소스 사용</strong></td><td>높은 처리량을 위해 더 많은 리소스 필요</td><td>상대적으로 적은 리소스로 운영 가능</td></tr><tr><td><strong>개발 복잡도</strong></td><td>이벤트 스키마 관리와 버전 관리가 더 복잡</td><td>비교적 단순한 메시지 구조와 관리</td></tr></tbody></table><p>Message Broker와 Event Broker의 가장 큰 차이점은 데이터 처리 방식과 보존 기간이다.<br>Message Broker는 일회성 메시지 전달에 초점을 맞추고 있어 메시지가 처리되면 삭제되는 반면, Event Broker는 이벤트를 지속적으로 보관하고 여러 서비스에서 재사용할 수 있도록 한다.</p><p>또한 확장성 측면에서도 차이가 있다.<br>Event Broker는 느슨한 결합을 제공하여 시스템을 쉽게 확장할 수 있지만, Message Broker는 상대적으로 강한 결합으로 인해 확장이 더 복잡할 수 있다.</p><p>두 시스템은 각각의 장단점이 있으며, 시스템의 요구사항과 사용 목적에 따라 적절한 선택이 필요하다.<br>예를 들어, 단순한 작업 큐가 필요하다면 Message Broker가, 실시간 데이터 분석이 필요하다면 Event Broker가 더 적합할 것이다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/event-broker-and-message-broker/>Event Broker-and-Message-Broker</a></li><li><a href=https://buenhyden.github.io/tags/message-queue/>Message-Queue</a></li><li><a href=https://buenhyden.github.io/tags/message-broker/>Message-Broker</a></li><li><a href=https://buenhyden.github.io/tags/event-broker/>Event-Broker</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend/web-application-server/web-application-server-and-web-server/><span class=title>« Prev</span><br><span>Web Application Server (WAS) and Web Server</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy-vs-cache-policy/><span class=title>Next »</span><br><span>Cache Strategy vs Cache Policy</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>