<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types of Real-time APIs | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design,Real-time-APIs,Types"><meta name=description content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/types-of-real-time-apis/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/types-of-real-time-apis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/types-of-real-time-apis/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types of Real-time APIs"><meta property="og:description" content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-15T01:56:00+00:00"><meta property="article:modified_time" content="2025-02-15T01:56:00+00:00"><meta property="article:tag" content="Backend Development"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Real-Time-APIs"><meta property="article:tag" content="Types"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types of Real-time APIs"><meta name=twitter:description content="Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Networking and Communication","item":"https://buenhyden.github.io/posts/networking-and-communication/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Network","item":"https://buenhyden.github.io/posts/networking-and-communication/fundamentals/"},{"@type":"ListItem","position":4,"name":"Real-time APIs","item":"https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/"},{"@type":"ListItem","position":5,"name":"Types of Real-time APIs","item":"https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/types-of-real-time-apis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Types of Real-time APIs","name":"Types of Real-time APIs","description":"Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다.","keywords":["Backend-Development","API-Design","Real-time-APIs","Types"],"articleBody":"Types of Real-time APIs Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다. 이는 사용자 경험을 향상시키고, 데이터 정확성과 응답성을 높이는 데 중요한 역할을 한다.\nReal-time API의 주요 유형 WebSocket API 특징: 단일 TCP 연결을 통해 양방향 통신을 지원. 클라이언트와 서버가 모두 데이터를 주고받을 수 있음. 낮은 지연 시간과 효율적인 데이터 전송 가능. 사용 사례: 채팅 애플리케이션, 온라인 게임, 협업 도구. Server-Sent Events (SSE) API 특징: HTTP 기반 단방향 통신(서버 → 클라이언트). 지속적인 연결 유지 및 자동 재연결 지원. 텍스트 기반 데이터 전송(UTF-8). 사용 사례: 실시간 알림, 뉴스 피드, 주식 가격 업데이트. Streaming API 특징: 서버에서 클라이언트로 지속적인 데이터 스트림 제공. 대규모 데이터 처리에 적합(예: 비디오, 오디오 스트리밍). WebSocket 또는 SSE를 기반으로 구현 가능. 사용 사례: 라이브 비디오 스트리밍, 소셜 미디어 피드, IoT 센서 데이터. Pub/Sub API 특징: Publish-Subscribe 패턴 기반. 발행자(Publisher)가 특정 주제(Topic)에 메시지를 게시하면 구독자(Subscriber)가 이를 수신. 데이터 생산자와 소비자를 분리하여 확장성과 효율성 제공. 사용 사례: 메시징 시스템(Kafka, PubNub), IoT 장치 간 통신. Push API 특징: 서버에서 클라이언트로 푸시 알림 전송. 클라이언트가 활성화되지 않아도 메시지 수신 가능. 모바일 애플리케이션에서 주로 사용됨. 사용 사례: 모바일 푸시 알림(Firebase Cloud Messaging), 이메일 알림. Event-Driven API 특징: 이벤트 중심 설계로 상태 변화나 특정 이벤트 발생 시 데이터를 전달. 이벤트 구독 및 처리에 최적화됨. 사용 사례: IoT 애플리케이션, 실시간 모니터링 시스템. Real-Time API 기술 비교 기본 특성 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 통신 방향 양방향(전이중) 단방향(서버→클라이언트) 단방향/양방향 가능 다방향(다대다) 단방향(서버→클라이언트) 이벤트 기반 프로토콜 WS/WSS HTTP/HTTPS HTTP/HTTPS 다양(MQTT, AMQP 등) HTTP/HTTPS 다양 연결 유지 지속 연결 지속 연결 지속 연결 지속/비지속 가능 비연결성 이벤트 발생 시 자동 재연결 수동 구현 필요 내장 지원 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 메시지 포맷 텍스트/바이너리 텍스트(UTF-8) 다양(JSON, XML 등) 다양 JSON 다양 데이터 크기 프레임 크기 제한 제한 없음 청크 단위 전송 일반적으로 작은 메시지 작은 메시지 이벤트 크기 기술적 특성 및 구현 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 연결 설정 HTTP 업그레이드 후 WS 프로토콜 일반 HTTP 연결 HTTP 연결 다양한 연결 방식 서비스 워커 등록 이벤트 리스너 등록 클라이언트 API WebSocket EventSource HTTP/Fetch 라이브러리별 다양 Push API, Service Worker 이벤트 리스너 서버 구현 WebSocket 서버 필요 일반 HTTP 서버 일반 HTTP 서버 메시지 브로커 서버 푸시 서비스 이벤트 처리 시스템 확장성 연결 유지 부담 상대적으로 가벼움 리소스 집약적 높은 확장성 높은 확장성 높은 확장성 헤더 오버헤드 낮음(최초 연결 후) 중간 중간 낮음 중간 구현에 따라 다름 통합 난이도 중간 쉬움 중간 중간~어려움 어려움 중간~어려움 활용 사례 및 지원 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 즉시성 매우 높음 높음 중간~높음 중간~높음 중간 중간~높음 브라우저 지원 대부분 지원 대부분 지원(IE 제외) 모두 지원 라이브러리 필요 대부분 지원 구현에 따라 다름 보안 고려사항 WSS 필수, 인증 필요 HTTPS 권장, 인증 필요 HTTPS 권장, 인증 필요 인증/권한 관리 중요 인증 키/토큰 관리 이벤트 검증 중요 리소스 사용량 중간~높음 낮음~중간 중간~높음 중간 낮음 중간 최적 사용 사례 채팅, 게임, 협업 도구 알림, 뉴스 피드, 실시간 데이터 대용량 데이터 전송 분산 메시징, IoT 알림, 백그라운드 메시지 마이크로서비스, 이벤트 기록 성능 및 구현 고려사항 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 지연 시간 매우 낮음(~100ms) 낮음(~500ms) 중간(~1s) 중간 높음(몇 초~몇 분) 구현에 따라 다름 처리량 높음 중간 매우 높음 매우 높음 낮음 구현에 따라 다름 배터리 영향 중간~높음 낮음~중간 중간~높음 구현에 따라 다름 낮음(백그라운드) 구현에 따라 다름 방화벽 통과 일부 제한 가능 대부분 허용 대부분 허용 혼합 대부분 허용 구현에 따라 다름 저대역폭 환경 적합하지 않음 적합함 적합하지 않음 구현에 따라 다름 적합함 구현에 따라 다름 오프라인 지원 미지원 미지원 미지원 일부 지원 가능 지원(백그라운드) 일부 지원 가능 용어 정리 용어 설명 참고 및 출처 ","wordCount":"618","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-15T01:56:00Z","dateModified":"2025-02-15T01:56:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/types-of-real-time-apis/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communication/>Networking and Communication</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/>Fundamentals of Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/real-time-communication/>Real-time APIs</a></div><h1 class="post-title entry-hint-parent">Types of Real-time APIs</h1><div class=post-description>Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다.</div><div class=post-meta><span title='2025-02-15 01:56:00 +0000 UTC'>February 15, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Networking%20and%20Communication/Fundamentals/Real-time%20Communication/Types-of-Real-time-APIs.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#types-of-real-time-apis>Types of Real-time APIs</a><ul><li><a href=#real-time-api의-주요-유형><strong>Real-time API의 주요 유형</strong></a></li><li><a href=#real-time-api-기술-비교>Real-Time API 기술 비교</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=types-of-real-time-apis>Types of Real-time APIs<a hidden class=anchor aria-hidden=true href=#types-of-real-time-apis>#</a></h2><p>Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다. 이는 사용자 경험을 향상시키고, 데이터 정확성과 응답성을 높이는 데 중요한 역할을 한다.</p><h3 id=real-time-api의-주요-유형><strong>Real-time API의 주요 유형</strong><a hidden class=anchor aria-hidden=true href=#real-time-api의-주요-유형>#</a></h3><h4 id=websocket-api>WebSocket API<a hidden class=anchor aria-hidden=true href=#websocket-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>단일 TCP 연결을 통해 양방향 통신을 지원.</li><li>클라이언트와 서버가 모두 데이터를 주고받을 수 있음.</li><li>낮은 지연 시간과 효율적인 데이터 전송 가능.</li></ul></li><li><strong>사용 사례</strong>: 채팅 애플리케이션, 온라인 게임, 협업 도구.</li></ul><h4 id=server-sent-events-sse-api>Server-Sent Events (SSE) API<a hidden class=anchor aria-hidden=true href=#server-sent-events-sse-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>HTTP 기반 단방향 통신(서버 → 클라이언트).</li><li>지속적인 연결 유지 및 자동 재연결 지원.</li><li>텍스트 기반 데이터 전송(UTF-8).</li></ul></li><li><strong>사용 사례</strong>: 실시간 알림, 뉴스 피드, 주식 가격 업데이트.</li></ul><h4 id=streaming-api>Streaming API<a hidden class=anchor aria-hidden=true href=#streaming-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>서버에서 클라이언트로 지속적인 데이터 스트림 제공.</li><li>대규모 데이터 처리에 적합(예: 비디오, 오디오 스트리밍).</li><li>WebSocket 또는 SSE를 기반으로 구현 가능.</li></ul></li><li><strong>사용 사례</strong>: 라이브 비디오 스트리밍, 소셜 미디어 피드, IoT 센서 데이터.</li></ul><h4 id=pubsub-api>Pub/Sub API<a hidden class=anchor aria-hidden=true href=#pubsub-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>Publish-Subscribe 패턴 기반.</li><li>발행자(Publisher)가 특정 주제(Topic)에 메시지를 게시하면 구독자(Subscriber)가 이를 수신.</li><li>데이터 생산자와 소비자를 분리하여 확장성과 효율성 제공.</li></ul></li><li><strong>사용 사례</strong>: 메시징 시스템(Kafka, PubNub), IoT 장치 간 통신.</li></ul><h4 id=push-api>Push API<a hidden class=anchor aria-hidden=true href=#push-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>서버에서 클라이언트로 푸시 알림 전송.</li><li>클라이언트가 활성화되지 않아도 메시지 수신 가능.</li><li>모바일 애플리케이션에서 주로 사용됨.</li><li><strong>사용 사례</strong>: 모바일 푸시 알림(Firebase Cloud Messaging), 이메일 알림.</li></ul></li></ul><h4 id=event-driven-api>Event-Driven API<a hidden class=anchor aria-hidden=true href=#event-driven-api>#</a></h4><ul><li><strong>특징</strong>:<ul><li>이벤트 중심 설계로 상태 변화나 특정 이벤트 발생 시 데이터를 전달.</li><li>이벤트 구독 및 처리에 최적화됨.</li><li><strong>사용 사례</strong>: IoT 애플리케이션, 실시간 모니터링 시스템.</li></ul></li></ul><h3 id=real-time-api-기술-비교>Real-Time API 기술 비교<a hidden class=anchor aria-hidden=true href=#real-time-api-기술-비교>#</a></h3><h4 id=기본-특성-비교>기본 특성 비교<a hidden class=anchor aria-hidden=true href=#기본-특성-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>통신 방향</strong></td><td>양방향(전이중)</td><td>단방향(서버→클라이언트)</td><td>단방향/양방향 가능</td><td>다방향(다대다)</td><td>단방향(서버→클라이언트)</td><td>이벤트 기반</td></tr><tr><td><strong>프로토콜</strong></td><td>WS/WSS</td><td>HTTP/HTTPS</td><td>HTTP/HTTPS</td><td>다양(MQTT, AMQP 등)</td><td>HTTP/HTTPS</td><td>다양</td></tr><tr><td><strong>연결 유지</strong></td><td>지속 연결</td><td>지속 연결</td><td>지속 연결</td><td>지속/비지속 가능</td><td>비연결성</td><td>이벤트 발생 시</td></tr><tr><td><strong>자동 재연결</strong></td><td>수동 구현 필요</td><td>내장 지원</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td><td>구현에 따라 다름</td></tr><tr><td><strong>메시지 포맷</strong></td><td>텍스트/바이너리</td><td>텍스트(UTF-8)</td><td>다양(JSON, XML 등)</td><td>다양</td><td>JSON</td><td>다양</td></tr><tr><td><strong>데이터 크기</strong></td><td>프레임 크기 제한</td><td>제한 없음</td><td>청크 단위 전송</td><td>일반적으로 작은 메시지</td><td>작은 메시지</td><td>이벤트 크기</td></tr></tbody></table><h4 id=기술적-특성-및-구현-비교>기술적 특성 및 구현 비교<a hidden class=anchor aria-hidden=true href=#기술적-특성-및-구현-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>연결 설정</strong></td><td>HTTP 업그레이드 후 WS 프로토콜</td><td>일반 HTTP 연결</td><td>HTTP 연결</td><td>다양한 연결 방식</td><td>서비스 워커 등록</td><td>이벤트 리스너 등록</td></tr><tr><td><strong>클라이언트 API</strong></td><td>WebSocket</td><td>EventSource</td><td>HTTP/Fetch</td><td>라이브러리별 다양</td><td>Push API, Service Worker</td><td>이벤트 리스너</td></tr><tr><td><strong>서버 구현</strong></td><td>WebSocket 서버 필요</td><td>일반 HTTP 서버</td><td>일반 HTTP 서버</td><td>메시지 브로커 서버</td><td>푸시 서비스</td><td>이벤트 처리 시스템</td></tr><tr><td><strong>확장성</strong></td><td>연결 유지 부담</td><td>상대적으로 가벼움</td><td>리소스 집약적</td><td>높은 확장성</td><td>높은 확장성</td><td>높은 확장성</td></tr><tr><td><strong>헤더 오버헤드</strong></td><td>낮음(최초 연결 후)</td><td>중간</td><td>중간</td><td>낮음</td><td>중간</td><td>구현에 따라 다름</td></tr><tr><td><strong>통합 난이도</strong></td><td>중간</td><td>쉬움</td><td>중간</td><td>중간~어려움</td><td>어려움</td><td>중간~어려움</td></tr></tbody></table><h4 id=활용-사례-및-지원-비교>활용 사례 및 지원 비교<a hidden class=anchor aria-hidden=true href=#활용-사례-및-지원-비교>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>즉시성</strong></td><td>매우 높음</td><td>높음</td><td>중간~높음</td><td>중간~높음</td><td>중간</td><td>중간~높음</td></tr><tr><td><strong>브라우저 지원</strong></td><td>대부분 지원</td><td>대부분 지원(IE 제외)</td><td>모두 지원</td><td>라이브러리 필요</td><td>대부분 지원</td><td>구현에 따라 다름</td></tr><tr><td><strong>보안 고려사항</strong></td><td>WSS 필수, 인증 필요</td><td>HTTPS 권장, 인증 필요</td><td>HTTPS 권장, 인증 필요</td><td>인증/권한 관리 중요</td><td>인증 키/토큰 관리</td><td>이벤트 검증 중요</td></tr><tr><td><strong>리소스 사용량</strong></td><td>중간~높음</td><td>낮음~중간</td><td>중간~높음</td><td>중간</td><td>낮음</td><td>중간</td></tr><tr><td><strong>최적 사용 사례</strong></td><td>채팅, 게임, 협업 도구</td><td>알림, 뉴스 피드, 실시간 데이터</td><td>대용량 데이터 전송</td><td>분산 메시징, IoT</td><td>알림, 백그라운드 메시지</td><td>마이크로서비스, 이벤트 기록</td></tr></tbody></table><h4 id=성능-및-구현-고려사항>성능 및 구현 고려사항<a hidden class=anchor aria-hidden=true href=#성능-및-구현-고려사항>#</a></h4><table><thead><tr><th>특성</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th><th>Streaming API</th><th>Pub/Sub API</th><th>Push API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>지연 시간</strong></td><td>매우 낮음(~100ms)</td><td>낮음(~500ms)</td><td>중간(~1s)</td><td>중간</td><td>높음(몇 초~몇 분)</td><td>구현에 따라 다름</td></tr><tr><td><strong>처리량</strong></td><td>높음</td><td>중간</td><td>매우 높음</td><td>매우 높음</td><td>낮음</td><td>구현에 따라 다름</td></tr><tr><td><strong>배터리 영향</strong></td><td>중간~높음</td><td>낮음~중간</td><td>중간~높음</td><td>구현에 따라 다름</td><td>낮음(백그라운드)</td><td>구현에 따라 다름</td></tr><tr><td><strong>방화벽 통과</strong></td><td>일부 제한 가능</td><td>대부분 허용</td><td>대부분 허용</td><td>혼합</td><td>대부분 허용</td><td>구현에 따라 다름</td></tr><tr><td><strong>저대역폭 환경</strong></td><td>적합하지 않음</td><td>적합함</td><td>적합하지 않음</td><td>구현에 따라 다름</td><td>적합함</td><td>구현에 따라 다름</td></tr><tr><td><strong>오프라인 지원</strong></td><td>미지원</td><td>미지원</td><td>미지원</td><td>일부 지원 가능</td><td>지원(백그라운드)</td><td>일부 지원 가능</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/real-time-apis/>Real-Time-APIs</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/><span class=title>« Prev</span><br><span>Javascript Engines</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/software-development/service-and-application-engineering/api-design-and-implementation/api-monitoring-and-analytics/api-monitoring/><span class=title>Next »</span><br><span>Monitoring</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>