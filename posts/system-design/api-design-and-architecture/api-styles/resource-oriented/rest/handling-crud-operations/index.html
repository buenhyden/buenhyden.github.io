<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Handling CRUD Operations | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,API-Styles,RESTful-API,Handling-CRUD-Operations"><meta name=description content="CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Handling CRUD Operations"><meta property="og:description" content="CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Handling CRUD Operations"><meta name=twitter:description content="CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기록하고 기억하고 활용하자.","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"},{"@type":"ListItem","position":3,"name":"API Design and Implementation","item":"https://buenhyden.github.io/posts/system-design/api-design-and-architecture/"},{"@type":"ListItem","position":4,"name":"API Styles","item":"https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/"},{"@type":"ListItem","position":5,"name":"Resource Style","item":""},{"@type":"ListItem","position":6,"name":"RESTful API","item":"https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/"},{"@type":"ListItem","position":7,"name":"Handling CRUD Operations","item":"https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기록하고 기억하고 활용하자.</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/>System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/>API Design and Implementation</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/>API Styles</a>&nbsp;»&nbsp;<a href>Resource Style</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/>RESTful API</a></div><h1>Handling CRUD Operations</h1><div class=post-description>CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다.</div></header><div class=post-content><h2 id=handling-crud-operations>Handling CRUD Operations<a hidden class=anchor aria-hidden=true href=#handling-crud-operations>#</a></h2><p>CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다.<br>이러한 작업은 데이터베이스, API 디자인, 애플리케이션 개발 등 다양한 분야에서 핵심적인 역할을 한다.</p><p>RESTful API에서 CRUD 작업 처리는 API 설계의 핵심이다. 표준 HTTP 메서드와 상태 코드를 활용하고, 자원 모델링, 엔드포인트 설계, 보안, 에러 핸들링 등 다양한 요소를 고려하여 효율적이고 안정적인 API를 구축해야 한다. 또한, 전통적인 CRUD 방식의 문제점을 인식하고, Get-and-Set, Get-and-Patch, Timestamp-Checked와 같은 대안을 고려하여 API의 유연성과 확장성을 높일 수 있다.</p><h3 id=crud-작업과-http-메서드-매핑>CRUD 작업과 HTTP 메서드 매핑<a hidden class=anchor aria-hidden=true href=#crud-작업과-http-메서드-매핑>#</a></h3><p>RESTful API에서는 CRUD 작업을 표준 HTTP 메서드와 매핑하여 구현한다.</p><table><thead><tr><th>CRUD 작업</th><th>HTTP 메서드</th><th>설명</th></tr></thead><tbody><tr><td>Create</td><td>POST</td><td>새로운 리소스를 생성합니다.</td></tr><tr><td>Read</td><td>GET</td><td>리소스의 현재 상태를 조회합니다.</td></tr><tr><td>Update</td><td>PUT/PATCH</td><td>리소스의 전체 또는 일부를 업데이트합니다.</td></tr><tr><td>Delete</td><td>DELETE</td><td>리소스를 삭제합니다.</td></tr></tbody></table><h3 id=crud-api의-중요성>CRUD API의 중요성<a hidden class=anchor aria-hidden=true href=#crud-api의-중요성>#</a></h3><ul><li><strong>일관성</strong>: 표준화된 방식으로 데이터를 관리하고 접근할 수 있도록 한다.</li><li><strong>확장성</strong>: 애플리케이션의 규모가 커짐에 따라 효율적으로 데이터를 처리할 수 있도록 지원한다.</li><li><strong>유연성</strong>: 다양한 클라이언트가 API를 통해 데이터에 접근하고 수정할 수 있도록 한다.</li></ul><h3 id=crud-api-설계-시-고려사항>CRUD API 설계 시 고려사항<a hidden class=anchor aria-hidden=true href=#crud-api-설계-시-고려사항>#</a></h3><ol><li><p><strong>자원 모델링</strong>:</p><ul><li>API의 핵심 자원을 식별하고, 각 자원에 대한 명확한 정의를 내린다.</li><li>자원 간의 관계를 설정하여 API 엔드포인트를 설계한다.</li></ul></li><li><p><strong>엔드포인트 설계</strong>:</p><ul><li>각 자원에 대한 CRUD 작업을 수행할 수 있는 엔드포인트를 정의한다.</li><li>일관성 있는 명명 규칙을 사용하여 엔드포인트를 설계한다. (예: <code>/users</code>, <code>/users/{id}</code>)</li></ul></li><li><p><strong>요청 및 응답 형식</strong>:</p><ul><li>JSON 또는 XML과 같은 표준 데이터 형식을 사용하여 요청과 응답을 구성한다.</li><li>API 요청에 필요한 파라미터와 응답으로 반환되는 데이터 구조를 명확히 정의한다.</li></ul></li><li><p><strong>상태 코드</strong>:</p><ul><li>각 API 요청의 성공 또는 실패를 나타내는 적절한 HTTP 상태 코드를 사용한다.</li><li>에러 발생 시, 상세한 에러 메시지를 응답에 포함하여 클라이언트가 문제를 해결할 수 있도록 돕는다.</li></ul></li><li><p><strong>보안</strong>:</p><ul><li>API에 대한 접근을 제어하기 위해 인증(Authentication) 및 권한 부여(Authorization) 메커니즘을 구현한다.</li><li>OAuth 2.0, JWT(JSON Web Token) 등의 표준 인증 방식을 활용한다.</li></ul></li><li><p><strong>버전 관리</strong>:</p><ul><li>API의 변경 사항을 관리하기 위해 버전 관리 전략을 수립한다.</li><li>URL 기반, 헤더 기반, 쿼리 파라미터 기반 등 다양한 버전 관리 방식을 고려한다.</li></ul></li><li><p><strong>에러 핸들링</strong>:</p><ul><li>예외적인 상황에 대한 처리를 구현하고, 사용자에게 유용한 피드백을 제공한다.</li><li>RFC 7807 또는 RFC 9457과 같은 표준을 준수하여 일관된 에러 응답 형식을 제공한다.</li></ul></li></ol><h3 id=crud-api-설계-시-문제점-및-대안>CRUD API 설계 시 문제점 및 대안<a hidden class=anchor aria-hidden=true href=#crud-api-설계-시-문제점-및-대안>#</a></h3><ol><li><p><strong>불필요한 Create/Update/Delete 구분</strong>:</p><ul><li>많은 클라이언트가 &ldquo;존재하지 않으면 생성, 존재하면 업데이트, 값이 없으면 삭제"와 같은 &ldquo;Set&rdquo; 연산을 필요로 한다.</li><li>대안: Get-and-Set 패턴을 사용하여 하나의 연산으로 모든 경우를 처리한다.</li></ul></li><li><p><strong>부분 업데이트의 어려움</strong>:</p><ul><li>CRUD는 리소스의 전체를 읽고 써야 하므로, 부분적인 업데이트가 어렵고 비효율적이다.</li><li>대안: Get-and-Patch 패턴을 사용하여 리소스의 특정 필드만 업데이트할 수 있도록 한다.</li></ul></li><li><p><strong>동시성 문제</strong>:</p><ul><li>여러 클라이언트가 동시에 리소스를 수정할 때, 데이터 일관성 문제가 발생할 수 있다.</li><li>대안: Timestamp-Checked 패턴을 사용하여 낙관적 동시성 제어를 구현한다.</li></ul></li><li><p><strong>검색 및 보안 변경 누락</strong>:</p><ul><li>CRUD API 설계 시 검색 및 보안 관련 기능이 누락되는 경우가 많다.</li><li>대안: API 설계 초기 단계에서 검색 및 보안 요구사항을 고려한다.</li></ul></li></ol><h3 id=추가적인-고려사항>추가적인 고려사항<a hidden class=anchor aria-hidden=true href=#추가적인-고려사항>#</a></h3><ul><li><strong>HATEOAS (Hypermedia as the Engine of Application State)</strong>: API 응답에 하이퍼링크를 포함하여 클라이언트가 API를 동적으로 탐색할 수 있도록 한다.</li><li><strong>API 문서화</strong>: Swagger/OpenAPI와 같은 도구를 사용하여 API 문서를 자동 생성하고, API 사용법을 명확히 설명한다.</li><li><strong>성능 최적화</strong>: 캐싱, 페이징, 압축 등을 통해 API 응답 시간을 최소화한다.</li></ul><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Get-and-Patch</h2></header><div class=entry-content><p>Get-and-Patch “Get-and-Patch"는 리소스의 부분적 업데이트를 효율적으로 처리하기 위한 REST API 디자인 패턴으로, 기존 CRUD(Create, Read, Update, Delete) 방식의 한계를 보완한다.
이 패턴은 GET과 PATCH 메서드 조합을 통해 리소스의 전체 상태를 검색하지 않고도 특정 필드만 업데이트할 수 있도록 설계되었다.
핵심 개념 두 단계 프로세스 Get: 리소스의 현재 상태 조회 (필요한 필드 확인) Patch: 변경된 필드만 서버에 전송하여 부분 업데이트 HTTP 메서드 활용 단계 HTTP 메서드 설명 Get GET 리소스의 전체/일부 상태 조회 Patch PATCH 식별된 필드만 부분적으로 업데이트 CRUD vs. Get-and-Patch 구분 CRUD (PUT) Get-and-Patch (PATCH) 업데이트 범위 전체 리소스 교체 특정 필드만 수정 네트워크 효율성 모든 필드 전송 필요 변경된 필드만 전송 멱등성 보장됨 조건부 보장 (구현 방식에 따라 다름) 동시성 제어 전체 리소스 버전 관리 필드 단위 낙관적 잠금 가능 사용 사례 단순 리소스 교체 대규모 객체의 일부 수정 작동 원리 Get 단계 클라이언트가 리소스의 현재 상태를 조회한다.
...</p></div><footer class=entry-footer><span title='2025-02-26 11:58:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Get-and-Patch" href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/get-and-patch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Get-and-Set</h2></header><div class=entry-content><p>Get-and-Set “Get-and-Set"은 전통적인 CRUD(Create, Read, Update, Delete) 방식을 개선한 REST API 디자인 패턴으로, 리소스의 존재 여부와 관계없이 단순화된 작업 흐름을 제공한다.
기본 개념 두 가지 핵심 연산 Get: 리소스의 현재 상태 조회 (CRUD의 Read와 동일) Set: Create/Update: 리소스 존재 여부와 무관하게 값을 설정 (Last-Write-Wins 정책) Delete: null 값을 전달하여 리소스 삭제 동작 원리 1 2 3 4 [클라이언트] [서버] Get 요청 → 리소스 상태 확인 Set 요청 → 값 설정/삭제 ← 최종 상태 반환 (옵션: 이전 값 포함) CRUD와의 차이점 기능 CRUD API Get-and-Set API 생성/수정 POST/PUT/PATCH 분리 단일 Set 연산으로 통합 삭제 DELETE 메서드 사용 Set(null)으로 처리 동시성 제어 복잡한 버전 관리 필요 Last-Write-Wins 기본 적용 에러 처리 상태 코드 404/409 등 다양 단순화된 200/400/500 사용 사례 복잡한 비즈니스 로직 단순 리소스 관리 시스템 작동 원리 상세 Set 연산의 3가지 시나리오 리소스 없음 + 값 전달: 새 리소스 생성 (201 Created) 리소스 존재 + 값 전달: 기존 리소스 덮어쓰기 (200 OK) 리소스 존재 + null 전달: 리소스 삭제 (204 No Content) Last-Write-Wins 동시성 제어 타임스탬프 기반: 최종 쓰기 요청이 우선 적용
...</p></div><footer class=entry-footer><span title='2025-02-26 11:58:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Get-and-Set" href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/get-and-set/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Timestamp-Checked</h2></header><div class=entry-content><p>Timestamp-Checked Timestamp-Checked 방식은 동시성 제어를 위한 중요한 기법 중 하나로, 주로 낙관적 동시성 제어(Optimistic Concurrency Control)의 맥락에서 사용된다.
기본 원리 타임스탬프 할당: 각 트랜잭션에 고유한 타임스탬프를 부여한다. 이는 주로 트랜잭션이 시작될 때 시스템 시간이나 논리적 카운터를 사용하여 생성된다. 읽기-검증-쓰기 단계: 트랜잭션은 다음 세 단계로 실행된다. 읽기 단계: 데이터를 읽고 로컬에서 작업을 수행한다. 검증 단계: 다른 트랜잭션과의 충돌을 검사한다. 쓰기 단계: 충돌이 없다면 변경사항을 데이터베이스에 반영한다. 충돌 감지: 트랜잭션이 커밋하려 할 때, 자신이 읽은 데이터가 다른 트랜잭션에 의해 변경되었는지 확인한다. 작동 방식 각 데이터 항목에는 두 가지 타임스탬프가 유지된다: 읽기 타임스탬프(R-timestamp): 해당 데이터를 성공적으로 읽은 트랜잭션 중 가장 큰 타임스탬프 쓰기 타임스탬프(W-timestamp): 해당 데이터를 성공적으로 수정한 트랜잭션 중 가장 큰 타임스탬프 트랜잭션이 데이터를 읽거나 쓰려고 할 때, 다음과 같은 규칙이 적용된다: 읽기 연산: 트랜잭션의 타임스탬프가 데이터의 쓰기 타임스탬프보다 작으면 연산이 거부되고 트랜잭션은 롤백된다. 쓰기 연산: 트랜잭션의 타임스탬프가 데이터의 읽기 또는 쓰기 타임스탬프보다 작으면 연산이 거부되고 트랜잭션은 롤백된다. 장점 교착 상태(Deadlock) 방지: 락을 사용하지 않기 때문에 교착 상태가 발생하지 않는다. 대기 시간 감소: 트랜잭션이 다른 트랜잭션을 기다리지 않고 바로 실행된다. 높은 동시성: 여러 트랜잭션이 동시에 실행될 수 있어 시스템의 처리량이 향상된다. 단점 롤백 가능성 증가: 충돌이 감지되면 트랜잭션이 롤백되어야 하므로, 시스템 부하가 높을 때 롤백 빈도가 증가할 수 있다. 연쇄 롤백: 하나의 트랜잭션 롤백이 다른 트랜잭션의 롤백을 유발할 수 있다. 오버헤드: 각 데이터 항목에 대해 타임스탬프를 유지하고 관리해야 하므로 추가적인 저장 공간과 처리 시간이 필요하다. Timestamp-Checked 방식은 특히 읽기 작업이 많고 쓰기 충돌이 적은 환경에서 효과적이다. 그러나 높은 동시성 환경에서는 롤백으로 인한 성능 저하를 주의해야 한다. 따라서 시스템의 특성과 요구사항을 고려하여 적절한 동시성 제어 방식을 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2025-02-26 11:58:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Timestamp-Checked" href=https://buenhyden.github.io/posts/system-design/api-design-and-architecture/api-styles/resource-oriented/rest/handling-crud-operations/timestamp-checked/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>