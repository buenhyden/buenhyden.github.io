<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Design | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Computer-Engineering,System-Design"><meta name=description content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System Design"><meta property="og:description" content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System Design"><meta name=twitter:description content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>System Design</h1><div class=post-description>소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정</div></header><div class=post-content><h2 id=system-design>System Design<a hidden class=anchor aria-hidden=true href=#system-design>#</a></h2><p>소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정<br>이는 소프트웨어 개발의 초기 단계에서 이루어지며, 개발자들이 구현할 소프트웨어의 아키텍처, 컴포넌트, 인터페이스, 데이터 모델 및 기타 시스템 구성 요소를 결정하는 데 도움을 준다.</p><h3 id=중요성>중요성<a hidden class=anchor aria-hidden=true href=#중요성>#</a></h3><ol><li><strong>복잡성 관리</strong>: 시스템 디자인은 복잡한 소프트웨어 시스템을 관리 가능한 단위로 분해하고 조직화하는 데 도움을 준다.</li><li><strong>유지보수성 향상</strong>: 잘 설계된 시스템은 유지보수가 쉽고 변경 사항을 쉽게 적용할 수 있다.</li><li><strong>확장성 제공</strong>: 좋은 디자인은 시스템이 미래의 요구사항에 맞춰 확장될 수 있도록 한다.</li><li><strong>품질 보장</strong>: 시스템 디자인은 소프트웨어의 품질 속성(성능, 보안성, 확장성 등)을 고려하여 설계된다.</li><li><strong>의사소통 촉진</strong>: 시스템 디자인은 개발 팀 간의 의사소통을 돕고, 시스템에 대한 공통된 이해를 제공한다.</li></ol><h3 id=소프트웨어-시스템-디자인-원칙>소프트웨어 시스템 디자인 원칙<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인-원칙>#</a></h3><ol><li><strong>단일 책임 원칙 (SRP)</strong>: 각 모듈이나 클래스는 하나의 책임만을 가져야 한다.</li><li><strong>개방-폐쇄 원칙 (OCP)</strong>: 소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다.</li><li><strong>리스코프 치환 원칙 (LSP)</strong>: 하위 타입은 상위 타입으로 대체 가능해야 한다.</li><li><strong>인터페이스 분리 원칙 (ISP)</strong>: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다.</li><li><strong>의존관계 역전 원칙 (DIP)</strong>: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.</li></ol><h3 id=소프트웨어-시스템-디자인의-주요-구성-요소>소프트웨어 시스템 디자인의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인의-주요-구성-요소>#</a></h3><h4 id=1-아키텍처-설계-architectural-design>1. 아키텍처 설계 (Architectural Design)<a hidden class=anchor aria-hidden=true href=#1-아키텍처-설계-architectural-design>#</a></h4><p>아키텍처 설계는 소프트웨어의 주요 구조적 요소와 이들 간의 관계를 정의한다.<br>이는 시스템의 전체적인 구조와 흐름을 묘사하며, 종종 다이어그램을 사용하여 표현된다.<br>아키텍처 설계는 시스템의 고수준 구조를 결정하고, 주요 컴포넌트들 간의 상호작용 방식을 정의한다.</p><h4 id=2-데이터클래스-설계-dataclass-design>2. 데이터/클래스 설계 (Data/Class Design)<a hidden class=anchor aria-hidden=true href=#2-데이터클래스-설계-dataclass-design>#</a></h4><p>데이터/클래스 설계는 시스템에서 사용될 데이터 구조와 클래스를 정의한다.<br>이 단계에서는 분석 클래스를 구현 클래스로 변환하고, 필요한 데이터 구조를 설계한다.</p><h4 id=3-인터페이스-설계-interface-design>3. 인터페이스 설계 (Interface Design)<a hidden class=anchor aria-hidden=true href=#3-인터페이스-설계-interface-design>#</a></h4><p>인터페이스 설계는 시스템 간의 소통을 돕는 부분으로, 두 시스템에서 사용하는 데이터 구조의 형식을 맞추거나, 두 시스템의 액션 사이의 공통점을 연결 짓는 방법을 디자인한다.</p><h4 id=4-컴포넌트-수준-설계-component-level-design>4. 컴포넌트 수준 설계 (Component-Level Design)<a hidden class=anchor aria-hidden=true href=#4-컴포넌트-수준-설계-component-level-design>#</a></h4><p>컴포넌트 수준 설계는 아키텍처의 구조적 요소를 소프트웨어 컴포넌트의 절차적인 설명으로 변환한다.<br>이 단계에서는 각 컴포넌트의 내부 구조와 동작을 자세히 정의한다.</p><h3 id=소프트웨어-시스템-디자인의-주요-단계>소프트웨어 시스템 디자인의 주요 단계<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인의-주요-단계>#</a></h3><ol><li>요구사항 분석<br>이 단계에서는 개발할 소프트웨어의 기능, 제약조건, 목표 등을 명확히 정의한다.<br>사용자와 이해관계자의 요구사항을 수집하고 분석하여 소프트웨어가 해결해야 할 문제와 제공해야 할 기능을 파악한다.</li><li>시스템 아키텍처 설계<br>전체 시스템의 구조와 주요 컴포넌트를 정의한다.<br>이 단계에서는 시스템의 고수준 구조와 컴포넌트 간의 상호작용 방식을 결정한다.</li><li>상세 설계<br>아키텍처 설계를 바탕으로 각 컴포넌트의 세부 사항을 설계한다.<br>이는 다음과 같은 하위 단계를 포함한다:<ul><li>데이터/클래스 설계: 시스템에서 사용될 데이터 구조와 클래스를 정의한다.</li><li>인터페이스 설계: 사용자 인터페이스와 시스템 간 인터페이스를 설계한다.</li><li>컴포넌트 수준 설계: 각 모듈의 내부 구조와 동작을 자세히 정의한다.</li></ul></li><li>보안 및 성능 고려<br>시스템의 보안 요구사항을 분석하고 성능 목표를 설정한다.<br>잠재적인 보안 위협을 식별하고 이를 완화하기 위한 설계를 수행한다.</li><li>프로토타입 개발<br>설계의 실현 가능성을 검증하고 사용자 피드백을 얻기 위해 프로토타입을 개발할 수 있다.</li><li>설계 검토 및 승인<br>설계 문서를 작성하고 이해관계자들과 함께 검토한다.<br>필요한 경우 수정을 거쳐 최종 승인을 받는다.</li></ol><h3 id=고려해야-할-주요-요소>고려해야 할 주요 요소<a hidden class=anchor aria-hidden=true href=#고려해야-할-주요-요소>#</a></h3><h4 id=기능적-요구사항과-비기능적-요구사항>기능적 요구사항과 비기능적 요구사항<a hidden class=anchor aria-hidden=true href=#기능적-요구사항과-비기능적-요구사항>#</a></h4><p>아키텍처 설계 시 기능적 요구사항과 비기능적 요구사항을 모두 고려해야 한다.</p><ul><li>기능적 요구사항은 시스템이 수행해야 할 기능과 기능을 정의한다.</li><li>비기능적 요구사항은 성능, 확장성, 보안성, 유지보수성 등의 품질 속성을 포함한다.</li></ul><p>두 가지 요구사항을 균형있게 고려하여 비즈니스 목표에 부합하는 아키텍처를 설계해야 한다.</p><h4 id=확장성과-유연성>확장성과 유연성<a hidden class=anchor aria-hidden=true href=#확장성과-유연성>#</a></h4><p>시스템의 확장성과 유연성을 고려해야 한다.<br>사용자 수나 데이터 양이 증가하더라도 시스템이 이를 수용할 수 있도록 설계해야 한다.<br>클라우드 서비스나 마이크로서비스 아키텍처 등의 기술을 활용하여 확장성을 높일 수 있다.</p><h4 id=모듈화와-재사용성>모듈화와 재사용성<a hidden class=anchor aria-hidden=true href=#모듈화와-재사용성>#</a></h4><p>시스템을 모듈화하여 설계하는 것이 중요하다.<br>모듈화를 통해 시스템을 여러 개의 독립적인 컴포넌트로 나누어 설계함으로써 복잡성을 관리하고 유지보수성을 높일 수 있다.<br>또한 재사용 가능한 컴포넌트를 활용하여 개발 시간과 비용을 절감할 수 있다.</p><h4 id=성능과-보안>성능과 보안<a hidden class=anchor aria-hidden=true href=#성능과-보안>#</a></h4><p>시스템의 성능과 보안을 최적화해야 한다.<br>정기적인 성능 테스트와 보안 테스트를 수행하여 시스템의 성능과 보안을 지속적으로 개선해야 한다.<br>특히 보안의 경우 제로 트러스트 접근 방식을 채택하여 시스템의 각 부분에 대한 인증과 권한 부여를 요구하는 것이 좋다.</p><h4 id=이해관계자의-요구사항>이해관계자의 요구사항<a hidden class=anchor aria-hidden=true href=#이해관계자의-요구사항>#</a></h4><p>모든 이해관계자의 요구사항을 고려해야 한다.<br>아키텍처는 이해관계자 간의 의사소통 도구로 활용될 수 있어야 하며, 개발 비용, 기간, 조직의 역량 등 구현에 대한 제약 사항도 정의해야 한다.</p><h4 id=변경-용이성>변경 용이성<a hidden class=anchor aria-hidden=true href=#변경-용이성>#</a></h4><p>시스템은 시간이 지남에 따라 변경될 수 있으므로, 아키텍처는 유연하게 설계되어야 한다.<br>변경 용이성을 고려하여 설계함으로써 향후 요구사항 변경이나 기술 변화에 쉽게 대응할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>네트워크 기능 가상화(Network Functions Virtualization, NFV)</h2></header><div class=entry-content><p>네트워크 기능 가상화(Network Functions Virtualization, NFV) NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.
이를 통해 범용 서버에서 가상 네트워크 기능(VNF)을 실행할 수 있게 된다.
주요 구성요소 가상화된 네트워크 기능(VNF): 소프트웨어로 구현된 네트워크 기능 NFV 인프라(NFVI): VNF를 실행하기 위한 하드웨어 및 소프트웨어 환경 NFV 관리 및 오케스트레이션(MANO): VNF와 NFVI를 관리하고 조율하는 프레임워크 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class NFVArchitecture: def __init__(self): # NFVI (NFV Infrastructure) self.compute_resources = VirtualCompute() self.network_resources = VirtualNetwork() self.storage_resources = VirtualStorage() # VNF (Virtual Network Functions) self.network_functions = { "firewall": VirtualFirewall(), "load_balancer": VirtualLoadBalancer(), "router": VirtualRouter() } # MANO (Management and Orchestration) self.orchestrator = NFVOrchestrator() self.vnf_manager = VNFManager() self.infrastructure_manager = InfrastructureManager() class VirtualNetworkFunction: def __init__(self, function_type): self.type = function_type self.status = "initialized" self.resources = {} def deploy(self, resources): """가상 네트워크 기능 배포""" self.resources = resources self.status = "deployed" def scale(self, factor): """자원 스케일링""" self.resources = { k: v * factor for k, v in self.resources.items() } 장점 하드웨어 비용 절감 유연성과 확장성 향상 신규 서비스 출시 시간 단축 운영 효율성 증대 자동화를 통한 관리 간소화 구현 과제와 해결 방안 성능 최적화
가상화로 인한 성능 저하를 최소화하기 위한 전략들:
...</p></div><footer class=entry-footer><span title='2024-12-23 02:06:00 +0000 UTC'>December 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;445 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 기능 가상화(Network Functions Virtualization, NFV)" href=https://buenhyden.github.io/posts/system-design/network-functions-virtualization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</h2></header><div class=entry-content><p>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN) 네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.
목적 네트워크 리소스 최적화 변화하는 비즈니스 요구사항에 신속한 대응 네트워크 관리 및 구성의 간소화 특징 제어 평면 (Control Plane) 과 데이터 평면 (Data Plane) 의 분리: 네트워크 장비의 제어 기능 (라우팅 결정 등) 을 별도의 소프트웨어 컨트롤러로 분리. 중앙집중식 관리: 전체 네트워크를 단일 지점에서 관리할 수 있어 효율성이 향상. 프로그래밍 가능성: API 를 통해 네트워크 동작을 프로그래밍할 수 있어 유연성이 증가 개방형 표준: 표준화된 프로토콜과 인터페이스를 사용하여 다양한 벤더의 장비를 통합 관리할 수 있음. 계층 구조 애플리케이션 계층 (Application Layer) 네트워크 서비스, 비즈니스 애플리케이션 API 를 통한 네트워크 제어 ↕ Northbound API 제어 계층 (Control Layer) SDN 컨트롤러 네트워크 정책 및 제어 로직 ↕ Southbound API (OpenFlow 등) 인프라 계층 (Infrastructure Layer) 스위치, 라우터 등 네트워크 장비 패킷 전송 및 처리 장점 유연성과 민첩성: 네트워크 구성을 신속하게 변경할 수 있다. 비용 절감: 하드웨어 의존도를 줄여 CAPEX 와 OPEX 를 절감할 수 있다. 중앙집중식 관리: 네트워크 전체를 단일 지점에서 관리할 수 있다. 보안 강화: 중앙에서 일관된 보안 정책을 적용할 수 있음. 단점 단일 장애 지점: 중앙 컨트롤러에 문제가 생기면 전체 네트워크에 영향을 줌. 성능 저하 가능성: 네트워크 규모가 커지면 컨트롤러의 부하가 증가할 수 있음. 보안 취약점: 중앙 컨트롤러가 공격 대상이 될 수 있음. 기업의 지출을 구분하는 두 가지 주요 카테고리
...</p></div><footer class=entry-footer><span title='2024-12-23 02:00:00 +0000 UTC'>December 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;240 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)" href=https://buenhyden.github.io/posts/system-design/software-defined-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Infrastructure</h2></header><div class=entry-content><p>Infrastructure Infrastructure(인프라스트럭처)는 조직의 IT 환경을 지원하고 운영하는 데 필요한 기본적인 구성 요소들의 집합이다.
이는 하드웨어, 소프트웨어, 네트워크 리소스 및 서비스를 포함한다.
Infrastructure의 주요 구성 요소 하드웨어
서버: 네트워크 저장소 및 애플리케이션 처리를 제공 스토리지 장치: 하드 드라이브, SSD 등 네트워킹 장비: 라우터, 스위치, 케이블 등 데이터 센터: 중요한 IT 장비와 지원 인프라를 수용하는 시설 소프트웨어
운영 체제: 하드웨어 운영 및 애플리케이션 실행의 기반 데이터베이스: 대량의 데이터를 조직, 저장 및 접근 용이하게 함 미들웨어: 소프트웨어 애플리케이션 간 통신 및 데이터 교환을 위한 연결 계층 네트워크 인프라
...</p></div><footer class=entry-footer><span title='2024-09-28 01:29:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;204 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Infrastructure" href=https://buenhyden.github.io/posts/system-design/infrastructure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 시스템 (Distributed System)</h2></header><div class=entry-content><p>분산 시스템 (Distributed System) 분산 시스템은 네트워크로 연결된 여러 독립적인 컴퓨터들이 하나의 통합된 시스템처럼 작동하는 컴퓨팅 환경을 말한다.
마치 여러 사람이 각자 맡은 일을 하면서도 하나의 팀으로 협력하는 것처럼, 분산 시스템의 각 컴퓨터들도 서로 메시지를 주고받으며 협력하여 작업을 수행한다.
분산 시스템의 주요 특징 동시성(Concurrency):
여러 컴포넌트가 동시에 작동하면서 자원을 공유하고 작업을 처리한다.
예를 들어, 온라인 쇼핑몰에서 수많은 사용자가 동시에 주문을 처리할 수 있다.
확장성(Scalability):
시스템의 크기와 성능을 필요에 따라 쉽게 확장할 수 있다.
수평적 확장(더 많은 컴퓨터 추가)과 수직적 확장(더 강력한 컴퓨터로 교체) 모두 가능하다.
...</p></div><footer class=entry-footer><span title='2024-11-09 02:51:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;575 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 시스템 (Distributed System)" href=https://buenhyden.github.io/posts/system-design/distributed-system/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>