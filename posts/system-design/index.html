<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Design | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Computer-Engineering,System-Design"><meta name=description content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System Design"><meta property="og:description" content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System Design"><meta name=twitter:description content="소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>System Design</h1><div class=post-description>소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정</div></header><div class=post-content><h2 id=system-design>System Design<a hidden class=anchor aria-hidden=true href=#system-design>#</a></h2><p>소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정<br>이는 소프트웨어 개발의 초기 단계에서 이루어지며, 개발자들이 구현할 소프트웨어의 아키텍처, 컴포넌트, 인터페이스, 데이터 모델 및 기타 시스템 구성 요소를 결정하는 데 도움을 준다.</p><h3 id=중요성>중요성<a hidden class=anchor aria-hidden=true href=#중요성>#</a></h3><ol><li><strong>복잡성 관리</strong>: 시스템 디자인은 복잡한 소프트웨어 시스템을 관리 가능한 단위로 분해하고 조직화하는 데 도움을 준다.</li><li><strong>유지보수성 향상</strong>: 잘 설계된 시스템은 유지보수가 쉽고 변경 사항을 쉽게 적용할 수 있다.</li><li><strong>확장성 제공</strong>: 좋은 디자인은 시스템이 미래의 요구사항에 맞춰 확장될 수 있도록 한다.</li><li><strong>품질 보장</strong>: 시스템 디자인은 소프트웨어의 품질 속성(성능, 보안성, 확장성 등)을 고려하여 설계된다.</li><li><strong>의사소통 촉진</strong>: 시스템 디자인은 개발 팀 간의 의사소통을 돕고, 시스템에 대한 공통된 이해를 제공한다.</li></ol><h3 id=소프트웨어-시스템-디자인-원칙>소프트웨어 시스템 디자인 원칙<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인-원칙>#</a></h3><ol><li><strong>단일 책임 원칙 (SRP)</strong>: 각 모듈이나 클래스는 하나의 책임만을 가져야 한다.</li><li><strong>개방-폐쇄 원칙 (OCP)</strong>: 소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다.</li><li><strong>리스코프 치환 원칙 (LSP)</strong>: 하위 타입은 상위 타입으로 대체 가능해야 한다.</li><li><strong>인터페이스 분리 원칙 (ISP)</strong>: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다.</li><li><strong>의존관계 역전 원칙 (DIP)</strong>: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.</li></ol><h3 id=소프트웨어-시스템-디자인의-주요-구성-요소>소프트웨어 시스템 디자인의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인의-주요-구성-요소>#</a></h3><h4 id=1-아키텍처-설계-architectural-design>1. 아키텍처 설계 (Architectural Design)<a hidden class=anchor aria-hidden=true href=#1-아키텍처-설계-architectural-design>#</a></h4><p>아키텍처 설계는 소프트웨어의 주요 구조적 요소와 이들 간의 관계를 정의한다.<br>이는 시스템의 전체적인 구조와 흐름을 묘사하며, 종종 다이어그램을 사용하여 표현된다.<br>아키텍처 설계는 시스템의 고수준 구조를 결정하고, 주요 컴포넌트들 간의 상호작용 방식을 정의한다.</p><h4 id=2-데이터클래스-설계-dataclass-design>2. 데이터/클래스 설계 (Data/Class Design)<a hidden class=anchor aria-hidden=true href=#2-데이터클래스-설계-dataclass-design>#</a></h4><p>데이터/클래스 설계는 시스템에서 사용될 데이터 구조와 클래스를 정의한다.<br>이 단계에서는 분석 클래스를 구현 클래스로 변환하고, 필요한 데이터 구조를 설계한다.</p><h4 id=3-인터페이스-설계-interface-design>3. 인터페이스 설계 (Interface Design)<a hidden class=anchor aria-hidden=true href=#3-인터페이스-설계-interface-design>#</a></h4><p>인터페이스 설계는 시스템 간의 소통을 돕는 부분으로, 두 시스템에서 사용하는 데이터 구조의 형식을 맞추거나, 두 시스템의 액션 사이의 공통점을 연결 짓는 방법을 디자인한다.</p><h4 id=4-컴포넌트-수준-설계-component-level-design>4. 컴포넌트 수준 설계 (Component-Level Design)<a hidden class=anchor aria-hidden=true href=#4-컴포넌트-수준-설계-component-level-design>#</a></h4><p>컴포넌트 수준 설계는 아키텍처의 구조적 요소를 소프트웨어 컴포넌트의 절차적인 설명으로 변환한다.<br>이 단계에서는 각 컴포넌트의 내부 구조와 동작을 자세히 정의한다.</p><h3 id=소프트웨어-시스템-디자인의-주요-단계>소프트웨어 시스템 디자인의 주요 단계<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템-디자인의-주요-단계>#</a></h3><ol><li>요구사항 분석<br>이 단계에서는 개발할 소프트웨어의 기능, 제약조건, 목표 등을 명확히 정의한다.<br>사용자와 이해관계자의 요구사항을 수집하고 분석하여 소프트웨어가 해결해야 할 문제와 제공해야 할 기능을 파악한다.</li><li>시스템 아키텍처 설계<br>전체 시스템의 구조와 주요 컴포넌트를 정의한다.<br>이 단계에서는 시스템의 고수준 구조와 컴포넌트 간의 상호작용 방식을 결정한다.</li><li>상세 설계<br>아키텍처 설계를 바탕으로 각 컴포넌트의 세부 사항을 설계한다.<br>이는 다음과 같은 하위 단계를 포함한다:<ul><li>데이터/클래스 설계: 시스템에서 사용될 데이터 구조와 클래스를 정의한다.</li><li>인터페이스 설계: 사용자 인터페이스와 시스템 간 인터페이스를 설계한다.</li><li>컴포넌트 수준 설계: 각 모듈의 내부 구조와 동작을 자세히 정의한다.</li></ul></li><li>보안 및 성능 고려<br>시스템의 보안 요구사항을 분석하고 성능 목표를 설정한다.<br>잠재적인 보안 위협을 식별하고 이를 완화하기 위한 설계를 수행한다.</li><li>프로토타입 개발<br>설계의 실현 가능성을 검증하고 사용자 피드백을 얻기 위해 프로토타입을 개발할 수 있다.</li><li>설계 검토 및 승인<br>설계 문서를 작성하고 이해관계자들과 함께 검토한다.<br>필요한 경우 수정을 거쳐 최종 승인을 받는다.</li></ol><h3 id=고려해야-할-주요-요소>고려해야 할 주요 요소<a hidden class=anchor aria-hidden=true href=#고려해야-할-주요-요소>#</a></h3><h4 id=기능적-요구사항과-비기능적-요구사항>기능적 요구사항과 비기능적 요구사항<a hidden class=anchor aria-hidden=true href=#기능적-요구사항과-비기능적-요구사항>#</a></h4><p>아키텍처 설계 시 기능적 요구사항과 비기능적 요구사항을 모두 고려해야 한다.</p><ul><li>기능적 요구사항은 시스템이 수행해야 할 기능과 기능을 정의한다.</li><li>비기능적 요구사항은 성능, 확장성, 보안성, 유지보수성 등의 품질 속성을 포함한다.</li></ul><p>두 가지 요구사항을 균형있게 고려하여 비즈니스 목표에 부합하는 아키텍처를 설계해야 한다.</p><h4 id=확장성과-유연성>확장성과 유연성<a hidden class=anchor aria-hidden=true href=#확장성과-유연성>#</a></h4><p>시스템의 확장성과 유연성을 고려해야 한다.<br>사용자 수나 데이터 양이 증가하더라도 시스템이 이를 수용할 수 있도록 설계해야 한다.<br>클라우드 서비스나 마이크로서비스 아키텍처 등의 기술을 활용하여 확장성을 높일 수 있다.</p><h4 id=모듈화와-재사용성>모듈화와 재사용성<a hidden class=anchor aria-hidden=true href=#모듈화와-재사용성>#</a></h4><p>시스템을 모듈화하여 설계하는 것이 중요하다.<br>모듈화를 통해 시스템을 여러 개의 독립적인 컴포넌트로 나누어 설계함으로써 복잡성을 관리하고 유지보수성을 높일 수 있다.<br>또한 재사용 가능한 컴포넌트를 활용하여 개발 시간과 비용을 절감할 수 있다.</p><h4 id=성능과-보안>성능과 보안<a hidden class=anchor aria-hidden=true href=#성능과-보안>#</a></h4><p>시스템의 성능과 보안을 최적화해야 한다.<br>정기적인 성능 테스트와 보안 테스트를 수행하여 시스템의 성능과 보안을 지속적으로 개선해야 한다.<br>특히 보안의 경우 제로 트러스트 접근 방식을 채택하여 시스템의 각 부분에 대한 인증과 권한 부여를 요구하는 것이 좋다.</p><h4 id=이해관계자의-요구사항>이해관계자의 요구사항<a hidden class=anchor aria-hidden=true href=#이해관계자의-요구사항>#</a></h4><p>모든 이해관계자의 요구사항을 고려해야 한다.<br>아키텍처는 이해관계자 간의 의사소통 도구로 활용될 수 있어야 하며, 개발 비용, 기간, 조직의 역량 등 구현에 대한 제약 사항도 정의해야 한다.</p><h4 id=변경-용이성>변경 용이성<a hidden class=anchor aria-hidden=true href=#변경-용이성>#</a></h4><p>시스템은 시간이 지남에 따라 변경될 수 있으므로, 아키텍처는 유연하게 설계되어야 한다.<br>변경 용이성을 고려하여 설계함으로써 향후 요구사항 변경이나 기술 변화에 쉽게 대응할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-10-19 02:43:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/system-design/load-balancers/loadbalancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>Message Queue 메시지 큐는 프로그램, 네트워크, 서비스 간에 데이터를 주고받을 때 사용하는 비동기 통신 방법.
Message Queue는 메시지를 임시로 저장하고 전달하는 중개자 역할을 한다.
Producer가 메시지를 큐에 전송하면, Consumer가 이를 처리할 준비가 될 때까지 메시지를 보관한다.
이는 시스템 컴포넌트 간의 결합도를 낮추고 확장성을 높이는 데 도움이 된다.
주요 특징 비동기 통신: Producer와 Consumer 간 직접적인 연결 없이 메시지를 교환할 수 있다. 내결함성: 메시지는 Consumer가 처리할 때까지 큐에 안전하게 저장된다. 시스템 장애 시에도 데이터 손실을 방지한다. 확장성: 트래픽 증가에 따라 Consumer를 쉽게 추가할 수 있어 시스템 확장이 용이하다. 부하 분산: 여러 Consumer가 메시지를 병렬로 처리하여 작업 부하를 분산시킬 수 있다. 순서 보장: FIFO(First-In-First-Out) 큐를 사용하여 메시지의 처리 순서를 보장할 수 있다. 메시지 큐의 장점 비동기 처리 시스템 간 느슨한 결합(Loose Coupling)을 제공합니다 생산자는 소비자의 처리 여부를 기다리지 않고 다음 작업을 진행할 수 있습니다 부하 분산 여러 소비자가 메시지를 나누어 처리할 수 있습니다 시스템의 부하를 효율적으로 분산시킬 수 있습니다 안정성 메시지가 유실되지 않고 안전하게 전달됩니다 시스템 장애 시에도 메시지가 보존됩니다 메시지 큐의 주요 구성요소 Producer (생산자)
...</p></div><footer class=entry-footer><span title='2024-10-21 06:56:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;467 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/system-design/asynchronism/message-queues/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DNS(Domain Name System)</h2></header><div class=entry-content><p>DNS(Domain Name System) 인터넷에서 도메인 이름을 IP 주소로 변환하는 분산형 데이터베이스 시스템이다.
https://www.cloudflare.com/ko-kr/learning/dns/glossary/what-is-my-ip-address/
인터넷 전화전화부로 비유되며 특정 컴퓨터 (또는 네트워크로 연결된 임의의 장치) 의 주소를 찾기 위해, 사람이 이해하기 쉬운 호스트 이름 (예: &lt;www.example.com>) 을 실제 네트워크 상에서 사용하는 IP 주소 (예: 192.168.1.1) 로 변환하고 해당 IP 주소로 접속하는 일련의 시스템을 DNS(Domain Name System) 이라고 한다.
DNS 는 전세계적으로 약속된 규칙을 공유한다.
웹 브라우저는 DNS 확인이 막후에서 발생하며 최초의 사용자 요청 외에 사용자 컴퓨터와의 추가적인 대화는 필요하지 않다.
...</p></div><footer class=entry-footer><span title='2024-10-17 02:03:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1041 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DNS(Domain Name System)" href=https://buenhyden.github.io/posts/system-design/domain-name-system/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>캐싱 (Caching)</h2></header><div class=entry-content><p>캐싱 (Caching) 캐싱은 자주 사용되는 데이터나 계산 결과를 빠르게 접근할 수 있는 위치에 임시로 저장하는 기술이다.
이는 데이터를 다시 계산하거나 원래 위치에서 다시 가져올 필요 없이 빠르게 접근할 수 있게 해준다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 캐싱의 기본 프로세스를 보여주는 예제 class CachingProcess: def __init__(self): self.storage = {} # 캐시 저장소 self.stats = {'hits': 0, 'misses': 0} # 캐싱 효율성 측정 def get_data(self, key): # 1. 캐시 확인 단계 if key in self.storage: self.stats['hits'] += 1 return self._handle_cache_hit(key) # 2. 캐시 미스 처리 단계 self.stats['misses'] += 1 data = self._fetch_from_source(key) # 3. 캐시 저장 단계 self._store_in_cache(key, data) return data def _handle_cache_hit(self, key): # 캐시 히트 시의 처리 로직 return self.storage[key] def _fetch_from_source(self, key): # 원본 소스에서 데이터를 가져오는 로직 return f"Data for {key}" def _store_in_cache(self, key, data): # 캐시 저장 로직 self.storage[key] = data 캐싱의 목적 성능 향상: 데이터 접근 속도를 높여 전체적인 시스템 성능을 개선한다. 서버 부하 감소: 반복적인 요청을 줄여 서버의 작업량을 감소시킨다. 네트워크 대역폭 절약: 데이터 전송량을 줄여 네트워크 리소스를 절약한다. 캐싱(Caching)의 주요 요소 캐시(Cache): 데이터를 임시 저장하는 공간 캐시 정책(Cache Policy): 데이터를 저장하고 관리하는 규칙 캐시 전략(Cache Strategy): 캐시를 효율적으로 활용하는 방법 캐시 무효화(Cache Invalidation): 원본 데이터와 캐시된 데이터의 동기화 캐시 일관성(Cache Coherence) 캐싱의 작동 원리 데이터 요청: 프로그램이 데이터를 요청한다. 캐시 확인: 시스템은 먼저 캐시에서 해당 데이터를 찾는다. 캐시 히트(Cache Hit): 데이터가 캐시에 있으면 즉시 반환한다. 캐시 미스(Cache Miss): 데이터가 캐시에 없으면 원본 소스에서 가져와 캐시에 저장한 후 반환한다. 캐싱의 적용 분야 웹 페이지 캐싱: 정적 콘텐츠를 저장하여 빠르게 제공한다. 데이터베이스 캐싱: 쿼리 결과를 저장하여 반복적인 요청에 대한 응답 시간을 단축한다. CDN(Content Delivery Network): 전 세계에 분산된 서버에 콘텐츠를 캐싱하여 빠른 로딩 속도를 제공한다. 캐싱의 장점 빠른 응답 시간: 사용자 경험을 개선한다. 서버 부하 감소: 시스템의 확장성과 안정성을 향상시킨다. 비용 절감: 데이터 전송 및 처리 비용을 줄인다. 캐싱 구현 시 고려사항 캐시 크기: 너무 작으면 효과가 적고, 너무 크면 메모리 낭비가 됩니다. 캐시 갱신 정책: 데이터 일관성을 유지하기 위해 적절한 갱신 전략이 필요합니다. 캐시 교체 알고리즘: LRU, LFU, FIFO 등 상황에 맞는 알고리즘을 선택해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-30 14:14:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;361 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 캐싱 (Caching)" href=https://buenhyden.github.io/posts/system-design/caching/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>