<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cache Strategy | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Strategy"><meta name=description content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Cache Strategy"><meta property="og:description" content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T03:30:00+00:00"><meta property="article:modified_time" content="2024-09-30T03:30:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Strategy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Cache Strategy"><meta name=twitter:description content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"},{"@type":"ListItem","position":3,"name":"캐싱 (Caching)","item":"https://buenhyden.github.io/posts/system-design/caching/"},{"@type":"ListItem","position":4,"name":"Cache Strategy","item":"https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cache Strategy","name":"Cache Strategy","description":"Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Cache-Strategy"],"articleBody":"Cache Strategy Cache Strategy(캐시 전략) 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.\n캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.\n캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.\n캐싱 전략의 필요성 캐싱은 데이터를 임시로 저장하여 반복적인 데이터 요청 시 빠르게 응답할 수 있도록 설계된 메커니즘이다. 하지만 캐싱이 제대로 설계되지 않으면 다음과 같은 문제가 발생할 수 있다:\nStale Data(오래된 데이터): 원본 데이터가 변경되었지만 캐시에 반영되지 않아 잘못된 데이터를 반환. Cache Miss: 캐시에 데이터가 없어서 데이터베이스를 반복적으로 조회하는 상황. 자원 낭비: 불필요한 데이터를 캐시에 저장하거나, 자주 사용되지 않는 데이터를 관리하는 데 리소스를 낭비. 이를 해결하기 위해 적절한 캐싱 전략이 필요하다.\n주요 캐싱 전략 읽기 중심(Read-heavy) 캐싱 전략 Cache-Aside (Lazy Loading) 동작 방식: 애플리케이션이 먼저 캐시를 조회. Cache Hit: 캐시에 데이터가 있으면 반환. Cache Miss: 캐시에 데이터가 없으면 데이터베이스에서 조회 후, 데이터를 반환하고 캐시에 저장. 특징: 가장 일반적으로 사용되는 전략. 캐시는 필요한 데이터만 저장하여 효율적. 캐시 장애 시에도 DB에서 데이터를 가져올 수 있어 탄력적. 단점: 첫 요청 시 Cache Miss로 인해 지연 발생. DB 업데이트 시 캐시를 동기화하지 않으면 오래된 데이터가 반환될 수 있음. 사용 사례: 전자상거래 사이트의 상품 정보 조회. Read-Through 동작 방식: 애플리케이션이 캐시를 조회. Cache Hit: 캐시에 데이터가 있으면 반환. Cache Miss: 캐시가 DB에서 데이터를 가져와 저장 후 반환. 특징: Cache Aside와 유사하지만, DB 조회 및 캐시 갱신 작업을 캐시 시스템이 처리. 동기화 작업이 자동화되어 간단함. 단점: 초기 요청 시 Cache Miss로 인해 지연 발생. 캐시에 의존도가 높아 장애 시 전체 시스템에 영향을 줄 수 있음. 사용 사례: 읽기 작업이 많은 대규모 시스템. Refresh-Ahead 동작 방식: TTL(Time-To-Live)이 만료되기 전에 자주 사용되는 데이터를 미리 갱신. 특징: Cache Miss를 최소화하여 성능을 향상. 자주 사용되는 데이터 예측이 중요. 단점: 잘못된 예측으로 인해 불필요한 리소스 낭비 가능. 사용 사례: 실시간 날씨 정보나 주식 가격처럼 자주 갱신되는 데이터. 쓰기 중심(Write-heavy) 캐싱 전략 Write-Around 동작 방식: 쓰기 작업 시 DB에만 데이터를 저장하고, 읽기 요청 시 Cache Miss가 발생하면 데이터를 DB에서 가져와 캐시에 저장. 특징: 쓰기 작업에서 캐시를 건드리지 않아 단순함. 자주 읽히지 않는 데이터는 캐시에 저장되지 않음으로써 리소스 절약 가능. 단점: 첫 읽기 요청 시 Cache Miss로 인한 지연 발생. 사용 사례: 로그 데이터나 이벤트 기록처럼 쓰기가 많고 읽기가 적은 경우. Write-Through 동작 방식: 쓰기 작업 시 데이터를 DB와 캐시에 동시에 저장. 특징: 항상 최신 상태의 데이터를 유지하며, 읽기 성능 향상에 유리. 단점: 쓰기 작업 속도가 느려질 수 있음(캐시와 DB 동기화 비용). 사용 사례: 사용자 프로필 정보처럼 읽기와 쓰기가 모두 중요한 경우. Write-Back (Write Behind) 동작 방식: 쓰기 작업 시 데이터를 먼저 캐시에 저장하고, 일정 시간 후 또는 특정 조건에서 DB에 반영(비동기). 특징: 쓰기 성능이 매우 빠름(캐시에만 기록). 여러 쓰기를 묶어 한 번에 DB에 반영하여 부하 감소 가능. 단점: 동기화 이전에 장애가 발생하면 데이터 유실 가능성 존재. 사용 사례: 실시간 로그 처리 또는 대량 쓰기가 필요한 환경. 시간 기반(Time-based) 전략 TTL(Time-To-Live) 각 항목에 유효 기간을 설정하여 일정 시간이 지나면 자동으로 무효화한다.\n간단하고 효과적이나, 잘못된 TTL 설정은 성능 저하를 초래할 수 있다.\n공간 기반(Space-based) 전략 LRU (Least Recently Used) 가장 오래 사용되지 않은 데이터를 제거하여 공간을 확보한다.\n자주 사용되는 데이터를 우선적으로 유지한다.\nLFU (Least Frequently Used) 가장 적게 참조된 데이터를 제거한다.\n주요 고려사항 데이터의 특성 분석:\n자주 변경되는 데이터인가? 읽기와 쓰기의 비율은 어떠한가? 시스템 요구사항 분석:\n고성능이 필요한지, 일관성이 더 중요한지 판단. 장애 대응 계획:\nCache Miss나 장애 발생 시 DB로의 부하 증가를 어떻게 처리할 것인지 계획 필요. 참고 및 출처 ","wordCount":"594","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T03:30:00Z","dateModified":"2024-09-30T03:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/>System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/caching/>캐싱 (Caching)</a></div><h1 class="post-title entry-hint-parent">Cache Strategy</h1><div class=post-description>Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.</div><div class=post-meta><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20Design/Caching/Cache%20Strategy/Cache-Strategy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cache-strategy>Cache Strategy</a><ul><li><a href=#캐싱-전략의-필요성>캐싱 전략의 필요성</a></li><li><a href=#주요-캐싱-전략>주요 캐싱 전략</a></li><li><a href=#주요-고려사항>주요 고려사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=cache-strategy>Cache Strategy<a hidden class=anchor aria-hidden=true href=#cache-strategy>#</a></h2><p><strong>Cache Strategy(캐시 전략)</strong> 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.<br>캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.</p><p>캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.</p><h3 id=캐싱-전략의-필요성>캐싱 전략의 필요성<a hidden class=anchor aria-hidden=true href=#캐싱-전략의-필요성>#</a></h3><p>캐싱은 데이터를 임시로 저장하여 반복적인 데이터 요청 시 빠르게 응답할 수 있도록 설계된 메커니즘이다. 하지만 캐싱이 제대로 설계되지 않으면 다음과 같은 문제가 발생할 수 있다:</p><ul><li><strong>Stale Data(오래된 데이터)</strong>: 원본 데이터가 변경되었지만 캐시에 반영되지 않아 잘못된 데이터를 반환.</li><li><strong>Cache Miss</strong>: 캐시에 데이터가 없어서 데이터베이스를 반복적으로 조회하는 상황.</li><li><strong>자원 낭비</strong>: 불필요한 데이터를 캐시에 저장하거나, 자주 사용되지 않는 데이터를 관리하는 데 리소스를 낭비.</li></ul><p>이를 해결하기 위해 적절한 <strong>캐싱 전략</strong>이 필요하다.</p><h3 id=주요-캐싱-전략>주요 캐싱 전략<a hidden class=anchor aria-hidden=true href=#주요-캐싱-전략>#</a></h3><h4 id=읽기-중심read-heavy-캐싱-전략>읽기 중심(Read-heavy) 캐싱 전략<a hidden class=anchor aria-hidden=true href=#읽기-중심read-heavy-캐싱-전략>#</a></h4><h5 id=cache-aside-lazy-loading>Cache-Aside (Lazy Loading)<a hidden class=anchor aria-hidden=true href=#cache-aside-lazy-loading>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>애플리케이션이 먼저 캐시를 조회.</li><li><strong>Cache Hit</strong>: 캐시에 데이터가 있으면 반환.</li><li><strong>Cache Miss</strong>: 캐시에 데이터가 없으면 데이터베이스에서 조회 후, 데이터를 반환하고 캐시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>가장 일반적으로 사용되는 전략.</li><li>캐시는 필요한 데이터만 저장하여 효율적.</li><li>캐시 장애 시에도 DB에서 데이터를 가져올 수 있어 <strong>탄력적</strong>.</li></ul></li><li><strong>단점</strong>:<ul><li>첫 요청 시 Cache Miss로 인해 지연 발생.</li><li>DB 업데이트 시 캐시를 동기화하지 않으면 오래된 데이터가 반환될 수 있음.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>전자상거래 사이트의 상품 정보 조회.</li></ul></li></ul><h5 id=read-through>Read-Through<a hidden class=anchor aria-hidden=true href=#read-through>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>애플리케이션이 캐시를 조회.</li><li><strong>Cache Hit</strong>: 캐시에 데이터가 있으면 반환.</li><li><strong>Cache Miss</strong>: 캐시가 DB에서 데이터를 가져와 저장 후 반환.</li></ul></li><li><strong>특징</strong>:<ul><li>Cache Aside와 유사하지만, DB 조회 및 캐시 갱신 작업을 캐시 시스템이 처리.</li><li>동기화 작업이 자동화되어 간단함.</li></ul></li><li><strong>단점</strong>:<ul><li>초기 요청 시 Cache Miss로 인해 지연 발생.</li><li>캐시에 의존도가 높아 장애 시 전체 시스템에 영향을 줄 수 있음.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>읽기 작업이 많은 대규모 시스템.</li></ul></li></ul><h5 id=refresh-ahead>Refresh-Ahead<a hidden class=anchor aria-hidden=true href=#refresh-ahead>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>TTL(Time-To-Live)이 만료되기 전에 자주 사용되는 데이터를 미리 갱신.</li></ul></li><li><strong>특징</strong>:<ul><li>Cache Miss를 최소화하여 성능을 향상.</li><li>자주 사용되는 데이터 예측이 중요.</li></ul></li><li><strong>단점</strong>:<ul><li>잘못된 예측으로 인해 불필요한 리소스 낭비 가능.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>실시간 날씨 정보나 주식 가격처럼 자주 갱신되는 데이터.</li></ul></li></ul><h4 id=쓰기-중심write-heavy-캐싱-전략>쓰기 중심(Write-heavy) 캐싱 전략<a hidden class=anchor aria-hidden=true href=#쓰기-중심write-heavy-캐싱-전략>#</a></h4><h5 id=write-around>Write-Around<a hidden class=anchor aria-hidden=true href=#write-around>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 DB에만 데이터를 저장하고, 읽기 요청 시 Cache Miss가 발생하면 데이터를 DB에서 가져와 캐시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>쓰기 작업에서 캐시를 건드리지 않아 단순함.</li><li>자주 읽히지 않는 데이터는 캐시에 저장되지 않음으로써 리소스 절약 가능.</li></ul></li><li><strong>단점</strong>:<ul><li>첫 읽기 요청 시 Cache Miss로 인한 지연 발생.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>로그 데이터나 이벤트 기록처럼 쓰기가 많고 읽기가 적은 경우.</li></ul></li></ul><h5 id=write-through>Write-Through<a hidden class=anchor aria-hidden=true href=#write-through>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 데이터를 DB와 캐시에 동시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>항상 최신 상태의 데이터를 유지하며, 읽기 성능 향상에 유리.</li></ul></li><li><strong>단점</strong>:<ul><li>쓰기 작업 속도가 느려질 수 있음(캐시와 DB 동기화 비용).</li></ul></li><li><strong>사용 사례</strong>:<ul><li>사용자 프로필 정보처럼 읽기와 쓰기가 모두 중요한 경우.</li></ul></li></ul><h5 id=write-back-write-behind>Write-Back (Write Behind)<a hidden class=anchor aria-hidden=true href=#write-back-write-behind>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 데이터를 먼저 캐시에 저장하고, 일정 시간 후 또는 특정 조건에서 DB에 반영(비동기).</li></ul></li><li><strong>특징</strong>:<ul><li>쓰기 성능이 매우 빠름(캐시에만 기록).</li><li>여러 쓰기를 묶어 한 번에 DB에 반영하여 부하 감소 가능.</li></ul></li><li><strong>단점</strong>:<ul><li>동기화 이전에 장애가 발생하면 데이터 유실 가능성 존재.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>실시간 로그 처리 또는 대량 쓰기가 필요한 환경.</li></ul></li></ul><h4 id=시간-기반time-based-전략>시간 기반(Time-based) 전략<a hidden class=anchor aria-hidden=true href=#시간-기반time-based-전략>#</a></h4><h5 id=ttltime-to-live>TTL(Time-To-Live)<a hidden class=anchor aria-hidden=true href=#ttltime-to-live>#</a></h5><p>각 항목에 유효 기간을 설정하여 일정 시간이 지나면 자동으로 무효화한다.<br>간단하고 효과적이나, 잘못된 TTL 설정은 성능 저하를 초래할 수 있다.</p><h4 id=공간-기반space-based-전략>공간 기반(Space-based) 전략<a hidden class=anchor aria-hidden=true href=#공간-기반space-based-전략>#</a></h4><h5 id=lru-least-recently-used>LRU (Least Recently Used)<a hidden class=anchor aria-hidden=true href=#lru-least-recently-used>#</a></h5><p>가장 오래 사용되지 않은 데이터를 제거하여 공간을 확보한다.<br>자주 사용되는 데이터를 우선적으로 유지한다.</p><h5 id=lfu-least-frequently-used>LFU (Least Frequently Used)<a hidden class=anchor aria-hidden=true href=#lfu-least-frequently-used>#</a></h5><p>가장 적게 참조된 데이터를 제거한다.</p><h3 id=주요-고려사항>주요 고려사항<a hidden class=anchor aria-hidden=true href=#주요-고려사항>#</a></h3><ol><li><p>데이터의 특성 분석:</p><ul><li>자주 변경되는 데이터인가?</li><li>읽기와 쓰기의 비율은 어떠한가?</li></ul></li><li><p>시스템 요구사항 분석:</p><ul><li>고성능이 필요한지, 일관성이 더 중요한지 판단.</li></ul></li><li><p>장애 대응 계획:</p><ul><li>Cache Miss나 장애 발생 시 DB로의 부하 증가를 어떻게 처리할 것인지 계획 필요.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-strategy/>Cache-Strategy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-design/caching/cache-invalidation/cache-invalidation/><span class=title>« Prev</span><br><span>Cache Invalidation</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-design/caching/types/caching-techniques/><span class=title>Next »</span><br><span>Caching Techniques</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>