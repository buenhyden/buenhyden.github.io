<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prefetch Policy | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Policy,Prefetch-Policy"><meta name=description content="**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Prefetch Policy"><meta property="og:description" content="**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T10:53:00+00:00"><meta property="article:modified_time" content="2024-09-30T10:53:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Policy"><meta property="article:tag" content="Prefetch-Policy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Prefetch Policy"><meta name=twitter:description content="**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"},{"@type":"ListItem","position":3,"name":"캐싱 (Caching)","item":"https://buenhyden.github.io/posts/system-design/caching/"},{"@type":"ListItem","position":4,"name":"Cache Policy","item":"https://buenhyden.github.io/posts/system-design/caching/cache-policy/"},{"@type":"ListItem","position":5,"name":"Prefetch Policy","item":"https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prefetch Policy","name":"Prefetch Policy","description":"**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Cache-Policy","Prefetch-Policy"],"articleBody":"Prefetch Policy Cache Policy의 Prefetch Policy는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.\n이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.\nPrefetching은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.\n이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.\nPrefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.\nPrefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.\n하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.\nPrefetching의 필요성 성능 향상: 메모리 접근 속도는 CPU 처리 속도에 비해 상대적으로 느리다. 따라서, 데이터를 미리 로드함으로써 CPU가 대기하는 시간을 줄일 수 있다. 데이터 지역성 활용: 프로그램의 데이터 접근 패턴은 일반적으로 지역성을 가지므로, 이전에 접근한 데이터가 다음에도 필요할 가능성이 높다. 이를 활용하여 필요한 데이터를 미리 가져올 수 있다. Prefetch Policy의 유형 Hardware Prefetching 설명: 하드웨어 수준에서 자동으로 prefetching을 수행한다. CPU나 메모리 컨트롤러가 데이터 접근 패턴을 분석하여 필요한 데이터를 미리 로드한다. 장점: 프로그래머의 개입 없이 자동으로 작동. 빠른 반응 속도. 단점: 잘못된 예측으로 인한 불필요한 메모리 사용 가능성. Software Prefetching 설명: 프로그래머가 코드 내에서 prefetch 명령어를 삽입하여 필요한 데이터를 미리 로드한다. 장점: 특정 알고리즘이나 데이터 구조에 최적화된 prefetching 가능. 더 세밀한 제어가 가능. 단점: 프로그래머의 추가 작업이 필요. 잘못된 prefetch로 인한 성능 저하 가능성. Compiler-Directed Prefetching 설명: 컴파일러가 코드 분석을 통해 자동으로 prefetch 명령어를 삽입한다. 반복문이나 특정 패턴에서 예측 가능한 데이터 접근을 감지하여 수행한다. 장점: 프로그래머의 개입 없이 성능 최적화 가능. 반복적인 데이터 접근 패턴에서 효과적. 단점: 모든 상황에서 최적화되지 않을 수 있음. Prefetch Policy의 구현 방법 Sequential Prefetching: 순차적으로 접근할 것으로 예상되는 데이터를 미리 로드한다. 예를 들어, 배열이나 리스트와 같은 구조에서 인덱스에 따라 데이터를 가져온다.\n예시: 반복문 내에서 다음 몇 개의 요소를 미리 로드하는 방식. Stride Prefetching: 일정한 간격으로 접근하는 패턴을 감지하여 그 간격에 맞춰 데이터를 미리 로드한다.\n예시: 배열의 모든 두 번째 요소를 접근할 경우, 첫 번째 요소를 가져온 후 두 번째 요소를 미리 가져오는 방식. Adaptive Prefetching: 시스템이 현재 데이터 접근 패턴을 분석하여 동적으로 prefetching 전략을 조정한다.\n장점: 다양한 패턴에 적응하여 성능 최적화 가능. 참고 및 출처 ","wordCount":"358","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T10:53:00Z","dateModified":"2024-09-30T10:53:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/>System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/caching/>캐싱 (Caching)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/>Cache Policy</a></div><h1 class="post-title entry-hint-parent">Prefetch Policy</h1><div class=post-description>**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략</div><div class=post-meta><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20Design/Caching/Cache%20Policy/prefetch-policy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#prefetch-policy>Prefetch Policy</a><ul><li><a href=#prefetching의-필요성>Prefetching의 필요성</a></li><li><a href=#prefetch-policy의-유형>Prefetch Policy의 유형</a></li><li><a href=#prefetch-policy의-구현-방법>Prefetch Policy의 구현 방법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=prefetch-policy>Prefetch Policy<a hidden class=anchor aria-hidden=true href=#prefetch-policy>#</a></h2><p><strong>Cache Policy</strong>의 <strong>Prefetch Policy</strong>는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.<br>이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.</p><p><strong>Prefetching</strong>은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.<br>이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.<br>Prefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.</p><p>Prefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.<br>하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.</p><h3 id=prefetching의-필요성>Prefetching의 필요성<a hidden class=anchor aria-hidden=true href=#prefetching의-필요성>#</a></h3><ul><li><strong>성능 향상</strong>: 메모리 접근 속도는 CPU 처리 속도에 비해 상대적으로 느리다. 따라서, 데이터를 미리 로드함으로써 CPU가 대기하는 시간을 줄일 수 있다.</li><li><strong>데이터 지역성 활용</strong>: 프로그램의 데이터 접근 패턴은 일반적으로 지역성을 가지므로, 이전에 접근한 데이터가 다음에도 필요할 가능성이 높다. 이를 활용하여 필요한 데이터를 미리 가져올 수 있다.</li></ul><h3 id=prefetch-policy의-유형>Prefetch Policy의 유형<a hidden class=anchor aria-hidden=true href=#prefetch-policy의-유형>#</a></h3><h4 id=hardware-prefetching>Hardware Prefetching<a hidden class=anchor aria-hidden=true href=#hardware-prefetching>#</a></h4><ul><li><strong>설명</strong>: 하드웨어 수준에서 자동으로 prefetching을 수행한다. CPU나 메모리 컨트롤러가 데이터 접근 패턴을 분석하여 필요한 데이터를 미리 로드한다.</li><li><strong>장점</strong>:<ul><li>프로그래머의 개입 없이 자동으로 작동.</li><li>빠른 반응 속도.</li></ul></li><li><strong>단점</strong>:<ul><li>잘못된 예측으로 인한 불필요한 메모리 사용 가능성.</li></ul></li></ul><h4 id=software-prefetching>Software Prefetching<a hidden class=anchor aria-hidden=true href=#software-prefetching>#</a></h4><ul><li><strong>설명</strong>: 프로그래머가 코드 내에서 prefetch 명령어를 삽입하여 필요한 데이터를 미리 로드한다.</li><li><strong>장점</strong>:<ul><li>특정 알고리즘이나 데이터 구조에 최적화된 prefetching 가능.</li><li>더 세밀한 제어가 가능.</li></ul></li><li><strong>단점</strong>:<ul><li>프로그래머의 추가 작업이 필요.</li><li>잘못된 prefetch로 인한 성능 저하 가능성.</li></ul></li></ul><h4 id=compiler-directed-prefetching>Compiler-Directed Prefetching<a hidden class=anchor aria-hidden=true href=#compiler-directed-prefetching>#</a></h4><ul><li><strong>설명</strong>: 컴파일러가 코드 분석을 통해 자동으로 prefetch 명령어를 삽입한다. 반복문이나 특정 패턴에서 예측 가능한 데이터 접근을 감지하여 수행한다.</li><li><strong>장점</strong>:<ul><li>프로그래머의 개입 없이 성능 최적화 가능.</li><li>반복적인 데이터 접근 패턴에서 효과적.</li></ul></li><li><strong>단점</strong>:<ul><li>모든 상황에서 최적화되지 않을 수 있음.</li></ul></li></ul><h3 id=prefetch-policy의-구현-방법>Prefetch Policy의 구현 방법<a hidden class=anchor aria-hidden=true href=#prefetch-policy의-구현-방법>#</a></h3><ol><li><p>Sequential Prefetching: 순차적으로 접근할 것으로 예상되는 데이터를 미리 로드한다. 예를 들어, 배열이나 리스트와 같은 구조에서 인덱스에 따라 데이터를 가져온다.</p><ul><li><strong>예시</strong>: 반복문 내에서 다음 몇 개의 요소를 미리 로드하는 방식.</li></ul></li><li><p>Stride Prefetching: 일정한 간격으로 접근하는 패턴을 감지하여 그 간격에 맞춰 데이터를 미리 로드한다.</p><ul><li><strong>예시</strong>: 배열의 모든 두 번째 요소를 접근할 경우, 첫 번째 요소를 가져온 후 두 번째 요소를 미리 가져오는 방식.</li></ul></li><li><p>Adaptive Prefetching: 시스템이 현재 데이터 접근 패턴을 분석하여 동적으로 prefetching 전략을 조정한다.</p><ul><li><strong>장점</strong>: 다양한 패턴에 적응하여 성능 최적화 가능.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-policy/>Cache-Policy</a></li><li><a href=https://buenhyden.github.io/tags/prefetch-policy/>Prefetch-Policy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/allocation-policy/><span class=title>« Prev</span><br><span>Allocation Policy</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/replacement-policy/><span class=title>Next »</span><br><span>Replacement Policy</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>