<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Caching Techniques | hyunyoun's Blog</title><meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Caching-Techniques"><meta name=description content="캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/system-components/data-and-state-management/cache/cache-types/caching-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/system-components/data-and-state-management/cache/cache-types/caching-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/system-components/data-and-state-management/cache/cache-types/caching-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Caching Techniques"><meta property="og:description" content="캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T02:37:00+00:00"><meta property="article:modified_time" content="2024-09-30T02:37:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Caching-Techniques"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Caching Techniques"><meta name=twitter:description content="캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Caching Techniques","item":"https://buenhyden.github.io/posts/system-design/system-components/data-and-state-management/cache/cache-types/caching-techniques/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Caching Techniques","name":"Caching Techniques","description":"캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Caching-Techniques"],"articleBody":"Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.\n브라우저 캐싱 (Browser Caching)\n브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.\n사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.\n이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.\n서버 사이드 캐싱 (Server-Side Caching)\n서버 사이드 캐싱은 동적으로 생성된 콘텐츠를 서버에 저장하여 반복적인 처리와 데이터베이스 쿼리를 줄이는 기술이다.\n데이터베이스 쿼리 결과, API 응답, 기타 서버 사이드 연산 결과를 캐시하여 애플리케이션의 성능을 크게 향상시킬 수 있다.\nRedis나 Memcached와 같은 인기 있는 캐싱 메커니즘을 사용하여 캐시된 데이터를 빠르고 효율적으로 저장하고 검색할 수 있다.\nCDN 캐싱 (Content Delivery Network Caching)\nCDN 캐싱은 개발자들이 웹 애플리케이션의 속도와 신뢰성을 향상시키기 위해 널리 사용하는 기술이다.\nCDN은 이미지, 비디오, 스크립트와 같은 정적 자산을 사용자와 가까운 서버에 캐시하여 지연 시간을 줄이고 로딩 시간을 개선한다. 이를 통해 개발자는 전 세계 사용자에게 콘텐츠를 빠르게 전달할 수 있으며, 사용자의 지리적 위치에 관계없이 빠른 접근성을 보장할 수 있다.\n데이터베이스 캐싱 (Database Caching)\n데이터베이스 캐싱은 자주 접근하는 데이터베이스 쿼리 결과를 메모리에 저장하는 기술이다. 이 방법은 반복적인 데이터베이스 조회를 줄여 응답 시간을 크게 개선할 수 있다.\n데이터베이스 캐싱의 주요 이점은 다음과 같다:\n더 빠른 데이터 검색 및 처리 데이터베이스 서버 부하 및 네트워크 트래픽 감소 애플리케이션 확장성 및 성능 향상 애플리케이션 서버 캐시 (Application Server Cache)\n애플리케이션 서버 캐시는 일반적으로 RAM과 같은 고속 액세스 하드웨어에 저장되며, 소프트웨어 구성 요소와 함께 사용될 수 있다.\n이 캐시의 주요 목적은 기본 저장 계층에 대한 액세스 필요성을 줄여 데이터 검색 성능을 향상시키는 것이다.\n용량과 속도를 교환하는 캐시는 일반적으로 완전하고 지속적인 데이터베이스와 달리 일시적으로 데이터의 하위 집합을 저장한다.\n분산 캐시 (Distributed Cache)\n분산 캐시는 클라우드나 서버 팜 환경에서 데이터를 저장하는 데 사용된다. 이 캐시는 요청을 처리하는 서버 간에 공유된다.\n클라이언트는 그룹의 어떤 서버에서든 처리될 수 있는 요청을 제출할 수 있으며, 클라이언트에 대한 캐시된 데이터를 사용할 수 있다.\nASP.NET Core는 SQL Server, Redis, NCache 분산 캐시와 함께 작동한다.\n이러한 다양한 캐싱 기술들은 각각의 장단점이 있으며, 애플리케이션의 특성과 요구사항에 따라 적절히 선택하여 사용해야 한다. 효과적인 캐싱 전략을 구현함으로써 시스템의 성능을 크게 향상시키고 사용자 경험을 개선할 수 있다.\n참고 및 출처 ","wordCount":"362","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T02:37:00Z","dateModified":"2024-09-30T02:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-design/system-components/data-and-state-management/cache/cache-types/caching-techniques/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Caching Techniques</h1><div class=post-description>캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.</div><div class=post-meta><span title='2024-09-30 02:37:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20Design/System%20Components/Data%20and%20State%20Management/Cache/Cache%20Types/Caching-Techniques.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#caching-techniques>Caching Techniques</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=caching-techniques>Caching Techniques<a hidden class=anchor aria-hidden=true href=#caching-techniques>#</a></h2><p>캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.</p><ol><li><p>브라우저 캐싱 (Browser Caching)<br>브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.<br>사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.<br>이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.</p></li><li><p>서버 사이드 캐싱 (Server-Side Caching)<br>서버 사이드 캐싱은 동적으로 생성된 콘텐츠를 서버에 저장하여 반복적인 처리와 데이터베이스 쿼리를 줄이는 기술이다.<br>데이터베이스 쿼리 결과, API 응답, 기타 서버 사이드 연산 결과를 캐시하여 애플리케이션의 성능을 크게 향상시킬 수 있다.<br>Redis나 Memcached와 같은 인기 있는 캐싱 메커니즘을 사용하여 캐시된 데이터를 빠르고 효율적으로 저장하고 검색할 수 있다.</p></li><li><p>CDN 캐싱 (Content Delivery Network Caching)<br>CDN 캐싱은 개발자들이 웹 애플리케이션의 속도와 신뢰성을 향상시키기 위해 널리 사용하는 기술이다.<br>CDN은 이미지, 비디오, 스크립트와 같은 정적 자산을 사용자와 가까운 서버에 캐시하여 지연 시간을 줄이고 로딩 시간을 개선한다. 이를 통해 개발자는 전 세계 사용자에게 콘텐츠를 빠르게 전달할 수 있으며, 사용자의 지리적 위치에 관계없이 빠른 접근성을 보장할 수 있다.</p></li><li><p>데이터베이스 캐싱 (Database Caching)<br>데이터베이스 캐싱은 자주 접근하는 데이터베이스 쿼리 결과를 메모리에 저장하는 기술이다. 이 방법은 반복적인 데이터베이스 조회를 줄여 응답 시간을 크게 개선할 수 있다.<br>데이터베이스 캐싱의 주요 이점은 다음과 같다:</p><ul><li>더 빠른 데이터 검색 및 처리</li><li>데이터베이스 서버 부하 및 네트워크 트래픽 감소</li><li>애플리케이션 확장성 및 성능 향상</li></ul></li><li><p>애플리케이션 서버 캐시 (Application Server Cache)<br>애플리케이션 서버 캐시는 일반적으로 RAM과 같은 고속 액세스 하드웨어에 저장되며, 소프트웨어 구성 요소와 함께 사용될 수 있다.<br>이 캐시의 주요 목적은 기본 저장 계층에 대한 액세스 필요성을 줄여 데이터 검색 성능을 향상시키는 것이다.<br>용량과 속도를 교환하는 캐시는 일반적으로 완전하고 지속적인 데이터베이스와 달리 일시적으로 데이터의 하위 집합을 저장한다.</p></li><li><p>분산 캐시 (Distributed Cache)<br>분산 캐시는 클라우드나 서버 팜 환경에서 데이터를 저장하는 데 사용된다. 이 캐시는 요청을 처리하는 서버 간에 공유된다.<br>클라이언트는 그룹의 어떤 서버에서든 처리될 수 있는 요청을 제출할 수 있으며, 클라이언트에 대한 캐시된 데이터를 사용할 수 있다.<br>ASP.NET Core는 SQL Server, Redis, NCache 분산 캐시와 함께 작동한다.</p></li></ol><p>이러한 다양한 캐싱 기술들은 각각의 장단점이 있으며, 애플리케이션의 특성과 요구사항에 따라 적절히 선택하여 사용해야 한다. 효과적인 캐싱 전략을 구현함으로써 시스템의 성능을 크게 향상시키고 사용자 경험을 개선할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/caching-techniques/>Caching-Techniques</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/enterprise-usage/monorepo-vs-multirepo/><span class=title>« Prev</span><br><span>MonoRepo vs. MultiRepo</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/cpu/><span class=title>Next »</span><br><span>CPU</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>