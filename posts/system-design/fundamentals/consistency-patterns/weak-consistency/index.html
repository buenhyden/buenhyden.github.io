<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Weak Consistency | hyunyoun's Blog</title>
<meta name=keywords content="System-Design,Fundamentals,Consistency-Patterns,Weak-Consistency"><meta name=description content="약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/weak-consistency/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/weak-consistency/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/weak-consistency/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/weak-consistency/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Weak Consistency"><meta property="og:description" content="약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Weak Consistency"><meta name=twitter:description content="약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://buenhyden.github.io/posts/system-design/"},{"@type":"ListItem","position":3,"name":"Fundamentals of System Design","item":"https://buenhyden.github.io/posts/system-design/fundamentals/"},{"@type":"ListItem","position":4,"name":"Consistency Patterns","item":"https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/"},{"@type":"ListItem","position":5,"name":"Weak Consistency","item":"https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/weak-consistency/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/>System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/fundamentals/>Fundamentals of System Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-design/fundamentals/consistency-patterns/>Consistency Patterns</a></div><h1>Weak Consistency</h1><div class=post-description>약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다.</div></header><div class=post-content><h2 id=약한-일관성-weak-consistency>약한 일관성 (Weak Consistency)<a hidden class=anchor aria-hidden=true href=#약한-일관성-weak-consistency>#</a></h2><p>Weak Consistency 는 데이터 일관성을 부분적으로 희생해 시스템 성능과 가용성을 높이는 모델이다. 쓰기 작업이 완료되면 즉시 모든 노드에 동기화되지 않으며, 애플리케이션 요구사항에 따라 일관성 수준을 조절한다. 일시적인 불일치를 허용함으로써 시스템의 가용성과 성능을 향상시킨다. 실시간 스트리밍, 소셜 미디어, 캐시 등에 활용되며, CAP 정리에서 Availability 와 Partition Tolerance 를 우선시한다. 최종 일관성 (Eventual Consistency) 등의 변형이 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>약한 일관성 (Weak Consistency) 은 분산 시스템에서 사용되는 일관성 모델로, 데이터 일관성보다 시스템의 가용성과 성능을 우선시하는 패턴이다.</p><ol><li><p><strong>정의</strong>: 데이터가 업데이트된 후, 시스템의 다른 노드에서 수행되는 후속 읽기 작업이 최신 데이터를 즉시 반영하지 않을 수 있는 모델리가. 즉, 쓰기 연산 후에 읽기 연산이 최신 데이터를 볼 수도 있고 그렇지 않을 수도 있다.</p></li><li><p><strong>최소 보장</strong>: 약한 일관성은 " 최선의 노력 (best-effort)" 접근 방식을 취하며, 특정 시간이 경과하거나 특정 조건이 충족된 후에만 최신 데이터가 반환될 수 있다.</p></li><li><p><strong>CAP 정리와의 관계</strong>: CAP 정리에 따르면, 일관성 (Consistency), 가용성 (Availability), 파티션 허용성 (Partition Tolerance) 중 세 가지를 모두 동시에 충족할 수 없다. 약한 일관성은 일관성을 희생하고 가용성과 파티션 허용성을 우선시한다 (AP 시스템).</p></li><li><p><strong>최종 일관성과의 관계</strong>: 최종 일관성 (Eventual Consistency) 은 약한 일관성의 한 형태로, 새로운 업데이트가 없을 때 모든 노드가 결국 동일한 상태로 수렴하는 것을 보장한다.</p></li><li><p><strong>주요 특징</strong>: 비동기적 데이터 복제, 낮은 지연 시간, 높은 가용성, 파티션 허용성이 특징이다.</p></li></ol><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>약한 일관성 모델은 다음과 같은 목적과 필요성을 가진다:</p><ol><li><p><strong>성능 향상</strong>: 강한 일관성 (Strong Consistency) 은 모든 노드 간의 동기화를 필요로 하여 지연 시간이 증가할 수 있다. 약한 일관성은 즉각적인 동기화가 필요하지 않아 응답 시간이 개선된다.</p></li><li><p><strong>가용성 증대</strong>: 네트워크 파티션이나 노드 장애 상황에서도 시스템이 계속 작동할 수 있게 한다. 강한 일관성 모델에서는 이런 상황에서 시스템이 차단되거나 사용 불가능해질 수 있다.</p></li><li><p><strong>확장성 지원</strong>: 대규모 분산 시스템에서 강한 일관성을 유지하는 것은 매우 복잡하고 비용이 많이 든다. 약한 일관성은 더 쉽게 확장할 수 있는 시스템 구축을 가능하게 한다.</p></li><li><p><strong>지리적 분산 지원</strong>: 전 세계적으로 분산된 시스템에서는 물리적 거리로 인한 지연 시간이 발생한다. 약한 일관성은 이러한 환경에서 더 효율적으로 작동할 수 있다.</p></li><li><p><strong>일시적 일관성 부족의 허용</strong>: 일부 애플리케이션에서는 데이터가 완벽하게 일관되지 않아도 충분히 기능할 수 있다. 약한 일관성은 이런 애플리케이션에 적합하다.</p></li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p>약한 일관성 모델의 주요 기능과 역할은 다음과 같다:</p><ol><li><strong>비동기 데이터 복제</strong>: 데이터 업데이트가 비동기적으로 다른 노드에 전파되어, 즉각적인 동기화 없이도 시스템이 계속 작동할 수 있게 한다.</li><li><strong>가용성 최적화</strong>: 네트워크 문제나 노드 장애가 발생해도 시스템이 계속 작동하도록 하여 높은 가용성을 제공한다.</li><li><strong>성능 향상</strong>: 즉각적인 동기화가 필요 없어 읽기 및 쓰기 작업의 지연 시간이 감소한다.</li><li><strong>확장성 지원</strong>: 대규모 분산 시스템에서도 효율적으로 작동할 수 있게 한다.</li><li><strong>부하 분산</strong>: 여러 노드에 걸쳐 데이터를 분산시켜 시스템 부하를 균등하게 분배한다.</li><li><strong>유연한 일관성 계층</strong>: 애플리케이션마다 다른 일관성 요구사항 지원</li><li><strong>조건적 일관성</strong>: 특정 시간/이벤트 발생 시 일관성 보장 (예: 사용자 새로고침)</li><li><strong>충돌 허용 및 지연 처리</strong>: 충돌 발생 시 나중에 해결 가능</li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p>약한 일관성 모델의 주요 특징은 다음과 같다:</p><ol><li><strong>비동기 복제</strong>: 데이터 업데이트가 비동기적으로 시스템 전체에 전파된다.</li><li><strong>낮은 지연 시간</strong>: 즉각적인 일관성 확인이 필요 없어 응답 시간이 빠르다.</li><li><strong>부분적 일관성</strong>: 일시적으로 노드 간에 데이터가 불일치할 수 있으나, 시간이 지나면 일관성이 달성될 수 있다.</li><li><strong>Best-Effort 접근 방식</strong>: 시스템은 최선을 다해 데이터를 전파하지만, 즉각적인 일관성을 보장하지는 않는다.</li><li><strong>고가용성</strong>: 네트워크 파티션이나 노드 장애 상황에서도 시스템이 계속 작동한다.</li><li><strong>확장성</strong>: 대규모 분산 환경에서 효율적으로 확장할 수 있다.</li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>약한 일관성의 핵심 원칙은 다음과 같다:</p><ol><li><strong>가용성 우선</strong>: 일관성보다 시스템의 가용성과 응답성을 우선시한다.</li><li><strong>점진적 수렴</strong>: 시간이 지남에 따라 모든 노드가 동일한 데이터 상태로 수렴할 수 있다.</li><li><strong>경쟁 상태 허용</strong>: 동시 업데이트로 인한 일시적인 데이터 불일치를 허용한다.</li><li><strong>부분적 실패 대응</strong>: 일부 노드가 실패하더라도 시스템이 계속 작동할 수 있어야 한다.</li><li><strong>비동기 통신</strong>: 노드 간 통신이 비동기적으로 이루어져 지연 시간을 줄인다.</li></ol><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ol><li>클라이언트가 노드 A 에 데이터 쓰기</li><li>노드 A 는 즉시 응답 후 비동기적으로 다른 노드에 전파</li><li>읽기 요청 시 로컬 노드 데이터 반환 (최신 여부 무관)</li><li>주기적 동기화 또는 사용자 트리거로 일관성 검증</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[클라이언트] → 쓰기 → [노드 A]  
</span></span><span class=line><span class=cl>노드 A → (비동기) → [노드 B], [노드 C]  
</span></span><span class=line><span class=cl>클라이언트 읽기 요청 → 최신 데이터 없을 수 있음
</span></span></code></pre></td></tr></table></div></div><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><h4 id=비동기-복제-asynchronous-replication>비동기 복제 (Asynchronous Replication)<a hidden class=anchor aria-hidden=true href=#비동기-복제-asynchronous-replication>#</a></h4><p>주 복제본에서 쓰기 작업이 완료된 후 클라이언트에 응답하고, 다른 복제본으로의 전파는 비동기적으로 진행하는 기법.</p><p><strong>구성</strong>:</p><ul><li>주 복제본과 부 복제본 구조</li><li>주 복제본에서 쓰기 작업 즉시 확인</li><li>배경에서 비동기적으로 부 복제본에 변경사항 전파</li></ul><p><strong>목적</strong>: 낮은 지연 시간과 높은 가용성 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 1개의 주 노드와 2개의 부 노드를 가진 MySQL 복제 설정
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 클라이언트가 주 노드에 데이터 X 업데이트 요청: X = &#34;new_value&#34;
</span></span><span class=line><span class=cl>2. 주 노드가 로컬에서 변경 적용 후 즉시 클라이언트에 성공 응답
</span></span><span class=line><span class=cl>3. 비동기적으로 복제 로그를 부 노드로 전송
</span></span><span class=line><span class=cl>4. 일시적으로 주 노드에서는 X = &#34;new_value&#34;, 부 노드에서는 X = &#34;old_value&#34;
</span></span><span class=line><span class=cl>5. 네트워크 상태와 시스템 부하에 따라 부 노드 동기화 시간 달라짐
</span></span></code></pre></td></tr></table></div></div><h4 id=클라이언트-측-버퍼링-client-side-buffering>클라이언트 측 버퍼링 (Client-side Buffering)<a hidden class=anchor aria-hidden=true href=#클라이언트-측-버퍼링-client-side-buffering>#</a></h4><p>클라이언트가 쓰기 작업을 로컬에 버퍼링하고 나중에 서버에 일괄 전송하는 방식.</p><p><strong>구성</strong>:</p><ul><li>클라이언트 로컬 메모리에 쓰기 작업 저장</li><li>배경에서 또는 특정 조건 (시간, 크기 등) 에 따라 서버로 전송</li><li>오프라인 작업 지원 메커니즘</li></ul><p><strong>목적</strong>: 네트워크 지연이나 연결 문제에 강한 사용자 경험 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8>8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 모바일 메모 애플리케이션과 백엔드 서버
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 사용자가 오프라인 상태에서 메모 작성 및 편집
</span></span><span class=line><span class=cl>2. 모바일 앱이 모든 변경사항을 로컬 데이터베이스에 저장
</span></span><span class=line><span class=cl>3. 네트워크 연결 감지 시:
</span></span><span class=line><span class=cl>   - 변경사항을 묶어서 서버에 전송
</span></span><span class=line><span class=cl>   - 충돌 해결 로직 실행(필요한 경우)
</span></span><span class=line><span class=cl>4. 사용자는 네트워크 상태와 무관하게 앱 사용 가능
</span></span></code></pre></td></tr></table></div></div><h4 id=리더리스-복제-leaderless-replication>리더리스 복제 (Leaderless Replication)<a hidden class=anchor aria-hidden=true href=#리더리스-복제-leaderless-replication>#</a></h4><p>중앙 조정자 없이 모든 노드가 읽기와 쓰기를 수용하는 방식.</p><p><strong>구성</strong>:</p><ul><li>클라이언트가 다수의 또는 모든 노드에 직접 쓰기</li><li>읽기 시 다수의 노드에서 응답을 수집하여 최신 값 선택</li><li>읽기 복구 (Read Repair) 나 반 - 엔트로피 (Anti-entropy) 프로세스로 일관성 유지</li></ul><p><strong>목적</strong>: 단일 실패 지점 제거 및 고가용성 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 5개의 대등한 노드로 구성된 Cassandra 클러스터
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 클라이언트가 키 K에 대한 쓰기 요청: K = &#34;value_x&#34;
</span></span><span class=line><span class=cl>2. 쓰기 요청이 모든 노드에 전송됨(실제로는 쿼럼 W 설정에 따라 다름)
</span></span><span class=line><span class=cl>3. 일부 노드(예: 3개)가 성공적으로 쓰기를 확인하면 작업 성공으로 간주
</span></span><span class=line><span class=cl>4. 나머지 노드는 일시적으로 오래된 값 보유
</span></span><span class=line><span class=cl>5. 이후 읽기 요청 시:
</span></span><span class=line><span class=cl>   - 여러 노드에서 데이터 요청(쿼럼 R 설정에 따라 다름)
</span></span><span class=line><span class=cl>   - 타임스탬프 비교로 최신 값 결정
</span></span><span class=line><span class=cl>   - 오래된 값을 가진 노드들에 대한 읽기 복구 진행
</span></span></code></pre></td></tr></table></div></div><h4 id=로컬-쓰기-글로벌-읽기-local-write-global-read>로컬 쓰기, 글로벌 읽기 (Local Write, Global Read)<a hidden class=anchor aria-hidden=true href=#로컬-쓰기-글로벌-읽기-local-write-global-read>#</a></h4><p>지리적으로 분산된 시스템에서 쓰기는 로컬에서 처리하고 읽기는 전역적으로 수행하는 방식.</p><p><strong>구성</strong>:</p><ul><li>각 지역에서 로컬 쓰기 우선 처리</li><li>글로벌 읽기 요청은 여러 지역의 데이터 통합</li><li>지역간 비동기 복제</li></ul><p><strong>목적</strong>: 지리적으로 분산된 시스템에서 쓰기 지연 시간 최소화</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 미국, 유럽, 아시아에 데이터 센터를 둔 소셜 미디어 플랫폼
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 아시아 사용자가 상태 업데이트: &#34;Hello World&#34;
</span></span><span class=line><span class=cl>2. 업데이트가 아시아 데이터 센터에 즉시 기록되고 사용자에게 확인
</span></span><span class=line><span class=cl>3. 비동기적으로 미국, 유럽 데이터 센터로 복제 시작
</span></span><span class=line><span class=cl>4. 동시에 유럽 사용자가 같은 프로필 조회 요청
</span></span><span class=line><span class=cl>5. 시스템이 여러 지역 데이터 센터에 질의:
</span></span><span class=line><span class=cl>   - 아시아: 새 상태 &#34;Hello World&#34;
</span></span><span class=line><span class=cl>   - 유럽, 미국: 아직 이전 상태
</span></span><span class=line><span class=cl>6. 값 병합 정책에 따라(보통 최신 타임스탬프) 표시할 데이터 결정
</span></span></code></pre></td></tr></table></div></div><h4 id=델타-복제-delta-replication>델타 복제 (Delta Replication)<a hidden class=anchor aria-hidden=true href=#델타-복제-delta-replication>#</a></h4><p>전체 데이터 대신 변경된 부분 (델타) 만 복제하는 기법.</p><p><strong>구성</strong>:</p><ul><li>변경 사항만 추적하는 델타 저장소 유지</li><li>델타 변경 사항 비동기 전송</li><li>수신 노드에서 델타 적용</li></ul><p><strong>목적</strong>: 네트워크 대역폭 절약 및 복제 효율성 향상</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 파일 동기화 서비스(Dropbox와 유사)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 사용자가 100MB 문서의 마지막 페이지만 수정
</span></span><span class=line><span class=cl>2. 클라이언트가 변경된 부분만 감지하여 델타(~10KB) 생성
</span></span><span class=line><span class=cl>3. 델타만 서버로 전송
</span></span><span class=line><span class=cl>4. 서버가 기존 파일에 델타 적용하여 업데이트
</span></span><span class=line><span class=cl>5. 다른 사용자의 디바이스로 델타만 전송
</span></span><span class=line><span class=cl>6. 각 디바이스가 로컬 파일에 델타 적용
</span></span></code></pre></td></tr></table></div></div><h4 id=느슨한-쿼럼-sloppy-quorum>느슨한 쿼럼 (Sloppy Quorum)<a hidden class=anchor aria-hidden=true href=#느슨한-쿼럼-sloppy-quorum>#</a></h4><p>일시적인 네트워크 분할 상황에서 정상적인 쿼럼 노드를 사용할 수 없을 때 일시적으로 다른 노드를 대체 사용하는 방식.</p><p><strong>구성</strong>:</p><ul><li>원래 지정된 노드 집합 정의</li><li>일부 노드 접근 불가 시 임시 대체 노드 사용</li><li>원래 노드 복구 시 힌티드 핸드오프 (Hinted Handoff) 로 데이터 전달</li></ul><p><strong>목적</strong>: 네트워크 분할 상황에서도 쓰기 작업 가용성 유지</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 10개 노드 클러스터의 DynamoDB, 쓰기 쿼럼 W=3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 데이터 항목 X는 노드 1, 2, 3에 저장되도록 해시됨
</span></span><span class=line><span class=cl>2. 네트워크 장애로 노드 3 접근 불가
</span></span><span class=line><span class=cl>3. 느슨한 쿼럼 적용:
</span></span><span class=line><span class=cl>   - 시스템이 노드 1, 2에 쓰기 후
</span></span><span class=line><span class=cl>   - 노드 3 대신 노드 4에 임시로 데이터 저장
</span></span><span class=line><span class=cl>   - 노드 4에는 &#34;이 데이터는 노드 3에 전달될 예정&#34;이라는 힌트 기록
</span></span><span class=line><span class=cl>4. 노드 3 복구 시 노드 4가 저장했던 데이터 전달
</span></span></code></pre></td></tr></table></div></div><h4 id=읽기-시점-일관성-read-your-writes-consistency>읽기 시점 일관성 (Read-your-writes Consistency)<a hidden class=anchor aria-hidden=true href=#읽기-시점-일관성-read-your-writes-consistency>#</a></h4><p>약한 일관성 모델 내에서 최소한 자신의 쓰기 작업 결과는 볼 수 있도록 보장하는 방식.</p><p><strong>구성</strong>:</p><ul><li>클라이언트별 세션 추적</li><li>쓰기 작업의 타임스탬프 또는 버전 기록</li><li>읽기 요청 시 자신의 쓰기가 반영된 복제본에서만 읽기 수행</li></ul><p><strong>목적</strong>: 사용자 경험 향상을 위한 최소한의 일관성 보장</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 웹 애플리케이션과 백엔드 데이터 저장소
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 사용자가 프로필 정보 업데이트: &#34;name&#34;: &#34;John Doe&#34;
</span></span><span class=line><span class=cl>2. 시스템이 세션에 {key: &#34;profile&#34;, version: 5} 기록
</span></span><span class=line><span class=cl>3. 사용자가 자신의 프로필 페이지 로드 요청
</span></span><span class=line><span class=cl>4. 시스템이 세션 정보 확인:
</span></span><span class=line><span class=cl>   - 사용자가 profile을 version 5로 업데이트했음을 인식
</span></span><span class=line><span class=cl>   - 최소한 version 5 이상의 데이터를 가진 복제본에서만 읽기 수행
</span></span><span class=line><span class=cl>5. 아직 복제가 완료되지 않았다면 최신 복제본을 찾거나 업데이트 완료까지 대기
</span></span></code></pre></td></tr></table></div></div><h4 id=세션-일관성-session-consistency>세션 일관성 (Session Consistency)<a hidden class=anchor aria-hidden=true href=#세션-일관성-session-consistency>#</a></h4><p>클라이언트 세션 내에서는 강한 일관성을 보장하지만, 세션 간에는 약한 일관성을 허용하는 방식.</p><p><strong>구성</strong>:</p><ul><li>클라이언트 세션 식별 및 추적</li><li>세션 내에서는 동일 서버/복제본 세트에 요청 라우팅</li><li>세션 메타데이터 유지</li></ul><p><strong>목적</strong>: 사용자 경험과 시스템 확장성 간의 균형 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 전자상거래 웹사이트와 분산 백엔드
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 사용자가 로그인하여 새 세션 시작
</span></span><span class=line><span class=cl>2. 시스템이 세션 ID와 서버 할당 정보 생성
</span></span><span class=line><span class=cl>3. 사용자가 장바구니에 상품 추가
</span></span><span class=line><span class=cl>4. 모든 후속 요청이 동일한 서버 세트로 라우팅됨:
</span></span><span class=line><span class=cl>   - 장바구니 조회 시 방금 추가한 상품 확인 가능
</span></span><span class=line><span class=cl>   - 주문 처리 시 최신 장바구니 상태 사용
</span></span><span class=line><span class=cl>5. 다른 디바이스에서 로그인하면 새 세션 생성:
</span></span><span class=line><span class=cl>   - 이전 세션의 변경사항이 아직 복제되지 않았을 수 있음
</span></span><span class=line><span class=cl>   - 점진적으로 일관성 달성
</span></span></code></pre></td></tr></table></div></div><h4 id=시간-기반-조정-time-based-reconciliation>시간 기반 조정 (Time-based Reconciliation)<a hidden class=anchor aria-hidden=true href=#시간-기반-조정-time-based-reconciliation>#</a></h4><p>타임스탬프를 사용하여 충돌을 자동으로 해결하는 방식.</p><p><strong>구성</strong>:</p><ul><li>모든 쓰기 작업에 타임스탬프 부여</li><li>충돌 시 가장 최근 타임스탬프를 가진 값 선택</li><li>물리적 또는 논리적 시계 사용</li></ul><p><strong>목적</strong>: 간단하면서도 예측 가능한 충돌 해결 메커니즘 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 다중 리전 NoSQL 데이터베이스
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 아시아 리전에서 객체 O 업데이트: {value: &#34;A&#34;, timestamp: 2023-01-01T12:00:00Z}
</span></span><span class=line><span class=cl>2. 네트워크 지연으로 인해 미국 리전으로 복제 진행 중
</span></span><span class=line><span class=cl>3. 동시에 미국 리전에서 같은 객체 업데이트: {value: &#34;B&#34;, timestamp: 2023-01-01T12:00:05Z}
</span></span><span class=line><span class=cl>4. 복제 과정에서 충돌 발생
</span></span><span class=line><span class=cl>5. 타임스탬프 비교:
</span></span><span class=line><span class=cl>   - 미국 리전 업데이트가 더 최근(12:00:05 &gt; 12:00:00)
</span></span><span class=line><span class=cl>   - 최종적으로 모든 리전에서 값 &#34;B&#34; 선택
</span></span></code></pre></td></tr></table></div></div><h4 id=우선순위-기반-조정-priority-based-reconciliation>우선순위 기반 조정 (Priority-based Reconciliation)<a hidden class=anchor aria-hidden=true href=#우선순위-기반-조정-priority-based-reconciliation>#</a></h4><p>미리 정의된 우선순위 규칙에 따라 충돌을 해결하는 방식.</p><p><strong>구성</strong>:</p><ul><li>데이터 타입, 작업 유형, 노드 등에 우선순위 부여</li><li>충돌 감지 시 우선순위 규칙 적용</li><li>애플리케이션 특성에 맞는 커스텀 규칙 정의</li></ul><p><strong>목적</strong>: 비즈니스 로직에 맞는 충돌 해결 정책 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 항공 예약 시스템
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 시스템에 좌석 예약 상태에 대한 우선순위 규칙 정의:
</span></span><span class=line><span class=cl>   - 예약 &gt; 대기 &gt; 비어있음
</span></span><span class=line><span class=cl>   - 관리자 작업 &gt; 시스템 자동화 &gt; 고객 요청
</span></span><span class=line><span class=cl>2. 고객 A가 좌석 S를 &#34;예약&#34; 상태로 변경
</span></span><span class=line><span class=cl>3. 네트워크 지연으로 일부 노드에 아직 반영 안 됨
</span></span><span class=line><span class=cl>4. 시스템 자동화가 동시에 같은 좌석을 &#34;비어있음&#34;으로 변경 시도
</span></span><span class=line><span class=cl>5. 충돌 감지 시:
</span></span><span class=line><span class=cl>   - &#34;예약&#34;이 &#34;비어있음&#34;보다 우선순위 높음
</span></span><span class=line><span class=cl>   - 최종적으로 모든 노드에서 &#34;예약&#34; 상태 유지
</span></span></code></pre></td></tr></table></div></div><h4 id=애플리케이션-특화-해결-application-specific-resolution>애플리케이션 특화 해결 (Application-specific Resolution)<a hidden class=anchor aria-hidden=true href=#애플리케이션-특화-해결-application-specific-resolution>#</a></h4><p>애플리케이션 도메인 지식을 활용하여 충돌을 해결하는 방식.</p><p><strong>구성</strong>:</p><ul><li>데이터 타입별 특화된 병합 함수 정의</li><li>비즈니스 규칙 기반 해결 로직</li><li>충돌 감지 시 커스텀 해결 로직 호출</li></ul><p><strong>목적</strong>: 애플리케이션의 의미론적 요구사항에 맞는 일관성 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시스템 구성: 협업 문서 편집 플랫폼
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시나리오:
</span></span><span class=line><span class=cl>1. 문서의 다양한 부분에 대한 특화된 병합 규칙 정의:
</span></span><span class=line><span class=cl>   - 텍스트: 충돌 시 모든 변경사항 하이라이트하여 사용자 선택 요청
</span></span><span class=line><span class=cl>   - 숫자 데이터(예: 예산): 최대값, 최소값, 또는 평균값 자동 선택
</span></span><span class=line><span class=cl>   - 체크리스트: 항목별 병합(한 쪽에서 체크된 항목은 병합 시 체크 유지)
</span></span><span class=line><span class=cl>2. 사용자 A가 문서의 숫자 필드를 100에서 120으로 변경
</span></span><span class=line><span class=cl>3. 사용자 B가 동시에 같은 필드를 100에서 130으로 변경
</span></span><span class=line><span class=cl>4. 병합 시 &#34;숫자 필드의 최대값 선택&#34; 규칙 적용
</span></span><span class=line><span class=cl>5. 최종 값으로 130 선택
</span></span></code></pre></td></tr></table></div></div><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><p>약한 일관성 모델의 주요 구성 요소와 그 역할은 다음과 같다:</p><table><thead><tr><th>구성 요소</th><th>역할</th><th>기능</th></tr></thead><tbody><tr><td><strong>복제 관리자 (Replication Manager)</strong></td><td>데이터 복제 프로세스 관리 및 조정</td><td>업데이트 전파, 복제 상태 모니터링</td></tr><tr><td><strong>버전 벡터 / 벡터 클럭 (Version Vectors / Vector Clocks)</strong></td><td>데이터 인과 관계 추적</td><td>동시 업데이트 감지, 충돌 분석 정보 제공</td></tr><tr><td><strong>충돌 해결 메커니즘 (Conflict Resolution Mechanism)</strong></td><td>동시 업데이트 충돌 처리</td><td>타임스탬프 기반 선택, 사용자 정의 병합 전략 수행</td></tr><tr><td><strong>안티 - 엔트로피 프로토콜 (Anti-entropy Protocol)</strong></td><td>데이터 불일치 정합성 유지</td><td>노드 간 데이터 비교 및 동기화 수행</td></tr><tr><td><strong>읽기 복구 메커니즘 (Read Repair)</strong></td><td>읽기 중 감지된 불일치 수정</td><td>다중 노드 데이터 비교 및 오래된 복제본 갱신</td></tr><tr><td><strong>가십 프로토콜 (Gossip Protocol)</strong></td><td>노드 상태와 메타데이터 전파</td><td>무작위 노드 간 정보 교환으로 전체 시스템 동기화</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>높은 가용성</td><td>네트워크 파티션이나 노드 장애 상황에서도 시스템이 계속 작동할 수 있음</td></tr><tr><td></td><td>낮은 지연 시간</td><td>즉각적인 일관성 검증이 필요 없어 응답 시간이 빨라짐</td></tr><tr><td></td><td>높은 처리량</td><td>동기화 오버헤드가 줄어들어 더 많은 요청을 처리할 수 있음</td></tr><tr><td></td><td>확장성</td><td>노드 추가가 쉽고, 대규모 분산 환경에서 효율적으로 작동함</td></tr><tr><td></td><td>지리적 분산 지원</td><td>물리적으로 멀리 떨어진 데이터 센터 간 작동에 적합함</td></tr><tr><td></td><td>비용 효율성</td><td>동기화 오버헤드가 줄어들어 리소스 사용이 효율적임</td></tr><tr><td>⚠ 단점</td><td>데이터 불일치</td><td>일시적으로 노드 간 데이터가 불일치할 수 있어 일관되지 않은 결과가 반환될 수 있음</td></tr><tr><td></td><td>복잡한 프로그래밍 모델</td><td>개발자가 데이터 불일치 가능성을 고려하여 애플리케이션을 설계해야 함</td></tr><tr><td></td><td>충돌 해결 복잡성</td><td>동시 업데이트로 인한 충돌을 해결하기 위한 추가 메커니즘이 필요함</td></tr><tr><td></td><td>디버깅 어려움</td><td>일시적 불일치로 인해 문제 추적과 디버깅이 어려워짐</td></tr><tr><td></td><td>잠재적 데이터 손실</td><td>노드 장애 발생 시 복제되지 않은 데이터가 손실될 가능성이 있음</td></tr><tr><td></td><td>사용 사례 제한</td><td>금융 거래와 같이 강한 일관성이 필요한 애플리케이션에는 적합하지 않음</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><p>약한 일관성 모델을 구현하고 유지하는 데 있어서의 주요 도전 과제는 다음과 같다:</p><ol><li><p><strong>충돌 해결</strong>: 동시 업데이트로 인한 데이터 충돌을 효과적으로 해결하는 것은 복잡한 문제이다. 적절한 충돌 해결 전략을 선택하고 구현해야 한다.</p></li><li><p><strong>최종 일관성 달성 보장</strong>: 시스템이 안정적으로 최종 일관성을 달성하도록 보장하는 것은 어려울 수 있다. 특히 지속적인 업데이트나 네트워크 문제가 있는 경우 더욱 그렇다.</p></li><li><p><strong>데이터 신선도 관리</strong>: 사용자가 오래된 데이터를 볼 수 있다는 점을 고려하여, 애플리케이션 수준에서 데이터 신선도를 어떻게 관리할지 결정해야 한다.</p></li><li><p><strong>개발자 친화적 인터페이스</strong>: 약한 일관성의 복잡성을 추상화하면서도 개발자가 필요한 제어를 할 수 있는 균형 잡힌 API 를 설계해야 한다.</p></li><li><p><strong>모니터링 및 디버깅</strong>: 분산된 노드에서 발생하는 일관성 문제를 모니터링하고 디버깅하는 것은 어려울 수 있다.</p></li><li><p><strong>데이터 손실 가능성 최소화</strong>: 노드 장애 시 데이터 손실을 최소화하기 위한 전략을 구현해야 한다.</p></li><li><p><strong>일관성 수준 조정</strong>: 애플리케이션의 요구사항에 맞게 일관성 수준을 조정하는 것은 복잡한 작업이다.</p></li></ol><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>유형</th><th>특징</th><th>사용 사례</th></tr></thead><tbody><tr><td>단순 약한 일관성</td><td>기본적인 약한 일관성 모델, 업데이트 전파에 대한 최소한의 보장만 제공</td><td>실시간 스트리밍, 로그 데이터</td></tr><tr><td>최종 일관성</td><td>시간이 지나면 모든 노드가 동일한 상태로 수렴함을 보장</td><td>DNS, 소셜 미디어 피드, 콘텐츠 전송 네트워크 (CDN)</td></tr><tr><td>읽기 후 쓰기 일관성</td><td>클라이언트가 자신이 쓴 데이터를 읽을 수 있음을 보장</td><td>사용자 프로필 업데이트, 콘텐츠 관리 시스템</td></tr><tr><td>세션 일관성</td><td>단일 세션 내에서 일관된 뷰를 제공</td><td>웹 애플리케이션 세션, 쇼핑 카트</td></tr><tr><td>인과 일관성</td><td>W 인과적으로 관련된 작업의 순서가 모든 노드에서 일관되게 관찰됨을 보장</td><td>채팅 애플리케이션, 협업 도구</td></tr><tr><td>단조 읽기 일관성</td><td>클라이언트가 한 번 읽은 데이터의 이전 버전을 읽지 않음을 보장</td><td>뉴스 피드, 블로그 댓글</td></tr><tr><td>단조 쓰기 일관성</td><td>클라이언트의 쓰기 작업이 순서대로 처리됨을 보장</td><td>로그 시스템, 감사 추적</td></tr><tr><td>쓰기 후 읽기 일관성</td><td>모든 노드에서 새로운 값을 읽기 전에 쓰기가 완료됨을 보장</td><td>구성 관리, 설정 업데이트</td></tr><tr><td>CRDT 기반 일관성</td><td>충돌 없는 복제 데이터 타입을 사용하여 자동 충돌 해결</td><td>실시간 협업 편집기, 분산 카운터</td></tr><tr><td>델타 상태 일관성</td><td>전체 상태가 아닌 변경된 부분 (델타) 만 전파</td><td>실시간 업데이트가 필요한 IoT 애플리케이션</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>응용 분야</th><th>구현 방식</th><th>예시</th></tr></thead><tbody><tr><td>콘텐츠 전송 네트워크 (CDN)</td><td>엣지 서버에 콘텐츠 캐싱, 비동기 갱신</td><td>Cloudflare, Akamai: 전 세계 엣지 서버에 콘텐츠 복제</td></tr><tr><td>NoSQL 데이터베이스</td><td>다중 리전 복제, 가십 프로토콜, 벡터 클럭</td><td>Amazon DynamoDB, Apache Cassandra: 최종 일관성 모드</td></tr><tr><td>소셜 미디어 플랫폼</td><td>사용자별 피드 비동기 업데이트, 읽기 시점 병합</td><td>Facebook, Twitter: 포스트와 댓글이 비동기적으로 업데이트됨</td></tr><tr><td>실시간 통신</td><td>메시지 전달 최적화, 상태 동기화 지연 허용</td><td>Discord, WhatsApp: 메시지 전송과 수신 사이에 지연 허용</td></tr><tr><td>게임 서버</td><td>플레이어 상태 비동기 업데이트, 충돌 해결 알고리즘</td><td>MMO 게임: 플레이어 위치 및 상태 업데이트</td></tr><tr><td>분산 캐시</td><td>쓰기 후 캐시 패턴, 비동기 데이터베이스 업데이트</td><td>Redis Cluster: 다중 노드 간 비동기 복제</td></tr><tr><td>IoT 시스템</td><td>디바이스 상태 비동기 업데이트, 델타 동기화</td><td>AWS IoT Core: 장치 섀도우로 오프라인 상태에서도 작동</td></tr><tr><td>로그 및 모니터링 시스템</td><td>분산 로그 수집기, 비동기 집계</td><td>ELK Stack: 로그 수집과 분석의 비동기 처리</td></tr><tr><td>쇼핑몰 재고 관리</td><td>최종 일관성 기반 재고 업데이트, 낙관적 잠금</td><td>Amazon: 재고 수량이 일시적으로 불일치할 수 있으나 결제 시 확인</td></tr><tr><td>협업 도구</td><td>CRDT 기반 문서 편집, 충돌 자동 해결</td><td>Google Docs: 여러 사용자가 동시에 문서 편집 가능</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1>사례 1<a hidden class=anchor aria-hidden=true href=#사례-1>#</a></h4><p>소셜 미디어 플랫폼은 약한 일관성 모델의 대표적인 활용 사례이다.<br>사용자가 글을 게시하거나 댓글을 달면, 이 정보는 즉시 모든 팔로워에게 전파되지 않고 비동기적으로 전파된다.</p><p><strong>시나리오</strong>:</p><ol><li>사용자 A 가 새 게시물을 작성한다.</li><li>게시물은 사용자 A 의 로컬 데이터 센터에 저장된다.</li><li>사용자 A 는 즉시 성공 응답을 받는다.</li><li>게시물은 비동기적으로 다른 지역의 데이터 센터로 복제된다.</li><li>사용자 B(다른 지역) 가 타임라인을 로드할 때, A 의 게시물이 아직 복제되지 않았다면 보이지 않을 수 있다.</li><li>시간이 경과하면 복제가 완료되고 사용자 B 는 A 의 게시물을 볼 수 있게 된다.</li></ol><p>이 시나리오에서 약한 일관성은 다음과 같은 이점을 제공한다:</p><ul><li>게시물 작성 시 즉각적인 응답으로 사용자 경험이 향상된다.</li><li>데이터 센터 간 동기화가 비동기적으로 이루어져 시스템 부하가 분산된다.</li><li>네트워크 문제가 있어도 사용자는 계속해서 서비스를 이용할 수 있다.</li></ul><h4 id=사례-2>사례 2<a hidden class=anchor aria-hidden=true href=#사례-2>#</a></h4><p>약한 일관성 모델의 대표적 사례인 <strong>Amazon DynamoDB</strong>를 중심으로 아키텍처와 구현 방식을 설명한다.</p><p><strong>Amazon DynamoDB 아키텍처 다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[클라이언트]
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       ├─ (쓰기 요청) ──▶ [마스터 노드]
</span></span><span class=line><span class=cl>       │                    │
</span></span><span class=line><span class=cl>       │                    ├─ 비동기 복제 ──▶ [복제본 노드 1]
</span></span><span class=line><span class=cl>       │                    └─ 비동기 복제 ──▶ [복제본 노드 2]
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       └─ (읽기 요청) ──▶ [가장 가까운 노드]
</span></span><span class=line><span class=cl>                          │
</span></span><span class=line><span class=cl>                          ├─ 최종적 일관성: 즉시 응답 (과거 데이터 가능)
</span></span><span class=line><span class=cl>                          └─ 강력한 일관성: 모든 노드 동기화 확인 후 응답
</span></span></code></pre></td></tr></table></div></div><p><strong>핵심 아키텍처 요소</strong></p><ol><li><p><strong>파티셔닝</strong></p><ul><li>데이터를 해시 키 기반으로 자동 분할 (샤딩)</li><li>각 파티션은 3 개 이상의 가용 영역 (AZ) 에 복제</li></ul></li><li><p><strong>비동기 복제 메커니즘</strong></p><ul><li>쓰기 작업 시 마스터 노드에서 즉시 처리 후 복제본에 비동기 전파</li><li>복제 지연 시간: 일반적으로 1 초 미만</li></ul></li><li><p><strong>충돌 해결 전략</strong></p><ul><li><strong>Last Write Wins(LWW)</strong>: 타임스탬프 기반 최신 데이터 선택</li><li><strong>클라이언트 측 병합</strong>: 애플리케이션에서 버전 벡터 비교 후 처리</li></ul></li></ol><p><strong>구현 방식 예시: 전자상거래 장바구니 시스템</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># DynamoDB 항목 구조 예시</span>
</span></span><span class=line><span class=cl><span class=n>item</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;CartID&#34;</span><span class=p>:</span> <span class=s2>&#34;user123&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;Items&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;productA&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;productB&#34;</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;Version&#34;</span><span class=p>:</span> <span class=mi>3</span>  <span class=c1># 버전 관리를 위한 벡터 클럭</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 쓰기 작업 (강력한 일관성)</span>
</span></span><span class=line><span class=cl><span class=n>dynamodb</span><span class=o>.</span><span class=n>put_item</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>TableName</span><span class=o>=</span><span class=s1>&#39;ShoppingCart&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Item</span><span class=o>=</span><span class=n>item</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ConditionExpression</span><span class=o>=</span><span class=s1>&#39;Version = :prev_version&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>ExpressionAttributeValues</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;:prev_version&#39;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 읽기 작업 (최종적 일관성)</span>
</span></span><span class=line><span class=cl><span class=n>response</span> <span class=o>=</span> <span class=n>dynamodb</span><span class=o>.</span><span class=n>get_item</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>TableName</span><span class=o>=</span><span class=s1>&#39;ShoppingCart&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;CartID&#39;</span><span class=p>:</span> <span class=s1>&#39;user123&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>ConsistentRead</span><span class=o>=</span><span class=kc>False</span>  <span class=c1># 약한 일관성 모드</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>동작 흐름</strong>:</p><ol><li>사용자 A 가 제품 추가 → 마스터 노드에 즉시 반영</li><li>복제본 노드들은 비동기적으로 업데이트 수신 (지연 가능)</li><li>사용자 B 가 장바구니 조회 → 가장 가까운 복제본에서 데이터 제공</li><li>일시적 불일치 발생 시 자동 충돌 해결 (버전 비교)</li></ol><p><strong>주요 설계 고려사항</strong></p><ol><li><strong>세션 일관성 (Session Consistency)</strong><ul><li>동일 클라이언트는 동일 노드로 라우팅되어 일관성 유지</li></ul></li><li><strong>모니터링 메트릭</strong><ul><li><code>ReplicationLatency</code> 지표로 복제 지연 추적</li></ul></li><li><strong>폴백 전략</strong><ul><li>일관성 읽기 실패 시 버전 비교 후 재시도 구현</li></ul></li></ol><h4 id=사례-3>사례 3<a hidden class=anchor aria-hidden=true href=#사례-3>#</a></h4><p><strong>캐시 시스템 (Cache System)</strong></p><p><strong>시스템</strong>:</p><ul><li><strong>Redis / Memcached</strong> 기반 캐시 계층</li><li><strong>CDN (Content Delivery Network)</strong> 캐시 서버</li><li><strong>로그 수집 시스템의 버퍼 노드</strong></li><li><strong>IoT 장치의 임시 로컬 저장소</strong></li></ul><p><strong>시나리오</strong>:<br>쇼핑몰에서 상품 상세 페이지를 열 때, DB 에서 데이터를 직접 읽기엔 느리기 때문에 캐시에서 빠르게 가져오도록 설계됨.</p><ul><li>데이터는 <code>Weak Consistency</code> 를 따르는 캐시에 먼저 저장됨.</li><li>캐시는 일정 TTL(Time-To-Live) 혹은 비동기적인 방식으로만 갱신됨.</li><li>DB 의 데이터가 바뀌어도 캐시에 즉시 반영되지 않을 수 있음.</li></ul><p>쇼핑몰 상품 조회</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>시간(Time) 흐름 →
</span></span><span class=line><span class=cl>사용자 A:     ──── Update(Product#123, price=300) ────► [DB]
</span></span><span class=line><span class=cl>                                                  └────X (캐시 반영 안 됨)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>사용자 B:         ◄──── Read(Product#123) ─────── [Cache: price=250]
</span></span><span class=line><span class=cl>                                                          ↓
</span></span><span class=line><span class=cl>                                                        오래된 값
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>시간 경과 후...
</span></span><span class=line><span class=cl>                            ◄──── Cache Refresh (price=300)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>사용자 C:         ◄──── Read(Product#123) ─────── [Cache: price=300]
</span></span></code></pre></td></tr></table></div></div><ul><li>사용자 A 가 DB 에 상품 가격을 업데이트했지만,</li><li>사용자 B 는 아직 캐시에 저장된 <strong>오래된 값 (price=250)</strong> 을 읽음</li><li>일정 시간이 지나 캐시가 갱신되어 사용자 C 부터는 <strong>최신 값 (price=300)</strong> 을 보게 됨</li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>주의할 점</th></tr></thead><tbody><tr><td>일관성 요구사항 분석</td><td>애플리케이션 요구사항에 따라 최적의 일관성 수준 선택</td><td>과도하게 약한 일관성을 적용하면 사용자 경험이 저하될 수 있음</td></tr><tr><td>데이터 유형별 일관성 차별화</td><td>중요도와 특성에 따라 데이터별로 다른 일관성 모델 적용</td><td>금융 거래와 같은 중요 데이터에는 약한 일관성을 적용하지 말 것</td></tr><tr><td>충돌 해결 전략</td><td>동시 업데이트로 인한 충돌 해결을 위한 명확한 전략 수립</td><td>충돌 해결이 없으면 데이터 무결성이 손상될 수 있음</td></tr><tr><td>시스템 모니터링</td><td>일관성 수준과 복제 지연을 모니터링하는 도구 구현</td><td>모니터링 부재 시 일관성 문제를 감지하지 못할 수 있음</td></tr><tr><td>사용자 경험 설계</td><td>일시적 일관성 부족을 사용자에게 적절히 전달하는 UI/UX 설계</td><td>불일치에 대한 안내가 없으면 사용자 혼란을 초래할 수 있음</td></tr><tr><td>복제 전략</td><td>데이터 센터 위치, 복제 토폴로지, 복제 빈도 최적화</td><td>부적절한 복제 전략은 지연 시간 증가 및 불일치를 연장시킬 수 있음</td></tr><tr><td>장애 처리</td><td>네트워크 파티션 및 노드 장애 시 동작 방식 명확화</td><td>장애 상황에서 자동 복구 메커니즘이 없으면 수동 개입이 필요함</td></tr><tr><td>데이터 신선도 관리</td><td>읽기 작업 시 데이터 신선도 요구사항 정의</td><td>너무 오래된 데이터를 반환하면 사용자 신뢰도가 감소할 수 있음</td></tr><tr><td>확장성 계획</td><td>확장 시 일관성 모델이 어떻게 영향받는지 고려</td><td>확장 시 복제 지연이 증가하여 일관성 저하가 발생할 수 있음</td></tr><tr><td>테스트 전략</td><td>약한 일관성 시나리오를 테스트하기 위한 전략 수립</td><td>일관성 문제는 재현하기 어려워 철저한 테스트가 필요함</td></tr></tbody></table><h3 id=성능을-최적화하기-위한-고려사항-및-주의할-점>성능을 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#성능을-최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>주의할 점</th></tr></thead><tbody><tr><td>복제 토폴로지 최적화</td><td>데이터 흐름 패턴에 맞는 최적의 복제 토폴로지 선택</td><td>잘못된 토폴로지는 네트워크 오버헤드와 복제 지연을 증가시킬 수 있음</td></tr><tr><td>지역 기반 라우팅</td><td>사용자를 가장 가까운 데이터 센터로 라우팅</td><td>로드 밸런싱만 고려하면 지연 시간이 증가할 수 있음</td></tr><tr><td>배치 처리</td><td>작은 업데이트를 모아 배치로 처리하여 네트워크 오버헤드 감소</td><td>배치 크기가 너무 크면 지연 시간이 길어질 수 있음</td></tr><tr><td>증분 동기화</td><td>전체 데이터가 아닌 변경된 부분만 동기화</td><td>장기간 누적된 변경사항 관리가 복잡해질 수 있음</td></tr><tr><td>가십 프로토콜 조정</td><td>가십 프로토콜의 빈도와 전파 패턴 최적화</td><td>너무 빈번한 가십은 네트워크 부하를 증가시킬 수 있음</td></tr><tr><td>벡터 클럭 최적화</td><td>벡터 클럭 크기를 관리하고 압축하는 전략 수립</td><td>벡터 클럭이 너무 크면 메모리 및 네트워크 오버헤드가 발생함</td></tr><tr><td>읽기 최적화</td><td>자주 읽는 데이터를 위한 캐싱 전략 구현</td><td>캐시 무효화 전략이 없으면 일관성 문제가 악화될 수 있음</td></tr><tr><td>쓰기 최적화</td><td>쓰기 작업을 위한 버퍼링 및 병합 전략 구현</td><td>과도한 버퍼링은 데이터 손실 위험을 증가시킬 수 있음</td></tr><tr><td>충돌 해결 효율화</td><td>효율적인 충돌 감지 및 해결 알고리즘 선택</td><td>복잡한 해결 알고리즘은 성능 저하를 초래할 수 있음</td></tr><tr><td>백그라운드 안티 - 엔트로피</td><td>주기적인 백그라운드 동기화로 일관성 유지</td><td>동기화 빈도 설정이 중요하며, 과도한 동기화는 리소스를 낭비함</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>하이브리드 일관성 모델</td><td>적응형 일관성</td><td>트래픽 패턴과 시스템 부하에 따라 일관성 수준을 자동으로 조정하는 시스템 등장</td></tr><tr><td></td><td>컨텍스트 인식 일관성</td><td>데이터의 중요도와 접근 패턴에 따라 일관성 수준을 다르게 적용</td></tr><tr><td>머신러닝 통합</td><td>일관성 예측</td><td>ML 알고리즘을 사용하여 사용자 행동과 데이터 접근 패턴을 예측하고 선제적 복제</td></tr><tr><td></td><td>충돌 해결 자동화</td><td>ML 기반 충돌 해결로 인간의 개입 없이 최적의 병합 결정</td></tr><tr><td>엣지 컴퓨팅 최적화</td><td>엣지 우선 일관성</td><td>엣지 디바이스에서의 로컬 일관성을 우선시하고 클라우드와 점진적 동기화</td></tr><tr><td></td><td>엣지 - 클라우드 하이브리드</td><td>엣지와 클라우드 간의 효율적인 데이터 동기화를 위한 새로운 프로토콜</td></tr><tr><td>양자 내성 분산 시스템</td><td>양자 안전 합의 알고리즘</td><td>양자 컴퓨팅 위협에 대비한 새로운 합의 및 일관성 프로토콜</td></tr><tr><td>지속성 메모리 활용</td><td>메모리 - 스토리지 계층 통합</td><td>지속성 메모리를 활용한 새로운 일관성 모델로 성능과 내구성 균형</td></tr><tr><td>대규모 글로벌 분산 시스템</td><td>글로벌 일관성 관리</td><td>전 세계적으로 분산된 시스템에서 지역별 일관성과 글로벌 일관성의 균형</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>CRDT 발전</td><td>고급 CRDT 구조</td><td>더 복잡한 데이터 구조를 지원하는 새로운 CRDT 유형 개발</td></tr><tr><td></td><td>압축 CRDT</td><td>메타데이터 오버헤드를 줄인 효율적인 CRDT 구현</td></tr><tr><td>일관성과 프라이버시</td><td>로컬 우선 암호화</td><td>데이터가 복제되기 전에 로컬에서 암호화하는 방식</td></tr><tr><td></td><td>차등 프라이버시 일관성</td><td>개인정보 보호를 고려한 일관성 모델</td></tr><tr><td>서버리스와 약한 일관성</td><td>함수형 일관성 모델</td><td>서버리스 환경에서 최적화된 약한 일관성 패턴</td></tr><tr><td>5G/6G 네트워크 영향</td><td>초저지연 일관성</td><td>초고속 네트워크를 활용한 새로운 일관성 모델</td></tr><tr><td>규제 준수</td><td>규제 인식 일관성</td><td>데이터 주권 및 규제 요구사항을 자동으로 고려하는 일관성 모델</td></tr><tr><td>블록체인 통합</td><td>검증 가능한 일관성</td><td>블록체인 기술을 활용한 감사 가능한 약한 일관성 구현</td></tr><tr><td>차등 일관성</td><td>워크로드 기반 조정</td><td>CPU/네트워크 상태에 따라 일관성 수준 동적 변경</td></tr></tbody></table><h3 id=주제와-관련하여서-하위-주제로-분류해서-추가적으로-학습해야할-내용>주제와 관련하여서 하위 주제로 분류해서 추가적으로 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여서-하위-주제로-분류해서-추가적으로-학습해야할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>이론적 기반</td><td>분산 시스템 이론</td><td>분산 시스템의 기본 원리와 개념</td></tr><tr><td></td><td>CAP 정리 및 확장</td><td>CAP 정리와 PACELC 정리 등 일관성 관련 정리</td></tr><tr><td></td><td>일관성 모델 분류학</td><td>다양한 일관성 모델의 체계적 분류와 비교</td></tr><tr><td>구현 기술</td><td>복제 프로토콜</td><td>데이터 복제를 위한 다양한 프로토콜</td></tr><tr><td></td><td>충돌 감지 및 해결</td><td>동시 업데이트 충돌을 감지하고 해결하는 알고리즘</td></tr><tr><td></td><td>벡터 클럭 및 버전 벡터</td><td>분산 환경에서 이벤트 순서 추적을 위한 메커니즘</td></tr><tr><td>최적화 기법</td><td>지역성 최적화</td><td>지리적 위치에 따른 데이터 접근 최적화</td></tr><tr><td></td><td>읽기/쓰기 최적화</td><td>다양한 읽기/쓰기 패턴에 대한 성능 최적화</td></tr><tr><td></td><td>네트워크 토폴로지 설계</td><td>약한 일관성에 최적화된 네트워크 구조</td></tr><tr><td>데이터 구조</td><td>CRDTs</td><td>충돌 없는 복제 데이터 타입의 이론과 구현</td></tr><tr><td></td><td>델타 상태 CRDTs</td><td>효율적인 상태 전파를 위한 델타 기반 CRDT</td></tr><tr><td></td><td>JSON CRDT</td><td>JSON 데이터를 위한 CRDT 구현</td></tr><tr><td>시스템 설계</td><td>하이브리드 일관성 시스템</td><td>다양한 일관성 모델을 혼합한 시스템 설계</td></tr><tr><td></td><td>멀티 데이터센터 아키텍처</td><td>지리적으로 분산된 데이터센터를 위한 일관성 설계</td></tr><tr><td></td><td>엣지 컴퓨팅 일관성</td><td>엣지 디바이스를 포함한 분산 환경에서의 일관성</td></tr></tbody></table><h3 id=주제와-관련하여서-추가로-알아야-하거나-학습해야할-내용들>주제와 관련하여서 추가로 알아야 하거나 학습해야할 내용들<a hidden class=anchor aria-hidden=true href=#주제와-관련하여서-추가로-알아야-하거나-학습해야할-내용들>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>관련 기술</td><td>NoSQL 데이터베이스</td><td>약한 일관성을 구현하는 다양한 NoSQL 솔루션</td></tr><tr><td></td><td>분산 메시징 시스템</td><td>비동기 통신을 위한 메시징 플랫폼과 일관성</td></tr><tr><td></td><td>이벤트 소싱</td><td>이벤트 기반 아키텍처와 약한 일관성의 관계</td></tr><tr><td>사용 사례</td><td>금융 시스템의 일관성</td><td>금융 거래에서 일관성 요구사항과 약한 일관성의 적용 가능성</td></tr><tr><td></td><td>IoT 와 약한 일관성</td><td>사물인터넷 환경에서의 데이터 일관성 관리</td></tr><tr><td></td><td>실시간 협업 시스템</td><td>실시간 협업 도구에서의 일관성 구현</td></tr><tr><td>성능과 모니터링</td><td>일관성 메트릭</td><td>약한 일관성 시스템의 성능을 측정하는 지표</td></tr><tr><td></td><td>일관성 모니터링 도구</td><td>분산 시스템에서 일관성 수준을 모니터링하는 방법</td></tr><tr><td></td><td>성능 벤치마킹</td><td>다양한 일관성 모델의 성능 비교</td></tr><tr><td>보안 및 규정 준수</td><td>분산 시스템 보안</td><td>약한 일관성 환경에서의 보안 고려사항</td></tr><tr><td></td><td>규제와 일관성</td><td>데이터 규제가 일관성 모델 선택에 미치는 영향</td></tr><tr><td></td><td>개인정보 보호와 일관성</td><td>개인정보 보호 요구사항과 일관성 모델의 관계</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>벡터 시계 (Vector Clock)</td><td>분산 시스템에서 이벤트 순서를 추적하는 논리적 타임스탬프 기법</td></tr><tr><td>SLA(Service Level Agreement)</td><td>서비스 수준 합의로 최대 허용 지연 시간 등을 명시한 계약</td></tr><tr><td>CAP 정리</td><td>Consistency, Availability, Partition Tolerance 중 2 개 보장 이론</td></tr></tbody></table><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>약한 일관성 (Weak Consistency)</td><td>데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치를 허용하는 일관성 모델입니다.</td></tr><tr><td>최종 일관성 (Eventual Consistency)</td><td>데이터의 최신 상태를 즉시 보장하지 않지만, 시간이 지나면 결국 일관된 상태가 되는 일관성 모델입니다.</td></tr><tr><td>비동기 동기화 (Asynchronous Synchronization)</td><td>데이터의 동기화를 비동기적으로 처리하여 시스템의 성능을 향상시키는 방법입니다.</td></tr><tr><td>데이터 복제 (Data Replication)</td><td>데이터를 여러 노드에 복제하여 가용성을 높이는 방법입니다.</td></tr><tr><td>Gossip Protocol</td><td>분산 노드 간 정보를 무작위로 전파하여 데이터 일관성을 확보하는 통신 프로토콜</td></tr><tr><td>Tunable Consistency</td><td>시스템이 상황에 따라 일관성 수준을 조절할 수 있는 기능</td></tr><tr><td>Network Partition</td><td>네트워크 단절로 인해 노드 간 통신이 불가능한 상태</td></tr><tr><td>CAP 정리</td><td>분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 파티션 허용성 (Partition Tolerance) 중 세 가지를 동시에 충족할 수 없다는 정리</td></tr><tr><td>PACELC 정리</td><td>CAP 정리를 확장한 개념으로, 네트워크 파티션 발생 시 (P) 에는 가용성 (A) 과 일관성 (C) 중 하나를 선택해야 하며, 그렇지 않은 경우 (E) 에는 지연 시간 (L) 과 일관성 (C) 중 하나를 선택해야 한다는 정리</td></tr><tr><td>벡터 클럭</td><td>분산 시스템에서 이벤트의 인과 관계를 추적하기 위한 메커니즘으로, 각 노드의 논리적 시간을 벡터로 표현</td></tr><tr><td>CRDT</td><td>충돌 없는 복제 데이터 타입 (Conflict-free Replicated Data Types) 으로, 동시 업데이트 충돌을 자동으로 해결할 수 있는 특수한 데이터 구조</td></tr><tr><td>안티 - 엔트로피</td><td>노드 간의 데이터 불일치를 주기적으로 감지하고 해결하는 프로세스</td></tr><tr><td>읽기 복구</td><td>읽기 작업 중에 발견된 데이터 불일치를 해결하는 메커니즘</td></tr><tr><td>쓰기 후 읽기 일관성</td><td>클라이언트가 자신이 작성한 데이터를 다시 읽을 때 최신 값을 볼 수 있음을 보장하는 일관성 모델</td></tr><tr><td>단조 읽기</td><td>클라이언트가 데이터를 한 번 읽으면, 이후 읽기 작업에서 그보다 오래된 버전을 볼 수 없음을 보장하는 일관성 모델</td></tr><tr><td>낙관적 복제</td><td>동기화 없이 복제본에 대한 즉각적인 업데이트를 허용하고, 나중에 복제본 간의 불일치를 해결하는 접근 방식</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.geeksforgeeks.org/weak-vs-eventual-consistency-in-system-design/>Weak vs Eventual Consistency in System Design – GeeksforGeeks</a></li><li><a href=https://cs.fyi/guide/consistency-patterns-week-strong-eventual/>Consistency Patterns – CS.fyi</a></li><li><a href=https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf>Amazon Dynamo: A Highly Available Key-value Store (SOSP 2007)</a></li><li><a href=https://dataintensive.net/>Designing Data-Intensive Applications – Martin Kleppmann</a></li><li><a href=https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html>AWS DynamoDB 공식 문서 – 일관성 설정</a></li><li><a href=https://crdt.tech/>Conflict-free Replicated Data Types (CRDTs)</a></li><li><a href=https://www.microsoft.com/en-us/research/publication/weak-consistency-models/>Weak Consistency Models - Microsoft Research</a></li><li><a href=https://aws.amazon.com/ko/dynamodb/consistency/>Amazon DynamoDB Consistency Models</a></li><li><a href=https://www.infoq.com/articles/weak-consistency-distributed-systems/>Weak Consistency in Distributed Systems – InfoQ</a></li><li><a href=https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/>CAP Theorem and Consistency in Distributed Systems – InfoQ</a></li><li><a href=https://akfpartners.com/growth-blog/scalability-and-weak-consistency>The Art of Scalability – AKF Partners 블로그</a></li><li><a href=https://systemdesign.one/consistency-patterns/>System Design - Consistency Patterns</a></li><li><a href=https://www.geeksforgeeks.org/consistency-model-in-distributed-system/>Consistency Model in Distributed System – GeeksforGeeks</a></li><li><a href=https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7>Eventual vs Strong Consistency in Distributed Databases – HackerNoon</a></li><li><a href=https://mwhittaker.github.io/consistency_in_distributed_systems/1_baseball.html>Consistency in Distributed Systems – Michael Whittaker</a></li><li><a href=https://www.scylladb.com/glossary/consistency-models/>What are Consistency Models? – ScyllaDB</a></li><li><a href=https://www.allthingsdistributed.com/2008/12/eventually_consistent.html>Eventually Consistent - Revisited – All Things Distributed</a></li><li><a href=https://www.baeldung.com/cs/eventual-consistency-vs-strong-eventual-consistency-vs-strong-consistency>Eventual Consistency vs. Strong Eventual Consistency vs. Strong Consistency – Baeldung</a></li></ul><hr></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>