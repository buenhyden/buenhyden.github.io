<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Messaging Systems | hyunyoun's Blog</title><meta name=keywords content="System-Design,System-Components,Messaging-Systems,Event-Driven-Architecture,Asynchronous-Communication,Distributed-Systems,Message-Broker"><meta name=description content="메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Messaging Systems"><meta property="og:description" content="메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-22T13:59:00+00:00"><meta property="article:modified_time" content="2025-04-22T13:59:00+00:00"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="System-Components"><meta property="article:tag" content="Messaging-Systems"><meta property="article:tag" content="Event-Driven-Architecture"><meta property="article:tag" content="Asynchronous-Communication"><meta property="article:tag" content="Distributed-Systems"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Messaging Systems"><meta name=twitter:description content="메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Messaging Systems","item":"https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Messaging Systems","name":"Messaging Systems","description":"메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다.","keywords":["System-Design","System-Components","Messaging-Systems","Event-Driven-Architecture","Asynchronous-Communication","Distributed-Systems","Message-Broker"],"articleBody":"Messaging Systems 메시징 시스템 (Messaging Systems) 은 애플리케이션 또는 서비스 간 메시지를 안전하게 송수신하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 장애 복원력, 실시간 데이터 처리 등 백엔드 시스템의 핵심 요구사항을 충족한다. 대표적으로 메시지 큐, 이벤트 스트리밍 플랫폼, 태스크 큐 등이 있으며, 각각 작업 분산, 실시간 이벤트 처리, 대규모 데이터 파이프라인 등 다양한 시나리오에 활용된다. 현대 분산 시스템과 마이크로서비스 아키텍처에서 메시징 시스템은 필수적이다.\n핵심 개념 메시징 시스템 (Messaging Systems) 은 독립적인 소프트웨어 구성 요소 간의 비동기 통신을 가능하게 하는 인프라이다. 이를 통해 시스템의 결합도를 낮추고, 확장성과 장애 허용성을 향상시킬 수 있다.\n기본 핵심 개념 메시지 (Message): 애플리케이션 간 교환되는 데이터 단위로, 헤더와 바디로 구성되며 메타데이터와 실제 내용을 포함한다. 다양한 형식을 지원한다 (JSON, XML, Protocol Buffers, Avro 등).\n메시지 지향 미들웨어 (MOM): 분산 애플리케이션 간의 메시지 기반 통신을 지원하는 인프라 솔루션이다.\n비동기 메시징 (Asynchronous Messaging): 발신자가 응답을 기다리지 않고 메시지를 전송하는 통신 방식으로, 시스템 결합도를 낮추고 확장성을 향상시킨다.\n이벤트 주도 아키텍처 (Event-Driven Architecture): 시스템 상태 변화를 이벤트로 표현하고, 이벤트를 통해 컴포넌트 간 통신하는 아키텍처 패턴이다.\n생산자 - 소비자 모델 (Producer-Consumer Model): 두 개 이상의 프로세스 (또는 스레드) 가 공유 자원 (버퍼) 을 통해 데이터를 주고받는 대표적인 병행 프로그래밍 패턴으로 둘 사이의 직접적인 연결 없이 느슨한 결합 (Loose Coupling) 유지한다.\n생산자 (Producer): 메시지를 생성하고 전송하는 주체 소비자 (Consumer): 메시지를 수신하고 처리하는 주체 브로커 (Broker): 메시지의 중개자 역할을 담당하는 중앙 구성 요소로, 메시지 저장, 라우팅, 전달을 담당하며, 클라이언트 간 직접적인 연결 필요성을 제거한다.\n메시지 브로커 (Message Broker): 메시지의 송신자와 수신자 사이에서 중개 역할을 하는 소프트웨어 모듈로, 메시지 검증, 변환, 라우팅을 담당한다.\n메시지 큐 (Message Queue): 메시지를 임시 저장하는 저장소로, FIFO 방식으로 메시지를 처리하며 비동기 통신을 가능하게 한다.\n큐와 토픽 (Queues and Topics)\n큐 (Queue): 1:1 통신 모델, 하나의 메시지는 하나의 소비자에게만 전달 토픽 (Topic): 1:N 발행 - 구독 (Pub-Sub) 모델, 하나의 메시지가 여러 소비자에게 전달 이벤트 스트리밍 (Event Streaming): 생산자가 이벤트를 스트림에 게시하면, 여러 소비자가 이를 구독하여 실시간으로 처리하는 모델이다. 주로 실시간 데이터 처리와 분석에 사용된다.\n태스크 큐 (Task Queue): 작업을 큐에 넣고, 워커가 이를 비동기적으로 처리하는 모델이다. 주로 백그라운드 작업 처리에 사용된다.\n심화 핵심 개념 메시지 지속성 (Message Persistence): 시스템 장애 시에도 메시지 손실을 방지하기 위해 메시지를 영구 저장소에 보관하는 기능이다.\n메시지 순서 보장 (Message Ordering): 메시지가 전송된 순서대로 처리되도록 보장하는 메커니즘이다.\n메시지 보장 (Message Guarantees): 메시징 시스템 (예: 메시지 큐, Pub/Sub 등) 에서 메시지가 얼마나 안정적으로 송신자에서 수신자에게 전달되는지를 보장하는 수준이다.\nAt-most-once: 메시지가 최대 한 번 전달됨 (일부 손실 가능) At-least-once: 메시지가 최소 한 번 전달됨 (중복 가능) Exactly-once: 메시지가 정확히 한 번 전달됨 (이상적이나 구현 복잡) 파티셔닝과 샤딩 (Partitioning and Sharding): 대용량 데이터 처리를 위한 분할 기법으로, 수평적 확장성 (Horizontal Scalability) 을 지원한다.\n메시지 오프셋과 순서 (Message Offset and Ordering): 메시지의 위치와 순서 관리 메커니즘으로, 순차적 처리와 병렬 처리 간의 균형을 가능하게 한다.\n장애 허용 (Fault Tolerance): 시스템 일부 장애 시에도 전체 기능 유지하게 한다.\n백프레셔 (Backpressure): 소비자의 처리 속도가 생산자의 전송 속도보다 느릴 때 발생하는 압력을 관리하는 기법이다.\n실무 구현 요소 Connection Pool Management: 효율적인 연결 관리 Message Serialization/Deserialization: 메시지 직렬화 및 역직렬화 Dead Letter Queue (DLQ): 처리 실패 메시지 관리 Circuit Breaker Pattern: 장애 전파 방지 Monitoring and Alerting: 성능 모니터링 및 알람 주요 개념 개념 설명 Queue 메시지를 순서대로 저장하고 소비자가 꺼내는 구조 Topic 메시지를 발행/구독하는 구조, 다수의 소비자에게 브로드캐스팅 가능 Producer 메시지를 생성하여 시스템에 전달하는 역할 Consumer 메시지를 수신하고 처리하는 역할 Broker 메시지를 수신하고 큐 또는 토픽에 적절히 저장한 뒤 소비자에게 전달 Message 전송되는 데이터 단위, 헤더와 바디로 구성됨 Partition 메시지를 병렬로 처리하기 위한 논리적 분할 단위 (Kafka 등) 배경 (Background) 발전 배경 과거에는 시스템 간 통신이 동기 방식 (예: HTTP 요청 - 응답) 에 의존해 있었고, 이는 시스템 확장성 및 유연성에 제약을 주었다. 비동기 메시징 시스템은 다양한 컴포넌트가 독립적으로 작동할 수 있게 하여, 마이크로서비스 아키텍처와 실시간 처리의 핵심 인프라로 발전하게 되었다.\n주요 전환점 대용량 데이터 스트리밍 필요성 증대 마이크로서비스 (MSA) 및 이벤트 기반 아키텍처의 확산 클라우드 네이티브 환경에서의 동적 확장 요구 목적 및 필요성 구분 설명 느슨한 결합 (Loose Coupling) 구성 요소 간 직접 의존 제거, 독립적인 개발·배포·확장 가능 비동기 통신 (Asynchronous) 생산자가 응답을 기다리지 않고 메시지 전송, 처리량 증가 및 응답 시간 개선 확장성 (Scalability) 소비자 수 증가만으로 병렬 처리 가능, 수평 확장을 통한 성능 향상 시간적 분리 (Temporal Decoupling) 생산자·소비자의 시간 독립성 보장, 장애 시에도 메시지 유실 없이 재처리 가능 장애 복구 (Fault Recovery) 메시지 영속성으로 장애 시에도 데이터 복구 가능, 시스템 복원력 향상 부하 완화 (Load Buffering) 큐를 통해 요청 폭주 시 백엔드 보호, 소비자 속도에 맞춰 안정적인 처리 실시간 처리 (Real-Time Processing) 스트리밍 데이터 실시간 처리 가능, 로그 분석·알림 시스템 등 적용 유연한 통신 패턴 지원 Pub-Sub, Request-Reply 등 다양한 통신 방식 지원 운영 유연성 (Operational Flexibility) 다양한 포맷/프로토콜 지원, 메시지 재처리·지연처리·필터링 등 기능 활용 가능 주요 기능 및 역할 (Key Functions and Roles) 기능/역할 설명 메시지 송수신 (Message Exchange) 생산자 (Producer) 와 소비자 (Consumer) 간 안정적인 메시지 전달 수행 큐잉 (Queueing) 메시지를 임시 저장하여 소비자와의 처리 속도 차이를 완충 라우팅 (Routing) 규칙 기반으로 메시지를 적절한 소비자나 큐/토픽으로 전달 (콘텐츠 기반, 헤더 기반 등) 메시지 변환 (Transformation) 데이터 포맷 및 프로토콜 변환을 통해 시스템 간 호환성 보장 메시지 필터링 (Filtering) 조건에 따라 필요한 메시지만 소비자에게 전달하여 처리 효율성 향상 스토어 - 포워드 (Store and Forward) 네트워크 지연이나 장애 시 메시지를 저장 후 재전송 가능 전송 보장 (Delivery Guarantee) At-most-once, At-least-once, Exactly-once 수준으로 메시지 전달 품질 보장 메시지 지속성 (Persistence) 장애 발생 시 데이터 손실 방지를 위한 디스크 기반 영속 저장 순서 보장 (Ordering) FIFO 또는 파티션 기반 처리 순서 보장 부하 분산 (Load Balancing) 소비자 그룹 간 메시지 분산으로 시스템 부하 균등화 흐름 제어 (Flow Control) 소비자 처리 속도에 따라 생산자 전송 속도 조절, 시스템 안정성 유지 우선순위 처리 (Prioritization) 중요도에 따른 메시지 처리 순서 결정 (예: 알람, 금융 트랜잭션 등 우선 처리) 트랜잭션 처리 (Transactional Support) 메시지 처리 과정의 원자성 보장 (commit/rollback 지원) 보안 및 접근 제어 (Security \u0026 ACL) 인증, 암호화, 권한 제어를 통한 안전한 메시지 송수신 보장 모니터링 및 로깅 (Monitoring \u0026 Logging) 메시지 흐름, 처리 지연, 실패 이벤트 등을 추적하여 운영 가시성 확보 장애 복구 (Fault Recovery) 오류 발생 시 재시도, DLQ(Dead Letter Queue) 등으로 장애 복구 지원 특징 graph TB A[메시징 시스템 특징] --\u003e B[비동기 통신] A --\u003e C[느슨한 결합] A --\u003e D[확장성] A --\u003e E[내결함성] B --\u003e B1[Non-blocking I/O] B --\u003e B2[Event-driven Processing] C --\u003e C1[Service Decoupling] C --\u003e C2[Protocol Independence] D --\u003e D1[Horizontal Scaling] D --\u003e D2[Load Distribution] E --\u003e E1[Message Persistence] E --\u003e E2[Failure Recovery] 특징 항목 설명 비동기 통신 (Asynchronous I/O) 메시지를 큐에 저장하고 응답 없이 처리, 시스템 부하 분산 및 응답 시간 개선 느슨한 결합 (Loose Coupling) 서비스 간 직접 의존 최소화, 독립적인 배포·확장·유지보수 가능 수평 확장성 (Horizontal Scalability) 파티셔닝 및 클러스터링을 통한 노드 추가 확장, 대규모 트래픽 대응 내결함성 (Fault Tolerance) 메시지 영속성, 장애 자동 복구, DLQ 등으로 장애 시 데이터 유실 방지 다양한 통신 패턴 지원 Point-to-Point, Publish-Subscribe, Request-Reply 등 유연한 메시징 패턴 지원 신뢰성 설정 가능 (Message Guarantee) At-most-once, At-least-once, Exactly-once 옵션으로 전달 신뢰성 조절 가능 트랜잭션 지원 (Transactional Messaging) 메시지 그룹을 원자적으로 처리하여 데이터 일관성 유지 분산 아키텍처 (Distributed Architecture) 복수 노드 기반 구성으로 단일 장애 지점 (SPOF) 제거, 고가용성 확보 프로토콜 독립성 (Protocol Independence) 다양한 시스템 간 AMQP, MQTT, STOMP 등 이기종 프로토콜 호환 가능 이벤트 기반 처리 (Event-Driven Processing) 이벤트 트리거 기반의 반응형 처리 구조, 실시간 분석 및 반응 시스템 구축에 적합 핵심 원칙 (Core Principles) 핵심 원칙 설명 느슨한 결합 (Loose Coupling) 서비스 간 직접 의존 최소화, 독립 배포 및 유지보수 가능 비동기 통신 우선 (Asynchrony First) 동기 통신 최소화, 처리 병목 제거 및 시스템 탄력성 확보 메시지 중심 설계 (Message-Centric Design) 메시지를 상호작용의 기본 단위로 활용, 명확한 계약 및 표준 포맷 채택 확장성 우선 (Scalability First) 파티션, 컨슈머 그룹 등을 고려한 수평 확장 기반 설계 장애 허용 설계 (Fault-Tolerant Design) 일부 실패에도 시스템 전체가 중단되지 않도록 복원 및 재시도 설계 적용 메시지 내구성 (Message Durability) 메시지 저장을 통한 재시작·복구 가능, 장애 시에도 데이터 손실 방지 멱등성 (Idempotency) 중복 메시지 수신 시에도 동일한 처리 결과 보장, 중복 방지 메시지 불변성 (Message Immutability) 메시지는 생성 후 변경 불가, 추적성 및 데이터 무결성 확보 정확한 전달 보장 (Exactly-once Delivery) 중복 없이 메시지를 단 한 번 전달 (구현은 복잡하나 이상적) 중복 수신 허용/방지 QoS 수준 설정에 따라 허용 또는 필터링 가능 (At-least-once or Exactly-once 선택) 독립 실행성 (Component Autonomy) 송신자와 수신자가 서로의 상태와 무관하게 작동 가능 최종 일관성 (Eventual Consistency) 메시징 기반 분산 시스템에서 데이터 동기화 지연 허용 주요 원리 **생산자 (Producer)**가 메시지를 브로커/큐/스트림에 전송 브로커/미들웨어가 메시지를 저장, 라우팅, 변환, 전달 **소비자 (Consumer/Subscriber/Worker)**가 메시지를 수신 및 처리 메시지 보장, 중복 방지, 오류 처리, 재시도 등 내부 로직 적용 graph LR A[Producer] --\u003e B[Message Broker] B --\u003e C[Queue/Topic] C --\u003e D[Consumer 1] C --\u003e E[Consumer 2] C --\u003e F[Consumer N] B --\u003e G[Dead Letter Queue] B --\u003e H[Message Store] 메시징 시스템의 주요 원리는 비동기 메시지 전달 패턴에 기반한다. 프로듀서가 메시지를 생성하여 브로커에 전달하면, 브로커는 이를 적절한 큐나 토픽으로 라우팅하고, 컨슈머들이 각자의 속도로 메시지를 처리한다.\n발행 - 구독 패턴 (Publish-Subscribe Pattern):\nsequenceDiagram participant P as Producer participant B as Message Broker participant C1 as Consumer 1 participant C2 as Consumer 2 P-\u003e\u003eB: Publish Message B-\u003e\u003eC1: Deliver Message B-\u003e\u003eC2: Deliver Message C1-\u003e\u003eB: Acknowledge C2-\u003e\u003eB: Acknowledge 포인트 - 투 - 포인트 패턴 (Point-to-Point Pattern):\nsequenceDiagram participant P as Producer participant Q as Message Queue participant C as Consumer P-\u003e\u003eQ: Send Message Q-\u003e\u003eC: Deliver Message C-\u003e\u003eQ: Acknowledge Q-\u003e\u003eQ: Remove Message 작동 원리 메시징 시스템의 작동 원리는 메시지의 생성, 저장, 전달, 처리의 4 단계로 구성된다. 각 단계에서 적절한 확인 메커니즘을 통해 메시지 전달의 신뢰성을 보장한다.\n단계 설명 1. 메시지 생성 및 발행 - 생산자가 메시지를 생성\n- 메시지 포맷 및 메타데이터 설정\n- 브로커에 전송 2. 메시지 수신 및 저장 - 브로커가 메시지 수신 및 유효성 검사\n- 큐 또는 토픽에 저장\n- 필요 시 디스크에 지속성 저장 3. 메시지 처리 및 전달 - 소비자가 메시지 요청 또는 구독\n- 브로커가 메시지를 전달\n- 소비자가 메시지 처리 후 확인 (Ack) 4. 흐름 제어 및 장애 처리 - 소비자 속도에 따라 메시지 전송 조절\n- 실패 메시지 재시도 또는 DLQ 이동\n- 오류 로깅 및 모니터링 수행 sequenceDiagram participant P as Producer participant B as Broker participant Q as Queue participant C as Consumer P-\u003e\u003eB: Send Message B-\u003e\u003eQ: Store Message Q--\u003e\u003eB: Acknowledge Storage B--\u003e\u003eP: Confirm Receipt C-\u003e\u003eQ: Poll/Subscribe Q-\u003e\u003eC: Deliver Message C-\u003e\u003eQ: Acknowledge Processing Q-\u003e\u003eB: Remove Message 구조 및 아키텍처 메시징 시스템은 다음과 같은 계층과 구성으로 이루어진다.\n구조는 프로듀서 - 브로커 - 컨슈머 중심의 데이터 흐름 기반이며, 고가용성 및 확장성을 고려한 클러스터 기반 분산 구조를 채택한다.\n메시징 시스템의 전체 아키텍처는 다음과 같이 구성된다:\ngraph TB subgraph \"Application Layer\" A1[Application 1] A2[Application 2] A3[Application 3] end subgraph \"Client Layer\" P1[Producer Client] P2[Producer Client] C1[Consumer Client] C2[Consumer Client] end subgraph \"Messaging Infrastructure\" LB[Load Balancer] subgraph \"Broker Cluster\" B1[Broker 1] B2[Broker 2] B3[Broker 3] end subgraph \"Storage Layer\" MS[Message Store] DLQ[Dead Letter Queue] end end subgraph \"Management \u0026 Monitoring\" MM[Management Console] MON[Monitoring System] end A1 --\u003e P1 A2 --\u003e P2 A3 --\u003e C1 A3 --\u003e C2 P1 --\u003e LB P2 --\u003e LB LB --\u003e B1 LB --\u003e B2 LB --\u003e B3 B1 --\u003e C1 B2 --\u003e C2 B1 --\u003e MS B2 --\u003e MS B3 --\u003e MS B1 --\u003e DLQ B2 --\u003e DLQ B3 --\u003e DLQ MM --\u003e B1 MM --\u003e B2 MM --\u003e B3 MON --\u003e B1 MON --\u003e B2 MON --\u003e B3 구성요소 분류 구성 요소 기능 역할 주요 특징 필수 Message Broker 메시지 수신, 저장, 라우팅, 전달 Producer 와 Consumer 사이의 중개자 메시지 변환, 프로토콜 번역, 로드 밸런싱 Message Queue 메시지 임시 저장, 순서 보장 FIFO 방식으로 메시지 처리 백프레셔 제어, 메시지 지속성 Producer (Publisher) 메시지 생성 및 전송 데이터를 메시지로 변환하여 전송 직렬화, 파티셔닝 키 설정 Consumer (Subscriber) 메시지 수신 및 처리 비즈니스 로직 실행 역직렬화, 처리 확인 (Ack/Nack) 선택 Load Balancer 트래픽 분산, 고가용성 확보 브로커 인스턴스 간 부하 분산 헬스 체크, 장애 감지 Message Store 메시지 지속성 보장 디스크 기반 메시지 영속 저장 복제, 백업, 압축 Dead Letter Queue 처리 실패 메시지 분리 및 저장 재시도 불가 메시지 수집 및 분석 재시도 정책, 경고/알림 기능 Management Console 시스템 운영/모니터링 도구 운영자에게 시스템 상태와 설정을 제공 메트릭 시각화, 설정 관리, 모니터링 대시보드 스키마 레지스트리 (Schema Registry) 메시지 스키마 버전 관리 데이터 호환성 보장 스키마 진화 지원 커넥터 (Connectors) 외부 시스템 연동 데이터 파이프라인 구축 플러그인 아키텍처 메시징 시스템 설계 및 구현 전략 메시징 모델 기반 처리 방식 유형 정의 구성 요소 주요 목적 및 특징 대표 시스템 / 활용 예시 메시지 큐 생산자와 소비자 간의 비동기 통신을 위한 큐 기반 메시징 시스템 생산자, 메시지 큐, 소비자 - 작업 분산, 순차적 처리\n- 신뢰성 있는 비동기 처리\n- 백프레셔 조절 가능 RabbitMQ: 이메일 전송 작업 큐잉\nSQS, ActiveMQ 이벤트 스트리밍 실시간 이벤트를 스트림 형태로 처리하며 다수 소비자에게 브로드캐스트하는 모델 생산자, 토픽, 소비자 - 실시간 이벤트 수집 및 분석\n- 과거 이벤트 재처리 가능\n- 높은 처리량과 확장성 Kafka: IoT 센서 데이터 실시간 분석\nPulsar, Kinesis 태스크 큐 ** 작업 (Task)** 을 큐에 저장하고 워커가 비동기적으로 처리하는 백그라운드 작업 전용 구조 생산자, 작업 큐, 워커 - 장시간 처리 작업 지원\n- 작업 스케줄링 및 병렬 워커 처리\n- 실패 시 재시도 가능 Celery: 이미지 처리\nSidekiq, RQ 하이브리드 메시지 큐 + 이벤트 스트리밍의 복합적 구조, 스트림과 큐를 동시에 운용 생산자, 큐/토픽, 소비자/워커 - 복합 워크플로우 구성\n- 유연한 데이터 흐름 설계\n- 처리 방식 선택 가능 Kafka (Queue+Topic), AutoMQ 메시징 패턴 (Messaging Patterns) 패턴 유형 정의 구성 요소 사용 목적 실무 예시 점대점 (Point-to-Point) 하나의 메시지를 단 하나의 소비자가 처리하는 1:1 통신 모델 프로듀서 → 메시지 큐 → 단일 컨슈머 신뢰성 있는 순차 처리, 부하 분산 주문 처리 시스템 (주문 생성 → 결제 처리) 발행 - 구독 (Publish-Subscribe) 발행자가 메시지를 여러 구독자에게 동시에 전달하는 1:N 모델 퍼블리셔 → 토픽 → 여러 구독자 느슨한 결합, 이벤트 브로드캐스트 재고 이벤트 → 주문, 분석, 알림 서비스 요청 - 응답 (Request-Reply) 요청 - 응답을 비동기 메시징으로 구현한 양방향 통신 모델 요청 큐 + 응답 큐 + 상관관계 ID 비동기 RPC 구현, 요청 - 응답 추적 가격 조회 요청 ↔ 계산 결과 응답 경쟁 소비자 (Competing Consumers) 여러 소비자가 하나의 큐에서 메시지를 경쟁적으로 소비하는 모델 단일 큐 → 병렬 컨슈머 (워커 풀) 수평 확장, 처리량 향상, 부하 분산 이미지 처리 큐 → 여러 워커가 병렬 처리 메시지 라우팅 (Message Routing) 메시지의 내용이나 속성에 따라 적절한 큐 또는 컨슈머로 전달하는 패턴 라우터 → 조건별 큐 → 특화된 컨슈머 메시지 유형 기반 분기 처리, 로직 분리 문의 메시지 → 기술/결제/일반 큐 자동 분류 고급 메시징 전략 및 신뢰성 보장 기술 전략/기술 정의 구현 기법 또는 메커니즘 적용 시나리오 예시 Exactly-once 처리 메시지를 중복 없이 단 한 번만 처리하여 정확성 보장 - Kafka 트랜잭션\n- Idempotent Producer + Offset Commit 결제 시스템 중복 결제 방지, 재고 중복 차감 방지 메시지 리플레이 (Replay) 저장된 메시지를 재소비하여 과거 이벤트를 재처리 - Kafka 오프셋 수동 리셋 및 재소비\n- 컨슈머 그룹 리플레이 전략 파이프라인 장애 복구, 데이터 정합성 검증 멀티 브로커 클러스터 구성 장애 발생 시에도 메시징 서비스를 유지하기 위한 고가용성 구조 설계 - Kafka 브로커 다중화\n- Zookeeper 또는 KRaft 기반 리더 선출 고부하 환경에서의 메시지 유실 방지, 무중단 운영 내구성 메시징 (Durable Messaging) 시스템 장애에도 메시지를 영구 저장하여 복구 가능한 메시징 구조 - 디스크 기반 로그 저장\n- 메시지 복제 및 체크포인트 유지 금융 거래 기록, 감사 로그, 미션 크리티컬 이벤트 처리 구현 기법 구성 요소 정의 및 목적 주요 구성 예시 / 특징 메시지 직렬화 (Message Serialization) 데이터를 바이트 스트림으로 변환하여 플랫폼 간 전송 가능하게 함 Avro, Protocol Buffers, JSON { \"eventType\": \"OrderCreated\", … } 와 같은 JSON 메시지 예시 메시지 파티셔닝 (Message Partitioning) 메시지를 논리적으로 분할하여 병렬 처리 및 시스템 확장성 향상 파티션 키, 해시 함수, 로드 밸런서 고객 ID 기반 파티셔닝, 파티션 수: 3~12, 복제 계수: 3 (권장) 컨슈머 그룹 (Consumer Groups) 하나의 토픽을 여러 소비자가 병렬로 처리하여 처리량 증가 및 장애 복구 용이 그룹 ID, 컨슈머 인스턴스, 코디네이터 주문 처리 시스템에서 여러 컨슈머 인스턴스가 병렬 처리 장점 항목 설명 확장성 (Scalability) 파티셔닝 및 클러스터링을 통해 수평 확장 가능, 메시지 처리량 증가 및 유연한 리소스 확장 대응 내결함성 (Fault Tolerance) 메시지 지속성 및 복제를 통한 장애 시 데이터 유실 방지, 재처리 및 DLQ 기반 복구 가능 비동기 처리 (Asynchronous Processing) 송신자 - 수신자 간 비동기 통신으로 지연 감소 및 시스템 병목 해소, 고성능 처리 가능 모듈 간 느슨한 결합 (Loose Coupling) 메시지 브로커를 통한 중개로 서비스 간 직접 의존 제거, 독립적 개발·배포·운영 가능 유연한 통신 패턴 지원 (Flexible Messaging Patterns) Point-to-Point, Pub/Sub, Fan-out 등 다양한 구조 지원으로 복잡한 요구 대응 가능 신뢰성 (Reliability) QoS 수준 설정 (At-most-once, At-least-once, Exactly-once) 을 통해 메시지 손실/중복 방지 가능 모니터링 용이성 (Observability) 메트릭, 로깅, 추적 등을 통해 시스템 상태를 실시간으로 모니터링하고 문제를 조기에 감지 가능 유연성 (Interoperability) 다양한 메시지 포맷과 프로토콜 (AMQP, MQTT, Kafka 등) 지원으로 이기종 시스템 간 통합 가능 단점과 문제점 단점 항목 설명 해결 방안 복잡성 증가 브로커 설정, 분산 처리, 클러스터 구성 등으로 인해 시스템 구조 복잡도 상승 모니터링 도구 (Kafka Manager 등) 도입, 관리 자동화 처리 지연 브로커를 거치는 네트워크 I/O 및 큐 적체로 인한 지연 발생 컨슈머 스케일 아웃, 백프레셔 (Backpressure) 메커니즘 적용 운영 오버헤드 브로커 운영, 파티션 관리, 장애 대응 등의 지속적 관리 필요 관리형 서비스 활용, 운영 문서화 및 자동화 도구 활용 단일 장애점 (SPOF) 브로커 장애 시 전체 메시징 흐름 중단 가능성 존재 브로커 이중화 및 클러스터 구성, 자동 장애 복구 시스템 구성 메시지 순서 보장 어려움 분산 처리 시 메시지 순서가 뒤섞일 수 있음 파티션 키 고정, 순서 보장 전용 토픽 사용, 단일 파티션 처리 문제점 문제 항목 원인 영향 해결 방법 및 기법 메시지 손실 Ack 누락, 브로커 장애, 네트워크 불안정 데이터 유실, 트랜잭션 오류 메시지 영속성 설정, 재시도 메커니즘, DLQ(Dead Letter Queue) 구성 중복 메시지 수신 네트워크 재전송, 컨슈머 재시작 중복 데이터 처리, 비즈니스 로직 오작동 멱등성 보장 (Idempotency), 중복 필터링 로직 구현 백프레셔 (Backpressure) 컨슈머 처리 속도 저하, 메시지 급증 메모리 부족, 처리 지연, 시스템 성능 저하 플로우 제어, 동적 컨슈머 스케일링, 쓰로틀링 적용 메시지 순서 오류 멀티 파티션 처리, 병렬 소비 데이터 불일치, 이벤트 순서 오류 파티션 키 설계, 단일 파티션 처리, 순서 보장 큐 활용 컨슈머 과부하 소비자 수 부족, 메시지 급증, 병목 발생 큐 적체, 메시지 지연, 처리 실패 컨슈머 그룹 확장, 로드밸런싱 적용 분류 기준에 따른 종류 및 유형 분류 기준 유형 특징 및 설명 대표 솔루션 전달 모델 Point-to-Point (점대점) 하나의 메시지가 하나의 소비자에게만 전달 (큐 기반) RabbitMQ, ActiveMQ Publish-Subscribe (발행 - 구독) 하나의 메시지를 여러 소비자가 구독 (토픽 기반) Kafka, MQTT, Apache Pulsar 메시지 저장 방식 In-Memory (인메모리) 메모리에 저장되어 빠른 처리 가능, 재시작 시 손실 가능 Redis Pub/Sub, ZeroMQ Persistent (영구 저장) 디스크에 저장되어 내구성 보장, 안정성 높음 Kafka, RabbitMQ (Durable 옵션) 배포 아키텍처 중앙 집중식 (Centralized) 단일 또는 소수 브로커 사용, 관리 용이하나 단일 장애점 위험 존재 RabbitMQ, ActiveMQ 분산식 (Distributed) 다중 브로커 기반, 고가용성 및 수평 확장에 유리 Apache Kafka, Pulsar, NATS 통신 프로토콜 AMQP 고급 메시징 기능, 라우팅 및 트랜잭션 지원 RabbitMQ, ActiveMQ MQTT 경량 프로토콜, IoT 및 저대역폭 환경에 적합 Mosquitto, HiveMQ Kafka Protocol 로그 기반 고성능 전송, 스트리밍 최적화 Apache Kafka, Redpanda STOMP 텍스트 기반, 다양한 언어 및 플랫폼과의 호환성 ActiveMQ, RabbitMQ 사용 목적 메시지 큐 (Message Queue) 작업 분배, 백그라운드 작업 처리, 비동기 통신 RabbitMQ, Amazon SQS, ActiveMQ 이벤트 스트리밍 (Event Streaming) 이벤트 로그 저장 및 실시간 분석, 대규모 데이터 스트림 처리 Apache Kafka, Pulsar 태스크 큐 (Task Queue) 분산 작업 스케줄링 및 실행, 비동기 워크플로우 처리 Celery, Sidekiq QoS 수준 At-most-once 최대 1 회 전달, 손실 가능성 존재 Redis Pub/Sub At-least-once 최소 1 회 전달, 중복 가능 RabbitMQ, Kafka (기본 설정) Exactly-once 정확히 1 회 전달, 가장 높은 신뢰성 (구현 복잡) Kafka (트랜잭션), Pulsar 메시지 순서 FIFO (First-In-First-Out) 메시지 순서 보장 Amazon SQS FIFO, Kafka Non-FIFO 순서 미보장, 고성능 처리에 적합 RabbitMQ (기본), Standard SQS 배포 형태 온프레미스 (On-Premises) 자체 인프라에서 운영 RabbitMQ, Kafka 클라우드 관리형 (Managed Cloud) SaaS 기반 운영, 유지보수 최소화 Amazon SQS, Google Pub/Sub 메시지 큐 vs. 이벤트 스트리밍 vs. 태스크 큐 항목 메시지 큐 (Message Queue) 이벤트 스트리밍 (Event Streaming) 태스크 큐 (Task Queue) 구조 큐 기반 아키텍처, 임시 저장 로그 기반 아키텍처, 영구적 저장 작업 중심 아키텍처, 작업 명세 및 결과 저장 통신 모델 Point-to-Point Publish/Subscribe Point-to-Point 주요 목적 서비스 간 비동기 통신, 버퍼링, 부하 분산 실시간 데이터 스트림 처리, 이벤트 기반 아키텍처 구축 백그라운드 작업, 장기 실행 작업 처리 데이터 모델 임시 메시지, 전달 후 제거 영구적 로그, 시간 순서 이벤트 작업 명세 및 상태 소비 모델 큐에서 메시지 제거 (소비 시) 구독자가 로그의 현재 위치 관리 작업 완료 시 큐에서 제거 메시지 소비 한 소비자가 메시지를 소비 여러 소비자가 메시지를 구독 한 소비자가 작업을 처리 메시지 보존 소비 후 삭제 일정 기간 동안 보존 작업 완료 후 삭제 재생 일반적으로 불가능 (소비 시 제거) 이전 이벤트 재생 가능 (위치 재설정) 일반적으로 불가능 (작업 완료 시 제거) 처리 담당 메시지 소비자 구독자의 선택 (데이터 소비만) 워커 프로세스 주요 사용 사례 작업 분산, 비동기 처리 실시간 데이터 처리, 이벤트 분석 백그라운드 작업 처리 대표 제품 RabbitMQ, ActiveMQ, IBM MQ Kafka, Pulsar, Kinesis Celery, Sidekiq, Resque 특징 - 다양한 라우팅 패턴\n- 우선순위 지정\n- 메시지 TTL\n- 트랜잭션 지원 - 이벤트 재생/시간 여행\n- 로그 압축/컴팩션\n- 고처리량 병렬 처리\n- 지속 가능 로그 저장 - 상태 추적\n- 결과 저장\n- 재시도 로직\n- 우선순위/의존성 지원 적합한 사용 사례 - 서비스 간 비동기 통신\n- 마이크로서비스 통합\n- 부하 분산 및 버퍼링\n- 서비스 디커플링\n- 작업 처리 보장 - 실시간 데이터 분석\n- 이벤트 소싱 아키텍처\n- 시계열 데이터 처리\n- 로그 수집 및 처리 CDC (변경 데이터 캡처) - 백그라운드 작업 처리\n- 리소스 집약적 작업\n- 주기적 작업 스케줄링\n- 웹 요청 외부 처리\n- 분산 작업 실행 부적합한 사용 사례 - 대용량 데이터 스트리밍\n- 장기 데이터 보존\n- 이벤트 재생 필요 시\n- 이벤트 소싱 아키텍처 - 단순 작업 큐\n- 단일 소비자 시나리오\n- 요청 - 응답 패턴 (주요 용도)\n- 작은 규모의 시스템 - 서비스 간 일반 통신\n- 이벤트 기반 시스템\n- 대용량 데이터 스트리밍\n- 실시간 처리 요구사항 아키텍처 및 작동 방식 비교 메시지 큐 1 2 3 4 5 6 7 8 9 10 11 12 +------------+ +------------+ +------------+ | | | | | | | 생산자(들) | -\u003e | 큐(들) | -\u003e | 소비자(들) | | | | | | | +------------+ +------------+ +------------+ | v +-------------+ | | | 임시 저장소 | | | +-------------+ 작동 원리:\n메시지가 생산자에 의해 큐에 추가됨 큐는 메시지를 FIFO 방식으로 저장 (일반적으로) 소비자가 큐에서 메시지를 가져와 처리 소비 확인 후 큐에서 메시지 제거 메시지는 소비될 때까지만 저장 이벤트 스트리밍 플랫폼 1 2 3 4 5 6 7 8 9 10 11 12 +------------+ +----------------+ +------------+ | | | | | | | 생산자(들) | -\u003e | 로그/파티션(들) | -\u003e | 소비자(들) | | | | | | | +------------+ +----------------+ +------------+ | v +-------------+ | | | 스토리지 계층 | | | +-------------+ 작동 원리:\n이벤트가 파티션된 로그에 추가됨 이벤트는 시간 순서대로 저장 (로그 구조) 소비자는 로그의 특정 위치 (오프셋) 에서 읽기 시작 이벤트는 영구적으로 저장 (구성된 보존 기간 동안) 소비자는 자신의 오프셋을 관리하고 언제든 재설정 가능 태스크 큐 1 2 3 4 5 6 7 8 9 10 11 12 +------------+ +------------+ +------------+ | | | | | | | 태스크 생성자| -\u003e | 태스크 큐(들)| -\u003e | 워커(들) | | | | | | | +------------+ +------------+ +------------+ | | v v +-------------+ +-------------+ | | | | | 태스크 저장소 | | 결과 저장소 | | | | | +-------------+ +-------------+ 작동 원리:\n응용 프로그램이 태스크 생성 및 큐에 제출 태스크는 함수/메서드 호출, 인자, 실행 컨텍스트 포함 워커 프로세스가 태스크를 가져와 실행 실행 결과 저장 및 상태 업데이트 태스크 메타데이터 및 결과는 별도 저장소에 유지 실무 사용 예시 카테고리 적용 사례 사용된 메시징 시스템 함께 사용되는 기술 기대 효과 전자상거래 주문 처리 파이프라인 Kafka, RabbitMQ Spring Boot, API Gateway 비동기 처리, 서비스 디커플링, 트랜잭션 안정성 강화 금융 서비스 실시간 거래 처리 Kafka, IBM MQ Kafka Streams, OAuth 인증 고가용성, 정확히 한 번 전달, 보안성 및 신뢰성 보장 IoT 플랫폼 센서 데이터 수집 및 처리 MQTT, NATS, Kafka InfluxDB, Grafana, Edge Devices 저지연, 실시간 반응, 확장성 높은 스트리밍 처리 모바일 앱 푸시 알림 전송 RabbitMQ, Firebase Cloud Messaging WebSocket, Firebase SDK 실시간 사용자 피드백 제공, 채널별 구독/우선순위 관리 소셜 미디어 활동 피드 생성 Kafka, Redis Streams Event Sourcing, CQRS 대규모 팬아웃, 이벤트 기반 반응, 시스템 반응성 증가 로그 분석 및 모니터링 로그 수집 및 실시간 분석 Kafka, Fluentd Elasticsearch, Kibana, Spark Streaming 대용량 로그 스트림 처리, 실시간 인사이트 확보 게임 서버 멀티플레이어 통신 NATS, Redis Pub/Sub Unity, WebRTC 초저지연 메시징, 이벤트 브로드캐스트, 동시 사용자 대응 헬스케어 환자 모니터링 및 경고 MQTT, Kafka Health IoT Devices, Secure Gateway 실시간 알림, 보안성 높은 통신, 지속적 데이터 스트림 확보 콘텐츠 워크플로우 미디어 변환 및 파일 처리 Kafka, Celery Python Worker, Redis, FFmpeg 비동기 작업 분산 처리, 상태 추적, 작업 실패 복구 데이터 파이프라인 실시간 스트리밍 + 배치 처리 Kafka, Airflow Spark, Hadoop, PostgreSQL 스트림 + 배치 통합 분석, 데이터 품질 유지, ETL 자동화 서버리스 아키텍처 이벤트 트리거 워크플로우 AWS SQS, Google Pub/Sub AWS Lambda, GCP Cloud Functions 확장성 우수, 비용 효율적, 실패 내성 높은 이벤트 처리 마이크로서비스 통신 서비스 간 메시지 교환 RabbitMQ, Kafka Docker, Kubernetes, Service Mesh (Istio 등) 서비스 간 느슨한 결합, 독립 배포, 트래픽 부하 완화 알림/통지 시스템 이메일, SMS, 앱 알림 SNS, Pub/Sub, RabbitMQ SMTP, Firebase, Twilio API 다중 채널 메시지 전송, 사용자 반응성 향상, 우선순위 기반 분배 활용 사례 사례 1: Kafka 기반 실시간 스트리밍 설계 예제 실시간으로 사용자 활동 로그를 수집하여 분석하는 Real-Time User Analytics System\n시스템 구성 요소\n구성 요소 설명 Web App 사용자 이벤트 발생 (ex: 클릭, 뷰, 구매 등) Kafka Topic 이벤트 수집용 토픽 (ex: user-events) Kafka Producer 사용자 이벤트를 Kafka 로 전송 Kafka Broker Cluster 메시지를 수집, 저장, 라우팅 Kafka Consumer Group Flink 또는 Kafka Streams 로 데이터 실시간 처리 ClickHouse / Druid 분석용 DB 로 수집된 이벤트를 저장 Grafana 사용자 이벤트를 시각화하는 대시보드 데이터 흐름 (Workflow)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [Web App] | | (JSON 로그 전송) v [Kafka Producer] | | (user-events 토픽으로 게시) v [Kafka Broker Cluster] --\u003e [Kafka Topic] | --------------------------- | | [Flink Processor] [Kafka Consumer - Archiver] | | [ClickHouse] [S3 Storage] 고려사항:\nPartition Key: user_id 기준으로 파티셔닝하여 순서 보장 Retention Policy: 7 일 유지 후 만료 Exactly-Once 처리: Kafka + Flink 의 Checkpointing 으로 보장 사례 2: 전자상거래 주문 처리 시스템 시스템 구성\ngraph TB subgraph \"Frontend\" WEB[Web Application] MOBILE[Mobile App] end subgraph \"API Gateway\" GW[API Gateway] end subgraph \"Microservices\" ORDER[Order Service] PAYMENT[Payment Service] INVENTORY[Inventory Service] SHIPPING[Shipping Service] NOTIFICATION[Notification Service] end subgraph \"Messaging Infrastructure\" KAFKA[Apache Kafka] subgraph \"Topics\" ORDER_TOPIC[order-events] PAYMENT_TOPIC[payment-events] SHIPPING_TOPIC[shipping-events] end end subgraph \"Data Layer\" ORDER_DB[(Order DB)] PAYMENT_DB[(Payment DB)] INVENTORY_DB[(Inventory DB)] end WEB --\u003e GW MOBILE --\u003e GW GW --\u003e ORDER ORDER --\u003e KAFKA KAFKA --\u003e ORDER_TOPIC KAFKA --\u003e PAYMENT_TOPIC KAFKA --\u003e SHIPPING_TOPIC ORDER_TOPIC --\u003e PAYMENT ORDER_TOPIC --\u003e INVENTORY PAYMENT_TOPIC --\u003e SHIPPING SHIPPING_TOPIC --\u003e NOTIFICATION ORDER --\u003e ORDER_DB PAYMENT --\u003e PAYMENT_DB INVENTORY --\u003e INVENTORY_DB Workflow:\n주문 접수: 고객이 웹/모바일 앱을 통해 주문 생성 주문 이벤트 발행: Order Service 가 ‘order-created’ 이벤트를 order-events 토픽에 발행 재고 확인: Inventory Service 가 이벤트를 수신하여 재고 확인 후 ‘inventory-reserved’ 이벤트 발행 결제 처리: Payment Service 가 결제 처리 후 ‘payment-completed’ 이벤트를 payment-events 토픽에 발행 배송 처리: Shipping Service 가 결제 완료 이벤트를 수신하여 배송 준비 및 ‘shipping-started’ 이벤트 발행 알림 전송: Notification Service 가 각 단계별 이벤트를 수신하여 고객에게 상태 알림 전송 메시징 시스템의 역할:\n비동기 처리: 각 서비스가 독립적으로 작업을 수행하여 전체 시스템 응답성 향상 이벤트 순서 보장: Kafka 의 파티션 키를 통해 같은 주문의 이벤트 순서 보장 장애 복구: 서비스 장애 시 메시지가 큐에 보존되어 복구 후 처리 재개 확장성: 트래픽 증가 시 컨슈머 인스턴스 추가로 처리 능력 확장 구현 예시 전자상거래 주문 처리 시스템의 Python 구현 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 import json import asyncio from typing import Dict, Any from kafka import KafkaProducer, KafkaConsumer from kafka.errors import KafkaError import logging # 설정 KAFKA_BOOTSTRAP_SERVERS = ['localhost:9092'] ORDER_TOPIC = 'order-events' PAYMENT_TOPIC = 'payment-events' class MessageProducer: \"\"\"메시지 발행자 클래스\"\"\" def __init__(self): self.producer = KafkaProducer( bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS, key_serializer=lambda k: str(k).encode('utf-8'), value_serializer=lambda v: json.dumps(v).encode('utf-8'), acks='all', # 모든 복제본에서 확인 retries=3, # 재시도 횟수 batch_size=16384, # 배치 크기 linger_ms=10 # 배치 대기 시간 ) async def publish_event(self, topic: str, key: str, event_data: Dict[str, Any]): \"\"\"이벤트 발행\"\"\" try: future = self.producer.send( topic=topic, key=key, value=event_data ) # 동기적으로 결과 확인 record_metadata = future.get(timeout=10) logging.info(f\"Event published to {record_metadata.topic}:{record_metadata.partition}:{record_metadata.offset}\") return True except KafkaError as e: logging.error(f\"Failed to publish event: {e}\") return False def close(self): \"\"\"프로듀서 종료\"\"\" self.producer.close() class OrderService: \"\"\"주문 서비스 클래스\"\"\" def __init__(self): self.producer = MessageProducer() async def create_order(self, order_data: Dict[str, Any]) -\u003e str: \"\"\"주문 생성 및 이벤트 발행\"\"\" order_id = f\"order_{order_data['customer_id']}_{int(asyncio.get_event_loop().time())}\" # 주문 데이터베이스 저장 (시뮬레이션) await self._save_order_to_db(order_id, order_data) # 주문 생성 이벤트 발행 event = { 'event_type': 'order_created', 'order_id': order_id, 'customer_id': order_data['customer_id'], 'items': order_data['items'], 'total_amount': order_data['total_amount'], 'timestamp': asyncio.get_event_loop().time() } success = await self.producer.publish_event( topic=ORDER_TOPIC, key=order_id, # 파티션 키로 주문 ID 사용 event_data=event ) if success: logging.info(f\"Order {order_id} created and event published\") return order_id else: logging.error(f\"Failed to publish order creation event for {order_id}\") raise Exception(\"Order event publication failed\") async def _save_order_to_db(self, order_id: str, order_data: Dict[str, Any]): \"\"\"주문 데이터베이스 저장 시뮬레이션\"\"\" await asyncio.sleep(0.1) # DB 작업 시뮬레이션 logging.info(f\"Order {order_id} saved to database\") class PaymentService: \"\"\"결제 서비스 클래스\"\"\" def __init__(self): self.producer = MessageProducer() self.consumer = KafkaConsumer( ORDER_TOPIC, bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS, group_id='payment-service-group', key_deserializer=lambda k: k.decode('utf-8'), value_deserializer=lambda v: json.loads(v.decode('utf-8')), auto_offset_reset='latest', enable_auto_commit=True ) async def start_consuming(self): \"\"\"주문 이벤트 수신 및 처리\"\"\" logging.info(\"Payment service started consuming order events\") for message in self.consumer: try: event_data = message.value if event_data['event_type'] == 'order_created': await self._process_payment(event_data) except Exception as e: logging.error(f\"Error processing payment: {e}\") async def _process_payment(self, order_event: Dict[str, Any]): \"\"\"결제 처리\"\"\" order_id = order_event['order_id'] amount = order_event['total_amount'] # 결제 처리 시뮬레이션 await asyncio.sleep(0.2) # 결제 완료 이벤트 발행 payment_event = { 'event_type': 'payment_completed', 'order_id': order_id, 'payment_id': f\"pay_{order_id}\", 'amount': amount, 'status': 'completed', 'timestamp': asyncio.get_event_loop().time() } success = await self.producer.publish_event( topic=PAYMENT_TOPIC, key=order_id, event_data=payment_event ) if success: logging.info(f\"Payment completed for order {order_id}\") else: logging.error(f\"Failed to publish payment completion event for {order_id}\") class NotificationService: \"\"\"알림 서비스 클래스\"\"\" def __init__(self): self.consumer = KafkaConsumer( ORDER_TOPIC, PAYMENT_TOPIC, bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS, group_id='notification-service-group', key_deserializer=lambda k: k.decode('utf-8'), value_deserializer=lambda v: json.loads(v.decode('utf-8')), auto_offset_reset='latest' ) async def start_consuming(self): \"\"\"이벤트 수신 및 알림 전송\"\"\" logging.info(\"Notification service started consuming events\") for message in self.consumer: try: event_data = message.value await self._send_notification(event_data) except Exception as e: logging.error(f\"Error sending notification: {e}\") async def _send_notification(self, event_data: Dict[str, Any]): \"\"\"알림 전송\"\"\" event_type = event_data['event_type'] order_id = event_data['order_id'] notification_messages = { 'order_created': f\"주문 {order_id}이 접수되었습니다.\", 'payment_completed': f\"주문 {order_id}의 결제가 완료되었습니다.\" } if event_type in notification_messages: # 실제 알림 전송 (이메일, SMS, 푸시 등) await asyncio.sleep(0.1) # 알림 전송 시뮬레이션 logging.info(f\"Notification sent: {notification_messages[event_type]}\") # 사용 예시 async def main(): \"\"\"메인 실행 함수\"\"\" logging.basicConfig(level=logging.INFO) # 서비스 인스턴스 생성 order_service = OrderService() payment_service = PaymentService() notification_service = NotificationService() # 백그라운드에서 컨슈머 서비스 실행 payment_task = asyncio.create_task(payment_service.start_consuming()) notification_task = asyncio.create_task(notification_service.start_consuming()) # 주문 생성 시뮬레이션 order_data = { 'customer_id': 'customer_123', 'items': [ {'product_id': 'prod_1', 'quantity': 2, 'price': 29.99}, {'product_id': 'prod_2', 'quantity': 1, 'price': 49.99} ], 'total_amount': 109.97 } try: order_id = await order_service.create_order(order_data) logging.info(f\"Order creation completed: {order_id}\") # 메시지 처리를 위한 대기 await asyncio.sleep(5) except Exception as e: logging.error(f\"Order creation failed: {e}\") finally: # 정리 작업 order_service.producer.close() payment_service.producer.close() payment_task.cancel() notification_task.cancel() if __name__ == \"__main__\": asyncio.run(main()) 도전 과제 카테고리 도전 과제 원인 영향 예방 방법 해결 방안 및 기법 확장성 (Scalability) 대규모 트래픽 처리 한계 사용자 증가, IoT 등 대량 이벤트 유입 처리량 저하, 메시지 지연, 큐 적체 오토 스케일링, 파티션 설계 수평 확장, 샤딩, 클러스터링, 로드밸런싱 적용 일관성 (Ordering) 메시지 순서 보장 병렬 처리, 멀티 스레드, 파티션 처리 순서 오류, 데이터 불일치, 트랜잭션 문제 파티션 키 설정, 순서 보장 필요 메시지의 단일 파티션 처리 이벤트 소싱, Kafka Streams, 순서 보장 큐 사용 신뢰성 (Reliability) 메시지 손실 및 중복 처리 네트워크 장애, Ack 누락, 재시도 로직 데이터 유실, 중복 처리, 비즈니스 로직 오류 QoS 설정, 멱등 키 사용, 중복 필터링 적용 Retry + DLQ, Idempotent Consumer 설계, 트랜잭션 처리 보안 및 규정 준수 (Security \u0026 Compliance) 데이터 노출 및 컴플라이언스 위반 위험 외부 네트워크 노출, 민감 정보 포함 메시지 전송 개인정보 유출, 법적 리스크, 신뢰도 하락 종단간 암호화 (TLS/SSL), RBAC, 접근 감사 로그 OAuth2 인증, 메시지 암호화, 데이터 마스킹 적용 운영 복잡도 (Operational Complexity) 메시지 브로커 및 클러스터 관리 복잡성 오프셋 관리, 파티션 재할당, 장애 복구 등 운영 부담 인프라 비용 증가, 장애 대응 지연 자동화 도구 도입, 표준 운영 절차 마련 Prometheus, Kafka UI, 클러스터 오토 리밸런싱 도구 활용 클라우드 환경 적응성 컨테이너 기반 클라우드 환경과의 통합 Kubernetes, 서버리스 등 클라우드 네이티브 환경 확산 기존 브로커와의 통합 어려움, 확장성 부족 클라우드 네이티브 메시징 솔루션 선택 KEDA, Strimzi, Cloud Pub/Sub 등 클라우드 친화형 메시징 도입 실시간 처리 요구 증가 고속 스트리밍 처리에 대한 대응 필요 IoT, 실시간 분석 시스템에서 초저지연 요구 기존 배치 처리 방식 한계, 시스템 병목 실시간 아키텍처 설계, 이벤트 기반 처리 Kafka Streams, Flink, Spark Streaming 등의 스트리밍 프레임워크 적용 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 분류 고려사항 주의할 점 권장 사항 아키텍처 설계 메시지 스키마 설계 스키마 변경 시 하위 호환성 문제 발생 Avro, Protocol Buffers + Schema Registry 사용, 스키마 진화 전략 수립 토픽 및 파티션 구성 파티션 수 변경이 어렵고 성능에 직접 영향 서비스 도메인 기반 분리, 향후 확장 고려한 설계 메시지 라우팅 전략 브로커 기반 복잡한 라우팅은 유지보수 어려움 라우팅 키 명확화, 라우팅은 소비자 쪽에서 처리 권장 신뢰성 보장 메시지 중복 처리 At-least-once 설정 시 중복 가능성 있음 메시지 ID 기반 멱등 처리 로직 구현 메시지 순서 보장 파티션 간 순서 보장 어려움 순서 보장 필요한 메시지는 단일 파티션 구성 오류 및 재처리 전략 실패 메시지 무한 반복 수신 위험 Dead Letter Queue 설정, 재시도 횟수 및 백오프 전략 구성 성능 최적화 배치 처리 설정 배치 크기 증가 시 메모리 과다 사용 가능 처리량과 지연시간 간 트레이드오프 고려, 적절한 배치 크기와 시간 설정 컨슈머 그룹 구성 파티션 수보다 많은 컨슈머는 할당 불균형 발생 파티션 수와 컨슈머 수를 균형 있게 유지 네트워크 지연 최적화 브로커 간 지리적 거리로 인한 지연 동일 리전 배치 또는 지연 최소화된 데이터 센터 구성 보안 및 컴플라이언스 인증 및 접근 제어 기본 설정으로 인증 및 암호화 미적용 TLS/SSL 암호화, SASL 인증, RBAC 및 ACL 정책 적용 민감 데이터 보호 메시지 내 개인정보 또는 비식별 데이터 포함 가능성 데이터 마스킹, 암호화, 토픽/큐 기반 접근 분리 운영 관리 모니터링 및 로깅 메트릭 부족 시 이상 탐지 어려움 Prometheus + Grafana 조합, 지표: 처리량, 지연, 실패율, 큐 깊이 등 수집 백업 및 복구 전략 장애 시 메시지 손실 및 복구 실패 위험 브로커 클러스터 구성, 다중 AZ 배포, 정기 백업 및 복구 테스트 실행 재해 복구 및 이중화 구성 단일 브로커 (SPOF) 는 전체 서비스 장애로 이어질 수 있음 클러스터 및 복제 설정, 장애 자동 전환 구성 클라우드 환경 적응 컨테이너 및 서버리스 통합 전통적 메시징 시스템과 클라우드 환경 간 호환성 문제 Strimzi, KEDA, Cloud Pub/Sub 등 클라우드 네이티브 메시징 솔루션 활용 데이터 보존 전략 메시지 저장 기간 설정 무분별한 저장은 스토리지 과부하, 너무 짧은 보존은 추적 불가 규제와 비즈니스 요구에 맞춘 TTL 설정, 아카이빙 전략 도입 클라이언트 구성 생산자/소비자 설정 최적화 기본 설정은 재시도, 타임아웃, 연결 수 제한 등 미비 커넥션 풀링, 타임아웃 설정, 재시도 횟수 및 백오프 전략 구성 최적화하기 위한 고려사항 및 주의할 점 카테고리 항목 설명 권장 사항 메시지 처리 최적화 메시지 배치 처리 처리량 향상에 효과적이나 과도한 메모리 사용 가능 16KB~1MB 사이의 배치 크기 설정, 지연과 처리량의 균형 유지 비동기 처리 방식 콜백 헬이나 복잡한 흐름 관리 이슈 발생 가능 async/await, Promise 패턴 사용 메시지 압축 압축으로 전송량 줄이지만 CPU 사용 증가 가능 snappy, gzip 등 경량 압축 사용 파티셔닝 및 분산 파티션 수 및 키 전략 잘못된 키로 인한 핫 파티션, 순서 보장 실패 가능 예상 처리량 기반 파티션 수 설정, 균형 잡힌 키 분산 전략 수립 소비자 그룹 최적화 파티션 수보다 많은 컨슈머 구성은 리소스 낭비 가능 파티션 수 ≥ 컨슈머 수, 그룹 리밸런싱 최소화 스토리지 최적화 메시지 보존 기간 과도한 데이터 축적으로 디스크 공간 부족 가능 TTL 설정, 필요 메시지만 저장, 주기적 아카이빙 로그 압축 및 디스크 I/O 중복 키 정리 가능하나 I/O 병목 발생 가능 키 기반 로그 압축 설정, SSD/NVMe, RAID 구성 최적화 네트워크 최적화 클라이언트 - 브로커 거리 지리적 분산 시 지연 및 병목 가능 브로커와 클라이언트를 동일 리전에 배치, 전용 회선 활용 연결 풀링 및 분산 구성 연결 수 제한이나 단일 브로커 집중 시 병목 가능 연결 풀 크기 조절, 브로커 로드 밸런싱 및 멀티 리전 복제 구성 네트워크 병목 대량 트래픽 시 인터페이스 병목 및 지연 발생 고속 네트워크 인터페이스, TCP 튜닝, 로컬 클러스터 구성 메모리 및 메시지 크기 메시지 페이로드 최적화 대용량 메시지는 메모리 과다 사용 및 전송 지연 유발 10MB 이하 권장, 바이너리 포맷 활용, 대형 데이터는 외부 스토리지 참조 캐싱 전략 과도한 캐시로 메모리 낭비 발생 가능 메타데이터, 페이지 캐시 활용, 적절한 캐시 크기 설정 운영 및 튜닝 모니터링 및 지표 추적 병목 지점 파악 어려움 Prometheus, Grafana, Kafka UI 등으로 대시보드 구축 오프셋 및 커밋 전략 수동 커밋 시 중복/유실 위험 존재 자동 커밋 사용 또는 정확한 오프셋 관리 로직 구현 성능 테스트 및 튜닝 실시간 환경과 다른 테스트로 실제 성능 예측 어려움 부하 테스트 시나리오 정기 수행, 성능 병목 시 GC 튜닝, 힙 메모리 최적화 비용 및 리소스 리소스 사용 최적화 과도한 CPU/메모리 사용은 비용 증가로 연결 오토스케일링, 예약 인스턴스, 사용량 기반 요금제 활용 클라우드 환경 대응 리소스 낭비 또는 과소 할당 발생 가능 사용량 기반 모니터링, 알림 설정, 스팟/예약 인스턴스 병행 주제와 관련하여 주목할 내용 카테고리 기술/주제 설명 출처 신기술 Event Mesh 글로벌 브로커 네트워크 구축으로 이벤트 라우팅 자동화 및 서비스 간 유연한 메시징 제공 SAP BTP Event Mesh Serverless Messaging AWS Lambda 와 SQS 같은 서비스로 서버리스 이벤트 기반 처리 강화 AWS IoT 등 아키텍처 CQRS 작성 (Command) 과 조회 (Query) 를 분리하여 메시징을 통한 시스템 성능과 확장성 향상 일반적 패턴 Event Sourcing 상태 변화를 이벤트 로그로 저장하여 시스템 상태 재구성 및 감사 가능 일반적 패턴 클라우드 - 엣지 하이브리드 아키텍처 Kubernetes 등에서 브로커를 엣지와 중앙 클라우드에 함께 구성해 지연 및 장애 회복성 강화 클라우드 - 엣지 통합 성능 최적화 Message Compression LZ4, Snappy 등의 경량 압축을 통해 네트워크 대역폭 절감 실무 권장 적용 Zero-Copy 무복사 방식으로 네트워크 전송 성능 최적화 실무 트렌드 보안 End-to-End Encryption (E2EE) MLS 와 같은 기술로 메시지 송수신 구간 전체에 걸쳐 암호화 보장 Messaging Layer Security Message Authentication HMAC 기반 인증으로 메시지 무결성과 인증성 확보 실무 권장 적용 운영 Schema Evolution Schema Registry 를 활용해 버전 호환성 보장하며 데이터 구조 변경 실무 Best Practice Dead Letter Queue (DLQ) 처리 실패 메시지를 격리하여 문제 분석 및 재처리 시점 확보 실무 필수 구성 학습해야 할 내용 카테고리 주제 항목 설명 기초 이론 분산 시스템 원칙 (CAP, PACELC) CAP 정리 일관성·가용성·분할 내성 간의 트레이드 오프 이해; 설계 시 우선순위 결정에 필수 메시징 패턴 Pub/Sub, Request/Reply, EIP Enterprise Integration Patterns 기반 메시징 구조 및 패턴 이해 프로토콜 AMQP, MQTT, HTTP/2 AMQP, MQTT 프로토콜 RabbitMQ 기반 AMQP 및 IoT 용 MQTT 의 특징과 차이점 파악 메시징 브로커 RabbitMQ, Kafka, Pulsar 주요 브로커 비교 시스템 종류와 특성에 따른 사용 시나리오 비교 스트리밍 처리 Kafka Streams, Apache Flink 실시간 스트림 처리 프레임워크 Kafka Streams 의 Exactly‑once, 상태 ful 처리 등 실무 활용 고급 아키텍처 마이크로서비스, 이벤트 주도 설계 CQRS, Event Sourcing 메시지 기반 비즈니스 로직 분리 및 상태 관리 아키텍처 이해 성능 최적화 파티셔닝, 컨슈머 그룹 메시지 병렬 처리 및 고가용성 확보 부하 분산과 소프트 파티션 설계를 위한 핵심 요소 모니터링 \u0026 운영 지표 수집, 분산 추적 Prometheus + Grafana, 흐름 추적 메시징 시스템의 상태 및 운영 이슈 시각화 및 분석 보안 인증, 암호화, 권한 TLS, SASL, 접근 제어 메시지 통신 보안을 위한 인증 및 권한 관리 구조 용어 정리 카테고리 용어 설명 메시징 패턴 Fire-and-Forget 메시지 전송 후 응답을 기다리지 않는 비동기 일방향 통신 Scatter-Gather 요청을 여러 수신자에게 분산 전송한 후 결과를 수집하는 패턴 Message Aggregator 여러 개의 관련 메시지를 하나의 결과 메시지로 집계 프로토콜 \u0026 표준 AMQP 고급 메시징 큐잉 프로토콜, 트랜잭션, QoS 지원 MQTT IoT 환경에 적합한 경량 발행 - 구독 프로토콜 STOMP 텍스트 기반 메시징 프로토콜, 다양한 플랫폼 간 호환성 지원 Kafka Protocol Kafka 고유의 고성능 메시지 전송 바이너리 프로토콜 JMS Java 기반 메시징 API 표준 CloudEvents 이벤트 데이터 표준 형식 사양, 플랫폼 간 상호운용성 제공 AsyncAPI 비동기 API 메시지, 채널, 프로토콜 문서 명세 스펙 시스템 구조 Producer 메시지를 생성하여 브로커로 전송하는 컴포넌트 Consumer 브로커로부터 메시지를 수신하여 처리하는 컴포넌트 Broker 메시지를 중개, 저장, 라우팅하는 미들웨어 Message Channel 메시지가 흐르는 논리적 링크 / 경로 Message Endpoint 애플리케이션과 브로커 간의 연결 지점 Message Gateway 이기종 메시징 시스템 간 브리지 역할 큐/스트림 모델 Topic Pub/Sub 방식에서 메시지를 분류하고 브로드캐스트하는 단위 Queue 1:1 메시지 전달을 위한 순차적 저장 구조 Dead Letter Queue (DLQ) 처리 실패한 메시지를 별도 저장해 재처리하거나 분석할 수 있는 큐 Task Queue 작업 단위를 큐에 넣고 워커가 실행하는 구조 Event Streaming 지속적인 이벤트 로그/스트림 저장 및 소비 구조 파티셔닝 \u0026 오프셋 Partition 메시지를 병렬 처리하기 위한 분할 단위 Offset 파티션 내 메시지 위치 인덱스로 소비 추적용 전송 보장 정책 At-most-once 최대 1 회 전송, 손실 발생 가능성 있음 At-least-once 최소 1 회 전송, 중복 가능성 있음 Exactly-once 정확히 1 회만 전송 보장 신뢰성 \u0026 흐름 제어 Idempotent 중복 수신 시에도 동일한 처리 결과를 보장하는 속성 Backpressure 소비자 처리 속도 부족 시 흐름 제어 메커니즘 구현 성능 지표 Throughput 단위 시간당 메시지 처리량 보안 Message Encryption 메시지 내용 암호화를 통한 데이터 보호 Message Authentication (HMAC 등) 메시지 무결성 및 인증 보장 Access Control List (ACL) 메시징 리소스에 대한 접근 권한 관리 목록 운영 관리 Message TTL 메시지 유효 기간 설정 Circuit Breaker 장애 발생 시 시스템 연쇄 실패 방지를 위한 보호 패턴 고급 아키텍처 패턴 CQRS 명령 (Command) 과 조회 (Query) 를 분리하는 아키텍처 패턴 Event Sourcing 모든 상태 변화 이벤트를 기록하여 상태 재구성 가능 구조 Saga 분산 환경에서 트랜잭션 조정을 위한 패턴, 마이크로서비스 조합 Schema Registry 메시지 스키마 버전 관리 및 호환성 보장 참고 및 출처 Enterprise Integration Patterns - Messaging Patterns Apache Kafka Documentation RabbitMQ vs Apache Kafka - AWS Comparison Event-Driven Architecture - Martin Fowler Microservices Pattern: Event-driven architecture Cloud Design Patterns - Microsoft Azure Distributed Systems Design Patterns Message Broker Architecture - IBM RabbitMQ Documentation AWS EventBridge CloudEvents Specification AsyncAPI Official Site KIP-932: Kafka Queues NATS 공식 문서 Apache Pulsar 공식 문서 Azure Service Bus 문서 AWS SQS 문서 AWS SNS 문서 AWS Kinesis 문서 Google Cloud Pub/Sub 문서 Celery 공식 문서 AMQP 프로토콜 명세 MQTT 프로토콜 명세 Confluent Schema Registry 문서 Messaging Systems: Why They Exist, Benefits, and Challenges Understanding Messaging Systems - System Design School Differences Between Messaging Queues and Streaming: A Deep Dive Message Queues vs. Streaming Systems: Key Differences and Use Cases Differences Between Event Streaming and Message Queuing - GitHub Message Queues vs. Event Streams: Key Differences - DEV.to RabbitMQ Use cases - CloudAMQP Optimizing Performance and Reliability in Messaging Systems Kafka 4 use cases and 4 real-life examples Event-Driven Architecture Examples - Estuary Red Hat AMQ Oracle Messaging Architecture Guide Red Hat Architectural Messaging Patterns Wikipedia - Messaging Pattern Wikipedia - Message Broker Wikipedia - Enterprise Integration Patterns Wikipedia - Event-driven Messaging Dev.to - Messaging Patterns 101 Dev.to - Choosing the Best Messaging System RisingWave - 5 Vital Challenges with Messaging Queues DZone - Developing Real-Time Messaging Systems UBB Cluj - MOM Lecture PDF Ably - Chat Architecture for Reliable Message Ordering Contus - Scalable Messaging Strategy App Alibaba Cloud - Queue Quandaries ","wordCount":"7253","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-22T13:59:00Z","dateModified":"2025-04-22T13:59:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Messaging Systems</h1><div class=post-description>메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다.</div><div class=post-meta><span title='2025-04-22 13:59:00 +0000 UTC'>April 22, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20Design/Message-Oriented%20Systems/Message%20Processing%20Systems/Messaging-Systems.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#messaging-systems>Messaging Systems</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#배경-background>배경 (Background)</a></li><li><a href=#목적-및-필요성>목적 및 필요성</a></li><li><a href=#주요-기능-및-역할-key-functions-and-roles>주요 기능 및 역할 (Key Functions and Roles)</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙-core-principles>핵심 원칙 (Core Principles)</a></li><li><a href=#주요-원리>주요 원리</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#메시징-시스템-설계-및-구현-전략>메시징 시스템 설계 및 구현 전략</a></li><li><a href=#장점>장점</a></li><li><a href=#단점과-문제점>단점과 문제점</a></li><li><a href=#분류-기준에-따른-종류-및-유형>분류 기준에 따른 종류 및 유형</a></li><li><a href=#실무-사용-예시>실무 사용 예시</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#구현-예시>구현 예시</a></li><li><a href=#도전-과제>도전 과제</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용</a></li><li><a href=#학습해야-할-내용>학습해야 할 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=messaging-systems>Messaging Systems<a hidden class=anchor aria-hidden=true href=#messaging-systems>#</a></h2><p>메시징 시스템 (Messaging Systems) 은 애플리케이션 또는 서비스 간 메시지를 안전하게 송수신하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 장애 복원력, 실시간 데이터 처리 등 백엔드 시스템의 핵심 요구사항을 충족한다. 대표적으로 메시지 큐, 이벤트 스트리밍 플랫폼, 태스크 큐 등이 있으며, 각각 작업 분산, 실시간 이벤트 처리, 대규모 데이터 파이프라인 등 다양한 시나리오에 활용된다. 현대 분산 시스템과 마이크로서비스 아키텍처에서 메시징 시스템은 필수적이다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>메시징 시스템 (Messaging Systems) 은 독립적인 소프트웨어 구성 요소 간의 비동기 통신을 가능하게 하는 인프라이다. 이를 통해 시스템의 결합도를 낮추고, 확장성과 장애 허용성을 향상시킬 수 있다.</p><h4 id=기본-핵심-개념>기본 핵심 개념<a hidden class=anchor aria-hidden=true href=#기본-핵심-개념>#</a></h4><ul><li><p><strong>메시지 (Message)</strong>: 애플리케이션 간 교환되는 데이터 단위로, 헤더와 바디로 구성되며 메타데이터와 실제 내용을 포함한다. 다양한 형식을 지원한다 (JSON, XML, Protocol Buffers, Avro 등).</p></li><li><p><strong>메시지 지향 미들웨어 (MOM)</strong>: 분산 애플리케이션 간의 메시지 기반 통신을 지원하는 인프라 솔루션이다.</p></li><li><p><strong>비동기 메시징 (Asynchronous Messaging)</strong>: 발신자가 응답을 기다리지 않고 메시지를 전송하는 통신 방식으로, 시스템 결합도를 낮추고 확장성을 향상시킨다.</p></li><li><p><strong>이벤트 주도 아키텍처 (Event-Driven Architecture)</strong>: 시스템 상태 변화를 이벤트로 표현하고, 이벤트를 통해 컴포넌트 간 통신하는 아키텍처 패턴이다.</p></li><li><p><strong>생산자 - 소비자 모델 (Producer-Consumer Model)</strong>: 두 개 이상의 프로세스 (또는 스레드) 가 공유 자원 (버퍼) 을 통해 데이터를 주고받는 대표적인 병행 프로그래밍 패턴으로 둘 사이의 직접적인 연결 없이 느슨한 결합 (Loose Coupling) 유지한다.</p><ul><li>생산자 (Producer): 메시지를 생성하고 전송하는 주체</li><li>소비자 (Consumer): 메시지를 수신하고 처리하는 주체</li></ul></li><li><p><strong>브로커 (Broker)</strong>: 메시지의 중개자 역할을 담당하는 중앙 구성 요소로, 메시지 저장, 라우팅, 전달을 담당하며, 클라이언트 간 직접적인 연결 필요성을 제거한다.</p></li><li><p><strong>메시지 브로커 (Message Broker)</strong>: 메시지의 송신자와 수신자 사이에서 중개 역할을 하는 소프트웨어 모듈로, 메시지 검증, 변환, 라우팅을 담당한다.</p></li><li><p><strong>메시지 큐 (Message Queue)</strong>: 메시지를 임시 저장하는 저장소로, FIFO 방식으로 메시지를 처리하며 비동기 통신을 가능하게 한다.</p></li><li><p><strong>큐와 토픽 (Queues and Topics)</strong></p><ul><li>큐 (Queue): 1:1 통신 모델, 하나의 메시지는 하나의 소비자에게만 전달</li><li>토픽 (Topic): 1:N 발행 - 구독 (Pub-Sub) 모델, 하나의 메시지가 여러 소비자에게 전달</li></ul></li><li><p><strong>이벤트 스트리밍 (Event Streaming)</strong>: 생산자가 이벤트를 스트림에 게시하면, 여러 소비자가 이를 구독하여 실시간으로 처리하는 모델이다. 주로 실시간 데이터 처리와 분석에 사용된다.</p></li><li><p><strong>태스크 큐 (Task Queue)</strong>: 작업을 큐에 넣고, 워커가 이를 비동기적으로 처리하는 모델이다. 주로 백그라운드 작업 처리에 사용된다.</p></li></ul><h4 id=심화-핵심-개념>심화 핵심 개념<a hidden class=anchor aria-hidden=true href=#심화-핵심-개념>#</a></h4><ul><li><p><strong>메시지 지속성 (Message Persistence)</strong>: 시스템 장애 시에도 메시지 손실을 방지하기 위해 메시지를 영구 저장소에 보관하는 기능이다.</p></li><li><p><strong>메시지 순서 보장 (Message Ordering)</strong>: 메시지가 전송된 순서대로 처리되도록 보장하는 메커니즘이다.</p></li><li><p><strong>메시지 보장 (Message Guarantees)</strong>: 메시징 시스템 (예: 메시지 큐, Pub/Sub 등) 에서 메시지가 얼마나 안정적으로 송신자에서 수신자에게 전달되는지를 보장하는 수준이다.</p><ul><li>At-most-once: 메시지가 최대 한 번 전달됨 (일부 손실 가능)</li><li>At-least-once: 메시지가 최소 한 번 전달됨 (중복 가능)</li><li>Exactly-once: 메시지가 정확히 한 번 전달됨 (이상적이나 구현 복잡)</li></ul></li><li><p><strong>파티셔닝과 샤딩 (Partitioning and Sharding)</strong>: 대용량 데이터 처리를 위한 분할 기법으로, 수평적 확장성 (Horizontal Scalability) 을 지원한다.</p></li><li><p><strong>메시지 오프셋과 순서 (Message Offset and Ordering)</strong>: 메시지의 위치와 순서 관리 메커니즘으로, 순차적 처리와 병렬 처리 간의 균형을 가능하게 한다.</p></li><li><p><strong>장애 허용 (Fault Tolerance)</strong>: 시스템 일부 장애 시에도 전체 기능 유지하게 한다.</p></li><li><p><strong>백프레셔 (Backpressure)</strong>: 소비자의 처리 속도가 생산자의 전송 속도보다 느릴 때 발생하는 압력을 관리하는 기법이다.</p></li></ul><h4 id=실무-구현-요소>실무 구현 요소<a hidden class=anchor aria-hidden=true href=#실무-구현-요소>#</a></h4><ul><li><strong>Connection Pool Management</strong>: 효율적인 연결 관리</li><li><strong>Message Serialization/Deserialization</strong>: 메시지 직렬화 및 역직렬화</li><li><strong>Dead Letter Queue (DLQ)</strong>: 처리 실패 메시지 관리</li><li><strong>Circuit Breaker Pattern</strong>: 장애 전파 방지</li><li><strong>Monitoring and Alerting</strong>: 성능 모니터링 및 알람</li></ul><h4 id=주요-개념>주요 개념<a hidden class=anchor aria-hidden=true href=#주요-개념>#</a></h4><table><thead><tr><th>개념</th><th>설명</th></tr></thead><tbody><tr><td>Queue</td><td>메시지를 순서대로 저장하고 소비자가 꺼내는 구조</td></tr><tr><td>Topic</td><td>메시지를 발행/구독하는 구조, 다수의 소비자에게 브로드캐스팅 가능</td></tr><tr><td>Producer</td><td>메시지를 생성하여 시스템에 전달하는 역할</td></tr><tr><td>Consumer</td><td>메시지를 수신하고 처리하는 역할</td></tr><tr><td>Broker</td><td>메시지를 수신하고 큐 또는 토픽에 적절히 저장한 뒤 소비자에게 전달</td></tr><tr><td>Message</td><td>전송되는 데이터 단위, 헤더와 바디로 구성됨</td></tr><tr><td>Partition</td><td>메시지를 병렬로 처리하기 위한 논리적 분할 단위 (Kafka 등)</td></tr></tbody></table><h3 id=배경-background>배경 (Background)<a hidden class=anchor aria-hidden=true href=#배경-background>#</a></h3><h4 id=발전-배경>발전 배경<a hidden class=anchor aria-hidden=true href=#발전-배경>#</a></h4><p>과거에는 시스템 간 통신이 동기 방식 (예: HTTP 요청 - 응답) 에 의존해 있었고, 이는 시스템 확장성 및 유연성에 제약을 주었다. 비동기 메시징 시스템은 다양한 컴포넌트가 독립적으로 작동할 수 있게 하여, 마이크로서비스 아키텍처와 실시간 처리의 핵심 인프라로 발전하게 되었다.</p><h4 id=주요-전환점>주요 전환점<a hidden class=anchor aria-hidden=true href=#주요-전환점>#</a></h4><ul><li>대용량 데이터 스트리밍 필요성 증대</li><li>마이크로서비스 (MSA) 및 이벤트 기반 아키텍처의 확산</li><li>클라우드 네이티브 환경에서의 동적 확장 요구</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><table><thead><tr><th><strong>구분</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>느슨한 결합 (Loose Coupling)</td><td>구성 요소 간 직접 의존 제거, 독립적인 개발·배포·확장 가능</td></tr><tr><td>비동기 통신 (Asynchronous)</td><td>생산자가 응답을 기다리지 않고 메시지 전송, 처리량 증가 및 응답 시간 개선</td></tr><tr><td>확장성 (Scalability)</td><td>소비자 수 증가만으로 병렬 처리 가능, 수평 확장을 통한 성능 향상</td></tr><tr><td>시간적 분리 (Temporal Decoupling)</td><td>생산자·소비자의 시간 독립성 보장, 장애 시에도 메시지 유실 없이 재처리 가능</td></tr><tr><td>장애 복구 (Fault Recovery)</td><td>메시지 영속성으로 장애 시에도 데이터 복구 가능, 시스템 복원력 향상</td></tr><tr><td>부하 완화 (Load Buffering)</td><td>큐를 통해 요청 폭주 시 백엔드 보호, 소비자 속도에 맞춰 안정적인 처리</td></tr><tr><td>실시간 처리 (Real-Time Processing)</td><td>스트리밍 데이터 실시간 처리 가능, 로그 분석·알림 시스템 등 적용</td></tr><tr><td>유연한 통신 패턴 지원</td><td>Pub-Sub, Request-Reply 등 다양한 통신 방식 지원</td></tr><tr><td>운영 유연성 (Operational Flexibility)</td><td>다양한 포맷/프로토콜 지원, 메시지 재처리·지연처리·필터링 등 기능 활용 가능</td></tr></tbody></table><h3 id=주요-기능-및-역할-key-functions-and-roles>주요 기능 및 역할 (Key Functions and Roles)<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할-key-functions-and-roles>#</a></h3><table><thead><tr><th><strong>기능/역할</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>메시지 송수신 (Message Exchange)</strong></td><td>생산자 (Producer) 와 소비자 (Consumer) 간 안정적인 메시지 전달 수행</td></tr><tr><td><strong>큐잉 (Queueing)</strong></td><td>메시지를 임시 저장하여 소비자와의 처리 속도 차이를 완충</td></tr><tr><td><strong>라우팅 (Routing)</strong></td><td>규칙 기반으로 메시지를 적절한 소비자나 큐/토픽으로 전달 (콘텐츠 기반, 헤더 기반 등)</td></tr><tr><td><strong>메시지 변환 (Transformation)</strong></td><td>데이터 포맷 및 프로토콜 변환을 통해 시스템 간 호환성 보장</td></tr><tr><td><strong>메시지 필터링 (Filtering)</strong></td><td>조건에 따라 필요한 메시지만 소비자에게 전달하여 처리 효율성 향상</td></tr><tr><td><strong>스토어 - 포워드 (Store and Forward)</strong></td><td>네트워크 지연이나 장애 시 메시지를 저장 후 재전송 가능</td></tr><tr><td><strong>전송 보장 (Delivery Guarantee)</strong></td><td>At-most-once, At-least-once, Exactly-once 수준으로 메시지 전달 품질 보장</td></tr><tr><td><strong>메시지 지속성 (Persistence)</strong></td><td>장애 발생 시 데이터 손실 방지를 위한 디스크 기반 영속 저장</td></tr><tr><td><strong>순서 보장 (Ordering)</strong></td><td>FIFO 또는 파티션 기반 처리 순서 보장</td></tr><tr><td><strong>부하 분산 (Load Balancing)</strong></td><td>소비자 그룹 간 메시지 분산으로 시스템 부하 균등화</td></tr><tr><td><strong>흐름 제어 (Flow Control)</strong></td><td>소비자 처리 속도에 따라 생산자 전송 속도 조절, 시스템 안정성 유지</td></tr><tr><td><strong>우선순위 처리 (Prioritization)</strong></td><td>중요도에 따른 메시지 처리 순서 결정 (예: 알람, 금융 트랜잭션 등 우선 처리)</td></tr><tr><td><strong>트랜잭션 처리 (Transactional Support)</strong></td><td>메시지 처리 과정의 원자성 보장 (commit/rollback 지원)</td></tr><tr><td><strong>보안 및 접근 제어 (Security & ACL)</strong></td><td>인증, 암호화, 권한 제어를 통한 안전한 메시지 송수신 보장</td></tr><tr><td><strong>모니터링 및 로깅 (Monitoring & Logging)</strong></td><td>메시지 흐름, 처리 지연, 실패 이벤트 등을 추적하여 운영 가시성 확보</td></tr><tr><td><strong>장애 복구 (Fault Recovery)</strong></td><td>오류 발생 시 재시도, DLQ(Dead Letter Queue) 등으로 장애 복구 지원</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><pre class=mermaid>graph TB
    A[메시징 시스템 특징] --&gt; B[비동기 통신]
    A --&gt; C[느슨한 결합]
    A --&gt; D[확장성]
    A --&gt; E[내결함성]
    
    B --&gt; B1[Non-blocking I/O]
    B --&gt; B2[Event-driven Processing]
    
    C --&gt; C1[Service Decoupling]
    C --&gt; C2[Protocol Independence]
    
    D --&gt; D1[Horizontal Scaling]
    D --&gt; D2[Load Distribution]
    
    E --&gt; E1[Message Persistence]
    E --&gt; E2[Failure Recovery]
</pre><table><thead><tr><th><strong>특징 항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>비동기 통신 (Asynchronous I/O)</strong></td><td>메시지를 큐에 저장하고 응답 없이 처리, 시스템 부하 분산 및 응답 시간 개선</td></tr><tr><td><strong>느슨한 결합 (Loose Coupling)</strong></td><td>서비스 간 직접 의존 최소화, 독립적인 배포·확장·유지보수 가능</td></tr><tr><td><strong>수평 확장성 (Horizontal Scalability)</strong></td><td>파티셔닝 및 클러스터링을 통한 노드 추가 확장, 대규모 트래픽 대응</td></tr><tr><td><strong>내결함성 (Fault Tolerance)</strong></td><td>메시지 영속성, 장애 자동 복구, DLQ 등으로 장애 시 데이터 유실 방지</td></tr><tr><td><strong>다양한 통신 패턴 지원</strong></td><td>Point-to-Point, Publish-Subscribe, Request-Reply 등 유연한 메시징 패턴 지원</td></tr><tr><td><strong>신뢰성 설정 가능 (Message Guarantee)</strong></td><td>At-most-once, At-least-once, Exactly-once 옵션으로 전달 신뢰성 조절 가능</td></tr><tr><td><strong>트랜잭션 지원 (Transactional Messaging)</strong></td><td>메시지 그룹을 원자적으로 처리하여 데이터 일관성 유지</td></tr><tr><td><strong>분산 아키텍처 (Distributed Architecture)</strong></td><td>복수 노드 기반 구성으로 단일 장애 지점 (SPOF) 제거, 고가용성 확보</td></tr><tr><td><strong>프로토콜 독립성 (Protocol Independence)</strong></td><td>다양한 시스템 간 AMQP, MQTT, STOMP 등 이기종 프로토콜 호환 가능</td></tr><tr><td><strong>이벤트 기반 처리 (Event-Driven Processing)</strong></td><td>이벤트 트리거 기반의 반응형 처리 구조, 실시간 분석 및 반응 시스템 구축에 적합</td></tr></tbody></table><h3 id=핵심-원칙-core-principles>핵심 원칙 (Core Principles)<a hidden class=anchor aria-hidden=true href=#핵심-원칙-core-principles>#</a></h3><table><thead><tr><th><strong>핵심 원칙</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>느슨한 결합 (Loose Coupling)</strong></td><td>서비스 간 직접 의존 최소화, 독립 배포 및 유지보수 가능</td></tr><tr><td><strong>비동기 통신 우선 (Asynchrony First)</strong></td><td>동기 통신 최소화, 처리 병목 제거 및 시스템 탄력성 확보</td></tr><tr><td><strong>메시지 중심 설계 (Message-Centric Design)</strong></td><td>메시지를 상호작용의 기본 단위로 활용, 명확한 계약 및 표준 포맷 채택</td></tr><tr><td><strong>확장성 우선 (Scalability First)</strong></td><td>파티션, 컨슈머 그룹 등을 고려한 수평 확장 기반 설계</td></tr><tr><td><strong>장애 허용 설계 (Fault-Tolerant Design)</strong></td><td>일부 실패에도 시스템 전체가 중단되지 않도록 복원 및 재시도 설계 적용</td></tr><tr><td><strong>메시지 내구성 (Message Durability)</strong></td><td>메시지 저장을 통한 재시작·복구 가능, 장애 시에도 데이터 손실 방지</td></tr><tr><td><strong>멱등성 (Idempotency)</strong></td><td>중복 메시지 수신 시에도 동일한 처리 결과 보장, 중복 방지</td></tr><tr><td><strong>메시지 불변성 (Message Immutability)</strong></td><td>메시지는 생성 후 변경 불가, 추적성 및 데이터 무결성 확보</td></tr><tr><td><strong>정확한 전달 보장 (Exactly-once Delivery)</strong></td><td>중복 없이 메시지를 단 한 번 전달 (구현은 복잡하나 이상적)</td></tr><tr><td><strong>중복 수신 허용/방지</strong></td><td>QoS 수준 설정에 따라 허용 또는 필터링 가능 (At-least-once or Exactly-once 선택)</td></tr><tr><td><strong>독립 실행성 (Component Autonomy)</strong></td><td>송신자와 수신자가 서로의 상태와 무관하게 작동 가능</td></tr><tr><td><strong>최종 일관성 (Eventual Consistency)</strong></td><td>메시징 기반 분산 시스템에서 데이터 동기화 지연 허용</td></tr></tbody></table><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><ol><li>**생산자 (Producer)**가 메시지를 브로커/큐/스트림에 전송</li><li><strong>브로커/미들웨어</strong>가 메시지를 저장, 라우팅, 변환, 전달</li><li>**소비자 (Consumer/Subscriber/Worker)**가 메시지를 수신 및 처리</li><li>메시지 보장, 중복 방지, 오류 처리, 재시도 등 내부 로직 적용</li></ol><pre class=mermaid>graph LR
    A[Producer] --&gt; B[Message Broker]
    B --&gt; C[Queue/Topic]
    C --&gt; D[Consumer 1]
    C --&gt; E[Consumer 2]
    C --&gt; F[Consumer N]
    
    B --&gt; G[Dead Letter Queue]
    B --&gt; H[Message Store]
</pre><p>메시징 시스템의 주요 원리는 비동기 메시지 전달 패턴에 기반한다. 프로듀서가 메시지를 생성하여 브로커에 전달하면, 브로커는 이를 적절한 큐나 토픽으로 라우팅하고, 컨슈머들이 각자의 속도로 메시지를 처리한다.</p><p><strong>발행 - 구독 패턴 (Publish-Subscribe Pattern)</strong>:</p><pre class=mermaid>sequenceDiagram
    participant P as Producer
    participant B as Message Broker
    participant C1 as Consumer 1
    participant C2 as Consumer 2
    
    P-&gt;&gt;B: Publish Message
    B-&gt;&gt;C1: Deliver Message
    B-&gt;&gt;C2: Deliver Message
    C1-&gt;&gt;B: Acknowledge
    C2-&gt;&gt;B: Acknowledge
</pre><p><strong>포인트 - 투 - 포인트 패턴 (Point-to-Point Pattern)</strong>:</p><pre class=mermaid>sequenceDiagram
    participant P as Producer
    participant Q as Message Queue
    participant C as Consumer
    
    P-&gt;&gt;Q: Send Message
    Q-&gt;&gt;C: Deliver Message
    C-&gt;&gt;Q: Acknowledge
    Q-&gt;&gt;Q: Remove Message
</pre><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><p>메시징 시스템의 작동 원리는 메시지의 생성, 저장, 전달, 처리의 4 단계로 구성된다. 각 단계에서 적절한 확인 메커니즘을 통해 메시지 전달의 신뢰성을 보장한다.</p><table><thead><tr><th><strong>단계</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>1. 메시지 생성 및 발행</strong></td><td>- 생산자가 메시지를 생성<br>- 메시지 포맷 및 메타데이터 설정<br>- 브로커에 전송</td></tr><tr><td><strong>2. 메시지 수신 및 저장</strong></td><td>- 브로커가 메시지 수신 및 유효성 검사<br>- 큐 또는 토픽에 저장<br>- 필요 시 디스크에 지속성 저장</td></tr><tr><td><strong>3. 메시지 처리 및 전달</strong></td><td>- 소비자가 메시지 요청 또는 구독<br>- 브로커가 메시지를 전달<br>- 소비자가 메시지 처리 후 확인 (Ack)</td></tr><tr><td><strong>4. 흐름 제어 및 장애 처리</strong></td><td>- 소비자 속도에 따라 메시지 전송 조절<br>- 실패 메시지 재시도 또는 DLQ 이동<br>- 오류 로깅 및 모니터링 수행</td></tr></tbody></table><pre class=mermaid>sequenceDiagram
    participant P as Producer
    participant B as Broker
    participant Q as Queue
    participant C as Consumer
    
    P-&gt;&gt;B: Send Message
    B-&gt;&gt;Q: Store Message
    Q--&gt;&gt;B: Acknowledge Storage
    B--&gt;&gt;P: Confirm Receipt
    
    C-&gt;&gt;Q: Poll/Subscribe
    Q-&gt;&gt;C: Deliver Message
    C-&gt;&gt;Q: Acknowledge Processing
    Q-&gt;&gt;B: Remove Message
</pre><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p>메시징 시스템은 다음과 같은 계층과 구성으로 이루어진다.<br>구조는 <strong>프로듀서 - 브로커 - 컨슈머</strong> 중심의 데이터 흐름 기반이며, 고가용성 및 확장성을 고려한 클러스터 기반 분산 구조를 채택한다.</p><p>메시징 시스템의 전체 아키텍처는 다음과 같이 구성된다:</p><pre class=mermaid>graph TB
    subgraph &#34;Application Layer&#34;
        A1[Application 1]
        A2[Application 2]
        A3[Application 3]
    end
    
    subgraph &#34;Client Layer&#34;
        P1[Producer Client]
        P2[Producer Client]
        C1[Consumer Client]
        C2[Consumer Client]
    end
    
    subgraph &#34;Messaging Infrastructure&#34;
        LB[Load Balancer]
        subgraph &#34;Broker Cluster&#34;
            B1[Broker 1]
            B2[Broker 2]
            B3[Broker 3]
        end
        
        subgraph &#34;Storage Layer&#34;
            MS[Message Store]
            DLQ[Dead Letter Queue]
        end
    end
    
    subgraph &#34;Management &amp; Monitoring&#34;
        MM[Management Console]
        MON[Monitoring System]
    end
    
    A1 --&gt; P1
    A2 --&gt; P2
    A3 --&gt; C1
    A3 --&gt; C2
    
    P1 --&gt; LB
    P2 --&gt; LB
    LB --&gt; B1
    LB --&gt; B2
    LB --&gt; B3
    
    B1 --&gt; C1
    B2 --&gt; C2
    
    B1 --&gt; MS
    B2 --&gt; MS
    B3 --&gt; MS
    
    B1 --&gt; DLQ
    B2 --&gt; DLQ
    B3 --&gt; DLQ
    
    MM --&gt; B1
    MM --&gt; B2
    MM --&gt; B3
    
    MON --&gt; B1
    MON --&gt; B2
    MON --&gt; B3
</pre><h4 id=구성요소>구성요소<a hidden class=anchor aria-hidden=true href=#구성요소>#</a></h4><table><thead><tr><th>분류</th><th>구성 요소</th><th>기능</th><th>역할</th><th>주요 특징</th></tr></thead><tbody><tr><td>필수</td><td><strong>Message Broker</strong></td><td>메시지 수신, 저장, 라우팅, 전달</td><td>Producer 와 Consumer 사이의 중개자</td><td>메시지 변환, 프로토콜 번역, 로드 밸런싱</td></tr><tr><td></td><td><strong>Message Queue</strong></td><td>메시지 임시 저장, 순서 보장</td><td>FIFO 방식으로 메시지 처리</td><td>백프레셔 제어, 메시지 지속성</td></tr><tr><td></td><td><strong>Producer (Publisher)</strong></td><td>메시지 생성 및 전송</td><td>데이터를 메시지로 변환하여 전송</td><td>직렬화, 파티셔닝 키 설정</td></tr><tr><td></td><td><strong>Consumer (Subscriber)</strong></td><td>메시지 수신 및 처리</td><td>비즈니스 로직 실행</td><td>역직렬화, 처리 확인 (Ack/Nack)</td></tr><tr><td>선택</td><td><strong>Load Balancer</strong></td><td>트래픽 분산, 고가용성 확보</td><td>브로커 인스턴스 간 부하 분산</td><td>헬스 체크, 장애 감지</td></tr><tr><td></td><td><strong>Message Store</strong></td><td>메시지 지속성 보장</td><td>디스크 기반 메시지 영속 저장</td><td>복제, 백업, 압축</td></tr><tr><td></td><td><strong>Dead Letter Queue</strong></td><td>처리 실패 메시지 분리 및 저장</td><td>재시도 불가 메시지 수집 및 분석</td><td>재시도 정책, 경고/알림 기능</td></tr><tr><td></td><td><strong>Management Console</strong></td><td>시스템 운영/모니터링 도구</td><td>운영자에게 시스템 상태와 설정을 제공</td><td>메트릭 시각화, 설정 관리, 모니터링 대시보드</td></tr><tr><td></td><td><strong>스키마 레지스트리 (Schema Registry)</strong></td><td>메시지 스키마 버전 관리</td><td>데이터 호환성 보장</td><td>스키마 진화 지원</td></tr><tr><td></td><td><strong>커넥터 (Connectors)</strong></td><td>외부 시스템 연동</td><td>데이터 파이프라인 구축</td><td>플러그인 아키텍처</td></tr></tbody></table><h3 id=메시징-시스템-설계-및-구현-전략>메시징 시스템 설계 및 구현 전략<a hidden class=anchor aria-hidden=true href=#메시징-시스템-설계-및-구현-전략>#</a></h3><h4 id=메시징-모델-기반-처리-방식>메시징 모델 기반 처리 방식<a hidden class=anchor aria-hidden=true href=#메시징-모델-기반-처리-방식>#</a></h4><table><thead><tr><th>유형</th><th>정의</th><th>구성 요소</th><th>주요 목적 및 특징</th><th>대표 시스템 / 활용 예시</th></tr></thead><tbody><tr><td><strong>메시지 큐</strong></td><td>생산자와 소비자 간의 비동기 통신을 위한 <strong>큐 기반 메시징 시스템</strong></td><td>생산자, 메시지 큐, 소비자</td><td>- 작업 분산, 순차적 처리<br>- 신뢰성 있는 비동기 처리<br>- 백프레셔 조절 가능</td><td><strong>RabbitMQ</strong>: 이메일 전송 작업 큐잉<br><strong>SQS</strong>, <strong>ActiveMQ</strong></td></tr><tr><td><strong>이벤트 스트리밍</strong></td><td>실시간 이벤트를 스트림 형태로 처리하며 <strong>다수 소비자에게 브로드캐스트</strong>하는 모델</td><td>생산자, 토픽, 소비자</td><td>- 실시간 이벤트 수집 및 분석<br>- 과거 이벤트 재처리 가능<br>- 높은 처리량과 확장성</td><td><strong>Kafka</strong>: IoT 센서 데이터 실시간 분석<br><strong>Pulsar</strong>, <strong>Kinesis</strong></td></tr><tr><td><strong>태스크 큐</strong></td><td>** 작업 (Task)** 을 큐에 저장하고 워커가 <strong>비동기적으로 처리</strong>하는 백그라운드 작업 전용 구조</td><td>생산자, 작업 큐, 워커</td><td>- 장시간 처리 작업 지원<br>- 작업 스케줄링 및 병렬 워커 처리<br>- 실패 시 재시도 가능</td><td><strong>Celery</strong>: 이미지 처리<br><strong>Sidekiq</strong>, <strong>RQ</strong></td></tr><tr><td><strong>하이브리드</strong></td><td>메시지 큐 + 이벤트 스트리밍의 <strong>복합적 구조</strong>, 스트림과 큐를 동시에 운용</td><td>생산자, 큐/토픽, 소비자/워커</td><td>- 복합 워크플로우 구성<br>- 유연한 데이터 흐름 설계<br>- 처리 방식 선택 가능</td><td><strong>Kafka (Queue+Topic)</strong>, <strong>AutoMQ</strong></td></tr></tbody></table><h4 id=메시징-패턴-messaging-patterns>메시징 패턴 (Messaging Patterns)<a hidden class=anchor aria-hidden=true href=#메시징-패턴-messaging-patterns>#</a></h4><table><thead><tr><th>패턴 유형</th><th>정의</th><th>구성 요소</th><th>사용 목적</th><th>실무 예시</th></tr></thead><tbody><tr><td><strong>점대점 (Point-to-Point)</strong></td><td>하나의 메시지를 단 하나의 소비자가 처리하는 1:1 통신 모델</td><td>프로듀서 → 메시지 큐 → 단일 컨슈머</td><td>신뢰성 있는 순차 처리, 부하 분산</td><td>주문 처리 시스템 (주문 생성 → 결제 처리)</td></tr><tr><td><strong>발행 - 구독 (Publish-Subscribe)</strong></td><td>발행자가 메시지를 여러 구독자에게 동시에 전달하는 1:N 모델</td><td>퍼블리셔 → 토픽 → 여러 구독자</td><td>느슨한 결합, 이벤트 브로드캐스트</td><td>재고 이벤트 → 주문, 분석, 알림 서비스</td></tr><tr><td><strong>요청 - 응답 (Request-Reply)</strong></td><td>요청 - 응답을 비동기 메시징으로 구현한 양방향 통신 모델</td><td>요청 큐 + 응답 큐 + 상관관계 ID</td><td>비동기 RPC 구현, 요청 - 응답 추적</td><td>가격 조회 요청 ↔ 계산 결과 응답</td></tr><tr><td><strong>경쟁 소비자 (Competing Consumers)</strong></td><td>여러 소비자가 하나의 큐에서 메시지를 경쟁적으로 소비하는 모델</td><td>단일 큐 → 병렬 컨슈머 (워커 풀)</td><td>수평 확장, 처리량 향상, 부하 분산</td><td>이미지 처리 큐 → 여러 워커가 병렬 처리</td></tr><tr><td><strong>메시지 라우팅 (Message Routing)</strong></td><td>메시지의 내용이나 속성에 따라 적절한 큐 또는 컨슈머로 전달하는 패턴</td><td>라우터 → 조건별 큐 → 특화된 컨슈머</td><td>메시지 유형 기반 분기 처리, 로직 분리</td><td>문의 메시지 → 기술/결제/일반 큐 자동 분류</td></tr></tbody></table><h4 id=고급-메시징-전략-및-신뢰성-보장-기술>고급 메시징 전략 및 신뢰성 보장 기술<a hidden class=anchor aria-hidden=true href=#고급-메시징-전략-및-신뢰성-보장-기술>#</a></h4><table><thead><tr><th>전략/기술</th><th>정의</th><th>구현 기법 또는 메커니즘</th><th>적용 시나리오 예시</th></tr></thead><tbody><tr><td><strong>Exactly-once 처리</strong></td><td>메시지를 중복 없이 단 한 번만 처리하여 <strong>정확성 보장</strong></td><td>- Kafka 트랜잭션<br>- Idempotent Producer + Offset Commit</td><td>결제 시스템 중복 결제 방지, 재고 중복 차감 방지</td></tr><tr><td><strong>메시지 리플레이 (Replay)</strong></td><td>저장된 메시지를 재소비하여 과거 이벤트를 <strong>재처리</strong></td><td>- Kafka 오프셋 수동 리셋 및 재소비<br>- 컨슈머 그룹 리플레이 전략</td><td>파이프라인 장애 복구, 데이터 정합성 검증</td></tr><tr><td><strong>멀티 브로커 클러스터 구성</strong></td><td>장애 발생 시에도 메시징 서비스를 유지하기 위한 <strong>고가용성 구조</strong> 설계</td><td>- Kafka 브로커 다중화<br>- Zookeeper 또는 KRaft 기반 리더 선출</td><td>고부하 환경에서의 메시지 유실 방지, 무중단 운영</td></tr><tr><td><strong>내구성 메시징 (Durable Messaging)</strong></td><td>시스템 장애에도 메시지를 <strong>영구 저장</strong>하여 복구 가능한 메시징 구조</td><td>- 디스크 기반 로그 저장<br>- 메시지 복제 및 체크포인트 유지</td><td>금융 거래 기록, 감사 로그, 미션 크리티컬 이벤트 처리</td></tr></tbody></table><h4 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h4><table><thead><tr><th><strong>구성 요소</strong></th><th><strong>정의 및 목적</strong></th><th><strong>주요 구성</strong></th><th><strong>예시 / 특징</strong></th></tr></thead><tbody><tr><td><strong>메시지 직렬화</strong> (Message Serialization)</td><td>데이터를 바이트 스트림으로 변환하여 플랫폼 간 전송 가능하게 함</td><td>Avro, Protocol Buffers, JSON</td><td><code>{ "eventType": "OrderCreated", … }</code> 와 같은 JSON 메시지 예시</td></tr><tr><td><strong>메시지 파티셔닝</strong> (Message Partitioning)</td><td>메시지를 논리적으로 분할하여 병렬 처리 및 시스템 확장성 향상</td><td>파티션 키, 해시 함수, 로드 밸런서</td><td>고객 ID 기반 파티셔닝, 파티션 수: 3~12, 복제 계수: 3 (권장)</td></tr><tr><td><strong>컨슈머 그룹</strong> (Consumer Groups)</td><td>하나의 토픽을 여러 소비자가 병렬로 처리하여 처리량 증가 및 장애 복구 용이</td><td>그룹 ID, 컨슈머 인스턴스, 코디네이터</td><td>주문 처리 시스템에서 여러 컨슈머 인스턴스가 병렬 처리</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>확장성 (Scalability)</strong></td><td>파티셔닝 및 클러스터링을 통해 수평 확장 가능, 메시지 처리량 증가 및 유연한 리소스 확장 대응</td></tr><tr><td><strong>내결함성 (Fault Tolerance)</strong></td><td>메시지 지속성 및 복제를 통한 장애 시 데이터 유실 방지, 재처리 및 DLQ 기반 복구 가능</td></tr><tr><td><strong>비동기 처리 (Asynchronous Processing)</strong></td><td>송신자 - 수신자 간 비동기 통신으로 지연 감소 및 시스템 병목 해소, 고성능 처리 가능</td></tr><tr><td><strong>모듈 간 느슨한 결합 (Loose Coupling)</strong></td><td>메시지 브로커를 통한 중개로 서비스 간 직접 의존 제거, 독립적 개발·배포·운영 가능</td></tr><tr><td><strong>유연한 통신 패턴 지원 (Flexible Messaging Patterns)</strong></td><td>Point-to-Point, Pub/Sub, Fan-out 등 다양한 구조 지원으로 복잡한 요구 대응 가능</td></tr><tr><td><strong>신뢰성 (Reliability)</strong></td><td>QoS 수준 설정 (At-most-once, At-least-once, Exactly-once) 을 통해 메시지 손실/중복 방지 가능</td></tr><tr><td><strong>모니터링 용이성 (Observability)</strong></td><td>메트릭, 로깅, 추적 등을 통해 시스템 상태를 실시간으로 모니터링하고 문제를 조기에 감지 가능</td></tr><tr><td><strong>유연성 (Interoperability)</strong></td><td>다양한 메시지 포맷과 프로토콜 (AMQP, MQTT, Kafka 등) 지원으로 이기종 시스템 간 통합 가능</td></tr></tbody></table><h3 id=단점과-문제점>단점과 문제점<a hidden class=anchor aria-hidden=true href=#단점과-문제점>#</a></h3><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><table><thead><tr><th><strong>항목</strong></th><th><strong>설명</strong></th><th><strong>해결 방안</strong></th></tr></thead><tbody><tr><td><strong>복잡성 증가</strong></td><td>브로커 설정, 분산 처리, 클러스터 구성 등으로 인해 시스템 구조 복잡도 상승</td><td>모니터링 도구 (Kafka Manager 등) 도입, 관리 자동화</td></tr><tr><td><strong>처리 지연</strong></td><td>브로커를 거치는 네트워크 I/O 및 큐 적체로 인한 지연 발생</td><td>컨슈머 스케일 아웃, 백프레셔 (Backpressure) 메커니즘 적용</td></tr><tr><td><strong>운영 오버헤드</strong></td><td>브로커 운영, 파티션 관리, 장애 대응 등의 지속적 관리 필요</td><td>관리형 서비스 활용, 운영 문서화 및 자동화 도구 활용</td></tr><tr><td><strong>단일 장애점 (SPOF)</strong></td><td>브로커 장애 시 전체 메시징 흐름 중단 가능성 존재</td><td>브로커 이중화 및 클러스터 구성, 자동 장애 복구 시스템 구성</td></tr><tr><td><strong>메시지 순서 보장 어려움</strong></td><td>분산 처리 시 메시지 순서가 뒤섞일 수 있음</td><td>파티션 키 고정, 순서 보장 전용 토픽 사용, 단일 파티션 처리</td></tr></tbody></table><h4 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h4><table><thead><tr><th><strong>문제 항목</strong></th><th><strong>원인</strong></th><th><strong>영향</strong></th><th><strong>해결 방법 및 기법</strong></th></tr></thead><tbody><tr><td><strong>메시지 손실</strong></td><td>Ack 누락, 브로커 장애, 네트워크 불안정</td><td>데이터 유실, 트랜잭션 오류</td><td>메시지 영속성 설정, 재시도 메커니즘, DLQ(Dead Letter Queue) 구성</td></tr><tr><td><strong>중복 메시지 수신</strong></td><td>네트워크 재전송, 컨슈머 재시작</td><td>중복 데이터 처리, 비즈니스 로직 오작동</td><td>멱등성 보장 (Idempotency), 중복 필터링 로직 구현</td></tr><tr><td><strong>백프레셔 (Backpressure)</strong></td><td>컨슈머 처리 속도 저하, 메시지 급증</td><td>메모리 부족, 처리 지연, 시스템 성능 저하</td><td>플로우 제어, 동적 컨슈머 스케일링, 쓰로틀링 적용</td></tr><tr><td><strong>메시지 순서 오류</strong></td><td>멀티 파티션 처리, 병렬 소비</td><td>데이터 불일치, 이벤트 순서 오류</td><td>파티션 키 설계, 단일 파티션 처리, 순서 보장 큐 활용</td></tr><tr><td><strong>컨슈머 과부하</strong></td><td>소비자 수 부족, 메시지 급증, 병목 발생</td><td>큐 적체, 메시지 지연, 처리 실패</td><td>컨슈머 그룹 확장, 로드밸런싱 적용</td></tr></tbody></table><h3 id=분류-기준에-따른-종류-및-유형>분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류-기준에-따른-종류-및-유형>#</a></h3><table><thead><tr><th><strong>분류 기준</strong></th><th><strong>유형</strong></th><th><strong>특징 및 설명</strong></th><th><strong>대표 솔루션</strong></th></tr></thead><tbody><tr><td><strong>전달 모델</strong></td><td>Point-to-Point (점대점)</td><td>하나의 메시지가 하나의 소비자에게만 전달 (큐 기반)</td><td>RabbitMQ, ActiveMQ</td></tr><tr><td></td><td>Publish-Subscribe (발행 - 구독)</td><td>하나의 메시지를 여러 소비자가 구독 (토픽 기반)</td><td>Kafka, MQTT, Apache Pulsar</td></tr><tr><td><strong>메시지 저장 방식</strong></td><td>In-Memory (인메모리)</td><td>메모리에 저장되어 빠른 처리 가능, 재시작 시 손실 가능</td><td>Redis Pub/Sub, ZeroMQ</td></tr><tr><td></td><td>Persistent (영구 저장)</td><td>디스크에 저장되어 내구성 보장, 안정성 높음</td><td>Kafka, RabbitMQ (Durable 옵션)</td></tr><tr><td><strong>배포 아키텍처</strong></td><td>중앙 집중식 (Centralized)</td><td>단일 또는 소수 브로커 사용, 관리 용이하나 단일 장애점 위험 존재</td><td>RabbitMQ, ActiveMQ</td></tr><tr><td></td><td>분산식 (Distributed)</td><td>다중 브로커 기반, 고가용성 및 수평 확장에 유리</td><td>Apache Kafka, Pulsar, NATS</td></tr><tr><td><strong>통신 프로토콜</strong></td><td>AMQP</td><td>고급 메시징 기능, 라우팅 및 트랜잭션 지원</td><td>RabbitMQ, ActiveMQ</td></tr><tr><td></td><td>MQTT</td><td>경량 프로토콜, IoT 및 저대역폭 환경에 적합</td><td>Mosquitto, HiveMQ</td></tr><tr><td></td><td>Kafka Protocol</td><td>로그 기반 고성능 전송, 스트리밍 최적화</td><td>Apache Kafka, Redpanda</td></tr><tr><td></td><td>STOMP</td><td>텍스트 기반, 다양한 언어 및 플랫폼과의 호환성</td><td>ActiveMQ, RabbitMQ</td></tr><tr><td><strong>사용 목적</strong></td><td>메시지 큐 (Message Queue)</td><td>작업 분배, 백그라운드 작업 처리, 비동기 통신</td><td>RabbitMQ, Amazon SQS, ActiveMQ</td></tr><tr><td></td><td>이벤트 스트리밍 (Event Streaming)</td><td>이벤트 로그 저장 및 실시간 분석, 대규모 데이터 스트림 처리</td><td>Apache Kafka, Pulsar</td></tr><tr><td></td><td>태스크 큐 (Task Queue)</td><td>분산 작업 스케줄링 및 실행, 비동기 워크플로우 처리</td><td>Celery, Sidekiq</td></tr><tr><td><strong>QoS 수준</strong></td><td>At-most-once</td><td>최대 1 회 전달, 손실 가능성 존재</td><td>Redis Pub/Sub</td></tr><tr><td></td><td>At-least-once</td><td>최소 1 회 전달, 중복 가능</td><td>RabbitMQ, Kafka (기본 설정)</td></tr><tr><td></td><td>Exactly-once</td><td>정확히 1 회 전달, 가장 높은 신뢰성 (구현 복잡)</td><td>Kafka (트랜잭션), Pulsar</td></tr><tr><td><strong>메시지 순서</strong></td><td>FIFO (First-In-First-Out)</td><td>메시지 순서 보장</td><td>Amazon SQS FIFO, Kafka</td></tr><tr><td></td><td>Non-FIFO</td><td>순서 미보장, 고성능 처리에 적합</td><td>RabbitMQ (기본), Standard SQS</td></tr><tr><td><strong>배포 형태</strong></td><td>온프레미스 (On-Premises)</td><td>자체 인프라에서 운영</td><td>RabbitMQ, Kafka</td></tr><tr><td></td><td>클라우드 관리형 (Managed Cloud)</td><td>SaaS 기반 운영, 유지보수 최소화</td><td>Amazon SQS, Google Pub/Sub</td></tr></tbody></table><h4 id=메시지-큐-vs-이벤트-스트리밍-vs-태스크-큐>메시지 큐 vs. 이벤트 스트리밍 vs. 태스크 큐<a hidden class=anchor aria-hidden=true href=#메시지-큐-vs-이벤트-스트리밍-vs-태스크-큐>#</a></h4><table><thead><tr><th>항목</th><th>메시지 큐 (Message Queue)</th><th>이벤트 스트리밍 (Event Streaming)</th><th>태스크 큐 (Task Queue)</th></tr></thead><tbody><tr><td><strong>구조</strong></td><td>큐 기반 아키텍처, 임시 저장</td><td>로그 기반 아키텍처, 영구적 저장</td><td>작업 중심 아키텍처, 작업 명세 및 결과 저장</td></tr><tr><td><strong>통신 모델</strong></td><td>Point-to-Point</td><td>Publish/Subscribe</td><td>Point-to-Point</td></tr><tr><td><strong>주요 목적</strong></td><td>서비스 간 비동기 통신, 버퍼링, 부하 분산</td><td>실시간 데이터 스트림 처리, 이벤트 기반 아키텍처 구축</td><td>백그라운드 작업, 장기 실행 작업 처리</td></tr><tr><td><strong>데이터 모델</strong></td><td>임시 메시지, 전달 후 제거</td><td>영구적 로그, 시간 순서 이벤트</td><td>작업 명세 및 상태</td></tr><tr><td><strong>소비 모델</strong></td><td>큐에서 메시지 제거 (소비 시)</td><td>구독자가 로그의 현재 위치 관리</td><td>작업 완료 시 큐에서 제거</td></tr><tr><td><strong>메시지 소비</strong></td><td>한 소비자가 메시지를 소비</td><td>여러 소비자가 메시지를 구독</td><td>한 소비자가 작업을 처리</td></tr><tr><td><strong>메시지 보존</strong></td><td>소비 후 삭제</td><td>일정 기간 동안 보존</td><td>작업 완료 후 삭제</td></tr><tr><td><strong>재생</strong></td><td>일반적으로 불가능 (소비 시 제거)</td><td>이전 이벤트 재생 가능 (위치 재설정)</td><td>일반적으로 불가능 (작업 완료 시 제거)</td></tr><tr><td><strong>처리 담당</strong></td><td>메시지 소비자</td><td>구독자의 선택 (데이터 소비만)</td><td>워커 프로세스</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>작업 분산, 비동기 처리</td><td>실시간 데이터 처리, 이벤트 분석</td><td>백그라운드 작업 처리</td></tr><tr><td><strong>대표 제품</strong></td><td>RabbitMQ, ActiveMQ, IBM MQ</td><td>Kafka, Pulsar, Kinesis</td><td>Celery, Sidekiq, Resque</td></tr><tr><td><strong>특징</strong></td><td>- 다양한 라우팅 패턴<br>- 우선순위 지정<br>- 메시지 TTL<br>- 트랜잭션 지원</td><td>- 이벤트 재생/시간 여행<br>- 로그 압축/컴팩션<br>- 고처리량 병렬 처리<br>- 지속 가능 로그 저장</td><td>- 상태 추적<br>- 결과 저장<br>- 재시도 로직<br>- 우선순위/의존성 지원</td></tr><tr><td><strong>적합한 사용 사례</strong></td><td>- 서비스 간 비동기 통신<br>- 마이크로서비스 통합<br>- 부하 분산 및 버퍼링<br>- 서비스 디커플링<br>- 작업 처리 보장</td><td>- 실시간 데이터 분석<br>- 이벤트 소싱 아키텍처<br>- 시계열 데이터 처리<br>- 로그 수집 및 처리 CDC (변경 데이터 캡처)</td><td>- 백그라운드 작업 처리<br>- 리소스 집약적 작업<br>- 주기적 작업 스케줄링<br>- 웹 요청 외부 처리<br>- 분산 작업 실행</td></tr><tr><td><strong>부적합한 사용 사례</strong></td><td>- 대용량 데이터 스트리밍<br>- 장기 데이터 보존<br>- 이벤트 재생 필요 시<br>- 이벤트 소싱 아키텍처</td><td>- 단순 작업 큐<br>- 단일 소비자 시나리오<br>- 요청 - 응답 패턴 (주요 용도)<br>- 작은 규모의 시스템</td><td>- 서비스 간 일반 통신<br>- 이벤트 기반 시스템<br>- 대용량 데이터 스트리밍<br>- 실시간 처리 요구사항</td></tr></tbody></table><h4 id=아키텍처-및-작동-방식-비교>아키텍처 및 작동 방식 비교<a hidden class=anchor aria-hidden=true href=#아키텍처-및-작동-방식-비교>#</a></h4><h5 id=메시지-큐>메시지 큐<a hidden class=anchor aria-hidden=true href=#메시지-큐>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------+    +------------+    +------------+
</span></span><span class=line><span class=cl>|            |    |            |    |            |
</span></span><span class=line><span class=cl>| 생산자(들)  | -&gt; |   큐(들)   | -&gt; | 소비자(들)  |
</span></span><span class=line><span class=cl>|            |    |            |    |            |
</span></span><span class=line><span class=cl>+------------+    +------------+    +------------+
</span></span><span class=line><span class=cl>                       |
</span></span><span class=line><span class=cl>                       v
</span></span><span class=line><span class=cl>                +-------------+
</span></span><span class=line><span class=cl>                |             |
</span></span><span class=line><span class=cl>                | 임시 저장소  |
</span></span><span class=line><span class=cl>                |             |
</span></span><span class=line><span class=cl>                +-------------+
</span></span></code></pre></td></tr></table></div></div><p><strong>작동 원리</strong>:</p><ul><li>메시지가 생산자에 의해 큐에 추가됨</li><li>큐는 메시지를 FIFO 방식으로 저장 (일반적으로)</li><li>소비자가 큐에서 메시지를 가져와 처리</li><li>소비 확인 후 큐에서 메시지 제거</li><li>메시지는 소비될 때까지만 저장</li></ul><h5 id=이벤트-스트리밍-플랫폼>이벤트 스트리밍 플랫폼<a hidden class=anchor aria-hidden=true href=#이벤트-스트리밍-플랫폼>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------+    +----------------+    +------------+
</span></span><span class=line><span class=cl>|            |    |                |    |            |
</span></span><span class=line><span class=cl>| 생산자(들)  | -&gt; | 로그/파티션(들) | -&gt; | 소비자(들)  |
</span></span><span class=line><span class=cl>|            |    |                |    |            |
</span></span><span class=line><span class=cl>+------------+    +----------------+    +------------+
</span></span><span class=line><span class=cl>                         |
</span></span><span class=line><span class=cl>                         v
</span></span><span class=line><span class=cl>                  +-------------+
</span></span><span class=line><span class=cl>                  |             |
</span></span><span class=line><span class=cl>                  | 스토리지 계층 |
</span></span><span class=line><span class=cl>                  |             |
</span></span><span class=line><span class=cl>                  +-------------+
</span></span></code></pre></td></tr></table></div></div><p><strong>작동 원리</strong>:</p><ul><li>이벤트가 파티션된 로그에 추가됨</li><li>이벤트는 시간 순서대로 저장 (로그 구조)</li><li>소비자는 로그의 특정 위치 (오프셋) 에서 읽기 시작</li><li>이벤트는 영구적으로 저장 (구성된 보존 기간 동안)</li><li>소비자는 자신의 오프셋을 관리하고 언제든 재설정 가능</li></ul><h5 id=태스크-큐>태스크 큐<a hidden class=anchor aria-hidden=true href=#태스크-큐>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+------------+    +------------+    +------------+
</span></span><span class=line><span class=cl>|            |    |            |    |            |
</span></span><span class=line><span class=cl>| 태스크 생성자| -&gt; | 태스크 큐(들)| -&gt; | 워커(들)   |
</span></span><span class=line><span class=cl>|            |    |            |    |            |
</span></span><span class=line><span class=cl>+------------+    +------------+    +------------+
</span></span><span class=line><span class=cl>                       |                  |
</span></span><span class=line><span class=cl>                       v                  v
</span></span><span class=line><span class=cl>                +-------------+    +-------------+
</span></span><span class=line><span class=cl>                |             |    |             |
</span></span><span class=line><span class=cl>                | 태스크 저장소 |    | 결과 저장소  |
</span></span><span class=line><span class=cl>                |             |    |             |
</span></span><span class=line><span class=cl>                +-------------+    +-------------+
</span></span></code></pre></td></tr></table></div></div><p><strong>작동 원리</strong>:</p><ul><li>응용 프로그램이 태스크 생성 및 큐에 제출</li><li>태스크는 함수/메서드 호출, 인자, 실행 컨텍스트 포함</li><li>워커 프로세스가 태스크를 가져와 실행</li><li>실행 결과 저장 및 상태 업데이트</li><li>태스크 메타데이터 및 결과는 별도 저장소에 유지</li></ul><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>적용 사례</strong></th><th><strong>사용된 메시징 시스템</strong></th><th><strong>함께 사용되는 기술</strong></th><th><strong>기대 효과</strong></th></tr></thead><tbody><tr><td><strong>전자상거래</strong></td><td>주문 처리 파이프라인</td><td>Kafka, RabbitMQ</td><td>Spring Boot, API Gateway</td><td>비동기 처리, 서비스 디커플링, 트랜잭션 안정성 강화</td></tr><tr><td><strong>금융 서비스</strong></td><td>실시간 거래 처리</td><td>Kafka, IBM MQ</td><td>Kafka Streams, OAuth 인증</td><td>고가용성, 정확히 한 번 전달, 보안성 및 신뢰성 보장</td></tr><tr><td><strong>IoT 플랫폼</strong></td><td>센서 데이터 수집 및 처리</td><td>MQTT, NATS, Kafka</td><td>InfluxDB, Grafana, Edge Devices</td><td>저지연, 실시간 반응, 확장성 높은 스트리밍 처리</td></tr><tr><td><strong>모바일 앱</strong></td><td>푸시 알림 전송</td><td>RabbitMQ, Firebase Cloud Messaging</td><td>WebSocket, Firebase SDK</td><td>실시간 사용자 피드백 제공, 채널별 구독/우선순위 관리</td></tr><tr><td><strong>소셜 미디어</strong></td><td>활동 피드 생성</td><td>Kafka, Redis Streams</td><td>Event Sourcing, CQRS</td><td>대규모 팬아웃, 이벤트 기반 반응, 시스템 반응성 증가</td></tr><tr><td><strong>로그 분석 및 모니터링</strong></td><td>로그 수집 및 실시간 분석</td><td>Kafka, Fluentd</td><td>Elasticsearch, Kibana, Spark Streaming</td><td>대용량 로그 스트림 처리, 실시간 인사이트 확보</td></tr><tr><td><strong>게임 서버</strong></td><td>멀티플레이어 통신</td><td>NATS, Redis Pub/Sub</td><td>Unity, WebRTC</td><td>초저지연 메시징, 이벤트 브로드캐스트, 동시 사용자 대응</td></tr><tr><td><strong>헬스케어</strong></td><td>환자 모니터링 및 경고</td><td>MQTT, Kafka</td><td>Health IoT Devices, Secure Gateway</td><td>실시간 알림, 보안성 높은 통신, 지속적 데이터 스트림 확보</td></tr><tr><td><strong>콘텐츠 워크플로우</strong></td><td>미디어 변환 및 파일 처리</td><td>Kafka, Celery</td><td>Python Worker, Redis, FFmpeg</td><td>비동기 작업 분산 처리, 상태 추적, 작업 실패 복구</td></tr><tr><td><strong>데이터 파이프라인</strong></td><td>실시간 스트리밍 + 배치 처리</td><td>Kafka, Airflow</td><td>Spark, Hadoop, PostgreSQL</td><td>스트림 + 배치 통합 분석, 데이터 품질 유지, ETL 자동화</td></tr><tr><td><strong>서버리스 아키텍처</strong></td><td>이벤트 트리거 워크플로우</td><td>AWS SQS, Google Pub/Sub</td><td>AWS Lambda, GCP Cloud Functions</td><td>확장성 우수, 비용 효율적, 실패 내성 높은 이벤트 처리</td></tr><tr><td><strong>마이크로서비스 통신</strong></td><td>서비스 간 메시지 교환</td><td>RabbitMQ, Kafka</td><td>Docker, Kubernetes, Service Mesh (Istio 등)</td><td>서비스 간 느슨한 결합, 독립 배포, 트래픽 부하 완화</td></tr><tr><td><strong>알림/통지 시스템</strong></td><td>이메일, SMS, 앱 알림</td><td>SNS, Pub/Sub, RabbitMQ</td><td>SMTP, Firebase, Twilio API</td><td>다중 채널 메시지 전송, 사용자 반응성 향상, 우선순위 기반 분배</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-kafka-기반-실시간-스트리밍-설계-예제>사례 1: Kafka 기반 실시간 스트리밍 설계 예제<a hidden class=anchor aria-hidden=true href=#사례-1-kafka-기반-실시간-스트리밍-설계-예제>#</a></h4><p>실시간으로 사용자 활동 로그를 수집하여 분석하는 <strong>Real-Time User Analytics System</strong></p><p><strong>시스템 구성 요소</strong></p><table><thead><tr><th>구성 요소</th><th>설명</th></tr></thead><tbody><tr><td>Web App</td><td>사용자 이벤트 발생 (ex: 클릭, 뷰, 구매 등)</td></tr><tr><td>Kafka Topic</td><td>이벤트 수집용 토픽 (ex: <code>user-events</code>)</td></tr><tr><td>Kafka Producer</td><td>사용자 이벤트를 Kafka 로 전송</td></tr><tr><td>Kafka Broker Cluster</td><td>메시지를 수집, 저장, 라우팅</td></tr><tr><td>Kafka Consumer Group</td><td>Flink 또는 Kafka Streams 로 데이터 실시간 처리</td></tr><tr><td>ClickHouse / Druid</td><td>분석용 DB 로 수집된 이벤트를 저장</td></tr><tr><td>Grafana</td><td>사용자 이벤트를 시각화하는 대시보드</td></tr></tbody></table><p><strong>데이터 흐름 (Workflow)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Web App]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   | (JSON 로그 전송)
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[Kafka Producer]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   | (user-events 토픽으로 게시)
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[Kafka Broker Cluster] --&gt; [Kafka Topic]
</span></span><span class=line><span class=cl>                                  |
</span></span><span class=line><span class=cl>               ---------------------------
</span></span><span class=line><span class=cl>               |                         |
</span></span><span class=line><span class=cl>         [Flink Processor]        [Kafka Consumer - Archiver]
</span></span><span class=line><span class=cl>               |                         |
</span></span><span class=line><span class=cl>         [ClickHouse]               [S3 Storage]
</span></span></code></pre></td></tr></table></div></div><p><strong>고려사항</strong>:</p><ul><li><strong>Partition Key</strong>: <code>user_id</code> 기준으로 파티셔닝하여 순서 보장</li><li><strong>Retention Policy</strong>: 7 일 유지 후 만료</li><li><strong>Exactly-Once 처리</strong>: Kafka + Flink 의 Checkpointing 으로 보장</li></ul><h4 id=사례-2-전자상거래-주문-처리-시스템>사례 2: 전자상거래 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#사례-2-전자상거래-주문-처리-시스템>#</a></h4><p><strong>시스템 구성</strong></p><pre class=mermaid>graph TB
    subgraph &#34;Frontend&#34;
        WEB[Web Application]
        MOBILE[Mobile App]
    end
    
    subgraph &#34;API Gateway&#34;
        GW[API Gateway]
    end
    
    subgraph &#34;Microservices&#34;
        ORDER[Order Service]
        PAYMENT[Payment Service]
        INVENTORY[Inventory Service]
        SHIPPING[Shipping Service]
        NOTIFICATION[Notification Service]
    end
    
    subgraph &#34;Messaging Infrastructure&#34;
        KAFKA[Apache Kafka]
        subgraph &#34;Topics&#34;
            ORDER_TOPIC[order-events]
            PAYMENT_TOPIC[payment-events]
            SHIPPING_TOPIC[shipping-events]
        end
    end
    
    subgraph &#34;Data Layer&#34;
        ORDER_DB[(Order DB)]
        PAYMENT_DB[(Payment DB)]
        INVENTORY_DB[(Inventory DB)]
    end
    
    WEB --&gt; GW
    MOBILE --&gt; GW
    GW --&gt; ORDER
    
    ORDER --&gt; KAFKA
    KAFKA --&gt; ORDER_TOPIC
    KAFKA --&gt; PAYMENT_TOPIC
    KAFKA --&gt; SHIPPING_TOPIC
    
    ORDER_TOPIC --&gt; PAYMENT
    ORDER_TOPIC --&gt; INVENTORY
    PAYMENT_TOPIC --&gt; SHIPPING
    SHIPPING_TOPIC --&gt; NOTIFICATION
    
    ORDER --&gt; ORDER_DB
    PAYMENT --&gt; PAYMENT_DB
    INVENTORY --&gt; INVENTORY_DB
</pre><p><strong>Workflow</strong>:</p><ol><li><strong>주문 접수</strong>: 고객이 웹/모바일 앱을 통해 주문 생성</li><li><strong>주문 이벤트 발행</strong>: Order Service 가 &lsquo;order-created&rsquo; 이벤트를 order-events 토픽에 발행</li><li><strong>재고 확인</strong>: Inventory Service 가 이벤트를 수신하여 재고 확인 후 &lsquo;inventory-reserved&rsquo; 이벤트 발행</li><li><strong>결제 처리</strong>: Payment Service 가 결제 처리 후 &lsquo;payment-completed&rsquo; 이벤트를 payment-events 토픽에 발행</li><li><strong>배송 처리</strong>: Shipping Service 가 결제 완료 이벤트를 수신하여 배송 준비 및 &lsquo;shipping-started&rsquo; 이벤트 발행</li><li><strong>알림 전송</strong>: Notification Service 가 각 단계별 이벤트를 수신하여 고객에게 상태 알림 전송</li></ol><p><strong>메시징 시스템의 역할</strong>:</p><ul><li><strong>비동기 처리</strong>: 각 서비스가 독립적으로 작업을 수행하여 전체 시스템 응답성 향상</li><li><strong>이벤트 순서 보장</strong>: Kafka 의 파티션 키를 통해 같은 주문의 이벤트 순서 보장</li><li><strong>장애 복구</strong>: 서비스 장애 시 메시지가 큐에 보존되어 복구 후 처리 재개</li><li><strong>확장성</strong>: 트래픽 증가 시 컨슈머 인스턴스 추가로 처리 능력 확장</li></ul><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><p>전자상거래 주문 처리 시스템의 Python 구현 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>  1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>  2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>  3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>  4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>  5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>  6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>  7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>  8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>  9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10> 10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11> 11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12> 12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13> 13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14> 14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15> 15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16> 16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17> 17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18> 18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19> 19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20> 20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21> 21</a>
</span><span class=lnt id=hl-11-22><a class=lnlinks href=#hl-11-22> 22</a>
</span><span class=lnt id=hl-11-23><a class=lnlinks href=#hl-11-23> 23</a>
</span><span class=lnt id=hl-11-24><a class=lnlinks href=#hl-11-24> 24</a>
</span><span class=lnt id=hl-11-25><a class=lnlinks href=#hl-11-25> 25</a>
</span><span class=lnt id=hl-11-26><a class=lnlinks href=#hl-11-26> 26</a>
</span><span class=lnt id=hl-11-27><a class=lnlinks href=#hl-11-27> 27</a>
</span><span class=lnt id=hl-11-28><a class=lnlinks href=#hl-11-28> 28</a>
</span><span class=lnt id=hl-11-29><a class=lnlinks href=#hl-11-29> 29</a>
</span><span class=lnt id=hl-11-30><a class=lnlinks href=#hl-11-30> 30</a>
</span><span class=lnt id=hl-11-31><a class=lnlinks href=#hl-11-31> 31</a>
</span><span class=lnt id=hl-11-32><a class=lnlinks href=#hl-11-32> 32</a>
</span><span class=lnt id=hl-11-33><a class=lnlinks href=#hl-11-33> 33</a>
</span><span class=lnt id=hl-11-34><a class=lnlinks href=#hl-11-34> 34</a>
</span><span class=lnt id=hl-11-35><a class=lnlinks href=#hl-11-35> 35</a>
</span><span class=lnt id=hl-11-36><a class=lnlinks href=#hl-11-36> 36</a>
</span><span class=lnt id=hl-11-37><a class=lnlinks href=#hl-11-37> 37</a>
</span><span class=lnt id=hl-11-38><a class=lnlinks href=#hl-11-38> 38</a>
</span><span class=lnt id=hl-11-39><a class=lnlinks href=#hl-11-39> 39</a>
</span><span class=lnt id=hl-11-40><a class=lnlinks href=#hl-11-40> 40</a>
</span><span class=lnt id=hl-11-41><a class=lnlinks href=#hl-11-41> 41</a>
</span><span class=lnt id=hl-11-42><a class=lnlinks href=#hl-11-42> 42</a>
</span><span class=lnt id=hl-11-43><a class=lnlinks href=#hl-11-43> 43</a>
</span><span class=lnt id=hl-11-44><a class=lnlinks href=#hl-11-44> 44</a>
</span><span class=lnt id=hl-11-45><a class=lnlinks href=#hl-11-45> 45</a>
</span><span class=lnt id=hl-11-46><a class=lnlinks href=#hl-11-46> 46</a>
</span><span class=lnt id=hl-11-47><a class=lnlinks href=#hl-11-47> 47</a>
</span><span class=lnt id=hl-11-48><a class=lnlinks href=#hl-11-48> 48</a>
</span><span class=lnt id=hl-11-49><a class=lnlinks href=#hl-11-49> 49</a>
</span><span class=lnt id=hl-11-50><a class=lnlinks href=#hl-11-50> 50</a>
</span><span class=lnt id=hl-11-51><a class=lnlinks href=#hl-11-51> 51</a>
</span><span class=lnt id=hl-11-52><a class=lnlinks href=#hl-11-52> 52</a>
</span><span class=lnt id=hl-11-53><a class=lnlinks href=#hl-11-53> 53</a>
</span><span class=lnt id=hl-11-54><a class=lnlinks href=#hl-11-54> 54</a>
</span><span class=lnt id=hl-11-55><a class=lnlinks href=#hl-11-55> 55</a>
</span><span class=lnt id=hl-11-56><a class=lnlinks href=#hl-11-56> 56</a>
</span><span class=lnt id=hl-11-57><a class=lnlinks href=#hl-11-57> 57</a>
</span><span class=lnt id=hl-11-58><a class=lnlinks href=#hl-11-58> 58</a>
</span><span class=lnt id=hl-11-59><a class=lnlinks href=#hl-11-59> 59</a>
</span><span class=lnt id=hl-11-60><a class=lnlinks href=#hl-11-60> 60</a>
</span><span class=lnt id=hl-11-61><a class=lnlinks href=#hl-11-61> 61</a>
</span><span class=lnt id=hl-11-62><a class=lnlinks href=#hl-11-62> 62</a>
</span><span class=lnt id=hl-11-63><a class=lnlinks href=#hl-11-63> 63</a>
</span><span class=lnt id=hl-11-64><a class=lnlinks href=#hl-11-64> 64</a>
</span><span class=lnt id=hl-11-65><a class=lnlinks href=#hl-11-65> 65</a>
</span><span class=lnt id=hl-11-66><a class=lnlinks href=#hl-11-66> 66</a>
</span><span class=lnt id=hl-11-67><a class=lnlinks href=#hl-11-67> 67</a>
</span><span class=lnt id=hl-11-68><a class=lnlinks href=#hl-11-68> 68</a>
</span><span class=lnt id=hl-11-69><a class=lnlinks href=#hl-11-69> 69</a>
</span><span class=lnt id=hl-11-70><a class=lnlinks href=#hl-11-70> 70</a>
</span><span class=lnt id=hl-11-71><a class=lnlinks href=#hl-11-71> 71</a>
</span><span class=lnt id=hl-11-72><a class=lnlinks href=#hl-11-72> 72</a>
</span><span class=lnt id=hl-11-73><a class=lnlinks href=#hl-11-73> 73</a>
</span><span class=lnt id=hl-11-74><a class=lnlinks href=#hl-11-74> 74</a>
</span><span class=lnt id=hl-11-75><a class=lnlinks href=#hl-11-75> 75</a>
</span><span class=lnt id=hl-11-76><a class=lnlinks href=#hl-11-76> 76</a>
</span><span class=lnt id=hl-11-77><a class=lnlinks href=#hl-11-77> 77</a>
</span><span class=lnt id=hl-11-78><a class=lnlinks href=#hl-11-78> 78</a>
</span><span class=lnt id=hl-11-79><a class=lnlinks href=#hl-11-79> 79</a>
</span><span class=lnt id=hl-11-80><a class=lnlinks href=#hl-11-80> 80</a>
</span><span class=lnt id=hl-11-81><a class=lnlinks href=#hl-11-81> 81</a>
</span><span class=lnt id=hl-11-82><a class=lnlinks href=#hl-11-82> 82</a>
</span><span class=lnt id=hl-11-83><a class=lnlinks href=#hl-11-83> 83</a>
</span><span class=lnt id=hl-11-84><a class=lnlinks href=#hl-11-84> 84</a>
</span><span class=lnt id=hl-11-85><a class=lnlinks href=#hl-11-85> 85</a>
</span><span class=lnt id=hl-11-86><a class=lnlinks href=#hl-11-86> 86</a>
</span><span class=lnt id=hl-11-87><a class=lnlinks href=#hl-11-87> 87</a>
</span><span class=lnt id=hl-11-88><a class=lnlinks href=#hl-11-88> 88</a>
</span><span class=lnt id=hl-11-89><a class=lnlinks href=#hl-11-89> 89</a>
</span><span class=lnt id=hl-11-90><a class=lnlinks href=#hl-11-90> 90</a>
</span><span class=lnt id=hl-11-91><a class=lnlinks href=#hl-11-91> 91</a>
</span><span class=lnt id=hl-11-92><a class=lnlinks href=#hl-11-92> 92</a>
</span><span class=lnt id=hl-11-93><a class=lnlinks href=#hl-11-93> 93</a>
</span><span class=lnt id=hl-11-94><a class=lnlinks href=#hl-11-94> 94</a>
</span><span class=lnt id=hl-11-95><a class=lnlinks href=#hl-11-95> 95</a>
</span><span class=lnt id=hl-11-96><a class=lnlinks href=#hl-11-96> 96</a>
</span><span class=lnt id=hl-11-97><a class=lnlinks href=#hl-11-97> 97</a>
</span><span class=lnt id=hl-11-98><a class=lnlinks href=#hl-11-98> 98</a>
</span><span class=lnt id=hl-11-99><a class=lnlinks href=#hl-11-99> 99</a>
</span><span class=lnt id=hl-11-100><a class=lnlinks href=#hl-11-100>100</a>
</span><span class=lnt id=hl-11-101><a class=lnlinks href=#hl-11-101>101</a>
</span><span class=lnt id=hl-11-102><a class=lnlinks href=#hl-11-102>102</a>
</span><span class=lnt id=hl-11-103><a class=lnlinks href=#hl-11-103>103</a>
</span><span class=lnt id=hl-11-104><a class=lnlinks href=#hl-11-104>104</a>
</span><span class=lnt id=hl-11-105><a class=lnlinks href=#hl-11-105>105</a>
</span><span class=lnt id=hl-11-106><a class=lnlinks href=#hl-11-106>106</a>
</span><span class=lnt id=hl-11-107><a class=lnlinks href=#hl-11-107>107</a>
</span><span class=lnt id=hl-11-108><a class=lnlinks href=#hl-11-108>108</a>
</span><span class=lnt id=hl-11-109><a class=lnlinks href=#hl-11-109>109</a>
</span><span class=lnt id=hl-11-110><a class=lnlinks href=#hl-11-110>110</a>
</span><span class=lnt id=hl-11-111><a class=lnlinks href=#hl-11-111>111</a>
</span><span class=lnt id=hl-11-112><a class=lnlinks href=#hl-11-112>112</a>
</span><span class=lnt id=hl-11-113><a class=lnlinks href=#hl-11-113>113</a>
</span><span class=lnt id=hl-11-114><a class=lnlinks href=#hl-11-114>114</a>
</span><span class=lnt id=hl-11-115><a class=lnlinks href=#hl-11-115>115</a>
</span><span class=lnt id=hl-11-116><a class=lnlinks href=#hl-11-116>116</a>
</span><span class=lnt id=hl-11-117><a class=lnlinks href=#hl-11-117>117</a>
</span><span class=lnt id=hl-11-118><a class=lnlinks href=#hl-11-118>118</a>
</span><span class=lnt id=hl-11-119><a class=lnlinks href=#hl-11-119>119</a>
</span><span class=lnt id=hl-11-120><a class=lnlinks href=#hl-11-120>120</a>
</span><span class=lnt id=hl-11-121><a class=lnlinks href=#hl-11-121>121</a>
</span><span class=lnt id=hl-11-122><a class=lnlinks href=#hl-11-122>122</a>
</span><span class=lnt id=hl-11-123><a class=lnlinks href=#hl-11-123>123</a>
</span><span class=lnt id=hl-11-124><a class=lnlinks href=#hl-11-124>124</a>
</span><span class=lnt id=hl-11-125><a class=lnlinks href=#hl-11-125>125</a>
</span><span class=lnt id=hl-11-126><a class=lnlinks href=#hl-11-126>126</a>
</span><span class=lnt id=hl-11-127><a class=lnlinks href=#hl-11-127>127</a>
</span><span class=lnt id=hl-11-128><a class=lnlinks href=#hl-11-128>128</a>
</span><span class=lnt id=hl-11-129><a class=lnlinks href=#hl-11-129>129</a>
</span><span class=lnt id=hl-11-130><a class=lnlinks href=#hl-11-130>130</a>
</span><span class=lnt id=hl-11-131><a class=lnlinks href=#hl-11-131>131</a>
</span><span class=lnt id=hl-11-132><a class=lnlinks href=#hl-11-132>132</a>
</span><span class=lnt id=hl-11-133><a class=lnlinks href=#hl-11-133>133</a>
</span><span class=lnt id=hl-11-134><a class=lnlinks href=#hl-11-134>134</a>
</span><span class=lnt id=hl-11-135><a class=lnlinks href=#hl-11-135>135</a>
</span><span class=lnt id=hl-11-136><a class=lnlinks href=#hl-11-136>136</a>
</span><span class=lnt id=hl-11-137><a class=lnlinks href=#hl-11-137>137</a>
</span><span class=lnt id=hl-11-138><a class=lnlinks href=#hl-11-138>138</a>
</span><span class=lnt id=hl-11-139><a class=lnlinks href=#hl-11-139>139</a>
</span><span class=lnt id=hl-11-140><a class=lnlinks href=#hl-11-140>140</a>
</span><span class=lnt id=hl-11-141><a class=lnlinks href=#hl-11-141>141</a>
</span><span class=lnt id=hl-11-142><a class=lnlinks href=#hl-11-142>142</a>
</span><span class=lnt id=hl-11-143><a class=lnlinks href=#hl-11-143>143</a>
</span><span class=lnt id=hl-11-144><a class=lnlinks href=#hl-11-144>144</a>
</span><span class=lnt id=hl-11-145><a class=lnlinks href=#hl-11-145>145</a>
</span><span class=lnt id=hl-11-146><a class=lnlinks href=#hl-11-146>146</a>
</span><span class=lnt id=hl-11-147><a class=lnlinks href=#hl-11-147>147</a>
</span><span class=lnt id=hl-11-148><a class=lnlinks href=#hl-11-148>148</a>
</span><span class=lnt id=hl-11-149><a class=lnlinks href=#hl-11-149>149</a>
</span><span class=lnt id=hl-11-150><a class=lnlinks href=#hl-11-150>150</a>
</span><span class=lnt id=hl-11-151><a class=lnlinks href=#hl-11-151>151</a>
</span><span class=lnt id=hl-11-152><a class=lnlinks href=#hl-11-152>152</a>
</span><span class=lnt id=hl-11-153><a class=lnlinks href=#hl-11-153>153</a>
</span><span class=lnt id=hl-11-154><a class=lnlinks href=#hl-11-154>154</a>
</span><span class=lnt id=hl-11-155><a class=lnlinks href=#hl-11-155>155</a>
</span><span class=lnt id=hl-11-156><a class=lnlinks href=#hl-11-156>156</a>
</span><span class=lnt id=hl-11-157><a class=lnlinks href=#hl-11-157>157</a>
</span><span class=lnt id=hl-11-158><a class=lnlinks href=#hl-11-158>158</a>
</span><span class=lnt id=hl-11-159><a class=lnlinks href=#hl-11-159>159</a>
</span><span class=lnt id=hl-11-160><a class=lnlinks href=#hl-11-160>160</a>
</span><span class=lnt id=hl-11-161><a class=lnlinks href=#hl-11-161>161</a>
</span><span class=lnt id=hl-11-162><a class=lnlinks href=#hl-11-162>162</a>
</span><span class=lnt id=hl-11-163><a class=lnlinks href=#hl-11-163>163</a>
</span><span class=lnt id=hl-11-164><a class=lnlinks href=#hl-11-164>164</a>
</span><span class=lnt id=hl-11-165><a class=lnlinks href=#hl-11-165>165</a>
</span><span class=lnt id=hl-11-166><a class=lnlinks href=#hl-11-166>166</a>
</span><span class=lnt id=hl-11-167><a class=lnlinks href=#hl-11-167>167</a>
</span><span class=lnt id=hl-11-168><a class=lnlinks href=#hl-11-168>168</a>
</span><span class=lnt id=hl-11-169><a class=lnlinks href=#hl-11-169>169</a>
</span><span class=lnt id=hl-11-170><a class=lnlinks href=#hl-11-170>170</a>
</span><span class=lnt id=hl-11-171><a class=lnlinks href=#hl-11-171>171</a>
</span><span class=lnt id=hl-11-172><a class=lnlinks href=#hl-11-172>172</a>
</span><span class=lnt id=hl-11-173><a class=lnlinks href=#hl-11-173>173</a>
</span><span class=lnt id=hl-11-174><a class=lnlinks href=#hl-11-174>174</a>
</span><span class=lnt id=hl-11-175><a class=lnlinks href=#hl-11-175>175</a>
</span><span class=lnt id=hl-11-176><a class=lnlinks href=#hl-11-176>176</a>
</span><span class=lnt id=hl-11-177><a class=lnlinks href=#hl-11-177>177</a>
</span><span class=lnt id=hl-11-178><a class=lnlinks href=#hl-11-178>178</a>
</span><span class=lnt id=hl-11-179><a class=lnlinks href=#hl-11-179>179</a>
</span><span class=lnt id=hl-11-180><a class=lnlinks href=#hl-11-180>180</a>
</span><span class=lnt id=hl-11-181><a class=lnlinks href=#hl-11-181>181</a>
</span><span class=lnt id=hl-11-182><a class=lnlinks href=#hl-11-182>182</a>
</span><span class=lnt id=hl-11-183><a class=lnlinks href=#hl-11-183>183</a>
</span><span class=lnt id=hl-11-184><a class=lnlinks href=#hl-11-184>184</a>
</span><span class=lnt id=hl-11-185><a class=lnlinks href=#hl-11-185>185</a>
</span><span class=lnt id=hl-11-186><a class=lnlinks href=#hl-11-186>186</a>
</span><span class=lnt id=hl-11-187><a class=lnlinks href=#hl-11-187>187</a>
</span><span class=lnt id=hl-11-188><a class=lnlinks href=#hl-11-188>188</a>
</span><span class=lnt id=hl-11-189><a class=lnlinks href=#hl-11-189>189</a>
</span><span class=lnt id=hl-11-190><a class=lnlinks href=#hl-11-190>190</a>
</span><span class=lnt id=hl-11-191><a class=lnlinks href=#hl-11-191>191</a>
</span><span class=lnt id=hl-11-192><a class=lnlinks href=#hl-11-192>192</a>
</span><span class=lnt id=hl-11-193><a class=lnlinks href=#hl-11-193>193</a>
</span><span class=lnt id=hl-11-194><a class=lnlinks href=#hl-11-194>194</a>
</span><span class=lnt id=hl-11-195><a class=lnlinks href=#hl-11-195>195</a>
</span><span class=lnt id=hl-11-196><a class=lnlinks href=#hl-11-196>196</a>
</span><span class=lnt id=hl-11-197><a class=lnlinks href=#hl-11-197>197</a>
</span><span class=lnt id=hl-11-198><a class=lnlinks href=#hl-11-198>198</a>
</span><span class=lnt id=hl-11-199><a class=lnlinks href=#hl-11-199>199</a>
</span><span class=lnt id=hl-11-200><a class=lnlinks href=#hl-11-200>200</a>
</span><span class=lnt id=hl-11-201><a class=lnlinks href=#hl-11-201>201</a>
</span><span class=lnt id=hl-11-202><a class=lnlinks href=#hl-11-202>202</a>
</span><span class=lnt id=hl-11-203><a class=lnlinks href=#hl-11-203>203</a>
</span><span class=lnt id=hl-11-204><a class=lnlinks href=#hl-11-204>204</a>
</span><span class=lnt id=hl-11-205><a class=lnlinks href=#hl-11-205>205</a>
</span><span class=lnt id=hl-11-206><a class=lnlinks href=#hl-11-206>206</a>
</span><span class=lnt id=hl-11-207><a class=lnlinks href=#hl-11-207>207</a>
</span><span class=lnt id=hl-11-208><a class=lnlinks href=#hl-11-208>208</a>
</span><span class=lnt id=hl-11-209><a class=lnlinks href=#hl-11-209>209</a>
</span><span class=lnt id=hl-11-210><a class=lnlinks href=#hl-11-210>210</a>
</span><span class=lnt id=hl-11-211><a class=lnlinks href=#hl-11-211>211</a>
</span><span class=lnt id=hl-11-212><a class=lnlinks href=#hl-11-212>212</a>
</span><span class=lnt id=hl-11-213><a class=lnlinks href=#hl-11-213>213</a>
</span><span class=lnt id=hl-11-214><a class=lnlinks href=#hl-11-214>214</a>
</span><span class=lnt id=hl-11-215><a class=lnlinks href=#hl-11-215>215</a>
</span><span class=lnt id=hl-11-216><a class=lnlinks href=#hl-11-216>216</a>
</span><span class=lnt id=hl-11-217><a class=lnlinks href=#hl-11-217>217</a>
</span><span class=lnt id=hl-11-218><a class=lnlinks href=#hl-11-218>218</a>
</span><span class=lnt id=hl-11-219><a class=lnlinks href=#hl-11-219>219</a>
</span><span class=lnt id=hl-11-220><a class=lnlinks href=#hl-11-220>220</a>
</span><span class=lnt id=hl-11-221><a class=lnlinks href=#hl-11-221>221</a>
</span><span class=lnt id=hl-11-222><a class=lnlinks href=#hl-11-222>222</a>
</span><span class=lnt id=hl-11-223><a class=lnlinks href=#hl-11-223>223</a>
</span><span class=lnt id=hl-11-224><a class=lnlinks href=#hl-11-224>224</a>
</span><span class=lnt id=hl-11-225><a class=lnlinks href=#hl-11-225>225</a>
</span><span class=lnt id=hl-11-226><a class=lnlinks href=#hl-11-226>226</a>
</span><span class=lnt id=hl-11-227><a class=lnlinks href=#hl-11-227>227</a>
</span><span class=lnt id=hl-11-228><a class=lnlinks href=#hl-11-228>228</a>
</span><span class=lnt id=hl-11-229><a class=lnlinks href=#hl-11-229>229</a>
</span><span class=lnt id=hl-11-230><a class=lnlinks href=#hl-11-230>230</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>Any</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>kafka</span> <span class=kn>import</span> <span class=n>KafkaProducer</span><span class=p>,</span> <span class=n>KafkaConsumer</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>kafka.errors</span> <span class=kn>import</span> <span class=n>KafkaError</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>logging</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 설정</span>
</span></span><span class=line><span class=cl><span class=n>KAFKA_BOOTSTRAP_SERVERS</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;localhost:9092&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>ORDER_TOPIC</span> <span class=o>=</span> <span class=s1>&#39;order-events&#39;</span>
</span></span><span class=line><span class=cl><span class=n>PAYMENT_TOPIC</span> <span class=o>=</span> <span class=s1>&#39;payment-events&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MessageProducer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;메시지 발행자 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span> <span class=o>=</span> <span class=n>KafkaProducer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>bootstrap_servers</span><span class=o>=</span><span class=n>KAFKA_BOOTSTRAP_SERVERS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>key_serializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>k</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>k</span><span class=p>)</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>value_serializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>v</span><span class=p>:</span> <span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>(</span><span class=n>v</span><span class=p>)</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>acks</span><span class=o>=</span><span class=s1>&#39;all&#39;</span><span class=p>,</span>  <span class=c1># 모든 복제본에서 확인</span>
</span></span><span class=line><span class=cl>            <span class=n>retries</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span>   <span class=c1># 재시도 횟수</span>
</span></span><span class=line><span class=cl>            <span class=n>batch_size</span><span class=o>=</span><span class=mi>16384</span><span class=p>,</span>  <span class=c1># 배치 크기</span>
</span></span><span class=line><span class=cl>            <span class=n>linger_ms</span><span class=o>=</span><span class=mi>10</span>       <span class=c1># 배치 대기 시간</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>publish_event</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>topic</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>event_data</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;이벤트 발행&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>future</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>send</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>topic</span><span class=o>=</span><span class=n>topic</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>key</span><span class=o>=</span><span class=n>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>value</span><span class=o>=</span><span class=n>event_data</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 동기적으로 결과 확인</span>
</span></span><span class=line><span class=cl>            <span class=n>record_metadata</span> <span class=o>=</span> <span class=n>future</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>timeout</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Event published to </span><span class=si>{</span><span class=n>record_metadata</span><span class=o>.</span><span class=n>topic</span><span class=si>}</span><span class=s2>:</span><span class=si>{</span><span class=n>record_metadata</span><span class=o>.</span><span class=n>partition</span><span class=si>}</span><span class=s2>:</span><span class=si>{</span><span class=n>record_metadata</span><span class=o>.</span><span class=n>offset</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=n>KafkaError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Failed to publish event: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;프로듀서 종료&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OrderService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;주문 서비스 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span> <span class=o>=</span> <span class=n>MessageProducer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_order</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>order_data</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;주문 생성 및 이벤트 발행&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>order_id</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;order_</span><span class=si>{</span><span class=n>order_data</span><span class=p>[</span><span class=s1>&#39;customer_id&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>_</span><span class=si>{</span><span class=nb>int</span><span class=p>(</span><span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span><span class=o>.</span><span class=n>time</span><span class=p>())</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 주문 데이터베이스 저장 (시뮬레이션)</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_save_order_to_db</span><span class=p>(</span><span class=n>order_id</span><span class=p>,</span> <span class=n>order_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 주문 생성 이벤트 발행</span>
</span></span><span class=line><span class=cl>        <span class=n>event</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;event_type&#39;</span><span class=p>:</span> <span class=s1>&#39;order_created&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;order_id&#39;</span><span class=p>:</span> <span class=n>order_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;customer_id&#39;</span><span class=p>:</span> <span class=n>order_data</span><span class=p>[</span><span class=s1>&#39;customer_id&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;items&#39;</span><span class=p>:</span> <span class=n>order_data</span><span class=p>[</span><span class=s1>&#39;items&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;total_amount&#39;</span><span class=p>:</span> <span class=n>order_data</span><span class=p>[</span><span class=s1>&#39;total_amount&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;timestamp&#39;</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>success</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>publish_event</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>topic</span><span class=o>=</span><span class=n>ORDER_TOPIC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span><span class=o>=</span><span class=n>order_id</span><span class=p>,</span>  <span class=c1># 파티션 키로 주문 ID 사용</span>
</span></span><span class=line><span class=cl>            <span class=n>event_data</span><span class=o>=</span><span class=n>event</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Order </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2> created and event published&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>order_id</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Failed to publish order creation event for </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Order event publication failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>_save_order_to_db</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>order_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>order_data</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;주문 데이터베이스 저장 시뮬레이션&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>  <span class=c1># DB 작업 시뮬레이션</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Order </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2> saved to database&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PaymentService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;결제 서비스 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span> <span class=o>=</span> <span class=n>MessageProducer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span> <span class=o>=</span> <span class=n>KafkaConsumer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>ORDER_TOPIC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>bootstrap_servers</span><span class=o>=</span><span class=n>KAFKA_BOOTSTRAP_SERVERS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>group_id</span><span class=o>=</span><span class=s1>&#39;payment-service-group&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>key_deserializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>k</span><span class=p>:</span> <span class=n>k</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>value_deserializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>v</span><span class=p>:</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>v</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>            <span class=n>auto_offset_reset</span><span class=o>=</span><span class=s1>&#39;latest&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>enable_auto_commit</span><span class=o>=</span><span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>start_consuming</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;주문 이벤트 수신 및 처리&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=s2>&#34;Payment service started consuming order events&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>message</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>event_data</span> <span class=o>=</span> <span class=n>message</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>event_data</span><span class=p>[</span><span class=s1>&#39;event_type&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;order_created&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_process_payment</span><span class=p>(</span><span class=n>event_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Error processing payment: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>_process_payment</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>order_event</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;결제 처리&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>order_id</span> <span class=o>=</span> <span class=n>order_event</span><span class=p>[</span><span class=s1>&#39;order_id&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>amount</span> <span class=o>=</span> <span class=n>order_event</span><span class=p>[</span><span class=s1>&#39;total_amount&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 결제 처리 시뮬레이션</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 결제 완료 이벤트 발행</span>
</span></span><span class=line><span class=cl>        <span class=n>payment_event</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;event_type&#39;</span><span class=p>:</span> <span class=s1>&#39;payment_completed&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;order_id&#39;</span><span class=p>:</span> <span class=n>order_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;payment_id&#39;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;pay_</span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;amount&#39;</span><span class=p>:</span> <span class=n>amount</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;status&#39;</span><span class=p>:</span> <span class=s1>&#39;completed&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;timestamp&#39;</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>success</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>publish_event</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>topic</span><span class=o>=</span><span class=n>PAYMENT_TOPIC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span><span class=o>=</span><span class=n>order_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>event_data</span><span class=o>=</span><span class=n>payment_event</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Payment completed for order </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Failed to publish payment completion event for </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>NotificationService</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;알림 서비스 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span> <span class=o>=</span> <span class=n>KafkaConsumer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>ORDER_TOPIC</span><span class=p>,</span> <span class=n>PAYMENT_TOPIC</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>bootstrap_servers</span><span class=o>=</span><span class=n>KAFKA_BOOTSTRAP_SERVERS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>group_id</span><span class=o>=</span><span class=s1>&#39;notification-service-group&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>key_deserializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>k</span><span class=p>:</span> <span class=n>k</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>value_deserializer</span><span class=o>=</span><span class=k>lambda</span> <span class=n>v</span><span class=p>:</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>v</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>            <span class=n>auto_offset_reset</span><span class=o>=</span><span class=s1>&#39;latest&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>start_consuming</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;이벤트 수신 및 알림 전송&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=s2>&#34;Notification service started consuming events&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>message</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>event_data</span> <span class=o>=</span> <span class=n>message</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_send_notification</span><span class=p>(</span><span class=n>event_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Error sending notification: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>_send_notification</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>event_data</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;알림 전송&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>event_type</span> <span class=o>=</span> <span class=n>event_data</span><span class=p>[</span><span class=s1>&#39;event_type&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>order_id</span> <span class=o>=</span> <span class=n>event_data</span><span class=p>[</span><span class=s1>&#39;order_id&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>notification_messages</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;order_created&#39;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;주문 </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>이 접수되었습니다.&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;payment_completed&#39;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;주문 </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>의 결제가 완료되었습니다.&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>event_type</span> <span class=ow>in</span> <span class=n>notification_messages</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 실제 알림 전송 (이메일, SMS, 푸시 등)</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>  <span class=c1># 알림 전송 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Notification sent: </span><span class=si>{</span><span class=n>notification_messages</span><span class=p>[</span><span class=n>event_type</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;메인 실행 함수&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>logging</span><span class=o>.</span><span class=n>basicConfig</span><span class=p>(</span><span class=n>level</span><span class=o>=</span><span class=n>logging</span><span class=o>.</span><span class=n>INFO</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 서비스 인스턴스 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>order_service</span> <span class=o>=</span> <span class=n>OrderService</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>payment_service</span> <span class=o>=</span> <span class=n>PaymentService</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>notification_service</span> <span class=o>=</span> <span class=n>NotificationService</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 백그라운드에서 컨슈머 서비스 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>payment_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>payment_service</span><span class=o>.</span><span class=n>start_consuming</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>notification_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>notification_service</span><span class=o>.</span><span class=n>start_consuming</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 주문 생성 시뮬레이션</span>
</span></span><span class=line><span class=cl>    <span class=n>order_data</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;customer_id&#39;</span><span class=p>:</span> <span class=s1>&#39;customer_123&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;items&#39;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=s1>&#39;product_id&#39;</span><span class=p>:</span> <span class=s1>&#39;prod_1&#39;</span><span class=p>,</span> <span class=s1>&#39;quantity&#39;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>&#39;price&#39;</span><span class=p>:</span> <span class=mf>29.99</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span><span class=s1>&#39;product_id&#39;</span><span class=p>:</span> <span class=s1>&#39;prod_2&#39;</span><span class=p>,</span> <span class=s1>&#39;quantity&#39;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;price&#39;</span><span class=p>:</span> <span class=mf>49.99</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;total_amount&#39;</span><span class=p>:</span> <span class=mf>109.97</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>order_id</span> <span class=o>=</span> <span class=k>await</span> <span class=n>order_service</span><span class=o>.</span><span class=n>create_order</span><span class=p>(</span><span class=n>order_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Order creation completed: </span><span class=si>{</span><span class=n>order_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 메시지 처리를 위한 대기</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Order creation failed: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정리 작업</span>
</span></span><span class=line><span class=cl>        <span class=n>order_service</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>payment_service</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>payment_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>notification_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>도전 과제</strong></th><th><strong>원인</strong></th><th><strong>영향</strong></th><th><strong>예방 방법</strong></th><th><strong>해결 방안 및 기법</strong></th></tr></thead><tbody><tr><td><strong>확장성 (Scalability)</strong></td><td>대규모 트래픽 처리 한계</td><td>사용자 증가, IoT 등 대량 이벤트 유입</td><td>처리량 저하, 메시지 지연, 큐 적체</td><td>오토 스케일링, 파티션 설계</td><td>수평 확장, 샤딩, 클러스터링, 로드밸런싱 적용</td></tr><tr><td><strong>일관성 (Ordering)</strong></td><td>메시지 순서 보장</td><td>병렬 처리, 멀티 스레드, 파티션 처리</td><td>순서 오류, 데이터 불일치, 트랜잭션 문제</td><td>파티션 키 설정, 순서 보장 필요 메시지의 단일 파티션 처리</td><td>이벤트 소싱, Kafka Streams, 순서 보장 큐 사용</td></tr><tr><td><strong>신뢰성 (Reliability)</strong></td><td>메시지 손실 및 중복 처리</td><td>네트워크 장애, Ack 누락, 재시도 로직</td><td>데이터 유실, 중복 처리, 비즈니스 로직 오류</td><td>QoS 설정, 멱등 키 사용, 중복 필터링 적용</td><td>Retry + DLQ, Idempotent Consumer 설계, 트랜잭션 처리</td></tr><tr><td><strong>보안 및 규정 준수 (Security & Compliance)</strong></td><td>데이터 노출 및 컴플라이언스 위반 위험</td><td>외부 네트워크 노출, 민감 정보 포함 메시지 전송</td><td>개인정보 유출, 법적 리스크, 신뢰도 하락</td><td>종단간 암호화 (TLS/SSL), RBAC, 접근 감사 로그</td><td>OAuth2 인증, 메시지 암호화, 데이터 마스킹 적용</td></tr><tr><td><strong>운영 복잡도 (Operational Complexity)</strong></td><td>메시지 브로커 및 클러스터 관리 복잡성</td><td>오프셋 관리, 파티션 재할당, 장애 복구 등 운영 부담</td><td>인프라 비용 증가, 장애 대응 지연</td><td>자동화 도구 도입, 표준 운영 절차 마련</td><td>Prometheus, Kafka UI, 클러스터 오토 리밸런싱 도구 활용</td></tr><tr><td><strong>클라우드 환경 적응성</strong></td><td>컨테이너 기반 클라우드 환경과의 통합</td><td>Kubernetes, 서버리스 등 클라우드 네이티브 환경 확산</td><td>기존 브로커와의 통합 어려움, 확장성 부족</td><td>클라우드 네이티브 메시징 솔루션 선택</td><td>KEDA, Strimzi, Cloud Pub/Sub 등 클라우드 친화형 메시징 도입</td></tr><tr><td><strong>실시간 처리 요구 증가</strong></td><td>고속 스트리밍 처리에 대한 대응 필요</td><td>IoT, 실시간 분석 시스템에서 초저지연 요구</td><td>기존 배치 처리 방식 한계, 시스템 병목</td><td>실시간 아키텍처 설계, 이벤트 기반 처리</td><td>Kafka Streams, Flink, Spark Streaming 등의 스트리밍 프레임워크 적용</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>분류</strong></th><th><strong>고려사항</strong></th><th><strong>주의할 점</strong></th><th><strong>권장 사항</strong></th></tr></thead><tbody><tr><td><strong>아키텍처 설계</strong></td><td>메시지 스키마 설계</td><td>스키마 변경 시 하위 호환성 문제 발생</td><td>Avro, Protocol Buffers + Schema Registry 사용, 스키마 진화 전략 수립</td></tr><tr><td></td><td>토픽 및 파티션 구성</td><td>파티션 수 변경이 어렵고 성능에 직접 영향</td><td>서비스 도메인 기반 분리, 향후 확장 고려한 설계</td></tr><tr><td></td><td>메시지 라우팅 전략</td><td>브로커 기반 복잡한 라우팅은 유지보수 어려움</td><td>라우팅 키 명확화, 라우팅은 소비자 쪽에서 처리 권장</td></tr><tr><td><strong>신뢰성 보장</strong></td><td>메시지 중복 처리</td><td>At-least-once 설정 시 중복 가능성 있음</td><td>메시지 ID 기반 멱등 처리 로직 구현</td></tr><tr><td></td><td>메시지 순서 보장</td><td>파티션 간 순서 보장 어려움</td><td>순서 보장 필요한 메시지는 단일 파티션 구성</td></tr><tr><td></td><td>오류 및 재처리 전략</td><td>실패 메시지 무한 반복 수신 위험</td><td>Dead Letter Queue 설정, 재시도 횟수 및 백오프 전략 구성</td></tr><tr><td><strong>성능 최적화</strong></td><td>배치 처리 설정</td><td>배치 크기 증가 시 메모리 과다 사용 가능</td><td>처리량과 지연시간 간 트레이드오프 고려, 적절한 배치 크기와 시간 설정</td></tr><tr><td></td><td>컨슈머 그룹 구성</td><td>파티션 수보다 많은 컨슈머는 할당 불균형 발생</td><td>파티션 수와 컨슈머 수를 균형 있게 유지</td></tr><tr><td></td><td>네트워크 지연 최적화</td><td>브로커 간 지리적 거리로 인한 지연</td><td>동일 리전 배치 또는 지연 최소화된 데이터 센터 구성</td></tr><tr><td><strong>보안 및 컴플라이언스</strong></td><td>인증 및 접근 제어</td><td>기본 설정으로 인증 및 암호화 미적용</td><td>TLS/SSL 암호화, SASL 인증, RBAC 및 ACL 정책 적용</td></tr><tr><td></td><td>민감 데이터 보호</td><td>메시지 내 개인정보 또는 비식별 데이터 포함 가능성</td><td>데이터 마스킹, 암호화, 토픽/큐 기반 접근 분리</td></tr><tr><td><strong>운영 관리</strong></td><td>모니터링 및 로깅</td><td>메트릭 부족 시 이상 탐지 어려움</td><td>Prometheus + Grafana 조합, 지표: 처리량, 지연, 실패율, 큐 깊이 등 수집</td></tr><tr><td></td><td>백업 및 복구 전략</td><td>장애 시 메시지 손실 및 복구 실패 위험</td><td>브로커 클러스터 구성, 다중 AZ 배포, 정기 백업 및 복구 테스트 실행</td></tr><tr><td></td><td>재해 복구 및 이중화 구성</td><td>단일 브로커 (SPOF) 는 전체 서비스 장애로 이어질 수 있음</td><td>클러스터 및 복제 설정, 장애 자동 전환 구성</td></tr><tr><td><strong>클라우드 환경 적응</strong></td><td>컨테이너 및 서버리스 통합</td><td>전통적 메시징 시스템과 클라우드 환경 간 호환성 문제</td><td>Strimzi, KEDA, Cloud Pub/Sub 등 클라우드 네이티브 메시징 솔루션 활용</td></tr><tr><td><strong>데이터 보존 전략</strong></td><td>메시지 저장 기간 설정</td><td>무분별한 저장은 스토리지 과부하, 너무 짧은 보존은 추적 불가</td><td>규제와 비즈니스 요구에 맞춘 TTL 설정, 아카이빙 전략 도입</td></tr><tr><td><strong>클라이언트 구성</strong></td><td>생산자/소비자 설정 최적화</td><td>기본 설정은 재시도, 타임아웃, 연결 수 제한 등 미비</td><td>커넥션 풀링, 타임아웃 설정, 재시도 횟수 및 백오프 전략 구성</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th><th><strong>권장 사항</strong></th></tr></thead><tbody><tr><td><strong>메시지 처리 최적화</strong></td><td>메시지 배치 처리</td><td>처리량 향상에 효과적이나 과도한 메모리 사용 가능</td><td>16KB~1MB 사이의 배치 크기 설정, 지연과 처리량의 균형 유지</td></tr><tr><td></td><td>비동기 처리 방식</td><td>콜백 헬이나 복잡한 흐름 관리 이슈 발생 가능</td><td>async/await, Promise 패턴 사용</td></tr><tr><td></td><td>메시지 압축</td><td>압축으로 전송량 줄이지만 CPU 사용 증가 가능</td><td>snappy, gzip 등 경량 압축 사용</td></tr><tr><td><strong>파티셔닝 및 분산</strong></td><td>파티션 수 및 키 전략</td><td>잘못된 키로 인한 핫 파티션, 순서 보장 실패 가능</td><td>예상 처리량 기반 파티션 수 설정, 균형 잡힌 키 분산 전략 수립</td></tr><tr><td></td><td>소비자 그룹 최적화</td><td>파티션 수보다 많은 컨슈머 구성은 리소스 낭비 가능</td><td>파티션 수 ≥ 컨슈머 수, 그룹 리밸런싱 최소화</td></tr><tr><td><strong>스토리지 최적화</strong></td><td>메시지 보존 기간</td><td>과도한 데이터 축적으로 디스크 공간 부족 가능</td><td>TTL 설정, 필요 메시지만 저장, 주기적 아카이빙</td></tr><tr><td></td><td>로그 압축 및 디스크 I/O</td><td>중복 키 정리 가능하나 I/O 병목 발생 가능</td><td>키 기반 로그 압축 설정, SSD/NVMe, RAID 구성 최적화</td></tr><tr><td><strong>네트워크 최적화</strong></td><td>클라이언트 - 브로커 거리</td><td>지리적 분산 시 지연 및 병목 가능</td><td>브로커와 클라이언트를 동일 리전에 배치, 전용 회선 활용</td></tr><tr><td></td><td>연결 풀링 및 분산 구성</td><td>연결 수 제한이나 단일 브로커 집중 시 병목 가능</td><td>연결 풀 크기 조절, 브로커 로드 밸런싱 및 멀티 리전 복제 구성</td></tr><tr><td></td><td>네트워크 병목</td><td>대량 트래픽 시 인터페이스 병목 및 지연 발생</td><td>고속 네트워크 인터페이스, TCP 튜닝, 로컬 클러스터 구성</td></tr><tr><td><strong>메모리 및 메시지 크기</strong></td><td>메시지 페이로드 최적화</td><td>대용량 메시지는 메모리 과다 사용 및 전송 지연 유발</td><td>10MB 이하 권장, 바이너리 포맷 활용, 대형 데이터는 외부 스토리지 참조</td></tr><tr><td></td><td>캐싱 전략</td><td>과도한 캐시로 메모리 낭비 발생 가능</td><td>메타데이터, 페이지 캐시 활용, 적절한 캐시 크기 설정</td></tr><tr><td><strong>운영 및 튜닝</strong></td><td>모니터링 및 지표 추적</td><td>병목 지점 파악 어려움</td><td>Prometheus, Grafana, Kafka UI 등으로 대시보드 구축</td></tr><tr><td></td><td>오프셋 및 커밋 전략</td><td>수동 커밋 시 중복/유실 위험 존재</td><td>자동 커밋 사용 또는 정확한 오프셋 관리 로직 구현</td></tr><tr><td></td><td>성능 테스트 및 튜닝</td><td>실시간 환경과 다른 테스트로 실제 성능 예측 어려움</td><td>부하 테스트 시나리오 정기 수행, 성능 병목 시 GC 튜닝, 힙 메모리 최적화</td></tr><tr><td><strong>비용 및 리소스</strong></td><td>리소스 사용 최적화</td><td>과도한 CPU/메모리 사용은 비용 증가로 연결</td><td>오토스케일링, 예약 인스턴스, 사용량 기반 요금제 활용</td></tr><tr><td></td><td>클라우드 환경 대응</td><td>리소스 낭비 또는 과소 할당 발생 가능</td><td>사용량 기반 모니터링, 알림 설정, 스팟/예약 인스턴스 병행</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>기술/주제</strong></th><th><strong>설명</strong></th><th><strong>출처</strong></th></tr></thead><tbody><tr><td><strong>신기술</strong></td><td>Event Mesh</td><td>글로벌 브로커 네트워크 구축으로 이벤트 라우팅 자동화 및 서비스 간 유연한 메시징 제공</td><td>SAP BTP Event Mesh</td></tr><tr><td></td><td>Serverless Messaging</td><td>AWS Lambda 와 SQS 같은 서비스로 서버리스 이벤트 기반 처리 강화</td><td>AWS IoT 등</td></tr><tr><td><strong>아키텍처</strong></td><td>CQRS</td><td>작성 (Command) 과 조회 (Query) 를 분리하여 메시징을 통한 시스템 성능과 확장성 향상</td><td>일반적 패턴</td></tr><tr><td></td><td>Event Sourcing</td><td>상태 변화를 이벤트 로그로 저장하여 시스템 상태 재구성 및 감사 가능</td><td>일반적 패턴</td></tr><tr><td></td><td>클라우드 - 엣지 하이브리드 아키텍처</td><td>Kubernetes 등에서 브로커를 엣지와 중앙 클라우드에 함께 구성해 지연 및 장애 회복성 강화</td><td>클라우드 - 엣지 통합</td></tr><tr><td><strong>성능 최적화</strong></td><td>Message Compression</td><td>LZ4, Snappy 등의 경량 압축을 통해 네트워크 대역폭 절감</td><td>실무 권장 적용</td></tr><tr><td></td><td>Zero-Copy</td><td>무복사 방식으로 네트워크 전송 성능 최적화</td><td>실무 트렌드</td></tr><tr><td><strong>보안</strong></td><td>End-to-End Encryption (E2EE)</td><td>MLS 와 같은 기술로 메시지 송수신 구간 전체에 걸쳐 암호화 보장</td><td>Messaging Layer Security</td></tr><tr><td></td><td>Message Authentication</td><td>HMAC 기반 인증으로 메시지 무결성과 인증성 확보</td><td>실무 권장 적용</td></tr><tr><td><strong>운영</strong></td><td>Schema Evolution</td><td>Schema Registry 를 활용해 버전 호환성 보장하며 데이터 구조 변경</td><td>실무 Best Practice</td></tr><tr><td></td><td>Dead Letter Queue (DLQ)</td><td>처리 실패 메시지를 격리하여 문제 분석 및 재처리 시점 확보</td><td>실무 필수 구성</td></tr></tbody></table><h3 id=학습해야-할-내용>학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#학습해야-할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>기초 이론</strong></td><td>분산 시스템 원칙 (CAP, PACELC)</td><td>CAP 정리</td><td>일관성·가용성·분할 내성 간의 트레이드 오프 이해; 설계 시 우선순위 결정에 필수</td></tr><tr><td></td><td>메시징 패턴</td><td>Pub/Sub, Request/Reply, EIP</td><td>Enterprise Integration Patterns 기반 메시징 구조 및 패턴 이해</td></tr><tr><td><strong>프로토콜</strong></td><td>AMQP, MQTT, HTTP/2</td><td>AMQP, MQTT 프로토콜</td><td>RabbitMQ 기반 AMQP 및 IoT 용 MQTT 의 특징과 차이점 파악</td></tr><tr><td><strong>메시징 브로커</strong></td><td>RabbitMQ, Kafka, Pulsar</td><td>주요 브로커 비교</td><td>시스템 종류와 특성에 따른 사용 시나리오 비교</td></tr><tr><td><strong>스트리밍 처리</strong></td><td>Kafka Streams, Apache Flink</td><td>실시간 스트림 처리 프레임워크</td><td>Kafka Streams 의 Exactly‑once, 상태 ful 처리 등 실무 활용</td></tr><tr><td><strong>고급 아키텍처</strong></td><td>마이크로서비스, 이벤트 주도 설계</td><td>CQRS, Event Sourcing</td><td>메시지 기반 비즈니스 로직 분리 및 상태 관리 아키텍처 이해</td></tr><tr><td><strong>성능 최적화</strong></td><td>파티셔닝, 컨슈머 그룹</td><td>메시지 병렬 처리 및 고가용성 확보</td><td>부하 분산과 소프트 파티션 설계를 위한 핵심 요소</td></tr><tr><td><strong>모니터링 & 운영</strong></td><td>지표 수집, 분산 추적</td><td>Prometheus + Grafana, 흐름 추적</td><td>메시징 시스템의 상태 및 운영 이슈 시각화 및 분석</td></tr><tr><td><strong>보안</strong></td><td>인증, 암호화, 권한</td><td>TLS, SASL, 접근 제어</td><td>메시지 통신 보안을 위한 인증 및 권한 관리 구조</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>메시징 패턴</strong></td><td>Fire-and-Forget</td><td>메시지 전송 후 응답을 기다리지 않는 비동기 일방향 통신</td></tr><tr><td></td><td>Scatter-Gather</td><td>요청을 여러 수신자에게 분산 전송한 후 결과를 수집하는 패턴</td></tr><tr><td></td><td>Message Aggregator</td><td>여러 개의 관련 메시지를 하나의 결과 메시지로 집계</td></tr><tr><td><strong>프로토콜 & 표준</strong></td><td>AMQP</td><td>고급 메시징 큐잉 프로토콜, 트랜잭션, QoS 지원</td></tr><tr><td></td><td>MQTT</td><td>IoT 환경에 적합한 경량 발행 - 구독 프로토콜</td></tr><tr><td></td><td>STOMP</td><td>텍스트 기반 메시징 프로토콜, 다양한 플랫폼 간 호환성 지원</td></tr><tr><td></td><td>Kafka Protocol</td><td>Kafka 고유의 고성능 메시지 전송 바이너리 프로토콜</td></tr><tr><td></td><td>JMS</td><td>Java 기반 메시징 API 표준</td></tr><tr><td></td><td>CloudEvents</td><td>이벤트 데이터 표준 형식 사양, 플랫폼 간 상호운용성 제공</td></tr><tr><td></td><td>AsyncAPI</td><td>비동기 API 메시지, 채널, 프로토콜 문서 명세 스펙</td></tr><tr><td><strong>시스템 구조</strong></td><td>Producer</td><td>메시지를 생성하여 브로커로 전송하는 컴포넌트</td></tr><tr><td></td><td>Consumer</td><td>브로커로부터 메시지를 수신하여 처리하는 컴포넌트</td></tr><tr><td></td><td>Broker</td><td>메시지를 중개, 저장, 라우팅하는 미들웨어</td></tr><tr><td></td><td>Message Channel</td><td>메시지가 흐르는 논리적 링크 / 경로</td></tr><tr><td></td><td>Message Endpoint</td><td>애플리케이션과 브로커 간의 연결 지점</td></tr><tr><td></td><td>Message Gateway</td><td>이기종 메시징 시스템 간 브리지 역할</td></tr><tr><td><strong>큐/스트림 모델</strong></td><td>Topic</td><td>Pub/Sub 방식에서 메시지를 분류하고 브로드캐스트하는 단위</td></tr><tr><td></td><td>Queue</td><td>1:1 메시지 전달을 위한 순차적 저장 구조</td></tr><tr><td></td><td>Dead Letter Queue (DLQ)</td><td>처리 실패한 메시지를 별도 저장해 재처리하거나 분석할 수 있는 큐</td></tr><tr><td></td><td>Task Queue</td><td>작업 단위를 큐에 넣고 워커가 실행하는 구조</td></tr><tr><td></td><td>Event Streaming</td><td>지속적인 이벤트 로그/스트림 저장 및 소비 구조</td></tr><tr><td><strong>파티셔닝 & 오프셋</strong></td><td>Partition</td><td>메시지를 병렬 처리하기 위한 분할 단위</td></tr><tr><td></td><td>Offset</td><td>파티션 내 메시지 위치 인덱스로 소비 추적용</td></tr><tr><td><strong>전송 보장 정책</strong></td><td>At-most-once</td><td>최대 1 회 전송, 손실 발생 가능성 있음</td></tr><tr><td></td><td>At-least-once</td><td>최소 1 회 전송, 중복 가능성 있음</td></tr><tr><td></td><td>Exactly-once</td><td>정확히 1 회만 전송 보장</td></tr><tr><td><strong>신뢰성 & 흐름 제어</strong></td><td>Idempotent</td><td>중복 수신 시에도 동일한 처리 결과를 보장하는 속성</td></tr><tr><td></td><td>Backpressure</td><td>소비자 처리 속도 부족 시 흐름 제어 메커니즘 구현</td></tr><tr><td><strong>성능 지표</strong></td><td>Throughput</td><td>단위 시간당 메시지 처리량</td></tr><tr><td><strong>보안</strong></td><td>Message Encryption</td><td>메시지 내용 암호화를 통한 데이터 보호</td></tr><tr><td></td><td>Message Authentication (HMAC 등)</td><td>메시지 무결성 및 인증 보장</td></tr><tr><td></td><td>Access Control List (ACL)</td><td>메시징 리소스에 대한 접근 권한 관리 목록</td></tr><tr><td><strong>운영 관리</strong></td><td>Message TTL</td><td>메시지 유효 기간 설정</td></tr><tr><td></td><td>Circuit Breaker</td><td>장애 발생 시 시스템 연쇄 실패 방지를 위한 보호 패턴</td></tr><tr><td><strong>고급 아키텍처 패턴</strong></td><td>CQRS</td><td>명령 (Command) 과 조회 (Query) 를 분리하는 아키텍처 패턴</td></tr><tr><td></td><td>Event Sourcing</td><td>모든 상태 변화 이벤트를 기록하여 상태 재구성 가능 구조</td></tr><tr><td></td><td>Saga</td><td>분산 환경에서 트랜잭션 조정을 위한 패턴, 마이크로서비스 조합</td></tr><tr><td></td><td>Schema Registry</td><td>메시지 스키마 버전 관리 및 호환성 보장</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.enterpriseintegrationpatterns.com/patterns/messaging/>Enterprise Integration Patterns - Messaging Patterns</a></li><li><a href=https://kafka.apache.org/documentation/>Apache Kafka Documentation</a></li><li><a href=https://aws.amazon.com/compare/the-difference-between-rabbitmq-and-kafka/>RabbitMQ vs Apache Kafka - AWS Comparison</a></li><li><a href=https://martinfowler.com/articles/patterns-of-distributed-systems/>Event-Driven Architecture - Martin Fowler</a></li><li><a href=https://microservices.io/patterns/data/event-driven-architecture.html>Microservices Pattern: Event-driven architecture</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/patterns/category/messaging>Cloud Design Patterns - Microsoft Azure</a></li><li><a href=https://dev.to/somadevtoo/9-software-architecture-patterns-for-distributed-systems-2o86>Distributed Systems Design Patterns</a></li><li><a href=https://www.ibm.com/think/topics/message-brokers>Message Broker Architecture - IBM</a></li><li><a href=https://www.rabbitmq.com/>RabbitMQ Documentation</a></li><li><a href=https://aws.amazon.com/eventbridge/>AWS EventBridge</a></li><li><a href=https://cloudevents.io/>CloudEvents Specification</a></li><li><a href=https://www.asyncapi.com/>AsyncAPI Official Site</a></li><li><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-932>KIP-932: Kafka Queues</a></li><li><a href=https://docs.nats.io/>NATS 공식 문서</a></li><li><a href=https://pulsar.apache.org/docs/en/concepts-overview/>Apache Pulsar 공식 문서</a></li><li><a href=https://docs.microsoft.com/en-us/azure/service-bus-messaging/>Azure Service Bus 문서</a></li><li><a href=https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html>AWS SQS 문서</a></li><li><a href=https://docs.aws.amazon.com/sns/latest/dg/welcome.html>AWS SNS 문서</a></li><li><a href=https://docs.aws.amazon.com/streams/latest/dev/introduction.html>AWS Kinesis 문서</a></li><li><a href=https://cloud.google.com/pubsub/docs>Google Cloud Pub/Sub 문서</a></li><li><a href=https://docs.celeryproject.org/en/stable/>Celery 공식 문서</a></li><li><a href=https://www.amqp.org/resources/specifications>AMQP 프로토콜 명세</a></li><li><a href=https://mqtt.org/mqtt-specification/>MQTT 프로토콜 명세</a></li><li><a href=https://docs.confluent.io/platform/current/schema-registry/index.html>Confluent Schema Registry 문서</a></li><li><a href=https://www.linkedin.com/pulse/messaging-systems-why-exist-benefits-challenges-santos-silva-fwj0f>Messaging Systems: Why They Exist, Benefits, and Challenges</a></li><li><a href=https://systemdesignschool.io/blog/messaging-systems>Understanding Messaging Systems - System Design School</a></li><li><a href=https://risingwave.com/blog/differences-between-messaging-queues-and-streaming-a-deep-dive/>Differences Between Messaging Queues and Streaming: A Deep Dive</a></li><li><a href=https://socprime.com/blog/message-queues-vs-streaming-systems-key-differences-and-use-cases/>Message Queues vs. Streaming Systems: Key Differences and Use Cases</a></li><li><a href=https://github.com/AutoMQ/automq/wiki/Differences-Between-Event-Streaming-and-Message-Queuing>Differences Between Event Streaming and Message Queuing - GitHub</a></li><li><a href=https://dev.to/varadasunandaibm/message-queues-vs-event-streams-key-differences-1097>Message Queues vs. Event Streams: Key Differences - DEV.to</a></li><li><a href=https://www.cloudamqp.com/blog/rabbitmq-use-cases-explaining-message-queues-and-when-to-use-them.html>RabbitMQ Use cases - CloudAMQP</a></li><li><a href=https://www.meshiq.com/optimizing-performance-and-reliability-in-messaging-systems/>Optimizing Performance and Reliability in Messaging Systems</a></li><li><a href=https://www.instaclustr.com/education/kafka-4-use-cases-and-4-real-life-examples/>Kafka 4 use cases and 4 real-life examples</a></li><li><a href=https://estuary.dev/blog/event-driven-architecture-examples/>Event-Driven Architecture Examples - Estuary</a></li><li><a href=https://access.redhat.com/products/red-hat-amq>Red Hat AMQ</a></li><li><a href=https://docs.oracle.com/cd/E19263-01/817-6440/architecture.html>Oracle Messaging Architecture Guide</a></li><li><a href=https://www.redhat.com/en/blog/architectural-messaging-patterns>Red Hat Architectural Messaging Patterns</a></li><li><a href=https://en.wikipedia.org/wiki/Messaging_pattern>Wikipedia - Messaging Pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Message_broker>Wikipedia - Message Broker</a></li><li><a href=https://en.wikipedia.org/wiki/Enterprise_Integration_Patterns>Wikipedia - Enterprise Integration Patterns</a></li><li><a href=https://en.wikipedia.org/wiki/Event-driven_messaging>Wikipedia - Event-driven Messaging</a></li><li><a href=https://dev.to/simsekahmett/messaging-patterns-101-a-comprehensive-guide-for-software-developers-2j3c>Dev.to - Messaging Patterns 101</a></li><li><a href=https://dev.to/patrick0806/choosing-the-best-messaging-system-practical-guide-286m>Dev.to - Choosing the Best Messaging System</a></li><li><a href=https://risingwave.com/blog/5-vital-challenges-faced-with-messaging-queues/>RisingWave - 5 Vital Challenges with Messaging Queues</a></li><li><a href=https://dzone.com/articles/developing-real-time-messaging-systems/>DZone - Developing Real-Time Messaging Systems</a></li><li><a href=https://www.cs.ubbcluj.ro/~dan/wsmt/Lecture8.pdf>UBB Cluj - MOM Lecture PDF</a></li><li><a href=https://ably.com/blog/chat-architecture-reliable-message-ordering>Ably - Chat Architecture for Reliable Message Ordering</a></li><li><a href=https://www.contus.com/blog/top-scalable-messaging-strategy-app/>Contus - Scalable Messaging Strategy App</a></li><li><a href=https://www.alibabacloud.com/tech-news/a/message_queue/gugz0vwtrt-queue-quandaries-solving-common-messaging-challenges>Alibaba Cloud - Queue Quandaries</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-design/>System-Design</a></li><li><a href=https://buenhyden.github.io/tags/system-components/>System-Components</a></li><li><a href=https://buenhyden.github.io/tags/messaging-systems/>Messaging-Systems</a></li><li><a href=https://buenhyden.github.io/tags/event-driven-architecture/>Event-Driven-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/asynchronous-communication/>Asynchronous-Communication</a></li><li><a href=https://buenhyden.github.io/tags/distributed-systems/>Distributed-Systems</a></li><li><a href=https://buenhyden.github.io/tags/message-broker/>Message-Broker</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/quality-attributes/run-time-reliability-and-efficiency/availability/availability-in-numbers/><span class=title>« Prev</span><br><span>Availability in Numbers</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-design/message-oriented-systems/messaging-fundamentals/queue-vs-topic/><span class=title>Next »</span><br><span>Queue vs. Topic</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>