<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cache Strategy | hyunyoun's Blog</title><meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Strategy"><meta name=description content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Cache Strategy"><meta property="og:description" content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Cache Strategy"><meta name=twitter:description content="Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cache Strategy","item":"https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Cache Strategy</h1><div class=post-description>Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.</div></header><div class=post-content><h2 id=cache-strategy>Cache Strategy<a hidden class=anchor aria-hidden=true href=#cache-strategy>#</a></h2><p><strong>Cache Strategy(캐시 전략)</strong> 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.<br>캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.</p><p>캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.</p><h3 id=캐싱-전략의-필요성>캐싱 전략의 필요성<a hidden class=anchor aria-hidden=true href=#캐싱-전략의-필요성>#</a></h3><p>캐싱은 데이터를 임시로 저장하여 반복적인 데이터 요청 시 빠르게 응답할 수 있도록 설계된 메커니즘이다. 하지만 캐싱이 제대로 설계되지 않으면 다음과 같은 문제가 발생할 수 있다:</p><ul><li><strong>Stale Data(오래된 데이터)</strong>: 원본 데이터가 변경되었지만 캐시에 반영되지 않아 잘못된 데이터를 반환.</li><li><strong>Cache Miss</strong>: 캐시에 데이터가 없어서 데이터베이스를 반복적으로 조회하는 상황.</li><li><strong>자원 낭비</strong>: 불필요한 데이터를 캐시에 저장하거나, 자주 사용되지 않는 데이터를 관리하는 데 리소스를 낭비.</li></ul><p>이를 해결하기 위해 적절한 <strong>캐싱 전략</strong>이 필요하다.</p><h3 id=주요-캐싱-전략>주요 캐싱 전략<a hidden class=anchor aria-hidden=true href=#주요-캐싱-전략>#</a></h3><h4 id=읽기-중심read-heavy-캐싱-전략>읽기 중심(Read-heavy) 캐싱 전략<a hidden class=anchor aria-hidden=true href=#읽기-중심read-heavy-캐싱-전략>#</a></h4><h5 id=cache-aside-lazy-loading>Cache-Aside (Lazy Loading)<a hidden class=anchor aria-hidden=true href=#cache-aside-lazy-loading>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>애플리케이션이 먼저 캐시를 조회.</li><li><strong>Cache Hit</strong>: 캐시에 데이터가 있으면 반환.</li><li><strong>Cache Miss</strong>: 캐시에 데이터가 없으면 데이터베이스에서 조회 후, 데이터를 반환하고 캐시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>가장 일반적으로 사용되는 전략.</li><li>캐시는 필요한 데이터만 저장하여 효율적.</li><li>캐시 장애 시에도 DB에서 데이터를 가져올 수 있어 <strong>탄력적</strong>.</li></ul></li><li><strong>단점</strong>:<ul><li>첫 요청 시 Cache Miss로 인해 지연 발생.</li><li>DB 업데이트 시 캐시를 동기화하지 않으면 오래된 데이터가 반환될 수 있음.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>전자상거래 사이트의 상품 정보 조회.</li></ul></li></ul><h5 id=read-through>Read-Through<a hidden class=anchor aria-hidden=true href=#read-through>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>애플리케이션이 캐시를 조회.</li><li><strong>Cache Hit</strong>: 캐시에 데이터가 있으면 반환.</li><li><strong>Cache Miss</strong>: 캐시가 DB에서 데이터를 가져와 저장 후 반환.</li></ul></li><li><strong>특징</strong>:<ul><li>Cache Aside와 유사하지만, DB 조회 및 캐시 갱신 작업을 캐시 시스템이 처리.</li><li>동기화 작업이 자동화되어 간단함.</li></ul></li><li><strong>단점</strong>:<ul><li>초기 요청 시 Cache Miss로 인해 지연 발생.</li><li>캐시에 의존도가 높아 장애 시 전체 시스템에 영향을 줄 수 있음.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>읽기 작업이 많은 대규모 시스템.</li></ul></li></ul><h5 id=refresh-ahead>Refresh-Ahead<a hidden class=anchor aria-hidden=true href=#refresh-ahead>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>TTL(Time-To-Live)이 만료되기 전에 자주 사용되는 데이터를 미리 갱신.</li></ul></li><li><strong>특징</strong>:<ul><li>Cache Miss를 최소화하여 성능을 향상.</li><li>자주 사용되는 데이터 예측이 중요.</li></ul></li><li><strong>단점</strong>:<ul><li>잘못된 예측으로 인해 불필요한 리소스 낭비 가능.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>실시간 날씨 정보나 주식 가격처럼 자주 갱신되는 데이터.</li></ul></li></ul><h4 id=쓰기-중심write-heavy-캐싱-전략>쓰기 중심(Write-heavy) 캐싱 전략<a hidden class=anchor aria-hidden=true href=#쓰기-중심write-heavy-캐싱-전략>#</a></h4><h5 id=write-around>Write-Around<a hidden class=anchor aria-hidden=true href=#write-around>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 DB에만 데이터를 저장하고, 읽기 요청 시 Cache Miss가 발생하면 데이터를 DB에서 가져와 캐시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>쓰기 작업에서 캐시를 건드리지 않아 단순함.</li><li>자주 읽히지 않는 데이터는 캐시에 저장되지 않음으로써 리소스 절약 가능.</li></ul></li><li><strong>단점</strong>:<ul><li>첫 읽기 요청 시 Cache Miss로 인한 지연 발생.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>로그 데이터나 이벤트 기록처럼 쓰기가 많고 읽기가 적은 경우.</li></ul></li></ul><h5 id=write-through>Write-Through<a hidden class=anchor aria-hidden=true href=#write-through>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 데이터를 DB와 캐시에 동시에 저장.</li></ul></li><li><strong>특징</strong>:<ul><li>항상 최신 상태의 데이터를 유지하며, 읽기 성능 향상에 유리.</li></ul></li><li><strong>단점</strong>:<ul><li>쓰기 작업 속도가 느려질 수 있음(캐시와 DB 동기화 비용).</li></ul></li><li><strong>사용 사례</strong>:<ul><li>사용자 프로필 정보처럼 읽기와 쓰기가 모두 중요한 경우.</li></ul></li></ul><h5 id=write-back-write-behind>Write-Back (Write Behind)<a hidden class=anchor aria-hidden=true href=#write-back-write-behind>#</a></h5><ul><li><strong>동작 방식</strong>:<ul><li>쓰기 작업 시 데이터를 먼저 캐시에 저장하고, 일정 시간 후 또는 특정 조건에서 DB에 반영(비동기).</li></ul></li><li><strong>특징</strong>:<ul><li>쓰기 성능이 매우 빠름(캐시에만 기록).</li><li>여러 쓰기를 묶어 한 번에 DB에 반영하여 부하 감소 가능.</li></ul></li><li><strong>단점</strong>:<ul><li>동기화 이전에 장애가 발생하면 데이터 유실 가능성 존재.</li></ul></li><li><strong>사용 사례</strong>:<ul><li>실시간 로그 처리 또는 대량 쓰기가 필요한 환경.</li></ul></li></ul><h4 id=시간-기반time-based-전략>시간 기반(Time-based) 전략<a hidden class=anchor aria-hidden=true href=#시간-기반time-based-전략>#</a></h4><h5 id=ttltime-to-live>TTL(Time-To-Live)<a hidden class=anchor aria-hidden=true href=#ttltime-to-live>#</a></h5><p>각 항목에 유효 기간을 설정하여 일정 시간이 지나면 자동으로 무효화한다.<br>간단하고 효과적이나, 잘못된 TTL 설정은 성능 저하를 초래할 수 있다.</p><h4 id=공간-기반space-based-전략>공간 기반(Space-based) 전략<a hidden class=anchor aria-hidden=true href=#공간-기반space-based-전략>#</a></h4><h5 id=lru-least-recently-used>LRU (Least Recently Used)<a hidden class=anchor aria-hidden=true href=#lru-least-recently-used>#</a></h5><p>가장 오래 사용되지 않은 데이터를 제거하여 공간을 확보한다.<br>자주 사용되는 데이터를 우선적으로 유지한다.</p><h5 id=lfu-least-frequently-used>LFU (Least Frequently Used)<a hidden class=anchor aria-hidden=true href=#lfu-least-frequently-used>#</a></h5><p>가장 적게 참조된 데이터를 제거한다.</p><h3 id=주요-고려사항>주요 고려사항<a hidden class=anchor aria-hidden=true href=#주요-고려사항>#</a></h3><ol><li><p>데이터의 특성 분석:</p><ul><li>자주 변경되는 데이터인가?</li><li>읽기와 쓰기의 비율은 어떠한가?</li></ul></li><li><p>시스템 요구사항 분석:</p><ul><li>고성능이 필요한지, 일관성이 더 중요한지 판단.</li></ul></li><li><p>장애 대응 계획:</p><ul><li>Cache Miss나 장애 발생 시 DB로의 부하 증가를 어떻게 처리할 것인지 계획 필요.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache-Aside</h2></header><div class=entry-content><p>Cache-Aside Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.
Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.
이 패턴은 “Lazy Loading” 또는 “Look Aside” 패턴으로도 알려져 있다.
Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside
동작 방식 애플리케이션이 데이터를 요청한다. 캐시를 먼저 확인한다. 캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다. 캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다. 데이터베이스에서 가져온 데이터를 캐시에 저장한다. 데이터를 애플리케이션에 반환한다. 구현 시 고려사항 캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다. TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다. 캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다. 동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다. 장점 성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다. 데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다. 유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다. 장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다. 단점 초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다. 데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다. 추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다. 사용 예시 동시성 처리와 오류 복구를 포함한 버전
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache-Aside" href=https://buenhyden.github.io/posts/system-design/system-design-fundamentals/caching/cache-strategy/access-strategy/cache-aside/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>