<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Horizontal vs. Vertical Scaling | hyunyoun's Blog</title><meta name=keywords content="System-Design,Fundamentals,Performance-vs-Scalability"><meta name=description content="수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Horizontal vs. Vertical Scaling"><meta property="og:description" content="수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-03T15:32:00+00:00"><meta property="article:modified_time" content="2025-04-03T15:32:00+00:00"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Performance-vs-Scalability"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Horizontal vs. Vertical Scaling"><meta name=twitter:description content="수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Horizontal vs. Vertical Scaling","item":"https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Horizontal vs. Vertical Scaling","name":"Horizontal vs. Vertical Scaling","description":"수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다.","keywords":["System-Design","Fundamentals","Performance-vs-Scalability"],"articleBody":"Horizontal vs. Vertical Scaling 시스템의 확장성은 성능과 안정성에 직접적인 영향을 미친다.\n수평/수직 확장은 시스템 확장성을 달성하는 상호보완적 전략이다. 수직 확장은 단일 노드의 CPU/RAM/Storage 업그레이드로 신속한 대응이 가능하나 하드웨어 한계와 Single Point of Failure(SPOF) 리스크가 존재한다. 수평 확장은 분산 아키텍처 기반으로 무한 확장성과 내결함성을 제공하나 데이터 일관성 유지가 어렵다.\n2025 년 트렌드로는 Kubernetes 기반 Hybrid Scaling(60% 기업 채택) 과 AI-Driven Auto-scaling(리소스 사용률 40% 개선) 이 주목받으며, Netflix 는 두 방식을 결합해 초당 5TB 스트리밍 데이터를 처리한다.\n목적 및 필요성 확장성의 중요성 확장성은 시스템이 증가하는 부하나 요청을 성능 저하 없이 처리할 수 있는 능력을 의미한다.\n확장성은 다음과 같은 이유로 중요하다:\n사용자 경험 유지: 트래픽 증가 시에도 일관된 응답 시간과 성능을 유지하여 사용자 경험을 저하시키지 않는다. 비즈니스 성장 지원: 비즈니스가 성장함에 따라 증가하는 수요를 효율적으로 처리할 수 있어야 한다. 비용 효율성: 적절한 확장 전략을 통해 필요한 리소스만 사용하여 비용을 최적화할 수 있다. 시스템 안정성: 부하 증가로 인한 시스템 장애나 성능 저하를 방지한다. 경쟁 우위 확보: 빠르고 안정적인 서비스를 제공함으로써 경쟁 우위를 확보할 수 있다. 수평적 확장 Vs 수직적 확장의 필요성 두 가지 확장 접근법은 서로 다른 상황과 요구사항에 대응하기 위해 필요하다:\n다양한 워크로드 특성: 다양한 유형의 워크로드와 애플리케이션에 따라 적합한 확장 전략이 달라진다. 비용 구조 최적화: 각 접근법은 서로 다른 비용 구조를 가지고 있어, 비즈니스 요구사항과 예산에 맞는 전략을 선택할 수 있다. 기술적 제약 대응: 특정 애플리케이션이나 기술 스택은 특정 확장 방식에 더 적합할 수 있다. 가용성 및 내결함성 요구사항: 고가용성이 필요한 시스템은 수평적 확장을 통한 중복성을 활용할 수 있다. 지리적 분산 요구: 글로벌 서비스는 지리적으로 분산된 인프라를 통해 지연 시간을 줄이고 가용성을 높일 수 있다. Horizontal vs. Vertical Scaling 항목 수평 확장 (Horizontal Scaling) 수직 확장 (Vertical Scaling) 확장 방법 서버 수를 늘려 부하 분산 기존 서버의 성능 향상 구조 변경 필요성 높음 (분산 시스템 구조 필요) 낮음 (기존 구조 유지 가능) 확장 한계 높음 (서버 추가로 확장 가능) 하드웨어 한계로 제한적 가용성 높음 (서버 장애 시 다른 서버로 대체 가능) 낮음 (단일 서버 장애 시 전체 서비스 영향) 비용 초기 비용 높음 (서버 추가 및 인프라 구축) 초기 비용 낮음 (하드웨어 업그레이드 비용) 유지보수 복잡함 (여러 서버 관리 필요) 간단함 (단일 서버 관리) 수평적 확장 (Horizontal Scaling) 수평적 확장은 시스템의 처리 능력을 향상시키기 위해 더 많은 서버나 노드를 추가하는 방식이다.\n수평적 확장의 핵심 개념은 다음과 같다:\n분산 처리: 여러 서버나 노드에 작업 부하를 분산시켜 전체 시스템의 처리 능력을 향상시킨다. 스케일 아웃 (Scale-out): 시스템 용량을 확장하기 위해 더 많은 서버나 인스턴스를 추가하는 과정을 의미한다. 로드 밸런싱 (Load Balancing): 여러 서버 간에 트래픽이나 작업량을 균등하게 분배하는 기술로, 수평적 확장의 핵심 구성 요소이다. 샤딩 (Sharding): 데이터베이스 컨텍스트에서 데이터를 여러 서버에 분산 저장하는 기술이다. 레플리케이션 (Replication): 데이터나 서비스의 복제본을 여러 서버에 배포하여 가용성과 내결함성을 향상시키는 기술이다. 탄력성 (Elasticity): 트래픽이나 수요 변화에 따라 자동으로 리소스를 추가하거나 제거할 수 있는 능력이다. 수평적 확장의 주요 기능 및 역할 부하 분산: 여러 서버나 노드에 걸쳐 작업 부하를 균등하게 분산시킨다. 고가용성 확보: 여러 인스턴스를 통해 단일 장애점을 제거하고 시스템 가용성을 향상시킨다. 지리적 분산 지원: 다양한 지역에 서버를 배치하여 지연 시간을 최소화하고 지역적 장애에 대응할 수 있다. 탄력적 확장: 수요 변화에 따라 리소스를 동적으로 추가하거나 제거할 수 있다. 비용 효율적인 확장: 필요에 따라 점진적으로 리소스를 추가할 수 있어 비용을 효율적으로 관리할 수 있다. 수평적 확장의 주요 특징 분산 아키텍처: 시스템이 여러 노드에 분산되어 있어 개별 노드의 장애가 전체 시스템에 영향을 미치지 않는다. 선형적 확장성: 노드 추가에 따라 처리 능력이 선형적으로 증가할 수 있다. 자동화 지원: 클라우드 환경에서는 자동 확장 기능을 통해 수요에 따라 자동으로 인스턴스를 추가하거나 제거할 수 있다. 로드 밸런싱 필요: 여러 서버 간에 트래픽을 균등하게 분배하기 위한 로드 밸런싱 메커니즘이 필요하다. 데이터 일관성 과제: 분산 환경에서 데이터 일관성을 유지하는 것이 복잡할 수 있다. 수평적 확장의 핵심 원칙 분산 처리: 작업 부하를 여러 노드에 분산시켜 전체 시스템의 처리 능력을 향상시킨다. 로드 밸런싱: 요청이나 작업을 여러 서버에 균등하게 분배하여 개별 서버의 부하를 최소화한다. 독립적 확장: 각 구성 요소나 서비스를 독립적으로 확장할 수 있어 리소스를 효율적으로 활용할 수 있다. 내결함성: 여러 인스턴스를 통해 단일 장애점을 제거하고 전체 시스템의 가용성을 향상시킨다. 데이터 샤딩: 데이터를 여러 서버에 분산 저장하여 데이터 처리 능력을 향상시킨다. 수평적 확장의 작동 원리 노드 추가: 시스템 용량을 확장하기 위해 서버나 노드를 추가한다. 로드 밸런싱: 로드 밸런서는 들어오는 요청을 여러 서버에 분배한다. 이를 위해 라운드 로빈, 최소 연결, 가중치 기반 등 다양한 알고리즘을 사용할 수 있다. 세션 관리: 사용자 세션을 유지하기 위해 세션 클러스터링, 스티키 세션, 세션리스 아키텍처 등의 방법을 사용한다. 데이터 분산: 데이터베이스 샤딩이나 파티셔닝을 통해 데이터를 여러 서버에 분산 저장한다. 서비스 복제: 동일한 서비스의 여러 인스턴스를 실행하여 부하를 분산시킨다. 자동 확장: 트래픽이나 리소스 사용량에 따라 자동으로 인스턴스를 추가하거나 제거한다. 수평적 확장 다이어그램 수평 확장은 로드 밸런서를 통해 여러 서버에 트래픽을 분산시키는 구조로, 각 서버는 동일한 기능을 수행하며, 서버 수를 늘려 확장성을 확보한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +-------------------+ +-------------------+ | 클라이언트 |-----\u003e| 로드 밸런서 | +-------------------+ +-------------------+ | | +------------------------+------------------------+ | | | +-----------------+ +-----------------+ +-----------------+ | 서버 인스턴스 1 | | 서버 인스턴스 2 | | 서버 인스턴스 3 | +-----------------+ +-----------------+ +-----------------+ | | | | | | +------------------------+------------------------+ | V +-------------------+ | 분산 데이터 스토리지 | +-------------------+ 수평적 확장 아키텍처 수평적 확장 아키텍처는 여러 서버나 노드로 구성되며, 이들은 함께 작동하여 부하를 분산시키고 전체 시스템의 처리 능력을 향상시킵니다.\n클라이언트 계층: 사용자나 클라이언트 애플리케이션으로부터 요청을 받는다. 로드 밸런싱 계층: 들어오는 요청을 여러 서버에 분배한다. 하드웨어 로드 밸런서나 소프트웨어 로드 밸런서를 사용할 수 있다. 애플리케이션 계층: 여러 서버 인스턴스가 동일한 애플리케이션 코드를 실행하여 요청을 처리한다. 데이터 계층: 데이터베이스 서버가 데이터를 저장하고 관리합니다. 샤딩이나 레플리케이션을 통해 데이터를 분산 저장할 수 있다. 캐싱 계층 (선택 사항): 자주 액세스하는 데이터를 캐싱하여 데이터베이스 부하를 줄이고 응답 시간을 개선한다. 모니터링 및 관리 계층: 시스템 상태를 모니터링하고 문제를 감지하며 자동 확장을 관리한다. 수평적 확장 구조\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 +-------------------+ | 사용자 요청 | +-------------------+ | V +-------------------+ +-------------------+ | 자동 확장 그룹 관리 |\u003c-----------| 로드 밸런서 | +-------------------+ +-------------------+ | | | +---------------------+---------------------+ | | | | | +-------------+ +-------------+ +-------------+ +---\u003e| 웹 서버 인스턴스 | | 웹 서버 인스턴스 | | 웹 서버 인스턴스 | +-------------+ +-------------+ +-------------+ | | | | | | +---------------------+---------------------+ | V +-------------------+ | 캐시 계층 | +-------------------+ | V +-------------------+ | 데이터베이스 | | (샤딩/복제) | +-------------------+ 수평적 확장의 주요 구성 요소 구성 요소 기능 역할 로드 밸런서 (Load Balancer) 요청을 여러 서버에 균등하게 분배 트래픽 분산, 서버 가용성 모니터링, 장애 서버 감지 및 트래픽 우회 웹/애플리케이션 서버 클러스터 클라이언트 요청 처리 동일한 애플리케이션 실행, 비즈니스 로직 수행, 응답 생성 분산 데이터베이스 시스템 데이터 저장 및 관리 샤딩으로 데이터 분산, 레플리케이션으로 복제, 데이터 정합성 유지 분산 캐시 자주 액세스하는 데이터 캐싱 데이터베이스 부하 감소, 빠른 응답 제공, 일관된 캐시 동기화 세션 관리 시스템 사용자 세션 유지 및 상태 관리 분산 환경에서도 세션 공유, 인증 상태 유지 자동 확장 그룹 (Auto Scaling) 서버 인스턴스 수를 자동으로 조절 리소스 모니터링, 수요에 따른 서버 자동 생성 및 제거 서비스 디스커버리 동적으로 서비스 인스턴스 감지 및 등록 서비스 레지스트리 유지, 새 인스턴스 자동 등록 및 검색 클라우드 스토리지 정적 파일 저장 및 백업 지원 확장 가능한 저장 공간 제공, 중복성 확보, 백업/복구 기능 제공 장단점 구분 항목 설명 ✅ 장점 무한한 확장성 서버를 계속 추가할 수 있어 트래픽 증가에 유연하게 대응 가능 고가용성 다수의 서버가 분산되어 있어 단일 장애점 (SPOF, Single Point of Failure) 이 없음 비용 효율성 고사양 장비 대신 저비용 장비 여러 대로 구성 가능 탄력적 확장 자동 확장을 통해 트래픽 변화에 따라 빠르게 대응 가능 지리적 분산 다양한 지역에 서버를 배치해 사용자 지연 시간 최소화 가능 무중단 확장 운영 중인 시스템에 영향을 주지 않고 서버를 추가할 수 있음 ⚠ 단점 아키텍처 복잡성 분산 시스템 설계 및 유지 관리가 복잡해짐 데이터 일관성 문제 여러 노드 간 동기화가 어렵고 일관성 모델 선택이 필요함 네트워크 오버헤드 서버 간 통신 및 데이터 동기화에 따른 트래픽 증가 로드 밸런싱 필요 트래픽을 균등 분산시키기 위한 수평적 확장의 유형 확장 유형 설명 특징 적용 사례 클러스터 기반 확장 여러 서버를 클러스터로 구성하여 동일 애플리케이션 실행 로드 밸런싱, 서버 간 상태 공유 가능, 일관된 사용자 경험 제공 웹 서버 클러스터, 애플리케이션 서버 팜 마이크로서비스 기반 확장 애플리케이션을 독립적인 서비스 단위로 분할하여 각각 확장 서비스 단위 확장 가능, 장애 격리 용이, 기술 스택 독립성 확보 마이크로서비스 아키텍처, SOA(Service-Oriented Architecture) 샤딩 기반 확장 데이터를 여러 데이터베이스에 나누어 저장 키/범위/지역 기반 샤딩 전략 활용, 쓰기 확장성 우수 대규모 사용자 DB, 분산 빅데이터 플랫폼 레플리케이션 기반 확장 동일한 데이터를 여러 서버에 복제하여 읽기 성능 향상 읽기 부하 분산, 장애 대응 강화, 다양한 복제 모델 (Master-Slave, Multi-Master) 사용 읽기 집약 시스템, CDN, 글로벌 콘텐츠 서비스 서버리스 확장 함수 단위 코드 실행, 요청에 따라 자동 확장 사용량 기반 과금, 무서버 인프라, 이벤트 기반 실행 AWS Lambda, Azure Functions, GCP Functions 수직적 확장 (Vertical Scaling) 수직적 확장은 기존 서버나 시스템의 성능을 향상시키기 위해 더 많은 리소스를 추가하는 방식이다.\n수직적 확장의 핵심 개념은 다음과 같다:\n스케일 업 (Scale-up): 기존 서버의 CPU, 메모리, 스토리지와 같은 하드웨어 리소스를 증가시키는 과정을 의미한다. 단일 노드 강화: 단일 시스템의 처리 능력을 향상시켜 더 많은 요청이나 작업을 처리할 수 있게 한다. 하드웨어 업그레이드: 더 강력한 CPU, 더 많은 RAM, 더 빠른 스토리지 등으로 서버를 업그레이드하는 과정이다. 소프트웨어 최적화: 하드웨어 리소스 외에도 소프트웨어 최적화를 통해 시스템 성능을 향상시키는 접근법도 수직적 확장에 포함될 수 있다. 물리적 한계: 수직적 확장은 단일 시스템의 물리적 한계에 제약을 받으며, 특정 지점 이상으로 확장하기 어렵다. 무중단 확장의 어려움: 일반적으로 수직적 확장은 시스템 다운타임을 필요로 하는 경우가 많다. 수직적 확장의 주요 기능 및 역할 단일 시스템 성능 향상: 개별 서버의 처리 능력을 향상시켜 더 많은 작업을 처리할 수 있다. 단순한 아키텍처 유지: 추가 서버 없이 기존 시스템을 강화하므로 아키텍처를 단순하게 유지할 수 있다. 관리 복잡성 감소: 관리해야 할 서버 수가 적어 운영 복잡성이 감소한다. 특정 워크로드 최적화: 메모리 집약적이거나 CPU 집약적인 특정 워크로드에 대해 최적화된 리소스 할당을 제공한다. 즉각적인 성능 향상: 하드웨어 업그레이드를 통해 즉각적인 성능 향상을 달성할 수 있다. 수직적 확장의 주요 특징 단일 시스템 강화: 하나의 서버나 시스템의 성능과 용량을 향상시키는 데 중점을 둔다. 하드웨어 한계: 확장성은 단일 서버에 추가할 수 있는 하드웨어 리소스의 물리적 한계에 제약을 받는다. 다운타임 가능성: 일반적으로 하드웨어 업그레이드 시 시스템 다운타임이 발생할 수 있다. 즉각적인 성능 향상: 하드웨어 리소스 증가 후 즉시 성능 향상을 체감할 수 있다. 관리 용이성: 추가 서버나 분산 시스템 관리가 필요 없어 관리가 상대적으로 단순하다. 수직적 확장의 핵심 원칙 리소스 집중화: 단일 시스템에 리소스를 집중시켜 성능을 최대화한다. 단순성 유지: 추가 서버 없이 기존 시스템을 강화하여 아키텍처 단순성을 유지한다. 하드웨어 최적화: CPU, 메모리, 스토리지 등의 하드웨어 리소스를 최적화하여 성능을 향상시킨다. 소프트웨어 최적화: 하드웨어 외에도 소프트웨어 최적화를 통해 시스템 성능을 향상시킨다. 자원 활용 극대화: 단일 시스템의 자원 활용을 극대화하여 효율성을 높인다. 수직적 확장의 작동 원리 하드웨어 업그레이드: CPU, 메모리, 스토리지 등의 하드웨어 리소스를 증가시킨다. 서버 교체: 기존 서버를 더 강력한 서버로 교체하거나 업그레이드된 서버로 워크로드를 이전한다. 리소스 할당 최적화: 시스템 리소스 할당을 최적화하여 성능을 향상시킨다. 소프트웨어 최적화: 코드 최적화, 캐싱, 인덱싱 등의 소프트웨어 최적화 기법을 적용한다. 하드웨어 통합: 여러 물리적 서버를 하나의 더 강력한 서버로 통합할 수 있다. 가상화 활용: 가상화 기술을 활용하여 하드웨어 리소스를 효율적으로 활용한다. 수직적 확장 다이어그램 수직 확장은 단일 서버의 하드웨어를 업그레이드하여 성능을 향상시키는 구조로, 구조 변경 없이 빠른 성능 향상이 가능하지만, 하드웨어 한계로 인해 확장성에 제한이 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 +-------------------+ | 클라이언트 | +-------------------+ | V +-------------------+ | 서버 | | | | CPU: 8코어 -\u003e 16코어 | | RAM: 16GB -\u003e 64GB | | SSD: 1TB -\u003e 4TB | +-------------------+ | V +-------------------+ | 데이터 스토리지 | +-------------------+ 수직적 확장 아키텍처 수직적 확장 아키텍처는 단일 서버의 성능과 용량을 강화하는 데 중점을 둔다.\n클라이언트 계층: 사용자나 클라이언트 애플리케이션으로부터 요청을 받는다. 애플리케이션 계층: 강화된 단일 서버가 모든 애플리케이션 코드를 실행하여 요청을 처리한다. 데이터 계층: 강화된 단일 데이터베이스 서버가 모든 데이터를 저장하고 관리한다. 백업 및 복구 계층: 시스템 장애 시 데이터 손실을 방지하기 위한 백업 및 복구 메커니즘이 필요하다. 모니터링 계층: 시스템 성능과 리소스 사용량을 모니터링하여 추가 업그레이드가 필요한 시점을 파악한다. 수직적 확장 구조\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 +-------------------+ | 사용자 요청 | +-------------------+ | V +-------------------+ | 고성능 서버 | | | | - 다중 코어 CPU | | - 대용량 메모리 | | - 고속 SSD | | - 고대역폭 네트워크 | +-------------------+ | V +-------------------+ | 고성능 DB | | | | - 고성능 스토리지 | | - 최적화된 인덱싱 | | - 메모리 내 캐싱 | +-------------------+ | V +-------------------+ | 백업 및 복구 | +-------------------+ 수직적 확장의 주요 구성 요소 구성 요소 기능 역할 고성능 서버 하드웨어 요청 처리 및 애플리케이션 실행 다중 코어 CPU, 대용량 메모리, 고속 스토리지로 고속 처리 환경 제공 고성능 데이터베이스 서버 데이터 저장 및 관리 대량 데이터 처리, 고속 쿼리 수행, 트랜잭션 안정성 확보 서버 가상화 환경 하드웨어 리소스의 효율적 활용 리소스 동적 할당, 워크로드 격리, 효율적 인프라 운영 로컬 캐시 자주 사용하는 데이터 캐싱 디스크 I/O 감소, 메모리 기반 데이터 응답 속도 향상 백업 및 복구 시스템 정기적인 데이터 백업 및 복구 데이터 무결성 보장, 장애 복구 지원, 재해 대비 고성능 네트워크 인터페이스 네트워크 통신 최적화 고대역폭 전송, 지연 최소화, 대용량 데이터 처리 성능 모니터링 시스템 시스템 자원 및 성능 상태 실시간 모니터링 병목 지점 감지, 리소스 분석, 업그레이드 타이밍 평가 최적화된 운영 체제 및 소프트웨어 하드웨어 리소스의 효율적 활용 및 시스템 안정성 유지 프로세스 스케줄링, 커널 최적화, 성능 및 자원 활용 최적화 장단점 구분 항목 설명 ✅ 장점 아키텍처 단순성 서버 한 대에서 운영되므로 시스템 구조가 단순하고 이해하기 쉬움 구현 용이성 리소스만 추가하면 되므로 코드나 구조 변경 없이 확장 가능 낮은 네트워크 지연 모든 처리 및 데이터가 단일 노드에서 수행되어 레이턴시가 낮음 데이터 일관성 용이 단일 시스템 기반이므로 데이터 정합성 유지가 쉬움 소프트웨어 호환성 대부분의 기존 애플리케이션과 호환되며 수정 없이 운영 가능 관리 오버헤드 감소 다수의 노드를 관리할 필요가 없어 관리 및 운영 복잡성이 줄어듦 ⚠ 단점 물리적 한계 단일 서버의 CPU, 메모리, 디스크 등 하드웨어에는 확장 한계가 존재 비용 비효율 고성능 장비는 가격이 급격히 비싸지며 성능 대비 효율이 떨어질 수 있음 다운타임 발생 가능 리소스 추가나 유지보수 시 시스템 재시작 등으로 인한 중단이 필요할 수 있음 단일 장애점 존재 서버에 문제가 생기면 전체 서비스가 중단될 위험이 있음 지리적 제약 단일 위치에서 처리되기 때문에 글로벌 사용자 대상 성능 보장이 어려움 자원 낭비 가능성 최대 트래픽에 맞춰 리소스를 고정하면 비성수기 동안 과잉 리소스가 낭비될 수 있음 수직적 확장의 유형 확장 방식 설명 특징 적용 사례 하드웨어 업그레이드 물리 서버의 CPU, 메모리, 스토리지 등 리소스를 증설 물리적 한계 존재, 다운타임 발생 가능, 즉각적인 성능 향상 온프레미스 서버, 물리 DB 서버 가상 머신 확장 가상 머신의 vCPU, vRAM 리소스를 증설 유연한 리소스 할당, 하이퍼바이저 오버헤드, 라이브 마이그레이션 가능 클라우드 VM, VMware, Hyper-V 기반 환경 컨테이너 리소스 확장 컨테이너 단위로 CPU/메모리 할당량 증설 세분화된 자원 제어, 빠른 확장 적용, 호스트 자원 한계 내에서만 확장 가능 Docker, Kubernetes Pod 데이터베이스 수직 확장 DB 서버의 메모리/CPU 증가, 캐시 및 인덱스 성능 최적화 쿼리 성능 향상, 캐시 크기 증가, 단일 노드 기반 확장 PostgreSQL, MySQL, Redis 등 관계형/인메모리 DB 클라우드 인스턴스 유형 변경 기존 인스턴스를 고사양 인스턴스 유형으로 교체 간편한 업그레이드, 다양한 스펙 선택, 요금 증가 가능 AWS EC2, Azure VM, Google Compute Engine 등 실무 적용 예시 산업 적용 사례 확장 유형 구현 방식 결과 및 이점 전자상거래 블랙프라이데이 세일 대비 수평적 확장 자동 확장 그룹 구성, 로드 밸런서 도입, 데이터베이스 읽기 복제본 추가 트래픽 증가에도 안정적 서비스 제공, 판매 기회 손실 방지, 고객 경험 향상 금융 서비스 핵심 거래 시스템 성능 향상 수직적 확장 고성능 서버 도입, 인메모리 데이터베이스 적용, SSD 스토리지 확장 트랜잭션 처리 시간 단축, 안정성 향상, 데이터 무결성 보장 미디어 스트리밍 글로벌 콘텐츠 전송 최적화 수평적 확장 CDN 활용, 지역별 서버 배포, 콘텐츠 복제 지연 시간 감소, 사용자 경험 개선, 대역폭 비용 최적화 게임 서비스 새 게임 출시에 따른 인프라 준비 하이브리드 확장 게임 서버는 수평적 확장, 데이터베이스는 수직적 확장 플레이어 수요 대응, 게임 지연 최소화, 데이터 일관성 유지 헬스케어 의료 영상 처리 시스템 수직적 확장 GPU 서버 도입, 대용량 메모리 확장, 고속 스토리지 적용 영상 처리 속도 향상, 진단 시간 단축, 정확도 개선 소셜 미디어 사용자 증가에 따른 피드 시스템 확장 수평적 확장 마이크로서비스 아키텍처, 데이터 샤딩, 캐시 클러스터 실시간 피드 업데이트, 개인화 서비스 제공, 사용자 증가에도 안정적 서비스 SaaS 다중 테넌트 애플리케이션 확장 수평적 확장 테넌트별 데이터 분리, 서버 클러스터 구성, API 게이트웨이 도입 테넌트 격리, 개별 확장 가능, 리소스 효율적 사용 IoT 센서 데이터 처리 시스템 분산 확장 에지 컴퓨팅, 데이터 분산 처리, 시계열 데이터베이스 실시간 데이터 처리, 네트워크 대역폭 최적화, 확장성 확보 AI/ML 모델 학습 인프라 수직적 확장 고성능 GPU 클러스터, 대용량 메모리, 고속 스토리지 학습 시간 단축, 복잡한 모델 처리 가능, 정확도 향상 정부/공공 세금 신고 시스템 계절적 수평 확장 피크 시즌에 클라우드 인스턴스 추가, 로드 밸런싱, 캐싱 신고 기간 중 안정적 서비스, 비용 효율성, 사용자 만족도 향상 활용 사례 사례 1 시나리오: 대형 전자상거래 플랫폼이 연례 세일 이벤트를 앞두고 트래픽이 평소보다 10 배 이상 증가할 것으로 예상된다. 이 플랫폼은 사용자가 제품을 검색하고, 구매하며, 리뷰를 남기는 기능을 제공한다. 이벤트 기간 동안 시스템 안정성을 유지하면서 사용자 경험을 최적화하기 위한 확장 전략이 필요하다.\n수평적 확장 접근법 계층 접근 방식 설명 웹/애플리케이션 서버 자동 확장 그룹 구성 트래픽 변화에 따라 서버 인스턴스를 자동으로 추가/제거 로드 밸런서 구성 여러 가용 영역 (AZ) 에 걸쳐 트래픽을 분산하여 고가용성 확보 컨테이너 오케스트레이션 Kubernetes 를 이용해 마이크로서비스 단위로 수평 확장 데이터베이스 계층 읽기/쓰기 분리 마스터 DB 는 쓰기 전용, 읽기 전용 복제본은 수평 확장 데이터 샤딩 키/범위/지역 기반 샤딩을 통해 데이터 분산 캐싱 계층 추가 Redis/Memcached 로 자주 조회되는 데이터를 캐싱하여 DB 부하 감소 검색 서비스 분산 검색 클러스터 Elasticsearch 를 다수 노드로 구성하여 검색 처리 확장 검색 인덱스 복제 읽기 성능 향상을 위한 인덱스 복제본 구성 검색 결과 캐싱 인기 검색 결과를 캐싱하여 응답 속도 향상 정적 자산 배포 CDN 활용 정적 파일 (이미지, JS 등) 을 글로벌 CDN 으로 전송 지역별 캐시 사용자 지리적 위치에 가까운 엣지 서버에 콘텐츠 캐싱 정적 자산 최적화 이미지 압축, JS/CSS 번들링 등 최적화를 통해 네트워크 부하 감소 수직적 확장 접근법 계층 접근 방식 설명 트랜잭션 DB 고성능 DB 서버 고성능 CPU 및 대용량 메모리를 갖춘 DB 서버로 교체 인메모리 DB 도입 주문 처리 등 고속 처리가 필요한 영역에 Redis 등 인메모리 DB 사용 SSD 스토리지 사용 고속 I/O 처리를 위한 SSD 기반 저장소 활용 분석 시스템 병렬 처리 DB 대용량 분석 처리를 위한 MPP 기반 데이터베이스 사용 메모리 최적화 분석 쿼리 성능을 위해 대용량 메모리를 DB 인스턴스에 할당 스토리지 계층화 핫 데이터는 SSD, 콜드 데이터는 HDD 등 계층화된 스토리지 구성 백엔드 API 서버 다중 코어 최적화 API 요청 병렬 처리를 위해 다중 코어 CPU 활용 네트워크 최적화 NIC(Network Interface Card) 성능 향상으로 응답 지연 최소화 커널 튜닝 OS 커널 파라미터 조정 (Linux sysctl 등) 으로 시스템 성능 극대화 하이브리드 확장 전략 실제 구현에서는 수평적 확장과 수직적 확장을 조합한 하이브리드 접근법이 가장 효과적일 수 있다:\n계층 수평 확장 적용 수직 확장 적용 웹/애플리케이션 계층 서버 수 자동 조절 (ASG, Kubernetes 등) - 데이터베이스 계층 읽기 전용 복제본 분산 (수평 확장) 마스터 DB 성능 강화 (고성능 인스턴스, 인메모리 활용 등) 캐싱 계층 Redis/Memcached 클러스터 확장 - 검색 서비스 Elasticsearch 클러스터 확장 - 백엔드 처리 시스템 - 주문, 결제 등 트랜잭션 중심 시스템에 고성능 서버 적용 전자상거래 확장 다이어그램 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 +-------------------+ | 사용자 요청 | +-------------------+ | v +-------------------+ +-------------------+ +-------------------+ | CDN |\u003c-------------\u003e| 로드 밸런서 |\u003c-------------\u003e| 자동 확장 그룹 관리 | |(수평적 확장 - 정적 자산)| |(수평적 확장 - 트래픽)| |(수평적 확장 - 인스턴스)| +-------------------+ +-------------------+ +-------------------+ | +-------------------------|-------------------------+ | | | +-------------+ +-------------+ +-------------+ | 웹 서버 인스턴스 | | 웹 서버 인스턴스 | | 웹 서버 인스턴스 | |(수평적 확장) | |(수평적 확장) | |(수평적 확장) | +-------------+ +-------------+ +-------------+ | | | +-------------------------|-------------------------+ | +-------------------------|-------------------------+ | | | +-------------+ +-------------+ +-------------+ | API 서버 | | API 서버 | | 검색 서비스 | |(수평적 확장) | |(수평적 확장) | |(수평적 확장) | +-------------+ +-------------+ +-------------+ | | | +-------------------------|-------------------------+ | +-------------------------|-------------------------+ | | | +-------------+ +-------------+ +-------------+ | Redis 캐시 | | Redis 캐시 | | Redis 캐시 | |(수평적 확장) | |(수평적 확장) | |(수평적 확장) | +-------------+ +-------------+ +-------------+ | | | +-------------------------|-------------------------+ | +-------------+ | 마스터 DB 서버 | |(수직적 확장) | +-------------+ | +-------------------------|-------------------------+ | | | +-------------+ +-------------+ +-------------+ | 읽기 전용 복제본 | | 읽기 전용 복제본 | | 읽기 전용 복제본 | |(수평적 확장) | |(수평적 확장) | |(수평적 확장) | +-------------+ +-------------+ +-------------+ 수평적 확장과 수직적 확장의 차이점 비교 (전자상거래 시나리오 기준) 측면 수평적 확장 적용 수직적 확장 적용 트래픽 처리 로드 밸런서를 통해 여러 웹 서버에 분산 강력한 단일 서버로 모든 트래픽 처리 데이터베이스 처리 읽기/쓰기 분리, 샤딩, 읽기 복제본 추가 고성능 데이터베이스 서버로 업그레이드 검색 기능 여러 검색 노드에 분산된 인덱스 단일 고성능 검색 서버 장애 대응 일부 서버 장애 시에도 서비스 지속 중복 시스템 필요, 장애 시 전체 영향 지역적 분산 전 세계 여러 지역에 서버 배포 가능 단일 위치에 제한됨 확장 시간 자동 확장으로 빠른 용량 확보 하드웨어 업그레이드에 시간 소요 비용 구조 트래픽에 따라 유연하게 비용 조정 피크 트래픽에 맞춘 고정 비용 복잡성 분산 시스템 관리의 복잡성 단순한 아키텍처 유지 최신 동향 주제 항목 설명 클라우드 네이티브 확장 서버리스 아키텍처 서버리스 컴퓨팅이 더욱 보편화되어 수평적 확장을 자동화하고 관리 오버헤드를 줄이는 접근법이 증가하고 있습니다. AWS Lambda, Azure Functions, Google Cloud Functions 등을 활용한 이벤트 기반 아키텍처가 주류로 자리잡고 있습니다. 멀티 클라우드 확장 전략 기업들이 벤더 종속성을 줄이기 위해 여러 클라우드 제공업체에 걸쳐 시스템을 확장하는 전략을 채택하고 있습니다. Kubernetes 와 같은 컨테이너 오케스트레이션 도구를 통해 클라우드 간 일관된 배포 및 확장이 가능해졌습니다. 자동화 및 지능형 확장 AI 기반 자동 확장 머신러닝 모델을 활용하여 트래픽 패턴을 예측하고 선제적으로 리소스를 확장하는 지능형 자동 확장 시스템이 등장하고 있습니다. 이를 통해 성능 저하 없이 비용을 최적화할 수 있습니다. FinOps 와 비용 최적화 클라우드 리소스 사용 비용을 최적화하기 위한 FinOps 관행이 확산되고 있습니다. 자동화된 비용 모니터링 및 최적화 도구를 통해 효율적인 확장 전략을 구현하는 기업이 증가하고 있습니다. 데이터베이스 확장 분산 데이터베이스의 발전 CockroachDB, TiDB 와 같은 분산 SQL 데이터베이스와 MongoDB, Cassandra 와 같은 NoSQL 데이터베이스는 수평적 확장성을 개선하여 글로벌 규모의 데이터 처리가 가능해졌습니다. 서버리스 데이터베이스 Amazon Aurora Serverless, Azure Cosmos DB 와 같은 서버리스 데이터베이스 솔루션이 자동 확장 기능을 제공하여 수동 확장 관리의 필요성을 줄이고 있습니다. 엣지 컴퓨팅 엣지 기반 수평적 확장 5G 네트워크의 확산과 함께 엣지 컴퓨팅이 보편화되면서, 사용자에 가까운 위치에서 처리를 수행하는 수평적 확장 전략이 증가하고 있습니다. 이를 통해 지연 시간을 줄이고 사용자 경험을 개선할 수 있습니다. 지역 분산 아키텍처 글로벌 서비스 제공을 위해 여러 지역에 걸쳐 리소스를 분산시키는 아키텍처가 표준이 되고 있습니다. 이를 통해 지역적 장애에 대한 내성을 높이고 데이터 주권 요구사항을 충족할 수 있습니다. 하이브리드 확장 동적 하이브리드 확장 워크로드 특성에 따라 수평적 확장과 수직적 확장을 동적으로 조합하는 하이브리드 접근법이 증가하고 있습니다. 컨테이너화된 마이크로서비스는 수평적으로 확장하고, 데이터베이스는 수직적으로 확장하는 등의 전략이 보편화되고 있습니다. 클라우드 - 온프레미스 하이브리드 클라우드와 온프레미스 환경을 결합한 하이브리드 모델이 확산되고 있습니다. 민감한 워크로드는 온프레미스에 유지하면서 확장이 필요한 워크로드는 클라우드로 이동하는 전략이 채택되고 있습니다. 클라우드 확장 전략 대각선 확장 (Diagonal Scaling) 수직 확장과 수평 확장을 결합하여 초기에는 서버 성능을 향상시키고, 이후에는 서버 수를 늘려 확장성을 확보하는 전략입니다. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 수평 확장:\n분산 시스템에 대한 이해와 경험 필요 데이터 일관성 유지 방안 마련 모니터링 및 로깅 시스템 구축 수직 확장:\n하드웨어 업그레이드 시 다운타임 최소화 방안 고려 비용 대비 성능 향상 효과 분석 장기적인 확장성 계획 수립 수평적 확장 Vs 수직적 확장 선택 기준 기준 수평적 확장 선택 수직적 확장 선택 워크로드 특성 병렬 처리 가능한 워크로드\n무상태 (Stateless) 애플리케이션\n읽기 중심 워크로드 단일 스레드 성능이 중요한 워크로드\n상태 유지 (Stateful) 애플리케이션\n트랜잭션 중심 워크로드 확장 규모 대규모 확장이 필요한 경우\n글로벌 서비스\n사용자 수 지속 증가 제한된 규모의 확장이 필요한 경우\n로컬 또는 지역 서비스\n안정적인 사용자 기반 비용 구조 유연한 비용 구조\n사용량 기반 지불\n점진적 투자 초기 투자 가능\n예측 가능한 부하\n장기적 사용을 위한 하드웨어 가용성 요구사항 고가용성 필요\n지역 장애 대응\n무중단 서비스 제한된 가용성 요구사항\n계획된 다운타임 허용\n백업 시스템으로 대응 개발 팀 역량 분산 시스템 경험\n마이크로서비스 아키텍처 이해\nDevOps 문화 단일 시스템 최적화 경험\n하드웨어 성능 튜닝 지식\n전통적인 운영 접근법 시간 제약 빠른 확장 필요\n동적 환경\n시장 변화에 빠른 대응 계획된 확장\n안정적인 환경\n충분한 계획 시간 ###최적화하기 위한 고려사항 및 주의할 점\n리소스 모니터링: CPU, 메모리, 네트워크 사용량 등을 지속적으로 모니터링하여 병목 현상 파악 자동 확장 설정: 트래픽 변화에 따라 자동으로 확장되도록 설정하여 효율적인 리소스 활용 캐싱 전략: 반복되는 요청에 대해 캐싱을 활용하여 응답 속도 향상 주제와 관련하여 주목할 내용들 주제 항목 설명 확장성 패턴 CQRS(Command Query Responsibility Segregation) 명령 (쓰기) 과 쿼리 (읽기) 책임을 분리하여 각각 독립적으로 확장할 수 있는 아키텍처 패턴입니다. 쓰기 작업은 수직적 확장, 읽기 작업은 수평적 확장을 적용할 수 있습니다. 이벤트 소싱 (Event Sourcing) 상태 변경을 이벤트 시퀀스로 저장하는 패턴으로, 수평적 확장에 적합한 이벤트 기반 아키텍처를 구현할 수 있습니다. 백프레셔 (Backpressure) 시스템 과부하를 방지하기 위해 처리 속도를 제어하는 메커니즘으로, 효율적인 확장을 위한 중요한 개념입니다. 확장 기술 서비스 매시 (Service Mesh) Istio, Linkerd 와 같은 서비스 매시는 마이크로서비스 간 통신을 제어하고 관리하여 수평적 확장의 복잡성을 줄여줍니다. 데이터 샤딩 전략 다양한 샤딩 전략 (해시 기반, 범위 기반, 지역 기반) 을 통해 데이터베이스 확장성을 최적화할 수 있습니다. 함수형 프로그래밍 불변성과 순수 함수를 강조하는 함수형 프로그래밍은 병렬 처리와 수평적 확장에 유리한 특성을 제공합니다. 확장 관리 카오스 엔지니어링 프로덕션 환경에서 의도적으로 장애를 발생시켜 시스템의 복원력을 테스트하는 방법으로, 확장 전략의 견고성을 검증할 수 있습니다. SRE(Site Reliability Engineering) Google 이 선도한 이 방법론은 확장성, 신뢰성, 효율성을 균형 있게 관리하기 위한 체계적인 접근법을 제공합니다. 퍼포먼스 예산 (Performance Budget) 확장 계획의 일부로 성능 목표를 설정하고 추적하여 사용자 경험 저하 없이 효율적으로 확장할 수 있습니다. 신기술 WebAssembly 브라우저 외부에서도 사용 가능한 이 기술은 엣지 컴퓨팅과 결합하여 새로운 형태의 분산 확장을 가능하게 합니다. 에너지 효율적 확장 탄소 발자국을 줄이기 위한 에너지 효율적인 확장 전략이 중요해지고 있으며, 이는 데이터 센터 위치, 하드웨어 선택, 워크로드 최적화 등을 포함합니다. 양자 컴퓨팅 준비 향후 양자 컴퓨팅이 상용화되면 특정 워크로드에 대한 수직적 확장의 개념이 크게 변화할 수 있으며, 이에 대한 준비가 필요합니다. 앞으로의 전망 주제 항목 설명 지능형 자동화 자가 최적화 시스템 AI/ML 을 활용하여 워크로드 패턴을 분석하고 최적의 확장 전략을 자동으로 결정하는 시스템이 보편화될 것입니다. 이러한 시스템은 수평적/수직적 확장을 동적으로 조합하여 비용과 성능 균형을 최적화할 것입니다. 예측적 확장 과거 데이터와 외부 요인 (이벤트, 마케팅 캠페인 등) 을 분석하여 부하를 예측하고 선제적으로 확장하는 시스템이 발전할 것입니다. 클라우드 발전 수평적/수직적 경계 희석 클라우드 기술의 발전으로 수평적 확장과 수직적 확장 간의 경계가 모호해질 것입니다. 자원 할당이 더욱 유연해지고 워크로드에 따라 동적으로 조정될 것입니다. 서버리스 2.0 현재의 서버리스 아키텍처를 넘어, 더 복잡한 워크로드와 상태 유지 애플리케이션도 효과적으로 처리할 수 있는 차세대 서버리스 플랫폼이 등장할 것입니다. 분산 컴퓨팅 엣지 - 클라우드 연속체 엣지 디바이스에서 클라우드 데이터 센터까지 연속적인 컴퓨팅 환경이 구축되어, 워크로드가 최적의 위치에서 자동으로 실행될 것입니다. P2P 리소스 공유 블록체인 기술을 활용한 분산형 컴퓨팅 자원 공유 네트워크가 발전하여, 기존 클라우드 제공업체에 대한 대안이 될 수 있습니다. 지속가능성 그린 컴퓨팅 탄소 발자국 최소화를 위한 에너지 효율적인 확장 전략이 더욱 중요해질 것입니다. 재생 에너지 사용이 많은 지역에서의 워크로드 실행, 저전력 하드웨어 선택 등이 확장 결정에 영향을 미칠 것입니다. 탄소 인식 컴퓨팅 워크로드 실행 시 탄소 배출량을 고려하여 확장 결정을 내리는 시스템이 등장할 것입니다. 이는 재생 에너지 가용성이 높을 때 배치 작업을 실행하는 등의 전략을 포함합니다. 새로운 컴퓨팅 패러다임 양자 컴퓨팅 통합 양자 컴퓨팅이 특정 워크로드에 활용되기 시작하면서, 기존의 확장 패러다임을 넘어선 새로운 형태의 하이브리드 아키텍처가 등장할 것입니다. 뉴로모픽 컴퓨팅 뇌 구조를 모방한 뉴로모픽 하드웨어의 발전으로, AI 워크로드에 대한 새로운 형태의 수직적 확장이 가능해질 것입니다. 주제와 관련하여 추가 학습해야 할 내용 카테고리 주제 설명 분산 시스템 CAP 이론 일관성 (Consistency), 가용성 (Availability), 분단 허용성 (Partition tolerance) 의 트레이드오프에 대한 이해. 수평적 확장 시 분산 시스템의 한계를 이해하는 데 필수적입니다. 분산 트랜잭션 관리 2 단계 커밋 (Two-Phase Commit), SAGA 패턴 등 분산 환경에서 트랜잭션 일관성을 보장하는 방법에 대한 학습이 필요합니다. 합의 알고리즘 Paxos, Raft 와 같은 알고리즘을 통해 분산 시스템에서 노드 간 합의를 이루는 방법을 학습해야 합니다. 데이터베이스 데이터베이스 샤딩 전략 해시 기반, 범위 기반, 디렉토리 기반 샤딩 등 다양한 데이터 분산 전략과 각각의 장단점을 이해해야 합니다. NoSQL 확장성 패턴 MongoDB, Cassandra, DynamoDB 등 다양한 NoSQL 데이터베이스의 확장 메커니즘과 적합한 사용 사례를 학습해야 합니다. 데이터 일관성 모델 강한 일관성, 최종 일관성, 인과적 일관성 등 다양한 일관성 모델과 각각의 트레이드오프를 이해해야 합니다. 클라우드 기술 컨테이너 오케스트레이션 Kubernetes, Docker Swarm 등의 컨테이너 오케스트레이션 도구를 활용한 수평적 확장 구현 방법을 학습해야 합니다. 서버리스 아키텍처 AWS Lambda, Azure Functions 등 서버리스 플랫폼의 확장 모델과 한계, 적합한 워크로드를 이해해야 합니다. 클라우드 네이티브 패턴 12 요소 앱 (12-Factor App) 방법론, 클라우드 네이티브 설계 원칙을 학습하여 확장 가능한 애플리케이션을 설계해야 합니다. 성능 최적화 성능 테스트 및 분석 병목 현상 식별, 부하 테스트 도구 (JMeter, Gatling 등) 활용, 성능 지표 분석 방법을 학습해야 합니다. 캐싱 전략 로컬 캐시, 분산 캐시, CDN 등 다양한 수준의 캐싱 전략과 적합한 사용 사례를 이해해야 합니다. 비동기 처리 패턴 이벤트 루프, 비동기 I/O, 메시지 큐 등을 활용한 확장성 향상 방법을 학습해야 합니다. DevOps 및 자동화 인프라스트럭처 자동화 Terraform, CloudFormation 등 IaC 도구를 활용한 확장 가능한 인프라 구축 방법을 학습해야 합니다. 모니터링 및 관측성 Prometheus, Grafana, ELK 스택 등을 활용한 분산 시스템 모니터링 및 문제 해결 방법을 이해해야 합니다. CI/CD 파이프라인 지속적 통합 및 배포 파이프라인을 구축하여 확장 가능한 개발 및 배포 프로세스를 구현하는 방법을 학습해야 합니다. 시스템 설계 마이크로서비스 아키텍처 서비스 분해, API 게이트웨이, 서비스 발견 등 마이크로서비스 구현 및 확장 패턴을 이해해야 합니다. 이벤트 기반 아키텍처 이벤트 소싱, CQRS, 이벤트 스트리밍 등의 패턴을 활용한 확장 가능한 아키텍처 설계 방법을 학습해야 합니다. 회복력 있는 시스템 설계 서킷 브레이커, 재시도, 타임아웃 등의 패턴을 통해 회복력 있는 분산 시스템을 설계하는 방법을 이해해야 합니다. 용어 정리 용어 설명 수평적 확장 (Horizontal Scaling) 시스템 용량을 증가시키기 위해 더 많은 서버나 노드를 추가하는 방식. 스케일 아웃 (Scale-out) 이라고도 함 수직적 확장 (Vertical Scaling) 기존 서버의 성능을 향상시키기 위해 CPU, 메모리 등의 리소스를 증가시키는 방식. 스케일 업 (Scale-up) 이라고도 함 로드 밸런서 (Load Balancer) 여러 서버에 네트워크 트래픽을 분산시키는 장치 또는 소프트웨어 샤딩 (Sharding) 데이터베이스를 여러 서버에 분산시키는 기술로, 각 서버는 전체 데이터의 일부 (샤드) 를 저장함 레플리케이션 (Replication) 데이터나 서비스의 복제본을 여러 서버에 유지하는 기술 자동 확장 (Auto Scaling) 트래픽이나 리소스 사용량에 따라 자동으로 컴퓨팅 리소스를 증가시키거나 감소시키는 기능 서버리스 (Serverless) 서버 관리 없이 함수 단위의 코드를 실행할 수 있는 클라우드 컴퓨팅 모델 마이크로서비스 (Microservices) 애플리케이션을 작고 독립적인 서비스로 분해하여 개발하고 배포하는 아키텍처 스타일 CAP 이론 분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 분단 허용성 (Partition tolerance) 을 동시에 만족시킬 수 없다는 이론 CDN(Content Delivery Network) 콘텐츠를 사용자와 가까운 위치에서 제공하여 지연 시간을 줄이는 분산 서버 네트워크 분산 캐시 (Distributed Cache) 여러 서버에 걸쳐 데이터를 캐싱하는 시스템으로, 성능 향상과 부하 분산에 활용됨 엣지 컴퓨팅 (Edge Computing) 데이터 처리를 중앙 집중식 서버가 아닌 네트워크 엣지 (사용자와 가까운 위치) 에서 수행하는 방식 서비스 매시 (Service Mesh) 마이크로서비스 간 통신을 관리하고 제어하는 인프라 계층 CQRS(Command Query Responsibility Segregation) 명령 (쓰기) 과 쿼리 (읽기) 책임을 분리하는 아키텍처 패턴 이벤트 소싱 (Event Sourcing) 시스템의 상태 변경을 이벤트 시퀀스로 저장하는 패턴 SRE(Site Reliability Engineering) 소프트웨어 엔지니어링 기술을 활용하여 대규모 시스템의 운영 문제를 해결하는 분야 SPOF(Single Point of Failure) 단일 장애점으로 시스템 전체 중단 가능성 Hot Add 시스템 가동 중 리소스 추가 대각선 확장 (Diagonal Scaling) 수직 확장과 수평 확장을 결합하여 유연한 확장성을 확보하는 전략 참고 및 출처 수평/수직 확장 관련 (Horizontal \u0026 Vertical Scaling) DigitalOcean: 9 Strategies to Scale Your Web App in 2025 CloudZero: Horizontal Vs. Vertical Scaling GeeksforGeeks - Horizontal and Vertical Scaling DigitalOcean - Horizontal scaling vs vertical scaling DEV Community - Horizontal scaling vs Vertical Scaling in System Design GeeksforGeeks - Horizontal and Vertical Scaling In Databases nOps - Horizontal vs. Vertical Scaling: HPA, VPA \u0026 Beyond PrepBytes - System Design – Horizontal and Vertical Scaling Spot.io - Horizontal vs. Vertical Scaling in the Cloud LinkedIn - Horizontal Scaling vs. Vertical Scaling 클라우드/자동 확장 트렌드 Fynd Academy: Scalability and Elasticity in Cloud Computing in 2025 Wipro: Cloud Trends 2025 - Unveiling the Future of Cloud Technology CloudZero: 2025 Cloud Computing Market Size And Trends 최신 연구 논문 (arXiv) HAS-GPU: Efficient Hybrid Auto-scaling with Fine-grained GPU Allocation A Tale of Two Scales: Reconciling Horizontal and Vertical Scaling StatuScale: Status-aware and Elastic Scaling Strategy for Microservice Applications Kubernetes / 자동화 관련 Kubernetes Auto-scaling: nOps ","wordCount":"5274","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-03T15:32:00Z","dateModified":"2025-04-03T15:32:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Horizontal vs. Vertical Scaling</h1><div class=post-description>수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다.</div><div class=post-meta><span title='2025-04-03 15:32:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20and%20Software%20Architecture/Implementation/Scalability%20Techniques/horizontal-vs-vertical-scaling.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#horizontal-vs-vertical-scaling>Horizontal vs. Vertical Scaling</a><ul><li><a href=#목적-및-필요성>목적 및 필요성</a></li><li><a href=#horizontal-vs-vertical-scaling-1>Horizontal vs. Vertical Scaling</a></li><li><a href=#수평적-확장-horizontal-scaling>수평적 확장 (Horizontal Scaling)</a></li><li><a href=#수직적-확장-vertical-scaling>수직적 확장 (Vertical Scaling)</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#주제와-관련하여-주목할-내용들>주제와 관련하여 주목할 내용들</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#주제와-관련하여-추가-학습해야-할-내용>주제와 관련하여 추가 학습해야 할 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#수평수직-확장-관련-horizontal--vertical-scaling>수평/수직 확장 관련 (Horizontal & Vertical Scaling)</a></li><li><a href=#클라우드자동-확장-트렌드>클라우드/자동 확장 트렌드</a></li><li><a href=#최신-연구-논문-arxiv>최신 연구 논문 (arXiv)</a></li><li><a href=#kubernetes--자동화-관련>Kubernetes / 자동화 관련</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=horizontal-vs-vertical-scaling>Horizontal vs. Vertical Scaling<a hidden class=anchor aria-hidden=true href=#horizontal-vs-vertical-scaling>#</a></h2><p>시스템의 확장성은 성능과 안정성에 직접적인 영향을 미친다.</p><p>수평/수직 확장은 시스템 확장성을 달성하는 상호보완적 전략이다. <strong>수직 확장</strong>은 단일 노드의 CPU/RAM/Storage 업그레이드로 신속한 대응이 가능하나 하드웨어 한계와 Single Point of Failure(SPOF) 리스크가 존재한다. <strong>수평 확장</strong>은 분산 아키텍처 기반으로 무한 확장성과 내결함성을 제공하나 데이터 일관성 유지가 어렵다.</p><p>2025 년 트렌드로는 Kubernetes 기반 Hybrid Scaling(60% 기업 채택) 과 AI-Driven Auto-scaling(리소스 사용률 40% 개선) 이 주목받으며, Netflix 는 두 방식을 결합해 초당 5TB 스트리밍 데이터를 처리한다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><h4 id=확장성의-중요성>확장성의 중요성<a hidden class=anchor aria-hidden=true href=#확장성의-중요성>#</a></h4><p>확장성은 시스템이 증가하는 부하나 요청을 성능 저하 없이 처리할 수 있는 능력을 의미한다.</p><p>확장성은 다음과 같은 이유로 중요하다:</p><ol><li><strong>사용자 경험 유지</strong>: 트래픽 증가 시에도 일관된 응답 시간과 성능을 유지하여 사용자 경험을 저하시키지 않는다.</li><li><strong>비즈니스 성장 지원</strong>: 비즈니스가 성장함에 따라 증가하는 수요를 효율적으로 처리할 수 있어야 한다.</li><li><strong>비용 효율성</strong>: 적절한 확장 전략을 통해 필요한 리소스만 사용하여 비용을 최적화할 수 있다.</li><li><strong>시스템 안정성</strong>: 부하 증가로 인한 시스템 장애나 성능 저하를 방지한다.</li><li><strong>경쟁 우위 확보</strong>: 빠르고 안정적인 서비스를 제공함으로써 경쟁 우위를 확보할 수 있다.</li></ol><h4 id=수평적-확장-vs-수직적-확장의-필요성>수평적 확장 Vs 수직적 확장의 필요성<a hidden class=anchor aria-hidden=true href=#수평적-확장-vs-수직적-확장의-필요성>#</a></h4><p>두 가지 확장 접근법은 서로 다른 상황과 요구사항에 대응하기 위해 필요하다:</p><ol><li><strong>다양한 워크로드 특성</strong>: 다양한 유형의 워크로드와 애플리케이션에 따라 적합한 확장 전략이 달라진다.</li><li><strong>비용 구조 최적화</strong>: 각 접근법은 서로 다른 비용 구조를 가지고 있어, 비즈니스 요구사항과 예산에 맞는 전략을 선택할 수 있다.</li><li><strong>기술적 제약 대응</strong>: 특정 애플리케이션이나 기술 스택은 특정 확장 방식에 더 적합할 수 있다.</li><li><strong>가용성 및 내결함성 요구사항</strong>: 고가용성이 필요한 시스템은 수평적 확장을 통한 중복성을 활용할 수 있다.</li><li><strong>지리적 분산 요구</strong>: 글로벌 서비스는 지리적으로 분산된 인프라를 통해 지연 시간을 줄이고 가용성을 높일 수 있다.</li></ol><h3 id=horizontal-vs-vertical-scaling-1>Horizontal vs. Vertical Scaling<a hidden class=anchor aria-hidden=true href=#horizontal-vs-vertical-scaling-1>#</a></h3><table><thead><tr><th>항목</th><th>수평 확장 (Horizontal Scaling)</th><th>수직 확장 (Vertical Scaling)</th></tr></thead><tbody><tr><td>확장 방법</td><td>서버 수를 늘려 부하 분산</td><td>기존 서버의 성능 향상</td></tr><tr><td>구조 변경 필요성</td><td>높음 (분산 시스템 구조 필요)</td><td>낮음 (기존 구조 유지 가능)</td></tr><tr><td>확장 한계</td><td>높음 (서버 추가로 확장 가능)</td><td>하드웨어 한계로 제한적</td></tr><tr><td>가용성</td><td>높음 (서버 장애 시 다른 서버로 대체 가능)</td><td>낮음 (단일 서버 장애 시 전체 서비스 영향)</td></tr><tr><td>비용</td><td>초기 비용 높음 (서버 추가 및 인프라 구축)</td><td>초기 비용 낮음 (하드웨어 업그레이드 비용)</td></tr><tr><td>유지보수</td><td>복잡함 (여러 서버 관리 필요)</td><td>간단함 (단일 서버 관리)</td></tr></tbody></table><h3 id=수평적-확장-horizontal-scaling>수평적 확장 (Horizontal Scaling)<a hidden class=anchor aria-hidden=true href=#수평적-확장-horizontal-scaling>#</a></h3><p>수평적 확장은 시스템의 처리 능력을 향상시키기 위해 더 많은 서버나 노드를 추가하는 방식이다.</p><p>수평적 확장의 핵심 개념은 다음과 같다:</p><ol><li><strong>분산 처리</strong>: 여러 서버나 노드에 작업 부하를 분산시켜 전체 시스템의 처리 능력을 향상시킨다.</li><li><strong>스케일 아웃 (Scale-out)</strong>: 시스템 용량을 확장하기 위해 더 많은 서버나 인스턴스를 추가하는 과정을 의미한다.</li><li><strong>로드 밸런싱 (Load Balancing)</strong>: 여러 서버 간에 트래픽이나 작업량을 균등하게 분배하는 기술로, 수평적 확장의 핵심 구성 요소이다.</li><li><strong>샤딩 (Sharding)</strong>: 데이터베이스 컨텍스트에서 데이터를 여러 서버에 분산 저장하는 기술이다.</li><li><strong>레플리케이션 (Replication)</strong>: 데이터나 서비스의 복제본을 여러 서버에 배포하여 가용성과 내결함성을 향상시키는 기술이다.</li><li><strong>탄력성 (Elasticity)</strong>: 트래픽이나 수요 변화에 따라 자동으로 리소스를 추가하거나 제거할 수 있는 능력이다.</li></ol><h4 id=수평적-확장의-주요-기능-및-역할>수평적 확장의 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#수평적-확장의-주요-기능-및-역할>#</a></h4><ol><li><strong>부하 분산</strong>: 여러 서버나 노드에 걸쳐 작업 부하를 균등하게 분산시킨다.</li><li><strong>고가용성 확보</strong>: 여러 인스턴스를 통해 단일 장애점을 제거하고 시스템 가용성을 향상시킨다.</li><li><strong>지리적 분산 지원</strong>: 다양한 지역에 서버를 배치하여 지연 시간을 최소화하고 지역적 장애에 대응할 수 있다.</li><li><strong>탄력적 확장</strong>: 수요 변화에 따라 리소스를 동적으로 추가하거나 제거할 수 있다.</li><li><strong>비용 효율적인 확장</strong>: 필요에 따라 점진적으로 리소스를 추가할 수 있어 비용을 효율적으로 관리할 수 있다.</li></ol><h4 id=수평적-확장의-주요-특징>수평적 확장의 주요 특징<a hidden class=anchor aria-hidden=true href=#수평적-확장의-주요-특징>#</a></h4><ol><li><strong>분산 아키텍처</strong>: 시스템이 여러 노드에 분산되어 있어 개별 노드의 장애가 전체 시스템에 영향을 미치지 않는다.</li><li><strong>선형적 확장성</strong>: 노드 추가에 따라 처리 능력이 선형적으로 증가할 수 있다.</li><li><strong>자동화 지원</strong>: 클라우드 환경에서는 자동 확장 기능을 통해 수요에 따라 자동으로 인스턴스를 추가하거나 제거할 수 있다.</li><li><strong>로드 밸런싱 필요</strong>: 여러 서버 간에 트래픽을 균등하게 분배하기 위한 로드 밸런싱 메커니즘이 필요하다.</li><li><strong>데이터 일관성 과제</strong>: 분산 환경에서 데이터 일관성을 유지하는 것이 복잡할 수 있다.</li></ol><h4 id=수평적-확장의-핵심-원칙>수평적 확장의 핵심 원칙<a hidden class=anchor aria-hidden=true href=#수평적-확장의-핵심-원칙>#</a></h4><ol><li><strong>분산 처리</strong>: 작업 부하를 여러 노드에 분산시켜 전체 시스템의 처리 능력을 향상시킨다.</li><li><strong>로드 밸런싱</strong>: 요청이나 작업을 여러 서버에 균등하게 분배하여 개별 서버의 부하를 최소화한다.</li><li><strong>독립적 확장</strong>: 각 구성 요소나 서비스를 독립적으로 확장할 수 있어 리소스를 효율적으로 활용할 수 있다.</li><li><strong>내결함성</strong>: 여러 인스턴스를 통해 단일 장애점을 제거하고 전체 시스템의 가용성을 향상시킨다.</li><li><strong>데이터 샤딩</strong>: 데이터를 여러 서버에 분산 저장하여 데이터 처리 능력을 향상시킨다.</li></ol><h4 id=수평적-확장의-작동-원리>수평적 확장의 작동 원리<a hidden class=anchor aria-hidden=true href=#수평적-확장의-작동-원리>#</a></h4><ol><li><strong>노드 추가</strong>: 시스템 용량을 확장하기 위해 서버나 노드를 추가한다.</li><li><strong>로드 밸런싱</strong>: 로드 밸런서는 들어오는 요청을 여러 서버에 분배한다. 이를 위해 라운드 로빈, 최소 연결, 가중치 기반 등 다양한 알고리즘을 사용할 수 있다.</li><li><strong>세션 관리</strong>: 사용자 세션을 유지하기 위해 세션 클러스터링, 스티키 세션, 세션리스 아키텍처 등의 방법을 사용한다.</li><li><strong>데이터 분산</strong>: 데이터베이스 샤딩이나 파티셔닝을 통해 데이터를 여러 서버에 분산 저장한다.</li><li><strong>서비스 복제</strong>: 동일한 서비스의 여러 인스턴스를 실행하여 부하를 분산시킨다.</li><li><strong>자동 확장</strong>: 트래픽이나 리소스 사용량에 따라 자동으로 인스턴스를 추가하거나 제거한다.</li></ol><h4 id=수평적-확장-다이어그램>수평적 확장 다이어그램<a hidden class=anchor aria-hidden=true href=#수평적-확장-다이어그램>#</a></h4><p>수평 확장은 로드 밸런서를 통해 여러 서버에 트래픽을 분산시키는 구조로, 각 서버는 동일한 기능을 수행하며, 서버 수를 늘려 확장성을 확보한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+-------------------+      +-------------------+
</span></span><span class=line><span class=cl>|     클라이언트     |-----&gt;|    로드 밸런서     |
</span></span><span class=line><span class=cl>+-------------------+      +-------------------+
</span></span><span class=line><span class=cl>                                   |
</span></span><span class=line><span class=cl>                                   |
</span></span><span class=line><span class=cl>          +------------------------+------------------------+
</span></span><span class=line><span class=cl>          |                        |                        |
</span></span><span class=line><span class=cl>+-----------------+     +-----------------+     +-----------------+
</span></span><span class=line><span class=cl>|    서버 인스턴스 1  |     |    서버 인스턴스 2  |     |    서버 인스턴스 3  |
</span></span><span class=line><span class=cl>+-----------------+     +-----------------+     +-----------------+
</span></span><span class=line><span class=cl>          |                        |                        |
</span></span><span class=line><span class=cl>          |                        |                        |
</span></span><span class=line><span class=cl>          +------------------------+------------------------+
</span></span><span class=line><span class=cl>                                   |
</span></span><span class=line><span class=cl>                                   V
</span></span><span class=line><span class=cl>                          +-------------------+
</span></span><span class=line><span class=cl>                          |  분산 데이터 스토리지  |
</span></span><span class=line><span class=cl>                          +-------------------+
</span></span></code></pre></td></tr></table></div></div><h4 id=수평적-확장-아키텍처>수평적 확장 아키텍처<a hidden class=anchor aria-hidden=true href=#수평적-확장-아키텍처>#</a></h4><p>수평적 확장 아키텍처는 여러 서버나 노드로 구성되며, 이들은 함께 작동하여 부하를 분산시키고 전체 시스템의 처리 능력을 향상시킵니다.</p><ol><li><strong>클라이언트 계층</strong>: 사용자나 클라이언트 애플리케이션으로부터 요청을 받는다.</li><li><strong>로드 밸런싱 계층</strong>: 들어오는 요청을 여러 서버에 분배한다. 하드웨어 로드 밸런서나 소프트웨어 로드 밸런서를 사용할 수 있다.</li><li><strong>애플리케이션 계층</strong>: 여러 서버 인스턴스가 동일한 애플리케이션 코드를 실행하여 요청을 처리한다.</li><li><strong>데이터 계층</strong>: 데이터베이스 서버가 데이터를 저장하고 관리합니다. 샤딩이나 레플리케이션을 통해 데이터를 분산 저장할 수 있다.</li><li><strong>캐싱 계층 (선택 사항)</strong>: 자주 액세스하는 데이터를 캐싱하여 데이터베이스 부하를 줄이고 응답 시간을 개선한다.</li><li><strong>모니터링 및 관리 계층</strong>: 시스템 상태를 모니터링하고 문제를 감지하며 자동 확장을 관리한다.</li></ol><p><strong>수평적 확장 구조</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                   +-------------------+
</span></span><span class=line><span class=cl>                                   |     사용자 요청     |
</span></span><span class=line><span class=cl>                                   +-------------------+
</span></span><span class=line><span class=cl>                                           |
</span></span><span class=line><span class=cl>                                           V
</span></span><span class=line><span class=cl>+-------------------+             +-------------------+
</span></span><span class=line><span class=cl>|  자동 확장 그룹 관리   |&lt;-----------|    로드 밸런서     |
</span></span><span class=line><span class=cl>+-------------------+             +-------------------+
</span></span><span class=line><span class=cl>        |                                 |
</span></span><span class=line><span class=cl>        |           +---------------------+---------------------+
</span></span><span class=line><span class=cl>        |           |                     |                     |
</span></span><span class=line><span class=cl>        |    +-------------+      +-------------+      +-------------+
</span></span><span class=line><span class=cl>        +---&gt;| 웹 서버 인스턴스 |      | 웹 서버 인스턴스 |      | 웹 서버 인스턴스 |
</span></span><span class=line><span class=cl>             +-------------+      +-------------+      +-------------+
</span></span><span class=line><span class=cl>                   |                     |                     |
</span></span><span class=line><span class=cl>                   |                     |                     |
</span></span><span class=line><span class=cl>                   +---------------------+---------------------+
</span></span><span class=line><span class=cl>                                         |
</span></span><span class=line><span class=cl>                                         V
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |     캐시 계층      |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                                         |
</span></span><span class=line><span class=cl>                                         V
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |    데이터베이스     |
</span></span><span class=line><span class=cl>                               |    (샤딩/복제)     |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span></code></pre></td></tr></table></div></div><h4 id=수평적-확장의-주요-구성-요소>수평적 확장의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#수평적-확장의-주요-구성-요소>#</a></h4><table><thead><tr><th>구성 요소</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>로드 밸런서 (Load Balancer)</strong></td><td>요청을 여러 서버에 균등하게 분배</td><td>트래픽 분산, 서버 가용성 모니터링, 장애 서버 감지 및 트래픽 우회</td></tr><tr><td><strong>웹/애플리케이션 서버 클러스터</strong></td><td>클라이언트 요청 처리</td><td>동일한 애플리케이션 실행, 비즈니스 로직 수행, 응답 생성</td></tr><tr><td><strong>분산 데이터베이스 시스템</strong></td><td>데이터 저장 및 관리</td><td>샤딩으로 데이터 분산, 레플리케이션으로 복제, 데이터 정합성 유지</td></tr><tr><td><strong>분산 캐시</strong></td><td>자주 액세스하는 데이터 캐싱</td><td>데이터베이스 부하 감소, 빠른 응답 제공, 일관된 캐시 동기화</td></tr><tr><td><strong>세션 관리 시스템</strong></td><td>사용자 세션 유지 및 상태 관리</td><td>분산 환경에서도 세션 공유, 인증 상태 유지</td></tr><tr><td><strong>자동 확장 그룹 (Auto Scaling)</strong></td><td>서버 인스턴스 수를 자동으로 조절</td><td>리소스 모니터링, 수요에 따른 서버 자동 생성 및 제거</td></tr><tr><td><strong>서비스 디스커버리</strong></td><td>동적으로 서비스 인스턴스 감지 및 등록</td><td>서비스 레지스트리 유지, 새 인스턴스 자동 등록 및 검색</td></tr><tr><td><strong>클라우드 스토리지</strong></td><td>정적 파일 저장 및 백업 지원</td><td>확장 가능한 저장 공간 제공, 중복성 확보, 백업/복구 기능 제공</td></tr></tbody></table><h4 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h4><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>무한한 확장성</td><td>서버를 계속 추가할 수 있어 트래픽 증가에 유연하게 대응 가능</td></tr><tr><td></td><td>고가용성</td><td>다수의 서버가 분산되어 있어 단일 장애점 (SPOF, Single Point of Failure) 이 없음</td></tr><tr><td></td><td>비용 효율성</td><td>고사양 장비 대신 저비용 장비 여러 대로 구성 가능</td></tr><tr><td></td><td>탄력적 확장</td><td>자동 확장을 통해 트래픽 변화에 따라 빠르게 대응 가능</td></tr><tr><td></td><td>지리적 분산</td><td>다양한 지역에 서버를 배치해 사용자 지연 시간 최소화 가능</td></tr><tr><td></td><td>무중단 확장</td><td>운영 중인 시스템에 영향을 주지 않고 서버를 추가할 수 있음</td></tr><tr><td>⚠ 단점</td><td>아키텍처 복잡성</td><td>분산 시스템 설계 및 유지 관리가 복잡해짐</td></tr><tr><td></td><td>데이터 일관성 문제</td><td>여러 노드 간 동기화가 어렵고 일관성 모델 선택이 필요함</td></tr><tr><td></td><td>네트워크 오버헤드</td><td>서버 간 통신 및 데이터 동기화에 따른 트래픽 증가</td></tr><tr><td></td><td>로드 밸런싱 필요</td><td>트래픽을 균등 분산시키기 위한</td></tr></tbody></table><h4 id=수평적-확장의-유형>수평적 확장의 유형<a hidden class=anchor aria-hidden=true href=#수평적-확장의-유형>#</a></h4><table><thead><tr><th>확장 유형</th><th>설명</th><th>특징</th><th>적용 사례</th></tr></thead><tbody><tr><td><strong>클러스터 기반 확장</strong></td><td>여러 서버를 클러스터로 구성하여 동일 애플리케이션 실행</td><td>로드 밸런싱, 서버 간 상태 공유 가능, 일관된 사용자 경험 제공</td><td>웹 서버 클러스터, 애플리케이션 서버 팜</td></tr><tr><td><strong>마이크로서비스 기반 확장</strong></td><td>애플리케이션을 독립적인 서비스 단위로 분할하여 각각 확장</td><td>서비스 단위 확장 가능, 장애 격리 용이, 기술 스택 독립성 확보</td><td>마이크로서비스 아키텍처, SOA(Service-Oriented Architecture)</td></tr><tr><td><strong>샤딩 기반 확장</strong></td><td>데이터를 여러 데이터베이스에 나누어 저장</td><td>키/범위/지역 기반 샤딩 전략 활용, 쓰기 확장성 우수</td><td>대규모 사용자 DB, 분산 빅데이터 플랫폼</td></tr><tr><td><strong>레플리케이션 기반 확장</strong></td><td>동일한 데이터를 여러 서버에 복제하여 읽기 성능 향상</td><td>읽기 부하 분산, 장애 대응 강화, 다양한 복제 모델 (Master-Slave, Multi-Master) 사용</td><td>읽기 집약 시스템, CDN, 글로벌 콘텐츠 서비스</td></tr><tr><td><strong>서버리스 확장</strong></td><td>함수 단위 코드 실행, 요청에 따라 자동 확장</td><td>사용량 기반 과금, 무서버 인프라, 이벤트 기반 실행</td><td>AWS Lambda, Azure Functions, GCP Functions</td></tr></tbody></table><h3 id=수직적-확장-vertical-scaling>수직적 확장 (Vertical Scaling)<a hidden class=anchor aria-hidden=true href=#수직적-확장-vertical-scaling>#</a></h3><p>수직적 확장은 기존 서버나 시스템의 성능을 향상시키기 위해 더 많은 리소스를 추가하는 방식이다.</p><p>수직적 확장의 핵심 개념은 다음과 같다:</p><ol><li><strong>스케일 업 (Scale-up)</strong>: 기존 서버의 CPU, 메모리, 스토리지와 같은 하드웨어 리소스를 증가시키는 과정을 의미한다.</li><li><strong>단일 노드 강화</strong>: 단일 시스템의 처리 능력을 향상시켜 더 많은 요청이나 작업을 처리할 수 있게 한다.</li><li><strong>하드웨어 업그레이드</strong>: 더 강력한 CPU, 더 많은 RAM, 더 빠른 스토리지 등으로 서버를 업그레이드하는 과정이다.</li><li><strong>소프트웨어 최적화</strong>: 하드웨어 리소스 외에도 소프트웨어 최적화를 통해 시스템 성능을 향상시키는 접근법도 수직적 확장에 포함될 수 있다.</li><li><strong>물리적 한계</strong>: 수직적 확장은 단일 시스템의 물리적 한계에 제약을 받으며, 특정 지점 이상으로 확장하기 어렵다.</li><li><strong>무중단 확장의 어려움</strong>: 일반적으로 수직적 확장은 시스템 다운타임을 필요로 하는 경우가 많다.</li></ol><h4 id=수직적-확장의-주요-기능-및-역할>수직적 확장의 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#수직적-확장의-주요-기능-및-역할>#</a></h4><ol><li><strong>단일 시스템 성능 향상</strong>: 개별 서버의 처리 능력을 향상시켜 더 많은 작업을 처리할 수 있다.</li><li><strong>단순한 아키텍처 유지</strong>: 추가 서버 없이 기존 시스템을 강화하므로 아키텍처를 단순하게 유지할 수 있다.</li><li><strong>관리 복잡성 감소</strong>: 관리해야 할 서버 수가 적어 운영 복잡성이 감소한다.</li><li><strong>특정 워크로드 최적화</strong>: 메모리 집약적이거나 CPU 집약적인 특정 워크로드에 대해 최적화된 리소스 할당을 제공한다.</li><li><strong>즉각적인 성능 향상</strong>: 하드웨어 업그레이드를 통해 즉각적인 성능 향상을 달성할 수 있다.</li></ol><h4 id=수직적-확장의-주요-특징>수직적 확장의 주요 특징<a hidden class=anchor aria-hidden=true href=#수직적-확장의-주요-특징>#</a></h4><ol><li><strong>단일 시스템 강화</strong>: 하나의 서버나 시스템의 성능과 용량을 향상시키는 데 중점을 둔다.</li><li><strong>하드웨어 한계</strong>: 확장성은 단일 서버에 추가할 수 있는 하드웨어 리소스의 물리적 한계에 제약을 받는다.</li><li><strong>다운타임 가능성</strong>: 일반적으로 하드웨어 업그레이드 시 시스템 다운타임이 발생할 수 있다.</li><li><strong>즉각적인 성능 향상</strong>: 하드웨어 리소스 증가 후 즉시 성능 향상을 체감할 수 있다.</li><li><strong>관리 용이성</strong>: 추가 서버나 분산 시스템 관리가 필요 없어 관리가 상대적으로 단순하다.</li></ol><h4 id=수직적-확장의-핵심-원칙>수직적 확장의 핵심 원칙<a hidden class=anchor aria-hidden=true href=#수직적-확장의-핵심-원칙>#</a></h4><ol><li><strong>리소스 집중화</strong>: 단일 시스템에 리소스를 집중시켜 성능을 최대화한다.</li><li><strong>단순성 유지</strong>: 추가 서버 없이 기존 시스템을 강화하여 아키텍처 단순성을 유지한다.</li><li><strong>하드웨어 최적화</strong>: CPU, 메모리, 스토리지 등의 하드웨어 리소스를 최적화하여 성능을 향상시킨다.</li><li><strong>소프트웨어 최적화</strong>: 하드웨어 외에도 소프트웨어 최적화를 통해 시스템 성능을 향상시킨다.</li><li><strong>자원 활용 극대화</strong>: 단일 시스템의 자원 활용을 극대화하여 효율성을 높인다.</li></ol><h4 id=수직적-확장의-작동-원리>수직적 확장의 작동 원리<a hidden class=anchor aria-hidden=true href=#수직적-확장의-작동-원리>#</a></h4><ol><li><strong>하드웨어 업그레이드</strong>: CPU, 메모리, 스토리지 등의 하드웨어 리소스를 증가시킨다.</li><li><strong>서버 교체</strong>: 기존 서버를 더 강력한 서버로 교체하거나 업그레이드된 서버로 워크로드를 이전한다.</li><li><strong>리소스 할당 최적화</strong>: 시스템 리소스 할당을 최적화하여 성능을 향상시킨다.</li><li><strong>소프트웨어 최적화</strong>: 코드 최적화, 캐싱, 인덱싱 등의 소프트웨어 최적화 기법을 적용한다.</li><li><strong>하드웨어 통합</strong>: 여러 물리적 서버를 하나의 더 강력한 서버로 통합할 수 있다.</li><li><strong>가상화 활용</strong>: 가상화 기술을 활용하여 하드웨어 리소스를 효율적으로 활용한다.</li></ol><h4 id=수직적-확장-다이어그램>수직적 확장 다이어그램<a hidden class=anchor aria-hidden=true href=#수직적-확장-다이어그램>#</a></h4><p>수직 확장은 단일 서버의 하드웨어를 업그레이드하여 성능을 향상시키는 구조로, 구조 변경 없이 빠른 성능 향상이 가능하지만, 하드웨어 한계로 인해 확장성에 제한이 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                +-------------------+
</span></span><span class=line><span class=cl>                |     클라이언트     |
</span></span><span class=line><span class=cl>                +-------------------+
</span></span><span class=line><span class=cl>                        |
</span></span><span class=line><span class=cl>                        V
</span></span><span class=line><span class=cl>                +-------------------+
</span></span><span class=line><span class=cl>                |       서버        |
</span></span><span class=line><span class=cl>                |                   |
</span></span><span class=line><span class=cl>                | CPU: 8코어 -&gt; 16코어 |
</span></span><span class=line><span class=cl>                | RAM: 16GB -&gt; 64GB |
</span></span><span class=line><span class=cl>                | SSD: 1TB -&gt; 4TB   |
</span></span><span class=line><span class=cl>                +-------------------+
</span></span><span class=line><span class=cl>                        |
</span></span><span class=line><span class=cl>                        V
</span></span><span class=line><span class=cl>                +-------------------+
</span></span><span class=line><span class=cl>                |    데이터 스토리지   |
</span></span><span class=line><span class=cl>                +-------------------+
</span></span></code></pre></td></tr></table></div></div><h4 id=수직적-확장-아키텍처>수직적 확장 아키텍처<a hidden class=anchor aria-hidden=true href=#수직적-확장-아키텍처>#</a></h4><p>수직적 확장 아키텍처는 단일 서버의 성능과 용량을 강화하는 데 중점을 둔다.</p><ol><li><strong>클라이언트 계층</strong>: 사용자나 클라이언트 애플리케이션으로부터 요청을 받는다.</li><li><strong>애플리케이션 계층</strong>: 강화된 단일 서버가 모든 애플리케이션 코드를 실행하여 요청을 처리한다.</li><li><strong>데이터 계층</strong>: 강화된 단일 데이터베이스 서버가 모든 데이터를 저장하고 관리한다.</li><li><strong>백업 및 복구 계층</strong>: 시스템 장애 시 데이터 손실을 방지하기 위한 백업 및 복구 메커니즘이 필요하다.</li><li><strong>모니터링 계층</strong>: 시스템 성능과 리소스 사용량을 모니터링하여 추가 업그레이드가 필요한 시점을 파악한다.</li></ol><p><strong>수직적 확장 구조</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |     사용자 요청     |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                        V
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |    고성능 서버     |
</span></span><span class=line><span class=cl>                               |                   |
</span></span><span class=line><span class=cl>                               | - 다중 코어 CPU     |
</span></span><span class=line><span class=cl>                               | - 대용량 메모리     |
</span></span><span class=line><span class=cl>                               | - 고속 SSD        |
</span></span><span class=line><span class=cl>                               | - 고대역폭 네트워크  |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                        V
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |    고성능 DB      |
</span></span><span class=line><span class=cl>                               |                   |
</span></span><span class=line><span class=cl>                               | - 고성능 스토리지   |
</span></span><span class=line><span class=cl>                               | - 최적화된 인덱싱   |
</span></span><span class=line><span class=cl>                               | - 메모리 내 캐싱    |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                        V
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span><span class=line><span class=cl>                               |   백업 및 복구     |
</span></span><span class=line><span class=cl>                               +-------------------+
</span></span></code></pre></td></tr></table></div></div><h4 id=수직적-확장의-주요-구성-요소>수직적 확장의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#수직적-확장의-주요-구성-요소>#</a></h4><table><thead><tr><th>구성 요소</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>고성능 서버 하드웨어</strong></td><td>요청 처리 및 애플리케이션 실행</td><td>다중 코어 CPU, 대용량 메모리, 고속 스토리지로 고속 처리 환경 제공</td></tr><tr><td><strong>고성능 데이터베이스 서버</strong></td><td>데이터 저장 및 관리</td><td>대량 데이터 처리, 고속 쿼리 수행, 트랜잭션 안정성 확보</td></tr><tr><td><strong>서버 가상화 환경</strong></td><td>하드웨어 리소스의 효율적 활용</td><td>리소스 동적 할당, 워크로드 격리, 효율적 인프라 운영</td></tr><tr><td><strong>로컬 캐시</strong></td><td>자주 사용하는 데이터 캐싱</td><td>디스크 I/O 감소, 메모리 기반 데이터 응답 속도 향상</td></tr><tr><td><strong>백업 및 복구 시스템</strong></td><td>정기적인 데이터 백업 및 복구</td><td>데이터 무결성 보장, 장애 복구 지원, 재해 대비</td></tr><tr><td><strong>고성능 네트워크 인터페이스</strong></td><td>네트워크 통신 최적화</td><td>고대역폭 전송, 지연 최소화, 대용량 데이터 처리</td></tr><tr><td><strong>성능 모니터링 시스템</strong></td><td>시스템 자원 및 성능 상태 실시간 모니터링</td><td>병목 지점 감지, 리소스 분석, 업그레이드 타이밍 평가</td></tr><tr><td><strong>최적화된 운영 체제 및 소프트웨어</strong></td><td>하드웨어 리소스의 효율적 활용 및 시스템 안정성 유지</td><td>프로세스 스케줄링, 커널 최적화, 성능 및 자원 활용 최적화</td></tr></tbody></table><h4 id=장단점-1>장단점<a hidden class=anchor aria-hidden=true href=#장단점-1>#</a></h4><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>아키텍처 단순성</td><td>서버 한 대에서 운영되므로 시스템 구조가 단순하고 이해하기 쉬움</td></tr><tr><td></td><td>구현 용이성</td><td>리소스만 추가하면 되므로 코드나 구조 변경 없이 확장 가능</td></tr><tr><td></td><td>낮은 네트워크 지연</td><td>모든 처리 및 데이터가 단일 노드에서 수행되어 레이턴시가 낮음</td></tr><tr><td></td><td>데이터 일관성 용이</td><td>단일 시스템 기반이므로 데이터 정합성 유지가 쉬움</td></tr><tr><td></td><td>소프트웨어 호환성</td><td>대부분의 기존 애플리케이션과 호환되며 수정 없이 운영 가능</td></tr><tr><td></td><td>관리 오버헤드 감소</td><td>다수의 노드를 관리할 필요가 없어 관리 및 운영 복잡성이 줄어듦</td></tr><tr><td>⚠ 단점</td><td>물리적 한계</td><td>단일 서버의 CPU, 메모리, 디스크 등 하드웨어에는 확장 한계가 존재</td></tr><tr><td></td><td>비용 비효율</td><td>고성능 장비는 가격이 급격히 비싸지며 성능 대비 효율이 떨어질 수 있음</td></tr><tr><td></td><td>다운타임 발생 가능</td><td>리소스 추가나 유지보수 시 시스템 재시작 등으로 인한 중단이 필요할 수 있음</td></tr><tr><td></td><td>단일 장애점 존재</td><td>서버에 문제가 생기면 전체 서비스가 중단될 위험이 있음</td></tr><tr><td></td><td>지리적 제약</td><td>단일 위치에서 처리되기 때문에 글로벌 사용자 대상 성능 보장이 어려움</td></tr><tr><td></td><td>자원 낭비 가능성</td><td>최대 트래픽에 맞춰 리소스를 고정하면 비성수기 동안 과잉 리소스가 낭비될 수 있음</td></tr></tbody></table><h4 id=수직적-확장의-유형>수직적 확장의 유형<a hidden class=anchor aria-hidden=true href=#수직적-확장의-유형>#</a></h4><table><thead><tr><th>확장 방식</th><th>설명</th><th>특징</th><th>적용 사례</th></tr></thead><tbody><tr><td><strong>하드웨어 업그레이드</strong></td><td>물리 서버의 CPU, 메모리, 스토리지 등 리소스를 증설</td><td>물리적 한계 존재, 다운타임 발생 가능, 즉각적인 성능 향상</td><td>온프레미스 서버, 물리 DB 서버</td></tr><tr><td><strong>가상 머신 확장</strong></td><td>가상 머신의 vCPU, vRAM 리소스를 증설</td><td>유연한 리소스 할당, 하이퍼바이저 오버헤드, 라이브 마이그레이션 가능</td><td>클라우드 VM, VMware, Hyper-V 기반 환경</td></tr><tr><td><strong>컨테이너 리소스 확장</strong></td><td>컨테이너 단위로 CPU/메모리 할당량 증설</td><td>세분화된 자원 제어, 빠른 확장 적용, 호스트 자원 한계 내에서만 확장 가능</td><td>Docker, Kubernetes Pod</td></tr><tr><td><strong>데이터베이스 수직 확장</strong></td><td>DB 서버의 메모리/CPU 증가, 캐시 및 인덱스 성능 최적화</td><td>쿼리 성능 향상, 캐시 크기 증가, 단일 노드 기반 확장</td><td>PostgreSQL, MySQL, Redis 등 관계형/인메모리 DB</td></tr><tr><td><strong>클라우드 인스턴스 유형 변경</strong></td><td>기존 인스턴스를 고사양 인스턴스 유형으로 교체</td><td>간편한 업그레이드, 다양한 스펙 선택, 요금 증가 가능</td><td>AWS EC2, Azure VM, Google Compute Engine 등</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>산업</th><th>적용 사례</th><th>확장 유형</th><th>구현 방식</th><th>결과 및 이점</th></tr></thead><tbody><tr><td><strong>전자상거래</strong></td><td>블랙프라이데이 세일 대비</td><td>수평적 확장</td><td>자동 확장 그룹 구성, 로드 밸런서 도입, 데이터베이스 읽기 복제본 추가</td><td>트래픽 증가에도 안정적 서비스 제공, 판매 기회 손실 방지, 고객 경험 향상</td></tr><tr><td><strong>금융 서비스</strong></td><td>핵심 거래 시스템 성능 향상</td><td>수직적 확장</td><td>고성능 서버 도입, 인메모리 데이터베이스 적용, SSD 스토리지 확장</td><td>트랜잭션 처리 시간 단축, 안정성 향상, 데이터 무결성 보장</td></tr><tr><td><strong>미디어 스트리밍</strong></td><td>글로벌 콘텐츠 전송 최적화</td><td>수평적 확장</td><td>CDN 활용, 지역별 서버 배포, 콘텐츠 복제</td><td>지연 시간 감소, 사용자 경험 개선, 대역폭 비용 최적화</td></tr><tr><td><strong>게임 서비스</strong></td><td>새 게임 출시에 따른 인프라 준비</td><td>하이브리드 확장</td><td>게임 서버는 수평적 확장, 데이터베이스는 수직적 확장</td><td>플레이어 수요 대응, 게임 지연 최소화, 데이터 일관성 유지</td></tr><tr><td><strong>헬스케어</strong></td><td>의료 영상 처리 시스템</td><td>수직적 확장</td><td>GPU 서버 도입, 대용량 메모리 확장, 고속 스토리지 적용</td><td>영상 처리 속도 향상, 진단 시간 단축, 정확도 개선</td></tr><tr><td><strong>소셜 미디어</strong></td><td>사용자 증가에 따른 피드 시스템 확장</td><td>수평적 확장</td><td>마이크로서비스 아키텍처, 데이터 샤딩, 캐시 클러스터</td><td>실시간 피드 업데이트, 개인화 서비스 제공, 사용자 증가에도 안정적 서비스</td></tr><tr><td><strong>SaaS</strong></td><td>다중 테넌트 애플리케이션 확장</td><td>수평적 확장</td><td>테넌트별 데이터 분리, 서버 클러스터 구성, API 게이트웨이 도입</td><td>테넌트 격리, 개별 확장 가능, 리소스 효율적 사용</td></tr><tr><td><strong>IoT</strong></td><td>센서 데이터 처리 시스템</td><td>분산 확장</td><td>에지 컴퓨팅, 데이터 분산 처리, 시계열 데이터베이스</td><td>실시간 데이터 처리, 네트워크 대역폭 최적화, 확장성 확보</td></tr><tr><td><strong>AI/ML</strong></td><td>모델 학습 인프라</td><td>수직적 확장</td><td>고성능 GPU 클러스터, 대용량 메모리, 고속 스토리지</td><td>학습 시간 단축, 복잡한 모델 처리 가능, 정확도 향상</td></tr><tr><td><strong>정부/공공</strong></td><td>세금 신고 시스템</td><td>계절적 수평 확장</td><td>피크 시즌에 클라우드 인스턴스 추가, 로드 밸런싱, 캐싱</td><td>신고 기간 중 안정적 서비스, 비용 효율성, 사용자 만족도 향상</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1>사례 1<a hidden class=anchor aria-hidden=true href=#사례-1>#</a></h4><p><strong>시나리오</strong>: 대형 전자상거래 플랫폼이 연례 세일 이벤트를 앞두고 트래픽이 평소보다 10 배 이상 증가할 것으로 예상된다. 이 플랫폼은 사용자가 제품을 검색하고, 구매하며, 리뷰를 남기는 기능을 제공한다. 이벤트 기간 동안 시스템 안정성을 유지하면서 사용자 경험을 최적화하기 위한 확장 전략이 필요하다.</p><h5 id=수평적-확장-접근법>수평적 확장 접근법<a hidden class=anchor aria-hidden=true href=#수평적-확장-접근법>#</a></h5><table><thead><tr><th>계층</th><th>접근 방식</th><th>설명</th></tr></thead><tbody><tr><td>웹/애플리케이션 서버</td><td>자동 확장 그룹 구성</td><td>트래픽 변화에 따라 서버 인스턴스를 자동으로 추가/제거</td></tr><tr><td></td><td>로드 밸런서 구성</td><td>여러 가용 영역 (AZ) 에 걸쳐 트래픽을 분산하여 고가용성 확보</td></tr><tr><td></td><td>컨테이너 오케스트레이션</td><td>Kubernetes 를 이용해 마이크로서비스 단위로 수평 확장</td></tr><tr><td>데이터베이스 계층</td><td>읽기/쓰기 분리</td><td>마스터 DB 는 쓰기 전용, 읽기 전용 복제본은 수평 확장</td></tr><tr><td></td><td>데이터 샤딩</td><td>키/범위/지역 기반 샤딩을 통해 데이터 분산</td></tr><tr><td></td><td>캐싱 계층 추가</td><td>Redis/Memcached 로 자주 조회되는 데이터를 캐싱하여 DB 부하 감소</td></tr><tr><td>검색 서비스</td><td>분산 검색 클러스터</td><td>Elasticsearch 를 다수 노드로 구성하여 검색 처리 확장</td></tr><tr><td></td><td>검색 인덱스 복제</td><td>읽기 성능 향상을 위한 인덱스 복제본 구성</td></tr><tr><td></td><td>검색 결과 캐싱</td><td>인기 검색 결과를 캐싱하여 응답 속도 향상</td></tr><tr><td>정적 자산 배포</td><td>CDN 활용</td><td>정적 파일 (이미지, JS 등) 을 글로벌 CDN 으로 전송</td></tr><tr><td></td><td>지역별 캐시</td><td>사용자 지리적 위치에 가까운 엣지 서버에 콘텐츠 캐싱</td></tr><tr><td></td><td>정적 자산 최적화</td><td>이미지 압축, JS/CSS 번들링 등 최적화를 통해 네트워크 부하 감소</td></tr></tbody></table><h5 id=수직적-확장-접근법>수직적 확장 접근법<a hidden class=anchor aria-hidden=true href=#수직적-확장-접근법>#</a></h5><table><thead><tr><th>계층</th><th>접근 방식</th><th>설명</th></tr></thead><tbody><tr><td>트랜잭션 DB</td><td>고성능 DB 서버</td><td>고성능 CPU 및 대용량 메모리를 갖춘 DB 서버로 교체</td></tr><tr><td></td><td>인메모리 DB 도입</td><td>주문 처리 등 고속 처리가 필요한 영역에 Redis 등 인메모리 DB 사용</td></tr><tr><td></td><td>SSD 스토리지 사용</td><td>고속 I/O 처리를 위한 SSD 기반 저장소 활용</td></tr><tr><td>분석 시스템</td><td>병렬 처리 DB</td><td>대용량 분석 처리를 위한 MPP 기반 데이터베이스 사용</td></tr><tr><td></td><td>메모리 최적화</td><td>분석 쿼리 성능을 위해 대용량 메모리를 DB 인스턴스에 할당</td></tr><tr><td></td><td>스토리지 계층화</td><td>핫 데이터는 SSD, 콜드 데이터는 HDD 등 계층화된 스토리지 구성</td></tr><tr><td>백엔드 API 서버</td><td>다중 코어 최적화</td><td>API 요청 병렬 처리를 위해 다중 코어 CPU 활용</td></tr><tr><td></td><td>네트워크 최적화</td><td>NIC(Network Interface Card) 성능 향상으로 응답 지연 최소화</td></tr><tr><td></td><td>커널 튜닝</td><td>OS 커널 파라미터 조정 (Linux sysctl 등) 으로 시스템 성능 극대화</td></tr></tbody></table><h5 id=하이브리드-확장-전략>하이브리드 확장 전략<a hidden class=anchor aria-hidden=true href=#하이브리드-확장-전략>#</a></h5><p>실제 구현에서는 수평적 확장과 수직적 확장을 조합한 하이브리드 접근법이 가장 효과적일 수 있다:</p><table><thead><tr><th>계층</th><th>수평 확장 적용</th><th>수직 확장 적용</th></tr></thead><tbody><tr><td>웹/애플리케이션 계층</td><td>서버 수 자동 조절 (ASG, Kubernetes 등)</td><td>-</td></tr><tr><td>데이터베이스 계층</td><td>읽기 전용 복제본 분산 (수평 확장)</td><td>마스터 DB 성능 강화 (고성능 인스턴스, 인메모리 활용 등)</td></tr><tr><td>캐싱 계층</td><td>Redis/Memcached 클러스터 확장</td><td>-</td></tr><tr><td>검색 서비스</td><td>Elasticsearch 클러스터 확장</td><td>-</td></tr><tr><td>백엔드 처리 시스템</td><td>-</td><td>주문, 결제 등 트랜잭션 중심 시스템에 고성능 서버 적용</td></tr></tbody></table><h5 id=전자상거래-확장-다이어그램>전자상거래 확장 다이어그램<a hidden class=anchor aria-hidden=true href=#전자상거래-확장-다이어그램>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                     +-------------------+
</span></span><span class=line><span class=cl>                                     |     사용자 요청     |
</span></span><span class=line><span class=cl>                                     +-------------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                                              v
</span></span><span class=line><span class=cl>+-------------------+               +-------------------+               +-------------------+
</span></span><span class=line><span class=cl>|       CDN        |&lt;-------------&gt;|    로드 밸런서     |&lt;-------------&gt;|  자동 확장 그룹 관리  |
</span></span><span class=line><span class=cl>|(수평적 확장 - 정적 자산)|               |(수평적 확장 - 트래픽)|               |(수평적 확장 - 인스턴스)|
</span></span><span class=line><span class=cl>+-------------------+               +-------------------+               +-------------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>            | 웹 서버 인스턴스 |           | 웹 서버 인스턴스 |           | 웹 서버 인스턴스 |
</span></span><span class=line><span class=cl>            |(수평적 확장)    |           |(수평적 확장)    |           |(수평적 확장)    |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>            |  API 서버   |           |  API 서버   |           |  검색 서비스   |
</span></span><span class=line><span class=cl>            |(수평적 확장)  |           |(수평적 확장)  |           |(수평적 확장)  |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>            |  Redis 캐시  |           |  Redis 캐시  |           |  Redis 캐시  |
</span></span><span class=line><span class=cl>            |(수평적 확장)  |           |(수평적 확장)  |           |(수평적 확장)  |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                                      +-------------+
</span></span><span class=line><span class=cl>                                      | 마스터 DB 서버 |
</span></span><span class=line><span class=cl>                                      |(수직적 확장)  |
</span></span><span class=line><span class=cl>                                      +-------------+
</span></span><span class=line><span class=cl>                                              |
</span></span><span class=line><span class=cl>                    +-------------------------|-------------------------+
</span></span><span class=line><span class=cl>                    |                         |                         |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span><span class=line><span class=cl>            | 읽기 전용 복제본 |           | 읽기 전용 복제본 |           | 읽기 전용 복제본 |
</span></span><span class=line><span class=cl>            |(수평적 확장)    |           |(수평적 확장)    |           |(수평적 확장)    |
</span></span><span class=line><span class=cl>            +-------------+           +-------------+           +-------------+
</span></span></code></pre></td></tr></table></div></div><h5 id=수평적-확장과-수직적-확장의-차이점-비교-전자상거래-시나리오-기준>수평적 확장과 수직적 확장의 차이점 비교 (전자상거래 시나리오 기준)<a hidden class=anchor aria-hidden=true href=#수평적-확장과-수직적-확장의-차이점-비교-전자상거래-시나리오-기준>#</a></h5><table><thead><tr><th>측면</th><th>수평적 확장 적용</th><th>수직적 확장 적용</th></tr></thead><tbody><tr><td><strong>트래픽 처리</strong></td><td>로드 밸런서를 통해 여러 웹 서버에 분산</td><td>강력한 단일 서버로 모든 트래픽 처리</td></tr><tr><td><strong>데이터베이스 처리</strong></td><td>읽기/쓰기 분리, 샤딩, 읽기 복제본 추가</td><td>고성능 데이터베이스 서버로 업그레이드</td></tr><tr><td><strong>검색 기능</strong></td><td>여러 검색 노드에 분산된 인덱스</td><td>단일 고성능 검색 서버</td></tr><tr><td><strong>장애 대응</strong></td><td>일부 서버 장애 시에도 서비스 지속</td><td>중복 시스템 필요, 장애 시 전체 영향</td></tr><tr><td><strong>지역적 분산</strong></td><td>전 세계 여러 지역에 서버 배포 가능</td><td>단일 위치에 제한됨</td></tr><tr><td><strong>확장 시간</strong></td><td>자동 확장으로 빠른 용량 확보</td><td>하드웨어 업그레이드에 시간 소요</td></tr><tr><td><strong>비용 구조</strong></td><td>트래픽에 따라 유연하게 비용 조정</td><td>피크 트래픽에 맞춘 고정 비용</td></tr><tr><td><strong>복잡성</strong></td><td>분산 시스템 관리의 복잡성</td><td>단순한 아키텍처 유지</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>클라우드 네이티브 확장</strong></td><td>서버리스 아키텍처</td><td>서버리스 컴퓨팅이 더욱 보편화되어 수평적 확장을 자동화하고 관리 오버헤드를 줄이는 접근법이 증가하고 있습니다. AWS Lambda, Azure Functions, Google Cloud Functions 등을 활용한 이벤트 기반 아키텍처가 주류로 자리잡고 있습니다.</td></tr><tr><td></td><td>멀티 클라우드 확장 전략</td><td>기업들이 벤더 종속성을 줄이기 위해 여러 클라우드 제공업체에 걸쳐 시스템을 확장하는 전략을 채택하고 있습니다. Kubernetes 와 같은 컨테이너 오케스트레이션 도구를 통해 클라우드 간 일관된 배포 및 확장이 가능해졌습니다.</td></tr><tr><td><strong>자동화 및 지능형 확장</strong></td><td>AI 기반 자동 확장</td><td>머신러닝 모델을 활용하여 트래픽 패턴을 예측하고 선제적으로 리소스를 확장하는 지능형 자동 확장 시스템이 등장하고 있습니다. 이를 통해 성능 저하 없이 비용을 최적화할 수 있습니다.</td></tr><tr><td></td><td>FinOps 와 비용 최적화</td><td>클라우드 리소스 사용 비용을 최적화하기 위한 FinOps 관행이 확산되고 있습니다. 자동화된 비용 모니터링 및 최적화 도구를 통해 효율적인 확장 전략을 구현하는 기업이 증가하고 있습니다.</td></tr><tr><td><strong>데이터베이스 확장</strong></td><td>분산 데이터베이스의 발전</td><td>CockroachDB, TiDB 와 같은 분산 SQL 데이터베이스와 MongoDB, Cassandra 와 같은 NoSQL 데이터베이스는 수평적 확장성을 개선하여 글로벌 규모의 데이터 처리가 가능해졌습니다.</td></tr><tr><td></td><td>서버리스 데이터베이스</td><td>Amazon Aurora Serverless, Azure Cosmos DB 와 같은 서버리스 데이터베이스 솔루션이 자동 확장 기능을 제공하여 수동 확장 관리의 필요성을 줄이고 있습니다.</td></tr><tr><td><strong>엣지 컴퓨팅</strong></td><td>엣지 기반 수평적 확장</td><td>5G 네트워크의 확산과 함께 엣지 컴퓨팅이 보편화되면서, 사용자에 가까운 위치에서 처리를 수행하는 수평적 확장 전략이 증가하고 있습니다. 이를 통해 지연 시간을 줄이고 사용자 경험을 개선할 수 있습니다.</td></tr><tr><td></td><td>지역 분산 아키텍처</td><td>글로벌 서비스 제공을 위해 여러 지역에 걸쳐 리소스를 분산시키는 아키텍처가 표준이 되고 있습니다. 이를 통해 지역적 장애에 대한 내성을 높이고 데이터 주권 요구사항을 충족할 수 있습니다.</td></tr><tr><td><strong>하이브리드 확장</strong></td><td>동적 하이브리드 확장</td><td>워크로드 특성에 따라 수평적 확장과 수직적 확장을 동적으로 조합하는 하이브리드 접근법이 증가하고 있습니다. 컨테이너화된 마이크로서비스는 수평적으로 확장하고, 데이터베이스는 수직적으로 확장하는 등의 전략이 보편화되고 있습니다.</td></tr><tr><td></td><td>클라우드 - 온프레미스 하이브리드</td><td>클라우드와 온프레미스 환경을 결합한 하이브리드 모델이 확산되고 있습니다. 민감한 워크로드는 온프레미스에 유지하면서 확장이 필요한 워크로드는 클라우드로 이동하는 전략이 채택되고 있습니다.</td></tr><tr><td>클라우드 확장 전략</td><td>대각선 확장 (Diagonal Scaling)</td><td>수직 확장과 수평 확장을 결합하여 초기에는 서버 성능을 향상시키고, 이후에는 서버 수를 늘려 확장성을 확보하는 전략입니다.</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><ul><li><p><strong>수평 확장</strong>:</p><ul><li>분산 시스템에 대한 이해와 경험 필요</li><li>데이터 일관성 유지 방안 마련</li><li>모니터링 및 로깅 시스템 구축</li></ul></li><li><p><strong>수직 확장</strong>:</p><ul><li>하드웨어 업그레이드 시 다운타임 최소화 방안 고려</li><li>비용 대비 성능 향상 효과 분석</li><li>장기적인 확장성 계획 수립</li></ul></li></ul><h4 id=수평적-확장-vs-수직적-확장-선택-기준>수평적 확장 Vs 수직적 확장 선택 기준<a hidden class=anchor aria-hidden=true href=#수평적-확장-vs-수직적-확장-선택-기준>#</a></h4><table><thead><tr><th>기준</th><th>수평적 확장 선택</th><th>수직적 확장 선택</th></tr></thead><tbody><tr><td>워크로드 특성</td><td>병렬 처리 가능한 워크로드<br>무상태 (Stateless) 애플리케이션<br>읽기 중심 워크로드</td><td>단일 스레드 성능이 중요한 워크로드<br>상태 유지 (Stateful) 애플리케이션<br>트랜잭션 중심 워크로드</td></tr><tr><td><strong>확장 규모</strong></td><td>대규모 확장이 필요한 경우<br>글로벌 서비스<br>사용자 수 지속 증가</td><td>제한된 규모의 확장이 필요한 경우<br>로컬 또는 지역 서비스<br>안정적인 사용자 기반</td></tr><tr><td><strong>비용 구조</strong></td><td>유연한 비용 구조<br>사용량 기반 지불<br>점진적 투자</td><td>초기 투자 가능<br>예측 가능한 부하<br>장기적 사용을 위한 하드웨어</td></tr><tr><td><strong>가용성 요구사항</strong></td><td>고가용성 필요<br>지역 장애 대응<br>무중단 서비스</td><td>제한된 가용성 요구사항<br>계획된 다운타임 허용<br>백업 시스템으로 대응</td></tr><tr><td><strong>개발 팀 역량</strong></td><td>분산 시스템 경험<br>마이크로서비스 아키텍처 이해<br>DevOps 문화</td><td>단일 시스템 최적화 경험<br>하드웨어 성능 튜닝 지식<br>전통적인 운영 접근법</td></tr><tr><td><strong>시간 제약</strong></td><td>빠른 확장 필요<br>동적 환경<br>시장 변화에 빠른 대응</td><td>계획된 확장<br>안정적인 환경<br>충분한 계획 시간</td></tr></tbody></table><p>###최적화하기 위한 고려사항 및 주의할 점</p><ul><li><strong>리소스 모니터링</strong>: CPU, 메모리, 네트워크 사용량 등을 지속적으로 모니터링하여 병목 현상 파악</li><li><strong>자동 확장 설정</strong>: 트래픽 변화에 따라 자동으로 확장되도록 설정하여 효율적인 리소스 활용</li><li><strong>캐싱 전략</strong>: 반복되는 요청에 대해 캐싱을 활용하여 응답 속도 향상</li></ul><h3 id=주제와-관련하여-주목할-내용들>주제와 관련하여 주목할 내용들<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용들>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>확장성 패턴</strong></td><td>CQRS(Command Query Responsibility Segregation)</td><td>명령 (쓰기) 과 쿼리 (읽기) 책임을 분리하여 각각 독립적으로 확장할 수 있는 아키텍처 패턴입니다. 쓰기 작업은 수직적 확장, 읽기 작업은 수평적 확장을 적용할 수 있습니다.</td></tr><tr><td></td><td>이벤트 소싱 (Event Sourcing)</td><td>상태 변경을 이벤트 시퀀스로 저장하는 패턴으로, 수평적 확장에 적합한 이벤트 기반 아키텍처를 구현할 수 있습니다.</td></tr><tr><td></td><td>백프레셔 (Backpressure)</td><td>시스템 과부하를 방지하기 위해 처리 속도를 제어하는 메커니즘으로, 효율적인 확장을 위한 중요한 개념입니다.</td></tr><tr><td><strong>확장 기술</strong></td><td>서비스 매시 (Service Mesh)</td><td>Istio, Linkerd 와 같은 서비스 매시는 마이크로서비스 간 통신을 제어하고 관리하여 수평적 확장의 복잡성을 줄여줍니다.</td></tr><tr><td></td><td>데이터 샤딩 전략</td><td>다양한 샤딩 전략 (해시 기반, 범위 기반, 지역 기반) 을 통해 데이터베이스 확장성을 최적화할 수 있습니다.</td></tr><tr><td></td><td>함수형 프로그래밍</td><td>불변성과 순수 함수를 강조하는 함수형 프로그래밍은 병렬 처리와 수평적 확장에 유리한 특성을 제공합니다.</td></tr><tr><td><strong>확장 관리</strong></td><td>카오스 엔지니어링</td><td>프로덕션 환경에서 의도적으로 장애를 발생시켜 시스템의 복원력을 테스트하는 방법으로, 확장 전략의 견고성을 검증할 수 있습니다.</td></tr><tr><td></td><td>SRE(Site Reliability Engineering)</td><td>Google 이 선도한 이 방법론은 확장성, 신뢰성, 효율성을 균형 있게 관리하기 위한 체계적인 접근법을 제공합니다.</td></tr><tr><td></td><td>퍼포먼스 예산 (Performance Budget)</td><td>확장 계획의 일부로 성능 목표를 설정하고 추적하여 사용자 경험 저하 없이 효율적으로 확장할 수 있습니다.</td></tr><tr><td><strong>신기술</strong></td><td>WebAssembly</td><td>브라우저 외부에서도 사용 가능한 이 기술은 엣지 컴퓨팅과 결합하여 새로운 형태의 분산 확장을 가능하게 합니다.</td></tr><tr><td></td><td>에너지 효율적 확장</td><td>탄소 발자국을 줄이기 위한 에너지 효율적인 확장 전략이 중요해지고 있으며, 이는 데이터 센터 위치, 하드웨어 선택, 워크로드 최적화 등을 포함합니다.</td></tr><tr><td></td><td>양자 컴퓨팅 준비</td><td>향후 양자 컴퓨팅이 상용화되면 특정 워크로드에 대한 수직적 확장의 개념이 크게 변화할 수 있으며, 이에 대한 준비가 필요합니다.</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>지능형 자동화</strong></td><td>자가 최적화 시스템</td><td>AI/ML 을 활용하여 워크로드 패턴을 분석하고 최적의 확장 전략을 자동으로 결정하는 시스템이 보편화될 것입니다. 이러한 시스템은 수평적/수직적 확장을 동적으로 조합하여 비용과 성능 균형을 최적화할 것입니다.</td></tr><tr><td></td><td>예측적 확장</td><td>과거 데이터와 외부 요인 (이벤트, 마케팅 캠페인 등) 을 분석하여 부하를 예측하고 선제적으로 확장하는 시스템이 발전할 것입니다.</td></tr><tr><td><strong>클라우드 발전</strong></td><td>수평적/수직적 경계 희석</td><td>클라우드 기술의 발전으로 수평적 확장과 수직적 확장 간의 경계가 모호해질 것입니다. 자원 할당이 더욱 유연해지고 워크로드에 따라 동적으로 조정될 것입니다.</td></tr><tr><td></td><td>서버리스 2.0</td><td>현재의 서버리스 아키텍처를 넘어, 더 복잡한 워크로드와 상태 유지 애플리케이션도 효과적으로 처리할 수 있는 차세대 서버리스 플랫폼이 등장할 것입니다.</td></tr><tr><td><strong>분산 컴퓨팅</strong></td><td>엣지 - 클라우드 연속체</td><td>엣지 디바이스에서 클라우드 데이터 센터까지 연속적인 컴퓨팅 환경이 구축되어, 워크로드가 최적의 위치에서 자동으로 실행될 것입니다.</td></tr><tr><td></td><td>P2P 리소스 공유</td><td>블록체인 기술을 활용한 분산형 컴퓨팅 자원 공유 네트워크가 발전하여, 기존 클라우드 제공업체에 대한 대안이 될 수 있습니다.</td></tr><tr><td><strong>지속가능성</strong></td><td>그린 컴퓨팅</td><td>탄소 발자국 최소화를 위한 에너지 효율적인 확장 전략이 더욱 중요해질 것입니다. 재생 에너지 사용이 많은 지역에서의 워크로드 실행, 저전력 하드웨어 선택 등이 확장 결정에 영향을 미칠 것입니다.</td></tr><tr><td></td><td>탄소 인식 컴퓨팅</td><td>워크로드 실행 시 탄소 배출량을 고려하여 확장 결정을 내리는 시스템이 등장할 것입니다. 이는 재생 에너지 가용성이 높을 때 배치 작업을 실행하는 등의 전략을 포함합니다.</td></tr><tr><td><strong>새로운 컴퓨팅 패러다임</strong></td><td>양자 컴퓨팅 통합</td><td>양자 컴퓨팅이 특정 워크로드에 활용되기 시작하면서, 기존의 확장 패러다임을 넘어선 새로운 형태의 하이브리드 아키텍처가 등장할 것입니다.</td></tr><tr><td></td><td>뉴로모픽 컴퓨팅</td><td>뇌 구조를 모방한 뉴로모픽 하드웨어의 발전으로, AI 워크로드에 대한 새로운 형태의 수직적 확장이 가능해질 것입니다.</td></tr></tbody></table><h3 id=주제와-관련하여-추가-학습해야-할-내용>주제와 관련하여 추가 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-추가-학습해야-할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>분산 시스템</strong></td><td>CAP 이론</td><td>일관성 (Consistency), 가용성 (Availability), 분단 허용성 (Partition tolerance) 의 트레이드오프에 대한 이해. 수평적 확장 시 분산 시스템의 한계를 이해하는 데 필수적입니다.</td></tr><tr><td></td><td>분산 트랜잭션 관리</td><td>2 단계 커밋 (Two-Phase Commit), SAGA 패턴 등 분산 환경에서 트랜잭션 일관성을 보장하는 방법에 대한 학습이 필요합니다.</td></tr><tr><td></td><td>합의 알고리즘</td><td>Paxos, Raft 와 같은 알고리즘을 통해 분산 시스템에서 노드 간 합의를 이루는 방법을 학습해야 합니다.</td></tr><tr><td><strong>데이터베이스</strong></td><td>데이터베이스 샤딩 전략</td><td>해시 기반, 범위 기반, 디렉토리 기반 샤딩 등 다양한 데이터 분산 전략과 각각의 장단점을 이해해야 합니다.</td></tr><tr><td></td><td>NoSQL 확장성 패턴</td><td>MongoDB, Cassandra, DynamoDB 등 다양한 NoSQL 데이터베이스의 확장 메커니즘과 적합한 사용 사례를 학습해야 합니다.</td></tr><tr><td></td><td>데이터 일관성 모델</td><td>강한 일관성, 최종 일관성, 인과적 일관성 등 다양한 일관성 모델과 각각의 트레이드오프를 이해해야 합니다.</td></tr><tr><td><strong>클라우드 기술</strong></td><td>컨테이너 오케스트레이션</td><td>Kubernetes, Docker Swarm 등의 컨테이너 오케스트레이션 도구를 활용한 수평적 확장 구현 방법을 학습해야 합니다.</td></tr><tr><td></td><td>서버리스 아키텍처</td><td>AWS Lambda, Azure Functions 등 서버리스 플랫폼의 확장 모델과 한계, 적합한 워크로드를 이해해야 합니다.</td></tr><tr><td></td><td>클라우드 네이티브 패턴</td><td>12 요소 앱 (12-Factor App) 방법론, 클라우드 네이티브 설계 원칙을 학습하여 확장 가능한 애플리케이션을 설계해야 합니다.</td></tr><tr><td><strong>성능 최적화</strong></td><td>성능 테스트 및 분석</td><td>병목 현상 식별, 부하 테스트 도구 (JMeter, Gatling 등) 활용, 성능 지표 분석 방법을 학습해야 합니다.</td></tr><tr><td></td><td>캐싱 전략</td><td>로컬 캐시, 분산 캐시, CDN 등 다양한 수준의 캐싱 전략과 적합한 사용 사례를 이해해야 합니다.</td></tr><tr><td></td><td>비동기 처리 패턴</td><td>이벤트 루프, 비동기 I/O, 메시지 큐 등을 활용한 확장성 향상 방법을 학습해야 합니다.</td></tr><tr><td><strong>DevOps 및 자동화</strong></td><td>인프라스트럭처 자동화</td><td>Terraform, CloudFormation 등 IaC 도구를 활용한 확장 가능한 인프라 구축 방법을 학습해야 합니다.</td></tr><tr><td></td><td>모니터링 및 관측성</td><td>Prometheus, Grafana, ELK 스택 등을 활용한 분산 시스템 모니터링 및 문제 해결 방법을 이해해야 합니다.</td></tr><tr><td></td><td>CI/CD 파이프라인</td><td>지속적 통합 및 배포 파이프라인을 구축하여 확장 가능한 개발 및 배포 프로세스를 구현하는 방법을 학습해야 합니다.</td></tr><tr><td><strong>시스템 설계</strong></td><td>마이크로서비스 아키텍처</td><td>서비스 분해, API 게이트웨이, 서비스 발견 등 마이크로서비스 구현 및 확장 패턴을 이해해야 합니다.</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>이벤트 소싱, CQRS, 이벤트 스트리밍 등의 패턴을 활용한 확장 가능한 아키텍처 설계 방법을 학습해야 합니다.</td></tr><tr><td></td><td>회복력 있는 시스템 설계</td><td>서킷 브레이커, 재시도, 타임아웃 등의 패턴을 통해 회복력 있는 분산 시스템을 설계하는 방법을 이해해야 합니다.</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>수평적 확장 (Horizontal Scaling)</td><td>시스템 용량을 증가시키기 위해 더 많은 서버나 노드를 추가하는 방식. 스케일 아웃 (Scale-out) 이라고도 함</td></tr><tr><td>수직적 확장 (Vertical Scaling)</td><td>기존 서버의 성능을 향상시키기 위해 CPU, 메모리 등의 리소스를 증가시키는 방식. 스케일 업 (Scale-up) 이라고도 함</td></tr><tr><td>로드 밸런서 (Load Balancer)</td><td>여러 서버에 네트워크 트래픽을 분산시키는 장치 또는 소프트웨어</td></tr><tr><td>샤딩 (Sharding)</td><td>데이터베이스를 여러 서버에 분산시키는 기술로, 각 서버는 전체 데이터의 일부 (샤드) 를 저장함</td></tr><tr><td>레플리케이션 (Replication)</td><td>데이터나 서비스의 복제본을 여러 서버에 유지하는 기술</td></tr><tr><td>자동 확장 (Auto Scaling)</td><td>트래픽이나 리소스 사용량에 따라 자동으로 컴퓨팅 리소스를 증가시키거나 감소시키는 기능</td></tr><tr><td>서버리스 (Serverless)</td><td>서버 관리 없이 함수 단위의 코드를 실행할 수 있는 클라우드 컴퓨팅 모델</td></tr><tr><td>마이크로서비스 (Microservices)</td><td>애플리케이션을 작고 독립적인 서비스로 분해하여 개발하고 배포하는 아키텍처 스타일</td></tr><tr><td>CAP 이론</td><td>분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 분단 허용성 (Partition tolerance) 을 동시에 만족시킬 수 없다는 이론</td></tr><tr><td>CDN(Content Delivery Network)</td><td>콘텐츠를 사용자와 가까운 위치에서 제공하여 지연 시간을 줄이는 분산 서버 네트워크</td></tr><tr><td>분산 캐시 (Distributed Cache)</td><td>여러 서버에 걸쳐 데이터를 캐싱하는 시스템으로, 성능 향상과 부하 분산에 활용됨</td></tr><tr><td>엣지 컴퓨팅 (Edge Computing)</td><td>데이터 처리를 중앙 집중식 서버가 아닌 네트워크 엣지 (사용자와 가까운 위치) 에서 수행하는 방식</td></tr><tr><td>서비스 매시 (Service Mesh)</td><td>마이크로서비스 간 통신을 관리하고 제어하는 인프라 계층</td></tr><tr><td>CQRS(Command Query Responsibility Segregation)</td><td>명령 (쓰기) 과 쿼리 (읽기) 책임을 분리하는 아키텍처 패턴</td></tr><tr><td>이벤트 소싱 (Event Sourcing)</td><td>시스템의 상태 변경을 이벤트 시퀀스로 저장하는 패턴</td></tr><tr><td>SRE(Site Reliability Engineering)</td><td>소프트웨어 엔지니어링 기술을 활용하여 대규모 시스템의 운영 문제를 해결하는 분야</td></tr><tr><td>SPOF(Single Point of Failure)</td><td>단일 장애점으로 시스템 전체 중단 가능성</td></tr><tr><td>Hot Add</td><td>시스템 가동 중 리소스 추가</td></tr><tr><td>대각선 확장 (Diagonal Scaling)</td><td>수직 확장과 수평 확장을 결합하여 유연한 확장성을 확보하는 전략</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=수평수직-확장-관련-horizontal--vertical-scaling>수평/수직 확장 관련 (Horizontal & Vertical Scaling)<a hidden class=anchor aria-hidden=true href=#수평수직-확장-관련-horizontal--vertical-scaling>#</a></h3><ul><li><a href=https://www.digitalocean.com/resources/articles/scale-web-app>DigitalOcean: 9 Strategies to Scale Your Web App in 2025</a></li><li><a href=https://www.cloudzero.com/blog/horizontal-vs-vertical-scaling/>CloudZero: Horizontal Vs. Vertical Scaling</a></li><li><a href=https://www.geeksforgeeks.org/system-design-horizontal-and-vertical-scaling/>GeeksforGeeks - Horizontal and Vertical Scaling</a></li><li><a href=https://www.digitalocean.com/resources/articles/horizontal-scaling-vs-vertical-scaling>DigitalOcean - Horizontal scaling vs vertical scaling</a></li><li><a href=https://dev.to/somadevtoo/horizontal-scaling-vs-vertical-scaling-in-system-design-3n09>DEV Community - Horizontal scaling vs Vertical Scaling in System Design</a></li><li><a href=https://www.geeksforgeeks.org/horizontal-and-vertical-scaling-in-databases/>GeeksforGeeks - Horizontal and Vertical Scaling In Databases</a></li><li><a href=https://www.nops.io/blog/horizontal-vs-vertical-scaling/>nOps - Horizontal vs. Vertical Scaling: HPA, VPA & Beyond</a></li><li><a href=https://www.prepbytes.com/blog/system-design/system-design-horizontal-and-vertical-scaling/>PrepBytes - System Design – Horizontal and Vertical Scaling</a></li><li><a href=https://spot.io/blog/horizontal-vs-vertical-scaling-in-the-cloud/>Spot.io - Horizontal vs. Vertical Scaling in the Cloud</a></li><li><a href=https://www.linkedin.com/pulse/horizontal-scaling-vs-vertical-your-business-like-pro-gitonga-bretton>LinkedIn - Horizontal Scaling vs. Vertical Scaling</a></li></ul><h3 id=클라우드자동-확장-트렌드>클라우드/자동 확장 트렌드<a hidden class=anchor aria-hidden=true href=#클라우드자동-확장-트렌드>#</a></h3><ul><li><a href=https://www.fynd.academy/blog/elasticity-in-cloud-computing>Fynd Academy: Scalability and Elasticity in Cloud Computing in 2025</a></li><li><a href=https://www.wipro.com/content/dam/nexus/en/lab45/images/cloud-trends-2025-unveiling-the-future-of-cloud-technology.pdf>Wipro: Cloud Trends 2025 - Unveiling the Future of Cloud Technology</a></li><li><a href=https://www.cloudzero.com/blog/cloud-computing-market-size/>CloudZero: 2025 Cloud Computing Market Size And Trends</a></li></ul><h3 id=최신-연구-논문-arxiv>최신 연구 논문 (arXiv)<a hidden class=anchor aria-hidden=true href=#최신-연구-논문-arxiv>#</a></h3><ul><li><a href=https://arxiv.org/abs/2505.01968>HAS-GPU: Efficient Hybrid Auto-scaling with Fine-grained GPU Allocation</a></li><li><a href=https://arxiv.org/abs/2407.14843>A Tale of Two Scales: Reconciling Horizontal and Vertical Scaling</a></li><li><a href=https://arxiv.org/abs/2407.10173>StatuScale: Status-aware and Elastic Scaling Strategy for Microservice Applications</a></li></ul><hr><h3 id=kubernetes--자동화-관련>Kubernetes / 자동화 관련<a hidden class=anchor aria-hidden=true href=#kubernetes--자동화-관련>#</a></h3><ul><li><a href=https://www.nops.io>Kubernetes Auto-scaling: nOps</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-design/>System-Design</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/performance-vs-scalability/>Performance-vs-Scalability</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-load-balancing/><span class=title>« Prev</span><br><span>Load Shifting vs. Load Balancing</span>
</a><a class=next href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/oauth/oauth-20-vs-openid-connect/><span class=title>Next »</span><br><span>OAuth 2.0 vs. OpenID Connect</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>