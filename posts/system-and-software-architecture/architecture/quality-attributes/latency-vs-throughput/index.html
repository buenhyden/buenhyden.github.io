<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Latency vs Throughput | hyunyoun's Blog</title><meta name=keywords content="System-Design,Fundamentals,Latency-vs-Throughput"><meta name=description content="지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Latency vs Throughput"><meta property="og:description" content="지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-18T05:08:00+00:00"><meta property="article:modified_time" content="2025-02-18T05:08:00+00:00"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Latency-vs-Throughput"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Latency vs Throughput"><meta name=twitter:description content="지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Latency vs Throughput","item":"https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Latency vs Throughput","name":"Latency vs Throughput","description":"지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다.","keywords":["System-Design","Fundamentals","Latency-vs-Throughput"],"articleBody":"Latency vs. Throughput Latency 와 Throughput 은 시스템 성능 평가의 양대 축으로 상호 보완적인 지표이다. Latency는 데이터 전송 지연 시간 (밀리초 단위) 으로, 실시간 화상 회의나 온라인 게임에서 사용자 경험에 직접적 영향을 미친다. Throughput은 초당 처리 가능한 데이터량 (MBps) 으로 대용량 트래픽 처리 능력을 결정한다. 시스템 설계자는 대역폭, 병목 현상, 하드웨어 자원 등 다양한 요소를 고려하여 균형점을 찾아야 한다. 이를 통해 실시간 시스템, 대용량 데이터 처리 등 다양한 응용 분야에서 최적의 성능을 달성할 수 있다.\n핵심 개념 지연시간 (Latency)\n지연시간은 데이터가 한 지점에서 다른 지점으로 이동하는 데 걸리는 시간이다. 시스템에서 요청이 시작된 시점부터 응답을 받는 시점까지의 지연을 의미합니다. 주로 밀리초 (ms), 마이크로초 (μs) 또는 나노초 (ns) 단위로 측정됩니다. 낮은 지연시간은 시스템의 응답성이 좋다는 것을 의미하며, 실시간 상호작용이 중요한 애플리케이션에서 특히 중요합니다.\n처리량 (Throughput)\n처리량은 시스템이 단위 시간당 처리할 수 있는 작업량을 나타낸다. 네트워크에서는 초당 비트 수 (bps), 초당 요청 수 (RPS), 또는 초당 트랜잭션 수 (TPS) 등으로 측정된다. 높은 처리량은 시스템이 효율적으로 많은 작업을 처리할 수 있음을 의미하며, 대용량 데이터 처리가 필요한 시스템에서 중요한다.\n대역폭 (Bandwidth)\n대역폭은 통신 채널의 최대 이론적 처리량을 나타낸다. 네트워크 케이블이나 연결이 처리할 수 있는 최대 데이터 양을 의미하며, 일반적으로 초당 비트 수 (bps) 로 표시된다. 대역폭은 처리량의 상한선을 설정하며, 실제 처리량은 대역폭보다 낮다.\n상충관계 (Trade-off)\n지연시간과 처리량 사이에는 상충관계가 존재한다. 처리량을 높이기 위해 배치 처리, 병렬 처리 등의 기법을 사용하면 개별 요청의 지연시간이 증가할 수 있다. 반대로 지연시간을 최소화하기 위해 자원을 최적화하면 전체 처리량이 감소할 수 있다. 시스템 설계자는 애플리케이션의 요구사항에 따라 적절한 균형점을 찾아야 한다.\n병목 현상 (Bottlenecks)\n시스템 내에서 전체 성능을 제한하는 요소를 병목 현상이라고 한다. 네트워크 대역폭, CPU 처리 능력, 메모리 접근 속도, 디스크 I/O 등 다양한 요소가 병목 현상을 일으킬 수 있으며, 이는 지연시간 증가와 처리량 감소로 이어진다. 효율적인 시스템 설계를 위해서는 병목 현상을 식별하고 해결하는 것이 중요하다.\n확장성 (Scalability)\n시스템이 증가하는 부하를 처리하기 위해 자원을 효율적으로 추가할 수 있는 능력을 의미한다. 수평적 확장 (더 많은 서버 추가) 과 수직적 확장 (더 강력한 서버로 업그레이드) 을 통해 처리량을 증가시킬 수 있다. 그러나 확장 시 지연시간에 미치는 영향도 고려해야 한다.\n응답 시간 (Response Time)\n응답 시간은 사용자가 요청을 보내고 완전한 응답을 받는 데 걸리는 총 시간을 의미한다. 지연시간과 관련이 있지만, 응답 시간에는 처리 시간과 대기 시간도 포함된다. 사용자 경험에 직접적인 영향을 미치는 중요한 지표이다.\n큐잉 이론 (Queueing Theory)\n큐잉 이론은 대기열 (큐) 의 동작을 수학적으로 연구하는 분야로, 지연시간과 처리량의 관계를 이해하는 데 중요한 이론적 기반을 제공한다. Little 의 법칙 (L = λW) 과 같은 원리를 통해 시스템의 성능을 예측하고 최적화할 수 있다.\n지연 시간 (Latency) vs. 처리량 (Throughput) 비교 사용자 경험 향상, 자원 활용 효율성 증대, 성능 병목 현상 파악, 확장성 계획 수립 등 다양한 목적을 위해 이 두 지표의 이해와 관리가 필요하다.\n항목 지연 시간 (Latency) 처리량 (Throughput) 정의 요청이 시작되어 응답을 받기까지의 시간 단위 시간당 처리 가능한 작업의 양 측정 단위 밀리초 (ms), 마이크로초 (μs) 등 초당 요청 수 (RPS), Mbps 등 중요성 실시간 응답이 필요한 시스템에서 중요 대량의 데이터 처리 시스템에서 중요 영향 요소 네트워크 지연, 처리 시간, 큐 대기 시간 등 시스템 자원, 네트워크 대역폭 등 최적화 목표 최소화 (낮을수록 좋음) 최대화 (높을수록 좋음) 최적화 방법 캐싱, 로드 밸런싱, 경량화 등 병렬 처리, 리소스 확장 등 중요 응용 분야 실시간 시스템, 온라인 게임, 금융 거래 시스템 대용량 데이터 처리, 백업 시스템, 데이터 마이그레이션 주요 기능 및 역할 지연시간과 처리량은 시스템 성능을 다각도로 평가하고 최적화하는 데 핵심적인 역할을 한다.\n항목 지연시간 (Latency) 처리량 (Throughput) 주요 역할 시스템 응답성 평가, 실시간성 보장, 사용자 경험 향상 시스템 효율성 평가, 자원 활용도 측정, 확장성 계획 성능 지표로서의 활용 애플리케이션의 응답 시간과 직접 연관, P99 지연시간 등 SLA 정의에 활용 시스템의 최대 처리 능력 정의, 용량 계획 수립에 활용 병목 현상 식별 높은 지연시간은 네트워크, CPU, 메모리 등의 병목 현상 식별에 도움 예상보다 낮은 처리량은 시스템 내 병목 현상 식별에 도움 시스템 설계 영향 낮은 지연시간을 위한 설계는 캐싱, 지역성, 효율적인 알고리즘 등에 초점 높은 처리량을 위한 설계는 병렬 처리, 배치 처리, 자원 효율성 등에 초점 특징 지연시간과 처리량은 다양한 요소에 의해 영향을 받으며, 각기 다른 특성을 가지고 있다.\n항목 지연시간 (Latency) 처리량 (Throughput) 변동성 네트워크 혼잡, 부하 변동 등에 따라 크게 변할 수 있음 시스템 자원 한계에 도달하기 전까지는 비교적 안정적 사용자 경험 영향 직접적인 영향 (느린 응답 = 나쁜 경험) 간접적인 영향 (처리량 한계 도달 시 지연시간 증가로 이어짐) 분포 특성 꼬리가 긴 (long-tailed) 분포를 보이는 경우가 많음 (P99, P999 지연시간 중요) 일반적으로 평균값이 의미 있는 정규 분포에 가까움 최적화 접근법 병렬 처리보다 직렬 처리가 유리할 수 있음 병렬 처리, 배치 처리가 유리함 핵심 원칙 지연시간과 처리량을 최적화하기 위한 핵심 원칙.\n원칙 설명 균형 찾기 애플리케이션 요구사항에 맞게 지연시간과 처리량 사이의 적절한 균형점 찾기 병목 현상 제거 시스템 내 병목 현상을 식별하고 제거하여 전체 성능 향상 적절한 측정 정확한 지연시간과 처리량 측정을 통해 성능 문제 식별 및 개선 확장성 고려 부하 증가에 따른 지연시간과 처리량의 변화를 고려한 확장 계획 수립 실제 사용자 경험 우선 평균값보다 P95, P99 등 실제 사용자가 경험하는 성능 지표에 초점 주요 원리 및 작동 원리 지연시간과 처리량의 관계는 다양한 이론과 원리로 설명될 수 있다.\n큐잉 이론과 Little 의 법칙 큐잉 이론은 지연시간과 처리량 사이의 관계를 수학적으로 설명한다. Little 의 법칙 (L = λW) 은 시스템 내 평균 요청 수 (L) 가 도착률 (λ) 과 평균 대기 시간 (W) 의 곱과 같다는 원리를 설명한다. 이는 처리량 (λ) 과 지연시간 (W) 사이의 근본적인 관계를 보여준다.\n지연시간 - 처리량 곡선 아래의 이미지는 분산 네트워크 성능 분석을 위한 **지연시간 - 처리량 곡선 (Latency-Throughput Curve)**을 보여주며, 다음과 같은 핵심 요소를 포함한다.\nX 축 (Injection Rate)\n트래픽 주입률: 네트워크에 초당 주입되는 데이터 양 (단위: flits/cycle). **0 부터 포화점 (Saturation Point)**까지 증가하며, 네트워크 부하를 점진적으로 높임. Y 축 (Latency)\n패킷 지연시간: 데이터가 네트워크를 통과하는 데 걸리는 시간 (단위: cycles). 초기에는 낮은 값 유지 → 트래픽 증가 시 급격히 상승. 곡선 형태\n선형 구간 (Linear Region): 낮은 주입률에서 처리량 증가 ↔ 지연시간 완만 상승. 포화 구간 (Saturation Region): 주입률 증가해도 처리량 정체 ↔ 지연시간 급증. 곡선 해석 및 성능 지표\n구분 설명 기술적 의미 Zero-Load Latency 트래픽이 0 일 때의 지연시간 네트워크 기본 성능 (토폴로지, 라우팅 알고리즘 영향) Saturation Throughput 네트워크가 처리할 수 있는 최대 처리량 플로우 컨트롤 및 버퍼 관리 효율성 결정 Latency Slope 지연시간 증가 기울기 네트워크 혼잡도 및 리소스 경쟁 정도 반영 성능 영향 요소\n토폴로지 (Topology)\n예시: 메시 (Mesh), 토러스 (Torus) → Bisection Bandwidth가 처리량 상한 결정. 영향: 높은 대역폭 → 포화점 지연. 라우팅 알고리즘 (Routing)\nMinimal vs. Non-Minimal: 비최소 라우팅은 지연시간 증가 대신 포화 처리량 향상. Adaptive Routing: 트래픽 부하에 따라 경로 동적 조정 → 곡선 형태 최적화. 플로우 컨트롤 (Flow Control)\nVirtual Channel 사용: 버퍼 경쟁 감소 → 포화 처리량 40% 향상 가능. Credit-Based vs. On/Off: 신호 오버헤드 차이로 지연시간 변동. 처리량 제한 요소 처리량은 다양한 요소에 의해 제한될 수 있다:\n하드웨어 제한: CPU, 메모리, 디스크 I/O 등 네트워크 제한: 대역폭, 패킷 손실, 혼잡 제어 소프트웨어 제한: 비효율적인 알고리즘, 동기화 오버헤드 지연시간 구성 요소 지연시간은 여러 구성 요소로 이루어져 있다:\n전파 지연 (Propagation Delay): 데이터가 물리적 거리를 이동하는 데 걸리는 시간 전송 지연 (Transmission Delay): 데이터를 매체에 전송하는 데 걸리는 시간 처리 지연 (Processing Delay): 데이터를 처리하는 데 걸리는 시간 대기열 지연 (Queuing Delay): 처리를 기다리는 동안 발생하는 지연 지연시간과 처리량의 관계 구조 및 아키텍처 지연 시간 최적화 아키텍처 지연 시간을 최소화하기 위해, 클라이언트와 서버 간의 거리를 줄이고, 데이터 처리 경로를 최적화하는 구조를 채택한다.\n요청 처리 경로를 최소화하고, 캐싱과 지역성을 활용하여 빠른 응답 시간을 제공한다. 예를 들어, CDN(Content Delivery Network) 을 활용하여 사용자와 가까운 위치에서 콘텐츠를 제공함으로써 지연 시간을 줄일 수 있다. 실시간 시스템, 온라인 게임, 고주파 거래 시스템 등에 적합하다.\n주요 특징:\n요청 경로 최소화 (홉 수 줄이기) 엣지 컴퓨팅 활용 캐싱 최적화 비동기 처리 대신 동기 처리 활용 지역성 (Locality) 최적화 처리량 최적화 아키텍처 처리량을 극대화하기 위해, 시스템은 병렬 처리, 배치 처리, 큐 시스템와 리소스 확장을 활용하여 높은 처리량을 제공한다. 예를 들어, 마이크로서비스 아키텍처를 도입하여 각 서비스가 독립적으로 확장 가능하게 설계함으로써 전체 시스템의 처리량을 향상시킬 수 있다. 이는 대용량 데이터 처리, 분석 시스템, 백업 시스템 등에 적합하다.\n주요 특징:\n병렬 처리 극대화 배치 처리 활용 큐 시스템 구현 비동기 처리 활용 수평적 확장성 설계 균형 잡힌 아키텍처 대부분의 실제 시스템은 지연시간과 처리량 사이의 균형을 맞추어야 한다. 이를 위해 다양한 기법을 조합하여 사용한다.\n주요 특징:\n마이크로서비스 아키텍처 캐싱과 큐 시스템의 조합 적응형 배치 처리 우선순위 기반 스케줄링 지능형 부하 분산 구성 요소 구성 요소 기능 및 역할 종류 작동 방식 지연시간 최적화 기여 처리량 최적화 기여 캐싱 시스템 자주 접근하는 데이터를 메모리에 저장하여 빠른 응답 제공 메모리 내 캐시, 분산 캐시 (Redis, Memcached), CDN, 브라우저 캐시 캐시 적중 시 원본 접근 없이 빠르게 데이터 제공 데이터 접근 속도를 메모리 수준으로 줄여 응답 시간 단축 원본 시스템의 부하 감소로 더 많은 요청을 처리 가능 로드 밸런서 요청을 여러 서버에 분산시켜 부하를 균등하게 처리 L4, L7, 글로벌 로드 밸런서 라운드 로빈, 최소 연결, 최소 지연시간 등 알고리즘으로 분산 가장 응답 속도가 빠른 서버로 분산하여 응답 지연 최소화 서버 간 부하 분산으로 동시 요청 처리량 증가 메시지 큐 비동기 처리로 병렬 처리 및 시스템 독립성 확보 Kafka, RabbitMQ, SQS, Pub/Sub 생산자가 메시지를 큐에 넣고 소비자가 비동기적으로 처리 요청 즉시 처리하지 않고 큐에 저장하여 시스템 병목 완화 소비자가 독립적으로 처리하므로 고속의 비동기 처리 가능 데이터베이스 데이터 저장, 쿼리 처리 및 트랜잭션 관리 RDBMS, NoSQL, 시계열 DB, 그래프 DB 인덱싱, 샤딩, 복제 등으로 성능 향상 인덱싱으로 검색 속도 향상, 캐싱으로 반복 조회 시간 절감 샤딩/복제로 수평 확장하여 높은 처리량 확보 네트워크 구성 요소 패킷 전송, 라우팅, 트래픽 제어 및 보안 라우터, 스위치, 프록시, 방화벽, CDN 패킷 포워딩, 큐잉, 우선순위 지정 등 네트워크 최적화 CDN, QoS 로 요청을 사용자 가까운 위치에서 처리해 지연 최소화 대역폭 제어, 트래픽 분산으로 동시 요청 수용 능력 증가 장점과 단점 접근 방식 장점 단점 지연시간 우선 최적화 - 사용자 경험 향상\n- 실시간 상호작용 개선\n- 빠른 응답성으로 사용자 만족도 증가 - 자원 활용도 감소 가능\n- 처리량 제한 가능\n- 구현 및 유지보수 비용 증가 처리량 우선 최적화 - 효율적인 자원 활용\n- 높은 데이터 처리 용량\n- 비용 효율적인 처리 - 개별 요청의 지연시간 증가\n- 실시간성 저하\n- 복잡한 비동기 처리 로직 필요 균형 잡힌 접근법 - 다양한 워크로드 지원\n- 확장성 향상\n- 사용자 경험과 효율성 모두 고려 - 구현 복잡도 증가\n- 더 많은 설계 노력 필요\n- 다양한 기술 스택 필요 지연시간과 처리량 최적화의 장단점과 운영 기준.\n측면 지연시간 최적화 장단점 처리량 최적화 장단점 운영 기준 인프라 비용 - 장점: 일부 영역만 고사양 장비 필요\n- 단점: 지리적 분산으로 인한 추가 비용 - 장점: 규모의 경제로 비용 효율성\n- 단점: 대규모 처리 인프라 필요 - 트래픽 패턴 분석\nROI 기반 인프라 투자\n- 클라우드 vs 온프레미스 결정 개발 복잡성 - 장점: 동기식 처리로 간단한 디버깅\n- 단점: 캐싱, 무효화 등 복잡한 로직 필요 - 장점: 표준화된 배치 처리 패턴\n- 단점: 비동기 처리의 복잡성, 재시도 로직 - 개발자 경험 고려\n- 적절한 추상화 레벨 설정\n- 자동화된 테스트 중요 확장성 - 장점: 수직적 확장으로 단순함\n- 단점: 물리적 한계 존재 - 장점: 수평적 확장으로 거의 무제한\n- 단점: 분산 시스템 복잡성 - 미래 성장 예측\n- 점진적 확장 계획\n- 확장성 병목 지속 모니터링 사용자 경험 - 장점: 즉각적 반응으로 좋은 UX\n- 단점: 부하 증가 시 성능 저하 가능성 - 장점: 안정적인 대량 데이터 처리\n- 단점: 개별 요청 지연 가능성 - 사용자 만족도 측정\n- 업계 벤치마크 대비 성능\nA/B 테스트를 통한 개선 유지보수 - 장점: 간단한 아키텍처 가능\n- 단점: 성능 튜닝의 지속적 필요성 - 장점: 모듈화된 컴포넌트\n- 단점: 분산 시스템 디버깅 어려움 - 모니터링 및 알림 체계\n- 성능 회귀 테스트\n- 정기적인 성능 검토 실무 적용 예시 사례 적용 방식 설명 온라인 게임 지연 시간 최적화 실시간 반응이 중요하므로 지연 시간을 최소화하여 사용자 경험 향상 데이터 분석 시스템 처리량 최적화 대량의 데이터를 효율적으로 처리하기 위해 시스템의 처리량을 극대화 스트리밍 서비스 지연 시간 및 처리량 최적화 빠른 응답과 안정적인 데이터 전송을 위해 지연 시간과 처리량을 동시에 최적화 활용 사례 시나리오: 대규모 E- 커머스 플랫폼의 성능 최적화\n상황: 대규모 온라인 쇼핑몰이 블랙프라이데이와 같은 특별 할인 기간 동안 트래픽이 평소의 10 배 이상 증가하는 문제에 직면했습니다. 사이트 로딩 시간이 길어지고, 결제 프로세스가 지연되며, 일부 사용자는 서비스를 이용할 수 없는 상황이 발생했습니다.\n목표:\n사이트 로딩 시간을 2 초 이내로 유지 장바구니 추가 및 결제 프로세스 응답 시간을 500ms 이내로 유지 초당 최소 5,000 건의 트랜잭션 처리 가능 99.99% 서비스 가용성 확보 E- 커머스 플랫폼 지연시간/처리량 최적화 다이어그램\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 [글로벌 사용자] │ ▼ +----------------------+ │ CloudFront CDN │◄─정적 자원(이미지,JS,CSS) │ (Edge Lambda@Edge) │─┐ +-----------+-----------+ │ │ │ │API 요청 │동적 콘텐츠 처리 ▼ │ +----------------------+ │ │ AWS Global Accelerator │ +-----------+-----------+ │ │ │ +----------+-----------+ │ ▼ ▼ │ +-----------------------+ +-----------------------+ │ API Gateway (REST) │ │ WebSocket Gateway │ │ - Rate Limiting │ │ - 실시간 재고 업데이트 │ │ - JWT 인증 │ +-----------+-----------+ +-----------+-----------+ │ │ │ ┌─────────────────┴─────────────────┐ │ ▼ ▼ ▼ +------------------+ +------------------+ +------------------+ │ Auto-Scaling Group │ Elastic Container │ │ Serverless │ │ - Web Server Cluster │ Service (ECS) │ │ (Lambda) │ │ - CPU 80% 기준 확장 │ - 결제/주문 마이크로서비스 │ │ - 추천 엔진 │ +------------------+ +------------------+ +------------------+ │ │ │ │ │ │ ▼ ▼ ▼ +------------------+ +------------------+ +------------------+ │ Redis Cluster │◄─세션/캐시────│ API Cache Layer │ │ Event Bridge │ │ (Multi-AZ) │─┐ │ (DynamoDB DAX) │ │ - 이벤트 오케스트레이션│ +------------------+ │ +------------------+ +------------------+ │ │ │ │ ▼ ▼ │ +------------------+ +------------------+ │ │ Read Replicas │ │ SQS/SNS/Kafka │ │ │ (Aurora Global DB)│ │ - 비동기 작업 큐 │ │ +------------------+ +------------------+ │ ▲ │ │ │ │ └───────┐ +------------------+ +------------------+ │ │ Primary Database │◄─────│ Batch Workers │ │ │ (Sharded RDS) │ │ (EC2 Spot) │ │ +------------------+ +------------------+ │ │ │ ▼ │ +------------------+ │ │ Data Lake │ │ │ (S3 + Athena) │ │ +------------------+ │ +------------------+ │ 모니터링 시스템 │ │ - CloudWatch │ │ - X-Ray │ │ - Prometheus │ +------------------+ 최적화 전략 (지연시간 vs. 처리량)\n구분 지연시간 최적화 전략 처리량 최적화 전략 핵심 기술 - CDN 엣지 캐싱\n- 인메모리 데이터베이스\n- Lazy Loading - Auto Scaling\n- DB 샤딩\n- 비동기 큐 주요 서비스 CloudFront, Redis, DAX ECS Fargate, Aurora Global, SQS 최적화 대상 사용자 체감 성능 (FCP, TTI) 시스템 처리 용량 (RPS, TPS) 모니터링 지표 - Time to First Byte (TTFB)\n- DOM Load - CPU/Memory Utilization\n- Queue Depth 트레이드오프 높은 인프라 비용 데이터 일관성 지연 가능성 적용 사례 제품 페이지 로딩, 검색 결과 주문 처리, 재고 관리, 배치 작업 계층별 최적화\n프론트엔드 계층 (지연시간 \u003c1s)\n점진적 정적 재생성 (ISR): Next.js 15+ 의 On-demand ISR 로 실시간 콘텐츠 갱신 WebAssembly 최적화: 이미지 리사이징을 WASM 으로 엣지 처리 HTTP/3 + QUIC: 멀티플렉싱으로 연결 지연시간 40% 감소 API 계층 (지연시간 \u003c300ms)\n계층적 캐싱 전략:\ngraph LR A[User] --\u003e B[Edge API Cache - 50ms] B --\u003e C{Cache Hit?} C --\u003e|Yes| D[Return Response] C --\u003e|No| E[Region API Cache - 100ms] E --\u003e F{Cache Hit?} F --\u003e|Yes| G[Return Response] F --\u003e|No| H[Origin Server - 300ms] GraphQL 지연 로딩: @defer 지시어 활용해 부분 응답 스트리밍\n데이터 계층 (처리량 \u003e10k TPS)\nAI 기반 샤딩:\n1 2 3 4 # 머신러닝 기반 샤드 키 생성 model = CatBoostClassifier() model.fit(user_behavior_data, shard_hotspots) shard_key = model.predict(new_data) 벡터화 쿼리 처리: PostgreSQL pgvector 확장으로 유사도 검색 가속화\n배치 처리 계층\n서버리스 스팟 인스턴스: AWS Lambda + EC2 Spot 혼합 배치로 비용 70% 절감 예측 확장: Prophet 모델 기반 트래픽 예측 → 리소스 사전 할당 핵심 설계 원칙\n지연시간 민감도 계층화:\n1 2 사용자 체감 영역 (Tier 0) → 마이크로초 단위 최적화 백오피스 영역 (Tier 2) → 처리량 중심 설계 비용 - 성능 최적화 곡선:\n1 2 $1/ms 감소 당 월 $2,400 절감 (10M MAU 기준) → CloudFront Intelligent Tiering + Lambda@Edge 조합으로 달성 장애 전파 차단:\n1 2 회로 차단기(Circuit Breaker) 패턴 구현 → Istio 서비스 메시에서 500ms 타임아웃 기준 자동 차단 Google, Meta 사례 기반 구조 선택 전략 Google 과 Meta(Facebook) 는 각자의 서비스 특성에 맞는 지연시간과 처리량 최적화 전략을 구현했다.\nGoogle 의 접근법 Google 은 다양한 서비스에 따라 다른 최적화 전략을 적용한다:\n검색 엔진: 낮은 지연시간을 위해 글로벌 분산 아키텍처와 인메모리 캐싱을 활용한다. Google 의 검색은 사용자 쿼리를 즉각 처리하기 위해 처리량보다 지연시간을 우선시한다. BigTable/Spanner: 분산 데이터베이스 시스템으로, 지연시간과 처리량의 균형을 맞추기 위해 설계되었다. Google 의 SRE(Site Reliability Engineering) 책에서는 BigTable 에 대해 \" 지연 시간이 낮은 사용자는 시스템이 도착하는 각 요청을 즉시 처리할 수 있도록 큐가 (거의 항상) 비어 있기를 원하지만, 오프라인 분석에 관심이 있는 사용자는 처리량에 더 관심이 있습니다 \" 라고 설명한다. Google 클라우드 네트워크: 프리미엄 티어에서는 자체 글로벌 백본 네트워크를 활용하여 지연시간을 최소화하고, 표준 티어에서는 인터넷을 통한 라우팅으로 비용 대비 처리량을 최적화한다. Meta(Facebook) 의 접근법 Meta 는 소셜 네트워크 특성에 맞게 다음과 같은 최적화 전략을 사용한다:\nTAO(The Associations and Objects): Facebook’s 소셜 그래프를 저장하는 분산 데이터 저장소로, 읽기 중심 워크로드에 최적화되어 있다. 다중 레이어 캐싱으로 지연시간을 최소화한다. Proxygen: Facebook 의 HTTP 서버 프레임워크로, 처리량 최적화를 위한 멀티스레딩과 지연시간 최적화를 위한 비동기 I/O 를 모두 활용한다. TCP BBR(Bottleneck Bandwidth and Round-trip propagation time): Google 이 개발하고 Meta 도 채택한 TCP 혼잡 제어 알고리즘으로, 네트워크 지연시간과 처리량을 모두 개선한다. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 고려사항 설명 사용자 경험 우선 사용자와 직접 상호작용하는 기능은 지연시간 최적화에, 백그라운드 처리는 처리량 최적화에 중점을 둡니다. 측정 기반 접근 실제 측정을 통해 병목 현상을 식별하고, 최적화 전략을 수립합니다. 가정이 아닌 데이터에 기반한 의사결정이 중요합니다. 점진적 개선 한 번에 모든 것을 최적화하려 하지 말고, 가장 큰 영향을 미치는 부분부터 점진적으로 개선합니다. 캐싱 전략 캐싱은 지연시간을 크게 줄일 수 있지만, 캐시 무효화와 일관성 문제에 주의해야 합니다. 비동기 처리 비동기 처리로 처리량을 높일 수 있지만, 복잡성이 증가하고 디버깅이 어려워질 수 있습니다. 확장성 설계 초기부터 확장성을 고려한 설계로 나중에 대규모 재작업을 방지합니다. 모니터링과 알림 지연시간과 처리량을 지속적으로 모니터링하고, 이상 징후 발생 시 즉시 알림을 받을 수 있는 시스템을 구축합니다. 최적화하기 위한 고려사항 및 주의할 점 고려사항 지연시간 최적화 처리량 최적화 하드웨어 최적화 - 더 빠른 CPU 와 메모리\nSSD 스토리지\n- 네트워크 하드웨어 업그레이드 - 더 많은 코어와 스레드\n- 대용량 메모리\n- 빠른 대용량 스토리지 소프트웨어 최적화 - 알고리즘 효율성 개선\nI/O 최소화\n- 동기화 병목 제거 - 병렬 처리 최적화\n- 배치 처리 효율화\n- 리소스 활용 극대화 네트워크 최적화 TCP 최적화 (BBR 같은 혼잡 제어)\n- 연결 재사용\n- 지역성 최적화 - 대역폭 확장\n- 프로토콜 최적화\n- 로드 밸런싱 데이터베이스 최적화 - 인덱싱 최적화\n- 쿼리 최적화\n- 캐싱 적용 - 파티셔닝/샤딩\n- 벌크 작업 최적화\n- 읽기/쓰기 분리 애플리케이션 설계 - 비동기 I/O\n- 마이크로서비스 아키텍처\n- 이벤트 기반 아키텍처 - 워커 풀 최적화\n- 작업 스케줄링\n- 큐 기반 처리 주제와 관련하여 주목할 내용 주제 항목 설명 네트워킹 TCP BBR Google 의 TCP BBR(Bottleneck Bandwidth and RTT) 혼잡 제어 알고리즘이 지연시간과 처리량을 동시에 최적화하는 접근법으로 주목받고 있습니다. 분산 시스템 서킷 브레이커 서킷 브레이커 패턴이 분산 시스템에서 장애 전파를 방지하고 지연시간 최소화와 처리량 유지에 기여하고 있습니다. 컨테이너 기술 Service Mesh Istio, Linkerd 등의 서비스 메시가 마이크로서비스 간 통신 최적화와 지연시간 모니터링을 제공합니다. 측정 방법론 테일 지연시간 평균 지연시간보다 P95, P99 등 테일 지연시간 (극단값) 에 초점을 맞춘 측정과 최적화가 중요해지고 있습니다. AI/ML 자율 최적화 AI/ML 을 활용한 자율적 성능 최적화 시스템이 지연시간과 처리량의 동적 균형을 찾는 방향으로 발전하고 있습니다. 모니터링 분산 추적 OpenTelemetry 와 같은 분산 추적 시스템이 복잡한 시스템에서 지연시간 문제 원인 파악에 필수적인 도구로 자리 잡고 있습니다. 최신 동향 주제 항목 설명 엣지 컴퓨팅 로컬 처리 사용자와 가까운 위치에서 데이터를 처리하여 지연시간을 크게 줄이는 엣지 컴퓨팅 기술이 확산되고 있습니다. 5G 와 결합하여 실시간 응용 프로그램에 혁신을 가져오고 있습니다. 프로토콜 최적화 QUIC 프로토콜 Google 이 개발한 QUIC 프로토콜이 HTTP/3 의 기반으로 자리 잡아, 연결 설정 지연시간을 33% 줄이고 멀티플렉싱을 통한 처리량 개선에 기여하고 있습니다. 하드웨어 가속 전용 가속기 AI 추론, 네트워크 패킷 처리 등을 위한 전용 하드웨어 가속기가 지연시간을 줄이고 처리량을 높이는 방향으로 발전하고 있습니다. 서버리스 컴퓨팅 자동 확장 서버리스 아키텍처가 자동 확장을 통해 변동하는 부하에 효율적으로 대응하여 처리량 최적화에 기여하고 있습니다. 분산 데이터베이스 글로벌 분산 CockroachDB, YugabyteDB 등 글로벌 분산 데이터베이스가 지연시간과 처리량의 균형을 목표로 발전하고 있습니다. 메시지 브로커 스트리밍 플랫폼 Kafka, Pulsar 등의 고성능 메시지 브로커가 실시간 데이터 스트리밍과 처리량 최적화를 위한 핵심 인프라로 자리 잡고 있습니다. 앞으로의 전망 주제 항목 설명 양자 컴퓨팅 양자 통신 양자 컴퓨팅과 양자 통신이 특정 영역에서 지연시간과 처리량의 한계를 극복할 잠재력을 가지고 있습니다. 네트워크 혁신 6G 네트워크 개발 중인 6G 네트워크는 초저지연 (sub-millisecond), 초고속 (테라비트급) 통신으로 새로운 응용 프로그램 가능성을 열 것입니다. 분산 시스템 엣지 - 클라우드 통합 엣지 컴퓨팅과 클라우드의 긴밀한 통합이 지연시간과 처리량의 최적화된 조합을 제공할 것입니다. 메모리 기술 비휘발성 메모리 차세대 비휘발성 메모리 기술이 지연시간과 처리량의 새로운 균형점을 제시할 것입니다. AI 인프라 AI 전용 데이터센터 AI 워크로드에 최적화된 데이터센터 아키텍처가 추론과 학습의 지연시간과 처리량을 획기적으로 개선할 것입니다. 지속가능성 에너지 효율 최적화 지연시간과 처리량뿐만 아니라 에너지 효율성까지 고려한 다차원적 최적화가 중요해질 것입니다. 처리량 멀티코어/다중 노드 기반 병렬 처리 CPU, GPU, TPU 의 코어 수 증가와 분산 시스템 확장을 통해 초고처리량 처리 환경 보편화 추가로 학습해야할 내용 주제 카테고리 설명 큐잉 이론 이론 지연시간과 처리량의 수학적 모델링, Little 의 법칙, M/M/1 큐 등 큐잉 이론의 기초와 응용 네트워크 프로토콜 네트워킹 TCP, UDP, QUIC 등 다양한 네트워크 프로토콜의 지연시간과 처리량 특성 이해 분산 시스템 설계 아키텍처 CAP 이론, 데이터 복제, 샤딩 등 분산 시스템에서 지연시간과 처리량 최적화 기법 하드웨어 아키텍처 하드웨어 CPU 캐시, NUMA 아키텍처, DMA 등 하드웨어 수준의 지연시간과 처리량 최적화 성능 측정 방법론 측정/분석 지연시간과 처리량 측정 도구, 통계적 분석 방법, 벤치마킹 기법 캐싱 전략 최적화 다양한 캐싱 전략, 캐시 일관성 프로토콜, 최적의 캐시 사이즈 결정 방법 로드 밸런싱 알고리즘 분산 컴퓨팅 라운드 로빈, 최소 연결, 해시 기반 등 다양한 로드 밸런싱 알고리즘의 장단점 데이터베이스 최적화 데이터 인덱싱, 쿼리 최적화, 트랜잭션 처리 등 데이터베이스 성능 향상 기법 실시간 시스템 특수 도메인 실시간 시스템의 요구사항과 지연시간 보장 메커니즘 클라우드 성능 최적화 클라우드 클라우드 환경에서의 지연시간과 처리량 최적화 전략, 자동 확장 정책 학습 주제 정리 카테고리 주제 설명 System Performance QoS (Quality of Service) 시스템에서 서비스 품질 보장을 위한 다양한 지표와 정책을 학습 Distributed Systems 분산 큐 시스템 (Kafka, RabbitMQ 등) 고처리량 시스템을 위한 메시지 기반 아키텍처 이해 Networking TCP/IP 지연 및 처리량 제어 전송 계층에서 성능을 제한하는 요소와 최적화 기법 학습 Cloud Computing Auto Scaling 및 Load Balancing 클라우드 기반에서 처리량과 응답 속도를 동적으로 조절하는 구조 이해 DevOps Performance Monitoring Tools Prometheus, Grafana, Datadog 등을 통한 실시간 모니터링과 튜닝 실습 용어 정리 용어 설명 지연시간 (Latency) 데이터가 한 지점에서 다른 지점으로 이동하는 데 걸리는 시간. 일반적으로 밀리초 (ms) 나 마이크로초 (μs) 단위로 측정됨 처리량 (Throughput) 단위 시간당 처리할 수 있는 작업량. 초당 비트 수 (bps), 초당 요청 수 (RPS) 등으로 측정됨 대역폭 (Bandwidth) 통신 채널의 최대 이론적 처리 용량. 처리량의 상한선을 결정함 응답 시간 (Response Time) 요청을 보내고 완전한 응답을 받을 때까지의 총 시간. 지연시간 + 처리 시간 + 대기 시간 P95/P99 지연시간 모든 요청 중 95%/99% 의 요청이 이 시간 이내에 처리됨을 나타내는 백분위 지연시간 테일 지연시간 (Tail Latency) 가장 느린 요청들 (일반적으로 상위 5% 또는 1%) 의 응답 시간 캐싱 (Caching) 자주 접근하는 데이터를 빠르게 접근할 수 있는 위치에 저장하여 지연시간을 줄이는 기법 큐잉 지연 (Queuing Delay) 처리를 기다리는 동안 요청이 큐에서 대기하는 시간 로드 밸런싱 (Load Balancing) 여러 서버나 자원에 작업을 분산하여 처리량을 높이는 기법 병목 현상 (Bottleneck) 시스템 성능을 제한하는 구성 요소나 프로세스 CDN(Content Delivery Network) 사용자와 가까운 위치에 콘텐츠를 캐싱하여 지연시간을 줄이는 분산 서버 네트워크 비동기 처리 (Asynchronous Processing) 요청을 즉시 응답하지 않고 백그라운드에서 처리하여 처리량을 높이는 기법 샤딩 (Sharding) 데이터베이스를 여러 파티션으로 분할하여 처리량을 높이는 기법 리틀의 법칙 (Little’s Law) L = λW: 평균 시스템 내 항목 수 (L) 는 평균 도착률 (λ) 과 평균 대기 시간 (W) 의 곱과 같다는 원리 TCP/IP 인터넷의 기본 통신 프로토콜. 신뢰성과 순서 보장에 중점을 두어 지연시간과 처리량에 영향을 미침 QUIC Google 이 개발한 UDP 기반 전송 프로토콜. 연결 설정 시간을 줄이고 멀티플렉싱을 지원하여 지연시간과 처리량 개선 엣지 컴퓨팅 (Edge Computing) 데이터 소스와 가까운 위치에서 처리하여 지연시간을 줄이는 분산 컴퓨팅 패러다임 모노레포 (Monorepo) 여러 프로젝트를 하나의 저장소에서 관리하는 방식. 빌드 최적화와 의존성 관리에 영향을 미침 폴리레포 (Polyrepo) 각 프로젝트를 별도의 저장소에서 관리하는 방식. 독립적인 개발과 배포에 유리함 QKD 양자 키 분배 보안 기술 MEC Mobile Edge Computing QoS (Quality of Service) 시스템이 일정 수준 이상의 서비스 품질을 보장하도록 관리하는 기술 RPC (Remote Procedure Call) 네트워크 상의 다른 서버에 있는 함수나 메서드를 호출하는 통신 기법 SLA (Service Level Agreement) 고객과 서비스 제공자 간의 서비스 품질, 성능 보장 등의 계약 참고 및 출처 Latency \u0026 Throughput 관련 Latency and Throughput in System Design | GeeksforGeeks System Design: Latency vs Throughput - cs.fyi Latency, throughput, and availability: system design interview concepts - IGotAnOffer Latency and Throughput for Systems Design Interview - Java Challengers Throughput vs Latency - AWS 비교 문서 Latency, Bandwidth, Throughput and Response Time | PerfMatrix Optimizing web servers for high throughput and low latency - Dropbox The Latency/Throughput Tradeoff - Dan Slimmon 모놀리포 Vs 폴리레포 (참고 추가) Monorepo vs. Polyrepo - GitHub Monorepo VS Polyrepo - DEV Community 최신 기술 동향 및 성능 최적화 사례 Google Cloud Rapid Storage - InfoQ Meta RTC Optimization - Facebook Engineering Meta ServiceRouter at Scale - CACM 성능 인프라 관련 도구 및 문서 Cloudflare CDN Documentation AWS Auto Scaling Prometheus Official Docs Kubernetes Horizontal Pod Autoscaler 기타 AWS 공식 문서 - Latency/Throughput 개념 Google QUIC 프로토콜 백서 2025 네트워크 트렌드 리포트 - IEEE ","wordCount":"4139","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-18T05:08:00Z","dateModified":"2025-02-18T05:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Latency vs Throughput</h1><div class=post-description>지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다.</div><div class=post-meta><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/System%20and%20Software%20Architecture/Architecture/Quality%20Attributes/latency-vs-throughput.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#latency-vs-throughput>Latency vs. Throughput</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#지연-시간-latency-vs-처리량-throughput-비교>지연 시간 (Latency) vs. 처리량 (Throughput) 비교</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#주요-원리-및-작동-원리>주요 원리 및 작동 원리</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#구성-요소>구성 요소</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#google-meta-사례-기반-구조-선택-전략>Google, Meta 사례 기반 구조 선택 전략</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#추가로-학습해야할-내용>추가로 학습해야할 내용</a></li><li><a href=#학습-주제-정리>학습 주제 정리</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#latency--throughput-관련>Latency & Throughput 관련</a></li><li><a href=#모놀리포-vs-폴리레포-참고-추가>모놀리포 Vs 폴리레포 (참고 추가)</a></li><li><a href=#최신-기술-동향-및-성능-최적화-사례>최신 기술 동향 및 성능 최적화 사례</a></li><li><a href=#성능-인프라-관련-도구-및-문서>성능 인프라 관련 도구 및 문서</a></li><li><a href=#기타>기타</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=latency-vs-throughput>Latency vs. Throughput<a hidden class=anchor aria-hidden=true href=#latency-vs-throughput>#</a></h2><p>Latency 와 Throughput 은 시스템 성능 평가의 양대 축으로 상호 보완적인 지표이다. <strong>Latency</strong>는 데이터 전송 지연 시간 (밀리초 단위) 으로, 실시간 화상 회의나 온라인 게임에서 사용자 경험에 직접적 영향을 미친다. <strong>Throughput</strong>은 초당 처리 가능한 데이터량 (MBps) 으로 대용량 트래픽 처리 능력을 결정한다. 시스템 설계자는 대역폭, 병목 현상, 하드웨어 자원 등 다양한 요소를 고려하여 균형점을 찾아야 한다. 이를 통해 실시간 시스템, 대용량 데이터 처리 등 다양한 응용 분야에서 최적의 성능을 달성할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><p>지연시간 (Latency)<br>지연시간은 데이터가 한 지점에서 다른 지점으로 이동하는 데 걸리는 시간이다. 시스템에서 요청이 시작된 시점부터 응답을 받는 시점까지의 지연을 의미합니다. 주로 밀리초 (ms), 마이크로초 (μs) 또는 나노초 (ns) 단위로 측정됩니다. 낮은 지연시간은 시스템의 응답성이 좋다는 것을 의미하며, 실시간 상호작용이 중요한 애플리케이션에서 특히 중요합니다.</p></li><li><p>처리량 (Throughput)<br>처리량은 시스템이 단위 시간당 처리할 수 있는 작업량을 나타낸다. 네트워크에서는 초당 비트 수 (bps), 초당 요청 수 (RPS), 또는 초당 트랜잭션 수 (TPS) 등으로 측정된다. 높은 처리량은 시스템이 효율적으로 많은 작업을 처리할 수 있음을 의미하며, 대용량 데이터 처리가 필요한 시스템에서 중요한다.</p></li><li><p>대역폭 (Bandwidth)<br>대역폭은 통신 채널의 최대 이론적 처리량을 나타낸다. 네트워크 케이블이나 연결이 처리할 수 있는 최대 데이터 양을 의미하며, 일반적으로 초당 비트 수 (bps) 로 표시된다. 대역폭은 처리량의 상한선을 설정하며, 실제 처리량은 대역폭보다 낮다.</p></li><li><p>상충관계 (Trade-off)<br>지연시간과 처리량 사이에는 상충관계가 존재한다. 처리량을 높이기 위해 배치 처리, 병렬 처리 등의 기법을 사용하면 개별 요청의 지연시간이 증가할 수 있다. 반대로 지연시간을 최소화하기 위해 자원을 최적화하면 전체 처리량이 감소할 수 있다. 시스템 설계자는 애플리케이션의 요구사항에 따라 적절한 균형점을 찾아야 한다.</p></li><li><p>병목 현상 (Bottlenecks)<br>시스템 내에서 전체 성능을 제한하는 요소를 병목 현상이라고 한다. 네트워크 대역폭, CPU 처리 능력, 메모리 접근 속도, 디스크 I/O 등 다양한 요소가 병목 현상을 일으킬 수 있으며, 이는 지연시간 증가와 처리량 감소로 이어진다. 효율적인 시스템 설계를 위해서는 병목 현상을 식별하고 해결하는 것이 중요하다.</p></li><li><p>확장성 (Scalability)<br>시스템이 증가하는 부하를 처리하기 위해 자원을 효율적으로 추가할 수 있는 능력을 의미한다. 수평적 확장 (더 많은 서버 추가) 과 수직적 확장 (더 강력한 서버로 업그레이드) 을 통해 처리량을 증가시킬 수 있다. 그러나 확장 시 지연시간에 미치는 영향도 고려해야 한다.</p></li><li><p>응답 시간 (Response Time)<br>응답 시간은 사용자가 요청을 보내고 완전한 응답을 받는 데 걸리는 총 시간을 의미한다. 지연시간과 관련이 있지만, 응답 시간에는 처리 시간과 대기 시간도 포함된다. 사용자 경험에 직접적인 영향을 미치는 중요한 지표이다.</p></li><li><p>큐잉 이론 (Queueing Theory)<br>큐잉 이론은 대기열 (큐) 의 동작을 수학적으로 연구하는 분야로, 지연시간과 처리량의 관계를 이해하는 데 중요한 이론적 기반을 제공한다. Little 의 법칙 (L = λW) 과 같은 원리를 통해 시스템의 성능을 예측하고 최적화할 수 있다.</p></li></ul><h3 id=지연-시간-latency-vs-처리량-throughput-비교>지연 시간 (Latency) vs. 처리량 (Throughput) 비교<a hidden class=anchor aria-hidden=true href=#지연-시간-latency-vs-처리량-throughput-비교>#</a></h3><p>사용자 경험 향상, 자원 활용 효율성 증대, 성능 병목 현상 파악, 확장성 계획 수립 등 다양한 목적을 위해 이 두 지표의 이해와 관리가 필요하다.</p><table><thead><tr><th>항목</th><th>지연 시간 (Latency)</th><th>처리량 (Throughput)</th></tr></thead><tbody><tr><td>정의</td><td>요청이 시작되어 응답을 받기까지의 시간</td><td>단위 시간당 처리 가능한 작업의 양</td></tr><tr><td>측정 단위</td><td>밀리초 (ms), 마이크로초 (μs) 등</td><td>초당 요청 수 (RPS), Mbps 등</td></tr><tr><td>중요성</td><td>실시간 응답이 필요한 시스템에서 중요</td><td>대량의 데이터 처리 시스템에서 중요</td></tr><tr><td>영향 요소</td><td>네트워크 지연, 처리 시간, 큐 대기 시간 등</td><td>시스템 자원, 네트워크 대역폭 등</td></tr><tr><td>최적화 목표</td><td>최소화 (낮을수록 좋음)</td><td>최대화 (높을수록 좋음)</td></tr><tr><td>최적화 방법</td><td>캐싱, 로드 밸런싱, 경량화 등</td><td>병렬 처리, 리소스 확장 등</td></tr><tr><td>중요 응용 분야</td><td>실시간 시스템, 온라인 게임, 금융 거래 시스템</td><td>대용량 데이터 처리, 백업 시스템, 데이터 마이그레이션</td></tr></tbody></table><h4 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h4><p>지연시간과 처리량은 시스템 성능을 다각도로 평가하고 최적화하는 데 핵심적인 역할을 한다.</p><table><thead><tr><th>항목</th><th>지연시간 (Latency)</th><th>처리량 (Throughput)</th></tr></thead><tbody><tr><td>주요 역할</td><td>시스템 응답성 평가, 실시간성 보장, 사용자 경험 향상</td><td>시스템 효율성 평가, 자원 활용도 측정, 확장성 계획</td></tr><tr><td>성능 지표로서의 활용</td><td>애플리케이션의 응답 시간과 직접 연관, P99 지연시간 등 SLA 정의에 활용</td><td>시스템의 최대 처리 능력 정의, 용량 계획 수립에 활용</td></tr><tr><td>병목 현상 식별</td><td>높은 지연시간은 네트워크, CPU, 메모리 등의 병목 현상 식별에 도움</td><td>예상보다 낮은 처리량은 시스템 내 병목 현상 식별에 도움</td></tr><tr><td>시스템 설계 영향</td><td>낮은 지연시간을 위한 설계는 캐싱, 지역성, 효율적인 알고리즘 등에 초점</td><td>높은 처리량을 위한 설계는 병렬 처리, 배치 처리, 자원 효율성 등에 초점</td></tr></tbody></table><h4 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h4><p>지연시간과 처리량은 다양한 요소에 의해 영향을 받으며, 각기 다른 특성을 가지고 있다.</p><table><thead><tr><th>항목</th><th>지연시간 (Latency)</th><th>처리량 (Throughput)</th></tr></thead><tbody><tr><td>변동성</td><td>네트워크 혼잡, 부하 변동 등에 따라 크게 변할 수 있음</td><td>시스템 자원 한계에 도달하기 전까지는 비교적 안정적</td></tr><tr><td>사용자 경험 영향</td><td>직접적인 영향 (느린 응답 = 나쁜 경험)</td><td>간접적인 영향 (처리량 한계 도달 시 지연시간 증가로 이어짐)</td></tr><tr><td>분포 특성</td><td>꼬리가 긴 (long-tailed) 분포를 보이는 경우가 많음 (P99, P999 지연시간 중요)</td><td>일반적으로 평균값이 의미 있는 정규 분포에 가까움</td></tr><tr><td>최적화 접근법</td><td>병렬 처리보다 직렬 처리가 유리할 수 있음</td><td>병렬 처리, 배치 처리가 유리함</td></tr></tbody></table><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>지연시간과 처리량을 최적화하기 위한 핵심 원칙.</p><table><thead><tr><th>원칙</th><th>설명</th></tr></thead><tbody><tr><td>균형 찾기</td><td>애플리케이션 요구사항에 맞게 지연시간과 처리량 사이의 적절한 균형점 찾기</td></tr><tr><td>병목 현상 제거</td><td>시스템 내 병목 현상을 식별하고 제거하여 전체 성능 향상</td></tr><tr><td>적절한 측정</td><td>정확한 지연시간과 처리량 측정을 통해 성능 문제 식별 및 개선</td></tr><tr><td>확장성 고려</td><td>부하 증가에 따른 지연시간과 처리량의 변화를 고려한 확장 계획 수립</td></tr><tr><td>실제 사용자 경험 우선</td><td>평균값보다 P95, P99 등 실제 사용자가 경험하는 성능 지표에 초점</td></tr></tbody></table><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><p>지연시간과 처리량의 관계는 다양한 이론과 원리로 설명될 수 있다.</p><h4 id=큐잉-이론과-little-의-법칙>큐잉 이론과 Little 의 법칙<a hidden class=anchor aria-hidden=true href=#큐잉-이론과-little-의-법칙>#</a></h4><p>큐잉 이론은 지연시간과 처리량 사이의 관계를 수학적으로 설명한다. Little 의 법칙 (L = λW) 은 시스템 내 평균 요청 수 (L) 가 도착률 (λ) 과 평균 대기 시간 (W) 의 곱과 같다는 원리를 설명한다. 이는 처리량 (λ) 과 지연시간 (W) 사이의 근본적인 관계를 보여준다.</p><h4 id=지연시간---처리량-곡선>지연시간 - 처리량 곡선<a hidden class=anchor aria-hidden=true href=#지연시간---처리량-곡선>#</a></h4><p>아래의 이미지는 <strong>분산 네트워크 성능 분석</strong>을 위한 **지연시간 - 처리량 곡선 (Latency-Throughput Curve)**을 보여주며, 다음과 같은 핵심 요소를 포함한다.</p><ol><li><p><strong>X 축 (Injection Rate)</strong></p><ul><li><strong>트래픽 주입률</strong>: 네트워크에 초당 주입되는 데이터 양 (단위: flits/cycle).</li><li>**0 부터 포화점 (Saturation Point)**까지 증가하며, 네트워크 부하를 점진적으로 높임.</li></ul></li><li><p><strong>Y 축 (Latency)</strong></p><ul><li><strong>패킷 지연시간</strong>: 데이터가 네트워크를 통과하는 데 걸리는 시간 (단위: cycles).</li><li>초기에는 낮은 값 유지 → 트래픽 증가 시 급격히 상승.</li></ul></li><li><p><strong>곡선 형태</strong></p><ul><li><strong>선형 구간 (Linear Region)</strong>: 낮은 주입률에서 처리량 증가 ↔ 지연시간 완만 상승.</li><li><strong>포화 구간 (Saturation Region)</strong>: 주입률 증가해도 처리량 정체 ↔ 지연시간 급증.</li></ul></li></ol><p><figure><img alt="지연시간-처리량 곡선" loading=lazy src=/img/Latency-throughput-curve-used-to-measure-performance-of-interconnection-networks.png></figure></p><p><strong>곡선 해석 및 성능 지표</strong></p><table><thead><tr><th>구분</th><th>설명</th><th>기술적 의미</th></tr></thead><tbody><tr><td><strong>Zero-Load Latency</strong></td><td>트래픽이 0 일 때의 지연시간</td><td>네트워크 기본 성능 (토폴로지, 라우팅 알고리즘 영향)</td></tr><tr><td><strong>Saturation Throughput</strong></td><td>네트워크가 처리할 수 있는 최대 처리량</td><td>플로우 컨트롤 및 버퍼 관리 효율성 결정</td></tr><tr><td><strong>Latency Slope</strong></td><td>지연시간 증가 기울기</td><td>네트워크 혼잡도 및 리소스 경쟁 정도 반영</td></tr></tbody></table><p><strong>성능 영향 요소</strong></p><ol><li><p><strong>토폴로지 (Topology)</strong></p><ul><li><strong>예시</strong>: 메시 (Mesh), 토러스 (Torus) → <strong>Bisection Bandwidth</strong>가 처리량 상한 결정.</li><li><strong>영향</strong>: 높은 대역폭 → 포화점 지연.</li></ul></li><li><p><strong>라우팅 알고리즘 (Routing)</strong></p><ul><li><strong>Minimal vs. Non-Minimal</strong>: 비최소 라우팅은 지연시간 증가 대신 포화 처리량 향상.</li><li><strong>Adaptive Routing</strong>: 트래픽 부하에 따라 경로 동적 조정 → 곡선 형태 최적화.</li></ul></li><li><p><strong>플로우 컨트롤 (Flow Control)</strong></p><ul><li><strong>Virtual Channel 사용</strong>: 버퍼 경쟁 감소 → 포화 처리량 40% 향상 가능.</li><li><strong>Credit-Based vs. On/Off</strong>: 신호 오버헤드 차이로 지연시간 변동.</li></ul></li></ol><h4 id=처리량-제한-요소>처리량 제한 요소<a hidden class=anchor aria-hidden=true href=#처리량-제한-요소>#</a></h4><p>처리량은 다양한 요소에 의해 제한될 수 있다:</p><ol><li><strong>하드웨어 제한</strong>: CPU, 메모리, 디스크 I/O 등</li><li><strong>네트워크 제한</strong>: 대역폭, 패킷 손실, 혼잡 제어</li><li><strong>소프트웨어 제한</strong>: 비효율적인 알고리즘, 동기화 오버헤드</li></ol><h4 id=지연시간-구성-요소>지연시간 구성 요소<a hidden class=anchor aria-hidden=true href=#지연시간-구성-요소>#</a></h4><p>지연시간은 여러 구성 요소로 이루어져 있다:</p><ol><li><strong>전파 지연 (Propagation Delay)</strong>: 데이터가 물리적 거리를 이동하는 데 걸리는 시간</li><li><strong>전송 지연 (Transmission Delay)</strong>: 데이터를 매체에 전송하는 데 걸리는 시간</li><li><strong>처리 지연 (Processing Delay)</strong>: 데이터를 처리하는 데 걸리는 시간</li><li><strong>대기열 지연 (Queuing Delay)</strong>: 처리를 기다리는 동안 발생하는 지연</li></ol><h4 id=지연시간과-처리량의-관계>지연시간과 처리량의 관계<a hidden class=anchor aria-hidden=true href=#지연시간과-처리량의-관계>#</a></h4><p><figure><img alt=Latency-throughput-relationship loading=lazy src=/img/Latency-throughput-relationship.png></figure></p><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=지연-시간-최적화-아키텍처>지연 시간 최적화 아키텍처<a hidden class=anchor aria-hidden=true href=#지연-시간-최적화-아키텍처>#</a></h4><p>지연 시간을 최소화하기 위해, 클라이언트와 서버 간의 거리를 줄이고, 데이터 처리 경로를 최적화하는 구조를 채택한다.<br>요청 처리 경로를 최소화하고, 캐싱과 지역성을 활용하여 빠른 응답 시간을 제공한다. 예를 들어, CDN(Content Delivery Network) 을 활용하여 사용자와 가까운 위치에서 콘텐츠를 제공함으로써 지연 시간을 줄일 수 있다. 실시간 시스템, 온라인 게임, 고주파 거래 시스템 등에 적합하다.</p><p><strong>주요 특징</strong>:</p><ul><li>요청 경로 최소화 (홉 수 줄이기)</li><li>엣지 컴퓨팅 활용</li><li>캐싱 최적화</li><li>비동기 처리 대신 동기 처리 활용</li><li>지역성 (Locality) 최적화</li></ul><h4 id=처리량-최적화-아키텍처>처리량 최적화 아키텍처<a hidden class=anchor aria-hidden=true href=#처리량-최적화-아키텍처>#</a></h4><p>처리량을 극대화하기 위해, 시스템은 병렬 처리, 배치 처리, 큐 시스템와 리소스 확장을 활용하여 높은 처리량을 제공한다. 예를 들어, 마이크로서비스 아키텍처를 도입하여 각 서비스가 독립적으로 확장 가능하게 설계함으로써 전체 시스템의 처리량을 향상시킬 수 있다. 이는 대용량 데이터 처리, 분석 시스템, 백업 시스템 등에 적합하다.</p><p><strong>주요 특징</strong>:</p><ul><li>병렬 처리 극대화</li><li>배치 처리 활용</li><li>큐 시스템 구현</li><li>비동기 처리 활용</li><li>수평적 확장성 설계</li></ul><h4 id=균형-잡힌-아키텍처>균형 잡힌 아키텍처<a hidden class=anchor aria-hidden=true href=#균형-잡힌-아키텍처>#</a></h4><p>대부분의 실제 시스템은 지연시간과 처리량 사이의 균형을 맞추어야 한다. 이를 위해 다양한 기법을 조합하여 사용한다.</p><p><strong>주요 특징</strong>:</p><ul><li>마이크로서비스 아키텍처</li><li>캐싱과 큐 시스템의 조합</li><li>적응형 배치 처리</li><li>우선순위 기반 스케줄링</li><li>지능형 부하 분산</li></ul><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><table><thead><tr><th>구성 요소</th><th>기능 및 역할</th><th>종류</th><th>작동 방식</th><th>지연시간 최적화 기여</th><th>처리량 최적화 기여</th></tr></thead><tbody><tr><td><strong>캐싱 시스템</strong></td><td>자주 접근하는 데이터를 메모리에 저장하여 빠른 응답 제공</td><td>메모리 내 캐시, 분산 캐시 (Redis, Memcached), CDN, 브라우저 캐시</td><td>캐시 적중 시 원본 접근 없이 빠르게 데이터 제공</td><td>데이터 접근 속도를 메모리 수준으로 줄여 응답 시간 단축</td><td>원본 시스템의 부하 감소로 더 많은 요청을 처리 가능</td></tr><tr><td><strong>로드 밸런서</strong></td><td>요청을 여러 서버에 분산시켜 부하를 균등하게 처리</td><td>L4, L7, 글로벌 로드 밸런서</td><td>라운드 로빈, 최소 연결, 최소 지연시간 등 알고리즘으로 분산</td><td>가장 응답 속도가 빠른 서버로 분산하여 응답 지연 최소화</td><td>서버 간 부하 분산으로 동시 요청 처리량 증가</td></tr><tr><td><strong>메시지 큐</strong></td><td>비동기 처리로 병렬 처리 및 시스템 독립성 확보</td><td>Kafka, RabbitMQ, SQS, Pub/Sub</td><td>생산자가 메시지를 큐에 넣고 소비자가 비동기적으로 처리</td><td>요청 즉시 처리하지 않고 큐에 저장하여 시스템 병목 완화</td><td>소비자가 독립적으로 처리하므로 고속의 비동기 처리 가능</td></tr><tr><td><strong>데이터베이스</strong></td><td>데이터 저장, 쿼리 처리 및 트랜잭션 관리</td><td>RDBMS, NoSQL, 시계열 DB, 그래프 DB</td><td>인덱싱, 샤딩, 복제 등으로 성능 향상</td><td>인덱싱으로 검색 속도 향상, 캐싱으로 반복 조회 시간 절감</td><td>샤딩/복제로 수평 확장하여 높은 처리량 확보</td></tr><tr><td><strong>네트워크 구성 요소</strong></td><td>패킷 전송, 라우팅, 트래픽 제어 및 보안</td><td>라우터, 스위치, 프록시, 방화벽, CDN</td><td>패킷 포워딩, 큐잉, 우선순위 지정 등 네트워크 최적화</td><td>CDN, QoS 로 요청을 사용자 가까운 위치에서 처리해 지연 최소화</td><td>대역폭 제어, 트래픽 분산으로 동시 요청 수용 능력 증가</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>접근 방식</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>지연시간 우선 최적화</td><td>- 사용자 경험 향상<br>- 실시간 상호작용 개선<br>- 빠른 응답성으로 사용자 만족도 증가</td><td>- 자원 활용도 감소 가능<br>- 처리량 제한 가능<br>- 구현 및 유지보수 비용 증가</td></tr><tr><td>처리량 우선 최적화</td><td>- 효율적인 자원 활용<br>- 높은 데이터 처리 용량<br>- 비용 효율적인 처리</td><td>- 개별 요청의 지연시간 증가<br>- 실시간성 저하<br>- 복잡한 비동기 처리 로직 필요</td></tr><tr><td>균형 잡힌 접근법</td><td>- 다양한 워크로드 지원<br>- 확장성 향상<br>- 사용자 경험과 효율성 모두 고려</td><td>- 구현 복잡도 증가<br>- 더 많은 설계 노력 필요<br>- 다양한 기술 스택 필요</td></tr></tbody></table><p>지연시간과 처리량 최적화의 장단점과 운영 기준.</p><table><thead><tr><th>측면</th><th>지연시간 최적화 장단점</th><th>처리량 최적화 장단점</th><th>운영 기준</th></tr></thead><tbody><tr><td>인프라 비용</td><td>- 장점: 일부 영역만 고사양 장비 필요<br>- 단점: 지리적 분산으로 인한 추가 비용</td><td>- 장점: 규모의 경제로 비용 효율성<br>- 단점: 대규모 처리 인프라 필요</td><td>- 트래픽 패턴 분석<br>ROI 기반 인프라 투자<br>- 클라우드 vs 온프레미스 결정</td></tr><tr><td>개발 복잡성</td><td>- 장점: 동기식 처리로 간단한 디버깅<br>- 단점: 캐싱, 무효화 등 복잡한 로직 필요</td><td>- 장점: 표준화된 배치 처리 패턴<br>- 단점: 비동기 처리의 복잡성, 재시도 로직</td><td>- 개발자 경험 고려<br>- 적절한 추상화 레벨 설정<br>- 자동화된 테스트 중요</td></tr><tr><td>확장성</td><td>- 장점: 수직적 확장으로 단순함<br>- 단점: 물리적 한계 존재</td><td>- 장점: 수평적 확장으로 거의 무제한<br>- 단점: 분산 시스템 복잡성</td><td>- 미래 성장 예측<br>- 점진적 확장 계획<br>- 확장성 병목 지속 모니터링</td></tr><tr><td>사용자 경험</td><td>- 장점: 즉각적 반응으로 좋은 UX<br>- 단점: 부하 증가 시 성능 저하 가능성</td><td>- 장점: 안정적인 대량 데이터 처리<br>- 단점: 개별 요청 지연 가능성</td><td>- 사용자 만족도 측정<br>- 업계 벤치마크 대비 성능<br>A/B 테스트를 통한 개선</td></tr><tr><td>유지보수</td><td>- 장점: 간단한 아키텍처 가능<br>- 단점: 성능 튜닝의 지속적 필요성</td><td>- 장점: 모듈화된 컴포넌트<br>- 단점: 분산 시스템 디버깅 어려움</td><td>- 모니터링 및 알림 체계<br>- 성능 회귀 테스트<br>- 정기적인 성능 검토</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>사례</th><th>적용 방식</th><th>설명</th></tr></thead><tbody><tr><td>온라인 게임</td><td>지연 시간 최적화</td><td>실시간 반응이 중요하므로 지연 시간을 최소화하여 사용자 경험 향상</td></tr><tr><td>데이터 분석 시스템</td><td>처리량 최적화</td><td>대량의 데이터를 효율적으로 처리하기 위해 시스템의 처리량을 극대화</td></tr><tr><td>스트리밍 서비스</td><td>지연 시간 및 처리량 최적화</td><td>빠른 응답과 안정적인 데이터 전송을 위해 지연 시간과 처리량을 동시에 최적화</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><p><strong>시나리오</strong>: 대규모 E- 커머스 플랫폼의 성능 최적화</p><p><strong>상황</strong>: 대규모 온라인 쇼핑몰이 블랙프라이데이와 같은 특별 할인 기간 동안 트래픽이 평소의 10 배 이상 증가하는 문제에 직면했습니다. 사이트 로딩 시간이 길어지고, 결제 프로세스가 지연되며, 일부 사용자는 서비스를 이용할 수 없는 상황이 발생했습니다.</p><p><strong>목표</strong>:</p><ul><li>사이트 로딩 시간을 2 초 이내로 유지</li><li>장바구니 추가 및 결제 프로세스 응답 시간을 500ms 이내로 유지</li><li>초당 최소 5,000 건의 트랜잭션 처리 가능</li><li>99.99% 서비스 가용성 확보</li></ul><p><strong>E- 커머스 플랫폼 지연시간/처리량 최적화 다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span><span class=lnt id=hl-0-52><a class=lnlinks href=#hl-0-52>52</a>
</span><span class=lnt id=hl-0-53><a class=lnlinks href=#hl-0-53>53</a>
</span><span class=lnt id=hl-0-54><a class=lnlinks href=#hl-0-54>54</a>
</span><span class=lnt id=hl-0-55><a class=lnlinks href=#hl-0-55>55</a>
</span><span class=lnt id=hl-0-56><a class=lnlinks href=#hl-0-56>56</a>
</span><span class=lnt id=hl-0-57><a class=lnlinks href=#hl-0-57>57</a>
</span><span class=lnt id=hl-0-58><a class=lnlinks href=#hl-0-58>58</a>
</span><span class=lnt id=hl-0-59><a class=lnlinks href=#hl-0-59>59</a>
</span><span class=lnt id=hl-0-60><a class=lnlinks href=#hl-0-60>60</a>
</span><span class=lnt id=hl-0-61><a class=lnlinks href=#hl-0-61>61</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>                              [글로벌 사용자]
</span></span><span class=line><span class=cl>                                     │
</span></span><span class=line><span class=cl>                                     ▼
</span></span><span class=line><span class=cl>                          +----------------------+
</span></span><span class=line><span class=cl>                          │   CloudFront CDN      │◄─정적 자원(이미지,JS,CSS)
</span></span><span class=line><span class=cl>                          │  (Edge Lambda@Edge)   │─┐
</span></span><span class=line><span class=cl>                          +-----------+-----------+ │
</span></span><span class=line><span class=cl>                                      │             │
</span></span><span class=line><span class=cl>                                      │API 요청      │동적 콘텐츠 처리
</span></span><span class=line><span class=cl>                                      ▼             │
</span></span><span class=line><span class=cl>                          +----------------------+  │
</span></span><span class=line><span class=cl>                          │  AWS Global Accelerator │
</span></span><span class=line><span class=cl>                          +-----------+-----------+  │
</span></span><span class=line><span class=cl>                                      │              │
</span></span><span class=line><span class=cl>                           +----------+-----------+  │
</span></span><span class=line><span class=cl>                           ▼                       ▼  │
</span></span><span class=line><span class=cl>               +-----------------------+   +-----------------------+ 
</span></span><span class=line><span class=cl>               │  API Gateway (REST)   │   │  WebSocket Gateway    │
</span></span><span class=line><span class=cl>               │  - Rate Limiting      │   │  - 실시간 재고 업데이트 │
</span></span><span class=line><span class=cl>               │  - JWT 인증           │   +-----------+-----------+
</span></span><span class=line><span class=cl>               +-----------+-----------+               │
</span></span><span class=line><span class=cl>                           │                           │
</span></span><span class=line><span class=cl>         ┌─────────────────┴─────────────────┐         │
</span></span><span class=line><span class=cl>         ▼                                   ▼         ▼
</span></span><span class=line><span class=cl>+------------------+               +------------------+       +------------------+
</span></span><span class=line><span class=cl>│ Auto-Scaling Group             │  Elastic Container    │       │   Serverless     │
</span></span><span class=line><span class=cl>│  - Web Server Cluster          │  Service (ECS)        │       │   (Lambda)       │
</span></span><span class=line><span class=cl>│  - CPU 80% 기준 확장            │  - 결제/주문 마이크로서비스   │       │  - 추천 엔진     │
</span></span><span class=line><span class=cl>+------------------+               +------------------+       +------------------+
</span></span><span class=line><span class=cl>         │                                   │                           │
</span></span><span class=line><span class=cl>         │                                   │                           │
</span></span><span class=line><span class=cl>         ▼                                   ▼                           ▼
</span></span><span class=line><span class=cl>+------------------+               +------------------+       +------------------+
</span></span><span class=line><span class=cl>│   Redis Cluster  │◄─세션/캐시────│   API Cache Layer │       │  Event Bridge    │
</span></span><span class=line><span class=cl>│  (Multi-AZ)      │─┐            │  (DynamoDB DAX)  │       │  - 이벤트 오케스트레이션│
</span></span><span class=line><span class=cl>+------------------+ │            +------------------+       +------------------+
</span></span><span class=line><span class=cl>                     │                     │                           │
</span></span><span class=line><span class=cl>                     │                     ▼                           ▼
</span></span><span class=line><span class=cl>                     │            +------------------+       +------------------+
</span></span><span class=line><span class=cl>                     │            │   Read Replicas   │       │  SQS/SNS/Kafka   │
</span></span><span class=line><span class=cl>                     │            │  (Aurora Global DB)│       │  - 비동기 작업 큐   │
</span></span><span class=line><span class=cl>                     │            +------------------+       +------------------+
</span></span><span class=line><span class=cl>                     │                     ▲                           │
</span></span><span class=line><span class=cl>                     │                     │                           │
</span></span><span class=line><span class=cl>                     └───────┐     +------------------+       +------------------+
</span></span><span class=line><span class=cl>                             │     │  Primary Database │◄─────│  Batch Workers    │
</span></span><span class=line><span class=cl>                             │     │  (Sharded RDS)    │       │  (EC2 Spot)       │
</span></span><span class=line><span class=cl>                             │     +------------------+       +------------------+
</span></span><span class=line><span class=cl>                             │                                           │
</span></span><span class=line><span class=cl>                             │                                           ▼
</span></span><span class=line><span class=cl>                             │                                 +------------------+
</span></span><span class=line><span class=cl>                             │                                 │  Data Lake       │
</span></span><span class=line><span class=cl>                             │                                 │  (S3 + Athena)   │
</span></span><span class=line><span class=cl>                             │                                 +------------------+
</span></span><span class=line><span class=cl>                             │
</span></span><span class=line><span class=cl>                   +------------------+
</span></span><span class=line><span class=cl>                   │  모니터링 시스템    │
</span></span><span class=line><span class=cl>                   │  - CloudWatch    │
</span></span><span class=line><span class=cl>                   │  - X-Ray         │
</span></span><span class=line><span class=cl>                   │  - Prometheus    │
</span></span><span class=line><span class=cl>                   +------------------+
</span></span></code></pre></td></tr></table></div></div><p><strong>최적화 전략 (지연시간 vs. 처리량)</strong></p><table><thead><tr><th>구분</th><th>지연시간 최적화 전략</th><th>처리량 최적화 전략</th></tr></thead><tbody><tr><td><strong>핵심 기술</strong></td><td>- CDN 엣지 캐싱<br>- 인메모리 데이터베이스<br>- Lazy Loading</td><td>- Auto Scaling<br>- DB 샤딩<br>- 비동기 큐</td></tr><tr><td><strong>주요 서비스</strong></td><td>CloudFront, Redis, DAX</td><td>ECS Fargate, Aurora Global, SQS</td></tr><tr><td><strong>최적화 대상</strong></td><td>사용자 체감 성능 (FCP, TTI)</td><td>시스템 처리 용량 (RPS, TPS)</td></tr><tr><td><strong>모니터링 지표</strong></td><td>- Time to First Byte (TTFB)<br>- DOM Load</td><td>- CPU/Memory Utilization<br>- Queue Depth</td></tr><tr><td><strong>트레이드오프</strong></td><td>높은 인프라 비용</td><td>데이터 일관성 지연 가능성</td></tr><tr><td><strong>적용 사례</strong></td><td>제품 페이지 로딩, 검색 결과</td><td>주문 처리, 재고 관리, 배치 작업</td></tr></tbody></table><p><strong>계층별 최적화</strong></p><ol><li><p>프론트엔드 계층 (지연시간 &lt;1s)</p><ul><li><strong>점진적 정적 재생성 (ISR)</strong>: Next.js 15+ 의 On-demand ISR 로 실시간 콘텐츠 갱신</li><li><strong>WebAssembly 최적화</strong>: 이미지 리사이징을 WASM 으로 엣지 처리</li><li><strong>HTTP/3 + QUIC</strong>: 멀티플렉싱으로 연결 지연시간 40% 감소</li></ul></li><li><p>API 계층 (지연시간 &lt;300ms)</p><ul><li><p><strong>계층적 캐싱 전략</strong>:</p><pre class=mermaid>graph LR  
  A[User] --&gt; B[Edge API Cache - 50ms]  
  B --&gt; C{Cache Hit?}  
  C --&gt;|Yes| D[Return Response]  
  C --&gt;|No| E[Region API Cache - 100ms]  
  E --&gt; F{Cache Hit?}  
  F --&gt;|Yes| G[Return Response]  
  F --&gt;|No| H[Origin Server - 300ms]  
</pre></li><li><p><strong>GraphQL 지연 로딩</strong>: <code>@defer</code> 지시어 활용해 부분 응답 스트리밍</p></li></ul></li><li><p>데이터 계층 (처리량 >10k TPS)</p><ul><li><p><strong>AI 기반 샤딩</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 머신러닝 기반 샤드 키 생성</span>
</span></span><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=n>CatBoostClassifier</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>model</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>user_behavior_data</span><span class=p>,</span> <span class=n>shard_hotspots</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>shard_key</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>predict</span><span class=p>(</span><span class=n>new_data</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>벡터화 쿼리 처리</strong>: PostgreSQL pgvector 확장으로 유사도 검색 가속화</p></li></ul></li><li><p>배치 처리 계층</p><ul><li><strong>서버리스 스팟 인스턴스</strong>: AWS Lambda + EC2 Spot 혼합 배치로 비용 70% 절감</li><li><strong>예측 확장</strong>: Prophet 모델 기반 트래픽 예측 → 리소스 사전 할당</li></ul></li></ol><p><strong>핵심 설계 원칙</strong></p><ol><li><p><strong>지연시간 민감도 계층화</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>사용자 체감 영역 (Tier 0) → 마이크로초 단위 최적화  
</span></span><span class=line><span class=cl>백오피스 영역 (Tier 2) → 처리량 중심 설계
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>비용 - 성능 최적화 곡선</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>$1/ms 감소 당 월 $2,400 절감 (10M MAU 기준)  
</span></span><span class=line><span class=cl>→ CloudFront Intelligent Tiering + Lambda@Edge 조합으로 달성
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>장애 전파 차단</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>회로 차단기(Circuit Breaker) 패턴 구현  
</span></span><span class=line><span class=cl>→ Istio 서비스 메시에서 500ms 타임아웃 기준 자동 차단
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=google-meta-사례-기반-구조-선택-전략>Google, Meta 사례 기반 구조 선택 전략<a hidden class=anchor aria-hidden=true href=#google-meta-사례-기반-구조-선택-전략>#</a></h3><p>Google 과 Meta(Facebook) 는 각자의 서비스 특성에 맞는 지연시간과 처리량 최적화 전략을 구현했다.</p><h4 id=google-의-접근법>Google 의 접근법<a hidden class=anchor aria-hidden=true href=#google-의-접근법>#</a></h4><p>Google 은 다양한 서비스에 따라 다른 최적화 전략을 적용한다:</p><ul><li><strong>검색 엔진</strong>: 낮은 지연시간을 위해 글로벌 분산 아키텍처와 인메모리 캐싱을 활용한다. Google 의 검색은 사용자 쿼리를 즉각 처리하기 위해 처리량보다 지연시간을 우선시한다.</li><li><strong>BigTable/Spanner</strong>: 분산 데이터베이스 시스템으로, 지연시간과 처리량의 균형을 맞추기 위해 설계되었다. Google 의 SRE(Site Reliability Engineering) 책에서는 BigTable 에 대해 " 지연 시간이 낮은 사용자는 시스템이 도착하는 각 요청을 즉시 처리할 수 있도록 큐가 (거의 항상) 비어 있기를 원하지만, 오프라인 분석에 관심이 있는 사용자는 처리량에 더 관심이 있습니다 " 라고 설명한다.</li><li><strong>Google 클라우드 네트워크</strong>: 프리미엄 티어에서는 자체 글로벌 백본 네트워크를 활용하여 지연시간을 최소화하고, 표준 티어에서는 인터넷을 통한 라우팅으로 비용 대비 처리량을 최적화한다.</li></ul><h4 id=metafacebook-의-접근법>Meta(Facebook) 의 접근법<a hidden class=anchor aria-hidden=true href=#metafacebook-의-접근법>#</a></h4><p>Meta 는 소셜 네트워크 특성에 맞게 다음과 같은 최적화 전략을 사용한다:</p><ul><li><strong>TAO(The Associations and Objects)</strong>: Facebook&rsquo;s 소셜 그래프를 저장하는 분산 데이터 저장소로, 읽기 중심 워크로드에 최적화되어 있다. 다중 레이어 캐싱으로 지연시간을 최소화한다.</li><li><strong>Proxygen</strong>: Facebook 의 HTTP 서버 프레임워크로, 처리량 최적화를 위한 멀티스레딩과 지연시간 최적화를 위한 비동기 I/O 를 모두 활용한다.</li><li><strong>TCP BBR(Bottleneck Bandwidth and Round-trip propagation time)</strong>: Google 이 개발하고 Meta 도 채택한 TCP 혼잡 제어 알고리즘으로, 네트워크 지연시간과 처리량을 모두 개선한다.</li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th></tr></thead><tbody><tr><td>사용자 경험 우선</td><td>사용자와 직접 상호작용하는 기능은 지연시간 최적화에, 백그라운드 처리는 처리량 최적화에 중점을 둡니다.</td></tr><tr><td>측정 기반 접근</td><td>실제 측정을 통해 병목 현상을 식별하고, 최적화 전략을 수립합니다. 가정이 아닌 데이터에 기반한 의사결정이 중요합니다.</td></tr><tr><td>점진적 개선</td><td>한 번에 모든 것을 최적화하려 하지 말고, 가장 큰 영향을 미치는 부분부터 점진적으로 개선합니다.</td></tr><tr><td>캐싱 전략</td><td>캐싱은 지연시간을 크게 줄일 수 있지만, 캐시 무효화와 일관성 문제에 주의해야 합니다.</td></tr><tr><td>비동기 처리</td><td>비동기 처리로 처리량을 높일 수 있지만, 복잡성이 증가하고 디버깅이 어려워질 수 있습니다.</td></tr><tr><td>확장성 설계</td><td>초기부터 확장성을 고려한 설계로 나중에 대규모 재작업을 방지합니다.</td></tr><tr><td>모니터링과 알림</td><td>지연시간과 처리량을 지속적으로 모니터링하고, 이상 징후 발생 시 즉시 알림을 받을 수 있는 시스템을 구축합니다.</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>지연시간 최적화</th><th>처리량 최적화</th></tr></thead><tbody><tr><td>하드웨어 최적화</td><td>- 더 빠른 CPU 와 메모리<br>SSD 스토리지<br>- 네트워크 하드웨어 업그레이드</td><td>- 더 많은 코어와 스레드<br>- 대용량 메모리<br>- 빠른 대용량 스토리지</td></tr><tr><td>소프트웨어 최적화</td><td>- 알고리즘 효율성 개선<br>I/O 최소화<br>- 동기화 병목 제거</td><td>- 병렬 처리 최적화<br>- 배치 처리 효율화<br>- 리소스 활용 극대화</td></tr><tr><td>네트워크 최적화</td><td>TCP 최적화 (BBR 같은 혼잡 제어)<br>- 연결 재사용<br>- 지역성 최적화</td><td>- 대역폭 확장<br>- 프로토콜 최적화<br>- 로드 밸런싱</td></tr><tr><td>데이터베이스 최적화</td><td>- 인덱싱 최적화<br>- 쿼리 최적화<br>- 캐싱 적용</td><td>- 파티셔닝/샤딩<br>- 벌크 작업 최적화<br>- 읽기/쓰기 분리</td></tr><tr><td>애플리케이션 설계</td><td>- 비동기 I/O<br>- 마이크로서비스 아키텍처<br>- 이벤트 기반 아키텍처</td><td>- 워커 풀 최적화<br>- 작업 스케줄링<br>- 큐 기반 처리</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>네트워킹</td><td>TCP BBR</td><td>Google 의 TCP BBR(Bottleneck Bandwidth and RTT) 혼잡 제어 알고리즘이 지연시간과 처리량을 동시에 최적화하는 접근법으로 주목받고 있습니다.</td></tr><tr><td>분산 시스템</td><td>서킷 브레이커</td><td>서킷 브레이커 패턴이 분산 시스템에서 장애 전파를 방지하고 지연시간 최소화와 처리량 유지에 기여하고 있습니다.</td></tr><tr><td>컨테이너 기술</td><td>Service Mesh</td><td>Istio, Linkerd 등의 서비스 메시가 마이크로서비스 간 통신 최적화와 지연시간 모니터링을 제공합니다.</td></tr><tr><td>측정 방법론</td><td>테일 지연시간</td><td>평균 지연시간보다 P95, P99 등 테일 지연시간 (극단값) 에 초점을 맞춘 측정과 최적화가 중요해지고 있습니다.</td></tr><tr><td>AI/ML</td><td>자율 최적화</td><td>AI/ML 을 활용한 자율적 성능 최적화 시스템이 지연시간과 처리량의 동적 균형을 찾는 방향으로 발전하고 있습니다.</td></tr><tr><td>모니터링</td><td>분산 추적</td><td>OpenTelemetry 와 같은 분산 추적 시스템이 복잡한 시스템에서 지연시간 문제 원인 파악에 필수적인 도구로 자리 잡고 있습니다.</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>엣지 컴퓨팅</td><td>로컬 처리</td><td>사용자와 가까운 위치에서 데이터를 처리하여 지연시간을 크게 줄이는 엣지 컴퓨팅 기술이 확산되고 있습니다. 5G 와 결합하여 실시간 응용 프로그램에 혁신을 가져오고 있습니다.</td></tr><tr><td>프로토콜 최적화</td><td>QUIC 프로토콜</td><td>Google 이 개발한 QUIC 프로토콜이 HTTP/3 의 기반으로 자리 잡아, 연결 설정 지연시간을 33% 줄이고 멀티플렉싱을 통한 처리량 개선에 기여하고 있습니다.</td></tr><tr><td>하드웨어 가속</td><td>전용 가속기</td><td>AI 추론, 네트워크 패킷 처리 등을 위한 전용 하드웨어 가속기가 지연시간을 줄이고 처리량을 높이는 방향으로 발전하고 있습니다.</td></tr><tr><td>서버리스 컴퓨팅</td><td>자동 확장</td><td>서버리스 아키텍처가 자동 확장을 통해 변동하는 부하에 효율적으로 대응하여 처리량 최적화에 기여하고 있습니다.</td></tr><tr><td>분산 데이터베이스</td><td>글로벌 분산</td><td>CockroachDB, YugabyteDB 등 글로벌 분산 데이터베이스가 지연시간과 처리량의 균형을 목표로 발전하고 있습니다.</td></tr><tr><td>메시지 브로커</td><td>스트리밍 플랫폼</td><td>Kafka, Pulsar 등의 고성능 메시지 브로커가 실시간 데이터 스트리밍과 처리량 최적화를 위한 핵심 인프라로 자리 잡고 있습니다.</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>양자 컴퓨팅</td><td>양자 통신</td><td>양자 컴퓨팅과 양자 통신이 특정 영역에서 지연시간과 처리량의 한계를 극복할 잠재력을 가지고 있습니다.</td></tr><tr><td>네트워크 혁신</td><td>6G 네트워크</td><td>개발 중인 6G 네트워크는 초저지연 (sub-millisecond), 초고속 (테라비트급) 통신으로 새로운 응용 프로그램 가능성을 열 것입니다.</td></tr><tr><td>분산 시스템</td><td>엣지 - 클라우드 통합</td><td>엣지 컴퓨팅과 클라우드의 긴밀한 통합이 지연시간과 처리량의 최적화된 조합을 제공할 것입니다.</td></tr><tr><td>메모리 기술</td><td>비휘발성 메모리</td><td>차세대 비휘발성 메모리 기술이 지연시간과 처리량의 새로운 균형점을 제시할 것입니다.</td></tr><tr><td>AI 인프라</td><td>AI 전용 데이터센터</td><td>AI 워크로드에 최적화된 데이터센터 아키텍처가 추론과 학습의 지연시간과 처리량을 획기적으로 개선할 것입니다.</td></tr><tr><td>지속가능성</td><td>에너지 효율 최적화</td><td>지연시간과 처리량뿐만 아니라 에너지 효율성까지 고려한 다차원적 최적화가 중요해질 것입니다.</td></tr><tr><td>처리량</td><td>멀티코어/다중 노드 기반 병렬 처리</td><td>CPU, GPU, TPU 의 코어 수 증가와 분산 시스템 확장을 통해 초고처리량 처리 환경 보편화</td></tr></tbody></table><h3 id=추가로-학습해야할-내용>추가로 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#추가로-학습해야할-내용>#</a></h3><table><thead><tr><th>주제</th><th>카테고리</th><th>설명</th></tr></thead><tbody><tr><td>큐잉 이론</td><td>이론</td><td>지연시간과 처리량의 수학적 모델링, Little 의 법칙, M/M/1 큐 등 큐잉 이론의 기초와 응용</td></tr><tr><td>네트워크 프로토콜</td><td>네트워킹</td><td>TCP, UDP, QUIC 등 다양한 네트워크 프로토콜의 지연시간과 처리량 특성 이해</td></tr><tr><td>분산 시스템 설계</td><td>아키텍처</td><td>CAP 이론, 데이터 복제, 샤딩 등 분산 시스템에서 지연시간과 처리량 최적화 기법</td></tr><tr><td>하드웨어 아키텍처</td><td>하드웨어</td><td>CPU 캐시, NUMA 아키텍처, DMA 등 하드웨어 수준의 지연시간과 처리량 최적화</td></tr><tr><td>성능 측정 방법론</td><td>측정/분석</td><td>지연시간과 처리량 측정 도구, 통계적 분석 방법, 벤치마킹 기법</td></tr><tr><td>캐싱 전략</td><td>최적화</td><td>다양한 캐싱 전략, 캐시 일관성 프로토콜, 최적의 캐시 사이즈 결정 방법</td></tr><tr><td>로드 밸런싱 알고리즘</td><td>분산 컴퓨팅</td><td>라운드 로빈, 최소 연결, 해시 기반 등 다양한 로드 밸런싱 알고리즘의 장단점</td></tr><tr><td>데이터베이스 최적화</td><td>데이터</td><td>인덱싱, 쿼리 최적화, 트랜잭션 처리 등 데이터베이스 성능 향상 기법</td></tr><tr><td>실시간 시스템</td><td>특수 도메인</td><td>실시간 시스템의 요구사항과 지연시간 보장 메커니즘</td></tr><tr><td>클라우드 성능 최적화</td><td>클라우드</td><td>클라우드 환경에서의 지연시간과 처리량 최적화 전략, 자동 확장 정책</td></tr></tbody></table><h3 id=학습-주제-정리>학습 주제 정리<a hidden class=anchor aria-hidden=true href=#학습-주제-정리>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>System Performance</td><td>QoS (Quality of Service)</td><td>시스템에서 서비스 품질 보장을 위한 다양한 지표와 정책을 학습</td></tr><tr><td>Distributed Systems</td><td>분산 큐 시스템 (Kafka, RabbitMQ 등)</td><td>고처리량 시스템을 위한 메시지 기반 아키텍처 이해</td></tr><tr><td>Networking</td><td>TCP/IP 지연 및 처리량 제어</td><td>전송 계층에서 성능을 제한하는 요소와 최적화 기법 학습</td></tr><tr><td>Cloud Computing</td><td>Auto Scaling 및 Load Balancing</td><td>클라우드 기반에서 처리량과 응답 속도를 동적으로 조절하는 구조 이해</td></tr><tr><td>DevOps</td><td>Performance Monitoring Tools</td><td>Prometheus, Grafana, Datadog 등을 통한 실시간 모니터링과 튜닝 실습</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>지연시간 (Latency)</td><td>데이터가 한 지점에서 다른 지점으로 이동하는 데 걸리는 시간. 일반적으로 밀리초 (ms) 나 마이크로초 (μs) 단위로 측정됨</td></tr><tr><td>처리량 (Throughput)</td><td>단위 시간당 처리할 수 있는 작업량. 초당 비트 수 (bps), 초당 요청 수 (RPS) 등으로 측정됨</td></tr><tr><td>대역폭 (Bandwidth)</td><td>통신 채널의 최대 이론적 처리 용량. 처리량의 상한선을 결정함</td></tr><tr><td>응답 시간 (Response Time)</td><td>요청을 보내고 완전한 응답을 받을 때까지의 총 시간. 지연시간 + 처리 시간 + 대기 시간</td></tr><tr><td>P95/P99 지연시간</td><td>모든 요청 중 95%/99% 의 요청이 이 시간 이내에 처리됨을 나타내는 백분위 지연시간</td></tr><tr><td>테일 지연시간 (Tail Latency)</td><td>가장 느린 요청들 (일반적으로 상위 5% 또는 1%) 의 응답 시간</td></tr><tr><td>캐싱 (Caching)</td><td>자주 접근하는 데이터를 빠르게 접근할 수 있는 위치에 저장하여 지연시간을 줄이는 기법</td></tr><tr><td>큐잉 지연 (Queuing Delay)</td><td>처리를 기다리는 동안 요청이 큐에서 대기하는 시간</td></tr><tr><td>로드 밸런싱 (Load Balancing)</td><td>여러 서버나 자원에 작업을 분산하여 처리량을 높이는 기법</td></tr><tr><td>병목 현상 (Bottleneck)</td><td>시스템 성능을 제한하는 구성 요소나 프로세스</td></tr><tr><td>CDN(Content Delivery Network)</td><td>사용자와 가까운 위치에 콘텐츠를 캐싱하여 지연시간을 줄이는 분산 서버 네트워크</td></tr><tr><td>비동기 처리 (Asynchronous Processing)</td><td>요청을 즉시 응답하지 않고 백그라운드에서 처리하여 처리량을 높이는 기법</td></tr><tr><td>샤딩 (Sharding)</td><td>데이터베이스를 여러 파티션으로 분할하여 처리량을 높이는 기법</td></tr><tr><td>리틀의 법칙 (Little&rsquo;s Law)</td><td>L = λW: 평균 시스템 내 항목 수 (L) 는 평균 도착률 (λ) 과 평균 대기 시간 (W) 의 곱과 같다는 원리</td></tr><tr><td>TCP/IP</td><td>인터넷의 기본 통신 프로토콜. 신뢰성과 순서 보장에 중점을 두어 지연시간과 처리량에 영향을 미침</td></tr><tr><td>QUIC</td><td>Google 이 개발한 UDP 기반 전송 프로토콜. 연결 설정 시간을 줄이고 멀티플렉싱을 지원하여 지연시간과 처리량 개선</td></tr><tr><td>엣지 컴퓨팅 (Edge Computing)</td><td>데이터 소스와 가까운 위치에서 처리하여 지연시간을 줄이는 분산 컴퓨팅 패러다임</td></tr><tr><td>모노레포 (Monorepo)</td><td>여러 프로젝트를 하나의 저장소에서 관리하는 방식. 빌드 최적화와 의존성 관리에 영향을 미침</td></tr><tr><td>폴리레포 (Polyrepo)</td><td>각 프로젝트를 별도의 저장소에서 관리하는 방식. 독립적인 개발과 배포에 유리함</td></tr><tr><td>QKD</td><td>양자 키 분배 보안 기술</td></tr><tr><td>MEC</td><td>Mobile Edge Computing</td></tr><tr><td>QoS (Quality of Service)</td><td>시스템이 일정 수준 이상의 서비스 품질을 보장하도록 관리하는 기술</td></tr><tr><td>RPC (Remote Procedure Call)</td><td>네트워크 상의 다른 서버에 있는 함수나 메서드를 호출하는 통신 기법</td></tr><tr><td>SLA (Service Level Agreement)</td><td>고객과 서비스 제공자 간의 서비스 품질, 성능 보장 등의 계약</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=latency--throughput-관련>Latency & Throughput 관련<a hidden class=anchor aria-hidden=true href=#latency--throughput-관련>#</a></h3><ul><li><a href=https://www.geeksforgeeks.org/latency-in-system-design/>Latency and Throughput in System Design | GeeksforGeeks</a></li><li><a href=https://cs.fyi/guide/latency-vs-throughput>System Design: Latency vs Throughput - cs.fyi</a></li><li><a href=https://igotanoffer.com/blogs/tech/latency-throughput-availability-system-design-interview>Latency, throughput, and availability: system design interview concepts - IGotAnOffer</a></li><li><a href=https://javachallengers.com/latency-and-throughput/>Latency and Throughput for Systems Design Interview - Java Challengers</a></li><li><a href=https://aws.amazon.com/compare/the-difference-between-throughput-and-latency/>Throughput vs Latency - AWS 비교 문서</a></li><li><a href=https://www.perfmatrix.com/latency-bandwidth-throughput-and-response-time/>Latency, Bandwidth, Throughput and Response Time | PerfMatrix</a></li><li><a href=https://dropbox.tech/infrastructure/optimizing-web-servers-for-high-throughput-and-low-latency>Optimizing web servers for high throughput and low latency - Dropbox</a></li><li><a href=https://blog.danslimmon.com/2019/02/26/the-latency-throughput-tradeoff-why-fast-services-are-slow-and-vice-versa/>The Latency/Throughput Tradeoff - Dan Slimmon</a></li></ul><h3 id=모놀리포-vs-폴리레포-참고-추가>모놀리포 Vs 폴리레포 (참고 추가)<a hidden class=anchor aria-hidden=true href=#모놀리포-vs-폴리레포-참고-추가>#</a></h3><ul><li><a href=https://github.com/joelparkerhenderson/monorepo-vs-polyrepo>Monorepo vs. Polyrepo - GitHub</a></li><li><a href=https://dev.to/bitdev_/monorepo-vs-polyrepo-j9>Monorepo VS Polyrepo - DEV Community</a></li></ul><h3 id=최신-기술-동향-및-성능-최적화-사례>최신 기술 동향 및 성능 최적화 사례<a hidden class=anchor aria-hidden=true href=#최신-기술-동향-및-성능-최적화-사례>#</a></h3><ul><li><a href=https://www.infoq.com/news/2025/05/google-cloud-rapid-storage>Google Cloud Rapid Storage - InfoQ</a></li><li><a href=https://engineering.fb.com/2024/03/20/networking-traffic/optimizing-rtc-bandwidth-estimation-machine-learning/>Meta RTC Optimization - Facebook Engineering</a></li><li><a href=https://cacm.acm.org/research/metas-hyperscale-infrastructure-overview-and-insights>Meta ServiceRouter at Scale - CACM</a></li></ul><h3 id=성능-인프라-관련-도구-및-문서>성능 인프라 관련 도구 및 문서<a hidden class=anchor aria-hidden=true href=#성능-인프라-관련-도구-및-문서>#</a></h3><ul><li><a href=https://www.cloudflare.com/learning/cdn/what-is-a-cdn/>Cloudflare CDN Documentation</a></li><li><a href=https://docs.aws.amazon.com/autoscaling/>AWS Auto Scaling</a></li><li><a href=https://prometheus.io/docs/introduction/overview/>Prometheus Official Docs</a></li><li><a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/>Kubernetes Horizontal Pod Autoscaler</a></li></ul><h3 id=기타>기타<a hidden class=anchor aria-hidden=true href=#기타>#</a></h3><ul><li><a href=https://aws.amazon.com/>AWS 공식 문서 - Latency/Throughput 개념</a></li><li><a href=https://research.google/>Google QUIC 프로토콜 백서</a></li><li><a href=https://standards.ieee.org/>2025 네트워크 트렌드 리포트 - IEEE</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-design/>System-Design</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/latency-vs-throughput/>Latency-vs-Throughput</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-basic-commands/><span class=title>« Prev</span><br><span>Git Basic Commands</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/><span class=title>Next »</span><br><span>ANSI</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>