<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Law of Demeter | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Design-Principles"><meta name=description content='"객체는 자신과 직접적으로 관련된 객체와만 대화해야 한다."'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/law-of-demeter/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/law-of-demeter/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/law-of-demeter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/law-of-demeter/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Law of Demeter"><meta property="og:description" content='"객체는 자신과 직접적으로 관련된 객체와만 대화해야 한다."'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Law of Demeter"><meta name=twitter:description content='"객체는 자신과 직접적으로 관련된 객체와만 대화해야 한다."'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System and Software Architecture","item":"https://buenhyden.github.io/posts/system-and-software-architecture/"},{"@type":"ListItem","position":3,"name":"Principles","item":""},{"@type":"ListItem","position":4,"name":"Design Principles","item":"https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/"},{"@type":"ListItem","position":5,"name":"Law of Demeter","item":"https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/law-of-demeter/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-and-software-architecture/>System and Software Architecture</a>&nbsp;»&nbsp;<a href>Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/>Design Principles</a></div><h1>Law of Demeter</h1><div class=post-description>&ldquo;객체는 자신과 직접적으로 관련된 객체와만 대화해야 한다.&rdquo;</div></header><div class=post-content><h2 id=law-of-demeter>Law of Demeter<a hidden class=anchor aria-hidden=true href=#law-of-demeter>#</a></h2><h2 id=1-주제의-분류가-적절한지에-대한-분석>1. 주제의 분류가 적절한지에 대한 분석<a hidden class=anchor aria-hidden=true href=#1-주제의-분류가-적절한지에-대한-분석>#</a></h2><p>Law of Demeter(데메테르의 법칙) 는 객체지향 소프트웨어 설계에서 결합도를 낮추고, 각 객체가 자신과 직접적으로 연관된 객체와만 상호작용하도록 권장하는 설계 원칙입니다. 이는 시스템 구조, 소프트웨어 아키텍처, 코드 품질 등과 밀접하게 관련되어 있으므로 &ldquo;System and Software Architecture > Principles > Design Principles&rdquo; 분류에 매우 적합합니다. 실제로 이 원칙은 느슨한 결합 (Loose Coupling), 정보 은닉 (Information Hiding), 유지보수성 향상 등 아키텍처 설계의 핵심 목표와 직접적으로 연결되어 있습니다 [1][2][5][6].</p><h2 id=1-주제-분류의-적절성-분석>1. 주제 분류의 적절성 분석<a hidden class=anchor aria-hidden=true href=#1-주제-분류의-적절성-분석>#</a></h2><p><strong>분류:</strong><br>&ldquo;Computer Science and Engineering&rdquo; > &ldquo;System and Software Architecture&rdquo; > &ldquo;Principles&rdquo; > &ldquo;Design Principles&rdquo;</p><p><strong>분석:</strong><br>&ldquo;Law of Demeter&rdquo; 는 소프트웨어 아키텍처의 설계 원칙 중 하나로, 모듈 간의 결합도를 낮추고 응집도를 높이는 것을 목표로 합니다. 따라서 &ldquo;System and Software Architecture&rdquo; 의 &ldquo;Design Principles&rdquo; 하위 분류로 적절합니다.</p><h2 id=1-주제-분류의-적절성-분석-1>1. 주제 분류의 적절성 분석<a hidden class=anchor aria-hidden=true href=#1-주제-분류의-적절성-분석-1>#</a></h2><p>제시된 분류 **&ldquo;Computer Science and Engineering&rdquo; > &ldquo;System and Software Architecture&rdquo; > &ldquo;Principles&rdquo; > &ldquo;Design Principles&rdquo;**는 매우 적절합니다.</p><p><strong>근거:</strong></p><ul><li>Law of Demeter 는 1987 년 Ian Holland 이 제안한 객체지향 설계 원칙입니다</li><li>소프트웨어 아키텍처에서 컴포넌트 간 결합도를 관리하는 핵심 설계 원칙입니다</li><li>시스템의 구조적 품질과 유지보수성에 직접적으로 영향을 미치는 아키텍처 원칙입니다</li><li>SOLID 원칙과 함께 현대 소프트웨어 설계의 기본 원칙으로 인정받고 있습니다</li></ul><h2 id=2-요약-설명-200-자-내외>2. 요약 설명 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200-자-내외>#</a></h2><p>Law of Demeter 는 객체가 자신과 직접적으로 연관된 객체 (자신, 인스턴스 변수, 메서드 인자, 생성한 객체) 와만 상호작용하도록 제한하는 설계 원칙입니다. 이를 통해 결합도를 낮추고, 코드의 유지보수성과 확장성을 높이며, 시스템의 복잡도를 줄일 수 있습니다 [1][2][5][6].</p><h2 id=2-요약-설명-200-자-내외-1>2. 요약 설명 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200-자-내외-1>#</a></h2><p>&ldquo;Law of Demeter&rdquo; 는 객체가 직접적으로 알고 있는 객체와만 상호작용해야 한다는 원칙으로, 모듈 간의 결합도를 낮추고 유지보수성을 향상시킵니다. 이를 통해 소프트웨어의 유연성과 확장성을 높일 수 있습니다.(<a href="https://medium.com/vattenfall-tech/the-law-of-demeter-by-example-fd7adbf0c324?utm_source=chatgpt.com" title="The Law of Demeter by Example">Medium</a>)</p><h2 id=2-요약-설명-200-자-내외-2>2. 요약 설명 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200-자-내외-2>#</a></h2><p>Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 &rsquo; 최소 지식의 원칙 &rsquo; 입니다.</p><h2 id=3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외>#</a></h2><p>1987 년 Ian Holland 이 제안한 Law of Demeter 는 객체지향 프로그래밍에서 느슨한 결합을 촉진하는 설계 가이드라인입니다. 객체는 자신의 직접적인 의존성과만 상호작용해야 하며, 다른 객체의 내부 구조를 탐색하지 말아야 한다는 원칙으로, 유지보수성과 적응성을 향상시킵니다.</p><h2 id=3-전체-개요-250-자-내외-1>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외-1>#</a></h2><p>&ldquo;Law of Demeter&rdquo; 는 객체 지향 설계에서 모듈 간의 결합도를 최소화하여 시스템의 유지보수성과 확장성을 향상시키는 설계 원칙입니다. 객체는 자신이 직접 알고 있는 객체와만 상호작용해야 하며, 이를 통해 시스템의 유연성과 모듈화를 촉진합니다.</p><h2 id=3-전체-개요-250-자-내외-2>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외-2>#</a></h2><p>Law of Demeter(데메테르의 법칙) 는 " 최소 지식 원칙 (Principle of Least Knowledge)" 이라고도 불리며, 소프트웨어의 각 모듈이나 객체가 자신과 밀접하게 연관된 객체와만 상호작용해야 한다는 설계 지침입니다. 이 원칙은 객체 간 불필요한 의존성과 결합도를 줄여 시스템의 유연성, 유지보수성, 테스트 용이성을 높입니다. 대표적으로 &ldquo;A.getB().getC().doSomething()&rdquo; 과 같은 체이닝 호출을 지양하고, 중간 객체의 책임을 명확히 분리하는 방식으로 적용됩니다. 실무에서는 Facade, Service Layer, DTO, 의존성 주입 등 다양한 패턴과 기법으로 활용됩니다 [1][2][3][5][6].</p><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><ul><li><p><strong>정의:</strong> &ldquo;Law of Demeter&rdquo; 는 객체가 자신이 직접 알고 있는 객체와만 상호작용해야 한다는 설계 원칙입니다.</p></li><li><p><strong>목적:</strong> 모듈 간의 결합도를 낮추고, 시스템의 유지보수성과 확장성을 향상시키는 것입니다.</p></li><li><p><strong>적용 대상:</strong> 객체 지향 프로그래밍에서의 클래스, 메서드, 모듈 등</p></li></ul><h2 id=4-핵심-개념-1>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-1>#</a></h2><ul><li><strong>정의</strong>: Law of Demeter 는 객체지향 설계에서 한 객체가 직접적으로 연관된 객체와만 상호작용하도록 제한하는 설계 원칙입니다. " 자신의 친구와만 대화하라 (Only talk to your immediate friends)" 라는 슬로건으로 요약됩니다 [1][2][4][6].</li><li><strong>핵심 규칙</strong>: 한 메서드는 다음 객체에만 메시지를 보낼 수 있습니다 [2][3][6]:<ul><li>자기 자신 (this)</li><li>메서드 인자 (argument)</li><li>자신이 생성한 객체</li><li>자신의 인스턴스 변수</li></ul></li><li><strong>지양해야 할 패턴</strong>: 체이닝 호출 (예: objA.getB().getC().doSomething()) 은 데메테르의 법칙 위반입니다 [2][3][6].</li><li><strong>목적</strong>: 결합도 최소화, 정보 은닉, 유지보수성 및 확장성 향상 [1][2][5][6].</li><li><strong>실무 적용</strong>: Facade 패턴, Service Layer, DTO, 의존성 주입 (DI), 캡슐화 등 다양한 설계 패턴과 연계 [5][6].</li></ul><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>Law of Demeter (디미터 법칙)</strong> 또는 **Principle of Least Knowledge (최소 지식의 원칙)**는 객체지향 프로그래밍에서 객체 간의 상호작용을 제한하여 느슨한 결합 (Loose Coupling) 을 달성하는 설계 원칙입니다.</p><p><strong>핵심 철학:</strong></p><ul><li>객체는 자신의 직접적인 " 친구 " 들과만 대화해야 함</li><li>" 낯선 사람 " 과는 대화하지 말아야 함</li><li>다른 객체의 내부 구조나 속성에 대해 최소한만 가정해야 함</li></ul><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><ul><li><strong>제안자</strong>: Ian Holland (Northeastern University)</li><li><strong>제안 시기</strong>: 1987 년 말</li><li><strong>프로젝트 배경</strong>: Demeter Project (하드웨어 기술 언어 Zeus 의 구현을 단순화하기 위한 도구 개발)</li><li><strong>명명 유래</strong>: 그리스 농업의 여신 데메테르 (Demeter) 에서 유래</li><li><strong>철학</strong>: 소프트웨어를 " 구축 " 하는 것이 아닌 " 성장 " 시키는 개념</li></ul><h3 id=배경-1>배경<a hidden class=anchor aria-hidden=true href=#배경-1>#</a></h3><ul><li>1987 년 Northeastern University 의 Ian Holland 가 제안, Demeter 프로젝트에서 유래 [1][4].</li><li>객체지향 설계에서 불필요한 결합과 정보 노출로 인한 유지보수성 저하 문제를 해결하고자 등장 [1][2][5].</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ol><li><strong>결합도 감소</strong>: 컴포넌트 간 상호의존성 최소화</li><li><strong>유지보수성 향상</strong>: 변경 시 영향 범위 제한</li><li><strong>캡슐화 강화</strong>: 객체의 내부 구현 은닉</li><li><strong>적응성 증대</strong>: 요구사항 변경에 대한 유연한 대응</li><li><strong>정보 숨김</strong>: 불필요한 세부사항 노출 방지</li></ol><h3 id=목적-및-필요성-1>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성-1>#</a></h3><ul><li>시스템의 결합도를 낮추고, 각 객체가 자신의 책임과 역할에 집중하도록 유도 [1][2][5][6].</li><li>변경에 강한 구조, 테스트 용이성, 코드의 명확성과 일관성 확보 [2][5][6].</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li>객체 간 직접적인 상호작용만 허용해 의존성 최소화</li><li>정보 은닉 (캡슐화) 강화</li><li>시스템의 안정성 및 유연성 향상</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>느슨한 결합 (Loose Coupling) 지향</li><li>정보 은닉 (Information Hiding) 강조</li><li>유지보수성, 확장성, 테스트 용이성 향상</li></ul><h3 id=핵심-원칙-및-주요-원리>핵심 원칙 및 주요 원리<a hidden class=anchor aria-hidden=true href=#핵심-원칙-및-주요-원리>#</a></h3><ul><li>" 친구의 친구와는 대화하지 않는다 (Only talk to your immediate friends)"[1][2][4][6].</li><li>객체는 자신이 직접 소유하거나, 생성했거나, 인자로 받은 객체와만 상호작용 [2][3][6].</li><li>객체 체이닝 (Chained Calls) 지양</li></ul><h4 id=다이어그램-mermaid>다이어그램 (Mermaid)<a hidden class=anchor aria-hidden=true href=#다이어그램-mermaid>#</a></h4><pre class=mermaid>flowchart TD
    A[Object A] --&gt;|has| B[Object B]
    B --&gt;|has| C[Object C]
    A -.-&gt;|&#34;X (위반)&#34;| C
    A --&gt;|&#34;O (준수)&#34;| B
</pre><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>객체의 메서드는 다음과 같은 객체의 메서드만 호출해야 합니다:</p><ol><li><p>자기 자신의 메서드</p></li><li><p>메서드의 매개변수로 전달된 객체의 메서드</p></li><li><p>자기 자신의 필드로 선언된 객체의 메서드</p></li><li><p>메서드 내에서 생성된 객체의 메서드</p></li></ol><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><p><strong>세 가지 핵심 권고사항:</strong></p><ol><li>각 단위는 다른 단위에 대해 제한된 지식만 가져야 함</li><li>각 단위는 친구들과만 대화해야 함</li><li>직접적인 친구들과만 대화해야 함</li></ol><p><strong>형식적 정의:</strong> 클래스 C 의 메서드 M 은 다음 유형의 객체 메서드만 호출할 수 있습니다:</p><ul><li>M 의 인수 객체들 (C 자신 포함)</li><li>C 의 인스턴스 변수 클래스들</li><li>M 에 의해 생성된 객체들</li><li>전역 변수 및 C 의 직접적인 구성 요소 객체들</li></ul><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><pre class=mermaid>graph TD
    A[Object A] --&gt; B[Object B]
    B --&gt; C[Object C]
    
    A -.-&gt; C
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    
    A -.-&gt;|&#34;❌ 위반: A.getB().getC()&#34;| C
    A --&gt;|&#34;✅ 준수: A가 B에게 위임&#34;| B
    B --&gt;|&#34;✅ B가 C와 직접 소통&#34;| C
</pre><p><strong>캡슐화 메커니즘:</strong></p><pre class=mermaid>flowchart LR
    subgraph &#34;Law of Demeter 준수&#34;
        A1[Object A] --&gt;|&#34;명령/위임&#34;| B1[Object B]
        B1 --&gt;|&#34;내부 처리&#34;| C1[Object C]
    end
    
    subgraph &#34;Law of Demeter 위반&#34;
        A2[Object A] --&gt;|&#34;직접 접근&#34;| B2[Object B]
        A2 -.-&gt;|&#34;체이닝 접근&#34;| C2[Object C]
        B2 --&gt; C2
    end
</pre><h3 id=작동-원리-1>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리-1>#</a></h3><p>객체 간의 상호작용을 제한하여, 한 객체의 내부 구조 변경이 다른 객체에 영향을 미치지 않도록 합니다. 이를 통해 시스템의 유연성과 유지보수성을 향상시킵니다.(<a href="https://codesignal.com/learn/courses/applying-clean-code-principles-in-python/lessons/applying-the-law-of-demeter-in-python?utm_source=chatgpt.com" title="Applying the Law of Demeter in Python | CodeSignal Learn">CodeSignal</a>)</p><h3 id=작동-원리-2>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리-2>#</a></h3><ul><li>메서드 내부에서 직접적으로 연관된 객체에만 메시지 전달</li><li>중간 객체의 내부 구조에 접근하지 않고, 필요한 기능은 중간 객체에 위임</li></ul><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><table><thead><tr><th>구성 요소</th><th>기능/역할</th><th>특징</th></tr></thead><tbody><tr><td>주체 객체</td><td>자신의 책임과 역할 수행</td><td>캡슐화, 정보 은닉</td></tr><tr><td>직접 연관 객체</td><td>인스턴스 변수, 인자, 생성 객체 등</td><td>제한적 상호작용</td></tr><tr><td>외부 객체</td><td>직접 연관되지 않은 객체</td><td>직접 접근 금지</td></tr></tbody></table><h4 id=구조-다이어그램-mermaid>구조 다이어그램 (Mermaid)<a hidden class=anchor aria-hidden=true href=#구조-다이어그램-mermaid>#</a></h4><pre class=mermaid>classDiagram
    class A {
        +doSomething()
        -b: B
    }
    class B {
        +doOtherThing()
        -c: C
    }
    class C {
        +doWork()
    }
    A --&gt; B
    B --&gt; C
    %% A가 C에 직접 접근하는 것은 LoD 위반
</pre><h4 id=필수선택-구성요소>필수/선택 구성요소<a hidden class=anchor aria-hidden=true href=#필수선택-구성요소>#</a></h4><table><thead><tr><th>구분</th><th>구성 요소</th><th>기능/역할</th><th>특징</th></tr></thead><tbody><tr><td>필수</td><td>주체 객체</td><td>핵심 로직, 메시지 전달</td><td>캡슐화, 정보 은닉</td></tr><tr><td>필수</td><td>직접 연관 객체</td><td>인스턴스 변수, 인자 등</td><td>제한적 상호작용</td></tr><tr><td>선택</td><td>외부 객체</td><td>직접 연관 없는 객체</td><td>직접 접근 금지</td></tr></tbody></table><h3 id=구조-및-아키텍처-1>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처-1>#</a></h3><p><strong>구성 요소:</strong></p><table><thead><tr><th>구성 요소</th><th>기능 및 역할</th></tr></thead><tbody><tr><td>객체 A</td><td>자신의 메서드와 필드를 통해 동작을 수행</td></tr><tr><td>객체 B</td><td>객체 A 의 필드로 선언되어 있으며, 객체 A 의 메서드에서 사용</td></tr><tr><td>객체 C</td><td>객체 B 의 필드로 선언되어 있으나, 객체 A 에서는 직접 접근하지 않음</td></tr></tbody></table><p><strong>다이어그램:</strong></p><pre class=mermaid>classDiagram
    class A {
        +methodA()
    }
    class B {
        +methodB()
    }
    class C {
        +methodC()
    }
    A --&gt; B : uses
    B --&gt; C : uses
</pre><h3 id=구조-및-아키텍처-2>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처-2>#</a></h3><p><strong>필수 구성요소:</strong></p><ol><li><strong>캡슐화 경계 (Encapsulation Boundary)</strong>: 객체 내부와 외부를 구분하는 경계</li><li><strong>인터페이스 계층 (Interface Layer)</strong>: 외부와의 상호작용을 담당하는 공개 메서드들</li><li><strong>위임 메커니즘 (Delegation Mechanism)</strong>: 내부 객체로의 요청 전달 구조</li></ol><p><strong>선택 구성요소:</strong></p><ol><li><strong>Facade 패턴</strong>: 복잡한 하위 시스템에 대한 단순한 인터페이스 제공</li><li><strong>Mediator 패턴</strong>: 객체 간 상호작용 중재</li><li><strong>Proxy 패턴</strong>: 실제 객체에 대한 접근 제어</li></ol><p><strong>계층형 아키텍처 구현:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;Layer 3 (Presentation)&#34;
        P[Presentation Layer]
    end
    
    subgraph &#34;Layer 2 (Business)&#34;
        B[Business Logic Layer]
    end
    
    subgraph &#34;Layer 1 (Data)&#34;
        D[Data Access Layer]
    end
    
    P --&gt;|&#34;Only next layer&#34;| B
    B --&gt;|&#34;Only next layer&#34;| D
    P -.-&gt;|&#34;❌ Layer skipping&#34;| D
</pre><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><h4 id=1-위임자-메서드-delegate-methods>1. 위임자 메서드 (Delegate Methods)<a hidden class=anchor aria-hidden=true href=#1-위임자-메서드-delegate-methods>#</a></h4><p><strong>정의</strong>: 내부 객체의 기능을 직접 노출하지 않고 래퍼 메서드를 통해 접근 <strong>구성</strong>: 공개 메서드 → 내부 객체의 비공개 메서드 호출 <strong>목적</strong>: 내부 구조 은닉과 인터페이스 안정성 확보</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ Law of Demeter 위반
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>order</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>street</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>getCustomer</span><span class=p>().</span><span class=nx>getAddress</span><span class=p>().</span><span class=nx>getStreet</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 깊은 탐색으로 인한 강한 결합
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✅ Law of Demeter 준수 - 위임 메서드 사용
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>getCustomerStreet</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>getAddressStreet</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>OrderProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>order</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>street</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>getCustomerStreet</span><span class=p>();</span> <span class=c1>// 직접 요청
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=2-명령-패턴-command-pattern>2. 명령 패턴 (Command Pattern)<a hidden class=anchor aria-hidden=true href=#2-명령-패턴-command-pattern>#</a></h4><p><strong>정의</strong>: 데이터를 요청하는 대신 수행할 행동을 명령 <strong>구성</strong>: 명령 객체 → 수신자 객체의 메서드 실행 <strong>목적</strong>: Tell Don&rsquo;t Ask 원칙 구현</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ 데이터 요청 후 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>PayrollProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>calculatePay</span><span class=p>(</span><span class=nx>employee</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>hours</span> <span class=o>=</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>getTimesheet</span><span class=p>().</span><span class=nx>getHours</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>rate</span> <span class=o>=</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>getDepartment</span><span class=p>().</span><span class=nx>getPayRate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>hours</span> <span class=o>*</span> <span class=nx>rate</span><span class=p>;</span> <span class=c1>// 외부에서 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✅ 행동 명령
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>PayrollProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>calculatePay</span><span class=p>(</span><span class=nx>employee</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>calculatePay</span><span class=p>();</span> <span class=c1>// 행동 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-인터페이스-분리-interface-segregation>3. 인터페이스 분리 (Interface Segregation)<a hidden class=anchor aria-hidden=true href=#3-인터페이스-분리-interface-segregation>#</a></h4><p><strong>정의</strong>: 넓은 인터페이스를 좁고 집중된 인터페이스로 분리 <strong>구성</strong>: 다중 특화 인터페이스 → 단일 책임 구현 <strong>목적</strong>: 불필요한 의존성 제거</p><h4 id=4-의존성-주입-dependency-injection>4. 의존성 주입 (Dependency Injection)<a hidden class=anchor aria-hidden=true href=#4-의존성-주입-dependency-injection>#</a></h4><p><strong>정의</strong>: 필요한 객체를 외부에서 주입받아 직접 참조 <strong>구성</strong>: 생성자/세터 주입 → 직접 의존성 확보 <strong>목적</strong>: 간접적 의존성 제거</p><h3 id=구현-기법-1>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법-1>#</a></h3><ul><li><p><strong>위임 메서드 (Delegation):</strong> 객체 A 가 객체 B 의 메서드를 직접 호출하지 않고, 객체 B 에 해당 작업을 위임합니다.</p></li><li><p><strong>퍼사드 패턴 (Facade Pattern):</strong> 복잡한 하위 시스템에 대한 단순한 인터페이스를 제공합니다.</p></li><li><p><strong>서비스 레이어 (Service Layer):</strong> 비즈니스 로직을 캡슐화하여, 프레젠테이션 계층과의 결합도를 낮춥니다.</p></li></ul><h3 id=구현-기법-2>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법-2>#</a></h3><table><thead><tr><th>기법</th><th>정의/구성</th><th>목적</th><th>실제 예시 (시스템/시나리오)</th></tr></thead><tbody><tr><td>위임 (Delegation)</td><td>중간 객체에 기능 위임</td><td>결합도 감소</td><td>Car 가 Engine 에 start() 위임</td></tr><tr><td>Facade 패턴</td><td>복잡한 내부 구조 감춤</td><td>단순화, 은닉</td><td>Service Layer, API Facade</td></tr><tr><td>DTO(Data Transfer Object)</td><td>데이터 전달만 담당</td><td>정보 은닉, 결합도 감소</td><td>API 응답 객체, DB 전송 객체</td></tr><tr><td>의존성 주입 (DI)</td><td>외부에서 객체 주입</td><td>결합도 최소화</td><td>Spring DI, 생성자 주입 등</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>결합도 감소</td><td>변경 영향 최소화, 유연성 향상</td></tr><tr><td></td><td>유지보수성</td><td>코드 수정/확장 용이</td></tr><tr><td></td><td>테스트 용이</td><td>Mock/Stub 활용 쉬움</td></tr><tr><td></td><td>정보 은닉</td><td>캡슐화 강화, 안정성 향상</td></tr><tr><td>⚠ 단점</td><td>코드 증가</td><td>위임 메서드 등 보일러플레이트 증가</td></tr><tr><td></td><td>성능 저하</td><td>위임 호출이 많아질 경우 오버헤드</td></tr><tr><td></td><td>설계 복잡성</td><td>위임/캡슐화 설계 필요</td></tr></tbody></table><h3 id=장점과-단점-1>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>낮은 결합도</td><td>객체 간의 의존성을 줄여 시스템의 유연성을 향상시킵니다.</td></tr><tr><td></td><td>높은 응집도</td><td>각 객체가 자신의 책임에 집중하여, 코드의 명확성과 재사용성을 높입니다.</td></tr><tr><td>⚠ 단점</td><td>코드 복잡성 증가</td><td>위임 메서드나 퍼사드 패턴의 도입으로 코드의 양이 증가할 수 있습니다.</td></tr><tr><td></td><td>성능 저하 가능성</td><td>추가적인 메서드 호출로 인해 성능이 저하될 수 있습니다.</td></tr></tbody></table><h3 id=장점과-단점-2>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점-2>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유지보수성 향상</td><td>객체 간 느슨한 결합으로 변경 시 영향 범위 최소화</td></tr><tr><td></td><td>캡슐화 강화</td><td>내부 구현 세부사항 은닉으로 안정적인 인터페이스 제공</td></tr><tr><td></td><td>테스트 용이성</td><td>모킹과 스텁 생성이 쉬워져 단위 테스트 작성 용이</td></tr><tr><td></td><td>재사용성 증대</td><td>독립적인 컴포넌트로 다른 컨텍스트에서 재사용 가능</td></tr><tr><td></td><td>병렬 개발 가능</td><td>인터페이스만 정의되면 독립적으로 개발 진행 가능</td></tr><tr><td>⚠ 단점</td><td>래퍼 메서드 증가</td><td>위임을 위한 추가 메서드들로 인한 코드량 증가</td></tr><tr><td></td><td>성능 오버헤드</td><td>추가적인 메서드 호출로 인한 시간/공간 비용 발생</td></tr><tr><td></td><td>과도한 추상화 위험</td><td>지나친 래퍼로 인해 실제 로직 파악이 어려워질 수 있음</td></tr><tr><td></td><td>넓은 인터페이스 위험</td><td>잘못 적용 시 클래스가 과도하게 많은 메서드를 노출할 수 있음</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><ol><li><p><strong>성능 vs 설계 품질의 균형</strong></p><ul><li><strong>문제</strong>: 추가적인 메서드 호출로 인한 성능 저하</li><li><strong>해결책</strong>: 핫스팟 분석을 통한 선택적 적용, 컴파일러 최적화 활용</li></ul></li><li><p><strong>과도한 래퍼 메서드</strong></p><ul><li><strong>문제</strong>: 모든 접근에 대해 래퍼 메서드 생성 시 코드 복잡성 증가</li><li><strong>해결책</strong>: 핵심 도메인 로직에 집중 적용, 실용적 접근법 채택</li></ul></li><li><p><strong>기존 코드베이스 적용</strong></p><ul><li><strong>문제</strong>: 레거시 시스템에서의 점진적 적용 어려움</li><li><strong>해결책</strong>: 단계적 리팩토링, 경계 컨텍스트별 적용</li></ul></li><li><p><strong>팀 협업 시 일관성</strong></p><ul><li><strong>문제</strong>: 개발자마다 다른 해석과 적용</li><li><strong>해결책</strong>: 코딩 가이드라인 수립, 코드 리뷰 프로세스 강화</li></ul></li></ol><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><ul><li><p><strong>과제:</strong> 기존 코드베이스에 &ldquo;Law of Demeter&rdquo; 를 적용하기 어려움</p></li><li><p><strong>해결책:</strong> 리팩토링을 통해 객체 간의 직접적인 상호작용을 줄이고, 위임 메서드나 퍼사드 패턴을 도입합니다.</p></li></ul><h3 id=도전-과제-및-해결책-1>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책-1>#</a></h3><ul><li><strong>도전 과제</strong>: 과도한 위임 메서드로 인한 코드 증가, 설계 복잡성</li><li><strong>해결책</strong>: 자동화 도구 활용, 적절한 수준의 캡슐화, 패턴 적용 시 밸런스 유지</li></ul><h3 id=분류에-따른-종류>분류에 따른 종류<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류</th><th>설명</th></tr></thead><tbody><tr><td><strong>적용 범위별</strong></td><td>메서드 레벨</td><td>개별 메서드 내에서의 객체 호출 제한</td></tr><tr><td></td><td>클래스 레벨</td><td>클래스 간 상호작용 구조 설계</td></tr><tr><td></td><td>패키지 레벨</td><td>패키지 간 의존성 관리</td></tr><tr><td><strong>엄격성 정도별</strong></td><td>엄격한 적용</td><td>모든 상황에서 일점 규칙 준수</td></tr><tr><td></td><td>실용적 적용</td><td>상황에 따른 유연한 해석</td></tr><tr><td></td><td>선택적 적용</td><td>핵심 도메인에만 적용</td></tr><tr><td><strong>구현 방식별</strong></td><td>위임 기반</td><td>메서드 위임을 통한 구현</td></tr><tr><td></td><td>인터페이스 기반</td><td>인터페이스 분리를 통한 구현</td></tr><tr><td></td><td>의존성 주입 기반</td><td>DI 컨테이너를 활용한 구현</td></tr></tbody></table><h3 id=분류에-따른-유형>분류에 따른 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-유형>#</a></h3><table><thead><tr><th>유형</th><th>특징</th><th>적용 상황</th><th>예시</th></tr></thead><tbody><tr><td><strong>Classic LoD</strong></td><td>전통적인 엄격한 적용</td><td>도메인 모델, 핵심 비즈니스 로직</td><td>엔터프라이즈 애플리케이션</td></tr><tr><td><strong>Pragmatic LoD</strong></td><td>실용성을 고려한 유연한 적용</td><td>유틸리티 클래스, 데이터 전송 객체</td><td>웹 API, 마이크로서비스</td></tr><tr><td><strong>Fluent LoD</strong></td><td>플루언트 인터페이스와의 조화</td><td>DSL, 빌더 패턴</td><td>SQL 빌더, 설정 API</td></tr><tr><td><strong>Contextual LoD</strong></td><td>컨텍스트에 따른 선택적 적용</td><td>레거시 통합, 서드파티 라이브러리</td><td>어댑터 패턴, 브릿지 패턴</td></tr></tbody></table><h3 id=분류에-따른-종류유형>분류에 따른 종류/유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류/유형</th><th>설명</th></tr></thead><tbody><tr><td>적용 범위</td><td>메서드, 클래스, 모듈</td><td>단위별로 적용 가능</td></tr><tr><td>구현 방식</td><td>위임, 패턴, DI</td><td>위임 메서드, Facade, Service Layer 등</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 영역</th><th>적용 방법/예시</th><th>효과</th></tr></thead><tbody><tr><td>도메인 모델</td><td>중첩 객체 직접 접근 금지, 위임 활용</td><td>결합도 감소, 유지보수성 향상</td></tr><tr><td>서비스 레이어</td><td>Facade 패턴 적용</td><td>내부 구조 은닉, 단순화</td></tr><tr><td>API 설계</td><td>DTO 활용, 체이닝 호출 금지</td><td>정보 은닉, 확장성 강화</td></tr><tr><td>의존성 관리</td><td>DI 로 객체 주입</td><td>결합도 최소화, 테스트 용이</td></tr></tbody></table><h3 id=실무-적용-예시-1>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시-1>#</a></h3><table><thead><tr><th>사례</th><th>설명</th></tr></thead><tbody><tr><td>웹 애플리케이션의 서비스 계층</td><td>컨트롤러가 서비스 계층을 통해 비즈니스 로직을 호출하고, 서비스 계층이 데이터 액세스 계층과 상호작용합니다.</td></tr></tbody></table><h3 id=실무-적용-예시-2>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시-2>#</a></h3><table><thead><tr><th>도메인</th><th>적용 사례</th><th>위반 예시</th><th>개선 방안</th><th></th></tr></thead><tbody><tr><td><strong>전자상거래</strong></td><td><code>order.calculateTotal()</code></td><td><code>order.getItems().getPrice().sum()</code></td><td>주문 객체가 총액 계산 로직 내장</td><td></td></tr><tr><td><strong>금융 시스템</strong></td><td><code>account.withdraw(amount)</code></td><td><code>account.getBalance().subtract()</code></td><td>계좌 객체가 출금 로직 직접 처리</td><td></td></tr><tr><td><strong>인사 관리</strong></td><td><code>employee.calculateSalary()</code></td><td><code>employee.getDept().getRate().calc()</code></td><td>직원 객체가 급여 계산 책임 담당</td><td></td></tr><tr><td><strong>게임 개발</strong></td><td><code>character.attack(target)</code></td><td><code>character.getWeapon().getDamage()</code></td><td>캐릭터가 공격 행동 전체 조율</td><td></td></tr><tr><td><strong>IoT 시스템</strong></td><td><code>device.sendCommand(command)</code></td><td><code>device.getConnection().getProtocol()</code></td><td>디바이스가 통신 프로토콜 추상화</td><td></td></tr></tbody></table><h3 id=활용-사례-전자상거래-주문-처리-시스템>활용 사례: 전자상거래 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#활용-사례-전자상거래-주문-처리-시스템>#</a></h3><p><strong>시나리오</strong>: 온라인 쇼핑몰에서 주문 처리 과정에 Law of Demeter 적용</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    subgraph &#34;Order Processing System&#34;
        OC[Order Controller]
        OS[Order Service]
        O[Order]
        C[Customer]
        P[Payment]
        I[Inventory]
        S[Shipping]
    end
    
    OC --&gt;|&#34;processOrder(orderData)&#34;| OS
    OS --&gt;|&#34;createOrder()&#34;| O
    OS --&gt;|&#34;validatePayment()&#34;| P
    OS --&gt;|&#34;checkInventory()&#34;| I
    OS --&gt;|&#34;arrangeShipping()&#34;| S
    
    O --&gt;|&#34;calculateTotal()&#34;| O
    O --&gt;|&#34;validateCustomer()&#34;| C
</pre><p><strong>Law of Demeter 위반 사례</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ 위반: 깊은 객체 탐색
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>customer</span> <span class=o>=</span> <span class=nx>orderData</span><span class=p>.</span><span class=nx>getCustomer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>address</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getAddress</span><span class=p>().</span><span class=nx>getStreet</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>const</span> <span class=nx>paymentMethod</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getPayment</span><span class=p>().</span><span class=nx>getMethod</span><span class=p>().</span><span class=nx>getType</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>const</span> <span class=nx>discount</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getMembership</span><span class=p>().</span><span class=nx>getLevel</span><span class=p>().</span><span class=nx>getDiscount</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=c1>// 복잡한 결합 관계로 인한 취약한 코드
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Law of Demeter 준수 개선안</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ✅ 개선: 책임 위임과 캡슐화
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>order</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>orderService</span><span class=p>.</span><span class=nx>createOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>process</span><span class=p>();</span> <span class=c1>// 단일 진입점
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>process</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>validateCustomerEligibility</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>calculateTotalWithDiscounts</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>processPayment</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>reserveInventory</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>arrangeShipping</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>getOrderSummary</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 각 메서드는 해당 도메인 객체에 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>validateCustomerEligibility</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>validateForOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>calculateTotalWithDiscounts</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>discount</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>getApplicableDiscount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>items</span><span class=p>.</span><span class=nx>calculateTotal</span><span class=p>(</span><span class=nx>discount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Controller
    participant OrderService
    participant Order
    participant Customer
    participant Payment
    participant Inventory
    
    Controller-&gt;&gt;OrderService: processOrder(data)
    OrderService-&gt;&gt;Order: createOrder()
    Order-&gt;&gt;Customer: validateForOrder()
    Customer--&gt;&gt;Order: validation result
    Order-&gt;&gt;Payment: processPayment()
    Payment--&gt;&gt;Order: payment result
    Order-&gt;&gt;Inventory: reserveItems()
    Inventory--&gt;&gt;Order: reservation result
    Order--&gt;&gt;OrderService: order summary
    OrderService--&gt;&gt;Controller: process result
</pre><p><strong>Workflow</strong>:</p><ol><li><strong>주문 접수</strong>: Controller 가 OrderService 에 주문 처리 요청</li><li><strong>주문 생성</strong>: OrderService 가 Order 객체 생성 및 초기화</li><li><strong>고객 검증</strong>: Order 가 Customer 에게 주문 자격 검증 위임</li><li><strong>결제 처리</strong>: Order 가 Payment 에게 결제 처리 위임</li><li><strong>재고 확인</strong>: Order 가 Inventory 에게 재고 확보 위임</li><li><strong>배송 준비</strong>: Order 가 Shipping 에게 배송 준비 위임</li><li><strong>결과 반환</strong>: 각 단계의 결과를 Controller 에 전달</li></ol><p><strong>각 컴포넌트의 역할</strong>:</p><ul><li><strong>Order</strong>: 주문 프로세스 전체 조율 및 상태 관리</li><li><strong>Customer</strong>: 고객 정보 관리 및 자격 검증</li><li><strong>Payment</strong>: 결제 수단 관리 및 결제 처리</li><li><strong>Inventory</strong>: 재고 관리 및 예약 처리</li><li><strong>Shipping</strong>: 배송지 관리 및 배송 일정 수립</li></ul><h3 id=활용-사례-시나리오-기반>활용 사례 (시나리오 기반)<a hidden class=anchor aria-hidden=true href=#활용-사례-시나리오-기반>#</a></h3><p><strong>상황</strong>: 자동차 (Car) 가 엔진 (Engine) 과 점화플러그 (SparkPlug) 를 통해 시동을 거는 시스템<br><strong>적용</strong>:</p><ul><li>Car 는 Engine 에만 접근, SparkPlug 에는 직접 접근하지 않음</li><li>Engine 이 내부적으로 SparkPlug 를 관리</li><li>Driver 는 Car 의 start() 만 호출</li></ul><h4 id=시스템-구성-다이어그램>시스템 구성 다이어그램<a hidden class=anchor aria-hidden=true href=#시스템-구성-다이어그램>#</a></h4><pre class=mermaid>graph TD
    Driver--&gt;|&#34;start()&#34;|Car
    Car--&gt;|&#34;start()&#34;|Engine
    Engine--&gt;|&#34;ignite()&#34;|SparkPlug
</pre><h4 id=workflow>Workflow<a hidden class=anchor aria-hidden=true href=#workflow>#</a></h4><ol><li>Driver 가 Car 의 start() 호출</li><li>Car 가 Engine 의 start() 호출</li><li>Engine 이 SparkPlug 의 ignite() 호출</li></ol><h4 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h4><ul><li>각 객체가 자신의 직접적인 친구와만 상호작용</li><li>내부 구조 은닉, 결합도 최소화</li></ul><h2 id=12-활용-사례-전자상거래-시스템에서의-law-of-demeter-적용>12. 활용 사례: 전자상거래 시스템에서의 Law of Demeter 적용<a hidden class=anchor aria-hidden=true href=#12-활용-사례-전자상거래-시스템에서의-law-of-demeter-적용>#</a></h2><h3 id=-시나리오>📌 시나리오<a hidden class=anchor aria-hidden=true href=#-시나리오>#</a></h3><p>전자상거래 플랫폼에서 주문 처리 (Checkout) 를 담당하는 <code>OrderService</code> 클래스가 <code>Customer</code>, <code>Cart</code>, <code>Payment</code>, <code>Shipping</code> 등의 도메인 객체와 상호작용함.</p><h4 id=문제-발생-전>문제 발생 전<a hidden class=anchor aria-hidden=true href=#문제-발생-전>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>customer</span><span class=p>.</span><span class=na>getCart</span><span class=p>().</span><span class=na>getItems</span><span class=p>().</span><span class=na>forEach</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=na>getProduct</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>➡ Law of Demeter 위반 (너무 많은 체이닝)</p><h4 id=리팩토링-후>리팩토링 후<a hidden class=anchor aria-hidden=true href=#리팩토링-후>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>customer</span><span class=p>.</span><span class=na>describeCartItems</span><span class=p>();</span><span class=w>  </span><span class=c1>// 위임 메서드 도입</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=시스템-구성>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성>#</a></h3><pre class=mermaid>classDiagram
    class OrderService {
        +checkout()
    }
    class Customer {
        +describeCartItems()
    }
    class Cart {
        +getItems()
    }
    class Item {
        +getProduct()
    }
    class Product {
        +getName()
    }
    OrderService --&gt; Customer : uses
    Customer --&gt; Cart : owns
    Cart --&gt; Item : contains
    Item --&gt; Product : references
</pre><h3 id=workflow-다이어그램>Workflow 다이어그램<a hidden class=anchor aria-hidden=true href=#workflow-다이어그램>#</a></h3><pre class=mermaid>sequenceDiagram
    participant OrderService
    participant Customer
    participant Cart
    participant Item
    participant Product

    OrderService-&gt;&gt;Customer: describeCartItems()
    Customer-&gt;&gt;Cart: getItems()
    Cart-&gt;&gt;Item: 각 아이템 반환
    Item-&gt;&gt;Product: getProduct()
    Product--&gt;&gt;Item: 이름 반환
</pre><h3 id=담당-역할-요약>담당 역할 요약<a hidden class=anchor aria-hidden=true href=#담당-역할-요약>#</a></h3><table><thead><tr><th>클래스</th><th>역할 설명</th></tr></thead><tbody><tr><td>OrderService</td><td>주문 처리 및 흐름 제어</td></tr><tr><td>Customer</td><td>고객 정보 및 행위 책임 주체</td></tr><tr><td>Cart</td><td>장바구니 항목 관리</td></tr><tr><td>Item</td><td>개별 상품 항목</td></tr><tr><td>Product</td><td>상품 정보 보유 객체</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>위임 메서드 관리</td><td>과도한 위임 메서드 증가 주의</td><td>자동화 도구 활용, 밸런스 유지</td></tr><tr><td>설계 복잡성</td><td>캡슐화와 단순함의 균형 필요</td><td>코드 리뷰, 설계 표준화</td></tr><tr><td>테스트 전략</td><td>Mock/Stub 활용</td><td>테스트 코드 작성</td></tr><tr><td>패턴 활용</td><td>Facade, Service Layer 적극 활용</td><td>패턴 적용 시 과도한 분리 주의</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>객체 간의 명확한 책임 분리</td><td>각 객체가 자신의 책임에 집중하도록 설계합니다.</td><td>단일 책임 원칙 (SRP) 을 준수합니다.</td></tr><tr><td>위임 메서드의 적절한 사용</td><td>필요한 경우에만 위임 메서드를 도입하여 코드의 복잡성을 관리합니다.</td><td>과도한 위임을 피하고, 코드의 가독성을 유지합니다.</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-2>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-2>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 단계</strong></td><td>도메인 모델의 책임 분산</td><td>DDD 기법을 활용한 명확한 경계 설정</td></tr><tr><td><strong>구현 단계</strong></td><td>과도한 래퍼 메서드 생성 방지</td><td>핵심 비즈니스 로직에 집중 적용</td></tr><tr><td><strong>테스트 단계</strong></td><td>모킹 복잡도 관리</td><td>인터페이스 기반 모킹 활용</td></tr><tr><td><strong>유지보수 단계</strong></td><td>인터페이스 변경 시 영향도 분석</td><td>버전 관리 및 점진적 마이그레이션</td></tr><tr><td><strong>성능 최적화</strong></td><td>메서드 호출 오버헤드 모니터링</td><td>프로파일링을 통한 병목 지점 식별</td></tr><tr><td><strong>팀 협업</strong></td><td>일관된 적용 기준 수립</td><td>코딩 컨벤션 및 리뷰 가이드라인 정립</td></tr></tbody></table><p>###최적화하기 위한 고려사항 및 주의할 점</p><table><thead><tr><th>구분</th><th>고려사항</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>추가 객체 생성으로 인한 메모리 증가</td><td>객체 풀링 및 경량 패턴 활용</td></tr><tr><td><strong>실행 시간</strong></td><td>메서드 호출 체인 증가</td><td>핫패스 식별 및 선택적 최적화</td></tr><tr><td><strong>캐싱 전략</strong></td><td>위임 결과의 캐싱 필요성</td><td>메모이제이션 패턴 적용</td></tr><tr><td><strong>컴파일러 최적화</strong></td><td>JIT 컴파일러의 인라이닝 활용</td><td>프로파일 기반 최적화 (PGO) 적용</td></tr><tr><td><strong>네트워크 통신</strong></td><td>분산 시스템에서의 원격 호출 최소화</td><td>배치 처리 및 비동기 패턴 활용</td></tr><tr><td><strong>데이터베이스 접근</strong></td><td>N+1 쿼리 문제 방지</td><td>지연 로딩 및 배치 로딩 전략 수립</td></tr></tbody></table><p>###최적화하기 위한 고려사항 및 주의할 점</p><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>위임 오버헤드</td><td>위임 호출이 많을 경우 성능 저하</td><td>필요시 직접 접근 허용</td></tr><tr><td>코드 최적화</td><td>불필요한 위임/계층 제거</td><td>정적 분석, 리팩토링</td></tr><tr><td>자동화 도구</td><td>위임 메서드 자동 생성 활용</td><td>생산성 향상</td></tr></tbody></table><p>###최적화하기 위한 고려사항 및 주의할 점</p><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>메서드 호출의 최소화</td><td>불필요한 메서드 호출을 줄여 성능을 향상시킵니다.</td><td>필요한 경우에만 위임 메서드를 사용합니다.</td></tr><tr><td>객체 생성의 최적화</td><td>객체의 생성을 효율적으로 관리하여 리소스 사용을 최적화합니다.</td><td>객체 풀링 (Object Pooling) 등의 기법을 활용합니다.</td></tr></tbody></table><hr><h2 id=8-주제와-관련하여-주목할-내용>8. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#8-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Law of Demeter</td><td>최소 지식 원칙</td><td>직접 연관된 객체와만 상호작용</td></tr><tr><td>Law of Demeter</td><td>느슨한 결합</td><td>결합도 최소화, 유지보수성 향상</td></tr><tr><td>Law of Demeter</td><td>정보 은닉</td><td>내부 구조 노출 방지</td></tr><tr><td>Law of Demeter</td><td>위임 (Delegation)</td><td>중간 객체에 기능 위임</td></tr><tr><td>Law of Demeter</td><td>패턴 활용</td><td>Facade, Service Layer, DTO 등</td></tr></tbody></table><h2 id=11-주제와-관련하여-주목할-내용>11. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#11-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>설계 원칙</td><td>Principle of Least Knowledge</td><td>객체는 가능한 한 적은 정보만 알아야 한다는 원칙</td></tr><tr><td>디자인 패턴</td><td>Delegation Pattern</td><td>직접 수행하지 않고, 다른 객체에 책임을 위임하는 설계 방식</td></tr><tr><td>코드 리팩토링</td><td>중간자 제거</td><td>중간 객체에 대한 과도한 의존을 제거함으로써 Law of Demeter 를 위반하지 않도록 함</td></tr><tr><td>객체 캡슐화</td><td>Encapsulation</td><td>객체 내부 정보를 숨기고, 인터페이스를 통해만 상호작용하게 함</td></tr><tr><td>유지보수 전략</td><td>리팩토링 도구</td><td>IntelliJ, SonarQube 등을 통해 LoD 위반을 자동 진단 가능</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>디자인 패턴</strong></td><td>Facade Pattern</td><td>복잡한 서브시스템에 대한 단순 인터페이스 제공</td></tr><tr><td></td><td>Mediator Pattern</td><td>객체 간 상호작용 중재 및 결합도 감소</td></tr><tr><td></td><td>Command Pattern</td><td>요청을 객체로 캡슐화하여 위임 구조 구현</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>Layered Architecture</td><td>계층 간 단방향 의존성으로 LoD 체계적 구현</td></tr><tr><td></td><td>Hexagonal Architecture</td><td>포트 - 어댑터를 통한 외부 의존성 격리</td></tr><tr><td></td><td>Clean Architecture</td><td>의존성 역전을 통한 핵심 로직 보호</td></tr><tr><td><strong>프로그래밍 원칙</strong></td><td>Tell Don&rsquo;t Ask</td><td>데이터 요청 대신 행동 명령으로 캡슐화 강화</td></tr><tr><td></td><td>Single Responsibility</td><td>단일 책임으로 인한 자연스러운 LoD 준수</td></tr><tr><td></td><td>Dependency Inversion</td><td>추상화 의존으로 결합도 감소</td></tr><tr><td><strong>메트릭스</strong></td><td>RFC (Response For Class)</td><td>클래스의 응답 메서드 수 측정</td></tr><tr><td></td><td>WMC (Weighted Methods)</td><td>클래스당 가중 메서드 수 측정</td></tr><tr><td></td><td>Coupling Metrics</td><td>객체 간 결합도 정량적 측정</td></tr><tr><td><strong>도구 및 기법</strong></td><td>Aspect-Oriented Programming</td><td>횡단 관심사 분리를 통한 LoD 지원</td></tr><tr><td></td><td>Dependency Injection</td><td>의존성 주입으로 직접 참조 확보</td></tr><tr><td></td><td>Interface Segregation</td><td>인터페이스 분리로 불필요한 의존성 제거</td></tr></tbody></table><h3 id=하위-주제로-분류한-추가-학습-내용>하위 주제로 분류한 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류한-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>기초 이론</strong></td><td>Coupling and Cohesion</td><td>결합도와 응집도의 이론적 배경</td></tr><tr><td></td><td>Information Hiding</td><td>정보 은닉의 원리와 구현 방법</td></tr><tr><td></td><td>Encapsulation Techniques</td><td>캡슐화 기법과 실무 적용</td></tr><tr><td><strong>고급 적용</strong></td><td>Microservices and LoD</td><td>마이크로서비스에서의 서비스 간 통신</td></tr><tr><td></td><td>Event-Driven Architecture</td><td>이벤트 기반 아키텍처에서의 느슨한 결합</td></tr><tr><td></td><td>Domain-Driven Design</td><td>DDD 에서의 집계와 경계 컨텍스트</td></tr><tr><td><strong>실무 기법</strong></td><td>Refactoring Legacy Code</td><td>레거시 코드의 점진적 LoD 적용</td></tr><tr><td></td><td>Testing with LoD</td><td>LoD 준수 코드의 테스트 전략</td></tr><tr><td></td><td>Performance Optimization</td><td>LoD 적용 시 성능 최적화 기법</td></tr><tr><td><strong>도구와 프레임워크</strong></td><td>Spring Framework and LoD</td><td>Spring 에서의 의존성 주입과 LoD</td></tr><tr><td></td><td>.NET Core Dependency Injection</td><td>.NET 에서의 DI 컨테이너 활용</td></tr><tr><td></td><td>Static Analysis Tools</td><td>정적 분석을 통한 LoD 위반 탐지</td></tr></tbody></table><h2 id=9-하위-주제별-추가-학습-필요-내용>9. 하위 주제별 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#9-하위-주제별-추가-학습-필요-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략 설명</th></tr></thead><tbody><tr><td>설계 원칙</td><td>캡슐화, 정보 은닉</td><td>LoD 와 연계되는 핵심 설계 원칙</td></tr><tr><td>패턴</td><td>Facade, Service Layer, DTO</td><td>LoD 실무 적용 대표 패턴</td></tr><tr><td>테스트</td><td>Mock/Stub 활용</td><td>LoD 구조에서의 테스트 전략</td></tr><tr><td>리팩토링</td><td>체이닝 호출 제거</td><td>LoD 위반 코드 개선 방법</td></tr></tbody></table><h3 id=관련-분야와-추가-학습-내용>관련 분야와 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야와-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>Clean Code Principles</td><td>클린 코드 원칙과 LoD 의 시너지</td></tr><tr><td></td><td>SOLID Principles Integration</td><td>SOLID 원칙들과의 통합적 적용</td></tr><tr><td></td><td>Architecture Decision Records</td><td>아키텍처 결정 시 LoD 고려사항 문서화</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>Functional Composition</td><td>함수 합성과 LoD 의 관계</td></tr><tr><td></td><td>Immutable Objects</td><td>불변 객체를 통한 안전한 데이터 전달</td></tr><tr><td></td><td>Monadic Design Patterns</td><td>모나드 패턴과 체이닝의 안전한 활용</td></tr><tr><td><strong>분산 시스템</strong></td><td>Service Mesh Architecture</td><td>서비스 메시와 마이크로서비스 통신</td></tr><tr><td></td><td>API Gateway Patterns</td><td>API 게이트웨이를 통한 서비스 추상화</td></tr><tr><td></td><td>Event Sourcing</td><td>이벤트 소싱에서의 도메인 경계</td></tr><tr><td><strong>성능 엔지니어링</strong></td><td>Memory Management</td><td>메모리 관리와 객체 생명주기</td></tr><tr><td></td><td>Compiler Optimizations</td><td>컴파일러 최적화와 인라이닝</td></tr><tr><td></td><td>Profiling and Monitoring</td><td>성능 프로파일링 도구와 메트릭</td></tr></tbody></table><h2 id=9-주제와-관련하여-하위-주제로-분류해서-추가적으로-학습해야-할-내용>9. 주제와 관련하여 하위 주제로 분류해서 추가적으로 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-하위-주제로-분류해서-추가적으로-학습해야-할-내용>#</a></h2><table><thead><tr><th>간략한 설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>최소 지식 원칙에 기반한 객체 간 상호작용 제한 설계 방식</td><td>설계 원칙</td><td>Principle of Least Knowledge</td></tr><tr><td>객체 간 책임을 위임하여 결합도를 낮추는 기법</td><td>디자인 패턴</td><td>Delegation Pattern</td></tr><tr><td>복잡한 의존성을 감추고 단일 진입점을 제공하는 패턴</td><td>디자인 패턴</td><td>Facade Pattern</td></tr><tr><td>계층화된 아키텍처에서 비즈니스 로직을 분리하는 레이어</td><td>소프트웨어 아키텍처</td><td>Service Layer</td></tr><tr><td>객체의 책임 분리 및 유지보수를 용이하게 하는 원칙</td><td>설계 원칙</td><td>Single Responsibility Principle (SRP)</td></tr></tbody></table><hr><h2 id=10-주제와-관련하여-추가로-알아야-하거나-학습해야-할-내용-관련-분야-포함>10. 주제와 관련하여 추가로 알아야 하거나 학습해야 할 내용 (관련 분야 포함)<a hidden class=anchor aria-hidden=true href=#10-주제와-관련하여-추가로-알아야-하거나-학습해야-할-내용-관련-분야-포함>#</a></h2><table><thead><tr><th>간략한 설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>클래스 간 의존성을 낮추고 코드 품질을 향상시키는 법칙</td><td>객체 지향 설계</td><td>SOLID 원칙</td></tr><tr><td>객체 간의 메시지 전달 구조 및 경계 설정</td><td>소프트웨어 아키텍처</td><td>Hexagonal Architecture</td></tr><tr><td>객체 간 메시지 전달 및 디커플링을 위한 디자인 패턴</td><td>디자인 패턴</td><td>Mediator Pattern</td></tr><tr><td>유지보수성과 확장성을 위한 코드 설계 전략</td><td>소프트웨어 공학</td><td>Clean Architecture</td></tr><tr><td>런타임 시 객체 간 상호작용을 제한하는 기법</td><td>객체지향 프로그래밍</td><td>Law of Demeter for Functions (함수에 대한 확장 적용)</td></tr></tbody></table><h2 id=10-추가로-알아야-할-내용-및-관련-분야>10. 추가로 알아야 할 내용 및 관련 분야<a hidden class=anchor aria-hidden=true href=#10-추가로-알아야-할-내용-및-관련-분야>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략 설명</th></tr></thead><tbody><tr><td>객체지향</td><td>결합도/응집도</td><td>LoD 가 결합도/응집도에 미치는 영향</td></tr><tr><td>아키텍처</td><td>계층화 설계</td><td>LoD 와 계층 구조의 관계</td></tr><tr><td>코드 품질</td><td>정적 분석 도구</td><td>LoD 위반 코드 자동 탐지</td></tr><tr><td>성능 최적화</td><td>위임 최적화</td><td>위임 호출의 성능 영향 및 개선</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Law of Demeter(데메테르의 법칙)</td><td>객체가 직접적으로 연관된 객체와만 상호작용하도록 제한하는 설계 원칙</td></tr><tr><td>위임 (Delegation)</td><td>기능 수행을 다른 객체에 위임하는 설계 기법</td></tr><tr><td>Facade 패턴</td><td>복잡한 내부 구조를 감추고 단순한 인터페이스 제공</td></tr><tr><td>DTO(Data Transfer Object)</td><td>데이터 전달만 담당하는 객체</td></tr><tr><td>의존성 주입 (Dependency Injection, DI)</td><td>외부에서 객체를 주입받아 결합도를 낮추는 기법</td></tr></tbody></table><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>결합도 (Coupling)</td><td>모듈 간의 상호 의존성 정도를 나타내는 지표</td></tr><tr><td>응집도 (Cohesion)</td><td>모듈 내부의 구성 요소들이 서로 관련되어 있는 정도</td></tr><tr><td>위임 메서드 (Delegation Method)</td><td>다른 객체의 메서드를 호출하는 중간 메서드</td></tr><tr><td>퍼사드 패턴 (Facade Pattern)</td><td>복잡한 하위 시스템에 대한 단순한 인터페이스를 제공하는 디자인 패턴</td></tr><tr><td>서비스 레이어 (Service Layer)</td><td>비즈니스 로직을 캡슐화하여 프레젠테이션 계층과의 결합도를 낮추는 계층</td></tr></tbody></table><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>최소 지식 원칙 (Principle of Least Knowledge)</td><td>하나의 객체는 가능한 한 다른 객체에 대해 적게 알아야 한다는 객체지향 설계 원칙</td></tr><tr><td>체이닝 (Chaining)</td><td>여러 객체를 점 (.) 연산자로 연속 호출하는 방식으로, LoD 위반의 주요 패턴</td></tr><tr><td>캡슐화 (Encapsulation)</td><td>객체의 데이터를 직접 접근하지 못하게 하고, 메서드를 통해 접근하도록 제한하는 설계 방식</td></tr><tr><td>리팩토링 (Refactoring)</td><td>외부 동작은 동일하게 유지하면서 코드 내부 구조를 개선하는 기법</td></tr><tr><td>위임 메서드 (Delegated Method)</td><td>책임을 다른 객체로 위임하는 메서드</td></tr></tbody></table><h2 id=용어-정리-3>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-3>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>느슨한 결합 (Loose Coupling)</td><td>컴포넌트 간 의존성이 최소화된 상태로, 한 컴포넌트의 변경이 다른 컴포넌트에 미치는 영향이 적음</td></tr><tr><td>메서드 체이닝 (Method Chaining)</td><td>여러 메서드를 연속적으로 호출하는 패턴 (예: obj.method1().method2().method3())</td></tr><tr><td>위임 (Delegation)</td><td>한 객체가 다른 객체에게 특정 작업의 수행을 맡기는 설계 패턴</td></tr><tr><td>캡슐화 (Encapsulation)</td><td>객체의 내부 상태와 구현을 외부로부터 숨기고 공개 인터페이스를 통해서만 접근하도록 하는 원칙</td></tr><tr><td>RFC (Response For Class)</td><td>클래스의 메서드 호출에 대응하여 잠재적으로 실행될 수 있는 메서드들의 수를 측정하는 메트릭</td></tr><tr><td>WMC (Weighted Methods per Class)</td><td>각 클래스에 정의된 메서드들의 가중 합계를 나타내는 복잡도 메트릭</td></tr><tr><td>정보 은닉 (Information Hiding)</td><td>모듈의 내부 구현 세부사항을 외부로부터 숨기는 소프트웨어 설계 원칙</td></tr><tr><td>Tell Don&rsquo;t Ask</td><td>객체에게 데이터를 요청하여 외부에서 처리하지 말고, 객체에게 수행할 작업을 직접 지시하는 원칙</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></li><li><a href=https://www.baeldung.com/java-demeter-law>Law of Demeter in Java - Baeldung</a></li><li><a href=https://www.infoworld.com/article/2251481/demystifying-the-law-of-demeter-principle.html>Demystifying the Law of Demeter principle - InfoWorld</a></li><li><a href=https://dzone.com/articles/the-genius-of-the-law-of-demeter>The Genius of the Law of Demeter - DZone</a></li><li><a href=https://www.geeksforgeeks.org/law-of-demeter-in-java-principle-of-least-knowledge/>Law of Demeter in Java – Principle of Least Knowledge - GeeksforGeeks</a></li><li><a href=https://testdouble.com/insights/law-of-demeter-explained>Breaking down the Law of Demeter: Keep it simple - Test Double</a></li><li><a href=https://pawelpluta.com/the-law-of-demeter-by-example/>The Law of Demeter by Example - Paweł Pluta</a></li><li><a href=https://www.designgurus.io/blog/essential-software-design-principles-you-should-know-before-the-interview>Essential Software Design Principles - Design Gurus</a></li></ul><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><p><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></p></li><li><p><a href=https://medium.com/vattenfall-tech/the-law-of-demeter-by-example-fd7adbf0c324>The Law of Demeter by Example - Medium</a></p></li><li><p><a href=https://www.baeldung.com/java-demeter-law>Baeldung: Law of Demeter in Java</a></p></li><li><p><a href=https://deviq.com/laws/law-of-demeter/>DevIQ: Law of Demeter</a></p></li><li><p><a href=https://www.jetbrains.com/help/idea/structural-search-and-replace.html>JetBrains - IntelliJ Structural Search</a></p></li><li><p><a href=https://docs.sonarsource.com/>SonarQube 공식 문서</a></p></li></ul><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><p><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></p></li><li><p><a href=https://medium.com/vattenfall-tech/the-law-of-demeter-by-example-fd7adbf0c324>The Law of Demeter by Example - Medium</a></p></li><li><p><a href=https://www.baeldung.com/java-demeter-law>Law of Demeter in Java | Baeldung</a></p></li><li><p><a href=https://deviq.com/laws/law-of-demeter/>Law of Demeter - DevIQ</a></p></li><li><p><a href=https://dev.to/dazevedo/law-of-demeter-principle-of-least-knowledge-35l2>Law of Demeter (Principle of Least Knowledge) - DEV Community</a></p></li></ul><h2 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></li><li><a href=https://dev.to/dazevedo/law-of-demeter-principle-of-least-knowledge-35l2>Law of Demeter (Principle of Least Knowledge) - DEV Community</a></li><li><a href=https://testdouble.com/insights/law-of-demeter-explained>Understanding the law of Demeter in coding - Test Double</a></li><li><a href=https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/general-formulation.html>Law of Demeter (General Formulation) - Northeastern University</a></li><li><a href=https://www.linkedin.com/pulse/understanding-law-demeter-design-approaches-venkataramanan-krishnan-mpyyc>Understanding &ldquo;the Law of Demeter&rdquo; and Design Approaches - LinkedIn</a></li><li><a href=https://deviq.com/laws/law-of-demeter/>The Law of Demeter - DevIQ</a></li><li><a href=http://www.pinte.ro/Blog/IT/The-Law-of-Demeter-software-design-principle/62>The Law of Demeter software design principle</a></li></ul><hr></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>