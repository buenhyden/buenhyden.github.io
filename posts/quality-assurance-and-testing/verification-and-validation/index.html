<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Verification and Validation | hyunyoun's Blog</title><meta name=keywords content="QA,QC,Quality-Assurance,Quality-Control,Test,Verification,Validation"><meta name=description content='Verification은 "제품을 올바르게 만들고 있는가?"를 확인하는 과정이고, Validation은 "올바른 제품을 만들고 있는가?"를 확인하는 과정이다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Verification and Validation"><meta property="og:description" content='Verification은 "제품을 올바르게 만들고 있는가?"를 확인하는 과정이고, Validation은 "올바른 제품을 만들고 있는가?"를 확인하는 과정이다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Verification and Validation"><meta name=twitter:description content='Verification은 "제품을 올바르게 만들고 있는가?"를 확인하는 과정이고, Validation은 "올바른 제품을 만들고 있는가?"를 확인하는 과정이다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Verification and Validation","item":"https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Verification and Validation</h1><div class=post-description>Verification은 &ldquo;제품을 올바르게 만들고 있는가?&ldquo;를 확인하는 과정이고, Validation은 &ldquo;올바른 제품을 만들고 있는가?&ldquo;를 확인하는 과정이다.</div></header><div class=post-content><h2 id=validation-and-verification>Validation and Verification<a hidden class=anchor aria-hidden=true href=#validation-and-verification>#</a></h2><p>소프트웨어 테스팅에서 Validation과 Verification은 서로 다른 관점과 목적을 가지고 있다.<br>Verification은 &ldquo;제품을 올바르게 만들고 있는가?&ldquo;를 확인하는 과정이고, Validation은 &ldquo;올바른 제품을 만들고 있는가?&ldquo;를 확인하는 과정이다.<br>이러한 근본적인 차이는 테스트 방법과 접근 방식에 큰 영향을 미친다.</p><h3 id=verification>Verification<a hidden class=anchor aria-hidden=true href=#verification>#</a></h3><p>Verification은 <strong>&ldquo;우리가 제품을 올바르게 만들고 있는가?&rdquo;</strong> 라는 질문에 답하는 프로세스로, 개발 과정 중에 제품이 명세된 요구사항과 설계 문서에 따라 정확하게 구현되고 있는지를 검증한다.</p><p>개발자와 테스터가 수행하며, 코드 레벨에서의 정확성과 기술적 완성도를 중요시한다.<br>예를 들어, 특정 함수가 입력값에 대해 정확한 출력값을 반환하는지, 데이터베이스 쿼리가 예상대로 작동하는지 등을 확인한다.</p><h3 id=validation>Validation<a hidden class=anchor aria-hidden=true href=#validation>#</a></h3><p>Validation은 <strong>&ldquo;우리가 올바른 제품을 만들고 있는가?&rdquo;</strong> 라는 질문에 답하는 프로세스로, 개발된 제품이 실제 사용자의 요구사항과 기대를 충족시키는지 확인하는 과정이다.</p><p>사용자 관점에서의 테스트가 주를 이루며, 실제 운영 환경에서의 적합성과 사용성을 중요시한다.<br>예를 들어, 사용자가 웹사이트에서 원하는 정보를 쉽게 찾을 수 있는지, 모바일 앱의 인터페이스가 직관적인지 등을 확인한다.</p><h3 id=프로세스와-방법론의-차이>프로세스와 방법론의 차이<a hidden class=anchor aria-hidden=true href=#프로세스와-방법론의-차이>#</a></h3><p>Verification은 주로 정적 테스팅 방법을 사용한다.<br>코드 리뷰, 문서 검토, 정적 분석 등이 여기에 해당한다.<br>Validation은 동적 테스팅 방법을 주로 사용하며, 실제 시스템을 실행하면서 테스트를 수행한다.<br>사용자 시나리오 테스트, 성능 테스트, 사용성 테스트 등이 이에 해당한다.</p><h3 id=품질-보증에서의-역할>품질 보증에서의 역할<a hidden class=anchor aria-hidden=true href=#품질-보증에서의-역할>#</a></h3><p>두 테스트 방식은 상호 보완적인 관계에 있다.<br>Verification이 제품의 기술적 완성도를 보장한다면, Validation은 제품의 실용적 가치를 보장한다.<br>따라서 효과적인 품질 보증을 위해서는 두 가지 접근 방식을 모두 적절히 활용해야 한다.</p><h3 id=validation-and-verification-1>Validation and Verification<a hidden class=anchor aria-hidden=true href=#validation-and-verification-1>#</a></h3><table><thead><tr><th>비교 기준</th><th>Verification (검증)</th><th>Validation (확인)</th></tr></thead><tbody><tr><td>정의</td><td>제품을 올바르게 만들고 있는지 검증 (Building the product right)</td><td>올바른 제품을 만들고 있는지 확인 (Building the right product)</td></tr><tr><td>목적</td><td>개발 중인 제품이 명세와 표준을 준수하는지 확인</td><td>개발된 제품이 실제 사용자의 요구사항을 충족하는지 확인</td></tr><tr><td>수행 시점</td><td>개발 단계에서 지속적으로 수행</td><td>개발 후반부나 완료 단계에서 수행</td></tr><tr><td>수행 주체</td><td>개발팀, QA팀, 테스트 엔지니어</td><td>최종 사용자, 고객, QA팀</td></tr><tr><td>검증 대상</td><td>코드, 문서, 설계 명세, 기술 표준 준수 여부</td><td>사용자 요구사항, 비즈니스 목표 달성 여부</td></tr><tr><td>주요 활동</td><td>- 코드 리뷰<br>- 정적 분석<br>- 단위 테스트<br>- 통합 테스트<br>- 기술 명세 검토</td><td>- 시스템 테스트<br>- 인수 테스트<br>- 베타 테스트<br>- 사용성 테스트<br>- 성능 테스트</td></tr><tr><td>테스트 방식</td><td>- 화이트박스 테스팅<br>- 정적 테스팅<br>- 구조 기반 테스팅</td><td>- 블랙박스 테스팅<br>- 동적 테스팅<br>- 행위 기반 테스팅</td></tr><tr><td>평가 기준</td><td>- 코딩 표준 준수<br>- 기술 명세 충족<br>- 설계 요구사항 만족</td><td>- 사용자 요구사항 충족<br>- 비즈니스 목표 달성<br>- 실제 환경에서의 적합성</td></tr><tr><td>주요 산출물</td><td>- 코드 리뷰 보고서<br>- 테스트 결과 문서<br>- 정적 분석 보고서<br>- 기술 검토 문서</td><td>- 사용자 인수 테스트 보고서<br>- 시스템 테스트 결과<br>- 성능 테스트 보고서<br>- 베타 테스트 피드백</td></tr><tr><td>오류 발견 시점</td><td>개발 초기 단계에서 발견 가능</td><td>개발 후반부나 실제 사용 단계에서 발견</td></tr><tr><td>비용 영향</td><td>초기에 문제 발견으로 수정 비용 최소화</td><td>후반부 발견으로 수정 비용이 상대적으로 높음</td></tr><tr><td>적용 범위</td><td>개별 컴포넌트나 모듈 수준의 검증</td><td>전체 시스템 수준의 검증</td></tr><tr><td>자동화 가능성</td><td>높은 자동화 가능성 (단위 테스트, 정적 분석 등)</td><td>부분적 자동화 가능 (일부 시스템 테스트)</td></tr><tr><td>품질 관점</td><td>내부 품질 (기술적 완성도) 중심</td><td>외부 품질 (사용자 만족도) 중심</td></tr><tr><td>리스크 관리</td><td>기술적 리스크 감소에 중점</td><td>비즈니스 리스크 감소에 중점</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>성능 프로파일링 (Performance Profiling)</h2></header><div class=entry-content><p>성능 프로파일링 (Performance Profiling) 성능 프로파일링(Performance Profiling)은 소프트웨어의 실행 동작을 분석하여 성능을 측정하고 개선하는 기술이다.
성능 프로파일링은 소프트웨어 개발 과정에서 중요한 품질 관리 활동으로, 초기 단계부터 지속적으로 수행하여 효율적이고 최적화된 소프트웨어를 개발하는 데 도움을 준다.
정의와 목적 성능 프로파일링은 소프트웨어의 실행 시 동작과 리소스 사용을 분석하는 과정이다.
주요 목적은 다음과 같다:
코드의 병목 지점 식별 리소스 사용량 분석 (CPU 시간, 메모리 사용 등) 실행 시간이 긴 함수나 코드 섹션 파악 성능 최적화를 위한 개선 지점 도출 프로파일링 단계 계획: 분석 대상과 목표 설정 데이터 수집: 실행 중 성능 데이터 수집 분석: 수집된 데이터 분석 및 병목 지점 식별 최적화: 분석 결과를 바탕으로 코드 개선 검증: 개선 효과 확인 주요 프로파일링 유형 CPU 프로파일링: 함수별 CPU 사용 시간 측정 메모리 프로파일링: 메모리 할당 및 해제 패턴 분석 I/O 프로파일링: 디스크, 네트워크 등 I/O 작업 분석 장점 코드 품질 향상 소프트웨어 효율성 증대 리소스 할당 최적화 사용자 경험 개선 확장성 향상 도구 다양한 성능 프로파일링 도구가 있으며, 대표적인 것들은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-29 16:10:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 성능 프로파일링 (Performance Profiling)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/dynamic-analysis-and-profiling/performance-profiling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>워크스루(Walkthrough)</h2></header><div class=entry-content><p>워크스루(Walkthrough) 워크스루는 마치 박물관 가이드가 관람객들을 안내하듯이, 코드 작성자가 리뷰어들을 코드를 통해 “안내"하는 과정이다.
이 과정에서 코드의 의도, 구현 방식, 그리고 잠재적인 문제점들을 함께 발견하고 논의할 수 있다.
워크스루 세션의 실제 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 워크스루 세션 중 코드 설명 예시 public class OrderProcessor { // 발표자: "주문 처리 시스템의 핵심 클래스입니다. // 주문의 유효성 검사부터 결제, 배송 처리까지 담당합니다." private final PaymentService paymentService; private final InventoryService inventoryService; private final ShippingService shippingService; public OrderResult processOrder(Order order) { // 발표자: "먼저 주문의 유효성을 검사합니다. // 여기서 중요한 것은 재고 확인입니다." if (!validateOrder(order)) { throw new InvalidOrderException("Invalid order"); } // 발표자: "재고가 확인되면 결제를 진행합니다. // 결제는 트랜잭션으로 처리됩니다." PaymentResult payment = paymentService.processPayment(order); // 리뷰어 질문: "결제 실패 시 재고는 어떻게 처리되나요?" // 발표자: "좋은 지적입니다. 결제 실패 시 재고를 원복하는 // 로직을 추가해야 할 것 같네요." if (payment.isSuccessful()) { // 발표자: "결제가 성공하면 배송 처리를 시작합니다." return createShippingOrder(order, payment); } return OrderResult.failure("Payment failed"); } } 워크스루의 주요 특징과 장점 상호작용적 학습
참가자들은 실시간으로 질문하고 토론할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:10:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 워크스루(Walkthrough)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/walkthrough/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>코드 리뷰 (Code Review)</h2></header><div class=entry-content><p>코드 리뷰 (Code Review) 코드 리뷰는 개발자가 작성한 코드를 다른 개발자들이 검토하고 피드백을 제공하는 과정이다.
이는 마치 작가들이 서로의 글을 읽고 조언을 주고받는 것과 유사하다.
주된 목적은 코드의 품질을 향상시키고 팀 내의 지식 공유를 촉진하는 것이다.
코드 리뷰의 실제 적용 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 리뷰가 필요한 코드 예시 public class UserService { public void createUser(String username, String password) { // 데이터베이스에 직접 저장 database.execute( "INSERT INTO users (username, password) VALUES ('" + username + "', '" + password + "')" ); } } // 리뷰어의 피드백 후 개선된 코드 public class UserService { /** * 새로운 사용자를 생성하고 저장합니다. * @param username 사용자 이름 * @param password 비밀번호 * @throws ValidationException 유효하지 않은 입력값 */ public void createUser(String username, String password) { // 입력값 검증 validateInput(username, password); // 비밀번호 해싱 String hashedPassword = passwordHasher.hash(password); // 준비된 구문을 사용하여 SQL 인젝션 방지 userRepository.save(new User(username, hashedPassword)); } } 주요 특징 품질 보증:
코드 리뷰는 버그를 찾아내고, 코드 품질을 향상시키며, 보안 취약점을 발견하는 데 도움을 준다.
여러 눈이 검토하므로 한 사람이 놓칠 수 있는 문제점들을 더 쉽게 발견할 수 있다. 지식 공유:
팀 멤버들이 서로의 코드를 검토하면서 자연스럽게 지식을 공유하고 학습할 수 있다.
주니어 개발자는 시니어의 피드백을 통해 성장할 수 있고, 시니어 개발자도 새로운 관점을 얻을 수 있다. 일관성 유지:
팀의 코딩 표준과 모범 사례를 준수하는지 확인함으로써, 전체 코드베이스의 일관성을 유지할 수 있다. 코드 리뷰 프로세스의 주요 단계 리뷰 준비
개발자는 리뷰를 위해 코드를 준비할 때 다음 사항들을 고려한다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:10:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코드 리뷰 (Code Review)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/code-review/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Inspection</h2></header><div class=entry-content><p>인스펙션 (inspection) 인스펙션(Inspection)은 정적 테스팅의 한 형태로, 가장 공식적이고 체계적인 리뷰 방법이다.
인스펙션은 FTR(Formal Technical Review)라고도 불리며, 정형화된 절차와 체크리스트를 사용하여 소프트웨어 산출물의 결함을 찾아내는 방법이다.
이는 정적 테스트 방법 중 가장 많은 인원이 참여하고 가장 공식적인 프로세스를 따른다.
주요 목적 결함 발견: 코드나 문서의 오류를 조기에 식별한다. 품질 향상: 소프트웨어 산출물의 전반적인 품질을 개선한다. 프로세스 개선: 개발 프로세스의 문제점을 파악하고 개선한다. 인스펙션 대상 인스펙션은 다음과 같은 소프트웨어 산출물에 적용된다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:08:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inspection" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/inspection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Peer Review</h2></header><div class=entry-content><p>Peer Review Peer Review는 소프트웨어 개발 과정에서 중요한 품질 보증 활동으로, 동료 개발자들이 서로의 코드나 문서를 검토하여 오류를 찾고 개선점을 제시하는 과정이다.
코드 리뷰가 중요한 이유는 여러 가지가 있다.
버그나 보안 취약점을 조기에 발견할 수 있다. 코드의 일관성과 유지보수성을 높일 수 있다. 팀 전체의 기술력 향상에 도움이 된다. 한 명의 실수나 실수를 하기 쉬운 부분을 여러 사람이 검토함으로써, 더 높은 품질의 코드를 만들 수 있다. Peer Review의 목적 오류 가능성 발견 및 해결 소프트웨어 품질 향상 개발자 스킬 향상 팀 내 지식 및 경험 공유 Peer Review의 장점 개발 초기 단계에서 실수 발견 및 수정 가능 전체적인 코드 품질 향상 팀 내 상호 신뢰 및 동기 부여 증진 가독성 높은 코드 작성 촉진 개선된 설계 발견 기회 Peer Review 프로세스 Peer Review는 일반적으로 다음과 같은 단계로 진행된다:
...</p></div><footer class=entry-footer><span title='2024-10-29 15:03:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Peer Review" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/peer-review/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정적 코드 분석 (Static Code analysis)</h2></header><div class=entry-content><p>정적 코드 분석 (Static Code analysis) 정적 코드 분석은 프로그램을 실행하지 않고 소스 코드를 분석하여 잠재적인 결함, 취약점, 코딩 표준 위반 등을 찾아내는 기술이다.
이는 마치 건축가가 건물을 짓기 전에 설계도를 검토하는 것과 유사하다.
코드의 품질과 안정성을 조기에 확보할 수 있다는 점에서 매우 중요한 기술이다.
특징 실행 없이 분석: 프로그램을 실행하지 않고 소스 코드만을 검사한다. 자동화: 대부분의 정적 분석 도구는 자동화되어 있어 빠른 분석이 가능하다. 조기 발견: 개발 초기 단계에서 문제점을 식별할 수 있다. 분석 기법 정적 코드 분석에는 다양한 기법이 사용된다:
...</p></div><footer class=entry-footer><span title='2024-10-29 06:06:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정적 코드 분석 (Static Code analysis)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/static-analysis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Formal Methods Model</h2></header><div class=entry-content><p>포멀 메소드 모델 (Formal Methods Model) 소프트웨어 개발에서 수학적 기법을 사용하여 시스템을 명세, 개발, 분석 및 검증하는 엄격한 접근 방식
소프트웨어의 정확성, 신뢰성 및 안전성을 보장하는 데 중점을 둔다.
특징 수학적 기반: 집합론, 논리학, 대수학 등의 수학적 기법을 사용 명확성과 정확성: 모호함을 제거하고 요구사항을 정확하게 명세 검증 가능성: 수학적 증명을 통해 시스템의 특성을 검증할 수 있다 추상화: 복잡한 시스템을 추상적으로 표현하여 이해와 분석을 용이하게 한다. 주요 기법 명세 언어: Z 표기법, B 메소드, Event-B 등의 형식적 명세 언어를 사용한다. 정리 증명: Coq, Isabelle 등의 도구를 사용하여 시스템 속성을 수학적으로 증명한다. 모델 검사: SPIN과 같은 도구를 사용하여 시스템의 모든 가능한 상태를 검사한다. 추상 해석: Frama-C와 같은 도구를 사용하여 프로그램의 런타임 오류 부재 등을 검증한다. 단점 높은 전문성 요구: 수학적 지식과 형식적 방법에 대한 이해가 필요하다. 시간과 비용: 초기 개발 단계에서 추가적인 노력과 비용이 필요할 수 있다 규모의 한계: 대규모 시스템에 적용하기 어려울 수 있다 적합한 프로젝트 유형 안전 중요 시스템, 보안 중요 시스템, 그리고 고신뢰성이 요구되는 소프트웨어 개발에 적합
...</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Formal Methods Model" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/formal-methods/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>