<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CI vs. CD vs. CD | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,CI-CD,CI-CD-Fundamentals"><meta name=description content="CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="CI vs. CD vs. CD"><meta property="og:description" content="CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T01:43:00+00:00"><meta property="article:modified_time" content="2024-10-02T01:43:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="CI-CD"><meta property="article:tag" content="CI-CD-Fundamentals"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="CI vs. CD vs. CD"><meta name=twitter:description content="CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"CI vs. CD vs. CD","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CI vs. CD vs. CD","name":"CI vs. CD vs. CD","description":"CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다.","keywords":["DevOps-and-Infrastructure","CI-CD","CI-CD-Fundamentals"],"articleBody":"CI(지속적 통합) Vs. CD(지속적 전달) vs. CD(지속적 배포) CI/CD 는 현대 소프트웨어 개발 방법론의 핵심으로, 개발 과정을 자동화하고 신속하게 가치를 전달하는 데 중점을 둔다. 지속적 통합 (CI) 은 개발자가 코드 변경 사항을 자주 통합하고 검증하는 과정을 말하며, 지속적 전달 (CD) 은 검증된 코드를 자동으로 프로덕션 환경에 배포 가능한 상태로 준비하는 과정을, 지속적 배포 (CD) 는 검증된 코드를 자동으로 프로덕션 환경에 배포하는 과정을, 각각 자동화하는 방법론이다. 이 세 가지 접근 방식의 주요 차이점은 코드 변경 사항이 프로덕션 환경에 도달하는 자동화 수준과 사람의 개입 정도에 있다. CI/CD 파이프라인은 코드 품질 향상, 출시 주기 단축, 팀 협업 강화 등 다양한 이점을 제공하며, 최신 트렌드로는 GitOps, AIOps, 보안 통합 (DevSecOps) 등이 있다.\n핵심 개념 CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 는 서로 연결된 개념이지만 각각 다른 목표와 특성을 가지고 있다.\n구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 정의 개발자들이 코드 변경사항을 메인 브랜치에 자주 (하루에 여러 번) 통합하는 방식 소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하는 방법론 개발자의 변경사항이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식 핵심 프로세스 코드 변경, 빌드, 테스트 CI + 자동 배포 (스테이징 환경까지) CI + CD(전달) + 자동 프로덕션 배포 종료 시점 테스트 단계 완료 후 프로덕션 배포 준비 완료 후 (수동 승인 필요) 프로덕션 환경 배포 완료 후 자동화 범위 통합, 빌드, 테스트 통합, 빌드, 테스트, 배포 준비 전체 파이프라인 (통합부터 프로덕션 배포까지) 주요 원리 CI/CD 의 주요 원리는 소프트웨어 개발 과정을 효율적이고 안정적으로 만들기 위한 핵심 개념:\n원칙 항목 설명 자동화 우선 (Automation First) 수동 개입을 최소화하고, 빌드·테스트·배포 등 반복 가능한 작업을 자동화하여 일관성 확보 빠른 피드백 루프 (Fast Feedback Loop) 코드 변경 후 즉시 피드백을 제공함으로써 문제를 조기에 발견하고 빠르게 수정 가능 작은 단위의 변경 (Small Batch Changes) 큰 기능보다는 작은 단위의 변경을 자주 배포하여 오류 범위 최소화 및 배포 안정성 향상 재현 가능한 환경 (Reproducible Environments) 개발/테스트/운영 환경 간 설정 차이를 제거하고, 인프라를 코드 (IaC) 로 일관되게 관리 가시성과 투명성 (Visibility \u0026 Transparency) 파이프라인 실행 상태, 실패 내역 등을 실시간으로 공유하고 전체 프로세스를 투명하게 관리 3.4 작동 원리 CI/CD 파이프라인의 작동 원리를 각 단계별로 살펴보면:\nCI(지속적 통합) 워크플로우:\n개발자가 코드 변경 사항을 소스 코드 저장소에 푸시 CI 서버가 코드 변경을 감지하고 자동으로 빌드 프로세스 시작 코드 컴파일 및 기본 문법 검사 수행 단위 테스트 및 통합 테스트 실행 코드 품질 및 보안 검사 수행 빌드 결과 및 테스트 보고서 생성 성공/실패 상태를 개발팀에 알림 CD(지속적 전달) 워크플로우:\nCI 단계를 성공적으로 통과한 코드를 대상으로 진행 테스트 환경에 자동 배포하여 심층 테스트 진행 성능 테스트, 부하 테스트, UI 테스트 등 실행 테스트 환경에서 검증 후 스테이징 환경으로 자동 승격 스테이징 환경에서 최종 검증 수행 프로덕션 배포 준비 완료 상태로 설정 배포 승인 요청 알림 발송 (수동 승인 단계) CD(지속적 배포) 워크플로우:\nCD(지속적 전달) 단계를 모두 통과한 코드 처리 자동화된 기준에 따라 프로덕션 배포 결정 (또는 자동 승인) 프로덕션 환경에 자동 배포 (블루/그린, 카나리, 롤링 등 전략 적용) 배포 후 자동 검증 테스트 실행 실시간 모니터링 및 성능 지표 수집 문제 발생 시 자동 롤백 또는 알림 트리거 배포 완료 및 성공 메트릭 수집 구성 요소 및 아키텍처 CI/CD 파이프라인은 소프트웨어 개발의 여러 단계를 자동화하는 통합 시스템이다. 각 단계별 주요 구성 요소와 역할은 다음과 같다:\n구성 요소 역할 도구 예시 주요 기능 소스 코드 관리 시스템 코드 버전 및 변경 사항 관리, 협업 지원 Git, SVN, Mercurial 브랜치 관리, 병합, 롤백, 이력 추적 빌드 서버 / CI 서버 자동 빌드, 테스트 실행, 빌드 상태 리포트 제공 Jenkins, GitHub Actions, GitLab CI/CD, CircleCI 자동 트리거, 병렬 빌드, 상태 알림 테스트 환경 다양한 테스트 수행을 위한 격리된 실행 환경 제공 (프레임워크에 따라 구성) 단위/통합/UI 테스트, 커버리지 측정, 품질 게이트 아티팩트 저장소 빌드 산출물 저장 및 배포 이력 관리 Nexus, Artifactory, Docker Registry 패키지 관리, 버전 추적, 의존성 제공 환경 구성 관리 인프라 구성 및 환경 자동화 관리 Ansible, Terraform, Puppet, Chef IaC, 환경 일관성 유지, 자동 프로비저닝 배포 자동화 도구 스테이징/운영 환경으로의 배포 자동화 Spinnaker, ArgoCD, Octopus Deploy 블루/그린 배포, 카나리 릴리스, 롤링 업데이트 모니터링 및 피드백 시스템 배포 상태 및 성능 모니터링, 피드백 수집 Prometheus, Grafana, New Relic, Datadog 실시간 대시보드, 경고, 자동 롤백 트리거 보안 검증 도구 코드 및 종속성 보안 분석, 컴플라이언스 검증 SonarQube, Snyk, OWASP ZAP 정적/동적 분석, 취약점 탐지, 라이선스 검토 CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 비교 CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 는 서로 연결된 개념이며, 점진적으로 자동화 수준을 높여가는 발전 단계로 볼 수 있다.\nCI(지속적 통합) 는 코드 변경사항을 빈번하게 메인 브랜치에 병합하고 자동 테스트하는 데 중점을 두며, CD(지속적 전달) 는 CI(지속적 통합) 를 포함하면서 테스트부터 스테이징 환경까지의 배포 과정을 자동화한다.\n가장 큰 차이점은 CI 는 코드 통합과 검증에 중점을 두는 반면, CD(전달) 는 배포 준비 상태를 자동화한다는 점이다.\nCD(지속적 전달) 는 배포 준비 상태까지 자동화하지만 프로덕션 배포는 수동 승인이 필요하며, CD(지속적 배포) 는 전체 과정 (개발부터 프로덕션까지) 을 완전 자동화하여 인간의 개입 없이 변경사항이 프로덕션에 배포된다.\n핵심 차이점은 프로덕션 배포에 대한 수동 승인의 유무이다.\n목적 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 주요 목적 코드 품질 보장과 통합 문제 조기 발견 신뢰할 수 있는 소프트웨어 릴리즈 프로세스 구축 개발 주기 가속화 및 사용자에게 신속한 가치 전달 해결 문제 통합 지옥 (Integration Hell) 방지 복잡한 수동 배포 프로세스 개선 배포 지연 및 수동 프로세스 제거 관점 코드 품질 배포 준비성 배포 속도 및 자동화 배포 결정 기술적 검증에 중점 비즈니스 결정에 중점 자동화된 검증에 중점 필요성 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 비즈니스 니즈 안정적인 소프트웨어 기반 확립 안정적이고 예측 가능한 릴리즈 주기 확립 시장 변화에 신속 대응 및 사용자 피드백 빠른 반영 팀 협업 측면 개발자 간 코드 충돌 최소화 개발팀과 운영팀 간 협업 강화 개발 - 운영 - 비즈니스 간 끊김 없는 워크플로우 품질 관리 측면 지속적인 코드 검증으로 버그 조기 발견 안정적인 릴리즈 품질 보장 작은 변경 단위의 배포로 위험 감소 현대적 요구 복잡한 소프트웨어의 안정적 개발 다양한 환경에서의 일관된 배포 지속적인 가치 제공 및 경쟁 우위 확보 주요 기능 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 자동화 기능 코드 통합, 빌드, 기본 테스트 CI + 심화 테스트, 환경 구성, 배포 준비 CD(전달) + 프로덕션 배포, 모니터링 테스트 범위 단위 테스트, 통합 테스트 단위/통합 테스트, 회귀 테스트, 성능 테스트 전체 테스트 스위트 + 카나리 테스트, A/B 테스트 보고 기능 빌드 및 테스트 결과 보고 배포 준비 상태 및 환경 품질 보고 배포 성공/실패, 사용자 영향 분석 보고 알림 체계 빌드 실패 알림 배포 준비 완료 및 승인 요청 알림 배포 성공/실패 및 성능 이슈 알림 역할 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 개발자 역할 코드 작성, 로컬 테스트, 빈번한 코드 통합 배포 가능한 품질의 코드 작성, 배포 스크립트 개발 프로덕션 중심 개발, 모니터링 코드 작성 운영팀 역할 CI 파이프라인 구축 지원 환경 구성, 배포 자동화 과정 관리 파이프라인 모니터링, 롤백 전략 수립 QA 팀 역할 자동화된 테스트 작성 지원 고급 테스트 전략 수립, 품질 게이트 정의 프로덕션 환경 모니터링, 사용자 경험 검증 비즈니스 역할 개발 진행 상황 추적 릴리즈 일정 및 기능 결정 실시간 사용자 피드백 분석 및 우선순위 결정 특징 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 배포 빈도 해당 없음 (배포 단계 없음) 필요에 따라 (일반적으로 주간, 격주간) 매우 빈번 (일일, 수시간마다) 변경 규모 작은 단위의 코드 통합 기능 중심 배포 번들 매우 작은 단위의 개별 변경사항 위험 수준 낮음 (프로덕션에 영향 없음) 중간 (통제된 배포 과정) 높음 (완전 자동화된 프로덕션 배포) 피드백 루프 개발자 중심 (코드 품질) 팀 중심 (릴리즈 준비성) 사용자 중심 (실제 가치 및 영향) 핵심 원칙 구분 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 개발 방식 작은 변경 단위, 잦은 커밋 항상 배포 가능한 상태 유지 지속적 가치 전달 자동화 중점 테스트 자동화 배포 프로세스 자동화 전체 배포 파이프라인 자동화 품질 관리 빠른 피드백, 조기 문제 발견 일관된 테스트, 다양한 환경 검증 프로덕션 중심 개발, 실시간 모니터링 중심 가치 통합 문제 최소화 릴리즈 과정 최적화 지속적 가치 전달 및 실험 추가 비교 분석 비교 측면 CI(지속적 통합) CD(지속적 전달) CD(지속적 배포) 도입 복잡성 낮음 - 기존 개발 워크플로우에 상대적으로 쉽게 통합 중간 - 다양한 환경 구성 및 테스트 자동화 필요 높음 - 고수준의 자동화, 모니터링, 롤백 전략 필요 팀 구조 영향 개발 중심 - 개발자 워크플로우에 집중 개발 - 운영 협업 - DevOps 문화 필요 전체 조직 변화 - 비즈니스, 개발, 운영 통합 필요 피드백 지연 수분 - 수시간 (빌드/테스트 결과) 수시간 - 수일 (환경 배포 결과) 수분 - 수시간 (프로덕션 영향) 장애 복구 시간 해당 없음 (프로덕션 영향 없음) 중간 - 수동 개입 필요할 수 있음 빠름 - 자동화된 감지 및 롤백 적합한 조직 규모 모든 규모 (소규모 팀에서도 쉽게 도입) 중소 - 대규모 (환경 관리 리소스 필요) 중간 - 대규모 (성숙한 DevOps 문화 필요) 비용 구조 낮음 - 중간 (CI 서버, 테스트 환경) 중간 (다중 환경, 테스트 인프라) 높음 (고급 도구, 모니터링, 훈련) 위험 관리 접근법 코드 품질 중심 - 빌드/테스트 실패 방지 환경 검증 중심 - 단계적 승격 점진적 노출 - 카나리/블루 - 그린 배포 적합한 애플리케이션 유형 모든 유형 대부분의 웹/모바일 애플리케이션 웹 서비스, SaaS, 마이크로서비스 규제 환경 적합성 높음 - 기본 품질 관리로 적합 매우 높음 - 감사 및 승인 프로세스 지원 중간 - 낮음 - 자동 배포가 규제와 충돌할 수 있음 확장성 높음 - 코드베이스/팀 성장에 쉽게 적응 중간 - 환경 증가에 따른 복잡성 중간 - 대규모 시스템에 추가 조정 필요 모니터링 요구사항 기본 (빌드/테스트 상태) 중간 (환경 상태, 배포 준비도) 고급 (실시간 성능, 사용자 영향, 롤백 트리거) 문화적 요구사항 협업 및 코드 품질 중심 DevOps 협업, 배포 규율 높은 자율성, 책임감, 실험 문화 장단점 비교 구분 ✅ 장점 ⚠ 단점 CI 조기 버그 발견, 협업 효율화 테스트 커버리지 확보 필요 CD(전달) 릴리스 유연성, 안정성 강화 수동 승인 지연 가능성 CD(배포) 배포 주기 최소화, 피드백 신속화 자동화 실패 시 프로덕션 장애 리스크 최신 동향 주제 항목 설명 AI/ML 통합 예측 테스트 실패 가능성 높은 테스트 케이스 우선 실행 GitOps 코드 기반 인프라 Terraform 으로 Kubernetes 환경 자동 관리. DevSecOps 보안 내재화 파이프라인 내 자동 보안 스캔 (SAST/DAST). 주목할 기술 기술 설명 자가 치유 파이프라인 AI 기반 장애 복구 시스템 Low-Code CI/CD 비개발자 참여 가능한 시각화 도구 추가 학습 내용 카테고리 핵심 학습 주제 설명 도구 및 기술 CI/CD 도구 비교 Jenkins, GitHub Actions, GitLab CI/CD, CircleCI, ArgoCD, Spinnaker 등 주요 도구의 특징과 사용 사례 컨테이너 및 오케스트레이션 Docker, Kubernetes, 헬름과 CI/CD 통합 방법 인프라스트럭처 코드 (IaC) Terraform, Ansible, CloudFormation 등을 CI/CD 파이프라인에 통합하는 방법 파이프라인 설계 파이프라인 아키텍처 패턴 단일 파이프라인 vs 다중 파이프라인, 모노레포 vs 멀티레포 전략 파이프라인 성능 최적화 빌드/테스트 병렬화, 캐싱 전략, 리소스 최적화 파이프라인 보안 보안 스캔 통합, 시크릿 관리, RBAC(역할 기반 접근 제어) 배포 전략 현대적 배포 패턴 블루 - 그린, 카나리, 롤링, A/B 테스트 배포 전략 상세 이해 특성 플래그 (Feature Flags) 배포와 릴리스 분리, 점진적 기능 출시, 실험 설계 데이터베이스 스키마 변경 관리 무중단 데이터베이스 마이그레이션 전략 품질 보증 테스트 자동화 전략 테스트 피라미드, 테스트 유형별 자동화 접근법 테스트 데이터 관리 테스트를 위한 데이터 준비, 가상화, 비식별화 계약 테스트 마이크로서비스 간 인터페이스 검증 방법 모니터링 및 관측성 관측성 3 대 요소 메트릭, 로그, 트레이스의 CI/CD 통합 CI/CD 메트릭 DORA 메트릭, 파이프라인 성능 지표, 배포 성공률 사용자 경험 모니터링 실제 사용자 모니터링 (RUM), 합성 모니터링 통합 문화 및 프로세스 DevOps 문화 구축 협업, 책임 공유, 지속적 개선 문화 조성 장애 관리 사후 분석, 학습 문화, 회복력 설계 변경 관리 CI/CD 와 ITIL/ITSM 프로세스 조화 클라우드 네이티브 서버리스 CI/CD AWS Lambda, Google Cloud Functions 기반 CI/CD 멀티클라우드 전략 다중 클라우드 환경에서의 일관된 CI/CD 에지 컴퓨팅 CI/CD 에지 디바이스 및 분산 시스템 CI/CD 고급 주제 GitOps Git 중심 인프라 및 애플리케이션 관리 AIOps 와 CI/CD AI 기반 배포 최적화 및 문제 예측 DevSecOps 보안 중심 CI/CD 파이프라인 설계 용어 정리 용어 설명 CI(Continuous Integration) 개발자들이 코드 변경사항을 메인 브랜치에 자주 통합하고 자동으로 빌드 및 테스트하는 소프트웨어 개발 방식 CD(Continuous Delivery) 소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하도록 자동화하는 방법론 CD(Continuous Deployment) 코드 변경이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식 파이프라인 (Pipeline) 코드 변경부터 프로덕션 배포까지 일련의 자동화된 단계 아티팩트 (Artifact) CI/CD 과정에서 생성된 배포 가능한 소프트웨어 패키지 IaC(Infrastructure as Code) 인프라스트럭처 구성을 코드로 관리하는 방식 카나리 배포 (Canary Deployment) 일부 사용자에게만 새 버전을 배포하여 위험을 최소화하는 전략 블루 - 그린 배포 (Blue-Green Deployment) 두 개의 동일한 프로덕션 환경을 번갈아 가며 배포하는 전략 롤링 배포 (Rolling Deployment) 서비스 중단 없이 점진적으로 새 버전을 배포하는 전략 특성 플래그 (Feature Flag) 배포와 릴리스를 분리하여 코드 활성화를 제어하는 기술 GitOps Git 을 중심으로 인프라와 애플리케이션 배포를 관리하는 방식 DevSecOps 개발, 보안, 운영을 통합하여 보안을 파이프라인에 내장하는 접근법 DORA 메트릭 배포 빈도, 변경 적용 시간, 복구 시간, 변경 실패율을 측정하는 지표 AIOps AI 기술을 활용한 IT 운영 자동화 및 최적화 관측성 (Observability) 시스템의 내부 상태를 외부 출력으로 이해할 수 있는 능력 참고 및 출처 GitLab CI/CD 개요 Jenkins 파이프라인 설명 AWS CodePipeline 아키텍처 Atlassian CI/CD 원칙 The New Stack: CI/CD 2025 동향 Atlassian: CI vs CD AWS: CI 설명 2025 CI/CD 트렌드(LinkedIn) CI/CD 파이프라인 구축 가이드 GitLab CI/CD 문서 GitHub Actions 문서 Jenkins 공식 문서 AWS DevOps 모범 사례 DORA - Google 클라우드 DevOps 연구 Kubernetes CD 도구 비교 DevSecOps 통합 가이드 GitOps 원칙 12 Factor App 방법론 ","wordCount":"2096","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-02T01:43:00Z","dateModified":"2024-10-02T01:43:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">CI vs. CD vs. CD</h1><div class=post-description>CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다.</div><div class=post-meta><span title='2024-10-02 01:43:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/DevOps%20and%20Infrastructure/CI-CD/CI-CD%20Fundamentals/ci-vs-cd-vs-cd.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#ci지속적-통합-vs-cd지속적-전달-vs-cd지속적-배포>CI(지속적 통합) Vs. CD(지속적 전달) vs. CD(지속적 배포)</a><ul><li><a href=#핵심-개념><strong>핵심 개념</strong></a></li><li><a href=#주요-원리>주요 원리</a></li><li><a href=#34-작동-원리>3.4 작동 원리</a></li><li><a href=#구성-요소-및-아키텍처>구성 요소 및 아키텍처</a></li><li><a href=#ci지속적-통합-cd지속적-전달-cd지속적-배포-비교>CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 비교</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#주목할-기술>주목할 기술</a></li><li><a href=#추가-학습-내용>추가 학습 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=ci지속적-통합-vs-cd지속적-전달-vs-cd지속적-배포>CI(지속적 통합) Vs. CD(지속적 전달) vs. CD(지속적 배포)<a hidden class=anchor aria-hidden=true href=#ci지속적-통합-vs-cd지속적-전달-vs-cd지속적-배포>#</a></h2><p>CI/CD 는 현대 소프트웨어 개발 방법론의 핵심으로, 개발 과정을 자동화하고 신속하게 가치를 전달하는 데 중점을 둔다. 지속적 통합 (CI) 은 개발자가 코드 변경 사항을 자주 통합하고 검증하는 과정을 말하며, 지속적 전달 (CD) 은 검증된 코드를 자동으로 프로덕션 환경에 배포 가능한 상태로 준비하는 과정을, 지속적 배포 (CD) 는 검증된 코드를 자동으로 프로덕션 환경에 배포하는 과정을, 각각 자동화하는 방법론이다. 이 세 가지 접근 방식의 주요 차이점은 코드 변경 사항이 프로덕션 환경에 도달하는 자동화 수준과 사람의 개입 정도에 있다. CI/CD 파이프라인은 코드 품질 향상, 출시 주기 단축, 팀 협업 강화 등 다양한 이점을 제공하며, 최신 트렌드로는 GitOps, AIOps, 보안 통합 (DevSecOps) 등이 있다.</p><h3 id=핵심-개념><strong>핵심 개념</strong><a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 는 서로 연결된 개념이지만 각각 다른 목표와 특성을 가지고 있다.</p><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>정의</td><td>개발자들이 코드 변경사항을 메인 브랜치에 자주 (하루에 여러 번) 통합하는 방식</td><td>소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하는 방법론</td><td>개발자의 변경사항이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식</td></tr><tr><td>핵심 프로세스</td><td>코드 변경, 빌드, 테스트</td><td>CI + 자동 배포 (스테이징 환경까지)</td><td>CI + CD(전달) + 자동 프로덕션 배포</td></tr><tr><td>종료 시점</td><td>테스트 단계 완료 후</td><td>프로덕션 배포 준비 완료 후 (수동 승인 필요)</td><td>프로덕션 환경 배포 완료 후</td></tr><tr><td>자동화 범위</td><td>통합, 빌드, 테스트</td><td>통합, 빌드, 테스트, 배포 준비</td><td>전체 파이프라인 (통합부터 프로덕션 배포까지)</td></tr></tbody></table><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><p>CI/CD 의 주요 원리는 소프트웨어 개발 과정을 효율적이고 안정적으로 만들기 위한 핵심 개념:</p><table><thead><tr><th>원칙 항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>자동화 우선 (Automation First)</strong></td><td>수동 개입을 최소화하고, 빌드·테스트·배포 등 반복 가능한 작업을 자동화하여 일관성 확보</td></tr><tr><td><strong>빠른 피드백 루프 (Fast Feedback Loop)</strong></td><td>코드 변경 후 즉시 피드백을 제공함으로써 문제를 조기에 발견하고 빠르게 수정 가능</td></tr><tr><td><strong>작은 단위의 변경 (Small Batch Changes)</strong></td><td>큰 기능보다는 작은 단위의 변경을 자주 배포하여 오류 범위 최소화 및 배포 안정성 향상</td></tr><tr><td><strong>재현 가능한 환경 (Reproducible Environments)</strong></td><td>개발/테스트/운영 환경 간 설정 차이를 제거하고, 인프라를 코드 (IaC) 로 일관되게 관리</td></tr><tr><td><strong>가시성과 투명성 (Visibility & Transparency)</strong></td><td>파이프라인 실행 상태, 실패 내역 등을 실시간으로 공유하고 전체 프로세스를 투명하게 관리</td></tr></tbody></table><h3 id=34-작동-원리>3.4 작동 원리<a hidden class=anchor aria-hidden=true href=#34-작동-원리>#</a></h3><p>CI/CD 파이프라인의 작동 원리를 각 단계별로 살펴보면:</p><p><strong>CI(지속적 통합) 워크플로우:</strong></p><ol><li>개발자가 코드 변경 사항을 소스 코드 저장소에 푸시</li><li>CI 서버가 코드 변경을 감지하고 자동으로 빌드 프로세스 시작</li><li>코드 컴파일 및 기본 문법 검사 수행</li><li>단위 테스트 및 통합 테스트 실행</li><li>코드 품질 및 보안 검사 수행</li><li>빌드 결과 및 테스트 보고서 생성</li><li>성공/실패 상태를 개발팀에 알림</li></ol><p><strong>CD(지속적 전달) 워크플로우:</strong></p><ol><li>CI 단계를 성공적으로 통과한 코드를 대상으로 진행</li><li>테스트 환경에 자동 배포하여 심층 테스트 진행</li><li>성능 테스트, 부하 테스트, UI 테스트 등 실행</li><li>테스트 환경에서 검증 후 스테이징 환경으로 자동 승격</li><li>스테이징 환경에서 최종 검증 수행</li><li>프로덕션 배포 준비 완료 상태로 설정</li><li>배포 승인 요청 알림 발송 (수동 승인 단계)</li></ol><p><strong>CD(지속적 배포) 워크플로우:</strong></p><ol><li>CD(지속적 전달) 단계를 모두 통과한 코드 처리</li><li>자동화된 기준에 따라 프로덕션 배포 결정 (또는 자동 승인)</li><li>프로덕션 환경에 자동 배포 (블루/그린, 카나리, 롤링 등 전략 적용)</li><li>배포 후 자동 검증 테스트 실행</li><li>실시간 모니터링 및 성능 지표 수집</li><li>문제 발생 시 자동 롤백 또는 알림 트리거</li><li>배포 완료 및 성공 메트릭 수집</li></ol><h3 id=구성-요소-및-아키텍처>구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-요소-및-아키텍처>#</a></h3><p>CI/CD 파이프라인은 소프트웨어 개발의 여러 단계를 자동화하는 통합 시스템이다. 각 단계별 주요 구성 요소와 역할은 다음과 같다:</p><table><thead><tr><th>구성 요소</th><th>역할</th><th>도구 예시</th><th>주요 기능</th></tr></thead><tbody><tr><td><strong>소스 코드 관리 시스템</strong></td><td>코드 버전 및 변경 사항 관리, 협업 지원</td><td>Git, SVN, Mercurial</td><td>브랜치 관리, 병합, 롤백, 이력 추적</td></tr><tr><td><strong>빌드 서버 / CI 서버</strong></td><td>자동 빌드, 테스트 실행, 빌드 상태 리포트 제공</td><td>Jenkins, GitHub Actions, GitLab CI/CD, CircleCI</td><td>자동 트리거, 병렬 빌드, 상태 알림</td></tr><tr><td><strong>테스트 환경</strong></td><td>다양한 테스트 수행을 위한 격리된 실행 환경 제공</td><td>(프레임워크에 따라 구성)</td><td>단위/통합/UI 테스트, 커버리지 측정, 품질 게이트</td></tr><tr><td><strong>아티팩트 저장소</strong></td><td>빌드 산출물 저장 및 배포 이력 관리</td><td>Nexus, Artifactory, Docker Registry</td><td>패키지 관리, 버전 추적, 의존성 제공</td></tr><tr><td><strong>환경 구성 관리</strong></td><td>인프라 구성 및 환경 자동화 관리</td><td>Ansible, Terraform, Puppet, Chef</td><td>IaC, 환경 일관성 유지, 자동 프로비저닝</td></tr><tr><td><strong>배포 자동화 도구</strong></td><td>스테이징/운영 환경으로의 배포 자동화</td><td>Spinnaker, ArgoCD, Octopus Deploy</td><td>블루/그린 배포, 카나리 릴리스, 롤링 업데이트</td></tr><tr><td><strong>모니터링 및 피드백 시스템</strong></td><td>배포 상태 및 성능 모니터링, 피드백 수집</td><td>Prometheus, Grafana, New Relic, Datadog</td><td>실시간 대시보드, 경고, 자동 롤백 트리거</td></tr><tr><td><strong>보안 검증 도구</strong></td><td>코드 및 종속성 보안 분석, 컴플라이언스 검증</td><td>SonarQube, Snyk, OWASP ZAP</td><td>정적/동적 분석, 취약점 탐지, 라이선스 검토</td></tr></tbody></table><h3 id=ci지속적-통합-cd지속적-전달-cd지속적-배포-비교>CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 비교<a hidden class=anchor aria-hidden=true href=#ci지속적-통합-cd지속적-전달-cd지속적-배포-비교>#</a></h3><p>CI(지속적 통합), CD(지속적 전달), CD(지속적 배포) 는 서로 연결된 개념이며, 점진적으로 자동화 수준을 높여가는 발전 단계로 볼 수 있다.</p><p>CI(지속적 통합) 는 코드 변경사항을 빈번하게 메인 브랜치에 병합하고 자동 테스트하는 데 중점을 두며, CD(지속적 전달) 는 CI(지속적 통합) 를 포함하면서 테스트부터 스테이징 환경까지의 배포 과정을 자동화한다.<br>가장 큰 차이점은 CI 는 코드 통합과 검증에 중점을 두는 반면, CD(전달) 는 배포 준비 상태를 자동화한다는 점이다.</p><p>CD(지속적 전달) 는 배포 준비 상태까지 자동화하지만 프로덕션 배포는 수동 승인이 필요하며, CD(지속적 배포) 는 전체 과정 (개발부터 프로덕션까지) 을 완전 자동화하여 인간의 개입 없이 변경사항이 프로덕션에 배포된다.<br>핵심 차이점은 프로덕션 배포에 대한 수동 승인의 유무이다.</p><h4 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>주요 목적</td><td>코드 품질 보장과 통합 문제 조기 발견</td><td>신뢰할 수 있는 소프트웨어 릴리즈 프로세스 구축</td><td>개발 주기 가속화 및 사용자에게 신속한 가치 전달</td></tr><tr><td>해결 문제</td><td>통합 지옥 (Integration Hell) 방지</td><td>복잡한 수동 배포 프로세스 개선</td><td>배포 지연 및 수동 프로세스 제거</td></tr><tr><td>관점</td><td>코드 품질</td><td>배포 준비성</td><td>배포 속도 및 자동화</td></tr><tr><td>배포 결정</td><td>기술적 검증에 중점</td><td>비즈니스 결정에 중점</td><td>자동화된 검증에 중점</td></tr></tbody></table><h4 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>비즈니스 니즈</td><td>안정적인 소프트웨어 기반 확립</td><td>안정적이고 예측 가능한 릴리즈 주기 확립</td><td>시장 변화에 신속 대응 및 사용자 피드백 빠른 반영</td></tr><tr><td>팀 협업 측면</td><td>개발자 간 코드 충돌 최소화</td><td>개발팀과 운영팀 간 협업 강화</td><td>개발 - 운영 - 비즈니스 간 끊김 없는 워크플로우</td></tr><tr><td>품질 관리 측면</td><td>지속적인 코드 검증으로 버그 조기 발견</td><td>안정적인 릴리즈 품질 보장</td><td>작은 변경 단위의 배포로 위험 감소</td></tr><tr><td>현대적 요구</td><td>복잡한 소프트웨어의 안정적 개발</td><td>다양한 환경에서의 일관된 배포</td><td>지속적인 가치 제공 및 경쟁 우위 확보</td></tr></tbody></table><h4 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>자동화 기능</td><td>코드 통합, 빌드, 기본 테스트</td><td>CI + 심화 테스트, 환경 구성, 배포 준비</td><td>CD(전달) + 프로덕션 배포, 모니터링</td></tr><tr><td>테스트 범위</td><td>단위 테스트, 통합 테스트</td><td>단위/통합 테스트, 회귀 테스트, 성능 테스트</td><td>전체 테스트 스위트 + 카나리 테스트, A/B 테스트</td></tr><tr><td>보고 기능</td><td>빌드 및 테스트 결과 보고</td><td>배포 준비 상태 및 환경 품질 보고</td><td>배포 성공/실패, 사용자 영향 분석 보고</td></tr><tr><td>알림 체계</td><td>빌드 실패 알림</td><td>배포 준비 완료 및 승인 요청 알림</td><td>배포 성공/실패 및 성능 이슈 알림</td></tr></tbody></table><h4 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>개발자 역할</td><td>코드 작성, 로컬 테스트, 빈번한 코드 통합</td><td>배포 가능한 품질의 코드 작성, 배포 스크립트 개발</td><td>프로덕션 중심 개발, 모니터링 코드 작성</td></tr><tr><td>운영팀 역할</td><td>CI 파이프라인 구축 지원</td><td>환경 구성, 배포 자동화 과정 관리</td><td>파이프라인 모니터링, 롤백 전략 수립</td></tr><tr><td>QA 팀 역할</td><td>자동화된 테스트 작성 지원</td><td>고급 테스트 전략 수립, 품질 게이트 정의</td><td>프로덕션 환경 모니터링, 사용자 경험 검증</td></tr><tr><td>비즈니스 역할</td><td>개발 진행 상황 추적</td><td>릴리즈 일정 및 기능 결정</td><td>실시간 사용자 피드백 분석 및 우선순위 결정</td></tr></tbody></table><h4 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>배포 빈도</td><td>해당 없음 (배포 단계 없음)</td><td>필요에 따라 (일반적으로 주간, 격주간)</td><td>매우 빈번 (일일, 수시간마다)</td></tr><tr><td>변경 규모</td><td>작은 단위의 코드 통합</td><td>기능 중심 배포 번들</td><td>매우 작은 단위의 개별 변경사항</td></tr><tr><td>위험 수준</td><td>낮음 (프로덕션에 영향 없음)</td><td>중간 (통제된 배포 과정)</td><td>높음 (완전 자동화된 프로덕션 배포)</td></tr><tr><td>피드백 루프</td><td>개발자 중심 (코드 품질)</td><td>팀 중심 (릴리즈 준비성)</td><td>사용자 중심 (실제 가치 및 영향)</td></tr></tbody></table><h4 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h4><table><thead><tr><th>구분</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td>개발 방식</td><td>작은 변경 단위, 잦은 커밋</td><td>항상 배포 가능한 상태 유지</td><td>지속적 가치 전달</td></tr><tr><td>자동화 중점</td><td>테스트 자동화</td><td>배포 프로세스 자동화</td><td>전체 배포 파이프라인 자동화</td></tr><tr><td>품질 관리</td><td>빠른 피드백, 조기 문제 발견</td><td>일관된 테스트, 다양한 환경 검증</td><td>프로덕션 중심 개발, 실시간 모니터링</td></tr><tr><td>중심 가치</td><td>통합 문제 최소화</td><td>릴리즈 과정 최적화</td><td>지속적 가치 전달 및 실험</td></tr></tbody></table><h4 id=추가-비교-분석>추가 비교 분석<a hidden class=anchor aria-hidden=true href=#추가-비교-분석>#</a></h4><table><thead><tr><th>비교 측면</th><th>CI(지속적 통합)</th><th>CD(지속적 전달)</th><th>CD(지속적 배포)</th></tr></thead><tbody><tr><td><strong>도입 복잡성</strong></td><td>낮음 - 기존 개발 워크플로우에 상대적으로 쉽게 통합</td><td>중간 - 다양한 환경 구성 및 테스트 자동화 필요</td><td>높음 - 고수준의 자동화, 모니터링, 롤백 전략 필요</td></tr><tr><td><strong>팀 구조 영향</strong></td><td>개발 중심 - 개발자 워크플로우에 집중</td><td>개발 - 운영 협업 - DevOps 문화 필요</td><td>전체 조직 변화 - 비즈니스, 개발, 운영 통합 필요</td></tr><tr><td><strong>피드백 지연</strong></td><td>수분 - 수시간 (빌드/테스트 결과)</td><td>수시간 - 수일 (환경 배포 결과)</td><td>수분 - 수시간 (프로덕션 영향)</td></tr><tr><td><strong>장애 복구 시간</strong></td><td>해당 없음 (프로덕션 영향 없음)</td><td>중간 - 수동 개입 필요할 수 있음</td><td>빠름 - 자동화된 감지 및 롤백</td></tr><tr><td><strong>적합한 조직 규모</strong></td><td>모든 규모 (소규모 팀에서도 쉽게 도입)</td><td>중소 - 대규모 (환경 관리 리소스 필요)</td><td>중간 - 대규모 (성숙한 DevOps 문화 필요)</td></tr><tr><td><strong>비용 구조</strong></td><td>낮음 - 중간 (CI 서버, 테스트 환경)</td><td>중간 (다중 환경, 테스트 인프라)</td><td>높음 (고급 도구, 모니터링, 훈련)</td></tr><tr><td><strong>위험 관리 접근법</strong></td><td>코드 품질 중심 - 빌드/테스트 실패 방지</td><td>환경 검증 중심 - 단계적 승격</td><td>점진적 노출 - 카나리/블루 - 그린 배포</td></tr><tr><td><strong>적합한 애플리케이션 유형</strong></td><td>모든 유형</td><td>대부분의 웹/모바일 애플리케이션</td><td>웹 서비스, SaaS, 마이크로서비스</td></tr><tr><td><strong>규제 환경 적합성</strong></td><td>높음 - 기본 품질 관리로 적합</td><td>매우 높음 - 감사 및 승인 프로세스 지원</td><td>중간 - 낮음 - 자동 배포가 규제와 충돌할 수 있음</td></tr><tr><td><strong>확장성</strong></td><td>높음 - 코드베이스/팀 성장에 쉽게 적응</td><td>중간 - 환경 증가에 따른 복잡성</td><td>중간 - 대규모 시스템에 추가 조정 필요</td></tr><tr><td><strong>모니터링 요구사항</strong></td><td>기본 (빌드/테스트 상태)</td><td>중간 (환경 상태, 배포 준비도)</td><td>고급 (실시간 성능, 사용자 영향, 롤백 트리거)</td></tr><tr><td><strong>문화적 요구사항</strong></td><td>협업 및 코드 품질 중심</td><td>DevOps 협업, 배포 규율</td><td>높은 자율성, 책임감, 실험 문화</td></tr></tbody></table><h4 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h4><table><thead><tr><th>구분</th><th>✅ 장점</th><th>⚠ 단점</th></tr></thead><tbody><tr><td><strong>CI</strong></td><td>조기 버그 발견, 협업 효율화</td><td>테스트 커버리지 확보 필요</td></tr><tr><td><strong>CD(전달)</strong></td><td>릴리스 유연성, 안정성 강화</td><td>수동 승인 지연 가능성</td></tr><tr><td><strong>CD(배포)</strong></td><td>배포 주기 최소화, 피드백 신속화</td><td>자동화 실패 시 프로덕션 장애 리스크</td></tr></tbody></table><hr><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>AI/ML 통합</strong></td><td>예측 테스트</td><td>실패 가능성 높은 테스트 케이스 우선 실행</td></tr><tr><td><strong>GitOps</strong></td><td>코드 기반 인프라</td><td>Terraform 으로 Kubernetes 환경 자동 관리.</td></tr><tr><td><strong>DevSecOps</strong></td><td>보안 내재화</td><td>파이프라인 내 자동 보안 스캔 (SAST/DAST).</td></tr></tbody></table><h3 id=주목할-기술>주목할 기술<a hidden class=anchor aria-hidden=true href=#주목할-기술>#</a></h3><table><thead><tr><th>기술</th><th>설명</th></tr></thead><tbody><tr><td><strong>자가 치유 파이프라인</strong></td><td>AI 기반 장애 복구 시스템</td></tr><tr><td><strong>Low-Code CI/CD</strong></td><td>비개발자 참여 가능한 시각화 도구</td></tr></tbody></table><hr><h3 id=추가-학습-내용>추가 학습 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>핵심 학습 주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>도구 및 기술</strong></td><td>CI/CD 도구 비교</td><td>Jenkins, GitHub Actions, GitLab CI/CD, CircleCI, ArgoCD, Spinnaker 등 주요 도구의 특징과 사용 사례</td></tr><tr><td></td><td>컨테이너 및 오케스트레이션</td><td>Docker, Kubernetes, 헬름과 CI/CD 통합 방법</td></tr><tr><td></td><td>인프라스트럭처 코드 (IaC)</td><td>Terraform, Ansible, CloudFormation 등을 CI/CD 파이프라인에 통합하는 방법</td></tr><tr><td><strong>파이프라인 설계</strong></td><td>파이프라인 아키텍처 패턴</td><td>단일 파이프라인 vs 다중 파이프라인, 모노레포 vs 멀티레포 전략</td></tr><tr><td></td><td>파이프라인 성능 최적화</td><td>빌드/테스트 병렬화, 캐싱 전략, 리소스 최적화</td></tr><tr><td></td><td>파이프라인 보안</td><td>보안 스캔 통합, 시크릿 관리, RBAC(역할 기반 접근 제어)</td></tr><tr><td><strong>배포 전략</strong></td><td>현대적 배포 패턴</td><td>블루 - 그린, 카나리, 롤링, A/B 테스트 배포 전략 상세 이해</td></tr><tr><td></td><td>특성 플래그 (Feature Flags)</td><td>배포와 릴리스 분리, 점진적 기능 출시, 실험 설계</td></tr><tr><td></td><td>데이터베이스 스키마 변경 관리</td><td>무중단 데이터베이스 마이그레이션 전략</td></tr><tr><td><strong>품질 보증</strong></td><td>테스트 자동화 전략</td><td>테스트 피라미드, 테스트 유형별 자동화 접근법</td></tr><tr><td></td><td>테스트 데이터 관리</td><td>테스트를 위한 데이터 준비, 가상화, 비식별화</td></tr><tr><td></td><td>계약 테스트</td><td>마이크로서비스 간 인터페이스 검증 방법</td></tr><tr><td><strong>모니터링 및 관측성</strong></td><td>관측성 3 대 요소</td><td>메트릭, 로그, 트레이스의 CI/CD 통합</td></tr><tr><td></td><td>CI/CD 메트릭</td><td>DORA 메트릭, 파이프라인 성능 지표, 배포 성공률</td></tr><tr><td></td><td>사용자 경험 모니터링</td><td>실제 사용자 모니터링 (RUM), 합성 모니터링 통합</td></tr><tr><td><strong>문화 및 프로세스</strong></td><td>DevOps 문화 구축</td><td>협업, 책임 공유, 지속적 개선 문화 조성</td></tr><tr><td></td><td>장애 관리</td><td>사후 분석, 학습 문화, 회복력 설계</td></tr><tr><td></td><td>변경 관리</td><td>CI/CD 와 ITIL/ITSM 프로세스 조화</td></tr><tr><td><strong>클라우드 네이티브</strong></td><td>서버리스 CI/CD</td><td>AWS Lambda, Google Cloud Functions 기반 CI/CD</td></tr><tr><td></td><td>멀티클라우드 전략</td><td>다중 클라우드 환경에서의 일관된 CI/CD</td></tr><tr><td></td><td>에지 컴퓨팅 CI/CD</td><td>에지 디바이스 및 분산 시스템 CI/CD</td></tr><tr><td><strong>고급 주제</strong></td><td>GitOps</td><td>Git 중심 인프라 및 애플리케이션 관리</td></tr><tr><td></td><td>AIOps 와 CI/CD</td><td>AI 기반 배포 최적화 및 문제 예측</td></tr><tr><td></td><td>DevSecOps</td><td>보안 중심 CI/CD 파이프라인 설계</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>CI(Continuous Integration)</td><td>개발자들이 코드 변경사항을 메인 브랜치에 자주 통합하고 자동으로 빌드 및 테스트하는 소프트웨어 개발 방식</td></tr><tr><td>CD(Continuous Delivery)</td><td>소프트웨어가 언제든지 안정적으로 릴리즈될 수 있는 상태를 유지하도록 자동화하는 방법론</td></tr><tr><td>CD(Continuous Deployment)</td><td>코드 변경이 테스트를 통과한 후 자동으로 프로덕션 환경에 배포되는 방식</td></tr><tr><td>파이프라인 (Pipeline)</td><td>코드 변경부터 프로덕션 배포까지 일련의 자동화된 단계</td></tr><tr><td>아티팩트 (Artifact)</td><td>CI/CD 과정에서 생성된 배포 가능한 소프트웨어 패키지</td></tr><tr><td>IaC(Infrastructure as Code)</td><td>인프라스트럭처 구성을 코드로 관리하는 방식</td></tr><tr><td>카나리 배포 (Canary Deployment)</td><td>일부 사용자에게만 새 버전을 배포하여 위험을 최소화하는 전략</td></tr><tr><td>블루 - 그린 배포 (Blue-Green Deployment)</td><td>두 개의 동일한 프로덕션 환경을 번갈아 가며 배포하는 전략</td></tr><tr><td>롤링 배포 (Rolling Deployment)</td><td>서비스 중단 없이 점진적으로 새 버전을 배포하는 전략</td></tr><tr><td>특성 플래그 (Feature Flag)</td><td>배포와 릴리스를 분리하여 코드 활성화를 제어하는 기술</td></tr><tr><td>GitOps</td><td>Git 을 중심으로 인프라와 애플리케이션 배포를 관리하는 방식</td></tr><tr><td>DevSecOps</td><td>개발, 보안, 운영을 통합하여 보안을 파이프라인에 내장하는 접근법</td></tr><tr><td>DORA 메트릭</td><td>배포 빈도, 변경 적용 시간, 복구 시간, 변경 실패율을 측정하는 지표</td></tr><tr><td>AIOps</td><td>AI 기술을 활용한 IT 운영 자동화 및 최적화</td></tr><tr><td>관측성 (Observability)</td><td>시스템의 내부 상태를 외부 출력으로 이해할 수 있는 능력</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://docs.gitlab.com/ee/ci/introduction/>GitLab CI/CD 개요</a></li><li><a href=https://www.jenkins.io/solutions/pipelines/>Jenkins 파이프라인 설명</a></li><li><a href=https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html>AWS CodePipeline 아키텍처</a></li><li><a href=https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment>Atlassian CI/CD 원칙</a></li><li><a href=https://thenewstack.io/ci-cd-in-2025-heres-whats-next/>The New Stack: CI/CD 2025 동향</a></li></ul><ul><li><a href=https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment>Atlassian: CI vs CD</a></li><li><a href=https://aws.amazon.com/devops/continuous-integration/>AWS: CI 설명</a></li><li><a href=https://www.linkedin.com/pulse/top-7-cicd-pipeline-trends-2025-kairos-technologies-inc-fcuuc>2025 CI/CD 트렌드(LinkedIn)</a></li><li><a href=https://www.redhat.com/en/topics/devops/what-cicd-pipeline>CI/CD 파이프라인 구축 가이드</a></li><li><a href=https://docs.gitlab.com/ee/ci/>GitLab CI/CD 문서</a></li><li><a href=https://docs.github.com/en/actions>GitHub Actions 문서</a></li><li><a href=https://www.jenkins.io/doc/>Jenkins 공식 문서</a></li><li><a href=https://aws.amazon.com/devops/what-is-devops/>AWS DevOps 모범 사례</a></li><li><a href=https://cloud.google.com/devops>DORA - Google 클라우드 DevOps 연구</a></li><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/>Kubernetes CD 도구 비교</a></li><li><a href=https://www.devsecops.org/>DevSecOps 통합 가이드</a></li><li><a href=https://www.gitops.tech/>GitOps 원칙</a></li><li><a href=https://12factor.net/>12 Factor App 방법론</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd/>CI-CD</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd-fundamentals/>CI-CD-Fundamentals</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-tools-and-platforms/gitlab-ci/><span class=title>« Prev</span><br><span>Gitlab CI</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/context-switching/><span class=title>Next »</span><br><span>Context Switching</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>