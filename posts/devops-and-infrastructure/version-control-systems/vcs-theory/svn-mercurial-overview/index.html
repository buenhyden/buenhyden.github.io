<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SVN Mercurial Overview | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,Version-Control-Systems,VCS-Theory"><meta name=description content="SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="SVN Mercurial Overview"><meta property="og:description" content="SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-28T04:19:00+00:00"><meta property="article:modified_time" content="2024-09-28T04:19:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="Version-Control-Systems"><meta property="article:tag" content="VCS-Theory"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="SVN Mercurial Overview"><meta name=twitter:description content="SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps and Infrastructure","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/"},{"@type":"ListItem","position":3,"name":"Version Control Systems","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/"},{"@type":"ListItem","position":4,"name":"Version Control System Theory","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/"},{"@type":"ListItem","position":5,"name":"SVN Mercurial Overview","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SVN Mercurial Overview","name":"SVN Mercurial Overview","description":"SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다.","keywords":["DevOps-and-Infrastructure","Version-Control-Systems","VCS-Theory"],"articleBody":"SVN Mercurial Overview SVN(Subversion)과 Mercurial은 소프트웨어 개발에서 코드의 변경 이력을 관리하고 협업을 지원하는 버전 관리 시스템이다. SVN은 중앙 집중형(Centralized) 시스템으로, 모든 버전 이력이 중앙 서버에 저장된다. 반면, Mercurial은 분산형(Distributed) 시스템으로, 각 개발자가 전체 저장소를 로컬에 복제하여 작업한다. 각 시스템은 저장 방식, 협업 모델, 성능 등에서 차이가 있으며, 프로젝트의 특성과 요구사항에 따라 적절한 시스템을 선택해야 한다.\n핵심 개념 SVN (Subversion) SVN은 Apache Software Foundation에서 개발한 중앙 집중식 버전 관리 시스템이다.\n핵심 개념은 다음과 같다:\n중앙 저장소: 모든 파일 버전과 변경 이력이 단일 중앙 서버에 저장된다. 작업 복사본(Working Copy): 개발자는 중앙 저장소의 일부 또는 전체를 로컬 머신에 체크아웃하여 작업한다. 델타 저장 방식: 파일 변경 사항을 델타(차이점)로 저장하여 공간을 절약한다. 원자적 커밋: 여러 파일에 대한 변경 사항이 단일 트랜잭션으로 처리된다. 리비전 번호: 각 커밋마다 순차적으로 증가하는 정수 형태의 리비전 번호가 할당된다. Mercurial Mercurial은 Matt Mackall이 개발한 분산형 버전 관리 시스템으로, 핵심 개념은 다음과 같다:\n분산 저장소: 모든 사용자가 저장소의 전체 복사본과 이력을 로컬에 보유한다. 체인지셋(Changeset): 프로젝트 상태의 스냅샷과 메타데이터를 포함하는 불변의 단위이다. 해시 기반 식별자: 각 체인지셋은 SHA-1 해시로 식별된다. 브랜치 모델: 가볍고 유연한 브랜칭 메커니즘을 제공한다. 확장성: 플러그인 시스템을 통해 기능을 확장할 수 있다. 목적 및 필요성 버전 관리 시스템인 SVN과 Mercurial의 필요성은 다음과 같다:\n코드 변경 추적: 소프트웨어 개발 과정에서 누가, 언제, 무엇을 변경했는지 추적할 필요가 있다. 협업 효율성: 여러 개발자가 동시에 작업할 때 코드 충돌을 최소화하고 병합을 용이하게 한다. 코드 백업: 개발 중인 코드의 안전한 백업을 제공한다. 실험적 개발: 새로운 기능이나 수정 사항을 안전하게 실험할 수 있는 환경을 제공한다. 릴리스 관리: 특정 버전의 소프트웨어를 쉽게 릴리스하고 관리할 수 있다. 책임 추적: 코드 변경에 대한 책임을 명확히 할 수 있다. 지식 보존: 개발 결정 사항과 진행 과정에 대한 지식을 보존한다. SVN과 Mercurial 비교 분석 기본 구조 및 특성 비교 항목 SVN Mercurial 아키텍처 유형 중앙 집중식(Centralized) 분산형(Distributed) 저장 방식 델타 저장 방식 델타 저장 + 스냅샷 식별자 체계 순차적 정수 리비전 번호 SHA-1 해시 기반 식별자 개발 언어 C Python + C 라이선스 Apache License GNU GPL v2+ 작업 단위 파일 + 디렉토리 체인지셋(전체 프로젝트 상태) 오프라인 능력 제한적 완전한 오프라인 작업 주요 기능 비교 기능 SVN Mercurial 버전 관리 방식 원자적 커밋, 디렉토리 버전 관리 분산 작업, 로컬 커밋 브랜치 관리 디렉토리 기반 브랜치, 효율적인 태깅 강력한 브랜치 지원, 이름 공간 브랜치 파일 처리 파일 잠금, 파일/디렉토리 이력 관리 자동 이름 변경 감지, 효율적 저장 서버 의존성 대부분 작업에 서버 필요 서버 없이 대부분 작업 가능 접근 프로토콜 HTTP, HTTPS, SVN, SVN+SSH HTTP, SSH, 로컬 프로토콜 UI 옵션 명령줄, GUI 클라이언트 명령줄, TortoiseHg, 웹 인터페이스 확장성 플러그인/후크 Python 기반 확장 시스템 대용량 파일 기본 지원 Largefiles 확장 기능 성능 및 효율성 측면 SVN Mercurial 로컬 작업 속도 서버 의존으로 상대적 느림 로컬 작업으로 빠른 성능 네트워크 의존성 높음 (대부분 작업에 필요) 낮음 (로컬 작업 중심) 저장소 크기 상대적으로 작음 (델타 기반) 중간 (델타 + 일부 스냅샷) 대규모 저장소 처리 대형 저장소에서 성능 저하 가능 효율적인 저장으로 대형 저장소 지원 병합 성능 상대적으로 복잡하고 느림 강력한 자동 병합 지원 브랜치 생성 비용 상대적으로 비용 높음 가볍고 빠른 브랜치 생성 부분 체크아웃 지원 (저장소 일부만 체크아웃 가능) 제한적 (전체 저장소 클론이 기본) 장점 및 단점 SVN 장점:\n중앙 집중식 모델로 단일 진실 소스 제공 세밀한 접근 제어 및 권한 관리 부분 체크아웃으로 대규모 저장소 효율적 관리 순차적 리비전 번호로 이해하기 쉬운 버전 참조 바이너리 파일에 대한 잠금 기능 제공 안정적이고 성숙한 시스템 단점:\n중앙 서버 의존성으로 오프라인 작업 제한적 네트워크 작업이 많아 속도가 느릴 수 있음 브랜치 병합이 복잡하고 충돌 해결이 어려움 매우 큰 저장소에서 성능 저하 발생 가능 파일 이름 변경 추적이 명시적으로 필요 커밋된 이력 수정이 어려움 Mercurial 장점:\n분산형 모델로 로컬에서 대부분 작업 가능 오프라인 상태에서도 커밋, 브랜치 등 작업 가능 로컬 작업 중심으로 빠른 성능 효율적인 저장 알고리즘으로 공간 절약 강력한 자동 병합 도구와 충돌 해결 제공 확장 시스템을 통한 기능 확장 용이 자동 파일 이름 변경 및 복사 감지 단점:\n분산 모델 개념이 초보자에게 어려울 수 있음 매우 큰 바이너리 파일 처리 시 성능 이슈 가능 Git에 비해 상대적으로 작은 생태계와 인지도 전체 저장소 복제가 기본이라 초기 클론 시간 소요 기본 보안 감사 기능이 제한적 초대형 프로젝트에서 Git 대비 성능 저하 가능성 적합한 사용 시나리오 시나리오 SVN Mercurial 대기업 개발 환경 중앙 통제, 엄격한 접근 제어, 감사 추적 필요 환경 팀 간 독립적 작업, 오프라인 작업 필요, 유연한 워크플로우 환경 오픈 소스 프로젝트 중앙 관리가 필요한 프로젝트 (Apache, GNOME) 분산 협업 중심 프로젝트 (Mozilla Firefox, OpenJDK) 소규모 팀 개발 간단한 프로젝트, 중앙 서버 관리 용이한 환경 독립적 작업 중심, Git보다 간단한 인터페이스 선호 시 바이너리 자산 관리 대용량 바이너리 파일 관리, 파일 잠금 필요 시 Largefiles 확장으로 바이너리 파일 관리 가능 규제 산업 감사 추적, 엄격한 접근 제어 필수 환경 로컬 작업 필요하나 중앙 관리도 중요한 하이브리드 환경 브랜칭 및 워크플로우 전략 항목 SVN Mercurial 브랜치 모델 디렉토리 기반 브랜치 이름 공간 브랜치, 익명 헤드 브랜치 전략 기능별 브랜치 최소화 권장 책임 분리 브랜치 권장 병합 방식 수동 해결 위주 3-way 머지 자동화 지원 워크플로우 유형 체크아웃-수정-커밋 주기 분기-개발-병합 워크플로우 협업 패턴 중앙화된 협업, 직접 커밋 분산 협업, 풀/푸시 모델 최적화 전략 영역 SVN Mercurial 저장소 구조 여러 작은 저장소로 분할 권장 저장소 크기 모니터링, 필요시 분할 서버 설정 Apache 튜닝, 캐시 최적화 서버 측 압축 설정, 웹 서버 최적화 네트워크 최적화 압축 활성화, HTTP 파이프라이닝 번들 사용, 압축 수준 조정 대용량 파일 외부 저장소, 바이너리 파일 분리 largefiles 확장, 바이너리 관리 정책 정기 유지 관리 저장소 압축, 불필요 파일 정리 저장소 압축(hg 컴팩션), 캐시 정리 마이그레이션 및 통합 고려사항 측면 SVN Mercurial 다른 시스템에서 이전 단계적 전환, 이력 보존 방안 수립 SVN/Git에서 이전 도구 활용, 이력 변환 CI/CD 통합 Jenkins/TeamCity 등과 통합 확장 시스템 활용, CI/CD 파이프라인 통합 IDE 통합 대부분 IDE와 통합 지원 TortoiseHg, IDE 플러그인 활용 라이선스 고려 Apache 라이선스, 상업적 활용 자유 GPL v2+, 라이선스 영향 검토 필요 실제 사용 사례 조직/프로젝트 사용 시스템 특이사항 Apache 프로젝트 SVN 중앙 관리형 오픈소스 개발 Mozilla Firefox Mercurial 대규모 분산 오픈소스 개발 엔터프라이즈 소프트웨어 SVN 엄격한 접근 제어, 감사 필요 환경 Facebook(일부) Mercurial 대규모 코드베이스에 맞게 사용자화 게임 스튜디오 SVN 대용량 바이너리 에셋 관리 OpenJDK Mercurial 분산 협업 중심 Java 개발 현대적 개발 환경에서의 위치 측면 SVN Mercurial 현재 시장 점유율 전통적 기업 환경에서 여전히 사용 Git에 비해 점유율 감소 추세 클라우드 통합 제한적 클라우드 지원 다양한 클라우드 서비스 지원 DevOps 친화성 제한적 CI/CD 통합 확장성 있는 DevOps 파이프라인 통합 신규 도입 추세 감소 추세, 레거시 시스템 유지 일부 특수 환경에서 새로운 도입 생태계 활성도 안정적 유지보수 중심 활발한 개발 및 확장 작동 원리 SVN의 작동 원리 SVN은 중앙 집중식 버전 관리 시스템으로 다음과 같은 원리로 작동한다:\n저장소 구조: 중앙 서버에 모든 버전 정보와 이력이 저장된다. 체크아웃: 개발자는 중앙 저장소의 특정 리비전을 로컬 작업 복사본으로 가져온다. 변경 사항 추적: 로컬에서 파일을 수정하면 SVN 클라이언트가 변경 사항을 추적한다. 업데이트: 개발자는 중앙 저장소의 최신 변경 사항을 로컬 작업 복사본에 업데이트한다. 커밋: 개발자가 변경 사항을 중앙 저장소에 커밋하면, 새로운 리비전이 생성된다. 델타 저장: 변경 사항은 델타(차이점)로 저장되어 공간을 절약한다. 충돌 감지 및 해결: 여러 개발자가 동일한 파일을 수정할 때 발생하는 충돌을 감지하고 해결한다. SVN 작동 원리 다이어그램:\n1 [개발자 1 작업 복사본] \u003c---- 체크아웃/업데이트/커밋 ----\u003e [중앙 SVN 저장소] \u003c---- 체크아웃/업데이트/커밋 ----\u003e [개발자 2 작업 복사본] Mercurial의 작동 원리 Mercurial은 분산형 버전 관리 시스템으로 다음과 같은 원리로 작동한다:\n저장소 복제: 개발자는 저장소의 전체 복사본을 로컬에 클론한다. 로컬 작업: 모든 버전 관리 작업(커밋, 브랜치, 로그 보기 등)이 로컬에서 수행된다. 체인지셋 생성: 변경 사항을 커밋하면 불변의 체인지셋이 생성된다. 해시 기반 식별: 각 체인지셋은 SHA-1 해시로 고유하게 식별된다. 푸시/풀: 개발자들은 저장소 간에 변경 사항을 푸시하거나 풀하여 동기화한다. 병합: 여러 개발 라인을 병합할 때 자동 충돌 해결과 수동 개입을 조합하여 사용한다. 저장소 그래프: 모든 커밋이 방향성 비순환 그래프(DAG)로 구성된다. Mercurial 작동 원리 다이어그램:\n1 2 3 4 5 [개발자 1 저장소 복사본] \u003c---- 푸시/풀 ----\u003e [중앙 저장소(선택적)] \u003c---- 푸시/풀 ----\u003e [개발자 2 저장소 복사본] ^ | v [개발자 3 저장소 복사본] 구성 요소 및 아키텍처 SVN의 구성 요소 및 아키텍처 SVN은 다음과 같은 주요 구성 요소로 이루어져 있다:\n저장소(Repository): 기능: 모든 프로젝트 데이터와 이력 저장 역할: 버전 관리 데이터의 중앙 저장소 역할 저장소 백엔드(FSFS/BDB): 기능: 저장소 데이터의 물리적 저장 역할: 파일 시스템 기반(FSFS) 또는 Berkeley DB(BDB) 기반 저장 제공 서버 프로세스(svnserve/Apache): 기능: 저장소에 대한 네트워크 액세스 제공 역할: svn://, http://, https://, svn+ssh:// 등의 프로토콜 지원 클라이언트(svn 명령줄 도구, TortoiseSVN 등): 기능: 사용자 인터페이스 제공 역할: 저장소와 상호작용하는 명령 실행 작업 복사본(Working Copy): 기능: 로컬에서 파일 편집 제공 역할: 저장소의 특정 리비전 상태를 로컬에 유지 APR(Apache Portable Runtime): 기능: 크로스 플랫폼 호환성 제공 역할: 다양한 운영 체제에서 일관된 기능 보장 SVN 아키텍처 다이어그램:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [클라이언트 측] [서버 측] +----------------+ +-----------------+ | SVN 명령줄 도구 | | Apache/svnserve | +----------------+ +-----------------+ | | v v +----------------+ +-----------------+ | 작업 복사본 |\u003c--- 네트워크 프로토콜 ---\u003e | 저장소 | +----------------+ (http, svn, etc.) +-----------------+ | v +-----------------+ | 저장소 백엔드 | | (FSFS/BDB) | +-----------------+ SVN(Subversion)은 일반적으로 다음과 같은 표준 디렉토리 구조를 사용한다:\n트렁크(trunk): 기본 개발 라인을 나타낸다. 주요 개발 작업이 이루어지는 곳이다. 프로젝트의 현재 최신 상태를 나타낸다. 경로 예시: /project/trunk/ 브랜치(branches): 메인 개발 라인에서 분기한 별도의 개발 라인이다. 새로운 기능 개발, 버그 수정, 실험적 작업 등에 사용된다. SVN에서 브랜치는 트렁크의 복사본으로 생성된다(실제로는 참조). 경로 예시: /project/branches/feature-x/ 태그(tags): 프로젝트의 특정 시점 스냅샷을 나타낸다. 주로 릴리스 버전을 표시하는 데 사용된다. 변경되지 않아야 하는 읽기 전용 참조이다. 경로 예시: /project/tags/v1.0/ 이 구조는 단순한 디렉토리 구조일 뿐, SVN이 이를 특별하게 처리하지는 않는다.\n이는 관례적인 패턴으로, 개발자들이 이 구조를 준수함으로써 효율적인 버전 관리가 가능해진다.\nSVN의 트렁크/브랜치/태그 작업 흐름:\n개발자는 트렁크에서 일상적인 개발 작업을 수행한다. 새로운 기능 개발이 필요하면 트렁크에서 브랜치를 생성한다. 브랜치에서 개발이 완료되면 트렁크로 병합(merge)한다. 릴리스 시점에는 트렁크 또는 안정화된 브랜치를 태그로 복사한다. SVN에서 브랜치와 태그 생성은 svn copy 명령을 사용하며, 실제로는 파일을 복제하지 않고 저장소 내에서 참조만 생성하므로 공간 효율적이다. 그러나 브랜치 병합은 명시적으로 수행해야 하며, 복잡한 병합 시나리오에서는 충돌 해결이 어려울 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [SVN 저장소] | +-- trunk/ | | | +-- src/ | +-- docs/ | +-- … | +-- branches/ | | | +-- feature-a/ | | | | | +-- src/ | | +-- docs/ | | +-- … | | | +-- bugfix-123/ | | | +-- src/ | +-- … | +-- tags/ | +-- v1.0.0/ | | | +-- src/ | +-- docs/ | +-- … | +-- v1.1.0/ | +-- … Mercurial의 구성 요소 및 아키텍처 Mercurial은 다음과 같은 주요 구성 요소로 이루어져 있다:\n저장소(.hg 디렉토리): 기능: 프로젝트의 모든 이력과 메타데이터 저장 역할: 로컬 작업 및 이력 관리의 기반 제공 스토어(Store): 기능: 파일 데이터 및 이력 정보의 물리적 저장 역할: 효율적인 델타 압축과 저장 제공 리비전 로그(Revlog): 기능: 파일 변경 이력 관리 역할: 델타 압축을 사용한 효율적인 이력 저장 디렉토리 매니페스트(Manifest): 기능: 각 리비전의 디렉토리 구조 추적 역할: 프로젝트 상태의 스냅샷 제공 클라이언트(hg 명령줄 도구, TortoiseHg 등): 기능: 사용자 인터페이스 제공 역할: 저장소 조작 명령 실행 확장 시스템(Extensions): 기능: 추가 기능 및 사용자 정의 확장 제공 역할: 기본 기능 확장 및 워크플로우 맞춤화 네트워크 레이어: 기능: 저장소 간 통신 제공 역할: HTTP, SSH 등의 프로토콜을 통한 푸시/풀 지원 Mercurial 아키텍처 다이어그램:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [로컬 저장소] +---------------------------+ | 작업 디렉토리 | +---------------------------+ | v +---------------------------+ | .hg 디렉토리 (저장소) | +---------------------------+ | | v v +--------------+ +--------------+ | 체인지셋 DB | | 매니페스트 DB | +--------------+ +--------------+ | | v v +--------------+ +--------------+ | 파일 리비전 | | 태그/브랜치 | | 로그 | | 정보 | +--------------+ +--------------+ | v +---------------------------+ | 네트워크 레이어 | +---------------------------+ | v [다른 저장소와의 상호작용] Mercurial 핵심 기능 및 CLI Mercurial(hg)의 핵심 기능과 주요 명령줄 인터페이스(CLI) 명령어는 다음과 같다:\n핵심 기능 분산 버전 관리: 모든 개발자가 전체 저장소 복사본을 로컬에 보유 네트워크 연결 없이도 대부분의 작업 수행 가능 체인지셋 기반 관리: 변경 사항이 원자적 체인지셋으로 관리됨 SHA-1 해시로 각 체인지셋 고유하게 식별 강력한 병합 지원: 자동화된 3-way 병합 알고리즘 브랜치 간 원활한 병합 지원 확장 시스템: Python으로 작성된 확장 모듈 추가 가능 기본 기능 확장 및 사용자 정의 워크플로우 구성 이름 공간 기반 브랜치: 네임드 브랜치: 이름이 있는 장기 브랜치 익명 헤드: 이름 없는 임시 개발 라인 푸시/풀 모델: 저장소 간 변경 사항을 푸시하거나 풀하는 메커니즘 HTTP, HTTPS, SSH 등 다양한 프로토콜 지원 효율적인 저장 구조: 리비전 로그(revlog) 기반 델타 압축 저장 파일 이름 변경 및 복사 자동 감지 웹 인터페이스: 내장된 웹 서버로 저장소 브라우징 가능 그래프 형태의 이력 시각화 주요 CLI 명령어 저장소 생성 및 복제: hg init: 새 저장소 생성 hg clone: 원격 저장소 복제 변경 사항 관리: hg status: 작업 디렉토리 상태 확인 hg diff: 변경 사항 확인 hg add: 파일을 버전 관리에 추가 hg remove: 파일 제거 hg commit 또는 hg ci: 변경 사항 커밋 이력 조회: hg log: 커밋 이력 조회 hg summary: 저장소 상태 요약 hg annotate: 파일의 각 라인 작성자 표시 hg grep: 이력에서 패턴 검색 원격 저장소 상호작용: hg pull: 원격 저장소에서 변경 사항 가져오기 hg push: 로컬 변경 사항을 원격 저장소로 보내기 hg incoming: 수신 예정 변경 사항 확인 hg outgoing: 발신 예정 변경 사항 확인 브랜치 및 병합: hg branch: 현재 브랜치 표시 또는 새 브랜치 생성 hg branches: 브랜치 목록 표시 hg merge: 다른 브랜치 병합 hg update 또는 hg up: 특정 리비전으로 작업 디렉토리 업데이트 hg resolve: 병합 충돌 해결 태그 관리: hg tag: 태그 생성 hg tags: 태그 목록 표시 작업 되돌리기: hg revert: 작업 디렉토리 변경 사항 되돌리기 hg backout: 이전 커밋 효과 취소하는 새 커밋 생성 hg strip: 커밋 제거(확장 필요) 고급 기능: hg bisect: 이진 검색으로 버그 도입 시점 찾기 hg graft: 특정 커밋 체리픽 hg shelve: 작업 중인 변경 사항 임시 저장(확장 필요) hg purge: 추적되지 않는 파일 제거(확장 필요) 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 고려사항 설명 협업 모델 SVN은 중앙 집중형, Mercurial은 분산형 협업에 적합합니다. 브랜치 전략 Mercurial은 브랜치와 머징이 용이하므로, 복잡한 브랜치 전략에 유리합니다. 접근 제어 SVN은 중앙 서버에서 접근 제어가 용이합니다. 최신 동향과 앞으로의 전망, 주목해야 할 기술들 2025년 기준으로 Git은 버전 관리 시스템 시장의 93% 이상을 차지하며, SVN은 약 20%, Mercurial은 5% 미만의 사용률을 보이고 있다.\nSVN의 현재 위치: SVN은 대용량 코드베이스, 대형 바이너리 파일, 중앙 집중식 관리가 필요한 특정 산업(제조업, 반도체 설계, 게임 개발 등)에서 여전히 활발히 사용됨\nMercurial의 상태: 2020년 Bitbucket의 Mercurial 지원 중단 이후 사용률이 크게 감소했으며, 주로 소수의 특정 프로젝트에서만 사용되고 있음\n용어 정리 용어 설명 원자적 커밋 여러 파일의 변경 사항이 하나의 단위로 처리되어 전체가 성공하거나 전체가 실패하는 특성 리비전 로그 저장소의 변경 이력을 저장하는 Mercurial의 핵심 데이터 구조 작업 복사본 SVN에서 중앙 저장소의 파일을 로컬에 복사하여 작업하는 공간 체인지셋 Mercurial에서 프로젝트 상태의 스냅샷과 메타데이터를 포함하는 불변의 단위 FSFS SVN에서 사용하는 파일 시스템 기반 저장소 백엔드, Berkeley DB를 대체 매니페스트 Mercurial에서 각 버전의 디렉토리 구조를 추적하는 파일 병합 추적 이전 병합 작업을 기억하여 중복 병합이나 충돌을 줄이는 기능 충돌 해결 동일 파일에 대한 서로 다른 변경 사항이 충돌할 때 이를 해결하는 프로세스 후크 스크립트 특정 이벤트(커밋, 업데이트 등) 발생 시 자동으로 실행되는 스크립트 샌드박스 버전 관리 시스템에서 격리된 환경에서 변경을 테스트할 수 있는 공간 참고 및 출처 SVN vs Git 비교 Mercurial revlog 구조 2025 VCS 시장 전망 SVN 공식 문서 SVN Book (Red-Bean) Mercurial 공식 문서 Mercurial CLI Command Reference 버전 관리 시스템 개요 (Atlassian Git Tutorials) Comparing Version Control Systems: SVN, Mercurial, Git - Stack Overflow Discussion RhodeCode 블로그: 2025년 버전 관리 시스템 인기도 Assembla 블로그: SVN은 여전히 사용되고 있는가? Apache 인프라 웹사이트: SVN 기본 사항 버전 관리 소프트웨어 비교: SVN, Git, Mercurial Mercurial의 최신 업데이트 SVN vs Git 비교 가이드 Mercurial vs SVN 비교 분석 Apache Subversion의 수명 주기 및 지원 일정 ","wordCount":"2570","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-28T04:19:00Z","dateModified":"2024-09-28T04:19:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-infrastructure/>DevOps and Infrastructure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/>Version Control Systems</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/>Version Control System Theory</a></div><h1 class="post-title entry-hint-parent">SVN Mercurial Overview</h1><div class=post-description>SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다.</div><div class=post-meta><span title='2024-09-28 04:19:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/DevOps%20and%20Infrastructure/Version%20Control%20Systems/VCS%20Theory/svn-mercurial-overview.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#svn-mercurial-overview>SVN Mercurial Overview</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#목적-및-필요성>목적 및 필요성</a></li><li><a href=#svn과-mercurial-비교-분석>SVN과 Mercurial 비교 분석</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#구성-요소-및-아키텍처>구성 요소 및 아키텍처</a></li><li><a href=#mercurial-핵심-기능-및-cli>Mercurial 핵심 기능 및 CLI</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최신-동향과-앞으로의-전망-주목해야-할-기술들>최신 동향과 앞으로의 전망, 주목해야 할 기술들</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=svn-mercurial-overview>SVN Mercurial Overview<a hidden class=anchor aria-hidden=true href=#svn-mercurial-overview>#</a></h2><p>SVN(Subversion)과 Mercurial은 소프트웨어 개발에서 코드의 변경 이력을 관리하고 협업을 지원하는 버전 관리 시스템이다. SVN은 중앙 집중형(Centralized) 시스템으로, 모든 버전 이력이 중앙 서버에 저장된다. 반면, Mercurial은 분산형(Distributed) 시스템으로, 각 개발자가 전체 저장소를 로컬에 복제하여 작업한다. 각 시스템은 저장 방식, 협업 모델, 성능 등에서 차이가 있으며, 프로젝트의 특성과 요구사항에 따라 적절한 시스템을 선택해야 한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><h4 id=svn-subversion>SVN (Subversion)<a hidden class=anchor aria-hidden=true href=#svn-subversion>#</a></h4><p>SVN은 Apache Software Foundation에서 개발한 중앙 집중식 버전 관리 시스템이다.</p><p>핵심 개념은 다음과 같다:</p><ol><li><strong>중앙 저장소</strong>: 모든 파일 버전과 변경 이력이 단일 중앙 서버에 저장된다.</li><li><strong>작업 복사본(Working Copy)</strong>: 개발자는 중앙 저장소의 일부 또는 전체를 로컬 머신에 체크아웃하여 작업한다.</li><li><strong>델타 저장 방식</strong>: 파일 변경 사항을 델타(차이점)로 저장하여 공간을 절약한다.</li><li><strong>원자적 커밋</strong>: 여러 파일에 대한 변경 사항이 단일 트랜잭션으로 처리된다.</li><li><strong>리비전 번호</strong>: 각 커밋마다 순차적으로 증가하는 정수 형태의 리비전 번호가 할당된다.</li></ol><h4 id=mercurial>Mercurial<a hidden class=anchor aria-hidden=true href=#mercurial>#</a></h4><p>Mercurial은 Matt Mackall이 개발한 분산형 버전 관리 시스템으로, 핵심 개념은 다음과 같다:</p><ol><li><strong>분산 저장소</strong>: 모든 사용자가 저장소의 전체 복사본과 이력을 로컬에 보유한다.</li><li><strong>체인지셋(Changeset)</strong>: 프로젝트 상태의 스냅샷과 메타데이터를 포함하는 불변의 단위이다.</li><li><strong>해시 기반 식별자</strong>: 각 체인지셋은 SHA-1 해시로 식별된다.</li><li><strong>브랜치 모델</strong>: 가볍고 유연한 브랜칭 메커니즘을 제공한다.</li><li><strong>확장성</strong>: 플러그인 시스템을 통해 기능을 확장할 수 있다.</li></ol><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>버전 관리 시스템인 SVN과 Mercurial의 필요성은 다음과 같다:</p><ol><li><strong>코드 변경 추적</strong>: 소프트웨어 개발 과정에서 누가, 언제, 무엇을 변경했는지 추적할 필요가 있다.</li><li><strong>협업 효율성</strong>: 여러 개발자가 동시에 작업할 때 코드 충돌을 최소화하고 병합을 용이하게 한다.</li><li><strong>코드 백업</strong>: 개발 중인 코드의 안전한 백업을 제공한다.</li><li><strong>실험적 개발</strong>: 새로운 기능이나 수정 사항을 안전하게 실험할 수 있는 환경을 제공한다.</li><li><strong>릴리스 관리</strong>: 특정 버전의 소프트웨어를 쉽게 릴리스하고 관리할 수 있다.</li><li><strong>책임 추적</strong>: 코드 변경에 대한 책임을 명확히 할 수 있다.</li><li><strong>지식 보존</strong>: 개발 결정 사항과 진행 과정에 대한 지식을 보존한다.</li></ol><h3 id=svn과-mercurial-비교-분석>SVN과 Mercurial 비교 분석<a hidden class=anchor aria-hidden=true href=#svn과-mercurial-비교-분석>#</a></h3><h4 id=기본-구조-및-특성>기본 구조 및 특성<a hidden class=anchor aria-hidden=true href=#기본-구조-및-특성>#</a></h4><table><thead><tr><th>비교 항목</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>아키텍처 유형</strong></td><td>중앙 집중식(Centralized)</td><td>분산형(Distributed)</td></tr><tr><td><strong>저장 방식</strong></td><td>델타 저장 방식</td><td>델타 저장 + 스냅샷</td></tr><tr><td><strong>식별자 체계</strong></td><td>순차적 정수 리비전 번호</td><td>SHA-1 해시 기반 식별자</td></tr><tr><td><strong>개발 언어</strong></td><td>C</td><td>Python + C</td></tr><tr><td><strong>라이선스</strong></td><td>Apache License</td><td>GNU GPL v2+</td></tr><tr><td><strong>작업 단위</strong></td><td>파일 + 디렉토리</td><td>체인지셋(전체 프로젝트 상태)</td></tr><tr><td><strong>오프라인 능력</strong></td><td>제한적</td><td>완전한 오프라인 작업</td></tr></tbody></table><h4 id=주요-기능-비교>주요 기능 비교<a hidden class=anchor aria-hidden=true href=#주요-기능-비교>#</a></h4><table><thead><tr><th>기능</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>버전 관리 방식</strong></td><td>원자적 커밋, 디렉토리 버전 관리</td><td>분산 작업, 로컬 커밋</td></tr><tr><td><strong>브랜치 관리</strong></td><td>디렉토리 기반 브랜치, 효율적인 태깅</td><td>강력한 브랜치 지원, 이름 공간 브랜치</td></tr><tr><td><strong>파일 처리</strong></td><td>파일 잠금, 파일/디렉토리 이력 관리</td><td>자동 이름 변경 감지, 효율적 저장</td></tr><tr><td><strong>서버 의존성</strong></td><td>대부분 작업에 서버 필요</td><td>서버 없이 대부분 작업 가능</td></tr><tr><td><strong>접근 프로토콜</strong></td><td>HTTP, HTTPS, SVN, SVN+SSH</td><td>HTTP, SSH, 로컬 프로토콜</td></tr><tr><td><strong>UI 옵션</strong></td><td>명령줄, GUI 클라이언트</td><td>명령줄, TortoiseHg, 웹 인터페이스</td></tr><tr><td><strong>확장성</strong></td><td>플러그인/후크</td><td>Python 기반 확장 시스템</td></tr><tr><td><strong>대용량 파일</strong></td><td>기본 지원</td><td>Largefiles 확장 기능</td></tr></tbody></table><h4 id=성능-및-효율성>성능 및 효율성<a hidden class=anchor aria-hidden=true href=#성능-및-효율성>#</a></h4><table><thead><tr><th>측면</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>로컬 작업 속도</strong></td><td>서버 의존으로 상대적 느림</td><td>로컬 작업으로 빠른 성능</td></tr><tr><td><strong>네트워크 의존성</strong></td><td>높음 (대부분 작업에 필요)</td><td>낮음 (로컬 작업 중심)</td></tr><tr><td><strong>저장소 크기</strong></td><td>상대적으로 작음 (델타 기반)</td><td>중간 (델타 + 일부 스냅샷)</td></tr><tr><td><strong>대규모 저장소 처리</strong></td><td>대형 저장소에서 성능 저하 가능</td><td>효율적인 저장으로 대형 저장소 지원</td></tr><tr><td><strong>병합 성능</strong></td><td>상대적으로 복잡하고 느림</td><td>강력한 자동 병합 지원</td></tr><tr><td><strong>브랜치 생성 비용</strong></td><td>상대적으로 비용 높음</td><td>가볍고 빠른 브랜치 생성</td></tr><tr><td><strong>부분 체크아웃</strong></td><td>지원 (저장소 일부만 체크아웃 가능)</td><td>제한적 (전체 저장소 클론이 기본)</td></tr></tbody></table><h4 id=장점-및-단점>장점 및 단점<a hidden class=anchor aria-hidden=true href=#장점-및-단점>#</a></h4><h5 id=svn>SVN<a hidden class=anchor aria-hidden=true href=#svn>#</a></h5><p>장점:</p><ul><li>중앙 집중식 모델로 단일 진실 소스 제공</li><li>세밀한 접근 제어 및 권한 관리</li><li>부분 체크아웃으로 대규모 저장소 효율적 관리</li><li>순차적 리비전 번호로 이해하기 쉬운 버전 참조</li><li>바이너리 파일에 대한 잠금 기능 제공</li><li>안정적이고 성숙한 시스템</li></ul><p>단점:</p><ul><li>중앙 서버 의존성으로 오프라인 작업 제한적</li><li>네트워크 작업이 많아 속도가 느릴 수 있음</li><li>브랜치 병합이 복잡하고 충돌 해결이 어려움</li><li>매우 큰 저장소에서 성능 저하 발생 가능</li><li>파일 이름 변경 추적이 명시적으로 필요</li><li>커밋된 이력 수정이 어려움</li></ul><h5 id=mercurial-1>Mercurial<a hidden class=anchor aria-hidden=true href=#mercurial-1>#</a></h5><p>장점:</p><ul><li>분산형 모델로 로컬에서 대부분 작업 가능</li><li>오프라인 상태에서도 커밋, 브랜치 등 작업 가능</li><li>로컬 작업 중심으로 빠른 성능</li><li>효율적인 저장 알고리즘으로 공간 절약</li><li>강력한 자동 병합 도구와 충돌 해결 제공</li><li>확장 시스템을 통한 기능 확장 용이</li><li>자동 파일 이름 변경 및 복사 감지</li></ul><p>단점:</p><ul><li>분산 모델 개념이 초보자에게 어려울 수 있음</li><li>매우 큰 바이너리 파일 처리 시 성능 이슈 가능</li><li>Git에 비해 상대적으로 작은 생태계와 인지도</li><li>전체 저장소 복제가 기본이라 초기 클론 시간 소요</li><li>기본 보안 감사 기능이 제한적</li><li>초대형 프로젝트에서 Git 대비 성능 저하 가능성</li></ul><h4 id=적합한-사용-시나리오>적합한 사용 시나리오<a hidden class=anchor aria-hidden=true href=#적합한-사용-시나리오>#</a></h4><table><thead><tr><th>시나리오</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>대기업 개발 환경</strong></td><td>중앙 통제, 엄격한 접근 제어, 감사 추적 필요 환경</td><td>팀 간 독립적 작업, 오프라인 작업 필요, 유연한 워크플로우 환경</td></tr><tr><td><strong>오픈 소스 프로젝트</strong></td><td>중앙 관리가 필요한 프로젝트 (Apache, GNOME)</td><td>분산 협업 중심 프로젝트 (Mozilla Firefox, OpenJDK)</td></tr><tr><td><strong>소규모 팀 개발</strong></td><td>간단한 프로젝트, 중앙 서버 관리 용이한 환경</td><td>독립적 작업 중심, Git보다 간단한 인터페이스 선호 시</td></tr><tr><td><strong>바이너리 자산 관리</strong></td><td>대용량 바이너리 파일 관리, 파일 잠금 필요 시</td><td>Largefiles 확장으로 바이너리 파일 관리 가능</td></tr><tr><td><strong>규제 산업</strong></td><td>감사 추적, 엄격한 접근 제어 필수 환경</td><td>로컬 작업 필요하나 중앙 관리도 중요한 하이브리드 환경</td></tr></tbody></table><h4 id=브랜칭-및-워크플로우-전략>브랜칭 및 워크플로우 전략<a hidden class=anchor aria-hidden=true href=#브랜칭-및-워크플로우-전략>#</a></h4><table><thead><tr><th>항목</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>브랜치 모델</strong></td><td>디렉토리 기반 브랜치</td><td>이름 공간 브랜치, 익명 헤드</td></tr><tr><td><strong>브랜치 전략</strong></td><td>기능별 브랜치 최소화 권장</td><td>책임 분리 브랜치 권장</td></tr><tr><td><strong>병합 방식</strong></td><td>수동 해결 위주</td><td>3-way 머지 자동화 지원</td></tr><tr><td><strong>워크플로우 유형</strong></td><td>체크아웃-수정-커밋 주기</td><td>분기-개발-병합 워크플로우</td></tr><tr><td><strong>협업 패턴</strong></td><td>중앙화된 협업, 직접 커밋</td><td>분산 협업, 풀/푸시 모델</td></tr></tbody></table><h4 id=최적화-전략>최적화 전략<a hidden class=anchor aria-hidden=true href=#최적화-전략>#</a></h4><table><thead><tr><th>영역</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>저장소 구조</strong></td><td>여러 작은 저장소로 분할 권장</td><td>저장소 크기 모니터링, 필요시 분할</td></tr><tr><td><strong>서버 설정</strong></td><td>Apache 튜닝, 캐시 최적화</td><td>서버 측 압축 설정, 웹 서버 최적화</td></tr><tr><td><strong>네트워크 최적화</strong></td><td>압축 활성화, HTTP 파이프라이닝</td><td>번들 사용, 압축 수준 조정</td></tr><tr><td><strong>대용량 파일</strong></td><td>외부 저장소, 바이너리 파일 분리</td><td>largefiles 확장, 바이너리 관리 정책</td></tr><tr><td><strong>정기 유지 관리</strong></td><td>저장소 압축, 불필요 파일 정리</td><td>저장소 압축(hg 컴팩션), 캐시 정리</td></tr></tbody></table><h4 id=마이그레이션-및-통합-고려사항>마이그레이션 및 통합 고려사항<a hidden class=anchor aria-hidden=true href=#마이그레이션-및-통합-고려사항>#</a></h4><table><thead><tr><th>측면</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>다른 시스템에서 이전</strong></td><td>단계적 전환, 이력 보존 방안 수립</td><td>SVN/Git에서 이전 도구 활용, 이력 변환</td></tr><tr><td><strong>CI/CD 통합</strong></td><td>Jenkins/TeamCity 등과 통합</td><td>확장 시스템 활용, CI/CD 파이프라인 통합</td></tr><tr><td><strong>IDE 통합</strong></td><td>대부분 IDE와 통합 지원</td><td>TortoiseHg, IDE 플러그인 활용</td></tr><tr><td><strong>라이선스 고려</strong></td><td>Apache 라이선스, 상업적 활용 자유</td><td>GPL v2+, 라이선스 영향 검토 필요</td></tr></tbody></table><h4 id=실제-사용-사례>실제 사용 사례<a hidden class=anchor aria-hidden=true href=#실제-사용-사례>#</a></h4><table><thead><tr><th>조직/프로젝트</th><th>사용 시스템</th><th>특이사항</th></tr></thead><tbody><tr><td>Apache 프로젝트</td><td>SVN</td><td>중앙 관리형 오픈소스 개발</td></tr><tr><td>Mozilla Firefox</td><td>Mercurial</td><td>대규모 분산 오픈소스 개발</td></tr><tr><td>엔터프라이즈 소프트웨어</td><td>SVN</td><td>엄격한 접근 제어, 감사 필요 환경</td></tr><tr><td>Facebook(일부)</td><td>Mercurial</td><td>대규모 코드베이스에 맞게 사용자화</td></tr><tr><td>게임 스튜디오</td><td>SVN</td><td>대용량 바이너리 에셋 관리</td></tr><tr><td>OpenJDK</td><td>Mercurial</td><td>분산 협업 중심 Java 개발</td></tr></tbody></table><h4 id=현대적-개발-환경에서의-위치>현대적 개발 환경에서의 위치<a hidden class=anchor aria-hidden=true href=#현대적-개발-환경에서의-위치>#</a></h4><table><thead><tr><th>측면</th><th>SVN</th><th>Mercurial</th></tr></thead><tbody><tr><td><strong>현재 시장 점유율</strong></td><td>전통적 기업 환경에서 여전히 사용</td><td>Git에 비해 점유율 감소 추세</td></tr><tr><td><strong>클라우드 통합</strong></td><td>제한적 클라우드 지원</td><td>다양한 클라우드 서비스 지원</td></tr><tr><td><strong>DevOps 친화성</strong></td><td>제한적 CI/CD 통합</td><td>확장성 있는 DevOps 파이프라인 통합</td></tr><tr><td><strong>신규 도입 추세</strong></td><td>감소 추세, 레거시 시스템 유지</td><td>일부 특수 환경에서 새로운 도입</td></tr><tr><td><strong>생태계 활성도</strong></td><td>안정적 유지보수 중심</td><td>활발한 개발 및 확장</td></tr></tbody></table><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><h4 id=svn의-작동-원리>SVN의 작동 원리<a hidden class=anchor aria-hidden=true href=#svn의-작동-원리>#</a></h4><p>SVN은 중앙 집중식 버전 관리 시스템으로 다음과 같은 원리로 작동한다:</p><ol><li><strong>저장소 구조</strong>: 중앙 서버에 모든 버전 정보와 이력이 저장된다.</li><li><strong>체크아웃</strong>: 개발자는 중앙 저장소의 특정 리비전을 로컬 작업 복사본으로 가져온다.</li><li><strong>변경 사항 추적</strong>: 로컬에서 파일을 수정하면 SVN 클라이언트가 변경 사항을 추적한다.</li><li><strong>업데이트</strong>: 개발자는 중앙 저장소의 최신 변경 사항을 로컬 작업 복사본에 업데이트한다.</li><li><strong>커밋</strong>: 개발자가 변경 사항을 중앙 저장소에 커밋하면, 새로운 리비전이 생성된다.</li><li><strong>델타 저장</strong>: 변경 사항은 델타(차이점)로 저장되어 공간을 절약한다.</li><li><strong>충돌 감지 및 해결</strong>: 여러 개발자가 동일한 파일을 수정할 때 발생하는 충돌을 감지하고 해결한다.</li></ol><p><strong>SVN 작동 원리 다이어그램</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[개발자 1 작업 복사본] &lt;---- 체크아웃/업데이트/커밋 ----&gt; [중앙 SVN 저장소] &lt;---- 체크아웃/업데이트/커밋 ----&gt; [개발자 2 작업 복사본]
</span></span></code></pre></td></tr></table></div></div><h4 id=mercurial의-작동-원리>Mercurial의 작동 원리<a hidden class=anchor aria-hidden=true href=#mercurial의-작동-원리>#</a></h4><p>Mercurial은 분산형 버전 관리 시스템으로 다음과 같은 원리로 작동한다:</p><ol><li><strong>저장소 복제</strong>: 개발자는 저장소의 전체 복사본을 로컬에 클론한다.</li><li><strong>로컬 작업</strong>: 모든 버전 관리 작업(커밋, 브랜치, 로그 보기 등)이 로컬에서 수행된다.</li><li><strong>체인지셋 생성</strong>: 변경 사항을 커밋하면 불변의 체인지셋이 생성된다.</li><li><strong>해시 기반 식별</strong>: 각 체인지셋은 SHA-1 해시로 고유하게 식별된다.</li><li><strong>푸시/풀</strong>: 개발자들은 저장소 간에 변경 사항을 푸시하거나 풀하여 동기화한다.</li><li><strong>병합</strong>: 여러 개발 라인을 병합할 때 자동 충돌 해결과 수동 개입을 조합하여 사용한다.</li><li><strong>저장소 그래프</strong>: 모든 커밋이 방향성 비순환 그래프(DAG)로 구성된다.</li></ol><p><strong>Mercurial 작동 원리 다이어그램</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[개발자 1 저장소 복사본] &lt;---- 푸시/풀 ----&gt; [중앙 저장소(선택적)] &lt;---- 푸시/풀 ----&gt; [개발자 2 저장소 복사본]
</span></span><span class=line><span class=cl>                                                   ^
</span></span><span class=line><span class=cl>                                                   |
</span></span><span class=line><span class=cl>                                                   v
</span></span><span class=line><span class=cl>                                        [개발자 3 저장소 복사본]
</span></span></code></pre></td></tr></table></div></div><h3 id=구성-요소-및-아키텍처>구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-요소-및-아키텍처>#</a></h3><h4 id=svn의-구성-요소-및-아키텍처>SVN의 구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#svn의-구성-요소-및-아키텍처>#</a></h4><p>SVN은 다음과 같은 주요 구성 요소로 이루어져 있다:</p><ol><li><strong>저장소(Repository)</strong>:<ul><li>기능: 모든 프로젝트 데이터와 이력 저장</li><li>역할: 버전 관리 데이터의 중앙 저장소 역할</li></ul></li><li><strong>저장소 백엔드(FSFS/BDB)</strong>:<ul><li>기능: 저장소 데이터의 물리적 저장</li><li>역할: 파일 시스템 기반(FSFS) 또는 Berkeley DB(BDB) 기반 저장 제공</li></ul></li><li><strong>서버 프로세스(svnserve/Apache)</strong>:<ul><li>기능: 저장소에 대한 네트워크 액세스 제공</li><li>역할: svn://, http://, https://, svn+ssh:// 등의 프로토콜 지원</li></ul></li><li><strong>클라이언트(svn 명령줄 도구, TortoiseSVN 등)</strong>:<ul><li>기능: 사용자 인터페이스 제공</li><li>역할: 저장소와 상호작용하는 명령 실행</li></ul></li><li><strong>작업 복사본(Working Copy)</strong>:<ul><li>기능: 로컬에서 파일 편집 제공</li><li>역할: 저장소의 특정 리비전 상태를 로컬에 유지</li></ul></li><li><strong>APR(Apache Portable Runtime)</strong>:<ul><li>기능: 크로스 플랫폼 호환성 제공</li><li>역할: 다양한 운영 체제에서 일관된 기능 보장</li></ul></li></ol><p><strong>SVN 아키텍처 다이어그램</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[클라이언트 측]                              [서버 측]
</span></span><span class=line><span class=cl>+----------------+                           +-----------------+
</span></span><span class=line><span class=cl>| SVN 명령줄 도구 |                           | Apache/svnserve |
</span></span><span class=line><span class=cl>+----------------+                           +-----------------+
</span></span><span class=line><span class=cl>        |                                            |
</span></span><span class=line><span class=cl>        v                                            v
</span></span><span class=line><span class=cl>+----------------+                           +-----------------+
</span></span><span class=line><span class=cl>|  작업 복사본    |&lt;--- 네트워크 프로토콜 ---&gt;   |     저장소       |
</span></span><span class=line><span class=cl>+----------------+    (http, svn, etc.)      +-----------------+
</span></span><span class=line><span class=cl>                                                     |
</span></span><span class=line><span class=cl>                                                     v
</span></span><span class=line><span class=cl>                                              +-----------------+
</span></span><span class=line><span class=cl>                                              | 저장소 백엔드   |
</span></span><span class=line><span class=cl>                                              | (FSFS/BDB)     |
</span></span><span class=line><span class=cl>                                              +-----------------+
</span></span></code></pre></td></tr></table></div></div><p>SVN(Subversion)은 일반적으로 다음과 같은 표준 디렉토리 구조를 사용한다:</p><ol><li><strong>트렁크(trunk)</strong>:<ul><li>기본 개발 라인을 나타낸다.</li><li>주요 개발 작업이 이루어지는 곳이다.</li><li>프로젝트의 현재 최신 상태를 나타낸다.</li><li>경로 예시: <code>/project/trunk/</code></li></ul></li><li><strong>브랜치(branches)</strong>:<ul><li>메인 개발 라인에서 분기한 별도의 개발 라인이다.</li><li>새로운 기능 개발, 버그 수정, 실험적 작업 등에 사용된다.</li><li>SVN에서 브랜치는 트렁크의 복사본으로 생성된다(실제로는 참조).</li><li>경로 예시: <code>/project/branches/feature-x/</code></li></ul></li><li><strong>태그(tags)</strong>:<ul><li>프로젝트의 특정 시점 스냅샷을 나타낸다.</li><li>주로 릴리스 버전을 표시하는 데 사용된다.</li><li>변경되지 않아야 하는 읽기 전용 참조이다.</li><li>경로 예시: <code>/project/tags/v1.0/</code></li></ul></li></ol><p>이 구조는 단순한 디렉토리 구조일 뿐, SVN이 이를 특별하게 처리하지는 않는다.<br>이는 관례적인 패턴으로, 개발자들이 이 구조를 준수함으로써 효율적인 버전 관리가 가능해진다.</p><p><strong>SVN의 트렁크/브랜치/태그 작업 흐름</strong>:</p><ol><li>개발자는 트렁크에서 일상적인 개발 작업을 수행한다.</li><li>새로운 기능 개발이 필요하면 트렁크에서 브랜치를 생성한다.</li><li>브랜치에서 개발이 완료되면 트렁크로 병합(merge)한다.</li><li>릴리스 시점에는 트렁크 또는 안정화된 브랜치를 태그로 복사한다.</li></ol><p>SVN에서 브랜치와 태그 생성은 <code>svn copy</code> 명령을 사용하며, 실제로는 파일을 복제하지 않고 저장소 내에서 참조만 생성하므로 공간 효율적이다. 그러나 브랜치 병합은 명시적으로 수행해야 하며, 복잡한 병합 시나리오에서는 충돌 해결이 어려울 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[SVN 저장소]
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  +-- trunk/
</span></span><span class=line><span class=cl>  |     |
</span></span><span class=line><span class=cl>  |     +-- src/
</span></span><span class=line><span class=cl>  |     +-- docs/
</span></span><span class=line><span class=cl>  |     +-- …
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  +-- branches/
</span></span><span class=line><span class=cl>  |     |
</span></span><span class=line><span class=cl>  |     +-- feature-a/
</span></span><span class=line><span class=cl>  |     |     |
</span></span><span class=line><span class=cl>  |     |     +-- src/
</span></span><span class=line><span class=cl>  |     |     +-- docs/
</span></span><span class=line><span class=cl>  |     |     +-- …
</span></span><span class=line><span class=cl>  |     |
</span></span><span class=line><span class=cl>  |     +-- bugfix-123/
</span></span><span class=line><span class=cl>  |           |
</span></span><span class=line><span class=cl>  |           +-- src/
</span></span><span class=line><span class=cl>  |           +-- …
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  +-- tags/
</span></span><span class=line><span class=cl>        |
</span></span><span class=line><span class=cl>        +-- v1.0.0/
</span></span><span class=line><span class=cl>        |     |
</span></span><span class=line><span class=cl>        |     +-- src/
</span></span><span class=line><span class=cl>        |     +-- docs/
</span></span><span class=line><span class=cl>        |     +-- …
</span></span><span class=line><span class=cl>        |
</span></span><span class=line><span class=cl>        +-- v1.1.0/
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              +-- …
</span></span></code></pre></td></tr></table></div></div><h4 id=mercurial의-구성-요소-및-아키텍처>Mercurial의 구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#mercurial의-구성-요소-및-아키텍처>#</a></h4><p>Mercurial은 다음과 같은 주요 구성 요소로 이루어져 있다:</p><ol><li><strong>저장소(.hg 디렉토리)</strong>:<ul><li>기능: 프로젝트의 모든 이력과 메타데이터 저장</li><li>역할: 로컬 작업 및 이력 관리의 기반 제공</li></ul></li><li><strong>스토어(Store)</strong>:<ul><li>기능: 파일 데이터 및 이력 정보의 물리적 저장</li><li>역할: 효율적인 델타 압축과 저장 제공</li></ul></li><li><strong>리비전 로그(Revlog)</strong>:<ul><li>기능: 파일 변경 이력 관리</li><li>역할: 델타 압축을 사용한 효율적인 이력 저장</li></ul></li><li><strong>디렉토리 매니페스트(Manifest)</strong>:<ul><li>기능: 각 리비전의 디렉토리 구조 추적</li><li>역할: 프로젝트 상태의 스냅샷 제공</li></ul></li><li><strong>클라이언트(hg 명령줄 도구, TortoiseHg 등)</strong>:<ul><li>기능: 사용자 인터페이스 제공</li><li>역할: 저장소 조작 명령 실행</li></ul></li><li><strong>확장 시스템(Extensions)</strong>:<ul><li>기능: 추가 기능 및 사용자 정의 확장 제공</li><li>역할: 기본 기능 확장 및 워크플로우 맞춤화</li></ul></li><li><strong>네트워크 레이어</strong>:<ul><li>기능: 저장소 간 통신 제공</li><li>역할: HTTP, SSH 등의 프로토콜을 통한 푸시/풀 지원</li></ul></li></ol><p><strong>Mercurial 아키텍처 다이어그램</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[로컬 저장소]
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>| 작업 디렉토리             |
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              v
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>| .hg 디렉토리 (저장소)     |
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>        |           |
</span></span><span class=line><span class=cl>        v           v
</span></span><span class=line><span class=cl>+--------------+  +--------------+
</span></span><span class=line><span class=cl>| 체인지셋 DB  |  | 매니페스트 DB |
</span></span><span class=line><span class=cl>+--------------+  +--------------+
</span></span><span class=line><span class=cl>        |           |
</span></span><span class=line><span class=cl>        v           v
</span></span><span class=line><span class=cl>+--------------+  +--------------+
</span></span><span class=line><span class=cl>|  파일 리비전 |  |  태그/브랜치 |
</span></span><span class=line><span class=cl>|    로그     |  |     정보     |
</span></span><span class=line><span class=cl>+--------------+  +--------------+
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              v
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>| 네트워크 레이어           |
</span></span><span class=line><span class=cl>+---------------------------+
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              v
</span></span><span class=line><span class=cl>[다른 저장소와의 상호작용]
</span></span></code></pre></td></tr></table></div></div><h3 id=mercurial-핵심-기능-및-cli>Mercurial 핵심 기능 및 CLI<a hidden class=anchor aria-hidden=true href=#mercurial-핵심-기능-및-cli>#</a></h3><p>Mercurial(hg)의 핵심 기능과 주요 명령줄 인터페이스(CLI) 명령어는 다음과 같다:</p><h4 id=핵심-기능>핵심 기능<a hidden class=anchor aria-hidden=true href=#핵심-기능>#</a></h4><ol><li><strong>분산 버전 관리</strong>:<ul><li>모든 개발자가 전체 저장소 복사본을 로컬에 보유</li><li>네트워크 연결 없이도 대부분의 작업 수행 가능</li></ul></li><li><strong>체인지셋 기반 관리</strong>:<ul><li>변경 사항이 원자적 체인지셋으로 관리됨</li><li>SHA-1 해시로 각 체인지셋 고유하게 식별</li></ul></li><li><strong>강력한 병합 지원</strong>:<ul><li>자동화된 3-way 병합 알고리즘</li><li>브랜치 간 원활한 병합 지원</li></ul></li><li><strong>확장 시스템</strong>:<ul><li>Python으로 작성된 확장 모듈 추가 가능</li><li>기본 기능 확장 및 사용자 정의 워크플로우 구성</li></ul></li><li><strong>이름 공간 기반 브랜치</strong>:<ul><li>네임드 브랜치: 이름이 있는 장기 브랜치</li><li>익명 헤드: 이름 없는 임시 개발 라인</li></ul></li><li><strong>푸시/풀 모델</strong>:<ul><li>저장소 간 변경 사항을 푸시하거나 풀하는 메커니즘</li><li>HTTP, HTTPS, SSH 등 다양한 프로토콜 지원</li></ul></li><li><strong>효율적인 저장 구조</strong>:<ul><li>리비전 로그(revlog) 기반 델타 압축 저장</li><li>파일 이름 변경 및 복사 자동 감지</li></ul></li><li><strong>웹 인터페이스</strong>:<ul><li>내장된 웹 서버로 저장소 브라우징 가능</li><li>그래프 형태의 이력 시각화</li></ul></li></ol><h4 id=주요-cli-명령어>주요 CLI 명령어<a hidden class=anchor aria-hidden=true href=#주요-cli-명령어>#</a></h4><ol><li><strong>저장소 생성 및 복제</strong>:<ul><li><code>hg init</code>: 새 저장소 생성</li><li><code>hg clone</code>: 원격 저장소 복제</li></ul></li><li><strong>변경 사항 관리</strong>:<ul><li><code>hg status</code>: 작업 디렉토리 상태 확인</li><li><code>hg diff</code>: 변경 사항 확인</li><li><code>hg add</code>: 파일을 버전 관리에 추가</li><li><code>hg remove</code>: 파일 제거</li><li><code>hg commit</code> 또는 <code>hg ci</code>: 변경 사항 커밋</li></ul></li><li><strong>이력 조회</strong>:<ul><li><code>hg log</code>: 커밋 이력 조회</li><li><code>hg summary</code>: 저장소 상태 요약</li><li><code>hg annotate</code>: 파일의 각 라인 작성자 표시</li><li><code>hg grep</code>: 이력에서 패턴 검색</li></ul></li><li><strong>원격 저장소 상호작용</strong>:<ul><li><code>hg pull</code>: 원격 저장소에서 변경 사항 가져오기</li><li><code>hg push</code>: 로컬 변경 사항을 원격 저장소로 보내기</li><li><code>hg incoming</code>: 수신 예정 변경 사항 확인</li><li><code>hg outgoing</code>: 발신 예정 변경 사항 확인</li></ul></li><li><strong>브랜치 및 병합</strong>:<ul><li><code>hg branch</code>: 현재 브랜치 표시 또는 새 브랜치 생성</li><li><code>hg branches</code>: 브랜치 목록 표시</li><li><code>hg merge</code>: 다른 브랜치 병합</li><li><code>hg update</code> 또는 <code>hg up</code>: 특정 리비전으로 작업 디렉토리 업데이트</li><li><code>hg resolve</code>: 병합 충돌 해결</li></ul></li><li><strong>태그 관리</strong>:<ul><li><code>hg tag</code>: 태그 생성</li><li><code>hg tags</code>: 태그 목록 표시</li></ul></li><li><strong>작업 되돌리기</strong>:<ul><li><code>hg revert</code>: 작업 디렉토리 변경 사항 되돌리기</li><li><code>hg backout</code>: 이전 커밋 효과 취소하는 새 커밋 생성</li><li><code>hg strip</code>: 커밋 제거(확장 필요)</li></ul></li><li><strong>고급 기능</strong>:<ul><li><code>hg bisect</code>: 이진 검색으로 버그 도입 시점 찾기</li><li><code>hg graft</code>: 특정 커밋 체리픽</li><li><code>hg shelve</code>: 작업 중인 변경 사항 임시 저장(확장 필요)</li><li><code>hg purge</code>: 추적되지 않는 파일 제거(확장 필요)</li></ul></li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th></tr></thead><tbody><tr><td>협업 모델</td><td>SVN은 중앙 집중형, Mercurial은 분산형 협업에 적합합니다.</td></tr><tr><td>브랜치 전략</td><td>Mercurial은 브랜치와 머징이 용이하므로, 복잡한 브랜치 전략에 유리합니다.</td></tr><tr><td>접근 제어</td><td>SVN은 중앙 서버에서 접근 제어가 용이합니다.</td></tr></tbody></table><h3 id=최신-동향과-앞으로의-전망-주목해야-할-기술들>최신 동향과 앞으로의 전망, 주목해야 할 기술들<a hidden class=anchor aria-hidden=true href=#최신-동향과-앞으로의-전망-주목해야-할-기술들>#</a></h3><p>2025년 기준으로 Git은 버전 관리 시스템 시장의 93% 이상을 차지하며, SVN은 약 20%, Mercurial은 5% 미만의 사용률을 보이고 있다.<br>SVN의 현재 위치: SVN은 대용량 코드베이스, 대형 바이너리 파일, 중앙 집중식 관리가 필요한 특정 산업(제조업, 반도체 설계, 게임 개발 등)에서 여전히 활발히 사용됨<br>Mercurial의 상태: 2020년 Bitbucket의 Mercurial 지원 중단 이후 사용률이 크게 감소했으며, 주로 소수의 특정 프로젝트에서만 사용되고 있음</p><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>원자적 커밋</td><td>여러 파일의 변경 사항이 하나의 단위로 처리되어 전체가 성공하거나 전체가 실패하는 특성</td></tr><tr><td>리비전 로그</td><td>저장소의 변경 이력을 저장하는 Mercurial의 핵심 데이터 구조</td></tr><tr><td>작업 복사본</td><td>SVN에서 중앙 저장소의 파일을 로컬에 복사하여 작업하는 공간</td></tr><tr><td>체인지셋</td><td>Mercurial에서 프로젝트 상태의 스냅샷과 메타데이터를 포함하는 불변의 단위</td></tr><tr><td>FSFS</td><td>SVN에서 사용하는 파일 시스템 기반 저장소 백엔드, Berkeley DB를 대체</td></tr><tr><td>매니페스트</td><td>Mercurial에서 각 버전의 디렉토리 구조를 추적하는 파일</td></tr><tr><td>병합 추적</td><td>이전 병합 작업을 기억하여 중복 병합이나 충돌을 줄이는 기능</td></tr><tr><td>충돌 해결</td><td>동일 파일에 대한 서로 다른 변경 사항이 충돌할 때 이를 해결하는 프로세스</td></tr><tr><td>후크 스크립트</td><td>특정 이벤트(커밋, 업데이트 등) 발생 시 자동으로 실행되는 스크립트</td></tr><tr><td>샌드박스</td><td>버전 관리 시스템에서 격리된 환경에서 변경을 테스트할 수 있는 공간</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://nulab.com/learn/software-development/git-vs-svn-version-control-system/>SVN vs Git 비교</a></li><li><a href=https://ericsink.com/vcbe/html/repository_structure.html>Mercurial revlog 구조</a></li><li><a href=https://rhodecode.com/blog/156/version-control-systems-popularity-in-2025>2025 VCS 시장 전망</a></li><li><a href=https://subversion.apache.org/>SVN 공식 문서</a></li><li><a href=https://svnbook.red-bean.com/>SVN Book (Red-Bean)</a></li><li><a href=https://www.mercurial-scm.org/>Mercurial 공식 문서</a></li><li><a href=https://www.mercurial-scm.org/doc/hg.1.html>Mercurial CLI Command Reference</a></li><li><a href=https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-vs-distributed>버전 관리 시스템 개요 (Atlassian Git Tutorials)</a></li><li><a href=https://stackoverflow.com/questions/3960051/compare-git-mercurial-and-svn>Comparing Version Control Systems: SVN, Mercurial, Git - Stack Overflow Discussion</a></li><li><a href=https://rhodecode.com/blog/156/version-control-systems-popularity-in-2025>RhodeCode 블로그: 2025년 버전 관리 시스템 인기도</a></li><li><a href=https://get.assembla.com/blog/is-subversion-svn-still-used/>Assembla 블로그: SVN은 여전히 사용되고 있는가?</a></li><li><a href=https://infra.apache.org/svn-basics.html>Apache 인프라 웹사이트: SVN 기본 사항</a></li><li><a href=https://www.timedoctor.com/blog/git-mecurial-and-cvs-comparison-of-svn-software/>버전 관리 소프트웨어 비교: SVN, Git, Mercurial</a></li><li><a href=https://wiki.mercurial-scm.org/WhatsNew>Mercurial의 최신 업데이트</a></li><li><a href=https://mindmajix.com/git-vs-svn>SVN vs Git 비교 가이드</a></li><li><a href=https://stackshare.io/stackups/mercurial-vs-svn>Mercurial vs SVN 비교 분석</a></li><li><a href=https://endoflife.date/subversion>Apache Subversion의 수명 주기 및 지원 일정</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/version-control-systems/>Version-Control-Systems</a></li><li><a href=https://buenhyden.github.io/tags/vcs-theory/>VCS-Theory</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branching-and-merging/><span class=title>« Prev</span><br><span>Branching and Merging</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/software-engineering-fundamentals/software-development-lifecycle/sdlc-phases/2-requirements-gathering-and-analysis/><span class=title>Next »</span><br><span>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>