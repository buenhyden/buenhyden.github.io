<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Hooks | hyunyoun's Blog</title>
<meta name=keywords content="DevOps-and-Infrastructure,Version-Control-Systems,Git-Workflow"><meta name=description content="Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git Hooks"><meta property="og:description" content="Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-28T12:38:00+00:00"><meta property="article:modified_time" content="2024-10-28T12:38:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="Version-Control-Systems"><meta property="article:tag" content="Git-Workflow"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git Hooks"><meta name=twitter:description content="Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps and Infrastructure","item":""},{"@type":"ListItem","position":3,"name":"Version Control Systems","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/"},{"@type":"ListItem","position":4,"name":"Git Workflow","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/"},{"@type":"ListItem","position":5,"name":"Git Hooks","item":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Hooks","name":"Git Hooks","description":"Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다.","keywords":["DevOps-and-Infrastructure","Version-Control-Systems","Git-Workflow"],"articleBody":"Git Hooks Git Hooks 는 Git 워크플로우의 특정 이벤트 (커밋, 푸시 등) 가 발생할 때 자동으로 실행되는 사용자 정의 스크립트이다. 이 스크립트들은 소스 코드 관리, 품질 보증, 배포 자동화 등 다양한 목적으로 활용된다. Git Hooks 는 클라이언트 측과 서버 측으로 나뉘며, 로컬 개발 환경에서의 코드 검증부터 원격 저장소에서의 배포 자동화까지 광범위한 워크플로우를 지원한다. 이를 통해 개발자들은 코딩 표준 준수, 테스트 자동화, 지속적 통합/배포 등을 효율적으로 구현할 수 있다.\n핵심 개념 Git Hooks 는 Git 작업 이벤트 트리거에 반응하는 자동화 스크립트이다. .git/hooks 디렉토리에 위치하며, 실행 가능한 권한이 부여된 스크립트 파일 형태로 존재한다. 이벤트는 커밋 생성, 브랜치 전환, 원격 저장소로의 푸시 등 Git 워크플로우의 다양한 시점에서 발생할 수 있으며 사전/사후 작업을 실행한다.\n1 2 3 # 예시: pre-commit 훅 #!/bin/sh npm run lint # 커밋 전 린트 실행 목적 Git Hooks 의 주요 목적은 다음과 같다:\n개발 워크플로우 자동화 코드 품질 및 일관성 유지 테스트 자동화 배포 프로세스 간소화 팀 협업 효율성 증대 보안 취약점 검사 자동화 필요성 Git Hooks 는 다음과 같은 이유로 필요하다:\n인적 오류 감소 - 수동 검사를 자동화하여 실수 방지 일관된 코드 품질 보장 - 모든 코드 변경에 동일한 검증 적용 개발 속도 향상 - 반복적인 작업 자동화 팀 표준 강제화 - 모든 팀원이 동일한 규칙 준수 배포 위험 감소 - 검증되지 않은 코드의 배포 방지 주요 기능 Git Hooks 의 주요 기능은 다음과 같다:\n코드 스타일 검사 (linting) 자동 테스트 실행 커밋 메시지 형식 검증 브랜치 명명 규칙 강제 금지된 파일 형식 차단 배포 자동화 외부 시스템 통합 (CI/CD, 이슈 트래커 등) 역할 Git Hooks 는 개발 프로세스에서 다음과 같은 역할을 수행한다:\n게이트키퍼 - 품질 기준을 충족하지 않는 코드의 저장소 진입 차단 자동화 도구 - 반복적인 작업 자동 실행 통합 지점 - 외부 시스템과 Git 워크플로우 연결 정책 시행자 - 팀의 코딩 표준 및 관행 강제화 알림 시스템 - 중요 이벤트 발생시 팀원에게 통지 특징 Git Hooks 의 주요 특징은 다음과 같다:\n사용자 정의 가능성 - 어떤 프로그래밍 언어로도 작성 가능 이식성 - 모든 Git 저장소에서 작동 유연성 - 다양한 워크플로우 단계에서 실행 가능 확장성 - 외부 도구와 쉽게 통합 선택적 사용 - 필요한 훅만 활성화 가능 로컬 및 서버 측 지원 - 개발자 워크스테이션과 원격 저장소 모두에서 사용 가능 핵심 원칙 Git Hooks 사용의 핵심 원칙은 다음과 같다:\n\" 코드에 문제가 있다면 일찍 찾아내라 “ - 문제가 확산되기 전에 조기 발견 자동화 우선 - 수동 과정보다 자동화된 프로세스 선호 실패는 빠르게 - 문제가 있다면 프로세스 초기에 실패하도록 설계 일관성 유지 - 모든 개발자가 동일한 검증 과정 통과 적절한 피드백 - 문제 발생 시 명확한 오류 메시지 제공 작동 원리 이벤트 기반 실행: Git 의 특정 이벤트 발생 시 해당하는 Hook 스크립트가 자동으로 실행된다. 스크립트 실행 흐름: 예를 들어, pre-commit Hook 은 git commit 명령 실행 시 커밋이 완료되기 전에 실행된다. 실행 결과에 따른 동작 제어: Hook 스크립트의 종료 상태에 따라 Git 명령의 실행 여부가 결정된다.\n작동 원리 다이어그램 flowchart TD A[Git 이벤트 발생] --\u003e B{해당 훅 스크립트 존재?} B -- 예 --\u003e C[스크립트 실행] C --\u003e D{성공?} D -- 예 --\u003e E[다음 단계 진행] D -- 아니오 --\u003e F[작업 중단] B -- 아니오 --\u003e E 구성 요소 및 아키텍처 Git Hooks 의 구성 요소 및 아키텍처는 다음과 같다:\n구성 요소 설명 역할 기능 예시 훅 스크립트 파일 .git/hooks 디렉토리에 위치한 실행 파일 Git 이벤트 발생 시 자동 실행 코드 검증, 테스트 실행, 메시지 형식 검사 등 Git 저장소 .git 디렉토리를 포함한 프로젝트 폴더 훅 설정 및 실행 환경 제공 버전 관리, 이벤트 트리거링 클라이언트 측 훅 로컬 환경에서 실행되는 훅 개발 중 코드 품질 사전 검증 커밋 전 검사, 메시지 포맷팅, 푸시 전 테스트 등 pre-commit, commit-msg, pre-push 서버 측 훅 원격 저장소 (Git 서버) 에서 실행되는 훅 조직 정책 강제 및 배포 연계 푸시 수신 검증, 브랜치 보호, 자동 배포 등 pre-receive, update, post-receive 훅 관리 도구 Husky, pre-commit, Lefthook 등 팀 단위에서의 훅 일관성 유지 훅 공유, 설정 자동화, 실행 환경 표준화 장점과 단점 구분 항목 설명 ✅ 장점 자동화 반복 작업 자동 처리, 생산성 향상 표준화 팀 규칙 강제, 코드 품질 일관성 유지 코드 품질 향상 일관된 코드 스타일과 표준을 강제하여 품질 향상 오류 감소 커밋이나 푸시 전에 문제를 감지하여 버그 유입 방지 CI/CD 파이프라인 강화 지속적 통합 및 배포 프로세스를 보완하고 강화 유연성 어떤 프로그래밍 언어로도 작성 가능하며 다양한 용도로 활용 ⚠ 단점 공유 어려움 .git/hooks 는 기본적으로 버전 관리 미지원 보안 위험 악성 스크립트 실행 가능성 과도한 제약 가능성 너무 엄격한 훅은 개발 생산성을 저하시킬 수 있음 유지보수 부담 시간이 지남에 따라 훅 스크립트 자체의 유지보수가 필요 디버깅 어려움 훅 실패 시 원인 파악이 복잡할 수 있음 성능 영향 복잡한 훅은 Git 작업 속도를 현저히 저하시킬 수 있음 클라이언트 vs. 서버 훅 비교 구분 클라이언트 훅 서버 훅 실행 위치 로컬 저장소 원격 저장소 서버 주요 이벤트 커밋, 머지, 푸시 전 푸시 수신 후 목적 개인 작업 표준화 팀 정책 강제 분류에 따른 종류 및 유형 분류 훅 이름 설명 실행 시점 클라이언트 측 pre-commit 커밋 생성 전 실행 git commit 명령 후, 커밋 메시지 입력 전 prepare-commit-msg 커밋 메시지 템플릿 준비 커밋 메시지 편집기 실행 전 commit-msg 커밋 메시지 검증 커밋 메시지 작성 후, 커밋 완료 전 post-commit 커밋 완료 후 알림 커밋 완료 직후 pre-rebase 리베이스 작업 전 검증 git rebase 명령 실행 전 post-rewrite 커밋 수정 명령 후 실행 git commit --amend 또는 git rebase 이후 pre-push 원격 저장소 푸시 전 검증 git push 실행 전, 원격 참조 업데이트 전 post-checkout 체크아웃 후 작업 환경 설정 git checkout 또는 git switch 이후 post-merge 병합 후 작업 환경 설정 git merge 완료 후 pre-auto-gc 가비지 컬렉션 전 검증 git gc --auto 실행 전 fsmonitor-watchman 파일 시스템 모니터링 설정 git status 와 같은 명령 성능 향상에 사용 서버 측 pre-receive 푸시 데이터 수신 전 검증 푸시 데이터를 수신하기 전, 모든 참조에 대해 한 번 update 개별 참조 업데이트 검증 업데이트되는 각 참조 (브랜치나 태그) 에 대해 실행 post-receive 모든 참조 업데이트 후 실행 푸시 프로세스 완료 후 한 번 실행 post-update 참조 업데이트 후 알림 업데이트된 모든 참조에 대해 한 번 실행 reference-transaction 참조 업데이트 트랜잭션 처리 참조가 변경될 때마다 실행 pre-auto-gc 자동 가비지 컬렉션 전 검증 서버의 git gc --auto 실행 전 이메일 워크플로우 applypatch-msg 패치 적용 메시지 검증 git am 실행 시 pre-applypatch 패치 적용 전 검증 패치 적용 후, 커밋 생성 전 post-applypatch 패치 적용 후 알림 git am 완료 후 실무 적용 예시 적용 사례 사용 훅 설명 이점 코드 스타일 검사 pre-commit ESLint, Prettier 등을 사용해 코드 스타일 검사 일관된 코드 스타일 유지, 리뷰 부담 감소 테스트 자동화 pre-push 유닛 테스트, 통합 테스트 자동 실행 테스트 실패한 코드의 저장소 반영 방지 커밋 메시지 표준화 commit-msg 커밋 메시지가 정해진 형식 (예: 컨벤셔널 커밋) 을 따르는지 검사 변경 이력 가독성 향상, 자동 버전 관리 지원 보안 취약점 검사 pre-commit, pre-push 의존성 패키지의 보안 취약점 검사 보안 위험 조기 감지 자동 배포 post-receive CI/CD 파이프라인 트리거, 서버 환경 자동 업데이트 배포 프로세스 간소화 이슈 트래커 연동 prepare-commit-msg 브랜치 이름에서 이슈 번호를 추출하여 커밋 메시지에 자동 추가 코드와 이슈 추적 시스템 연계 강화 문서 자동 생성 post-commit, post-receive API 문서, CHANGELOG 등 자동 업데이트 문서의 최신 상태 유지 데이터베이스 마이그레이션 post-checkout, post-merge 브랜치 전환 또는 병합 후 자동으로 DB 스키마 업데이트 개발 환경 일관성 유지 환경 변수 검증 pre-commit 민감한 정보 (API 키, 비밀번호 등) 가 커밋되지 않도록 방지 보안 강화, 민감 정보 유출 방지 성능 테스트 pre-push 주요 기능의 성능 회귀 테스트 자동 실행 성능 저하 조기 탐지 샘플 Git Hook 스크립트 (pre-commit 예시) 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh # .git/hooks/pre-commit echo \"🔍 Running lint check before commit...\" npx eslint . --ext .js,.jsx,.ts,.tsx if [ $? -ne 0 ]; then echo \"❌ Lint errors detected. Commit aborted.\" exit 1 fi echo \"✅ Lint passed. Proceeding with commit.\" 실행 전 반드시 chmod +x.git/hooks/pre-commit 로 실행 권한 부여 필요.\nPre-commit 프레임워크 구성 예시 (Python 기반) pre-commit 설치\n1 pip install pre-commit .pre-commit-config.yaml 구성\n1 2 3 4 5 6 7 8 9 10 11 12 repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.5.0 hooks: - id: trailing-whitespace - id: end-of-file-fixer - id: check-yaml - repo: https://github.com/psf/black rev: 23.7.0 hooks: - id: black language_version: python3 설치 및 적용\n1 2 pre-commit install # git hook에 자동 등록 pre-commit run --all-files # 수동 실행 이 방식은 팀 내에서 hook 구성 공유를 YAML 로 하고, 자동 배포까지 가능하다는 장점이 있다.\nHusky 연동 예제 (Node.js 기반) 설치 및 초기화\n1 2 npm install husky --save-dev npx husky install package.json 에 postinstall 스크립트 추가:\n1 2 3 \"scripts\": { \"prepare\": \"husky install\" } Hook 추가\n1 npx husky add .husky/pre-commit \"npm run lint \u0026\u0026 npm test\" 생성된 .husky/pre-commit 파일 예시:\n1 2 3 4 5 6 #!/bin/sh . \"$(dirname \"$0\")/_/husky.sh\" echo \"✅ Husky pre-commit 실행 중...\" npm run lint npm test Lefthook 연동 예제 (언어 독립형) 설치\n1 2 3 brew install lefthook # macOS # 또는 gem install lefthook # Ruby 기반 환경 초기화 및 설정\n1 lefthook install .lefthook.yml 설정 파일 예시:\n1 2 3 4 5 6 7 pre-commit: parallel: true commands: lint: run: npx eslint . test: run: npm test .git/hooks/ 가 자동으로 Lefthook 에 의해 관리된다.\n실행 확인\n1 lefthook run pre-commit Git-secrets 연동 예제 (AWS 키 및 민감정보 방지) 설치\n1 2 3 git clone https://github.com/awslabs/git-secrets.git cd git-secrets make install Git 저장소에 Hook 설정\n1 2 git secrets --install git secrets --register-aws ~/.git-templates 또는 전역 hook 으로도 설정 가능\n사용자 정의 정규식 추가 예시\n1 2 git secrets --add 'PRIVATE_KEY' git secrets --add 'apikey_[0-9a-f]{32}' 검사 실행\n1 git secrets --scan 커밋 전 민감한 정보가 있는지 검사하며, 발견 시 커밋이 차단된다.\n도구 비교 요약 도구 특징 주요 사용 환경 Husky Node.js 프로젝트에 적합, 간단한 CLI 프론트엔드, JS 기반 프로젝트 Lefthook 언어 독립, 병렬 실행, 빠른 성능 Monorepo, 다중 언어 환경 git-secrets 민감정보 탐지, 보안 강화 AWS 환경, 보안 규정 있는 조직 CI 환경 GitHub Actions 의 .github/workflows 디렉토리에서 Git Hooks 와 통합된 자동화 예제.\n목적\n로컬 개발자는 pre-commit Git Hook 으로 코드 스타일과 테스트를 체크 GitHub Actions 에서는 PR 이나 push 시 동일한 검사를 자동 수행 디렉토리 구조 예시\n1 2 3 4 5 . ├── .pre-commit-config.yaml └── .github └── workflows └── pre-commit.yml .pre-commit-config.yaml 예시\n1 2 3 4 5 6 7 8 9 10 repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.5.0 hooks: - id: trailing-whitespace - id: end-of-file-fixer - repo: https://github.com/psf/black rev: 24.3.0 hooks: - id: black .github/workflows/pre-commit.yml 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 name: pre-commit checks on: pull_request: push: branches: [main, develop] jobs: lint-and-format: name: Run pre-commit hooks runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 with: python-version: '3.11' - name: Install dependencies run: | python -m pip install --upgrade pip pip install pre-commit - name: Run pre-commit hooks run: pre-commit run --all-files 주요 구성 해설\n항목 설명 on push, pull_request 이벤트 발생 시 실행 runs-on GitHub 의 Ubuntu 러너 사용 setup-python Python 기반의 pre-commit 도구 환경 구성 pre-commit run --all-files 전체 파일 대상 Hook 실행 📌 실무 팁 항목 내용 공유 유지 .pre-commit-config.yaml 은 버전 관리되므로, 팀 전체에 공통 정책 적용 가능 재현성 확보 GitHub Actions 에서도 동일한 Hook 실행 → CI 와 로컬의 결과 불일치 최소화 병렬 실행 고려 복잡한 작업은 pre-commit 에서 parallel: true 설정 지원 활용 예시 및 다이어그램 1 2 3 4 5 6 [개발자 로컬] pre-commit → 린트/테스트 → 실패 시 커밋 차단 ↘ 성공 시 커밋 완료 → 원격 저장소 푸시 [서버] pre-receive → 코드 검증 → 승인 시 배포 파이프라인 실행 활용 예시: 린트 / 테스트 상황: 팀에서 코드 품질을 유지하기 위해 커밋 전 린트와 테스트를 자동 실행하고, 실패 시 커밋을 막고 싶다. sequenceDiagram participant 개발자 participant Git participant 훅 스크립트 개발자-\u003e\u003eGit: git commit 실행 Git-\u003e\u003e훅 스크립트: pre-commit 훅 실행 훅 스크립트-\u003e\u003eGit: 린트/테스트 결과 반환 alt 성공 Git-\u003e\u003e개발자: 커밋 성공 else 실패 Git-\u003e\u003e개발자: 커밋 차단, 오류 메시지 출력 end 활용 예시: 지속적 통합 파이프라인 구축 시나리오: 개발자가 새로운 기능을 개발하고 이를 팀의 저장소에 통합하는 과정\n개발자가 로컬에서 코드 작성 커밋 시도 → pre-commit 훅 실행 (코드 린팅, 포맷팅) 커밋 메시지 작성 → commit-msg 훅 실행 (커밋 메시지 형식 검증) 원격 저장소 푸시 시도 → pre-push 훅 실행 (단위 테스트 실행) 푸시 데이터 서버 도착 → pre-receive 훅 실행 (브랜치 권한 검사) 브랜치 업데이트 → update 훅 실행 (특정 파일 변경 검증) 모든 검증 완료 → post-receive 훅 실행 (CI 시스템 트리거) CI 시스템에서 통합 테스트, 보안 검사 실행 모든 검증 통과 시 자동 배포 진행 3-9. 실무 적용 고려사항 및 주의점 항목 내용 공유 전략 core.hooksPath 설정, Husky(허스키) 등 도구 사용 크로스 플랫폼 OS 별 스크립트 호환성 고려 보안 스크립트 검증 및 실행 권한 관리 유지보수 훅 스크립트의 주기적 업데이트 및 테스트 필요 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 고려사항 설명 해결 방안 팀 전체 공유 Git 훅은 기본적으로 로컬에 저장되어 공유되지 않음 Husky, pre-commit 같은 도구를 통해 패키지 관리자와 통합하여 설정 공유 성능 최적화 무거운 검사는 커밋/푸시 과정을 지연시킬 수 있음 필수적인 검사만 pre-commit 에 포함, 나머지는 pre-push 나 CI 단계로 이동 우회 가능성 --no-verify 플래그로 클라이언트 측 훅을 우회할 수 있음 서버 측 훅과 함께 사용하여 중요한 검증 강제화 훅 디버깅 훅 실패 시 원인 파악이 어려울 수 있음 상세한 오류 메시지 제공, 로깅 기능 추가 다양한 개발 환경 팀원마다 다른 OS 환경에서 동일한 훅이 작동해야 함 크로스 플랫폼 스크립트 작성 또는 Docker 컨테이너 활용 새 팀원 온보딩 새 개발자가 프로젝트 설정에 익숙해져야 함 명확한 문서화, 자동화된 설정 스크립트 제공 점진적 도입 한번에 많은 훅을 도입하면 팀의 저항을 불러일으킬 수 있음 가장 가치 있는 훅부터 점진적으로 도입 예외 상황 처리 특정 상황에서는 검증을 건너뛰어야 할 필요가 있음 조건부 검사 로직 구현, 긴급 상황용 우회 메커니즘 마련 훅 테스트 훅 자체에 버그가 있을 수 있음 훅 스크립트에 대한 테스트 코드 작성 버전 관리 훅 스크립트의 변경 이력을 추적해야 함 훅 스크립트를 별도 저장소나 프로젝트 내 디렉토리에서 관리 Git Hooks 공유 및 관리 도구 Git Hooks 를 팀 전체에서 효과적으로 공유하고 관리하기 위한 도구들이 있다:\nHusky: npm 기반 프로젝트에서 Git Hooks 를 쉽게 설정하고 공유할 수 있는 도구 pre-commit: 다양한 언어와 도구에 대한 훅 관리를 제공하는 프레임워크 Lefthook: 빠르고 강력한 Git Hooks 관리자 githooks: 팀 전체에서 훅을 공유하기 위한 간단한 솔루션 git-hooks: 분산된 훅 관리를 위한 도구 CI/CD 시스템과의 통합 Git Hooks 는 CI/CD 시스템과 효과적으로 통합할 수 있다:\n진입점 검증: 로컬 훅으로 기본적인 검증을 수행하고 CI 시스템에서 더 철저한 검증 CI 트리거: post-receive 훅을 사용하여 CI 파이프라인 자동 트리거 결과 피드백: CI 결과를 Git 워크플로우에 통합하여 피드백 루프 강화 멀티환경 지원 다양한 개발 환경에서 Git Hooks 를 일관되게 사용하기 위한 방법:\n셸 스크립트 대신 고급 언어 사용: Python, Node.js 등 크로스 플랫폼 언어 활용 Docker 컨테이너 활용: 일관된 실행 환경 제공 환경 감지 및 적응: 실행 환경에 따라 다른 명령어 실행 성능을 최적화하기 위한 고려사항 및 주의할 점 검사 범위 최소화: 변경된 파일만 검사하여 불필요한 처리 방지\n1 2 3 4 5 6 7 # 변경된 파일만 lint 검사 예시 STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\\.js$') if [ \"$STAGED_FILES\" = \"\" ]; then exit 0 fi eslint $STAGED_FILES 단계적 검증 전략: 가벼운 검사는 pre-commit 에, 무거운 검사는 pre-push 에 배치\n병렬 처리: 독립적인 검사는 병렬로 실행하여 시간 단축\n1 2 # 병렬 처리 예시 npm run lint \u0026 npm run type-check \u0026 wait 캐싱 활용: 이전에 검증된 파일의 결과를 캐싱하여 재사용\n1 2 # ESLint 캐싱 예시 eslint --cache . 점진적 검증: 전체 검증은 CI 서버에서 수행하고, 로컬에서는 최소 검증\n타임아웃 설정: 무한 루프 방지를 위한 타임아웃 메커니즘 구현\n리소스 사용량 모니터링: 메모리, CPU 사용량을 주기적으로 확인하여 최적화\n최신 동향 주제 항목 설명 자동화 GitOps 와 Git Hooks 통합 GitOps 워크플로우에서 Git Hooks 가 중요한 구성 요소로 자리 잡고 있으며, 인프라 변경 검증에 활용되고 있습니다. 보안 보안 중심 Git Hooks 소프트웨어 공급망 보안이 중요해짐에 따라 의존성 취약점 검사, 자격 증명 유출 방지, 코드 보안 분석을 자동화하는 훅이 표준화되고 있습니다. 표준화 언어별 표준 훅 템플릿 프로그래밍 언어와 프레임워크별로 최적화된 표준 Git Hooks 템플릿이 등장하여 개발자들이 쉽게 채택할 수 있게 되었습니다. 통합 AI 코드 리뷰 통합 AI 기반 코드 리뷰 도구가 Git Hooks 와 통합되어 커밋 전에 자동으로 코드 품질, 보안 취약점, 성능 문제를 분석하고 개선 제안을 제공합니다. 성능 경량화 및 성능 개선 증분 분석과 캐싱 기술의 발전으로 Git Hooks 의 실행 시간이 크게 단축되었으며, 대규모 프로젝트에서도 원활하게 작동합니다. 개발자 경험 인터랙티브 Git Hooks 개발자에게 더 나은 피드백을 제공하는 인터랙티브 훅이 등장하여, 문제 발생 시 자동 수정 제안이나 시각적 피드백을 제공합니다. 클라우드 클라우드 네이티브 훅 클라우드 네이티브 환경에 최적화된 Git Hooks 가 개발되어 Kubernetes 매니페스트 검증, 클라우드 리소스 정책 준수 확인 등을 자동화합니다. 관리 Git Hooks-as-a-Service 기업용 Git Hooks 관리 서비스가 등장하여 조직 전체의 훅 정책을 중앙에서 관리하고 모니터링할 수 있게 되었습니다. 주목해야 할 기술 주제 항목 설명 클라우드 연계 서버리스 훅 클라우드 함수로 훅 실행, 유지보수 용이 자동화 Git Hooks 오케스트레이션 다양한 훅을 조직화하고 상호작용을 관리하는 고급 오케스트레이션 도구가 개발되고 있습니다. 인공지능 AI 기반 코드 검증 머신러닝 모델을 활용해 코드 패턴을 학습하고 버그, 보안 취약점, 성능 이슈를 예측하는 훅이 주목받고 있습니다. 컴플라이언스 규제 준수 자동화 금융, 의료 등 규제가 엄격한 산업에서 컴플라이언스 요구사항을 자동으로 검증하는 특수 목적 훅이 발전하고 있습니다. 보안 SBOM 생성 및 검증 소프트웨어 자재명세서 (SBOM) 생성 및 검증을 자동화하는 훅이 개발되어 소프트웨어 공급망 보안을 강화합니다. 보안 코드 서명 훅 스크립트 무결성 검증 협업 분산 팀 최적화 원격/분산 팀을 위한 협업 최적화 훅이 개발되어 시간대와 지역에 관계없이 일관된 개발 경험을 제공합니다. 앞으로의 전망 주제 항목 설명 자동화 전체 SDLC 통합 Git Hooks 가 소프트웨어 개발 수명 주기 (SDLC) 전반에 더 깊이 통합되어 요구사항부터 배포, 모니터링까지 자동화할 것으로 예상됩니다. 지능화 적응형 Git Hooks 프로젝트와 개발자의 패턴을 학습하여 최적의 검증 전략을 자동으로 조정하는 적응형 훅이 등장할 것으로 예상됩니다. 표준화 산업별 표준 확립 각 산업 분야에 최적화된 Git Hooks 표준이 확립되어 모범 사례가 널리 공유될 것으로 예상됩니다. 통합 개발 도구 생태계 통합 Git Hooks 가 IDE, 코드 에디터, 이슈 트래커, 지식 관리 시스템 등과 더욱 긴밀하게 통합될 것으로 예상됩니다. 확장 비개발 영역으로 확장 Git Hooks 의 개념이 소프트웨어 개발을 넘어 문서 관리, 디자인 시스템, 데이터 파이프라인 등으로 확장될 것으로 예상됩니다. 하위 주제로 분류하여 추가 학습 내용 카테고리 주제 설명 기초 Git Hooks 설정 기초 Git Hooks 의 기본 설정 방법, 활성화/비활성화, 권한 설정 등 기초 지식 기초 프로그래밍 언어별 Git Hooks 다양한 언어 (Bash, Python, JavaScript 등) 로 Git Hooks 작성하기 도구 Husky 깊게 알아보기 JavaScript 프로젝트에서 가장 널리 사용되는 Git Hooks 관리 도구 마스터하기 도구 pre-commit 프레임워크 다양한 언어 지원이 가능한 pre-commit 프레임워크 활용법 고급 서버 측 Git Hooks 심화 깃랩, 깃허브 등 Git 호스팅 서비스에서의 서버 측 훅 구현 고급 CI/CD 파이프라인과 Git Hooks 통합 Jenkins, GitHub Actions, GitLab CI 등과 Git Hooks 연동 방법 고급 대규모 조직에서의 Git Hooks 관리 수백 개의 저장소와 개발자가 있는 환경에서 Git Hooks 관리 전략 보안 보안 중심 Git Hooks 구현 취약점 스캐닝, 비밀 정보 유출 방지, SAST/DAST 통합 성능 Git Hooks 성능 최적화 대규모 코드베이스에서 Git Hooks 성능 병목 현상 해결 방법 사례 연구 산업별 Git Hooks 사례 연구 금융, 의료, 정부 등 다양한 산업에서의 Git Hooks 적용 사례 추가 학습 내용 카테고리 주제 설명 연관 기술 GitOps Git 을 중심으로 한 운영 워크플로우와 Git Hooks 의 역할 연관 기술 정적 코드 분석 Git Hooks 와 함께 활용할 수 있는 정적 코드 분석 도구와 방법론 연관 기술 코드 품질 메트릭스 Git Hooks 로 측정 및 관리할 수 있는 코드 품질 지표 개발 방법론 TDD 와 Git Hooks 테스트 주도 개발에서 Git Hooks 를 활용하는 방법 개발 방법론 지속적 품질 관리 Git Hooks 를 활용한 지속적인 코드 품질 관리 전략 도구 통합 Docker 와 Git Hooks 컨테이너화된 환경에서 Git Hooks 구현 전략 도구 통합 코드 리뷰 도구와 Git Hooks Git Hooks 와 코드 리뷰 프로세스 및 도구 통합 관리 Git Hooks 모니터링 Git Hooks 실행 현황 및 효과 모니터링 방법 관리 Git Hooks 문서화 팀 내 Git Hooks 사용 문서화 및 지식 공유 전략 성능 Git Hooks 벤치마킹 Git Hooks 성능 측정 및 비교 방법론 용어 정리 용어 설명 Husky Git Hooks 를 손쉽게 관리하고 팀에 공유할 수 있게 해주는 도구 Lefthook 멀티 플랫폼 지원 훅 관리 도구 core.hooksPath Git 훅 디렉토리 경로를 지정하는 Git 설정 옵션 용어 정리 용어 설명 pre-receive 서버 측 훅: 푸시된 커밋 전체 검증 Husky Git Hooks 관리 도구: 패키지.json 에 훅 설정 가능 용어 정리 용어 설명 Hook 특정 이벤트 발생 시 자동으로 실행되는 스크립트 pre-commit 커밋 전에 실행되는 Hook 스크립트 commit-msg 커밋 메시지를 검사하는 Hook pre-receive 원격 저장소에서 푸시 전에 실행되는 서버 측 Hook core.hooksPath 공통 Hook 디렉토리를 지정할 수 있는 Git 설정 항목 용어 정리 용어 설명 Git Hooks Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트 클라이언트 측 훅 로컬 개발 환경에서 실행되는 Git Hooks 로, 개발자의 워크스테이션에서 작동 서버 측 훅 원격 저장소에서 실행되는 Git Hooks 로, 저장소 관리자가 설정하고 모든 사용자에게 적용 pre-commit 커밋이 생성되기 전에 실행되는 훅으로, 코드 검증에 주로 사용 pre-push 원격 저장소로 푸시하기 전에 실행되는 훅으로, 광범위한 테스트에 활용 post-receive 원격 저장소에서 푸시 작업이 완료된 후 실행되는 훅으로, 배포 자동화에 주로 사용 Husky npm 기반 프로젝트에서 Git Hooks 를 쉽게 설정하고 관리할 수 있는 도구 lint-staged 스테이징된 파일에 대해서만 linter 를 실행하는 도구로, Git Hooks 와 함께 자주 사용 pre-commit 프레임워크 다양한 언어와 도구에 대한 훅 관리를 제공하는 Python 기반 프레임워크 Conventional Commits 커밋 메시지에 대한 규약으로, Git Hooks 를 통해 강제할 수 있음 참고 및 출처 Git 공식 문서 - Git Hooks\nHusky 공식 문서\npre-commit 공식 사이트\nGitHub Actions Docs\n참고 및 출처 Git 공식 문서 Atlassian Git 튜토리얼 2025 DevOps 트렌드 분석 참고 및 출처 Git 공식 문서: Git Hooks Atlassian Git Hooks 가이드 Husky 공식 문서 2025 DevOps 트렌드 분석 참고 및 출처 Git Hooks 공식 문서 Pro Git Book - Git Hooks 섹션 Atlassian Git Hooks 튜토리얼 Husky - Git Hooks 관리 도구 pre-commit 프레임워크 문서 GitLab Server Hooks 문서 GitHub Actions와 Git Hooks 통합 가이드 Git Hooks를 활용한 코드 품질 관리 Lefthook - 빠른 Git Hooks 관리자 Git Hooks와 지속적 통합 파이프라인 구축 ","wordCount":"3573","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-28T12:38:00Z","dateModified":"2024-10-28T12:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href>DevOps and Infrastructure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/>Version Control Systems</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/>Git Workflow</a></div><h1 class="post-title entry-hint-parent">Git Hooks</h1><div class=post-description>Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다.</div><div class=post-meta><span title='2024-10-28 12:38:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/DevOps%20and%20Infrastructure/Version%20Control%20Systems/Git%20Workflow/git-hooks.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git-hooks>Git Hooks</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#목적>목적</a></li><li><a href=#필요성>필요성</a></li><li><a href=#주요-기능>주요 기능</a></li><li><a href=#역할>역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#구성-요소-및-아키텍처>구성 요소 및 아키텍처</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#클라이언트-vs-서버-훅-비교>클라이언트 vs. 서버 훅 비교</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-예시-및-다이어그램>활용 예시 및 다이어그램</a></li><li><a href=#3-9-실무-적용-고려사항-및-주의점>3-9. 실무 적용 고려사항 및 주의점</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#성능을-최적화하기-위한-고려사항-및-주의할-점>성능을 최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#주목해야-할-기술>주목해야 할 기술</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#하위-주제로-분류하여-추가-학습-내용>하위 주제로 분류하여 추가 학습 내용</a></li><li><a href=#추가-학습-내용>추가 학습 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#용어-정리-1>용어 정리</a></li><li><a href=#용어-정리-2>용어 정리</a><ul><li><a href=#용어-정리-3>용어 정리</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li><li><a href=#참고-및-출처-1>참고 및 출처</a></li><li><a href=#참고-및-출처-2>참고 및 출처</a><ul><li><a href=#참고-및-출처-3>참고 및 출처</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=git-hooks>Git Hooks<a hidden class=anchor aria-hidden=true href=#git-hooks>#</a></h2><p>Git Hooks 는 Git 워크플로우의 특정 이벤트 (커밋, 푸시 등) 가 발생할 때 자동으로 실행되는 사용자 정의 스크립트이다. 이 스크립트들은 소스 코드 관리, 품질 보증, 배포 자동화 등 다양한 목적으로 활용된다. Git Hooks 는 클라이언트 측과 서버 측으로 나뉘며, 로컬 개발 환경에서의 코드 검증부터 원격 저장소에서의 배포 자동화까지 광범위한 워크플로우를 지원한다. 이를 통해 개발자들은 코딩 표준 준수, 테스트 자동화, 지속적 통합/배포 등을 효율적으로 구현할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>Git Hooks 는 <strong>Git 작업 이벤트 트리거</strong>에 반응하는 <strong>자동화 스크립트</strong>이다. <code>.git/hooks</code> 디렉토리에 위치하며, 실행 가능한 권한이 부여된 스크립트 파일 형태로 존재한다. 이벤트는 커밋 생성, 브랜치 전환, 원격 저장소로의 푸시 등 Git 워크플로우의 다양한 시점에서 발생할 수 있으며 사전/사후 작업을 실행한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 예시: pre-commit 훅</span>
</span></span><span class=line><span class=cl><span class=c1>#!/bin/sh</span>
</span></span><span class=line><span class=cl>npm run lint  <span class=c1># 커밋 전 린트 실행</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><p>Git Hooks 의 주요 목적은 다음과 같다:</p><ol><li>개발 워크플로우 자동화</li><li>코드 품질 및 일관성 유지</li><li>테스트 자동화</li><li>배포 프로세스 간소화</li><li>팀 협업 효율성 증대</li><li>보안 취약점 검사 자동화</li></ol><h3 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h3><p>Git Hooks 는 다음과 같은 이유로 필요하다:</p><ol><li>인적 오류 감소 - 수동 검사를 자동화하여 실수 방지</li><li>일관된 코드 품질 보장 - 모든 코드 변경에 동일한 검증 적용</li><li>개발 속도 향상 - 반복적인 작업 자동화</li><li>팀 표준 강제화 - 모든 팀원이 동일한 규칙 준수</li><li>배포 위험 감소 - 검증되지 않은 코드의 배포 방지</li></ol><h3 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h3><p>Git Hooks 의 주요 기능은 다음과 같다:</p><ol><li>코드 스타일 검사 (linting)</li><li>자동 테스트 실행</li><li>커밋 메시지 형식 검증</li><li>브랜치 명명 규칙 강제</li><li>금지된 파일 형식 차단</li><li>배포 자동화</li><li>외부 시스템 통합 (CI/CD, 이슈 트래커 등)</li></ol><h3 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h3><p>Git Hooks 는 개발 프로세스에서 다음과 같은 역할을 수행한다:</p><ol><li><strong>게이트키퍼</strong> - 품질 기준을 충족하지 않는 코드의 저장소 진입 차단</li><li><strong>자동화 도구</strong> - 반복적인 작업 자동 실행</li><li><strong>통합 지점</strong> - 외부 시스템과 Git 워크플로우 연결</li><li><strong>정책 시행자</strong> - 팀의 코딩 표준 및 관행 강제화</li><li><strong>알림 시스템</strong> - 중요 이벤트 발생시 팀원에게 통지</li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p>Git Hooks 의 주요 특징은 다음과 같다:</p><ol><li><strong>사용자 정의 가능성</strong> - 어떤 프로그래밍 언어로도 작성 가능</li><li><strong>이식성</strong> - 모든 Git 저장소에서 작동</li><li><strong>유연성</strong> - 다양한 워크플로우 단계에서 실행 가능</li><li><strong>확장성</strong> - 외부 도구와 쉽게 통합</li><li><strong>선택적 사용</strong> - 필요한 훅만 활성화 가능</li><li><strong>로컬 및 서버 측 지원</strong> - 개발자 워크스테이션과 원격 저장소 모두에서 사용 가능</li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>Git Hooks 사용의 핵심 원칙은 다음과 같다:</p><ol><li><strong>" 코드에 문제가 있다면 일찍 찾아내라 &ldquo;</strong> - 문제가 확산되기 전에 조기 발견</li><li><strong>자동화 우선</strong> - 수동 과정보다 자동화된 프로세스 선호</li><li><strong>실패는 빠르게</strong> - 문제가 있다면 프로세스 초기에 실패하도록 설계</li><li><strong>일관성 유지</strong> - 모든 개발자가 동일한 검증 과정 통과</li><li><strong>적절한 피드백</strong> - 문제 발생 시 명확한 오류 메시지 제공</li></ol><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><ul><li><strong>이벤트 기반 실행</strong>: Git 의 특정 이벤트 발생 시 해당하는 Hook 스크립트가 자동으로 실행된다.</li><li><strong>스크립트 실행 흐름</strong>: 예를 들어, <code>pre-commit</code> Hook 은 <code>git commit</code> 명령 실행 시 커밋이 완료되기 전에 실행된다.</li><li><strong>실행 결과에 따른 동작 제어</strong>: Hook 스크립트의 종료 상태에 따라 Git 명령의 실행 여부가 결정된다.<br><figure><img alt="Git Hook 작동 원리" loading=lazy src=/img/8c8e049c-0cc4-4a3c-bdad-40b68a153fcf.png></figure></li></ul><h4 id=작동-원리-다이어그램>작동 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램>#</a></h4><pre class=mermaid>flowchart TD
A[Git 이벤트 발생] --&gt; B{해당 훅 스크립트 존재?}
B -- 예 --&gt; C[스크립트 실행]
C --&gt; D{성공?}
D -- 예 --&gt; E[다음 단계 진행]
D -- 아니오 --&gt; F[작업 중단]
B -- 아니오 --&gt; E
</pre><h3 id=구성-요소-및-아키텍처>구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-요소-및-아키텍처>#</a></h3><p>Git Hooks 의 구성 요소 및 아키텍처는 다음과 같다:</p><table><thead><tr><th>구성 요소</th><th>설명</th><th>역할</th><th>기능</th><th>예시</th></tr></thead><tbody><tr><td><strong>훅 스크립트 파일</strong></td><td><code>.git/hooks</code> 디렉토리에 위치한 실행 파일</td><td>Git 이벤트 발생 시 자동 실행</td><td>코드 검증, 테스트 실행, 메시지 형식 검사 등</td><td></td></tr><tr><td><strong>Git 저장소</strong></td><td><code>.git</code> 디렉토리를 포함한 프로젝트 폴더</td><td>훅 설정 및 실행 환경 제공</td><td>버전 관리, 이벤트 트리거링</td><td></td></tr><tr><td><strong>클라이언트 측 훅</strong></td><td>로컬 환경에서 실행되는 훅</td><td>개발 중 코드 품질 사전 검증</td><td>커밋 전 검사, 메시지 포맷팅, 푸시 전 테스트 등</td><td><code>pre-commit</code>, <code>commit-msg</code>, <code>pre-push</code></td></tr><tr><td><strong>서버 측 훅</strong></td><td>원격 저장소 (Git 서버) 에서 실행되는 훅</td><td>조직 정책 강제 및 배포 연계</td><td>푸시 수신 검증, 브랜치 보호, 자동 배포 등</td><td><code>pre-receive</code>, <code>update</code>, <code>post-receive</code></td></tr><tr><td><strong>훅 관리 도구</strong></td><td>Husky, pre-commit, Lefthook 등</td><td>팀 단위에서의 훅 일관성 유지</td><td>훅 공유, 설정 자동화, 실행 환경 표준화</td><td></td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>자동화</td><td>반복 작업 자동 처리, 생산성 향상</td></tr><tr><td></td><td>표준화</td><td>팀 규칙 강제, 코드 품질 일관성 유지</td></tr><tr><td></td><td>코드 품질 향상</td><td>일관된 코드 스타일과 표준을 강제하여 품질 향상</td></tr><tr><td></td><td>오류 감소</td><td>커밋이나 푸시 전에 문제를 감지하여 버그 유입 방지</td></tr><tr><td></td><td>CI/CD 파이프라인 강화</td><td>지속적 통합 및 배포 프로세스를 보완하고 강화</td></tr><tr><td></td><td>유연성</td><td>어떤 프로그래밍 언어로도 작성 가능하며 다양한 용도로 활용</td></tr><tr><td>⚠ 단점</td><td>공유 어려움</td><td>.git/hooks 는 기본적으로 버전 관리 미지원</td></tr><tr><td></td><td>보안 위험</td><td>악성 스크립트 실행 가능성</td></tr><tr><td></td><td>과도한 제약 가능성</td><td>너무 엄격한 훅은 개발 생산성을 저하시킬 수 있음</td></tr><tr><td></td><td>유지보수 부담</td><td>시간이 지남에 따라 훅 스크립트 자체의 유지보수가 필요</td></tr><tr><td></td><td>디버깅 어려움</td><td>훅 실패 시 원인 파악이 복잡할 수 있음</td></tr><tr><td></td><td>성능 영향</td><td>복잡한 훅은 Git 작업 속도를 현저히 저하시킬 수 있음</td></tr></tbody></table><h3 id=클라이언트-vs-서버-훅-비교>클라이언트 vs. 서버 훅 비교<a hidden class=anchor aria-hidden=true href=#클라이언트-vs-서버-훅-비교>#</a></h3><table><thead><tr><th>구분</th><th>클라이언트 훅</th><th>서버 훅</th></tr></thead><tbody><tr><td><strong>실행 위치</strong></td><td>로컬 저장소</td><td>원격 저장소 서버</td></tr><tr><td><strong>주요 이벤트</strong></td><td>커밋, 머지, 푸시 전</td><td>푸시 수신 후</td></tr><tr><td><strong>목적</strong></td><td>개인 작업 표준화</td><td>팀 정책 강제</td></tr></tbody></table><h4 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h4><table><thead><tr><th>분류</th><th>훅 이름</th><th>설명</th><th>실행 시점</th></tr></thead><tbody><tr><td>클라이언트 측</td><td>pre-commit</td><td>커밋 생성 전 실행</td><td><code>git commit</code> 명령 후, 커밋 메시지 입력 전</td></tr><tr><td></td><td>prepare-commit-msg</td><td>커밋 메시지 템플릿 준비</td><td>커밋 메시지 편집기 실행 전</td></tr><tr><td></td><td>commit-msg</td><td>커밋 메시지 검증</td><td>커밋 메시지 작성 후, 커밋 완료 전</td></tr><tr><td></td><td>post-commit</td><td>커밋 완료 후 알림</td><td>커밋 완료 직후</td></tr><tr><td></td><td>pre-rebase</td><td>리베이스 작업 전 검증</td><td><code>git rebase</code> 명령 실행 전</td></tr><tr><td></td><td>post-rewrite</td><td>커밋 수정 명령 후 실행</td><td><code>git commit --amend</code> 또는 <code>git rebase</code> 이후</td></tr><tr><td></td><td>pre-push</td><td>원격 저장소 푸시 전 검증</td><td><code>git push</code> 실행 전, 원격 참조 업데이트 전</td></tr><tr><td></td><td>post-checkout</td><td>체크아웃 후 작업 환경 설정</td><td><code>git checkout</code> 또는 <code>git switch</code> 이후</td></tr><tr><td></td><td>post-merge</td><td>병합 후 작업 환경 설정</td><td><code>git merge</code> 완료 후</td></tr><tr><td></td><td>pre-auto-gc</td><td>가비지 컬렉션 전 검증</td><td><code>git gc --auto</code> 실행 전</td></tr><tr><td></td><td>fsmonitor-watchman</td><td>파일 시스템 모니터링 설정</td><td><code>git status</code> 와 같은 명령 성능 향상에 사용</td></tr><tr><td>서버 측</td><td>pre-receive</td><td>푸시 데이터 수신 전 검증</td><td>푸시 데이터를 수신하기 전, 모든 참조에 대해 한 번</td></tr><tr><td></td><td>update</td><td>개별 참조 업데이트 검증</td><td>업데이트되는 각 참조 (브랜치나 태그) 에 대해 실행</td></tr><tr><td></td><td>post-receive</td><td>모든 참조 업데이트 후 실행</td><td>푸시 프로세스 완료 후 한 번 실행</td></tr><tr><td></td><td>post-update</td><td>참조 업데이트 후 알림</td><td>업데이트된 모든 참조에 대해 한 번 실행</td></tr><tr><td></td><td>reference-transaction</td><td>참조 업데이트 트랜잭션 처리</td><td>참조가 변경될 때마다 실행</td></tr><tr><td></td><td>pre-auto-gc</td><td>자동 가비지 컬렉션 전 검증</td><td>서버의 <code>git gc --auto</code> 실행 전</td></tr><tr><td>이메일 워크플로우</td><td>applypatch-msg</td><td>패치 적용 메시지 검증</td><td><code>git am</code> 실행 시</td></tr><tr><td></td><td>pre-applypatch</td><td>패치 적용 전 검증</td><td>패치 적용 후, 커밋 생성 전</td></tr><tr><td></td><td>post-applypatch</td><td>패치 적용 후 알림</td><td><code>git am</code> 완료 후</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 사례</th><th>사용 훅</th><th>설명</th><th>이점</th></tr></thead><tbody><tr><td>코드 스타일 검사</td><td>pre-commit</td><td>ESLint, Prettier 등을 사용해 코드 스타일 검사</td><td>일관된 코드 스타일 유지, 리뷰 부담 감소</td></tr><tr><td>테스트 자동화</td><td>pre-push</td><td>유닛 테스트, 통합 테스트 자동 실행</td><td>테스트 실패한 코드의 저장소 반영 방지</td></tr><tr><td>커밋 메시지 표준화</td><td>commit-msg</td><td>커밋 메시지가 정해진 형식 (예: 컨벤셔널 커밋) 을 따르는지 검사</td><td>변경 이력 가독성 향상, 자동 버전 관리 지원</td></tr><tr><td>보안 취약점 검사</td><td>pre-commit, pre-push</td><td>의존성 패키지의 보안 취약점 검사</td><td>보안 위험 조기 감지</td></tr><tr><td>자동 배포</td><td>post-receive</td><td>CI/CD 파이프라인 트리거, 서버 환경 자동 업데이트</td><td>배포 프로세스 간소화</td></tr><tr><td>이슈 트래커 연동</td><td>prepare-commit-msg</td><td>브랜치 이름에서 이슈 번호를 추출하여 커밋 메시지에 자동 추가</td><td>코드와 이슈 추적 시스템 연계 강화</td></tr><tr><td>문서 자동 생성</td><td>post-commit, post-receive</td><td>API 문서, CHANGELOG 등 자동 업데이트</td><td>문서의 최신 상태 유지</td></tr><tr><td>데이터베이스 마이그레이션</td><td>post-checkout, post-merge</td><td>브랜치 전환 또는 병합 후 자동으로 DB 스키마 업데이트</td><td>개발 환경 일관성 유지</td></tr><tr><td>환경 변수 검증</td><td>pre-commit</td><td>민감한 정보 (API 키, 비밀번호 등) 가 커밋되지 않도록 방지</td><td>보안 강화, 민감 정보 유출 방지</td></tr><tr><td>성능 테스트</td><td>pre-push</td><td>주요 기능의 성능 회귀 테스트 자동 실행</td><td>성능 저하 조기 탐지</td></tr></tbody></table><h4 id=샘플-git-hook-스크립트-pre-commit-예시>샘플 Git Hook 스크립트 (pre-commit 예시)<a hidden class=anchor aria-hidden=true href=#샘플-git-hook-스크립트-pre-commit-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># .git/hooks/pre-commit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;🔍 Running lint check before commit...&#34;</span>
</span></span><span class=line><span class=cl>npx eslint . --ext .js,.jsx,.ts,.tsx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=nv>$?</span> -ne <span class=m>0</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> <span class=s2>&#34;❌ Lint errors detected. Commit aborted.&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nb>exit</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;✅ Lint passed. Proceeding with commit.&#34;</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>실행 전 반드시 <code>chmod +x.git/hooks/pre-commit</code> 로 실행 권한 부여 필요.</p></blockquote><h4 id=pre-commit-프레임워크-구성-예시-python-기반>Pre-commit 프레임워크 구성 예시 (Python 기반)<a hidden class=anchor aria-hidden=true href=#pre-commit-프레임워크-구성-예시-python-기반>#</a></h4><ol><li><p><code>pre-commit</code> 설치</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install pre-commit
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>.pre-commit-config.yaml</code> 구성</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>repos</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>repo</span><span class=p>:</span><span class=w> </span><span class=l>https://github.com/pre-commit/pre-commit-hooks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rev</span><span class=p>:</span><span class=w> </span><span class=l>v4.5.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hooks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>trailing-whitespace</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>end-of-file-fixer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>check-yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>repo</span><span class=p>:</span><span class=w> </span><span class=l>https://github.com/psf/black</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rev</span><span class=p>:</span><span class=w> </span><span class=m>23.7.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hooks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>black</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>language_version</span><span class=p>:</span><span class=w> </span><span class=l>python3</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>설치 및 적용</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pre-commit install      <span class=c1># git hook에 자동 등록</span>
</span></span><span class=line><span class=cl>pre-commit run --all-files  <span class=c1># 수동 실행</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><blockquote><p>이 방식은 팀 내에서 hook 구성 공유를 YAML 로 하고, 자동 배포까지 가능하다는 장점이 있다.</p></blockquote><h4 id=husky-연동-예제-nodejs-기반>Husky 연동 예제 (Node.js 기반)<a hidden class=anchor aria-hidden=true href=#husky-연동-예제-nodejs-기반>#</a></h4><ol><li><p>설치 및 초기화</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>npm install husky --save-dev
</span></span><span class=line><span class=cl>npx husky install
</span></span></code></pre></td></tr></table></div></div><p><code>package.json</code> 에 postinstall 스크립트 추가:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=s2>&#34;scripts&#34;</span><span class=err>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;prepare&#34;</span><span class=p>:</span> <span class=s2>&#34;husky install&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Hook 추가</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>npx husky add .husky/pre-commit <span class=s2>&#34;npm run lint &amp;&amp; npm test&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>생성된 <code>.husky/pre-commit</code> 파일 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>. <span class=s2>&#34;</span><span class=k>$(</span>dirname <span class=s2>&#34;</span><span class=nv>$0</span><span class=s2>&#34;</span><span class=k>)</span><span class=s2>/_/husky.sh&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;✅ Husky pre-commit 실행 중...&#34;</span>
</span></span><span class=line><span class=cl>npm run lint
</span></span><span class=line><span class=cl>npm <span class=nb>test</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=lefthook-연동-예제-언어-독립형>Lefthook 연동 예제 (언어 독립형)<a hidden class=anchor aria-hidden=true href=#lefthook-연동-예제-언어-독립형>#</a></h4><ol><li><p>설치</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install lefthook   <span class=c1># macOS</span>
</span></span><span class=line><span class=cl><span class=c1># 또는</span>
</span></span><span class=line><span class=cl>gem install lefthook    <span class=c1># Ruby 기반 환경</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>초기화 및 설정</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lefthook install
</span></span></code></pre></td></tr></table></div></div><p><code>.lefthook.yml</code> 설정 파일 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>pre-commit</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>parallel</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>commands</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>lint</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>npx eslint .</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>npm test</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>.git/hooks/</code> 가 자동으로 Lefthook 에 의해 관리된다.</p></li><li><p>실행 확인</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lefthook run pre-commit
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=git-secrets-연동-예제-aws-키-및-민감정보-방지>Git-secrets 연동 예제 (AWS 키 및 민감정보 방지)<a hidden class=anchor aria-hidden=true href=#git-secrets-연동-예제-aws-키-및-민감정보-방지>#</a></h4><ol><li><p>설치</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone https://github.com/awslabs/git-secrets.git
</span></span><span class=line><span class=cl><span class=nb>cd</span> git-secrets
</span></span><span class=line><span class=cl>make install
</span></span></code></pre></td></tr></table></div></div></li><li><p>Git 저장소에 Hook 설정</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git secrets --install
</span></span><span class=line><span class=cl>git secrets --register-aws
</span></span></code></pre></td></tr></table></div></div></li></ol><blockquote><p><code>~/.git-templates</code> 또는 전역 hook 으로도 설정 가능</p></blockquote><ol><li><p>사용자 정의 정규식 추가 예시</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git secrets --add <span class=s1>&#39;PRIVATE_KEY&#39;</span>
</span></span><span class=line><span class=cl>git secrets --add <span class=s1>&#39;apikey_[0-9a-f]{32}&#39;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>검사 실행</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git secrets --scan
</span></span></code></pre></td></tr></table></div></div></li></ol><blockquote><p>커밋 전 민감한 정보가 있는지 검사하며, 발견 시 커밋이 차단된다.</p></blockquote><h4 id=도구-비교-요약>도구 비교 요약<a hidden class=anchor aria-hidden=true href=#도구-비교-요약>#</a></h4><table><thead><tr><th>도구</th><th>특징</th><th>주요 사용 환경</th></tr></thead><tbody><tr><td><strong>Husky</strong></td><td>Node.js 프로젝트에 적합, 간단한 CLI</td><td>프론트엔드, JS 기반 프로젝트</td></tr><tr><td><strong>Lefthook</strong></td><td>언어 독립, 병렬 실행, 빠른 성능</td><td>Monorepo, 다중 언어 환경</td></tr><tr><td><strong>git-secrets</strong></td><td>민감정보 탐지, 보안 강화</td><td>AWS 환경, 보안 규정 있는 조직</td></tr></tbody></table><h4 id=ci-환경>CI 환경<a hidden class=anchor aria-hidden=true href=#ci-환경>#</a></h4><p>GitHub Actions 의 <code>.github/workflows</code> 디렉토리에서 <strong>Git Hooks 와 통합된 자동화 예제</strong>.</p><p><strong>목적</strong></p><ul><li>로컬 개발자는 <code>pre-commit</code> Git Hook 으로 코드 스타일과 테스트를 체크</li><li>GitHub Actions 에서는 <strong>PR 이나 push 시</strong> 동일한 검사를 자동 수행</li></ul><p><strong>디렉토리 구조 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── .pre-commit-config.yaml
</span></span><span class=line><span class=cl>└── .github
</span></span><span class=line><span class=cl>    └── workflows
</span></span><span class=line><span class=cl>        └── pre-commit.yml
</span></span></code></pre></td></tr></table></div></div><p><strong><code>.pre-commit-config.yaml</code> 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>repos</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>repo</span><span class=p>:</span><span class=w> </span><span class=l>https://github.com/pre-commit/pre-commit-hooks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rev</span><span class=p>:</span><span class=w> </span><span class=l>v4.5.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hooks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>trailing-whitespace</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>end-of-file-fixer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>repo</span><span class=p>:</span><span class=w> </span><span class=l>https://github.com/psf/black</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rev</span><span class=p>:</span><span class=w> </span><span class=m>24.3.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>hooks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>black</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong><code>.github/workflows/pre-commit.yml</code> 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span><span class=lnt id=hl-20-16><a class=lnlinks href=#hl-20-16>16</a>
</span><span class=lnt id=hl-20-17><a class=lnlinks href=#hl-20-17>17</a>
</span><span class=lnt id=hl-20-18><a class=lnlinks href=#hl-20-18>18</a>
</span><span class=lnt id=hl-20-19><a class=lnlinks href=#hl-20-19>19</a>
</span><span class=lnt id=hl-20-20><a class=lnlinks href=#hl-20-20>20</a>
</span><span class=lnt id=hl-20-21><a class=lnlinks href=#hl-20-21>21</a>
</span><span class=lnt id=hl-20-22><a class=lnlinks href=#hl-20-22>22</a>
</span><span class=lnt id=hl-20-23><a class=lnlinks href=#hl-20-23>23</a>
</span><span class=lnt id=hl-20-24><a class=lnlinks href=#hl-20-24>24</a>
</span><span class=lnt id=hl-20-25><a class=lnlinks href=#hl-20-25>25</a>
</span><span class=lnt id=hl-20-26><a class=lnlinks href=#hl-20-26>26</a>
</span><span class=lnt id=hl-20-27><a class=lnlinks href=#hl-20-27>27</a>
</span><span class=lnt id=hl-20-28><a class=lnlinks href=#hl-20-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>pre-commit checks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>main, develop]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>lint-and-format</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Run pre-commit hooks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Set up Python</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-python@v5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>python-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3.11&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install dependencies</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          python -m pip install --upgrade pip
</span></span></span><span class=line><span class=cl><span class=sd>          pip install pre-commit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Run pre-commit hooks</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>pre-commit run --all-files</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>주요 구성 해설</p><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><code>on</code></td><td><code>push</code>, <code>pull_request</code> 이벤트 발생 시 실행</td></tr><tr><td><code>runs-on</code></td><td>GitHub 의 Ubuntu 러너 사용</td></tr><tr><td><code>setup-python</code></td><td>Python 기반의 pre-commit 도구 환경 구성</td></tr><tr><td><code>pre-commit run --all-files</code></td><td>전체 파일 대상 Hook 실행</td></tr></tbody></table><h5 id=-실무-팁>📌 실무 팁<a hidden class=anchor aria-hidden=true href=#-실무-팁>#</a></h5><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>공유 유지</td><td><code>.pre-commit-config.yaml</code> 은 버전 관리되므로, 팀 전체에 공통 정책 적용 가능</td></tr><tr><td>재현성 확보</td><td>GitHub Actions 에서도 동일한 Hook 실행 → CI 와 로컬의 결과 불일치 최소화</td></tr><tr><td>병렬 실행 고려</td><td>복잡한 작업은 <code>pre-commit</code> 에서 <code>parallel: true</code> 설정 지원</td></tr></tbody></table><h3 id=활용-예시-및-다이어그램>활용 예시 및 다이어그램<a hidden class=anchor aria-hidden=true href=#활용-예시-및-다이어그램>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5>5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[개발자 로컬]
</span></span><span class=line><span class=cl>pre-commit → 린트/테스트 → 실패 시 커밋 차단
</span></span><span class=line><span class=cl>           ↘ 성공 시 커밋 완료 → 원격 저장소 푸시
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[서버]
</span></span><span class=line><span class=cl>pre-receive → 코드 검증 → 승인 시 배포 파이프라인 실행
</span></span></code></pre></td></tr></table></div></div><h4 id=활용-예시-린트--테스트>활용 예시: 린트 / 테스트<a hidden class=anchor aria-hidden=true href=#활용-예시-린트--테스트>#</a></h4><ul><li><strong>상황:</strong> 팀에서 코드 품질을 유지하기 위해 커밋 전 린트와 테스트를 자동 실행하고, 실패 시 커밋을 막고 싶다.</li></ul><pre class=mermaid>sequenceDiagram
participant 개발자
participant Git
participant 훅 스크립트

개발자-&gt;&gt;Git: git commit 실행
Git-&gt;&gt;훅 스크립트: pre-commit 훅 실행
훅 스크립트-&gt;&gt;Git: 린트/테스트 결과 반환
alt 성공
    Git-&gt;&gt;개발자: 커밋 성공
else 실패
    Git-&gt;&gt;개발자: 커밋 차단, 오류 메시지 출력
end
</pre><h4 id=활용-예시-지속적-통합-파이프라인-구축>활용 예시: 지속적 통합 파이프라인 구축<a hidden class=anchor aria-hidden=true href=#활용-예시-지속적-통합-파이프라인-구축>#</a></h4><p><strong>시나리오</strong>: 개발자가 새로운 기능을 개발하고 이를 팀의 저장소에 통합하는 과정</p><ol><li>개발자가 로컬에서 코드 작성</li><li>커밋 시도 → <code>pre-commit</code> 훅 실행 (코드 린팅, 포맷팅)</li><li>커밋 메시지 작성 → <code>commit-msg</code> 훅 실행 (커밋 메시지 형식 검증)</li><li>원격 저장소 푸시 시도 → <code>pre-push</code> 훅 실행 (단위 테스트 실행)</li><li>푸시 데이터 서버 도착 → <code>pre-receive</code> 훅 실행 (브랜치 권한 검사)</li><li>브랜치 업데이트 → <code>update</code> 훅 실행 (특정 파일 변경 검증)</li><li>모든 검증 완료 → <code>post-receive</code> 훅 실행 (CI 시스템 트리거)</li><li>CI 시스템에서 통합 테스트, 보안 검사 실행</li><li>모든 검증 통과 시 자동 배포 진행</li></ol><h3 id=3-9-실무-적용-고려사항-및-주의점>3-9. 실무 적용 고려사항 및 주의점<a hidden class=anchor aria-hidden=true href=#3-9-실무-적용-고려사항-및-주의점>#</a></h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>공유 전략</td><td>core.hooksPath 설정, Husky(허스키) 등 도구 사용</td></tr><tr><td>크로스 플랫폼</td><td>OS 별 스크립트 호환성 고려</td></tr><tr><td>보안</td><td>스크립트 검증 및 실행 권한 관리</td></tr><tr><td>유지보수</td><td>훅 스크립트의 주기적 업데이트 및 테스트 필요</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>해결 방안</th></tr></thead><tbody><tr><td>팀 전체 공유</td><td>Git 훅은 기본적으로 로컬에 저장되어 공유되지 않음</td><td>Husky, pre-commit 같은 도구를 통해 패키지 관리자와 통합하여 설정 공유</td></tr><tr><td>성능 최적화</td><td>무거운 검사는 커밋/푸시 과정을 지연시킬 수 있음</td><td>필수적인 검사만 pre-commit 에 포함, 나머지는 pre-push 나 CI 단계로 이동</td></tr><tr><td>우회 가능성</td><td><code>--no-verify</code> 플래그로 클라이언트 측 훅을 우회할 수 있음</td><td>서버 측 훅과 함께 사용하여 중요한 검증 강제화</td></tr><tr><td>훅 디버깅</td><td>훅 실패 시 원인 파악이 어려울 수 있음</td><td>상세한 오류 메시지 제공, 로깅 기능 추가</td></tr><tr><td>다양한 개발 환경</td><td>팀원마다 다른 OS 환경에서 동일한 훅이 작동해야 함</td><td>크로스 플랫폼 스크립트 작성 또는 Docker 컨테이너 활용</td></tr><tr><td>새 팀원 온보딩</td><td>새 개발자가 프로젝트 설정에 익숙해져야 함</td><td>명확한 문서화, 자동화된 설정 스크립트 제공</td></tr><tr><td>점진적 도입</td><td>한번에 많은 훅을 도입하면 팀의 저항을 불러일으킬 수 있음</td><td>가장 가치 있는 훅부터 점진적으로 도입</td></tr><tr><td>예외 상황 처리</td><td>특정 상황에서는 검증을 건너뛰어야 할 필요가 있음</td><td>조건부 검사 로직 구현, 긴급 상황용 우회 메커니즘 마련</td></tr><tr><td>훅 테스트</td><td>훅 자체에 버그가 있을 수 있음</td><td>훅 스크립트에 대한 테스트 코드 작성</td></tr><tr><td>버전 관리</td><td>훅 스크립트의 변경 이력을 추적해야 함</td><td>훅 스크립트를 별도 저장소나 프로젝트 내 디렉토리에서 관리</td></tr></tbody></table><h4 id=git-hooks-공유-및-관리-도구>Git Hooks 공유 및 관리 도구<a hidden class=anchor aria-hidden=true href=#git-hooks-공유-및-관리-도구>#</a></h4><p>Git Hooks 를 팀 전체에서 효과적으로 공유하고 관리하기 위한 도구들이 있다:</p><ol><li><strong>Husky</strong>: npm 기반 프로젝트에서 Git Hooks 를 쉽게 설정하고 공유할 수 있는 도구</li><li><strong>pre-commit</strong>: 다양한 언어와 도구에 대한 훅 관리를 제공하는 프레임워크</li><li><strong>Lefthook</strong>: 빠르고 강력한 Git Hooks 관리자</li><li><strong>githooks</strong>: 팀 전체에서 훅을 공유하기 위한 간단한 솔루션</li><li><strong>git-hooks</strong>: 분산된 훅 관리를 위한 도구</li></ol><h4 id=cicd-시스템과의-통합>CI/CD 시스템과의 통합<a hidden class=anchor aria-hidden=true href=#cicd-시스템과의-통합>#</a></h4><p>Git Hooks 는 CI/CD 시스템과 효과적으로 통합할 수 있다:</p><ol><li><strong>진입점 검증</strong>: 로컬 훅으로 기본적인 검증을 수행하고 CI 시스템에서 더 철저한 검증</li><li><strong>CI 트리거</strong>: post-receive 훅을 사용하여 CI 파이프라인 자동 트리거</li><li><strong>결과 피드백</strong>: CI 결과를 Git 워크플로우에 통합하여 피드백 루프 강화</li></ol><h4 id=멀티환경-지원>멀티환경 지원<a hidden class=anchor aria-hidden=true href=#멀티환경-지원>#</a></h4><p>다양한 개발 환경에서 Git Hooks 를 일관되게 사용하기 위한 방법:</p><ol><li><strong>셸 스크립트 대신 고급 언어 사용</strong>: Python, Node.js 등 크로스 플랫폼 언어 활용</li><li><strong>Docker 컨테이너 활용</strong>: 일관된 실행 환경 제공</li><li><strong>환경 감지 및 적응</strong>: 실행 환경에 따라 다른 명령어 실행</li></ol><h3 id=성능을-최적화하기-위한-고려사항-및-주의할-점>성능을 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#성능을-최적화하기-위한-고려사항-및-주의할-점>#</a></h3><ol><li><p><strong>검사 범위 최소화</strong>: 변경된 파일만 검사하여 불필요한 처리 방지</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 변경된 파일만 lint 검사 예시</span>
</span></span><span class=line><span class=cl><span class=nv>STAGED_FILES</span><span class=o>=</span><span class=k>$(</span>git diff --cached --name-only --diff-filter<span class=o>=</span>ACM <span class=p>|</span> grep <span class=s1>&#39;\.js$&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$STAGED_FILES</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>  <span class=nb>exit</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>eslint <span class=nv>$STAGED_FILES</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>단계적 검증 전략</strong>: 가벼운 검사는 pre-commit 에, 무거운 검사는 pre-push 에 배치</p></li><li><p><strong>병렬 처리</strong>: 독립적인 검사는 병렬로 실행하여 시간 단축</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 병렬 처리 예시</span>
</span></span><span class=line><span class=cl>npm run lint <span class=p>&amp;</span> npm run type-check <span class=p>&amp;</span> <span class=nb>wait</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>캐싱 활용</strong>: 이전에 검증된 파일의 결과를 캐싱하여 재사용</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ESLint 캐싱 예시</span>
</span></span><span class=line><span class=cl>eslint --cache .
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>점진적 검증</strong>: 전체 검증은 CI 서버에서 수행하고, 로컬에서는 최소 검증</p></li><li><p><strong>타임아웃 설정</strong>: 무한 루프 방지를 위한 타임아웃 메커니즘 구현</p></li><li><p><strong>리소스 사용량 모니터링</strong>: 메모리, CPU 사용량을 주기적으로 확인하여 최적화</p></li></ol><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>자동화</td><td>GitOps 와 Git Hooks 통합</td><td>GitOps 워크플로우에서 Git Hooks 가 중요한 구성 요소로 자리 잡고 있으며, 인프라 변경 검증에 활용되고 있습니다.</td></tr><tr><td>보안</td><td>보안 중심 Git Hooks</td><td>소프트웨어 공급망 보안이 중요해짐에 따라 의존성 취약점 검사, 자격 증명 유출 방지, 코드 보안 분석을 자동화하는 훅이 표준화되고 있습니다.</td></tr><tr><td>표준화</td><td>언어별 표준 훅 템플릿</td><td>프로그래밍 언어와 프레임워크별로 최적화된 표준 Git Hooks 템플릿이 등장하여 개발자들이 쉽게 채택할 수 있게 되었습니다.</td></tr><tr><td>통합</td><td>AI 코드 리뷰 통합</td><td>AI 기반 코드 리뷰 도구가 Git Hooks 와 통합되어 커밋 전에 자동으로 코드 품질, 보안 취약점, 성능 문제를 분석하고 개선 제안을 제공합니다.</td></tr><tr><td>성능</td><td>경량화 및 성능 개선</td><td>증분 분석과 캐싱 기술의 발전으로 Git Hooks 의 실행 시간이 크게 단축되었으며, 대규모 프로젝트에서도 원활하게 작동합니다.</td></tr><tr><td>개발자 경험</td><td>인터랙티브 Git Hooks</td><td>개발자에게 더 나은 피드백을 제공하는 인터랙티브 훅이 등장하여, 문제 발생 시 자동 수정 제안이나 시각적 피드백을 제공합니다.</td></tr><tr><td>클라우드</td><td>클라우드 네이티브 훅</td><td>클라우드 네이티브 환경에 최적화된 Git Hooks 가 개발되어 Kubernetes 매니페스트 검증, 클라우드 리소스 정책 준수 확인 등을 자동화합니다.</td></tr><tr><td>관리</td><td>Git Hooks-as-a-Service</td><td>기업용 Git Hooks 관리 서비스가 등장하여 조직 전체의 훅 정책을 중앙에서 관리하고 모니터링할 수 있게 되었습니다.</td></tr></tbody></table><hr><h3 id=주목해야-할-기술>주목해야 할 기술<a hidden class=anchor aria-hidden=true href=#주목해야-할-기술>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>클라우드 연계</td><td>서버리스 훅</td><td>클라우드 함수로 훅 실행, 유지보수 용이</td></tr><tr><td>자동화</td><td>Git Hooks 오케스트레이션</td><td>다양한 훅을 조직화하고 상호작용을 관리하는 고급 오케스트레이션 도구가 개발되고 있습니다.</td></tr><tr><td>인공지능</td><td>AI 기반 코드 검증</td><td>머신러닝 모델을 활용해 코드 패턴을 학습하고 버그, 보안 취약점, 성능 이슈를 예측하는 훅이 주목받고 있습니다.</td></tr><tr><td>컴플라이언스</td><td>규제 준수 자동화</td><td>금융, 의료 등 규제가 엄격한 산업에서 컴플라이언스 요구사항을 자동으로 검증하는 특수 목적 훅이 발전하고 있습니다.</td></tr><tr><td>보안</td><td>SBOM 생성 및 검증</td><td>소프트웨어 자재명세서 (SBOM) 생성 및 검증을 자동화하는 훅이 개발되어 소프트웨어 공급망 보안을 강화합니다.</td></tr><tr><td>보안</td><td>코드 서명</td><td>훅 스크립트 무결성 검증</td></tr><tr><td>협업</td><td>분산 팀 최적화</td><td>원격/분산 팀을 위한 협업 최적화 훅이 개발되어 시간대와 지역에 관계없이 일관된 개발 경험을 제공합니다.</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>자동화</td><td>전체 SDLC 통합</td><td>Git Hooks 가 소프트웨어 개발 수명 주기 (SDLC) 전반에 더 깊이 통합되어 요구사항부터 배포, 모니터링까지 자동화할 것으로 예상됩니다.</td></tr><tr><td>지능화</td><td>적응형 Git Hooks</td><td>프로젝트와 개발자의 패턴을 학습하여 최적의 검증 전략을 자동으로 조정하는 적응형 훅이 등장할 것으로 예상됩니다.</td></tr><tr><td>표준화</td><td>산업별 표준 확립</td><td>각 산업 분야에 최적화된 Git Hooks 표준이 확립되어 모범 사례가 널리 공유될 것으로 예상됩니다.</td></tr><tr><td>통합</td><td>개발 도구 생태계 통합</td><td>Git Hooks 가 IDE, 코드 에디터, 이슈 트래커, 지식 관리 시스템 등과 더욱 긴밀하게 통합될 것으로 예상됩니다.</td></tr><tr><td>확장</td><td>비개발 영역으로 확장</td><td>Git Hooks 의 개념이 소프트웨어 개발을 넘어 문서 관리, 디자인 시스템, 데이터 파이프라인 등으로 확장될 것으로 예상됩니다.</td></tr></tbody></table><h3 id=하위-주제로-분류하여-추가-학습-내용>하위 주제로 분류하여 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류하여-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>기초</td><td>Git Hooks 설정 기초</td><td>Git Hooks 의 기본 설정 방법, 활성화/비활성화, 권한 설정 등 기초 지식</td></tr><tr><td>기초</td><td>프로그래밍 언어별 Git Hooks</td><td>다양한 언어 (Bash, Python, JavaScript 등) 로 Git Hooks 작성하기</td></tr><tr><td>도구</td><td>Husky 깊게 알아보기</td><td>JavaScript 프로젝트에서 가장 널리 사용되는 Git Hooks 관리 도구 마스터하기</td></tr><tr><td>도구</td><td>pre-commit 프레임워크</td><td>다양한 언어 지원이 가능한 pre-commit 프레임워크 활용법</td></tr><tr><td>고급</td><td>서버 측 Git Hooks 심화</td><td>깃랩, 깃허브 등 Git 호스팅 서비스에서의 서버 측 훅 구현</td></tr><tr><td>고급</td><td>CI/CD 파이프라인과 Git Hooks 통합</td><td>Jenkins, GitHub Actions, GitLab CI 등과 Git Hooks 연동 방법</td></tr><tr><td>고급</td><td>대규모 조직에서의 Git Hooks 관리</td><td>수백 개의 저장소와 개발자가 있는 환경에서 Git Hooks 관리 전략</td></tr><tr><td>보안</td><td>보안 중심 Git Hooks 구현</td><td>취약점 스캐닝, 비밀 정보 유출 방지, SAST/DAST 통합</td></tr><tr><td>성능</td><td>Git Hooks 성능 최적화</td><td>대규모 코드베이스에서 Git Hooks 성능 병목 현상 해결 방법</td></tr><tr><td>사례 연구</td><td>산업별 Git Hooks 사례 연구</td><td>금융, 의료, 정부 등 다양한 산업에서의 Git Hooks 적용 사례</td></tr></tbody></table><h3 id=추가-학습-내용>추가 학습 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>연관 기술</td><td>GitOps</td><td>Git 을 중심으로 한 운영 워크플로우와 Git Hooks 의 역할</td></tr><tr><td>연관 기술</td><td>정적 코드 분석</td><td>Git Hooks 와 함께 활용할 수 있는 정적 코드 분석 도구와 방법론</td></tr><tr><td>연관 기술</td><td>코드 품질 메트릭스</td><td>Git Hooks 로 측정 및 관리할 수 있는 코드 품질 지표</td></tr><tr><td>개발 방법론</td><td>TDD 와 Git Hooks</td><td>테스트 주도 개발에서 Git Hooks 를 활용하는 방법</td></tr><tr><td>개발 방법론</td><td>지속적 품질 관리</td><td>Git Hooks 를 활용한 지속적인 코드 품질 관리 전략</td></tr><tr><td>도구 통합</td><td>Docker 와 Git Hooks</td><td>컨테이너화된 환경에서 Git Hooks 구현 전략</td></tr><tr><td>도구 통합</td><td>코드 리뷰 도구와 Git Hooks</td><td>Git Hooks 와 코드 리뷰 프로세스 및 도구 통합</td></tr><tr><td>관리</td><td>Git Hooks 모니터링</td><td>Git Hooks 실행 현황 및 효과 모니터링 방법</td></tr><tr><td>관리</td><td>Git Hooks 문서화</td><td>팀 내 Git Hooks 사용 문서화 및 지식 공유 전략</td></tr><tr><td>성능</td><td>Git Hooks 벤치마킹</td><td>Git Hooks 성능 측정 및 비교 방법론</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Husky</td><td>Git Hooks 를 손쉽게 관리하고 팀에 공유할 수 있게 해주는 도구</td></tr><tr><td>Lefthook</td><td>멀티 플랫폼 지원 훅 관리 도구</td></tr><tr><td>core.hooksPath</td><td>Git 훅 디렉토리 경로를 지정하는 Git 설정 옵션</td></tr></tbody></table><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>pre-receive</strong></td><td>서버 측 훅: 푸시된 커밋 전체 검증</td></tr><tr><td><strong>Husky</strong></td><td>Git Hooks 관리 도구: 패키지.json 에 훅 설정 가능</td></tr></tbody></table><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Hook</td><td>특정 이벤트 발생 시 자동으로 실행되는 스크립트</td></tr><tr><td>pre-commit</td><td>커밋 전에 실행되는 Hook 스크립트</td></tr><tr><td>commit-msg</td><td>커밋 메시지를 검사하는 Hook</td></tr><tr><td>pre-receive</td><td>원격 저장소에서 푸시 전에 실행되는 서버 측 Hook</td></tr><tr><td>core.hooksPath</td><td>공통 Hook 디렉토리를 지정할 수 있는 Git 설정 항목</td></tr></tbody></table><h3 id=용어-정리-3>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-3>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Git Hooks</td><td>Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트</td></tr><tr><td>클라이언트 측 훅</td><td>로컬 개발 환경에서 실행되는 Git Hooks 로, 개발자의 워크스테이션에서 작동</td></tr><tr><td>서버 측 훅</td><td>원격 저장소에서 실행되는 Git Hooks 로, 저장소 관리자가 설정하고 모든 사용자에게 적용</td></tr><tr><td>pre-commit</td><td>커밋이 생성되기 전에 실행되는 훅으로, 코드 검증에 주로 사용</td></tr><tr><td>pre-push</td><td>원격 저장소로 푸시하기 전에 실행되는 훅으로, 광범위한 테스트에 활용</td></tr><tr><td>post-receive</td><td>원격 저장소에서 푸시 작업이 완료된 후 실행되는 훅으로, 배포 자동화에 주로 사용</td></tr><tr><td>Husky</td><td>npm 기반 프로젝트에서 Git Hooks 를 쉽게 설정하고 관리할 수 있는 도구</td></tr><tr><td>lint-staged</td><td>스테이징된 파일에 대해서만 linter 를 실행하는 도구로, Git Hooks 와 함께 자주 사용</td></tr><tr><td>pre-commit 프레임워크</td><td>다양한 언어와 도구에 대한 훅 관리를 제공하는 Python 기반 프레임워크</td></tr><tr><td>Conventional Commits</td><td>커밋 메시지에 대한 규약으로, Git Hooks 를 통해 강제할 수 있음</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><p><a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks>Git 공식 문서 - Git Hooks</a></p></li><li><p><a href=https://typicode.github.io/husky/#/>Husky 공식 문서</a></p></li><li><p><a href=https://pre-commit.com/>pre-commit 공식 사이트</a></p></li><li><p><a href=https://docs.github.com/en/actions>GitHub Actions Docs</a></p></li></ul><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><a href=https://git-scm.com/book/ms/v2/Customizing-Git-Git-Hooks>Git 공식 문서</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-hooks>Atlassian Git 튜토리얼</a></li><li><a href=https://yozm.wishket.com/magazine/detail/2910/>2025 DevOps 트렌드 분석</a></li></ul><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><a href=https://git-scm.com/book/ko/v2/Customizing-Git-Git-Hooks>Git 공식 문서: Git Hooks</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-hooks>Atlassian Git Hooks 가이드</a></li><li><a href=https://typicode.github.io/husky/#/>Husky 공식 문서</a></li><li><a href=https://yozm.wishket.com/magazine/detail/2910/>2025 DevOps 트렌드 분석</a></li></ul><h3 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h3><ul><li><a href=https://git-scm.com/docs/githooks>Git Hooks 공식 문서</a></li><li><a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks>Pro Git Book - Git Hooks 섹션</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-hooks>Atlassian Git Hooks 튜토리얼</a></li><li><a href=https://typicode.github.io/husky/>Husky - Git Hooks 관리 도구</a></li><li><a href=https://pre-commit.com/>pre-commit 프레임워크 문서</a></li><li><a href=https://docs.gitlab.com/ee/administration/server_hooks.html>GitLab Server Hooks 문서</a></li><li><a href=https://github.blog/2021-06-15-integrating-git-hooks-github-actions/>GitHub Actions와 Git Hooks 통합 가이드</a></li><li><a href=https://medium.com/better-programming/improving-code-quality-with-git-hooks-54d004f3d761>Git Hooks를 활용한 코드 품질 관리</a></li><li><a href=https://github.com/evilmartians/lefthook>Lefthook - 빠른 Git Hooks 관리자</a></li><li><a href=https://www.infoq.com/articles/continuous-integration-git-hooks/>Git Hooks와 지속적 통합 파이프라인 구축</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/version-control-systems/>Version-Control-Systems</a></li><li><a href=https://buenhyden.github.io/tags/git-workflow/>Git-Workflow</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/static-code-analysis/><span class=title>« Prev</span><br><span>정적 코드 분석 (Static Code analysis)</span>
</a><a class=next href=https://buenhyden.github.io/posts/quality-assurance/fundamentals/quality-metric/lines-of-code/><span class=title>Next »</span><br><span>코드 크기 메트릭(Lines of Code, LOC)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>