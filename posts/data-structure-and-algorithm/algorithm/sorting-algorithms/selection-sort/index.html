<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>선택 정렬 (Selection Sort) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm,Sorting-Algorithms"><meta name=description content="선택 정렬 (Selection Sort)
선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.
선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.

  https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw
알고리즘 작동 원리


초기화:

배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.
초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.



최솟값 탐색:"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="선택 정렬 (Selection Sort)"><meta property="og:description" content="선택 정렬 (Selection Sort) 선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.
선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.
https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw
알고리즘 작동 원리 초기화:
배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다. 초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다. 최솟값 탐색:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-15T08:38:00+00:00"><meta property="article:modified_time" content="2024-10-15T08:38:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Sorting-Algorithms"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="선택 정렬 (Selection Sort)"><meta name=twitter:description content="선택 정렬 (Selection Sort)
선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.
선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.

  https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw
알고리즘 작동 원리


초기화:

배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.
초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.



최솟값 탐색:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/"},{"@type":"ListItem","position":4,"name":"정렬 알고리즘 (Sorting Algorithms)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/"},{"@type":"ListItem","position":5,"name":"선택 정렬 (Selection Sort)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"선택 정렬 (Selection Sort)","name":"선택 정렬 (Selection Sort)","description":"선택 정렬 (Selection Sort) 선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.\n전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.\n선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.\nhttps://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw\n알고리즘 작동 원리 초기화:\n배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다. 초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다. 최솟값 탐색:\n","keywords":["Data-Structure-and-Algorithm","Algorithm","Sorting-Algorithms"],"articleBody":"선택 정렬 (Selection Sort) 선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.\n전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.\n선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.\nhttps://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw\n알고리즘 작동 원리 초기화:\n배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다. 초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다. 최솟값 탐색:\n정렬되지 않은 영역에서 가장 작은 요소를 찾는다. 이 요소를 정렬되지 않은 영역의 첫 번째 요소와 **교환(swap)**한다. 영역 확장:\n정렬된 영역을 한 칸 확장하고, 정렬되지 않은 영역을 한 칸 축소한다. 배열이 완전히 정렬될 때까지 이 과정을 반복한다. 예시: [29, 10, 14, 37, 14]\n1단계: 전체에서 최솟값 10 선택 → 첫 번째 요소(29)와 교환 → [10, 29, 14, 37, 14] 2단계: 남은 배열(29, 14, 37, 14)에서 최솟값 14 선택 → 두 번째 요소(29)와 교환 → [10, 14, 29, 37, 14] 3단계: 남은 배열(29, 37, 14)에서 최솟값 14 선택 → 세 번째 요소(29)와 교환 → [10, 14, 14, 37, 29] 4단계: 남은 배열(37, 29)에서 최솟값 29 선택 → 네 번째 요소(37)와 교환 → [10, 14, 14, 29, 37] 시간 복잡도 최선/최악/평균: 모두 O(n²) 모든 경우에서 정렬되지 않은 영역을 완전 탐색해야 한다. 비교 횟수: $$ \\frac{n(n-1)}{2} $$ (n-1 + n-2 + … + 1)\n공간 복잡도 O(1): 배열 내에서 요소 교환만 이루어지므로 추가 메모리가 필요하지 않는다(In-place 알고리즘). 장단점 장점 구현이 간단하여 교육용으로 적합하다. 메모리 효율적입니다(제자리 정렬). 적은 교환 횟수: 최대 n-1번의 교환만 발생한다(버블 정렬보다 효율적). 단점 대규모 데이터에 비효율적: 시간 복잡도가 O(n²)이므로 성능이 급격히 저하된다. 불안정 정렬(Unstable Sort): 동일한 값의 요소가 원본 순서를 유지하지 못할 수 있다. 사용 사례 소규모 데이터 세트: 1,000개 미만의 요소를 정렬할 때. 메모리 제약 환경: 추가 메모리 사용을 최소화해야 할 때. 플래시 메모리: 쓰기 연산이 비용이 큰 경우(교환 횟수가 적음). 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 def selection_sort(arr): n = len(arr) for i in range(n-1): min_idx = i for j in range(i+1, n): if arr[j] \u003c arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr # 예시 실행 arr = [29, 10, 14, 37, 14] print(selection_sort(arr)) # 출력: [10, 14, 14, 29, 37] 다른 정렬 알고리즘과의 비교 버블 정렬(Bubble Sort): 더 많은 교환 발생 → 선택 정렬이 일반적으로 빠릅니다. 삽입 정렬(Insertion Sort): 거의 정렬된 배열에서 더 효율적이지만, 선택 정렬은 비교 횟수가 일정합니다. 합병 정렬(Merge Sort): O(n log n) 시간 복잡도로 대규모 데이터에 적합하지만, 추가 메모리가 필요합니다. 참고 및 출처 ","wordCount":"411","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-15T08:38:00Z","dateModified":"2024-10-15T08:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/>Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/>정렬 알고리즘 (Sorting Algorithms)</a></div><h1 class="post-title entry-hint-parent">선택 정렬 (Selection Sort)</h1><div class=post-meta><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;411 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Algorithm/Sorting%20Algorithms/Selection-Sort.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#선택-정렬-selection-sort>선택 정렬 (Selection Sort)</a><ul><li><a href=#알고리즘-작동-원리><strong>알고리즘 작동 원리</strong></a></li><li><a href=#시간-복잡도><strong>시간 복잡도</strong></a></li><li><a href=#공간-복잡도><strong>공간 복잡도</strong></a></li><li><a href=#장단점><strong>장단점</strong></a></li><li><a href=#사용-사례><strong>사용 사례</strong></a></li><li><a href=#구현-예시>구현 예시</a></li><li><a href=#다른-정렬-알고리즘과의-비교><strong>다른 정렬 알고리즘과의 비교</strong></a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=선택-정렬-selection-sort>선택 정렬 (Selection Sort)<a hidden class=anchor aria-hidden=true href=#선택-정렬-selection-sort>#</a></h2><p>선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, <strong>작은 데이터 세트에서 효율적</strong>이며 <strong>메모리 사용이 최소화</strong>되는 특징을 갖는다.<br>전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 <strong>정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치</strong>하는 방식으로 동작한다.</p><p>선택 정렬은 <strong>알고리즘의 기본 원리를 이해</strong>하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.</p><p><figure><img alt="Selection Sort" loading=lazy src=/img/Selection-sort.png><figcaption>https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw</figcaption></figure></p><h3 id=알고리즘-작동-원리><strong>알고리즘 작동 원리</strong><a hidden class=anchor aria-hidden=true href=#알고리즘-작동-원리>#</a></h3><ol><li><p><strong>초기화</strong>:</p><ul><li>배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.</li><li>초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.</li></ul></li><li><p><strong>최솟값 탐색</strong>:</p><ul><li>정렬되지 않은 영역에서 <strong>가장 작은 요소</strong>를 찾는다.</li><li>이 요소를 정렬되지 않은 영역의 첫 번째 요소와 **교환(swap)**한다.</li></ul></li><li><p><strong>영역 확장</strong>:</p><ul><li>정렬된 영역을 한 칸 확장하고, 정렬되지 않은 영역을 한 칸 축소한다.</li><li>배열이 완전히 정렬될 때까지 이 과정을 반복한다.</li></ul></li></ol><p><strong>예시</strong>: <code>[29, 10, 14, 37, 14]</code></p><ul><li><strong>1단계</strong>: 전체에서 최솟값 <code>10</code> 선택 → 첫 번째 요소(<code>29</code>)와 교환 → <code>[10, 29, 14, 37, 14]</code></li><li><strong>2단계</strong>: 남은 배열(<code>29, 14, 37, 14</code>)에서 최솟값 <code>14</code> 선택 → 두 번째 요소(<code>29</code>)와 교환 → <code>[10, 14, 29, 37, 14]</code></li><li><strong>3단계</strong>: 남은 배열(<code>29, 37, 14</code>)에서 최솟값 <code>14</code> 선택 → 세 번째 요소(<code>29</code>)와 교환 → <code>[10, 14, 14, 37, 29]</code></li><li><strong>4단계</strong>: 남은 배열(<code>37, 29</code>)에서 최솟값 <code>29</code> 선택 → 네 번째 요소(<code>37</code>)와 교환 → <code>[10, 14, 14, 29, 37]</code></li></ul><h3 id=시간-복잡도><strong>시간 복잡도</strong><a hidden class=anchor aria-hidden=true href=#시간-복잡도>#</a></h3><ul><li><strong>최선/최악/평균</strong>: 모두 <strong>O(n²)</strong><ul><li>모든 경우에서 정렬되지 않은 영역을 완전 탐색해야 한다.</li><li>비교 횟수: $$ \frac{n(n-1)}{2} $$</li></ul></li></ul><p>(n-1 + n-2 + … + 1)</p><h3 id=공간-복잡도><strong>공간 복잡도</strong><a hidden class=anchor aria-hidden=true href=#공간-복잡도>#</a></h3><ul><li><strong>O(1)</strong>: 배열 내에서 요소 교환만 이루어지므로 추가 메모리가 필요하지 않는다(<strong>In-place 알고리즘</strong>).</li></ul><h3 id=장단점><strong>장단점</strong><a hidden class=anchor aria-hidden=true href=#장단점>#</a></h3><h4 id=장점><strong>장점</strong><a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li><strong>구현이 간단</strong>하여 교육용으로 적합하다.</li><li><strong>메모리 효율적</strong>입니다(제자리 정렬).</li><li><strong>적은 교환 횟수</strong>: 최대 <strong>n-1번</strong>의 교환만 발생한다(버블 정렬보다 효율적).</li></ul><h4 id=단점><strong>단점</strong><a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>대규모 데이터에 비효율적</strong>: 시간 복잡도가 O(n²)이므로 성능이 급격히 저하된다.</li><li><strong>불안정 정렬(Unstable Sort)</strong>: 동일한 값의 요소가 원본 순서를 유지하지 못할 수 있다.</li></ul><h3 id=사용-사례><strong>사용 사례</strong><a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h3><ul><li><strong>소규모 데이터 세트</strong>: 1,000개 미만의 요소를 정렬할 때.</li><li><strong>메모리 제약 환경</strong>: 추가 메모리 사용을 최소화해야 할 때.</li><li><strong>플래시 메모리</strong>: 쓰기 연산이 비용이 큰 경우(교환 횟수가 적음).</li></ul><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_idx</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 실행</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>29</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=mi>37</span><span class=p>,</span> <span class=mi>14</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>))</span>  <span class=c1># 출력: [10, 14, 14, 29, 37]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=다른-정렬-알고리즘과의-비교><strong>다른 정렬 알고리즘과의 비교</strong><a hidden class=anchor aria-hidden=true href=#다른-정렬-알고리즘과의-비교>#</a></h3><ul><li><strong>버블 정렬(Bubble Sort)</strong>: 더 많은 교환 발생 → 선택 정렬이 일반적으로 빠릅니다.</li><li><strong>삽입 정렬(Insertion Sort)</strong>: 거의 정렬된 배열에서 더 효율적이지만, 선택 정렬은 비교 횟수가 일정합니다.</li><li><strong>합병 정렬(Merge Sort)</strong>: O(n log n) 시간 복잡도로 대규모 데이터에 적합하지만, 추가 메모리가 필요합니다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/sorting-algorithms/>Sorting-Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/><span class=title>« Prev</span><br><span>삽입 정렬 (Insertion Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/><span class=title>Next »</span><br><span>퀵 정렬 (Quick Sort)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>