<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>삽입 정렬 (Insertion Sort) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm,Sorting-Algorithms"><meta name=description content="삽입 정렬 (Insertion Sort)
삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.
삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.

  https://www.geeksforgeeks.org/insertion-sort-algorithm/
삽입 정렬의 작동 원리

초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.
요소 선택: 정렬되지 않은 부분에서 요소를 선택한다.
비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.
삽입: 찾은 위치에 요소를 삽입한다.
반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.

예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="삽입 정렬 (Insertion Sort)"><meta property="og:description" content="삽입 정렬 (Insertion Sort) 삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.
삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
https://www.geeksforgeeks.org/insertion-sort-algorithm/
삽입 정렬의 작동 원리 초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다. 요소 선택: 정렬되지 않은 부분에서 요소를 선택한다. 비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다. 삽입: 찾은 위치에 요소를 삽입한다. 반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다. 예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-15T08:38:00+00:00"><meta property="article:modified_time" content="2024-10-15T08:38:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Sorting-Algorithms"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="삽입 정렬 (Insertion Sort)"><meta name=twitter:description content="삽입 정렬 (Insertion Sort)
삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.
삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.

  https://www.geeksforgeeks.org/insertion-sort-algorithm/
삽입 정렬의 작동 원리

초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.
요소 선택: 정렬되지 않은 부분에서 요소를 선택한다.
비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.
삽입: 찾은 위치에 요소를 삽입한다.
반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.

예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/"},{"@type":"ListItem","position":4,"name":"정렬 알고리즘 (Sorting Algorithms)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/"},{"@type":"ListItem","position":5,"name":"삽입 정렬 (Insertion Sort)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"삽입 정렬 (Insertion Sort)","name":"삽입 정렬 (Insertion Sort)","description":"삽입 정렬 (Insertion Sort) 삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.\n이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.\n삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.\n그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.\nhttps://www.geeksforgeeks.org/insertion-sort-algorithm/\n삽입 정렬의 작동 원리 초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다. 요소 선택: 정렬되지 않은 부분에서 요소를 선택한다. 비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다. 삽입: 찾은 위치에 요소를 삽입한다. 반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다. 예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정\n","keywords":["Data-Structure-and-Algorithm","Algorithm","Sorting-Algorithms"],"articleBody":"삽입 정렬 (Insertion Sort) 삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.\n이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.\n삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.\n그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.\nhttps://www.geeksforgeeks.org/insertion-sort-algorithm/\n삽입 정렬의 작동 원리 초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다. 요소 선택: 정렬되지 않은 부분에서 요소를 선택한다. 비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다. 삽입: 찾은 위치에 요소를 삽입한다. 반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다. 예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정\n1단계: 2를 5와 비교 → [2, 5, 4, 6, 1, 3] 2단계: 4를 5, 2와 비교 → [2, 4, 5, 6, 1, 3] 3단계: 6은 이미 올바른 위치 → 변화 없음 4단계: 1을 모든 요소와 비교 → [1, 2, 4, 5, 6, 3] 5단계: 3을 6, 5, 4, 2와 비교 → [1, 2, 3, 4, 5, 6] 시간 복잡도 최선의 경우 (이미 정렬된 배열): O(n) - 각 요소가 한 번씩만 비교된다. 평균 및 최악의 경우 (역순 정렬): O(n²) - 모든 요소를 비교하고 이동시켜야 한다. 공간 복잡도 O(1): 추가 메모리 없이 배열 내에서 요소를 교환하며 정렬한다. 장점 간단한 구현: 코드가 직관적이고 이해하기 쉽다. 제자리 정렬 (In-place): 추가 메모리를 거의 사용하지 않는다. 안정 정렬 (Stable): 동일한 값의 요소들이 원본 순서를 유지한다. 작은 데이터셋 효율성: 작은 배열이나 부분 정렬된 배열에서 매우 빠르다. 단점 큰 데이터셋 비효율: 대규모 데이터에서는 O(n²) 시간 복잡도로 인해 성능이 급격히 저하된다. 비교적 많은 이동 연산: 요소 삽입을 위해 여러 요소를 이동시켜야 한다. 최적화 전략 이진 검색 활용: 정렬된 부분에서 삽입 위치를 이진 검색으로 찾아 비교 횟수를 줄인다. 조기 종료: 삽입 과정 중 교환이 없으면 반복을 중단하여 불필요한 연산을 줄인다. 구현 예시 기본적인 삽입 정렬의 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def insertion_sort(arr): # 첫 번째 요소는 이미 정렬되어 있다고 가정하고 시작 for i in range(1, len(arr)): # 현재 삽입할 요소를 선택 key = arr[i] # 정렬된 부분에서 삽입할 위치를 찾음 j = i - 1 # key보다 큰 요소들을 오른쪽으로 이동 while j \u003e= 0 and arr[j] \u003e key: arr[j + 1] = arr[j] j -= 1 # 찾은 위치에 key 삽입 arr[j + 1] = key return arr 거의 정렬된 데이터 처리:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def nearly_sorted_insertion_sort(arr, max_distance): \"\"\" 각 요소가 최종 위치에서 최대 max_distance만큼 떨어져 있는 거의 정렬된 배열을 위한 최적화된 삽입 정렬 \"\"\" for i in range(1, len(arr)): key = arr[i] j = i - 1 # 제한된 범위 내에서만 검색 while j \u003e= max(0, i-max_distance) and arr[j] \u003e key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr 온라인 정렬 (실시간 데이터 처리):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class OnlineInserter: def __init__(self): self.sorted_data = [] def insert(self, value): \"\"\" 정렬된 상태를 유지하면서 새로운 값을 삽입 \"\"\" left, right = 0, len(self.sorted_data) # 이진 검색으로 삽입 위치 찾기 while left \u003c right: mid = (left + right) // 2 if self.sorted_data[mid] \u003c= value: left = mid + 1 else: right = mid self.sorted_data.insert(left, value) 적용 사례 실시간 데이터 처리: 실시간으로 들어오는 데이터를 정렬해야 할 때 유용하다. 온라인 게임 순위 업데이트: 새로운 점수가 추가될 때마다 순위를 재정렬하는 데 적합하다. 인터랙티브 애플리케이션: 사용자 입력에 따라 데이터를 지속적으로 정렬해야 하는 경우 효율적이다. 참고 및 출처 ","wordCount":"603","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-15T08:38:00Z","dateModified":"2024-10-15T08:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/>Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/>정렬 알고리즘 (Sorting Algorithms)</a></div><h1 class="post-title entry-hint-parent">삽입 정렬 (Insertion Sort)</h1><div class=post-meta><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;603 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Algorithm/Sorting%20Algorithms/Insertion-Sort.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#삽입-정렬-insertion-sort>삽입 정렬 (Insertion Sort)</a><ul><li><a href=#삽입-정렬의-작동-원리><strong>삽입 정렬의 작동 원리</strong></a></li><li><a href=#시간-복잡도>시간 복잡도</a></li><li><a href=#공간-복잡도>공간 복잡도</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#최적화-전략>최적화 전략</a></li><li><a href=#구현-예시>구현 예시</a></li><li><a href=#적용-사례>적용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=삽입-정렬-insertion-sort>삽입 정렬 (Insertion Sort)<a hidden class=anchor aria-hidden=true href=#삽입-정렬-insertion-sort>#</a></h2><p>삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.<br>이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.</p><p>삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.<br>그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.</p><p><figure><img alt="Insertion Sort" loading=lazy src=/img/Insertion-sorting.png><figcaption>https://www.geeksforgeeks.org/insertion-sort-algorithm/</figcaption></figure></p><h3 id=삽입-정렬의-작동-원리><strong>삽입 정렬의 작동 원리</strong><a hidden class=anchor aria-hidden=true href=#삽입-정렬의-작동-원리>#</a></h3><ol><li><strong>초기화</strong>: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.</li><li><strong>요소 선택</strong>: 정렬되지 않은 부분에서 요소를 선택한다.</li><li><strong>비교 및 이동</strong>: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.</li><li><strong>삽입</strong>: 찾은 위치에 요소를 삽입한다.</li><li><strong>반복</strong>: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.</li></ol><p><strong>예시</strong>: 배열 <code>[5, 2, 4, 6, 1, 3]</code>의 정렬 과정</p><ul><li><strong>1단계</strong>: <code>2</code>를 <code>5</code>와 비교 → <code>[2, 5, 4, 6, 1, 3]</code></li><li><strong>2단계</strong>: <code>4</code>를 <code>5</code>, <code>2</code>와 비교 → <code>[2, 4, 5, 6, 1, 3]</code></li><li><strong>3단계</strong>: <code>6</code>은 이미 올바른 위치 → 변화 없음</li><li><strong>4단계</strong>: <code>1</code>을 모든 요소와 비교 → <code>[1, 2, 4, 5, 6, 3]</code></li><li><strong>5단계</strong>: <code>3</code>을 <code>6</code>, <code>5</code>, <code>4</code>, <code>2</code>와 비교 → <code>[1, 2, 3, 4, 5, 6]</code></li></ul><h3 id=시간-복잡도>시간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도>#</a></h3><ul><li><strong>최선의 경우 (이미 정렬된 배열)</strong>: O(n) - 각 요소가 한 번씩만 비교된다.</li><li><strong>평균 및 최악의 경우 (역순 정렬)</strong>: O(n²) - 모든 요소를 비교하고 이동시켜야 한다.</li></ul><h3 id=공간-복잡도>공간 복잡도<a hidden class=anchor aria-hidden=true href=#공간-복잡도>#</a></h3><ul><li><strong>O(1)</strong>: 추가 메모리 없이 배열 내에서 요소를 교환하며 정렬한다.</li></ul><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ul><li><strong>간단한 구현</strong>: 코드가 직관적이고 이해하기 쉽다.</li><li><strong>제자리 정렬 (In-place)</strong>: 추가 메모리를 거의 사용하지 않는다.</li><li><strong>안정 정렬 (Stable)</strong>: 동일한 값의 요소들이 원본 순서를 유지한다.</li><li><strong>작은 데이터셋 효율성</strong>: 작은 배열이나 부분 정렬된 배열에서 매우 빠르다.</li></ul><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ul><li><strong>큰 데이터셋 비효율</strong>: 대규모 데이터에서는 O(n²) 시간 복잡도로 인해 성능이 급격히 저하된다.</li><li><strong>비교적 많은 이동 연산</strong>: 요소 삽입을 위해 여러 요소를 이동시켜야 한다.</li></ul><h3 id=최적화-전략>최적화 전략<a hidden class=anchor aria-hidden=true href=#최적화-전략>#</a></h3><ul><li><strong>이진 검색 활용</strong>: 정렬된 부분에서 삽입 위치를 이진 검색으로 찾아 비교 횟수를 줄인다.</li><li><strong>조기 종료</strong>: 삽입 과정 중 교환이 없으면 반복을 중단하여 불필요한 연산을 줄인다.</li></ul><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><ol><li><p>기본적인 삽입 정렬의 구현</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 요소는 이미 정렬되어 있다고 가정하고 시작</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 삽입할 요소를 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정렬된 부분에서 삽입할 위치를 찾음</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># key보다 큰 요소들을 오른쪽으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 찾은 위치에 key 삽입</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>거의 정렬된 데이터 처리:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>nearly_sorted_insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>max_distance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    각 요소가 최종 위치에서 최대 max_distance만큼 떨어져 있는
</span></span></span><span class=line><span class=cl><span class=s2>    거의 정렬된 배열을 위한 최적화된 삽입 정렬
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 제한된 범위 내에서만 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=nb>max</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=n>max_distance</span><span class=p>)</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>온라인 정렬 (실시간 데이터 처리):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>OnlineInserter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sorted_data</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        정렬된 상태를 유지하면서 새로운 값을 삽입
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>sorted_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 이진 검색으로 삽입 위치 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>sorted_data</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>sorted_data</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=적용-사례>적용 사례<a hidden class=anchor aria-hidden=true href=#적용-사례>#</a></h3><ul><li><strong>실시간 데이터 처리</strong>: 실시간으로 들어오는 데이터를 정렬해야 할 때 유용하다.</li><li><strong>온라인 게임 순위 업데이트</strong>: 새로운 점수가 추가될 때마다 순위를 재정렬하는 데 적합하다.</li><li><strong>인터랙티브 애플리케이션</strong>: 사용자 입력에 따라 데이터를 지속적으로 정렬해야 하는 경우 효율적이다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/sorting-algorithms/>Sorting-Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/><span class=title>« Prev</span><br><span>병합 정렬 (Merge Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/><span class=title>Next »</span><br><span>선택 정렬 (Selection Sort)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>