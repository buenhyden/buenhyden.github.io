<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm"><meta name=description content="문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Algorithm"><meta property="og:description" content="문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Algorithm"><meta name=twitter:description content="문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a></div><h1>Algorithm</h1><div class=post-description>문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차</div></header><div class=post-content><h2 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h2><p>알고리즘은 주어진 문제를 해결하기 위한 명확하고 순차적인 단계들의 집합이다.<br>우리의 일상생활에 비유하자면, 요리 레시피나 조립 설명서와 같은 것이라고 할 수 있다.<br>레시피가 음식을 만드는 정확한 순서와 방법을 알려주는 것처럼, 알고리즘은 컴퓨터가 특정 문제를 해결하기 위해 따라야 할 정확한 지침을 제공한다.</p><p><figure><img alt="What is Algorithm?" loading=lazy src=/img/What-is-Algorithm_-1024x631.jpg><figcaption>Source: https://www.geeksforgeeks.org/fundamentals-of-algorithms/</figcaption></figure></p><h3 id=특성>특성<a hidden class=anchor aria-hidden=true href=#특성>#</a></h3><ol><li><strong>입력(Input)</strong>: 문제를 해결하기 위한 초기 데이터나 조건이 주어져야 한다.</li><li><strong>출력(Output)</strong>: 알고리즘은 반드시 결과를 생성해야 한다.</li><li><strong>명확성(Definiteness)</strong>: 각 단계는 모호하지 않고 정확해야 한다.</li><li><strong>유한성(Finiteness)</strong>: 알고리즘은 반드시 유한한 단계 후에 종료되어야 한다.</li><li><strong>효과성(Effectiveness)</strong>: 각 단계는 실제로 실행 가능해야 한다.</li></ol><h3 id=필요한-이유>필요한 이유<a hidden class=anchor aria-hidden=true href=#필요한-이유>#</a></h3><p>프로그래밍에서 알고리즘이 필요한 이유는 여러 가지가 있다.<br>가장 중요한 것은 효율성이다.<br>같은 문제를 해결하더라도 어떤 알고리즘을 사용하느냐에 따라 실행 시간과 메모리 사용량이 크게 달라질 수 있다.</p><p>예를 들어, 1부터 100까지의 합을 구하는 문제를 생각해보자.<br>단순히 반복문을 사용하여 더하는 방법도 있지만, 가우스의 덧셈 공식을 사용하면 단 한 번의 계산으로 결과를 얻을 수 있다.<br>이처럼 효율적인 알고리즘은 시간과 자원을 절약하게 해준다.</p><h3 id=평가-기준>평가 기준<a hidden class=anchor aria-hidden=true href=#평가-기준>#</a></h3><p>알고리즘을 평가할 때는 주로 시간 복잡도와 공간 복잡도를 고려한다.<br>시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 의미하며, 공간 복잡도는 필요한 메모리의 양을 의미한다.<br>이러한 복잡도는 보통 빅오(Big-O) 표기법을 사용하여 나타낸다.<br>예를 들어, O(n)은 입력 크기에 비례하여 시간이 증가함을 의미하고, O(log n)은 입력 크기가 커져도 시간이 로그함수처럼 완만하게 증가함을 의미한다.</p><h3 id=중요성>중요성<a hidden class=anchor aria-hidden=true href=#중요성>#</a></h3><ol><li>효율성 향상: 효율적인 알고리즘은 프로그램의 실행 속도를 높이고 시스템 자원 사용을 최소화한다.</li><li>문제 해결 능력 개발: 알고리즘 학습은 논리적 사고력과 문제 해결 능력을 향상시킨다.</li><li>복잡한 문제 해결: 알고리즘은 복잡한 문제를 체계적으로 분석하고 해결하는 데 도움을 준다.</li><li>프로그래밍 역량 강화: 알고리즘에 대한 이해는 효율적인 코드 작성과 프로그램 최적화에 필수적이다.</li><li>다양한 분야 응용: 알고리즘은 빅데이터 분석, 인공지능, 네트워크 통신 등 다양한 기술 분야에서 핵심적인 역할을 한다.</li></ol><h3 id=알고리즘-설계의-기본-원칙>알고리즘 설계의 기본 원칙<a hidden class=anchor aria-hidden=true href=#알고리즘-설계의-기본-원칙>#</a></h3><p>좋은 알고리즘을 설계하기 위해서는 몇 가지 원칙을 고려해야 한다.<br>정확성이 가장 기본이 되어야 하며, 효율성을 고려해야 한다.<br>또한 알고리즘은 가능한 한 단순하고 이해하기 쉬워야 하며, 확장성이 있어야 한다.<br>문제를 작은 단위로 나누어 해결하는 분할 정복 방법이나, 최적의 해결책을 찾아가는 그리디 방법 등 다양한 설계 기법이 있다.</p><h3 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h3><p>각 카테고리의 알고리즘들은 서로 다른 문제 영역에 특화되어 있으며, 실제 응용에서는 여러 알고리즘을 조합하여 사용하는 경우가 많다.<br>효율적인 프로그램 개발을 위해서는 각 알고리즘의 특성과 적용 가능한 상황을 잘 이해하고 있어야 한다.</p><h4 id=정렬-알고리즘-sorting-algorithms>정렬 알고리즘 (Sorting Algorithms)<a hidden class=anchor aria-hidden=true href=#정렬-알고리즘-sorting-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>안정성</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>비교 기반 정렬</td><td>O(n log n) ~ O(n²)</td><td>O(1) ~ O(n)</td><td>변동적</td><td>• 요소 간 비교를 통한 정렬<br>• 범용적 사용 가능</td><td>• 퀵 정렬<br>• 병합 정렬<br>• 힙 정렬</td><td>• 데이터베이스 정렬<br>• 파일 시스템</td></tr><tr><td>분산 정렬</td><td>O(n + k)</td><td>O(n + k)</td><td>대부분 안정적</td><td>• 키 값의 분포를 이용<br>• 특정 조건에서 매우 효율적</td><td>• 기수 정렬<br>• 계수 정렬</td><td>• 정수 데이터 정렬<br>• 문자열 정렬</td></tr></tbody></table><h4 id=검색-알고리즘-search-algorithms>검색 알고리즘 (Search Algorithms)<a hidden class=anchor aria-hidden=true href=#검색-알고리즘-search-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>전제 조건</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>정렬 기반 검색</td><td>O(log n)</td><td>O(1)</td><td>정렬된 데이터</td><td>• 분할 정복 방식<br>• 효율적인 검색</td><td>• 이진 검색<br>• 보간 검색</td><td>• 데이터베이스 검색<br>• 사전 검색</td></tr><tr><td>해시 기반 검색</td><td>O(1) 평균</td><td>O(n)</td><td>해시 함수 필요</td><td>• 직접 접근<br>• 충돌 해결 필요</td><td>• 해시 테이블 검색<br>• 블룸 필터</td><td>• 캐시 시스템<br>• 데이터베이스 인덱싱</td></tr></tbody></table><h4 id=그래프-알고리즘-graph-algorithms>그래프 알고리즘 (Graph Algorithms)<a hidden class=anchor aria-hidden=true href=#그래프-알고리즘-graph-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>해결 문제</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>최단 경로</td><td>O(V log V + E)</td><td>O(V)</td><td>경로 최적화</td><td>• 가중치 고려<br>• 다양한 최적화 가능</td><td>• 다익스트라<br>• 벨만-포드</td><td>• 네비게이션<br>• 네트워크 라우팅</td></tr><tr><td>순회</td><td>O(V + E)</td><td>O(V)</td><td>그래프 탐색</td><td>• 전체 노드 방문<br>• 연결성 확인</td><td>• DFS<br>• BFS</td><td>• 웹 크롤링<br>• 소셜 네트워크 분석</td></tr></tbody></table><h4 id=문자열-알고리즘-string-algorithms>문자열 알고리즘 (String Algorithms)<a hidden class=anchor aria-hidden=true href=#문자열-알고리즘-string-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>주요 기능</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>패턴 매칭</td><td>O(n + m)</td><td>O(m)</td><td>문자열 검색</td><td>• 패턴 찾기<br>• 효율적인 매칭</td><td>• KMP<br>• Boyer-Moore</td><td>• 텍스트 편집기<br>• DNA 서열 분석</td></tr><tr><td>문자열 처리</td><td>O(n)</td><td>O(1) ~ O(n)</td><td>문자열 변환</td><td>• 문자열 조작<br>• 인코딩 처리</td><td>• 라빈-카프<br>• 매나처</td><td>• 데이터 압축<br>• 자연어 처리</td></tr></tbody></table><h4 id=기하-알고리즘-geometric-algorithms>기하 알고리즘 (Geometric Algorithms)<a hidden class=anchor aria-hidden=true href=#기하-알고리즘-geometric-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>처리 대상</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>컨벡스 헐</td><td>O(n log n)</td><td>O(n)</td><td>점집합</td><td>• 외곽선 찾기<br>• 기하학적 최적화</td><td>• Graham Scan<br>• Jarvis March</td><td>• 컴퓨터 그래픽스<br>• 패턴 인식</td></tr><tr><td>근접점 쌍</td><td>O(n log n)</td><td>O(n)</td><td>점집합</td><td>• 최근접 점 찾기<br>• 공간 분할</td><td>• 분할 정복<br>• 평면 스위핑</td><td>• 충돌 감지<br>• 클러스터링</td></tr></tbody></table><h4 id=수치-알고리즘-numerical-algorithms>수치 알고리즘 (Numerical Algorithms)<a hidden class=anchor aria-hidden=true href=#수치-알고리즘-numerical-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>정확도</th><th>적용 분야</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>근사해 찾기</td><td>변동적</td><td>조절 가능</td><td>수치 해석</td><td>• 반복적 개선<br>• 오차 최소화</td><td>• 뉴턴-랩슨<br>• 이분법</td><td>• 공학 계산<br>• 금융 모델링</td></tr><tr><td>행렬 연산</td><td>O(n³)</td><td>정확함</td><td>선형대수</td><td>• 행렬 분해<br>• 연립방정식 해결</td><td>• 가우스 소거법<br>• LU 분해</td><td>• 3D 그래픽스<br>• 신호 처리</td></tr></tbody></table><h4 id=최적화-알고리즘-optimization-algorithms>최적화 알고리즘 (Optimization Algorithms)<a hidden class=anchor aria-hidden=true href=#최적화-알고리즘-optimization-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>최적성</th><th>적용 분야</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>전역 최적화</td><td>변동적</td><td>보장 가능</td><td>조합 최적화</td><td>• 전체 해 탐색<br>• 최적해 보장</td><td>• 분기 한정법<br>• 동적 계획법</td><td>• 물류 최적화<br>• 자원 할당</td></tr><tr><td>근사 최적화</td><td>다항시간</td><td>근사해</td><td>실시간 최적화</td><td>• 빠른 해 도출<br>• 실용적 해결책</td><td>• 유전 알고리즘<br>• 시뮬레이티드 어닐링</td><td>• 스케줄링<br>• 네트워크 설계</td></tr></tbody></table><h4 id=암호화-알고리즘-cryptographic-algorithms>암호화 알고리즘 (Cryptographic Algorithms)<a hidden class=anchor aria-hidden=true href=#암호화-알고리즘-cryptographic-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>보안 강도</th><th>속도</th><th>용도</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>대칭키 암호화</td><td>중간</td><td>빠름</td><td>데이터 보안</td><td>• 같은 키로 암/복호화<br>• 빠른 처리</td><td>• AES<br>• DES</td><td>• 파일 암호화<br>• 통신 보안</td></tr><tr><td>공개키 암호화</td><td>높음</td><td>느림</td><td>키 교환/인증</td><td>• 공개키/개인키 쌍<br>• 수학적 기반</td><td>• RSA<br>• ECC</td><td>• 디지털 서명<br>• SSL/TLS</td></tr></tbody></table><h4 id=머신러닝-알고리즘-machine-learning-algorithms>머신러닝 알고리즘 (Machine Learning Algorithms)<a hidden class=anchor aria-hidden=true href=#머신러닝-알고리즘-machine-learning-algorithms>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>학습 방식</th><th>데이터 요구량</th><th>적용 분야</th><th>주요 특징</th><th>대표적 알고리즘</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>지도 학습</td><td>레이블 필요</td><td>많음</td><td>예측/분류</td><td>• 입출력 쌍 학습<br>• 패턴 인식</td><td>• 신경망<br>• SVM</td><td>• 이미지 인식<br>• 스팸 필터링</td></tr><tr><td>비지도 학습</td><td>레이블 불필요</td><td>매우 많음</td><td>패턴 발견</td><td>• 데이터 구조 파악<br>• 군집화</td><td>• K-means<br>• PCA</td><td>• 추천 시스템<br>• 이상 탐지</td></tr></tbody></table><h4 id=동적-프로그래밍-dynamic-programming>동적 프로그래밍 (Dynamic Programming)<a hidden class=anchor aria-hidden=true href=#동적-프로그래밍-dynamic-programming>#</a></h4><table><thead><tr><th>알고리즘 유형</th><th>시간 복잡도</th><th>공간 복잡도</th><th>문제 특성</th><th>주요 특징</th><th>대표적 예제</th><th>실제 응용 사례</th></tr></thead><tbody><tr><td>Top-Down</td><td>O(상태 수 × 상태당 계산)</td><td>O(상태 수)</td><td>최적 부분 구조</td><td>• 메모이제이션<br>• 재귀적 구현</td><td>• 피보나치 수열<br>• 최장 공통 부분수열</td><td>• 경로 계획<br>• 리소스 할당</td></tr><tr><td>Bottom-Up</td><td>O(상태 수 × 상태당 계산)</td><td>O(상태 수)</td><td>중복 부분 문제</td><td>• 테이블화<br>• 반복적 구현</td><td>• 배낭 문제<br>• 최단 경로</td><td>• 순서 최적화<br>• 게임 전략</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>보간 검색 (Interpolation Search)</h2></header><div class=entry-content><p>보간 검색 (Interpolation Search) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-30 12:33:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보간 검색 (Interpolation Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>깊이 우선 탐색 (Depth-First Search)</h2></header><div class=entry-content><p>깊이 우선 탐색 (Depth-First Search, DFS) 그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.
미로에서 한 길을 끝까지 가보고, 막힌 길이면 되돌아와서 다른 길을 탐색하는 것과 비슷하다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
작동 방식 루트 노드(또는 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색한다.
각 분기에서 가장 깊은 곳까지 탐색한 후에 백트래킹(되돌아가기)하여 다음 분기로 넘어간다.
장점 메모리 사용이 너비 우선 탐색(BFS)보다 효율적. 현재 경로상의 노드들만 기억하면 되기 때문. 목표 노드가 깊은 단계에 있을 때 BFS보다 빠르게 발견할 수 있다. 모든 노드를 방문하고자 할 때 적합. 단점 해가 없는 경로에 빠질 경우 불필요한 탐색을 할 수 있다. 찾은 경로가 최단 경로라는 보장이 없다. 무한 깊이의 경우에는 탐색이 끝나지 않을 수 있다. 주의해야 할 점 깊이가 매우 깊은 그래프에서는 재귀 방식 사용시 스택 오버플로우가 발생할 수 있으므로, 반복적 방식을 고려해야 합니다. 양방향 그래프에서는 무한 루프를 방지하기 위해 반드시 방문 체크를 해야 합니다. 그래프에 사이클이 있는 경우를 항상 고려해야 합니다. 주로 사용하는 데이터 구조 DFS는 주로 스택(Stack)을 사용하여 구현한다.
재귀 호출을 사용할 경우 시스템 스택을 활용하고, 반복문을 사용할 경우 직접 스택을 구현하여 사용한다.
...</p></div><footer class=entry-footer><span title='2024-10-30 05:41:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 깊이 우선 탐색 (Depth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>너비 우선 탐색 (Breadth-First Search)</h2></header><div class=entry-content><p>너비 우선 탐색 (Breadth-First Search, BFS) BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘.
시작 노드에서 인접한 모든 노드를 탐색한 후, 그 다음 레벨의 노드들을 차례로 탐색한다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
장점 최단 경로 보장: 가중치가 없는 그래프에서 출발 노드에서 목표 노드까지의 최단 경로를 항상 찾는다. 무한 경로 방지: 모든 경로를 동시에 진행하기 때문에 무한히 깊은 경로에 빠질 위험이 없습니다. 넓은 탐색: 특정 깊이까지의 모든 노드를 탐색하는 데 적합합니다. 단점 높은 메모리 사용량: 큐에 저장해야 할 노드가 많아질 수 있어 메모리 사용량이 큽니다. 탐색 속도 저하: 경로가 매우 길거나 그래프가 클 경우, 탐색 속도가 느려질 수 있습니다. 해가 없는 경우 비효율적: 유한 그래프에서는 모든 노드를 탐색해야 하고, 무한 그래프에서는 종료하지 못할 수 있습니다. 주의해야 할 점 방문 여부를 반드시 확인해야 합니다. 그렇지 않으면 중복 방문으로 인해 무한 루프에 빠질 수 있습니다. 큐 자료구조를 활용해야 하며, 재귀적으로 구현하지 않습니다. 주로 사용하는 데이터 구조 큐(Queue): BFS는 선입선출(FIFO) 원칙을 따르므로 큐를 사용하여 다음에 탐색할 노드를 관리합니다. 큐를 사용하면 현재 레벨의 모든 노드를 방문한 후 다음 레벨로 자연스럽게 넘어갈 수 있습니다. 배열 또는 집합(Set): 방문 여부를 기록하기 위해 사용됩니다. 배열은 간단하게 구현할 수 있고, 집합은 중복 방지에 효과적입니다. 구현 예시 Java 인접 리스트를 사용하여 그래프를 표현했습니다. LinkedList를 사용하여 큐를 구현했습니다. 기본적인 BFS 탐색을 구현하여 방문 순서를 출력합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Java Implementation import java.util.*; class Graph { private int V; // 정점의 개수 private LinkedList&lt;Integer>[] adj; // 인접 리스트 @SuppressWarnings("unchecked") Graph(int v) { V = v; adj = new LinkedList[v]; for (int i = 0; i &lt; v; ++i) adj[i] = new LinkedList&lt;>(); } // 그래프에 간선 추가 void addEdge(int v, int w) { adj[v].add(w); } // BFS 구현 void BFS(int start) { // 방문 여부를 체크할 배열 boolean[] visited = new boolean[V]; // BFS를 위한 큐 생성 Queue&lt;Integer> queue = new LinkedList&lt;>(); // 시작 노드를 방문 처리하고 큐에 삽입 visited[start] = true; queue.add(start); while (!queue.isEmpty()) { // 큐에서 정점을 꺼내서 출력 start = queue.poll(); System.out.print(start + " "); // 현재 정점과 인접한 모든 정점에 대해 for (int n : adj[start]) { // 방문하지 않은 정점이면 방문 처리하고 큐에 삽입 if (!visited[n]) { visited[n] = true; queue.add(n); } } } } } Javascript 객체를 사용하여 인접 리스트를 구현했습니다. 배열의 shift()와 push()를 사용하여 큐 동작을 구현했습니다. 방문한 노드들의 순서를 배열로 반환합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // JavaScript Implementation class Graph { constructor() { this.adjacencyList = {}; } addVertex(vertex) { if (!this.adjacencyList[vertex]) { this.adjacencyList[vertex] = []; } } addEdge(vertex1, vertex2) { this.adjacencyList[vertex1].push(vertex2); this.adjacencyList[vertex2].push(vertex1); } bfs(start) { const queue = [start]; // 큐 생성 및 시작 노드 추가 const visited = {}; // 방문 체크를 위한 객체 const result = []; // 방문 순서를 저장할 배열 visited[start] = true; // 시작 노드 방문 처리 while (queue.length) { const vertex = queue.shift(); // 큐에서 정점 추출 result.push(vertex); // 결과 배열에 추가 // 인접한 정점들을 처리 this.adjacencyList[vertex].forEach(neighbor => { if (!visited[neighbor]) { visited[neighbor] = true; queue.push(neighbor); } }); } return result; } } Python collections.deque를 사용하여 효율적인 큐 구현을 했습니다. 거리 정보와 경로 추적 기능을 추가했습니다. 최단 경로를 찾는 기능도 구현되어 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # Python Implementation from collections import deque class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def bfs_with_distance(self, start): # 방문 여부와 거리를 저장할 딕셔너리 visited = {} distance = {} parent = {} # 경로 추적을 위한 부모 노드 저장 # 큐 생성 및 시작 노드 초기화 queue = deque([start]) visited[start] = True distance[start] = 0 parent[start] = None while queue: # 큐에서 정점을 꺼내서 처리 current = queue.popleft() print(f"방문: {current} (거리: {distance[current]})") # 인접한 모든 정점에 대해 for neighbor in self.graph.get(current, []): if neighbor not in visited: visited[neighbor] = True distance[neighbor] = distance[current] + 1 parent[neighbor] = current queue.append(neighbor) return distance, parent def find_shortest_path(self, start, end, parent): # 최단 경로 재구성 path = [] current = end while current is not None: path.append(current) current = parent[current] return path[::-1] # 경로를 역순으로 반환 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-30 05:41:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 너비 우선 탐색 (Breadth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
Source: https://jojozhuang.github.io/algorithm/algorithm-binary-search/
장점 검색 속도가 매우 빠릅니다. 시간 복잡도는 O(log n)입니다. 대용량 데이터에서 특정 값의 위치를 찾는 데 효율적입니다. 단점 반드시 정렬된 데이터에서만 사용할 수 있습니다. 데이터의 삽입, 삭제가 빈번한 경우 비효율적일 수 있습니다. 주의해야 할 점들 정렬 상태 유지:
...</p></div><footer class=entry-footer><span title='2024-10-30 05:40:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1070 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 검색 (Hash Search)</h2></header><div class=entry-content><p>해시 검색 (Hash Search) 해시 테이블을 이용한 효율적인 검색 알고리즘
해시 검색은 키(key)를 해시 함수(hash function)에 통과시켜 얻은 해시 값(hash value)을 인덱스로 사용하여 데이터에 직접 접근하는 방식.
이 방식은 (Key, Value) 쌍으로 데이터를 저장하고 검색하는 해시 테이블 자료구조를 기반으로 한다.
Source: https://www.researchgate.net/figure/An-example-of-hash-search_fig1_220781807
장점 빠른 검색 속도: 평균적으로 O(1)의 시간 복잡도를 가집니다. 효율적인 삽입과 삭제: 데이터의 추가와 제거도 일반적으로 O(1) 시간에 수행됩니다. 중복 확인 용이: 키의 중복 여부를 쉽게 확인할 수 있습니다. 단점 추가 메모리 필요: 해시 테이블을 위한 별도의 저장 공간이 필요합니다. 해시 충돌: 서로 다른 키가 동일한 해시 값을 가질 수 있어 충돌 해결 방법이 필요합니다. 데이터 순서 보장 안됨: 저장 순서가 유지되지 않습니다. 주의해야 할 점 적절한 해시 함수 선택: 키를 고르게 분포시키고 충돌을 최소화하는 해시 함수를 사용해야 합니다. 충돌 해결 방법 구현: 체이닝이나 개방 주소법 등의 충돌 해결 기법을 적용해야 합니다. 로드 팩터 관리: 해시 테이블의 크기와 저장된 데이터 수의 비율을 적절히 유지해야 합니다. 체이닝(Chaining) Java 구현에서 사용된 방식으로, 각 버킷에 연결 리스트를 사용 충돌이 발생하면 같은 버킷에 있는 연결 리스트에 추가 메모리를 더 사용하지만, 구현이 비교적 단순 개방 주소법(Open Addressing) 다음 사용 가능한 슬롯을 찾아 저장 메모리 사용이 효율적이지만, 클러스터링 문제 발생 가능 주로 사용하는 데이터 구조 해시 검색은 주로 해시 테이블(Hash Table) 자료구조와 함께 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-30 05:40:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 검색 (Hash Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>