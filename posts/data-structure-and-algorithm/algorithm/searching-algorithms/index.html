<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>검색 알고리즘 (Searching Algorithms) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm,검색-알고리즘"><meta name=description content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="검색 알고리즘 (Searching Algorithms)"><meta property="og:description" content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="검색 알고리즘 (Searching Algorithms)"><meta name=twitter:description content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/"},{"@type":"ListItem","position":4,"name":"검색 알고리즘 (Searching Algorithms)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/>Algorithm</a></div><h1>검색 알고리즘 (Searching Algorithms)</h1><div class=post-description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</div></header><div class=post-content><h2 id=검색-알고리즘-searching-algorithms>검색 알고리즘 (Searching Algorithms)<a hidden class=anchor aria-hidden=true href=#검색-알고리즘-searching-algorithms>#</a></h2><p>데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 방법을 정의하는 알고리즘.<br>데이터의 정렬 상태, 크기, 구조 등에 따라 적합한 알고리즘이 달라진다.</p><p>장점:</p><ul><li>데이터 검색 속도 향상</li><li>대규모 데이터셋 처리 가능</li></ul><p>단점:</p><ul><li>일부 알고리즘은 정렬된 데이터 필요</li><li>구현 복잡도 증가 가능</li></ul><h3 id=일반적인-특징>일반적인 특징<a hidden class=anchor aria-hidden=true href=#일반적인-특징>#</a></h3><ol><li><strong>효율성</strong>: 대부분의 검색 알고리즘은 효율적인 데이터 검색을 목표로 합니다.</li><li><strong>정확성</strong>: 검색 결과는 항상 정확해야 합니다.</li><li><strong>적응성</strong>: 다양한 데이터 구조와 크기에 적용할 수 있어야 합니다.</li><li><strong>확장성</strong>: 데이터셋의 크기가 증가해도 성능이 크게 저하되지 않아야 합니다.</li></ol><h3 id=주요-종류>주요 종류<a hidden class=anchor aria-hidden=true href=#주요-종류>#</a></h3><h4 id=기본-검색-알고리즘>기본 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#기본-검색-알고리즘>#</a></h4><table><thead><tr><th>알고리즘 이름</th><th>시간 복잡도</th><th>공간 복잡도</th><th>정렬 필요 여부</th><th>특징</th><th>적합한 사용 케이스</th></tr></thead><tbody><tr><td>순차 검색 (Sequential Search)</td><td>O(n)</td><td>O(1)</td><td>불필요</td><td>• 가장 단순한 검색 방법<br>• 처음부터 끝까지 순차적으로 검색<br>• 구현이 매우 간단</td><td>• 소규모 데이터셋<br>• 정렬되지 않은 데이터<br>• 일회성 검색</td></tr><tr><td>이진 검색 (Binary Search)</td><td>O(log n)</td><td>O(1)</td><td>필수</td><td>• 정렬된 데이터에서만 사용 가능<br>• 중간값을 기준으로 범위를 좁혀가며 검색<br>• 분할 정복 방식</td><td>• 대규모 정렬된 데이터<br>• 반복적인 검색 작업<br>• 정적인 데이터셋</td></tr><tr><td>해시 검색 (Hash Search)</td><td>O(1) 평균<br>O(n) 최악</td><td>O(n)</td><td>불필요</td><td>• 해시 함수를 사용하여 직접 접근<br>• 충돌 해결 방법 필요<br>• 키-값 쌍으로 데이터 저장</td><td>• 빈번한 검색 작업<br>• 키-값 데이터<br>• 캐싱 시스템</td></tr><tr><td>보간 검색 (Interpolation Search)</td><td>O(log log n) 평균<br>O(n) 최악</td><td>O(1)</td><td>필수</td><td>• 이진 검색의 개선 버전<br>• 데이터 분포를 고려한 검색<br>• 균등 분포에서 효율적</td><td>• 균등 분포된 데이터<br>• 정렬된 숫자 데이터<br>• 큰 데이터셋</td></tr></tbody></table><h4 id=그래프-검색-알고리즘>그래프 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#그래프-검색-알고리즘>#</a></h4><table><thead><tr><th>알고리즘 이름</th><th>시간 복잡도</th><th>공간 복잡도</th><th>특징</th><th>적합한 사용 케이스</th></tr></thead><tbody><tr><td>깊이 우선 검색 (DFS)</td><td>O(V + E)</td><td>O(V)</td><td>• 한 경로를 끝까지 탐색<br>• 스택/재귀 사용<br>• 메모리 효율적</td><td>• 경로 존재 확인<br>• 위상 정렬<br>• 연결 요소 찾기</td></tr><tr><td>너비 우선 검색 (BFS)</td><td>O(V + E)</td><td>O(V)</td><td>• 레벨 단위 탐색<br>• 큐 사용<br>• 최단 경로 보장</td><td>• 최단 경로<br>• 네트워크 분석<br>• 레벨 단위 처리</td></tr></tbody></table><p>[V: 정점 수, E: 간선 수]</p><h3 id=최신-트렌드와-발전-방향>최신 트렌드와 발전 방향<a hidden class=anchor aria-hidden=true href=#최신-트렌드와-발전-방향>#</a></h3><ul><li>병렬 검색 알고리즘 개발</li><li>분산 환경에서의 검색 최적화</li><li>머신러닝을 활용한 검색 성능 개선</li><li>빅데이터 환경에 적합한 검색 알고리즘 연구</li></ul><h3 id=검색-알고리즘-선택-시-고려사항>검색 알고리즘 선택 시 고려사항<a hidden class=anchor aria-hidden=true href=#검색-알고리즘-선택-시-고려사항>#</a></h3><ol><li><p>데이터의 특성</p><ul><li>데이터의 크기</li><li>데이터의 정렬 상태</li><li>데이터의 변경 빈도</li></ul></li><li><p>성능 요구사항</p><ul><li>검색 속도 요구사항</li><li>메모리 사용량 제약</li><li>구현의 복잡도</li></ul></li><li><p>응용 환경</p><ul><li>검색 빈도</li><li>삽입/삭제 빈도</li><li>동시성 요구사항&mdash;</li></ul></li></ol><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>보간 검색 (Interpolation Search)</h2></header><div class=entry-content><p>보간 검색 (Interpolation Search) 보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.
이진 탐색(Binary Search)과 유사하지만, 데이터 분포를 고려해 탐색 위치를 예측함으로써 평균적으로 더 빠른 성능을 보인다. 특히 균등한 데이터 분포에서 효과적이다.
보간 검색은 데이터 특성에 민감하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.
핵심 개념 데이터 균등성 가정: 배열의 값이 선형적으로 분포되어 있다고 가정한다.
예측 위치 계산: 탐색 위치를 다음 공식으로 계산한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 12:33:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;592 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보간 검색 (Interpolation Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>깊이 우선 탐색 (Depth-First Search)</h2></header><div class=entry-content><p>깊이 우선 탐색 (Depth-First Search, DFS) 그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.
미로에서 한 길을 끝까지 가보고, 막힌 길이면 되돌아와서 다른 길을 탐색하는 것과 비슷하다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
작동 방식 루트 노드(또는 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색한다.
각 분기에서 가장 깊은 곳까지 탐색한 후에 백트래킹(되돌아가기)하여 다음 분기로 넘어간다.
장점 메모리 사용이 너비 우선 탐색(BFS)보다 효율적. 현재 경로상의 노드들만 기억하면 되기 때문. 목표 노드가 깊은 단계에 있을 때 BFS보다 빠르게 발견할 수 있다. 모든 노드를 방문하고자 할 때 적합. 단점 해가 없는 경로에 빠질 경우 불필요한 탐색을 할 수 있다. 찾은 경로가 최단 경로라는 보장이 없다. 무한 깊이의 경우에는 탐색이 끝나지 않을 수 있다. 주의해야 할 점 깊이가 매우 깊은 그래프에서는 재귀 방식 사용시 스택 오버플로우가 발생할 수 있으므로, 반복적 방식을 고려해야 합니다. 양방향 그래프에서는 무한 루프를 방지하기 위해 반드시 방문 체크를 해야 합니다. 그래프에 사이클이 있는 경우를 항상 고려해야 합니다. 주로 사용하는 데이터 구조 DFS는 주로 스택(Stack)을 사용하여 구현한다.
재귀 호출을 사용할 경우 시스템 스택을 활용하고, 반복문을 사용할 경우 직접 스택을 구현하여 사용한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:41:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 깊이 우선 탐색 (Depth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>너비 우선 탐색 (Breadth-First Search)</h2></header><div class=entry-content><p>너비 우선 탐색 (Breadth-First Search, BFS) BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘.
시작 노드에서 인접한 모든 노드를 탐색한 후, 그 다음 레벨의 노드들을 차례로 탐색한다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
장점 최단 경로 보장: 가중치가 없는 그래프에서 출발 노드에서 목표 노드까지의 최단 경로를 항상 찾는다. 무한 경로 방지: 모든 경로를 동시에 진행하기 때문에 무한히 깊은 경로에 빠질 위험이 없습니다. 넓은 탐색: 특정 깊이까지의 모든 노드를 탐색하는 데 적합합니다. 단점 높은 메모리 사용량: 큐에 저장해야 할 노드가 많아질 수 있어 메모리 사용량이 큽니다. 탐색 속도 저하: 경로가 매우 길거나 그래프가 클 경우, 탐색 속도가 느려질 수 있습니다. 해가 없는 경우 비효율적: 유한 그래프에서는 모든 노드를 탐색해야 하고, 무한 그래프에서는 종료하지 못할 수 있습니다. 주의해야 할 점 방문 여부를 반드시 확인해야 합니다. 그렇지 않으면 중복 방문으로 인해 무한 루프에 빠질 수 있습니다. 큐 자료구조를 활용해야 하며, 재귀적으로 구현하지 않습니다. 주로 사용하는 데이터 구조 큐(Queue): BFS는 선입선출(FIFO) 원칙을 따르므로 큐를 사용하여 다음에 탐색할 노드를 관리합니다. 큐를 사용하면 현재 레벨의 모든 노드를 방문한 후 다음 레벨로 자연스럽게 넘어갈 수 있습니다. 배열 또는 집합(Set): 방문 여부를 기록하기 위해 사용됩니다. 배열은 간단하게 구현할 수 있고, 집합은 중복 방지에 효과적입니다. 구현 예시 Java 인접 리스트를 사용하여 그래프를 표현했습니다. LinkedList를 사용하여 큐를 구현했습니다. 기본적인 BFS 탐색을 구현하여 방문 순서를 출력합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Java Implementation import java.util.*; class Graph { private int V; // 정점의 개수 private LinkedList&lt;Integer>[] adj; // 인접 리스트 @SuppressWarnings("unchecked") Graph(int v) { V = v; adj = new LinkedList[v]; for (int i = 0; i &lt; v; ++i) adj[i] = new LinkedList&lt;>(); } // 그래프에 간선 추가 void addEdge(int v, int w) { adj[v].add(w); } // BFS 구현 void BFS(int start) { // 방문 여부를 체크할 배열 boolean[] visited = new boolean[V]; // BFS를 위한 큐 생성 Queue&lt;Integer> queue = new LinkedList&lt;>(); // 시작 노드를 방문 처리하고 큐에 삽입 visited[start] = true; queue.add(start); while (!queue.isEmpty()) { // 큐에서 정점을 꺼내서 출력 start = queue.poll(); System.out.print(start + " "); // 현재 정점과 인접한 모든 정점에 대해 for (int n : adj[start]) { // 방문하지 않은 정점이면 방문 처리하고 큐에 삽입 if (!visited[n]) { visited[n] = true; queue.add(n); } } } } } Javascript 객체를 사용하여 인접 리스트를 구현했습니다. 배열의 shift()와 push()를 사용하여 큐 동작을 구현했습니다. 방문한 노드들의 순서를 배열로 반환합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // JavaScript Implementation class Graph { constructor() { this.adjacencyList = {}; } addVertex(vertex) { if (!this.adjacencyList[vertex]) { this.adjacencyList[vertex] = []; } } addEdge(vertex1, vertex2) { this.adjacencyList[vertex1].push(vertex2); this.adjacencyList[vertex2].push(vertex1); } bfs(start) { const queue = [start]; // 큐 생성 및 시작 노드 추가 const visited = {}; // 방문 체크를 위한 객체 const result = []; // 방문 순서를 저장할 배열 visited[start] = true; // 시작 노드 방문 처리 while (queue.length) { const vertex = queue.shift(); // 큐에서 정점 추출 result.push(vertex); // 결과 배열에 추가 // 인접한 정점들을 처리 this.adjacencyList[vertex].forEach(neighbor => { if (!visited[neighbor]) { visited[neighbor] = true; queue.push(neighbor); } }); } return result; } } Python collections.deque를 사용하여 효율적인 큐 구현을 했습니다. 거리 정보와 경로 추적 기능을 추가했습니다. 최단 경로를 찾는 기능도 구현되어 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # Python Implementation from collections import deque class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def bfs_with_distance(self, start): # 방문 여부와 거리를 저장할 딕셔너리 visited = {} distance = {} parent = {} # 경로 추적을 위한 부모 노드 저장 # 큐 생성 및 시작 노드 초기화 queue = deque([start]) visited[start] = True distance[start] = 0 parent[start] = None while queue: # 큐에서 정점을 꺼내서 처리 current = queue.popleft() print(f"방문: {current} (거리: {distance[current]})") # 인접한 모든 정점에 대해 for neighbor in self.graph.get(current, []): if neighbor not in visited: visited[neighbor] = True distance[neighbor] = distance[current] + 1 parent[neighbor] = current queue.append(neighbor) return distance, parent def find_shortest_path(self, start, end, parent): # 최단 경로 재구성 path = [] current = end while current is not None: path.append(current) current = parent[current] return path[::-1] # 경로를 역순으로 반환 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-15 05:41:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 너비 우선 탐색 (Breadth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
Source: https://jojozhuang.github.io/algorithm/algorithm-binary-search/
장점 검색 속도가 매우 빠릅니다. 시간 복잡도는 O(log n)입니다. 대용량 데이터에서 특정 값의 위치를 찾는 데 효율적입니다. 단점 반드시 정렬된 데이터에서만 사용할 수 있습니다. 데이터의 삽입, 삭제가 빈번한 경우 비효율적일 수 있습니다. 주의해야 할 점들 정렬 상태 유지:
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1070 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 검색 (Hash Search)</h2></header><div class=entry-content><p>해시 검색 (Hash Search) 해시 테이블을 이용한 효율적인 검색 알고리즘
해시 검색은 키(key)를 해시 함수(hash function)에 통과시켜 얻은 해시 값(hash value)을 인덱스로 사용하여 데이터에 직접 접근하는 방식.
이 방식은 (Key, Value) 쌍으로 데이터를 저장하고 검색하는 해시 테이블 자료구조를 기반으로 한다.
Source: https://www.researchgate.net/figure/An-example-of-hash-search_fig1_220781807
장점 빠른 검색 속도: 평균적으로 O(1)의 시간 복잡도를 가집니다. 효율적인 삽입과 삭제: 데이터의 추가와 제거도 일반적으로 O(1) 시간에 수행됩니다. 중복 확인 용이: 키의 중복 여부를 쉽게 확인할 수 있습니다. 단점 추가 메모리 필요: 해시 테이블을 위한 별도의 저장 공간이 필요합니다. 해시 충돌: 서로 다른 키가 동일한 해시 값을 가질 수 있어 충돌 해결 방법이 필요합니다. 데이터 순서 보장 안됨: 저장 순서가 유지되지 않습니다. 주의해야 할 점 적절한 해시 함수 선택: 키를 고르게 분포시키고 충돌을 최소화하는 해시 함수를 사용해야 합니다. 충돌 해결 방법 구현: 체이닝이나 개방 주소법 등의 충돌 해결 기법을 적용해야 합니다. 로드 팩터 관리: 해시 테이블의 크기와 저장된 데이터 수의 비율을 적절히 유지해야 합니다. 체이닝(Chaining) Java 구현에서 사용된 방식으로, 각 버킷에 연결 리스트를 사용 충돌이 발생하면 같은 버킷에 있는 연결 리스트에 추가 메모리를 더 사용하지만, 구현이 비교적 단순 개방 주소법(Open Addressing) 다음 사용 가능한 슬롯을 찾아 저장 메모리 사용이 효율적이지만, 클러스터링 문제 발생 가능 주로 사용하는 데이터 구조 해시 검색은 주로 해시 테이블(Hash Table) 자료구조와 함께 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 검색 (Hash Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>순차 검색 (Sequential Search)</h2></header><div class=entry-content><p>순차 검색(Sequential Search / Linear Search) 순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법.
이는 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.
Source: https://www.tutorialspoint.com/data_structures_algorithms/linear_search_algorithm.htm
장점 구현이 매우 간단하고 직관적입니다. 데이터의 정렬 여부와 상관없이 사용할 수 있습니다. 단점 데이터의 양이 많아질수록 검색 시간이 선형적으로 증가합니다. 대규모 데이터셋에서는 비효율적입니다. 주의해야 할 점 데이터의 양이 많을 경우 검색 시간이 매우 길어질 수 있으므로 주의해야 합니다. 검색 종료 조건을 명확히 설정해야 합니다.
일반적으로 두 가지 조건이 있습니다: 검색 실패: 검색할 값을 발견하지 못하고 리스트의 끝을 지나간 경우 검색 성공: 리스트에서 검색할 값과 같은 요소를 발견한 경우 주로 사용하는 데이터 구조 순차 검색은 주로 배열이나 연결 리스트와 같은 선형 자료구조에서 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:31:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;774 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 순차 검색 (Sequential Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>