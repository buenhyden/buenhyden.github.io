<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>백트래킹 (Backtracking) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm-Design,Algorithm-Design-techniques,Backtracking"><meta name=description content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="백트래킹 (Backtracking)"><meta property="og:description" content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-13T05:23:00+00:00"><meta property="article:modified_time" content="2024-10-13T05:23:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Algorithm-Design"><meta property="article:tag" content="Algorithm-Design-Techniques"><meta property="article:tag" content="Backtracking"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="백트래킹 (Backtracking)"><meta name=twitter:description content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"알고리즘 설계 (Algorithm Design)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/"},{"@type":"ListItem","position":4,"name":"Algorithm Design techniques","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/"},{"@type":"ListItem","position":5,"name":"백트래킹 (Backtracking)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"백트래킹 (Backtracking)","name":"백트래킹 (Backtracking)","description":"백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.","keywords":["Data-Structure-and-Algorithm","Algorithm-Design","Algorithm-Design-techniques","Backtracking"],"articleBody":"백트래킹 (Backtracking) 백트래킹은 ‘되돌아가기’라는 의미를 가지고 있다.\n백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.\n이 알고리즘은 문제의 해결책을 찾기 위해 가능한 모든 경우의 수를 체계적으로 탐색하는 방법이다.\n백트래킹의 핵심 아이디어는 다음과 같다:\n해결책을 찾아가는 과정에서 여러 선택지를 순차적으로 시도한다. 현재의 선택이 해결책으로 이어질 가능성이 없다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다. 이 과정을 반복하여 최종적으로 해결책을 찾거나, 모든 가능성을 탐색한다. 백트래킹은 단순한 완전 탐색(Exhaustive Search)과는 다르다.\n백트래킹은 현재의 선택이 유망한지(promising) 판단하여, 유망하지 않다면 더 이상 그 방향으로 탐색하지 않고 이전 단계로 돌아간다. 이를 ‘가지치기(pruning)‘라고 한다.\nSource: https://www.geeksforgeeks.org/introduction-to-backtracking-2/\n그림에서 보여지는 것처럼, IS: 재귀 호출이 유효한 솔루션을 찾기 시작하는 초기 상태를 나타낸다. C: 재귀 호출에 대한 다른 체크포인트를 나타낸다. TN: 더 이상 재귀 호출을 할 수 없는 터미널 노드를 나타낸다. 이러한 노드는 재귀의 기본 사례로 작용하며 이 상태에서 현재 솔루션이 유효한지 여부를 판별한다. 각 체크포인트에서 프로그램은 몇 가지 결정을 내리고 다른 체크포인트로 이동하여 최종 노드에 도달한 후, 솔루션이 유효한지 여부를 확인한 후 프로그램은 체크포인트로 돌아가 다른 경로를 탐색하기 시작한다.\n예를 들어 위의 이미지에서 TN1…TN5 는 솔루션이 허용되지 않는 최종 노드이고, TN6 은 유효한 솔루션을 찾은 상태이다. 이미지 속 뒤로 가는 화살표는 동작의 후퇴를 보여주며, 어떤 체크포인트에서 변경한 내용을 되돌리는 것을 의미한다. 백트래킹의 작동 원리 백트래킹 알고리즘은 주로 깊이 우선 탐색(DFS) 방식을 사용하여 구현된다.\n작동 원리는 다음과 같다:\n시작 상태에서 출발한다. 현재 상태에서 가능한 모든 선택지를 확인한다. 선택지 중 하나를 선택하여 다음 단계로 진행한다. 선택한 경로가 해결책으로 이어질 가능성이 있는지 검사한다(이를 ‘유망성 검사’라고 한다). 유망하지 않다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다(이를 ‘백트래킹’ 이라고 한다). 해결책을 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다. 백트래킹의 장단점 장점:\n모든 가능한 해결책을 체계적으로 탐색할 수 있다. 불필요한 탐색을 줄여 효율성을 높일 수 있다. 복잡한 문제에 대해 해결책이 존재하는지 여부를 확실히 알 수 있다. 단점:\n최악의 경우 모든 경우의 수를 탐색해야 하므로 시간이 오래 걸릴 수 있다. 문제의 크기가 커질수록 탐색해야 할 경우의 수가 기하급수적으로 증가할 수 있다. 백트래킹 구현의 기본 구조 백트래킹은 주로 재귀 함수를 사용하여 구현한다.\n기본적인 구조는 다음과 같다:\n1 2 3 4 5 6 7 8 9 function backtrack(현재 상태): if 해결책을 찾았다면: 해결책 반환 for 가능한 각 선택지에 대해: if 선택이 유망하다면: 선택을 적용 backtrack(새로운 상태) 선택을 취소 (백트래킹) 이러한 구조를 통해 모든 가능한 경우를 체계적으로 탐색하면서, 불필요한 탐색을 줄일 수 있다.\n좋은 알고리즘의 조건 효과적인 가지치기 조건 명확한 상태 표현 효율적인 유망성 검사 적절한 재귀 구조 효율적인 구현을 위한 팁 가지치기 조건을 최대한 일찍 적용 상태를 효율적으로 표현하고 관리 메모이제이션 기법 활용 고려 반복문 대신 비트마스크 사용 검토 실제 예시 N-Queen 문제를 통해 백트래킹을 이해해보자.\n이 문제는 N×N 크기의 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제이다.\n다음은 4-Queen 문제를 해결하는 파이썬 코드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def is_safe(board, row, col, n): # 같은 열에 퀸이 있는지 검사 for i in range(row): if board[i][col] == 1: return False # 왼쪽 위 대각선 검사 for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)): if board[i][j] == 1: return False # 오른쪽 위 대각선 검사 for i, j in zip(range(row-1, -1, -1), range(col+1, n)): if board[i][j] == 1: return False return True def solve_n_queens(n): def backtrack(board, row): # 모든 퀸을 배치했다면 성공 if row == n: return True # 현재 행의 각 열에 퀸을 놓아보기 for col in range(n): if is_safe(board, row, col, n): # 퀸을 배치 board[row][col] = 1 # 다음 행으로 진행 if backtrack(board, row + 1): return True # 실패하면 퀸을 제거(백트래킹) board[row][col] = 0 return False # 체스판 초기화 board = [[0 for x in range(n)] for y in range(n)] if backtrack(board, 0): return board return None # 사용 예시 solution = solve_n_queens(4) for row in solution: print(row) 이 코드에서 백트래킹의 핵심 요소들을 볼 수 있다:\n선택: 각 행에서 퀸을 놓을 열을 선택한다. 제약 조건 검사: is_safe 함수로 퀸이 서로 공격할 수 없는 위치인지 확인한다. 백트래킹: 현재 선택이 해결책으로 이어지지 않으면 퀸을 제거하고 다른 위치를 시도한다. 참고 및 출처 ","wordCount":"682","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-13T05:23:00Z","dateModified":"2024-10-13T05:23:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/>알고리즘 설계 (Algorithm Design)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/>Algorithm Design techniques</a></div><h1 class="post-title entry-hint-parent">백트래킹 (Backtracking)</h1><div class=post-description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</div><div class=post-meta><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;682 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Algorithm%20Design/Algorithm%20Design%20techniques/Backtracking.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#백트래킹-backtracking>백트래킹 (Backtracking)</a><ul><li><a href=#백트래킹의-작동-원리>백트래킹의 작동 원리</a></li><li><a href=#백트래킹의-장단점>백트래킹의 장단점</a></li><li><a href=#백트래킹-구현의-기본-구조>백트래킹 구현의 기본 구조</a></li><li><a href=#좋은-알고리즘의-조건>좋은 알고리즘의 조건</a></li><li><a href=#효율적인-구현을-위한-팁>효율적인 구현을 위한 팁</a></li><li><a href=#실제-예시>실제 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=백트래킹-backtracking>백트래킹 (Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹-backtracking>#</a></h2><p>백트래킹은 &lsquo;되돌아가기&rsquo;라는 의미를 가지고 있다.<br>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.<br>이 알고리즘은 문제의 해결책을 찾기 위해 가능한 모든 경우의 수를 체계적으로 탐색하는 방법이다.</p><p>백트래킹의 핵심 아이디어는 다음과 같다:</p><ol><li>해결책을 찾아가는 과정에서 여러 선택지를 순차적으로 시도한다.</li><li>현재의 선택이 해결책으로 이어질 가능성이 없다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다.</li><li>이 과정을 반복하여 최종적으로 해결책을 찾거나, 모든 가능성을 탐색한다.</li></ol><p>백트래킹은 단순한 완전 탐색(Exhaustive Search)과는 다르다.<br>백트래킹은 현재의 선택이 유망한지(promising) 판단하여, 유망하지 않다면 더 이상 그 방향으로 탐색하지 않고 이전 단계로 돌아간다. 이를 &lsquo;가지치기(pruning)&lsquo;라고 한다.</p><p><figure><img alt=Backtracking loading=lazy src=/img/backtracking.png><figcaption>Source: https://www.geeksforgeeks.org/introduction-to-backtracking-2/</figcaption></figure></p><ul><li>그림에서 보여지는 것처럼,<ul><li><strong>IS</strong>: 재귀 호출이 유효한 솔루션을 찾기 시작하는 <strong>초기 상태</strong>를 나타낸다.</li><li><strong>C</strong>: 재귀 호출에 대한 다른 <strong><strong>체크포인트를</strong></strong> 나타낸다.</li><li><strong>TN</strong>: 더 이상 재귀 호출을 할 수 없는 <strong><strong>터미널 노드를</strong></strong> 나타낸다. 이러한 노드는 재귀의 기본 사례로 작용하며 이 상태에서 현재 솔루션이 유효한지 여부를 판별한다.</li></ul></li><li>각 체크포인트에서 프로그램은 몇 가지 결정을 내리고 다른 체크포인트로 이동하여 최종 노드에 도달한 후, 솔루션이 유효한지 여부를 확인한 후 프로그램은 체크포인트로 돌아가 다른 경로를 탐색하기 시작한다.<br>예를 들어 위의 이미지에서 <strong><strong>TN1…TN5</strong></strong> 는 솔루션이 허용되지 않는 최종 노드이고, <strong><strong>TN6</strong></strong> 은 유효한 솔루션을 찾은 상태이다.</li><li>이미지 속 뒤로 가는 화살표는 동작의 후퇴를 보여주며, 어떤 체크포인트에서 변경한 내용을 되돌리는 것을 의미한다.</li></ul><h3 id=백트래킹의-작동-원리>백트래킹의 작동 원리<a hidden class=anchor aria-hidden=true href=#백트래킹의-작동-원리>#</a></h3><p>백트래킹 알고리즘은 주로 깊이 우선 탐색(DFS) 방식을 사용하여 구현된다.<br>작동 원리는 다음과 같다:</p><ol><li>시작 상태에서 출발한다.</li><li>현재 상태에서 가능한 모든 선택지를 확인한다.</li><li>선택지 중 하나를 선택하여 다음 단계로 진행한다.</li><li>선택한 경로가 해결책으로 이어질 가능성이 있는지 검사한다(이를 &lsquo;유망성 검사&rsquo;라고 한다).</li><li>유망하지 않다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다(이를 <strong>&lsquo;백트래킹&rsquo;</strong> 이라고 한다).</li><li>해결책을 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다.</li></ol><h3 id=백트래킹의-장단점>백트래킹의 장단점<a hidden class=anchor aria-hidden=true href=#백트래킹의-장단점>#</a></h3><p>장점:</p><ol><li>모든 가능한 해결책을 체계적으로 탐색할 수 있다.</li><li>불필요한 탐색을 줄여 효율성을 높일 수 있다.</li><li>복잡한 문제에 대해 해결책이 존재하는지 여부를 확실히 알 수 있다.</li></ol><p>단점:</p><ol><li>최악의 경우 모든 경우의 수를 탐색해야 하므로 시간이 오래 걸릴 수 있다.</li><li>문제의 크기가 커질수록 탐색해야 할 경우의 수가 기하급수적으로 증가할 수 있다.</li></ol><h3 id=백트래킹-구현의-기본-구조>백트래킹 구현의 기본 구조<a hidden class=anchor aria-hidden=true href=#백트래킹-구현의-기본-구조>#</a></h3><p>백트래킹은 주로 재귀 함수를 사용하여 구현한다.<br>기본적인 구조는 다음과 같다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function backtrack(현재 상태):
</span></span><span class=line><span class=cl>    if 해결책을 찾았다면:
</span></span><span class=line><span class=cl>        해결책 반환
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    for 가능한 각 선택지에 대해:
</span></span><span class=line><span class=cl>        if 선택이 유망하다면:
</span></span><span class=line><span class=cl>            선택을 적용
</span></span><span class=line><span class=cl>            backtrack(새로운 상태)
</span></span><span class=line><span class=cl>            선택을 취소 (백트래킹)
</span></span></code></pre></td></tr></table></div></div><p>이러한 구조를 통해 모든 가능한 경우를 체계적으로 탐색하면서, 불필요한 탐색을 줄일 수 있다.</p><h3 id=좋은-알고리즘의-조건>좋은 알고리즘의 조건<a hidden class=anchor aria-hidden=true href=#좋은-알고리즘의-조건>#</a></h3><ol><li>효과적인 가지치기 조건</li><li>명확한 상태 표현</li><li>효율적인 유망성 검사</li><li>적절한 재귀 구조</li></ol><h3 id=효율적인-구현을-위한-팁>효율적인 구현을 위한 팁<a hidden class=anchor aria-hidden=true href=#효율적인-구현을-위한-팁>#</a></h3><ol><li>가지치기 조건을 최대한 일찍 적용</li><li>상태를 효율적으로 표현하고 관리</li><li>메모이제이션 기법 활용 고려</li><li>반복문 대신 비트마스크 사용 검토</li></ol><h3 id=실제-예시>실제 예시<a hidden class=anchor aria-hidden=true href=#실제-예시>#</a></h3><p>N-Queen 문제를 통해 백트래킹을 이해해보자.<br>이 문제는 N×N 크기의 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제이다.</p><p>다음은 4-Queen 문제를 해결하는 파이썬 코드:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span><span class=lnt id=hl-1-44><a class=lnlinks href=#hl-1-44>44</a>
</span><span class=lnt id=hl-1-45><a class=lnlinks href=#hl-1-45>45</a>
</span><span class=lnt id=hl-1-46><a class=lnlinks href=#hl-1-46>46</a>
</span><span class=lnt id=hl-1-47><a class=lnlinks href=#hl-1-47>47</a>
</span><span class=lnt id=hl-1-48><a class=lnlinks href=#hl-1-48>48</a>
</span><span class=lnt id=hl-1-49><a class=lnlinks href=#hl-1-49>49</a>
</span><span class=lnt id=hl-1-50><a class=lnlinks href=#hl-1-50>50</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 같은 열에 퀸이 있는지 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 위 대각선 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=nb>range</span><span class=p>(</span><span class=n>col</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 위 대각선 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>),</span> <span class=nb>range</span><span class=p>(</span><span class=n>col</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 퀸을 배치했다면 성공</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 행의 각 열에 퀸을 놓아보기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># 퀸을 배치</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 실패하면 퀸을 제거(백트래킹)</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 체스판 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>board</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>y</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>board</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>solution</span> <span class=o>=</span> <span class=n>solve_n_queens</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드에서 백트래킹의 핵심 요소들을 볼 수 있다:</p><ul><li>선택: 각 행에서 퀸을 놓을 열을 선택한다.</li><li>제약 조건 검사: is_safe 함수로 퀸이 서로 공격할 수 없는 위치인지 확인한다.</li><li>백트래킹: 현재 선택이 해결책으로 이어지지 않으면 퀸을 제거하고 다른 위치를 시도한다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/algorithm-design/>Algorithm-Design</a></li><li><a href=https://buenhyden.github.io/tags/algorithm-design-techniques/>Algorithm-Design-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/backtracking/>Backtracking</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/><span class=title>« Prev</span><br><span>근사 알고리즘 (Approximation algorithm)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/><span class=title>Next »</span><br><span>분기 한정법 (Branch and Bound)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>