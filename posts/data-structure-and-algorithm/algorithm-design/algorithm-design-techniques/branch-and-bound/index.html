<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>분기 한정법 (Branch and Bound) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Algorithm-Design,Algorithm-Design-techniques,Branch-and-Bound"><meta name=description content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="분기 한정법 (Branch and Bound)"><meta property="og:description" content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-13T05:23:00+00:00"><meta property="article:modified_time" content="2024-10-13T05:23:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Algorithm-Design"><meta property="article:tag" content="Algorithm-Design-Techniques"><meta property="article:tag" content="Branch-and-Bound"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="분기 한정법 (Branch and Bound)"><meta name=twitter:description content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"알고리즘 설계 (Algorithm Design)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/"},{"@type":"ListItem","position":4,"name":"Algorithm Design techniques","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/"},{"@type":"ListItem","position":5,"name":"분기 한정법 (Branch and Bound)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"분기 한정법 (Branch and Bound)","name":"분기 한정법 (Branch and Bound)","description":"분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.","keywords":["Data-Structure-and-Algorithm","Algorithm-Design","Algorithm-Design-techniques","Branch-and-Bound"],"articleBody":"분기 한정법 (Branch and Bound) 분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.\n이 방법은 가능한 모든 해를 체계적으로 탐색하면서도 불필요한 탐색을 줄이는 것이 특징이다.\n분기 한정법은 두 가지 주요 개념을 기반으로 한다:\n분기(Branch): 문제를 더 작은 하위 문제로 나누는 과정. 한정(Bound): 각 하위 문제의 잠재적인 해결책의 품질을 평가하는 과정.\n이 방법은 상태 공간 트리를 사용하여 모든 가능한 해결책을 체계적으로 탐색한다. 특성 분기(Branching): 문제를 더 작은 하위 문제로 나눈다. 각 분기는 겹치지 않는 부분 문제들을 만든다. 한정(Bounding): 각 하위 문제의 해의 범위를 추정한다. 상한(upper bound)과 하한(lower bound)을 계산한다. 유망하지 않은 분기는 더 이상 탐색하지 않는다. 가지치기(Pruning): 최적해가 될 수 없는 하위 문제를 제거한다. 상태 공간 트리(State Space Tree) 사용: 가능한 해들을 트리 구조로 표현한다. 목적과 필요성 분기 한정법의 주요 목적은 다음과 같다:\n복잡한 최적화 문제의 최적해를 찾기 불필요한 탐색을 줄여 효율적으로 해를 찾기 NP-난해 문제에 대한 실용적인 해결책 제공\n이 방법은 완전 탐색으로는 시간이 너무 오래 걸리는 문제들을 효율적으로 해결할 수 있어 필요하다. 장단점 장점:\n최적해를 보장한다. 불필요한 탐색을 줄여 효율성을 높인다. 다양한 최적화 문제에 적용 가능하다. 단점:\n최악의 경우 여전히 지수 시간 복잡도를 가진다. 효과적인 한계 함수(bounding function)를 설계하는 것이 어려울 수 있다. 메모리 사용량이 많을 수 있다. 작동 원리 초기 문제를 루트 노드로 하는 상태 공간 트리를 생성한다. 현재 노드에서 가능한 선택지들로 분기(branch)한다. 각 하위 노드의 한계값(bound)을 계산한다. 한계값이 현재까지의 최선의 해보다 나쁜 노드는 가지치기(prune)한다. 가장 유망한 노드를 선택하여 탐색을 계속한다. 최적해를 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다. 핵심 구성 요소 분기 함수(branch): 현재 노드에서 가능한 선택지들을 생성 한계 함수(bound): 하위 트리의 최적값 추정 선택 함수(selection): 다음에 탐색할 노드 선택 가지치기 조건(pruning): 유망하지 않은 노드 제거 기준 분기 한정법 Vs 백트래킹 분기 한정법은 백트래킹과 유사하지만 몇 가지 중요한 차이점이 있다:\n목적: 분기 한정법은 최적화 문제에 특화되어 있습니다. 탐색 순서: 분기 한정법은 가장 유망한 노드를 우선적으로 탐색한다. 가지치기: 분기 한정법은 더 적극적으로 가지치기를 수행한다. 좋은 알고리즘의 조건 효과적인 분기 전략: 문제를 균형 있게 나누는 분기 방법 강력한 한계 함수: 정확하면서도 계산이 빠른 한계값 추정 방법 효율적인 탐색 전략: 유망한 노드를 빠르게 찾는 방법 메모리 효율성: 필요한 정보만을 저장하여 메모리 사용 최소화 효율적인 구현을 위한 팁 문제에 특화된 한계 함수를 개발한다. 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)의 장단점을 고려하여 적절한 탐색 전략을 선택한다. 병렬 처리를 활용하여 여러 하위 문제를 동시에 탐색하는 것을 고려한다. 메모이제이션 기법을 사용하여 중복 계산을 줄인다. 실제 예시 Source: https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/\n0/1 배낭 문제(0/1 Knapsack Problem)\n주어진 조건:\nn개의 물건이 있음 각 물건 i는 무게 w[i]와 가치 v[i]를 가짐 배낭의 최대 수용 가능 무게는 W 각 물건은 통째로 선택하거나 선택하지 않아야 함 (0 또는 1)\n목표: 배낭의 무게 제한을 초과하지 않으면서 선택된 물건들의 총 가치를 최대화하는 물건들의 조합을 찾는 것\n수학적 표현: 1 2 3 최대화: `Σ(v[i] * x[i]) (i = 1 to n)` 제약 조건: `Σ(w[i] * x[i]) ≤ W` 여기서` x[i]는 0 또는 1 (물건을 선택하거나 선택하지 않음)` 0/1 배낭 문제(0/1 Knapsack Problem)를 해결하는 분기 한정법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class Item: def __init__(self, weight, value, index): self.weight = weight # 물건의 무게 self.value = value # 물건의 가치 self.index = index # 물건의 인덱스 self.ratio = value / weight # 단위 무게당 가치 def knapsack_branch_and_bound(items, capacity): n = len(items) # 단위 무게당 가치 기준으로 정렬 (한정 함수의 효율을 위해) items.sort(key=lambda x: x.ratio, reverse=True) # 최적해를 저장할 변수들 max_value = 0 # 지금까지 찾은 최적해의 가치 best_solution = [0] * n # 최적해의 선택 여부 저장 def bound(node_level, current_weight, current_value): \"\"\" 현재 노드에서 가능한 최대 가치를 계산하는 한정 함수 이 값이 현재까지의 최적해보다 작다면 더 탐색할 필요가 없음 \"\"\" if current_weight \u003e= capacity: return 0 # 현재 노드의 한계값 계산 bound_value = current_value total_weight = current_weight j = node_level # 남은 물건들을 가치/무게 비율이 높은 순서대로 분할하여 추가 while j \u003c n and total_weight + items[j].weight \u003c= capacity: total_weight += items[j].weight bound_value += items[j].value j += 1 # 마지막 물건은 분할하여 추가 if j \u003c n: bound_value += (capacity - total_weight) * items[j].ratio return bound_value def branch(node_level, current_weight, current_value, solution): \"\"\" 분기 함수: 각 물건을 선택하거나 선택하지 않는 두 가지 경우로 분기 \"\"\" nonlocal max_value, best_solution # 모든 물건을 고려했다면 현재 해답 평가 if node_level == n: if current_value \u003e max_value: max_value = current_value best_solution = solution[:] return # 한계값 계산하여 가지치기 여부 결정 if bound(node_level, current_weight, current_value) \u003c= max_value: return # 유망하지 않은 노드는 가지치기 # 현재 물건을 선택하는 경우 탐색 if current_weight + items[node_level].weight \u003c= capacity: solution[items[node_level].index] = 1 branch(node_level + 1, current_weight + items[node_level].weight, current_value + items[node_level].value, solution) # 현재 물건을 선택하지 않는 경우 탐색 solution[items[node_level].index] = 0 branch(node_level + 1, current_weight, current_value, solution) # 초기 호출 branch(0, 0, 0, [0] * n) return max_value, best_solution # 사용 예시 if __name__ == \"__main__\": # 테스트 데이터 weights = [2, 3.14, 1.98, 5, 3] # 물건들의 무게 values = [40,50,100,95,30] # 물건들의 가치 capacity = 10 # 배낭의 용량 # Item 객체들 생성 items = [Item(w, v, i) for i, (w, v) in enumerate(zip(weights, values))] # 알고리즘 실행 max_value, solution = knapsack_branch_and_bound(items, capacity) print(f\"최대 가치: {max_value}\") print(f\"선택된 물건들: {solution}\") 참고 및 출처 ","wordCount":"910","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-13T05:23:00Z","dateModified":"2024-10-13T05:23:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/>알고리즘 설계 (Algorithm Design)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/>Algorithm Design techniques</a></div><h1 class="post-title entry-hint-parent">분기 한정법 (Branch and Bound)</h1><div class=post-description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</div><div class=post-meta><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;910 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Algorithm%20Design/Algorithm%20Design%20techniques/Branch-and-Bound.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#분기-한정법-branch-and-bound>분기 한정법 (Branch and Bound)</a><ul><li><a href=#특성>특성</a></li><li><a href=#목적과-필요성>목적과 필요성</a></li><li><a href=#장단점>장단점</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#핵심-구성-요소>핵심 구성 요소</a></li><li><a href=#분기-한정법-vs-백트래킹>분기 한정법 Vs 백트래킹</a></li><li><a href=#좋은-알고리즘의-조건>좋은 알고리즘의 조건</a></li><li><a href=#효율적인-구현을-위한-팁>효율적인 구현을 위한 팁</a></li><li><a href=#실제-예시>실제 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=분기-한정법-branch-and-bound>분기 한정법 (Branch and Bound)<a hidden class=anchor aria-hidden=true href=#분기-한정법-branch-and-bound>#</a></h2><p>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.<br>이 방법은 가능한 모든 해를 체계적으로 탐색하면서도 불필요한 탐색을 줄이는 것이 특징이다.</p><p>분기 한정법은 두 가지 주요 개념을 기반으로 한다:</p><ol><li><strong>분기(Branch)</strong>: 문제를 더 작은 하위 문제로 나누는 과정.</li><li><strong>한정(Bound)</strong>: 각 하위 문제의 잠재적인 해결책의 품질을 평가하는 과정.<br>이 방법은 상태 공간 트리를 사용하여 모든 가능한 해결책을 체계적으로 탐색한다.</li></ol><h3 id=특성>특성<a hidden class=anchor aria-hidden=true href=#특성>#</a></h3><ol><li>분기(Branching): 문제를 더 작은 하위 문제로 나눈다.<ul><li>각 분기는 겹치지 않는 부분 문제들을 만든다.</li></ul></li><li>한정(Bounding): 각 하위 문제의 해의 범위를 추정한다.<ul><li>상한(upper bound)과 하한(lower bound)을 계산한다.</li><li>유망하지 않은 분기는 더 이상 탐색하지 않는다.</li></ul></li><li>가지치기(Pruning): 최적해가 될 수 없는 하위 문제를 제거한다.</li><li>상태 공간 트리(State Space Tree) 사용: 가능한 해들을 트리 구조로 표현한다.</li></ol><h3 id=목적과-필요성>목적과 필요성<a hidden class=anchor aria-hidden=true href=#목적과-필요성>#</a></h3><p>분기 한정법의 주요 목적은 다음과 같다:</p><ol><li>복잡한 최적화 문제의 최적해를 찾기</li><li>불필요한 탐색을 줄여 효율적으로 해를 찾기</li><li>NP-난해 문제에 대한 실용적인 해결책 제공<br>이 방법은 완전 탐색으로는 시간이 너무 오래 걸리는 문제들을 효율적으로 해결할 수 있어 필요하다.</li></ol><h3 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h3><p>장점:</p><ol><li>최적해를 보장한다.</li><li>불필요한 탐색을 줄여 효율성을 높인다.</li><li>다양한 최적화 문제에 적용 가능하다.</li></ol><p>단점:</p><ol><li>최악의 경우 여전히 지수 시간 복잡도를 가진다.</li><li>효과적인 한계 함수(bounding function)를 설계하는 것이 어려울 수 있다.</li><li>메모리 사용량이 많을 수 있다.</li></ol><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><ol><li>초기 문제를 루트 노드로 하는 상태 공간 트리를 생성한다.</li><li>현재 노드에서 가능한 선택지들로 분기(branch)한다.</li><li>각 하위 노드의 한계값(bound)을 계산한다.</li><li>한계값이 현재까지의 최선의 해보다 나쁜 노드는 가지치기(prune)한다.</li><li>가장 유망한 노드를 선택하여 탐색을 계속한다.</li><li>최적해를 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다.</li></ol><h3 id=핵심-구성-요소>핵심 구성 요소<a hidden class=anchor aria-hidden=true href=#핵심-구성-요소>#</a></h3><ol><li>분기 함수(branch): 현재 노드에서 가능한 선택지들을 생성</li><li>한계 함수(bound): 하위 트리의 최적값 추정</li><li>선택 함수(selection): 다음에 탐색할 노드 선택</li><li>가지치기 조건(pruning): 유망하지 않은 노드 제거 기준</li></ol><h3 id=분기-한정법-vs-백트래킹>분기 한정법 Vs 백트래킹<a hidden class=anchor aria-hidden=true href=#분기-한정법-vs-백트래킹>#</a></h3><p>분기 한정법은 백트래킹과 유사하지만 몇 가지 중요한 차이점이 있다:</p><ol><li><strong>목적</strong>: 분기 한정법은 최적화 문제에 특화되어 있습니다.</li><li><strong>탐색 순서</strong>: 분기 한정법은 가장 유망한 노드를 우선적으로 탐색한다.</li><li><strong>가지치기</strong>: 분기 한정법은 더 적극적으로 가지치기를 수행한다.</li></ol><h3 id=좋은-알고리즘의-조건>좋은 알고리즘의 조건<a hidden class=anchor aria-hidden=true href=#좋은-알고리즘의-조건>#</a></h3><ol><li>효과적인 분기 전략: 문제를 균형 있게 나누는 분기 방법</li><li>강력한 한계 함수: 정확하면서도 계산이 빠른 한계값 추정 방법</li><li>효율적인 탐색 전략: 유망한 노드를 빠르게 찾는 방법</li><li>메모리 효율성: 필요한 정보만을 저장하여 메모리 사용 최소화</li></ol><h3 id=효율적인-구현을-위한-팁>효율적인 구현을 위한 팁<a hidden class=anchor aria-hidden=true href=#효율적인-구현을-위한-팁>#</a></h3><ol><li>문제에 특화된 한계 함수를 개발한다.</li><li>깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)의 장단점을 고려하여 적절한 탐색 전략을 선택한다.</li><li>병렬 처리를 활용하여 여러 하위 문제를 동시에 탐색하는 것을 고려한다.</li><li>메모이제이션 기법을 사용하여 중복 계산을 줄인다.</li></ol><h3 id=실제-예시>실제 예시<a hidden class=anchor aria-hidden=true href=#실제-예시>#</a></h3><p><figure><img alt="0/1 Knapsack using Branch and Bound" loading=lazy src=/img/0-1-Knapsack-using-Branch-and-Bound3.jpg><figcaption>Source: https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/</figcaption></figure></p><blockquote><p>0/1 배낭 문제(0/1 Knapsack Problem)<br>주어진 조건:</p><ul><li>n개의 물건이 있음</li><li>각 물건 i는 무게 <code>w[i]</code>와 가치 <code>v[i]</code>를 가짐</li><li>배낭의 최대 수용 가능 무게는 W</li><li>각 물건은 통째로 선택하거나 선택하지 않아야 함 (0 또는 1)<br>목표:</li><li>배낭의 무게 제한을 초과하지 않으면서</li><li>선택된 물건들의 총 가치를 최대화하는 물건들의 조합을 찾는 것<br>수학적 표현:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>최대화: `Σ(v[i] * x[i])  (i = 1 to n)`
</span></span><span class=line><span class=cl>제약 조건: `Σ(w[i] * x[i]) ≤ W`
</span></span><span class=line><span class=cl>여기서` x[i]는 0 또는 1 (물건을 선택하거나 선택하지 않음)`
</span></span></code></pre></td></tr></table></div></div></blockquote><p>0/1 배낭 문제(0/1 Knapsack Problem)를 해결하는 분기 한정법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span><span class=lnt id=hl-1-44><a class=lnlinks href=#hl-1-44>44</a>
</span><span class=lnt id=hl-1-45><a class=lnlinks href=#hl-1-45>45</a>
</span><span class=lnt id=hl-1-46><a class=lnlinks href=#hl-1-46>46</a>
</span><span class=lnt id=hl-1-47><a class=lnlinks href=#hl-1-47>47</a>
</span><span class=lnt id=hl-1-48><a class=lnlinks href=#hl-1-48>48</a>
</span><span class=lnt id=hl-1-49><a class=lnlinks href=#hl-1-49>49</a>
</span><span class=lnt id=hl-1-50><a class=lnlinks href=#hl-1-50>50</a>
</span><span class=lnt id=hl-1-51><a class=lnlinks href=#hl-1-51>51</a>
</span><span class=lnt id=hl-1-52><a class=lnlinks href=#hl-1-52>52</a>
</span><span class=lnt id=hl-1-53><a class=lnlinks href=#hl-1-53>53</a>
</span><span class=lnt id=hl-1-54><a class=lnlinks href=#hl-1-54>54</a>
</span><span class=lnt id=hl-1-55><a class=lnlinks href=#hl-1-55>55</a>
</span><span class=lnt id=hl-1-56><a class=lnlinks href=#hl-1-56>56</a>
</span><span class=lnt id=hl-1-57><a class=lnlinks href=#hl-1-57>57</a>
</span><span class=lnt id=hl-1-58><a class=lnlinks href=#hl-1-58>58</a>
</span><span class=lnt id=hl-1-59><a class=lnlinks href=#hl-1-59>59</a>
</span><span class=lnt id=hl-1-60><a class=lnlinks href=#hl-1-60>60</a>
</span><span class=lnt id=hl-1-61><a class=lnlinks href=#hl-1-61>61</a>
</span><span class=lnt id=hl-1-62><a class=lnlinks href=#hl-1-62>62</a>
</span><span class=lnt id=hl-1-63><a class=lnlinks href=#hl-1-63>63</a>
</span><span class=lnt id=hl-1-64><a class=lnlinks href=#hl-1-64>64</a>
</span><span class=lnt id=hl-1-65><a class=lnlinks href=#hl-1-65>65</a>
</span><span class=lnt id=hl-1-66><a class=lnlinks href=#hl-1-66>66</a>
</span><span class=lnt id=hl-1-67><a class=lnlinks href=#hl-1-67>67</a>
</span><span class=lnt id=hl-1-68><a class=lnlinks href=#hl-1-68>68</a>
</span><span class=lnt id=hl-1-69><a class=lnlinks href=#hl-1-69>69</a>
</span><span class=lnt id=hl-1-70><a class=lnlinks href=#hl-1-70>70</a>
</span><span class=lnt id=hl-1-71><a class=lnlinks href=#hl-1-71>71</a>
</span><span class=lnt id=hl-1-72><a class=lnlinks href=#hl-1-72>72</a>
</span><span class=lnt id=hl-1-73><a class=lnlinks href=#hl-1-73>73</a>
</span><span class=lnt id=hl-1-74><a class=lnlinks href=#hl-1-74>74</a>
</span><span class=lnt id=hl-1-75><a class=lnlinks href=#hl-1-75>75</a>
</span><span class=lnt id=hl-1-76><a class=lnlinks href=#hl-1-76>76</a>
</span><span class=lnt id=hl-1-77><a class=lnlinks href=#hl-1-77>77</a>
</span><span class=lnt id=hl-1-78><a class=lnlinks href=#hl-1-78>78</a>
</span><span class=lnt id=hl-1-79><a class=lnlinks href=#hl-1-79>79</a>
</span><span class=lnt id=hl-1-80><a class=lnlinks href=#hl-1-80>80</a>
</span><span class=lnt id=hl-1-81><a class=lnlinks href=#hl-1-81>81</a>
</span><span class=lnt id=hl-1-82><a class=lnlinks href=#hl-1-82>82</a>
</span><span class=lnt id=hl-1-83><a class=lnlinks href=#hl-1-83>83</a>
</span><span class=lnt id=hl-1-84><a class=lnlinks href=#hl-1-84>84</a>
</span><span class=lnt id=hl-1-85><a class=lnlinks href=#hl-1-85>85</a>
</span><span class=lnt id=hl-1-86><a class=lnlinks href=#hl-1-86>86</a>
</span><span class=lnt id=hl-1-87><a class=lnlinks href=#hl-1-87>87</a>
</span><span class=lnt id=hl-1-88><a class=lnlinks href=#hl-1-88>88</a>
</span><span class=lnt id=hl-1-89><a class=lnlinks href=#hl-1-89>89</a>
</span><span class=lnt id=hl-1-90><a class=lnlinks href=#hl-1-90>90</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>    <span class=c1># 물건의 무게</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>      <span class=c1># 물건의 가치</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>index</span> <span class=o>=</span> <span class=n>index</span>      <span class=c1># 물건의 인덱스</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>ratio</span> <span class=o>=</span> <span class=n>value</span> <span class=o>/</span> <span class=n>weight</span>  <span class=c1># 단위 무게당 가치</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 단위 무게당 가치 기준으로 정렬 (한정 함수의 효율을 위해)</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>.</span><span class=n>ratio</span><span class=p>,</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최적해를 저장할 변수들</span>
</span></span><span class=line><span class=cl>    <span class=n>max_value</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 지금까지 찾은 최적해의 가치</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># 최적해의 선택 여부 저장</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bound</span><span class=p>(</span><span class=n>node_level</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        현재 노드에서 가능한 최대 가치를 계산하는 한정 함수
</span></span></span><span class=line><span class=cl><span class=s2>        이 값이 현재까지의 최적해보다 작다면 더 탐색할 필요가 없음
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>&gt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드의 한계값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>bound_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>=</span> <span class=n>current_weight</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>node_level</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 남은 물건들을 가치/무게 비율이 높은 순서대로 분할하여 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 물건은 분할하여 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>ratio</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound_value</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>branch</span><span class=p>(</span><span class=n>node_level</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        분기 함수: 각 물건을 선택하거나 선택하지 않는 두 가지 경우로 분기
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>max_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 물건을 고려했다면 현재 해답 평가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node_level</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_value</span> <span class=o>&gt;</span> <span class=n>max_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_solution</span> <span class=o>=</span> <span class=n>solution</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 한계값 계산하여 가지치기 여부 결정</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>bound</span><span class=p>(</span><span class=n>node_level</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>max_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>  <span class=c1># 유망하지 않은 노드는 가지치기</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 현재 물건을 선택하는 경우 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node_level</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solution</span><span class=p>[</span><span class=n>items</span><span class=p>[</span><span class=n>node_level</span><span class=p>]</span><span class=o>.</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>branch</span><span class=p>(</span><span class=n>node_level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node_level</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>current_value</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node_level</span><span class=p>]</span><span class=o>.</span><span class=n>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                  
</span></span><span class=line><span class=cl>        <span class=c1># 현재 물건을 선택하지 않는 경우 탐색</span>
</span></span><span class=line><span class=cl>        <span class=n>solution</span><span class=p>[</span><span class=n>items</span><span class=p>[</span><span class=n>node_level</span><span class=p>]</span><span class=o>.</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>branch</span><span class=p>(</span><span class=n>node_level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 호출</span>
</span></span><span class=line><span class=cl>    <span class=n>branch</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 테스트 데이터</span>
</span></span><span class=line><span class=cl>    <span class=n>weights</span> <span class=o>=</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mf>3.14</span><span class=p>,</span> <span class=mf>1.98</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>  <span class=c1># 물건들의 무게</span>
</span></span><span class=line><span class=cl>    <span class=n>values</span> <span class=o>=</span> <span class=p>[</span><span class=mi>40</span><span class=p>,</span><span class=mi>50</span><span class=p>,</span><span class=mi>100</span><span class=p>,</span><span class=mi>95</span><span class=p>,</span><span class=mi>30</span><span class=p>]</span>   <span class=c1># 물건들의 가치</span>
</span></span><span class=line><span class=cl>    <span class=n>capacity</span> <span class=o>=</span> <span class=mi>10</span>           <span class=c1># 배낭의 용량</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Item 객체들 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[</span><span class=n>Item</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=nb>zip</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 알고리즘 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>max_value</span><span class=p>,</span> <span class=n>solution</span> <span class=o>=</span> <span class=n>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;최대 가치: </span><span class=si>{</span><span class=n>max_value</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;선택된 물건들: </span><span class=si>{</span><span class=n>solution</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/algorithm-design/>Algorithm-Design</a></li><li><a href=https://buenhyden.github.io/tags/algorithm-design-techniques/>Algorithm-Design-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/branch-and-bound/>Branch-and-Bound</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/><span class=title>« Prev</span><br><span>백트래킹 (Backtracking)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/><span class=title>Next »</span><br><span>탐욕 알고리즘 (Greedy Algorithm)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>