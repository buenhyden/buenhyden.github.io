<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Primitive data structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="Non-Primitive data structure - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-Primitive data structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-Primitive data structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a></div><h1>Non-Primitive data structure</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linear Data Structure vs Non-Linear Data Structure</h2></header><div class=entry-content><p>Non-Primitive Linear Data Structure Vs Non-Linear Data Structure 데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.
측면 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적 또는 선형적으로 배열된 구조 데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조 구조 단일 레벨 구조 다중 레벨 구조 데이터 관계 요소 간 1:1 관계 요소 간 1:N 또는 N:N 관계 순회 단일 실행으로 모든 요소 순회 가능 단일 실행으로 모든 요소 순회 불가능 구현 복잡성 구현이 상대적으로 간단 구현이 상대적으로 복잡 메모리 사용 메모리 사용이 덜 효율적 메모리 사용이 더 효율적 시간 복잡도 입력 크기에 따라 증가 특정 작업에서 더 효율적 데이터 접근 순차적 접근 계층적 또는 네트워크 기반 접근 삽입/삭제 상대적으로 간단 더 복잡하지만 유연함 응용 분야 간단한 데이터 저장 및 처리 복잡한 관계 표현, AI, 이미지 처리 등 예시 배열, 연결 리스트, 스택, 큐 트리, 그래프, 해시 테이블, 힙 공통점:
...</p></div><footer class=entry-footer><span title='2024-11-06 11:00:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linear Data Structure vs Non-Linear Data Structure" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear-data-structure-vs-non-linear-data-structure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 (Hash)</h2></header><div class=entry-content><p>해시 (Hash) 임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변환하는 과정이다.
이때 사용되는 함수를 해시 함수(Hash Function)라고 하며, 변환된 결과값을 해시값(Hash Value) 또는 해시 코드라고 한다. 그리고, 해시 테이블은 해시 함수를 사용하여 키(key)를 특정 버킷(bucket) 또는 슬롯(slot)에 매핑하는 자료구조이다.
해시 (Hash)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 변환한다. 해시 함수를 통해 생성된 해시 값에서 원래의 입력 데이터를 역으로 추적하는 것은 매우 어렵거나 불가능하다. 동일한 입력에 대해 항상 같은 해시 값을 생성한다. 이상적으로는 서로 다른 입력에 대해 다른 해시 값을 생성해야 한다. 해시의 특징 고정된 길이의 해시 값 생성 키-값 쌍으로 데이터 저장 빠른 검색 및 삽입 연산 해시 충돌 가능성 해시의 장점 빠른 검색 속도: 평균적으로 O(1)의 시간 복잡도로 데이터를 검색할 수 있다. 효율적인 메모리 사용: 키를 통해 직접 접근이 가능하므로 메모리를 효율적으로 사용한다. 데이터의 고유성 보장: 같은 키에 대해 항상 같은 해시 값을 생성한다. 해시의 단점 해시 충돌: 서로 다른 키가 같은 해시 값을 가질 수 있다. 순서 보장의 어려움: 데이터의 순서를 유지하기 어렵다. 공간 효율성 저하: 충돌 해결을 위한 추가 공간이 필요할 수 있다. 해시의 응용 데이터베이스 인덱싱 암호화 및 데이터 무결성 검증 캐싱 시스템 블록체인 기술 해시의 동작 원리 키를 입력받아 해시 함수를 통해 해시 값 생성 해시 값을 인덱스로 사용하여 데이터 저장 또는 검색 충돌 발생 시 해결 방법 적용 (체이닝 또는 개방 주소법) 해시 충돌과 해결 방법
...</p></div><footer class=entry-footer><span title='2024-11-17 01:33:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1004 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 (Hash)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>그래프 (Graph)</h2></header><div class=entry-content><p>그래프 (Graph) 노드(또는 정점)와 그 노드를 연결하는 간선으로 구성된 자료구조로, 복잡한 관계를 표현하는 데 사용된다.
그래프는 노드(Node) 또는 정점(Vertex)과 그들을 연결하는 간선(Edge)의 집합으로 정의된다.
수학적으로 그래프 G는 G = (V, E)로 표현되며, V는 정점의 집합, E는 간선의 집합을 나타낸다.
![Graph Data Structure](Introduction-to-Graphs.webp “https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/_
그래프의 특징 네트워크 모델: 그래프는 네트워크 구조를 표현하는 데 적합하다. 다중 경로: 두 노드 사이에 여러 경로가 존재할 수 있다. 순환 가능: 사이클(Cycle)을 포함할 수 있다. 방향성: 방향 그래프(Directed Graph)와 무방향 그래프(Undirected Graph)로 구분된다. 가중치: 간선에 가중치를 부여할 수 있다. 그래프의 장점 유연성: 그래프는 다양한 관계와 데이터 구조를 표현하는 데 매우 유연하다. 다양한 응용: 경로 찾기, 데이터 클러스터링, 네트워크 분석, 기계 학습 등 다양한 문제 해결에 사용될 수 있다. 효율적인 알고리즘: 그래프 알고리즘은 종종 매우 효율적이며, 복잡한 문제를 신속하게 해결할 수 있다. 직관적 표현: 복잡한 데이터 구조를 간단하고 직관적인 방식으로 표현할 수 있어 이해와 분석이 용이하다. 단점 복잡성: 그래프 이론이나 관련 알고리즘에 익숙하지 않은 사람들에게는 이해하기 어려울 수 있다 계산 비용: 매우 크거나 복잡한 그래프의 경우, 생성과 조작에 많은 계산 비용이 들 수 있다. 구현의 어려움: 그래프 알고리즘을 설계하고 구현하는 것은 어려울 수 있으며, 버그와 오류에 취약할 수 있다 시각화의 어려움: 매우 크거나 복잡한 그래프의 경우 시각화와 분석이 어려울 수 있다. 그래프의 응용 그래프는 다양한 분야에서 활용된다:
...</p></div><footer class=entry-footer><span title='2024-11-09 05:54:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;789 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 그래프 (Graph)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>힙 (Heap)</h2></header><div class=entry-content><p>힙 (Heap) 힙 (Heap)은 완전 이진 트리(Complete Binary Tree) 구조를 가지면서 부모 노드와 자식 노드 간에 특정한 순서가 있는 자료구조이다.
힙은 주로 우선순위 큐를 구현하는 데 사용되며, 최댓값이나 최솟값을 빠르게 찾아야 하는 상황에서 매우 효율적이다.
힙은 크게 두 가지 종류가 있다:
최대 힙(Max Heap): 부모 노드의 값이 자식 노드의 값보다 크거나 같은 힙. ![Max Heap](max-heap-1.webp “https://www.geeksforgeeks.org/introduction-to-heap/ _
최소 힙(Min Heap): 부모 노드의 값이 자식 노드의 값보다 작거나 같은 힙. https://www.geeksforgeeks.org/introduction-to-heap/
...</p></div><footer class=entry-footer><span title='2024-11-09 05:54:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1310 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 (Heap)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>트리 (Tree)</h2></header><div class=entry-content><p>트리 (Tree) 트리의 개념과 정의 트리는 노드(Node)들과 이들을 연결하는 간선(Edge)들로 구성된 계층적 자료구조이다.
노드(Node)들이 부모-자식 관계로 연결되어 있으며, 하나의 루트 노드에서 시작하여 아래로 뻗어나가는 형태를 가진다.
트리는 다음과 같은 특징을 가진다.
하나의 루트 노드를 가집니다. 각 노드는 0개 이상의 자식 노드를 가질 수 있습니다. 사이클(순환)이 없는 연결 구조입니다. 모든 노드는 단 하나의 부모 노드를 가집니다(루트 노드 제외). ![Tree Data Structure](Introduction-to-tree-.webp “https://www.geeksforgeeks.org/introduction-to-tree-data-structure/ _
트리의 특징 계층적 구조: 데이터를 계층적으로 표현할 수 있다. 비순환성: 노드 간에 순환 경로가 존재하지 않는다. 연결성: 모든 노드는 서로 연결되어 있다. 방향성: 부모에서 자식으로의 방향성을 가진다. 트리의 장점 계층적 데이터 표현: 현실 세계의 많은 구조를 자연스럽게 모델링할 수 있다. 효율적인 검색: 이진 탐색 트리의 경우, 평균 O(log n) 시간 복잡도로 검색이 가능하다. 유연한 구조: 데이터의 삽입과 삭제가 비교적 용이하다. 재귀적 알고리즘 적용: 트리의 구조가 재귀적이어서 많은 문제를 재귀적으로 해결할 수 있다. 트리의 단점 구현 복잡성: 링크드 리스트나 배열에 비해 구현이 복잡할 수 있다. 메모리 사용: 포인터를 사용하므로 추가적인 메모리가 필요하다. 균형 유지의 어려움: 불균형한 트리는 성능 저하를 일으킬 수 있다. 트리의 응용 파일 시스템 구조 데이터베이스 인덱싱 컴파일러의 구문 분석 네트워크 라우팅 알고리즘 의사결정 트리(머신러닝) 트리의 동작 원리 트리는 노드 간의 부모-자식 관계를 통해 데이터를 구조화한다.
각 노드는 데이터와 자식 노드에 대한 참조를 포함한다.
트리의 연산은 대부분 재귀적으로 수행된다.
...</p></div><footer class=entry-footer><span title='2024-11-09 05:53:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;885 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 트리 (Tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>