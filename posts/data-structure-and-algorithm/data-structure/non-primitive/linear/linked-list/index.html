<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>연결 리스트 (Linked List) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Data-Structure,Non-Primitive-data-structure,Linear-Data-Structure,Linked-List"><meta name=description content="각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="연결 리스트 (Linked List)"><meta property="og:description" content="각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="연결 리스트 (Linked List)"><meta name=twitter:description content="각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"},{"@type":"ListItem","position":5,"name":"Linear Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/"},{"@type":"ListItem","position":6,"name":"연결 리스트 (Linked List)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/>Non-Primitive data structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/>Linear Structure</a></div><h1>연결 리스트 (Linked List)</h1><div class=post-description>각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조</div></header><div class=post-content><h2 id=연결-리스트-linked-list>연결 리스트 (Linked List)<a hidden class=anchor aria-hidden=true href=#연결-리스트-linked-list>#</a></h2><p>연결 리스트(Linked List)는 각각의 데이터가 노드(Node)라는 단위로 구성되어 있고, 이 노드들이 다음 노드를 가리키는 참조(Reference)를 통해 순차적으로 연결된 자료구조이다. 각 노드는 데이터와 다음 노드를 가리키는 링크로 구성된다.</p><p><figure><img alt="Linked List Data Structure" loading=lazy src=/img/linked-list.webp><figcaption>https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure/?ref=ghm</figcaption></figure></p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><strong>동적 크기</strong><ul><li>필요에 따라 크기가 자유롭게 늘어나거나 줄어들 수 있다.</li><li>메모리를 효율적으로 사용할 수 있다.</li></ul></li><li><strong>비연속적 메모리 저장</strong><ul><li>각 노드는 메모리 상에서 연속적으로 저장될 필요가 없다.</li><li>데이터가 물리적으로 흩어져 있어도 논리적으로 연결된다.</li></ul></li><li><strong>순차적 접근</strong><ul><li>특정 노드에 접근하기 위해서는 첫 노드부터 순차적으로 탐색해야 한다.</li><li>이전 노드에 대한 참조가 없으면 뒤로 이동이 불가능하다.</li></ul></li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li><strong>동적 크기 조절</strong><ul><li>메모리 공간을 필요한 만큼만 사용할 수 있다.</li><li>크기 제한이 없어 자유로운 데이터 추가가 가능하다.</li></ul></li><li><strong>삽입과 삭제의 효율성</strong><ul><li>포인터만 변경하면 되므로 O(1) 시간에 가능하다.</li><li>데이터의 이동이 필요 없어 효율적이다.</li></ul></li><li><strong>메모리 활용의 유연성</strong><ul><li>연속된 메모리 공간이 필요하지 않다.</li><li>메모리 파편화를 줄일 수 있다.</li></ul></li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li><strong>임의 접근의 비효율성</strong><ul><li>특정 위치의 데이터에 접근하려면 처음부터 순차적으로 탐색해야 한다.</li><li>접근 시간이 O(n)으로 배열보다 느리다.</li></ul></li><li><strong>추가 메모리 사용</strong><ul><li>각 노드마다 다음 노드를 가리키는 포인터를 저장해야 한다.</li><li>배열보다 더 많은 메모리를 사용한다.</li></ul></li><li><strong>캐시 지역성 낮음</strong><ul><li>메모리상에서 연속적이지 않아 캐시 효율이 떨어질 수 있다.</li></ul></li></ol><h3 id=응용>응용<a hidden class=anchor aria-hidden=true href=#응용>#</a></h3><ol><li>스택과 큐의 구현</li><li>이미지 뷰어의 이전/다음 기능</li><li>음악 플레이어의 재생 목록</li><li>웹 브라우저의 뒤로/앞으로 기능</li></ol><h3 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h3><ol><li>단일 연결 리스트(Singly Linked List)<ul><li>각 노드가 다음 노드만을 가리킴</li><li>한 방향으로만 순회 가능</li></ul></li><li>이중 연결 리스트(Doubly Linked List)<ul><li>각 노드가 이전 노드와 다음 노드를 모두 가리킴</li><li>양방향 순회 가능</li></ul></li><li>원형 연결 리스트(Circular Linked List)<ul><li>마지막 노드가 첫 번째 노드를 가리켜 순환 구조를 형성</li></ul></li></ol><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><ul><li>각 노드는 데이터와 다음 노드의 주소를 저장한다.</li><li>헤드 노드부터 시작하여 링크를 따라가며 원하는 노드에 접근한다.</li></ul><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><ol><li>노드(Node): 연결 리스트의 기본 구성 단위<ul><li>데이터 필드: 실제 저장하고자 하는 데이터</li><li>링크 필드: 다음 노드의 주소를 저장하는 포인터</li></ul></li><li>헤드(Head): 첫 번째 노드를 가리키는 참조</li><li>테일(Tail): 마지막 노드를 가리키는 참조 (선택적)</li></ol><h3 id=구현-방식과-메모리-구조>구현 방식과 메모리 구조<a hidden class=anchor aria-hidden=true href=#구현-방식과-메모리-구조>#</a></h3><ul><li>각 노드는 힙 메모리에 동적으로 할당된다.</li><li>노드들은 메모리 상에 비연속적으로 위치하며, 링크로 연결된다.<br>메모리를 효율적으로 사용할 수 있지만, 캐시 지역성(Cache Locality)은 배열보다 떨어질 수 있다.</li></ul><h3 id=주요-연산들의-동작-과정>주요 연산들의 동작 과정<a hidden class=anchor aria-hidden=true href=#주요-연산들의-동작-과정>#</a></h3><ol><li>삽입: 새 노드를 생성하고 링크를 조정하여 리스트에 추가합니다.</li><li>삭제: 노드의 링크를 조정하여 특정 노드를 제거합니다.</li><li>탐색: 헤드부터 시작하여 원하는 노드를 찾을 때까지 링크를 따라갑니다.</li></ol><h3 id=적합한-사용-사례>적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#적합한-사용-사례>#</a></h3><ol><li>데이터의 삽입/삭제가 빈번한 경우<ul><li>큐(Queue)나 스택(Stack)의 구현</li><li>실시간 데이터 스트림 처리</li></ul></li><li>데이터 크기가 가변적인 경우<ul><li>동적 메모리 할당이 필요한 상황</li><li>데이터 수집 및 처리 시스템</li></ul></li><li>순차적 접근이 주로 필요한 경우<ul><li>음악 재생 목록</li><li>브라우저 방문 기록</li></ul></li></ol><h3 id=예시-코드>예시 코드<a hidden class=anchor aria-hidden=true href=#예시-코드>#</a></h3><h4 id=java>Java<a hidden class=anchor aria-hidden=true href=#java>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span><span class=w> </span><span class=n>data</span><span class=p>;</span><span class=w>           </span><span class=c1>// 데이터를 저장하는 필드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>     </span><span class=c1>// 다음 노드를 가리키는 참조</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>data</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>data</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LinkedList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>head</span><span class=p>;</span><span class=w>    </span><span class=c1>// 첫 번째 노드를 가리키는 참조</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>        </span><span class=c1>// 리스트의 크기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>LinkedList</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>head</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=python>Python<a hidden class=anchor aria-hidden=true href=#python>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LinkedList</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert_at_beginning</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>new_node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert_at_end</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrent Skip List</h2></header><div class=entry-content><p>Concurrent Skip List Concurrent Skip List는 Skip List 자료구조를 기반으로 하여 멀티스레드 환경에서 동시에 삽입, 삭제, 검색 작업을 수행할 수 있도록 구현된 동시성 자료구조이다.
Skip List는 여러 계층의 연결 리스트로 구성된 정렬된 데이터 구조인데, ConcurrentSkipList는 이를 멀티스레드 환경에서 안전하게 사용할 수 있도록 구현한 것이다.
이 자료구조는 락-프리(lock-free) 또는 세밀한 동기화 메커니즘을 사용하여 높은 동시성을 제공한다.
특징 동시성 지원: 여러 스레드가 동시에 자료구조에 접근하고 수정할 수 있다. 락-프리 구현: 대부분의 연산에서 락을 사용하지 않고 Compare-and-Swap(CAS) 연산을 활용한다. 확장성: 멀티코어 시스템에서 높은 확장성을 제공한다. 로그 시간 복잡도: 평균적으로 O(log n) 시간 복잡도로 검색, 삽입, 삭제 연산을 수행한다. 확률적 균형: 재조정 작업 없이 확률적으로 균형을 유지한다. 구현 방식 레벨별 락-프리 리스트: 각 레벨의 리스트를 락-프리 연결 리스트로 취급한다. CAS 연산 사용: 노드 삽입 시 CAS 연산을 사용하여 동시성을 제어한다. 마킹 기법: 노드 삭제 시 다음 참조를 마킹하여 논리적 삭제를 수행한다. 도움 메커니즘: find() 메서드가 마킹된 노드를 정리하는 역할을 수행한다. 장점 높은 동시성: 여러 스레드가 동시에 작업을 수행할 수 있어 성능이 향상된다. 확장성: 스레드 수가 증가해도 성능 저하가 적다. 간단한 구현: 동시성 트리 구조에 비해 구현이 상대적으로 간단하다. 메모리 효율성: 일부 트리 구조보다 메모리 효율적일 수 있다. 응용 동시성 우선순위 큐: 멀티스레드 환경에서 효율적인 우선순위 큐 구현에 사용된다. 데이터베이스 시스템: 동시성 인덱싱 구조로 활용된다. 분산 시스템: 분산 환경에서의 정렬된 데이터 관리에 사용된다. 캐시 시스템: 동시성 캐시 구현에 활용될 수 있다. 동작 원리 Concurrent Skip List는 여러 레벨의 연결 리스트로 구성되며, 각 레벨은 이전 레벨의 “빠른 경로"로 작용한다.
검색, 삽입, 삭제 작업은 상위 레벨에서 시작하여 하위 레벨로 이동하면서 수행된다.
...</p></div><footer class=entry-footer><span title='2024-10-08 13:22:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;364 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Skip List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Read-Copy-Update List</h2></header><div class=entry-content><p>Read-Copy-Update (RCU) List RCU List는 동시성을 지원하는 연결 리스트 구조로, 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계되었다.
RCU List는 Read-Copy-Update 메커니즘을 사용하여 구현된 동시성 연결 리스트로 읽기 작업에 대해 락을 사용하지 않으면서도 동시에 업데이트를 수행할 수 있게 해준다.
특징 락 없는 읽기: 읽기 작업은 동기화 없이 수행된다. 동시성 지원: 여러 스레드가 동시에 리스트에 접근할 수 있다. 읽기 성능 최적화: 읽기 작업의 성능이 매우 뛰어나다. 공간-시간 트레이드오프: 더 많은 공간을 사용하여 빠른 연산을 가능하게 한다. 구현 방식 삽입: 새 노드를 생성하고 원자적으로 리스트에 연결한다. 삭제: 노드를 리스트에서 제거한 후, 일정 시간이 지난 뒤 메모리를 해제한다. 읽기: 동기화 없이 리스트를 순회한다. 장점 높은 읽기 성능: 읽기 작업이 매우 빠르다. 확장성: 다중 코어 시스템에서 좋은 성능을 보인다. 데드락 방지: 읽기 작업에서 락을 사용하지 않아 데드락 위험이 줄어든다. 응용 운영체제 커널 데이터베이스 시스템 네트워크 스택 고성능 멀티스레드 애플리케이션 동작 원리 읽기 작업: 동기화 없이 리스트를 순회한다. 쓰기 작업: 새로운 버전의 데이터를 생성하고, 원자적으로 포인터를 업데이트한다. 삭제: 노드를 리스트에서 제거한 후, 모든 읽기 작업이 완료될 때까지 기다렸다가 메모리를 해제한다. 구성 요소 노드: 데이터와 다음 노드를 가리키는 포인터를 포함한다. 헤드 포인터: 리스트의 첫 번째 노드를 가리킨다. RCU 동기화 프리미티브: rcu_read_lock(), rcu_read_unlock(), synchronize_rcu() 등 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.util.concurrent.atomic.AtomicReference; public class LockFreeStack&lt;T> { private static class Node&lt;T> { final T value; Node&lt;T> next; Node(T value) { this.value = value; } } private AtomicReference&lt;Node&lt;T>> head = new AtomicReference&lt;>(null); public void push(T value) { Node&lt;T> newNode = new Node&lt;T>(value); while (true) { Node&lt;T> currentHead = head.get(); newNode.next = currentHead; // CAS로 head를 새 노드로 업데이트 시도 if (head.compareAndSet(currentHead, newNode)) { return; } // 실패하면 다시 시도 } } public T pop() { while (true) { Node&lt;T> currentHead = head.get(); if (currentHead == null) { return null; } // CAS로 head를 다음 노드로 업데이트 시도 if (head.compareAndSet( currentHead, currentHead.next)) { return currentHead.value; } // 실패하면 다시 시도 } } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-08 13:22:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;348 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Read-Copy-Update List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circular Linked List</h2></header><div class=entry-content><p>Circular Linked List 이는 Linked List의 한 변형으로, 데이터를 저장하고 조직하는 특정한 방식을 제공한다.
Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.
이 구조에서는 리스트의 끝이 존재하지 않으며, 모든 노드가 연결되어 원을 형성한다.
https://www.geeksforgeeks.org/circular-linked-list/
특징 마지막 노드의 next 포인터가 NULL이 아닌 첫 번째 노드를 가리킨다. 리스트의 어느 노드에서 시작하더라도 모든 노드를 순회할 수 있다. 리스트의 끝과 시작이 연결되어 있어 순환 구조를 가진다. 장점 리스트의 처음이나 마지막에 노드를 삽입하는 연산이 편리하다. 하나의 노드에서 다른 모든 노드로의 접근이 가능하다. 순환적인 데이터 구조를 표현하기에 적합하다. 메모리를 효율적으로 사용할 수 있다. 단점 구현이 단순 연결 리스트보다 복잡하다. 무한 루프에 빠질 가능성이 있어 순회 중단이 어려울 수 있다. 노드 삭제 시 이전 노드를 찾기 위해 전체 리스트를 순회해야 할 수 있다. 응용 Circular Linked List는 다음과 같은 상황에서 유용하게 사용된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;371 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Linked List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Doubly Linked List</h2></header><div class=entry-content><p>Doubly Linked List Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.
Doubly Linked List는 각 노드가 데이터와 두 개의 링크 필드를 가지고 있는 있으며, 이 두 개의 링크는 이전 노드(previous node)와 다음 노드(next node)를 가리킨다.
이러한 구조로 인해 리스트의 양방향 순회가 가능해진다.
![Doubly Linked List](Insertion-at-the-End-in-Doubly-Linked-List-copy.webp “https://www.geeksforgeeks.org/doubly-linked-list/ _
특징 양방향 연결: 각 노드는 이전 노드와 다음 노드를 모두 가리킨다. 헤드와 테일: 리스트의 시작(헤드)과 끝(테일)을 모두 가리키는 포인터를 유지한다. 순환 구조: 마지막 노드의 다음 노드는 첫 번째 노드를, 첫 번째 노드의 이전 노드는 마지막 노드를 가리킬 수 있다. 장점 양방향 탐색: 리스트를 앞뒤로 탐색할 수 있어 효율적인 검색이 가능하다. 삽입과 삭제의 효율성: 노드의 삽입과 삭제가 O(1) 시간 복잡도로 수행된다. 리스트 끝에서의 연산: 테일 포인터를 통해 리스트의 마지막 요소에 즉시 접근할 수 있다. 단점 메모리 사용량 증가: 각 노드가 두 개의 포인터를 저장해야 하므로 메모리 사용량이 증가한다. 구현의 복잡성: 단일 연결 리스트에 비해 구현이 더 복잡하다. 삽입과 삭제 시 포인터 조작: 노드 삽입과 삭제 시 여러 포인터를 조작해야 한다. 응용 웹 브라우저의 앞으로/뒤로 탐색 기능 음악 플레이어의 재생 목록 운영 체제의 작업 스케줄링 캐시 구현 복잡한 데이터 구조(예: 그래프)의 기본 구성 요소 동작 원리 삽입: 새 노드를 생성하고 이전 노드와 다음 노드의 포인터를 적절히 조정한다. 삭제: 삭제할 노드의 이전 노드와 다음 노드를 서로 연결하고 해당 노드를 메모리에서 해제한다. 탐색: 헤드나 테일에서 시작하여 원하는 노드를 찾을 때까지 포인터를 따라 이동한다. 구성 요소 노드: 데이터와 이전/다음 노드를 가리키는 두 개의 포인터로 구성된다. 헤드 포인터: 리스트의 첫 번째 노드를 가리킨다. 테일 포인터: 리스트의 마지막 노드를 가리킨다. 구현 방식 JavaScript를 사용한 Doubly Linked List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;573 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Doubly Linked List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/doubly-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Skip List</h2></header><div class=entry-content><p>Skip List Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다.
Skip List는 여러 레벨의 연결 리스트로 구성된 데이터 구조로, 각 레벨은 그 아래 레벨의 일부 요소를 포함하며, 최하위 레벨은 모든 요소를 포함한다.
https://en.wikipedia.org/wiki/Skip_list#/media/File:Skip_list.svg
특징 다중 레벨 구조: 여러 층의 연결 리스트로 구성된다. 확률적 균형: 랜덤화를 통해 구조의 균형을 유지한다. 정렬 상태 유지: 요소들은 정렬된 순서로 유지된다. 장점 빠른 검색: 평균 O(log n) 시간 복잡도로 검색이 가능하다. 효율적인 삽입/삭제: 평균 O(log n) 시간에 삽입과 삭제가 가능하다. 구현의 단순성: 균형 이진 탐색 트리에 비해 구현이 간단하다. 단점 추가 메모리 사용: 여러 레벨의 포인터로 인해 추가 메모리가 필요하다. 확률적 성능: 최악의 경우 O(n) 시간 복잡도가 발생할 수 있다. 응용 데이터베이스 인덱싱: RocksDB와 같은 키-값 저장소에서 사용된다. 메모리 관리: 비휘발성 메모리 최적화에 활용된다. 캐시 구현: 효율적인 캐시 시스템 구축에 사용된다. 동작 원리 검색: 최상위 레벨에서 시작하여 목표 값보다 작은 노드를 따라 이동하고, 큰 값을 만나면 아래 레벨로 내려간다. 삽입: 랜덤하게 레벨을 결정하고, 해당 레벨까지 노드를 생성하여 연결한다. 삭제: 노드를 찾아 모든 레벨에서 제거한다. 구성 요소 노드: 키, 값, 여러 레벨의 다음 노드 포인터를 포함한다. 헤드 노드: 모든 레벨의 시작점 역할을 한다. 레벨: 여러 층의 연결 리스트 구조를 형성한다. 구현 방식 JavaScript를 사용한 Skip List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;500 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Skip List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circular Doubly Linked List</h2></header><div class=entry-content><p>Circular Doubly Linked List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-08 07:23:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Doubly Linked List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-doubly-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Singly Linked List</h2></header><div class=entry-content><p>Singly Linked List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-08 07:18:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Singly Linked List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/singly-linked-list/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>