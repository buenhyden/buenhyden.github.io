<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>배열 (Array) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Data-Structure,Non-Primitive-data-structure,Linear-Data-Structure,Array"><meta name=description content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="배열 (Array)"><meta property="og:description" content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="배열 (Array)"><meta name=twitter:description content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"},{"@type":"ListItem","position":5,"name":"Linear Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/"},{"@type":"ListItem","position":6,"name":"배열 (Array)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/>Non-Primitive data structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/>Linear Structure</a></div><h1>배열 (Array)</h1><div class=post-description>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.</div></header><div class=post-content><h2 id=배열-array>배열 (Array)<a hidden class=anchor aria-hidden=true href=#배열-array>#</a></h2><p>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.<br>각 요소는 고유한 인덱스를 통해 접근할 수 있으며, 이 인덱스는 일반적으로 0부터 시작한다.</p><p><figure><img alt="Memory Representation of Array" loading=lazy src=/img/Memory-Representation-of-Array.webp><figcaption>https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/</figcaption></figure></p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><strong>인덱스 기반 접근</strong><ul><li>0부터 시작하는 인덱스를 통해 즉시 접근 가능</li><li>시간복잡도 O(1)로 매우 빠른 접근 속도</li></ul></li><li><strong>연속된 메모리 할당</strong><ul><li>메모리에 연속적으로 저장되어 있어 캐시 효율성이 좋음</li><li>메모리 관리가 효율적</li></ul></li><li><strong>고정된 크기</strong> (일반적인 배열의 경우)<ul><li>생성 시 크기가 결정됨 (동적 배열은 예외)</li><li>크기 변경이 필요한 경우 새로운 배열을 생성해야 함</li></ul></li><li>동일한 데이터 타입<ul><li>하나의 배열은 같은 데이터 타입의 요소만 저장할 수 있다.</li></ul></li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li><strong>빠른 접근 속도</strong><ul><li>인덱스를 통한 직접 접근으로 검색이 매우 빠름</li><li>순차적인 데이터 처리에 효율적</li></ul></li><li><strong>메모리 효율성</strong><ul><li>연속된 메모리 공간 사용으로 메모리 관리가 효율적</li><li>캐시 지역성이 좋아 성능에 이점</li></ul></li><li><strong>간단한 구현</strong><ul><li>사용하기 쉽고 직관적</li><li>기본적인 연산들이 단순함</li></ul></li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li><strong>크기의 제한</strong><ul><li>일반 배열의 경우 크기가 고정됨</li><li>크기 변경 시 새로운 배열 생성 필요</li></ul></li><li><strong>삽입과 삭제의 비효율성</strong><ul><li>중간에 요소를 삽입하거나 삭제할 때 많은 이동 필요</li><li>시간복잡도 O(n)으로 비효율적</li></ul></li><li><strong>메모리 낭비 가능성</strong><ul><li>할당된 크기를 다 사용하지 않을 경우 메모리 낭비</li><li>동적 크기 조절이 어려움</li></ul></li></ol><h3 id=응용>응용<a hidden class=anchor aria-hidden=true href=#응용>#</a></h3><ol><li>데이터 저장 및 처리: 리스트, 스택, 큐 등의 구현에 사용됩니다.</li><li>정렬 및 검색 알고리즘: 다양한 정렬과 검색 알고리즘의 기본 자료구조로 활용됩니다.</li><li>행렬 연산: 다차원 배열을 이용한 행렬 계산에 사용됩니다.</li></ol><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><p>배열은 연속된 메모리 공간에 요소들을 저장합니다. 각 요소는 동일한 크기의 메모리를 차지하며, 배열의 시작 주소와 인덱스를 이용해 특정 요소의 주소를 계산할 수 있습니다.</p><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><ol><li>요소(Element): 배열에 저장된 각각의 데이터</li><li>인덱스(Index): 각 요소의 위치를 나타내는 숫자</li><li>길이(Length): 배열에 저장할 수 있는 요소의 총 개수</li></ol><h3 id=구현-방식과-메모리-구조>구현 방식과 메모리 구조<a hidden class=anchor aria-hidden=true href=#구현-방식과-메모리-구조>#</a></h3><p>배열은 메모리에서 연속된 공간을 할당받아 데이터를 저장한다.</p><p>각 요소의 주소는 다음과 같이 계산된다:<br><code>요소의 주소 = 배열의 기본 주소 + (인덱스 × 데이터 타입의 크기)</code></p><p>예를 들어, 정수 배열에서 각 정수가 4바이트를 차지한다면:</p><ul><li>첫 번째 요소(인덱스 0): 기본 주소 + (0 × 4)</li><li>두 번째 요소(인덱스 1): 기본 주소 + (1 × 4)</li><li>세 번째 요소(인덱스 2): 기본 주소 + (2 × 4)<br>이러한 구조 덕분에 배열은 인덱스를 통한 직접 접근이 가능하며, 매우 빠른 검색 속도를 제공한다.</li></ul><h3 id=주요-연산들의-동작-과정>주요 연산들의 동작 과정<a hidden class=anchor aria-hidden=true href=#주요-연산들의-동작-과정>#</a></h3><ol><li>접근(Access): 인덱스를 통해 직접 접근 (O(1))</li><li>삽입(Insertion): 새로운 요소 삽입 시 기존 요소들을 이동 (O(n))</li><li>삭제(Deletion): 요소 삭제 후 빈 공간을 채우기 위해 요소들을 이동 (O(n))</li><li>검색(Search): 순차 검색 시 O(n), 정렬된 배열에서 이진 검색 시 O(log n)</li></ol><h3 id=사용하기-적절한-곳>사용하기 적절한 곳<a hidden class=anchor aria-hidden=true href=#사용하기-적절한-곳>#</a></h3><ol><li><strong>데이터의 크기가 고정적인 경우</strong><ul><li>학생 명단, 좌석 배치 등</li></ul></li><li><strong>random access가 빈번한 경우</strong><ul><li>인덱스를 통한 빠른 접근이 필요할 때</li></ul></li><li><strong>순차적인 데이터 처리가 필요한 경우</strong><ul><li>리스트 순회, 데이터 검색 등</li></ul></li><li><strong>간단한 데이터 구조가 필요한 경우</strong><ul><li>간단한 리스트 관리, 임시 데이터 저장 등</li></ul></li></ol><h3 id=예시-코드>예시 코드<a hidden class=anchor aria-hidden=true href=#예시-코드>#</a></h3><h4 id=java>Java<a hidden class=anchor aria-hidden=true href=#java>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ArrayOperations</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 배열 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>5</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 요소 삽입</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>numbers</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>numbers</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>20</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>numbers</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>30</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 요소 접근</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;두 번째 요소: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>numbers</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 요소 수정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>numbers</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>25</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 배열 순회</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numbers</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;요소 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=javascript>Javascript<a hidden class=anchor aria-hidden=true href=#javascript>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 배열 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>fruits</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;apple&#39;</span><span class=p>,</span> <span class=s1>&#39;banana&#39;</span><span class=p>,</span> <span class=s1>&#39;orange&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 접근
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fruits</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span> <span class=c1>// 출력: banana
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 삽입
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fruits</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s1>&#39;grape&#39;</span><span class=p>);</span> <span class=c1>// 끝에 삽입
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fruits</span><span class=p>.</span><span class=nx>unshift</span><span class=p>(</span><span class=s1>&#39;mango&#39;</span><span class=p>);</span> <span class=c1>// 시작에 삽입
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fruits</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span> <span class=c1>// 끝에서 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fruits</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span> <span class=c1>// 시작에서 삭제
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 검색
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>index</span> <span class=o>=</span> <span class=nx>fruits</span><span class=p>.</span><span class=nx>indexOf</span><span class=p>(</span><span class=s1>&#39;banana&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>index</span><span class=p>);</span> <span class=c1>// 출력: 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 순회
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fruits</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>fruit</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fruit</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 길이
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fruits</span><span class=p>.</span><span class=nx>length</span><span class=p>);</span> <span class=c1>// 출력: 3
</span></span></span></code></pre></td></tr></table></div></div><p>이러한 특성들로 인해 배열은 다양한 알고리즘과 데이터 처리 작업에서 핵심적인 역할을 한다.<br>초보자들은 배열의 기본 개념을 이해하고 다양한 연산을 연습함으로써 프로그래밍 실력을 향상시킬 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Suffix Array</h2></header><div class=entry-content><p>Suffix Array Suffix Array는 주어진 문자열의 모든 접미사(suffix)를 사전순으로 정렬한 배열로, 각 요소는 접미사의 시작 위치를 나타내는 정수이다.
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
특징 모든 접미사를 사전순으로 정렬하여 저장한다. 공간 효율적인 구조를 가진다. 빠른 문자열 검색을 가능하게 한다. 장점 효율적인 문자열 검색과 패턴 매칭이 가능하다. 공간 복잡도가 O(n)으로 효율적이다. 다양한 문자열 관련 문제 해결에 활용될 수 있다. 단점 구축 과정이 복잡할 수 있다. 기본 구현의 시간 복잡도가 O(n^2 log n)으로 높다. 응용 문자열 검색 및 패턴 매칭 생물정보학에서의 DNA 시퀀싱 분석 데이터 압축 알고리즘 텍스트 인덱싱 및 전체 텍스트 검색 동작 원리 문자열의 모든 접미사를 생성한다. 생성된 접미사들을 사전순으로 정렬한다. 정렬된 접미사의 시작 위치를 배열에 저장한다. 구성 요소 원본 문자열 정수 배열 (접미사의 시작 위치를 저장) (선택적으로) LCP(Longest Common Prefix) 배열 구현 방식 일반적으로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-06 13:01:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;273 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Array" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/suffix-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fixed Size Array</h2></header><div class=entry-content><p>Fixed Size Array 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 07:22:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fixed Size Array" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/fixed-size-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multi-dimensional Array</h2></header><div class=entry-content><p>Multi-dimensional Array 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 07:21:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multi-dimensional Array" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/multi-dimensional-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>One-dimensional Array</h2></header><div class=entry-content><p>One-dimensional Array 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 07:21:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to One-dimensional Array" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/one-dimensional-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적 배열 (Dynamic Array)</h2></header><div class=entry-content><p>동적 배열 (Dynamic Array) 동적 배열은 크기가 가변적인 배열 형태의 데이터 구조이다.
정적 배열과 달리 실행 시간에 크기를 조절할 수 있어 메모리를 효율적으로 사용할 수 있다.
https://www.geeksforgeeks.org/how-do-dynamic-arrays-work/
특징 가변적 크기: 필요에 따라 크기가 자동으로 조절된다. 연속된 메모리 할당: 요소들이 메모리상에 연속적으로 저장된다. 임의 접근(Random Access): 인덱스를 통해 O(1) 시간에 요소에 접근할 수 있다. 동적 메모리 할당: 실행 시간에 메모리를 할당하고 해제할 수 있다. 장점 유연성: 크기를 미리 정하지 않아도 되어 유연한 데이터 관리가 가능하다. 메모리 효율성: 필요한 만큼만 메모리를 사용한다. 빠른 접근 속도: 인덱스를 통한 빠른 요소 접근이 가능하다. 단점 재할당 비용: 크기 조정 시 새로운 메모리 할당과 데이터 복사에 따른 비용이 발생한다. 메모리 단편화: 빈번한 크기 조정으로 메모리 단편화가 발생할 수 있다. 삽입/삭제 연산의 비효율성: 중간에 요소를 삽입하거나 삭제할 때 다른 요소들을 이동시켜야 한다. 응용 리스트 구현: Java의 ArrayList, Python의 list 등의 기본 자료구조 구현에 사용된다. 스택과 큐 구현: 동적 배열을 이용해 스택과 큐를 효율적으로 구현할 수 있다. 데이터베이스 인덱싱: 빠른 검색을 위한 인덱스 구조에 활용된다. 동작 원리 초기화: 일정 크기의 배열로 시작한다. 삽입: 배열이 가득 차면 더 큰 크기의 새 배열을 생성하고 기존 데이터를 복사한다. 삭제: 요소를 제거하고 필요시 배열 크기를 줄인다. 접근: 인덱스를 통해 직접 접근한다. 구성 요소 내부 배열: 실제 데이터를 저장하는 고정 크기 배열 크기(size): 현재 저장된 요소의 수 용량(capacity): 내부 배열의 전체 크기 구현 방식 (Java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class DynamicArray&lt;T> { private T[] array; private int size; private int capacity; @SuppressWarnings("unchecked") public DynamicArray(int initialCapacity) { array = (T[]) new Object[initialCapacity]; size = 0; capacity = initialCapacity; } public void add(T element) { if (size == capacity) { grow(); } array[size++] = element; } @SuppressWarnings("unchecked") private void grow() { capacity *= 2; T[] newArray = (T[]) new Object[capacity]; System.arraycopy(array, 0, newArray, 0, size); array = newArray; } public T get(int index) { if (index &lt; 0 || index >= size) { throw new IndexOutOfBoundsException(); } return array[index]; } public int size() { return size; } } 구현 시 고려사항 초기 크기 설정 예상 데이터 량에 따른 적절한 초기 크기 설정 너무 작으면 잦은 재할당, 너무 크면 메모리 낭비 확장 정책 단순 2배 증가 vs 다른 증가 비율 애플리케이션 특성에 맞는 정책 선택 축소 정책 언제 배열 크기를 줄일 것인지 메모리 효율성과 성능 사이의 균형 스레드 안전성 멀티스레드 환경에서의 동기화 고려 락(Lock) 메커니즘 구현 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 07:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;409 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적 배열 (Dynamic Array)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/dynamic-array/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>