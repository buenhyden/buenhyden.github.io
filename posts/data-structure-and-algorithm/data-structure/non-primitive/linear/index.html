<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linear Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="Linear Structure - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Linear Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Linear Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"},{"@type":"ListItem","position":5,"name":"Linear Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/>Non-Primitive data structure</a></div><h1>Linear Structure</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스택 (Stack)</h2></header><div class=entry-content><p>스택 (Stack) 스택 (Stack)은 ‘후입선출’(LIFO: Last In First Out) 원칙을 따르는 선형 자료구조로, 가장 최근에 들어온 데이터가 가장 먼저 나가게 된다.
LIFO (Last In First Out)
마지막에 들어온 데이터가 가장 먼저 나가는 원칙
실행 취소(undo), 함수 호출 관리, 괄호 매칭 등에 사용
실생활 예시: 책상에 쌓인 책더미 웹 브라우저의 뒤로 가기 기록 프로그래밍의 함수 호출 스택 작동 방식: Push (삽입): 새로운 데이터는 항상 스택의 top에 추가됨 Pop (제거): 가장 최근에 추가된 데이터(top)가 먼저 제거됨 1 2 3 4 5 Push(1) → [1] Push(2) → [2,1] Push(3) → [3,2,1] Pop() → 반환: 3, 스택: [2,1] Pop() → 반환: 2, 스택: [1] ![Stack Data structure](Stack-Data-Structure.png “https://www.geeksforgeeks.org/stack-data-structure/?ref=outind_
스택(Stack)은 컴퓨터 과학에서 중요한 선형 데이터 구조입니다.
...</p></div><footer class=entry-footer><span title='2024-10-08 05:53:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;682 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스택 (Stack)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>연결 리스트 (Linked List)</h2></header><div class=entry-content><p>연결 리스트 (Linked List) 연결 리스트(Linked List)는 각각의 데이터가 노드(Node)라는 단위로 구성되어 있고, 이 노드들이 다음 노드를 가리키는 참조(Reference)를 통해 순차적으로 연결된 자료구조이다. 각 노드는 데이터와 다음 노드를 가리키는 링크로 구성된다.
https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure/?ref=ghm
특징 동적 크기 필요에 따라 크기가 자유롭게 늘어나거나 줄어들 수 있다. 메모리를 효율적으로 사용할 수 있다. 비연속적 메모리 저장 각 노드는 메모리 상에서 연속적으로 저장될 필요가 없다. 데이터가 물리적으로 흩어져 있어도 논리적으로 연결된다. 순차적 접근 특정 노드에 접근하기 위해서는 첫 노드부터 순차적으로 탐색해야 한다. 이전 노드에 대한 참조가 없으면 뒤로 이동이 불가능하다. 장점 동적 크기 조절 메모리 공간을 필요한 만큼만 사용할 수 있다. 크기 제한이 없어 자유로운 데이터 추가가 가능하다. 삽입과 삭제의 효율성 포인터만 변경하면 되므로 O(1) 시간에 가능하다. 데이터의 이동이 필요 없어 효율적이다. 메모리 활용의 유연성 연속된 메모리 공간이 필요하지 않다. 메모리 파편화를 줄일 수 있다. 단점 임의 접근의 비효율성 특정 위치의 데이터에 접근하려면 처음부터 순차적으로 탐색해야 한다. 접근 시간이 O(n)으로 배열보다 느리다. 추가 메모리 사용 각 노드마다 다음 노드를 가리키는 포인터를 저장해야 한다. 배열보다 더 많은 메모리를 사용한다. 캐시 지역성 낮음 메모리상에서 연속적이지 않아 캐시 효율이 떨어질 수 있다. 응용 스택과 큐의 구현 이미지 뷰어의 이전/다음 기능 음악 플레이어의 재생 목록 웹 브라우저의 뒤로/앞으로 기능 종류 단일 연결 리스트(Singly Linked List) 각 노드가 다음 노드만을 가리킴 한 방향으로만 순회 가능 이중 연결 리스트(Doubly Linked List) 각 노드가 이전 노드와 다음 노드를 모두 가리킴 양방향 순회 가능 원형 연결 리스트(Circular Linked List) 마지막 노드가 첫 번째 노드를 가리켜 순환 구조를 형성 동작 원리 각 노드는 데이터와 다음 노드의 주소를 저장한다. 헤드 노드부터 시작하여 링크를 따라가며 원하는 노드에 접근한다. 구성 요소 노드(Node): 연결 리스트의 기본 구성 단위 데이터 필드: 실제 저장하고자 하는 데이터 링크 필드: 다음 노드의 주소를 저장하는 포인터 헤드(Head): 첫 번째 노드를 가리키는 참조 테일(Tail): 마지막 노드를 가리키는 참조 (선택적) 구현 방식과 메모리 구조 각 노드는 힙 메모리에 동적으로 할당된다. 노드들은 메모리 상에 비연속적으로 위치하며, 링크로 연결된다.
메모리를 효율적으로 사용할 수 있지만, 캐시 지역성(Cache Locality)은 배열보다 떨어질 수 있다. 주요 연산들의 동작 과정 삽입: 새 노드를 생성하고 링크를 조정하여 리스트에 추가합니다. 삭제: 노드의 링크를 조정하여 특정 노드를 제거합니다. 탐색: 헤드부터 시작하여 원하는 노드를 찾을 때까지 링크를 따라갑니다. 적합한 사용 사례 데이터의 삽입/삭제가 빈번한 경우 큐(Queue)나 스택(Stack)의 구현 실시간 데이터 스트림 처리 데이터 크기가 가변적인 경우 동적 메모리 할당이 필요한 상황 데이터 수집 및 처리 시스템 순차적 접근이 주로 필요한 경우 음악 재생 목록 브라우저 방문 기록 예시 코드 Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Node&lt;T> { T data; // 데이터를 저장하는 필드 Node&lt;T> next; // 다음 노드를 가리키는 참조 public Node(T data) { this.data = data; this.next = null; } } public class LinkedList&lt;T> { private Node&lt;T> head; // 첫 번째 노드를 가리키는 참조 private int size; // 리스트의 크기 public LinkedList() { this.head = null; this.size = 0; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert_at_beginning(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def insert_at_end(self, data): new_node = Node(data) if self.head is None: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;544 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 연결 리스트 (Linked List)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>큐 (Queue)</h2></header><div class=entry-content><p>큐 (Queue) 큐 (Queue)는 “선입선출(FIFO: First In First Out)” 원칙을 따르는 데이터 구조이다.
즉, 가장 먼저 삽입된 요소가 가장 먼저 제거된다.
FIFO (First In First Out)
먼저 들어온 데이터가 가장 먼저 나가는 원칙
프로세스 스케줄링, 프린터 대기열, 네트워크 패킷 처리 등에 사용
실생활 예시: 은행 창구 대기열 프린터 인쇄 대기열 식당 주문 처리 작동 방식: Enqueue (삽입): 새로운 데이터는 큐의 뒤쪽(rear)에 추가됨 Dequeue (제거): 가장 먼저 들어온 데이터가 앞쪽(front)에서 제거됨 1 2 3 4 5 Enqueue(1) → [1] Enqueue(2) → [1,2] Enqueue(3) → [1,2,3] Dequeue() → 반환: 1, 큐: [2,3] Dequeue() → 반환: 2, 큐: [3] ![Queue Data Structure](Queue-Data-structure1.png “https://www.geeksforgeeks.org/queue-data-structure/?ref=outind _
...</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;729 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 큐 (Queue)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>배열 (Array)</h2></header><div class=entry-content><p>배열 (Array) 배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.
각 요소는 고유한 인덱스를 통해 접근할 수 있으며, 이 인덱스는 일반적으로 0부터 시작한다.
https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/
특징 인덱스 기반 접근 0부터 시작하는 인덱스를 통해 즉시 접근 가능 시간복잡도 O(1)로 매우 빠른 접근 속도 연속된 메모리 할당 메모리에 연속적으로 저장되어 있어 캐시 효율성이 좋음 메모리 관리가 효율적 고정된 크기 (일반적인 배열의 경우) 생성 시 크기가 결정됨 (동적 배열은 예외) 크기 변경이 필요한 경우 새로운 배열을 생성해야 함 동일한 데이터 타입 하나의 배열은 같은 데이터 타입의 요소만 저장할 수 있다. 장점 빠른 접근 속도 인덱스를 통한 직접 접근으로 검색이 매우 빠름 순차적인 데이터 처리에 효율적 메모리 효율성 연속된 메모리 공간 사용으로 메모리 관리가 효율적 캐시 지역성이 좋아 성능에 이점 간단한 구현 사용하기 쉽고 직관적 기본적인 연산들이 단순함 단점 크기의 제한 일반 배열의 경우 크기가 고정됨 크기 변경 시 새로운 배열 생성 필요 삽입과 삭제의 비효율성 중간에 요소를 삽입하거나 삭제할 때 많은 이동 필요 시간복잡도 O(n)으로 비효율적 메모리 낭비 가능성 할당된 크기를 다 사용하지 않을 경우 메모리 낭비 동적 크기 조절이 어려움 응용 데이터 저장 및 처리: 리스트, 스택, 큐 등의 구현에 사용됩니다. 정렬 및 검색 알고리즘: 다양한 정렬과 검색 알고리즘의 기본 자료구조로 활용됩니다. 행렬 연산: 다차원 배열을 이용한 행렬 계산에 사용됩니다. 동작 원리 배열은 연속된 메모리 공간에 요소들을 저장합니다. 각 요소는 동일한 크기의 메모리를 차지하며, 배열의 시작 주소와 인덱스를 이용해 특정 요소의 주소를 계산할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-10-06 05:52:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 배열 (Array)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>