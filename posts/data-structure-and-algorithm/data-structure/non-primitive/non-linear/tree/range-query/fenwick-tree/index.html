<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fenwick Tree | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Data-Structure,Non-Primitive-data-structure,Non-Linear-Data-Structure,Tree,Range-Query,Fenwick-Tree"><meta name=description content="Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fenwick Tree"><meta property="og:description" content="Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-11T12:56:00+00:00"><meta property="article:modified_time" content="2024-10-11T12:56:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Data-Structure"><meta property="article:tag" content="Non-Primitive-Data-Structure"><meta property="article:tag" content="Non-Linear-Data-Structure"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Range-Query"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fenwick Tree"><meta name=twitter:description content="Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"},{"@type":"ListItem","position":6,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/"},{"@type":"ListItem","position":7,"name":"Range Query","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/"},{"@type":"ListItem","position":8,"name":"Fenwick Tree","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fenwick Tree","name":"Fenwick Tree","description":"Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.","keywords":["Data-Structure-and-Algorithm","Data-Structure","Non-Primitive-data-structure","Non-Linear-Data-Structure","Tree","Range-Query","Fenwick-Tree"],"articleBody":"Fenwick Tree (Binary Indexed Tree, BIT) Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.\n1994년 Peter M. Fenwick에 의해 제안되었다.\n데이터를 저장하고 조작하는 방식을 정의하며, 특정 연산을 효율적으로 수행할 수 있게 해줍니다.\nhttps://en.wikipedia.org/wiki/Fenwick_tree#/media/File:16-node_Fenwick_tree.svg\n일반적인 트리와 달리, 배열을 사용하여 이진 트리를 암시적으로 표현한다.\n각 인덱스는 이진수 표현에서 마지막 1의 위치에 따라 관리하는 구간의 크기가 결정된다.\n특징 공간 효율성: 세그먼트 트리보다 메모리 사용이 적다. 동적 구조: 데이터의 변경을 효율적으로 처리할 수 있다. 이진 표현 활용: 인덱스의 이진 표현을 사용하여 누적 빈도를 저장하고 조작한다. 로그 시간 복잡도: 쿼리와 업데이트 연산이 O(log n) 시간에 수행된다. 장점 효율적인 시간 복잡도: 구간 합 계산과 업데이트 모두 O(log n)이다. 메모리 효율성: 세그먼트 트리에 비해 메모리 사용량이 적다. 구현의 용이성: 세그먼트 트리보다 구현이 간단하다. 다차원으로의 확장 가능성: 2차원 이상의 배열에도 적용할 수 있다. 단점 구현 복잡성: 세그먼트 트리에 비해 구현이 약간 더 복잡할 수 있다. 제한된 연산: 일부 복잡한 연산은 직접 지원하지 않는다. 응용 데이터베이스 시스템의 구간 합 쿼리 알고리즘 대회 문제 해결 실시간 데이터 분석 시스템 금융 데이터의 누적 합 계산 동작 원리 구축: 원본 배열의 각 요소에 대해 트리를 업데이트합니다. 쿼리: 이진 표현을 이용해 필요한 부분합들을 효율적으로 더합니다. 업데이트: 해당 인덱스와 그 조상 노드들을 갱신합니다. 구성 요소 배열: 부분합을 저장하는 기본 구조 인덱스: 이진 표현을 이용해 트리 구조를 암시적으로 표현 LSB(Least Significant Bit): 업데이트와 쿼리 연산에서 중요한 역할을 한다. 구현 방식 Fenwick Tree는 주로 다음과 같은 방식으로 구현된다:\n1차원 배열을 사용하여 트리 구조를 표현한다. 비트 연산을 활용하여 부모 노드와 자식 노드 간의 관계를 정의한다. 업데이트와 쿼리 함수를 구현하여 데이터 조작과 조회를 수행한다. 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree: def __init__(self, n): self.size = n self.tree = [0] * (n + 1) # 1-based indexing 사용 def update(self, index, delta): \"\"\"특정 인덱스의 값을 delta만큼 증가시킵니다\"\"\" while index \u003c= self.size: self.tree[index] += delta # 다음 담당 구간으로 이동 (마지막 1비트를 더함) index += index \u0026 (-index) def prefix_sum(self, index): \"\"\"1부터 index까지의 구간 합을 반환합니다\"\"\" total = 0 while index \u003e 0: total += self.tree[index] # 이전 담당 구간으로 이동 (마지막 1비트를 뺌) index -= index \u0026 (-index) return total def range_sum(self, left, right): \"\"\"left부터 right까지의 구간 합을 반환합니다\"\"\" return self.prefix_sum(right) - self.prefix_sum(left - 1) 실제 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Fenwick Tree 사용 예시 ft = FenwickTree(10) # 배열 [3, 2, 4, 5, 1, 1, 2, 3, 4, 1]을 표현 initial_array = [3, 2, 4, 5, 1, 1, 2, 3, 4, 1] for i in range(len(initial_array)): ft.update(i + 1, initial_array[i]) # 구간 합 계산 예시 print(ft.range_sum(1, 5)) # 인덱스 1~5의 합: 3+2+4+5+1 = 15 print(ft.range_sum(3, 7)) # 인덱스 3~7의 합: 4+5+1+1+2 = 13 # 값 업데이트 예시 ft.update(4, 2) # 인덱스 4의 값을 2만큼 증가 참고 및 출처 ","wordCount":"477","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-11T12:56:00Z","dateModified":"2024-10-11T12:56:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/>Non-Primitive data structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/>Range Query</a></div><h1 class="post-title entry-hint-parent">Fenwick Tree</h1><div class=post-description>Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.</div><div class=post-meta><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Data%20Structure/Non-Primitive/Non-Linear/Tree/Range%20Query/Fenwick-Tree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#fenwick-tree-binary-indexed-tree-bit>Fenwick Tree (Binary Indexed Tree, BIT)</a><ul><li><a href=#특징>특징</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#응용>응용</a></li><li><a href=#동작-원리>동작 원리</a></li><li><a href=#구성-요소>구성 요소</a></li><li><a href=#구현-방식>구현 방식</a></li></ul></li><li><a href=#예시-코드>예시 코드</a><ul><li><a href=#실제-사용-예시>실제 사용 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=fenwick-tree-binary-indexed-tree-bit>Fenwick Tree (Binary Indexed Tree, BIT)<a hidden class=anchor aria-hidden=true href=#fenwick-tree-binary-indexed-tree-bit>#</a></h2><p>Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.<br>1994년 Peter M. Fenwick에 의해 제안되었다.<br>데이터를 저장하고 조작하는 방식을 정의하며, 특정 연산을 효율적으로 수행할 수 있게 해줍니다.</p><p><figure><img alt="Depiction of a 16-node Fenwick tree, with nodes containing range sums of a 15-node array A" loading=lazy src=/img/640px-16-node_Fenwick_tree.svg.png><figcaption>https://en.wikipedia.org/wiki/Fenwick_tree#/media/File:16-node_Fenwick_tree.svg</figcaption></figure></p><p>일반적인 트리와 달리, 배열을 사용하여 이진 트리를 암시적으로 표현한다.<br>각 인덱스는 이진수 표현에서 마지막 1의 위치에 따라 관리하는 구간의 크기가 결정된다.</p><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li>공간 효율성: 세그먼트 트리보다 메모리 사용이 적다.</li><li>동적 구조: 데이터의 변경을 효율적으로 처리할 수 있다.</li><li>이진 표현 활용: 인덱스의 이진 표현을 사용하여 누적 빈도를 저장하고 조작한다.</li><li>로그 시간 복잡도: 쿼리와 업데이트 연산이 O(log n) 시간에 수행된다.</li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>효율적인 시간 복잡도: 구간 합 계산과 업데이트 모두 O(log n)이다.</li><li>메모리 효율성: 세그먼트 트리에 비해 메모리 사용량이 적다.</li><li>구현의 용이성: 세그먼트 트리보다 구현이 간단하다.</li><li>다차원으로의 확장 가능성: 2차원 이상의 배열에도 적용할 수 있다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li>구현 복잡성: 세그먼트 트리에 비해 구현이 약간 더 복잡할 수 있다.</li><li>제한된 연산: 일부 복잡한 연산은 직접 지원하지 않는다.</li></ol><h3 id=응용>응용<a hidden class=anchor aria-hidden=true href=#응용>#</a></h3><ol><li>데이터베이스 시스템의 구간 합 쿼리</li><li>알고리즘 대회 문제 해결</li><li>실시간 데이터 분석 시스템</li><li>금융 데이터의 누적 합 계산</li></ol><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><ol><li>구축: 원본 배열의 각 요소에 대해 트리를 업데이트합니다.</li><li>쿼리: 이진 표현을 이용해 필요한 부분합들을 효율적으로 더합니다.</li><li>업데이트: 해당 인덱스와 그 조상 노드들을 갱신합니다.</li></ol><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><ol><li>배열: 부분합을 저장하는 기본 구조</li><li>인덱스: 이진 표현을 이용해 트리 구조를 암시적으로 표현</li><li>LSB(Least Significant Bit): 업데이트와 쿼리 연산에서 중요한 역할을 한다.</li></ol><h3 id=구현-방식>구현 방식<a hidden class=anchor aria-hidden=true href=#구현-방식>#</a></h3><p>Fenwick Tree는 주로 다음과 같은 방식으로 구현된다:</p><ol><li>1차원 배열을 사용하여 트리 구조를 표현한다.</li><li>비트 연산을 활용하여 부모 노드와 자식 노드 간의 관계를 정의한다.</li><li>업데이트와 쿼리 함수를 구현하여 데이터 조작과 조회를 수행한다.</li></ol><h2 id=예시-코드>예시 코드<a hidden class=anchor aria-hidden=true href=#예시-코드>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FenwickTree</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>def</span> <span class=n>__init__</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>self</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=n>self</span><span class=p>.</span><span class=n>tree</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=err>#</span> <span class=mi>1</span><span class=o>-</span><span class=n>based</span> <span class=n>indexing</span> <span class=err>사용</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>def</span> <span class=n>update</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>delta</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;&#34;&#34;특정 인덱스의 값을 delta만큼 증가시킵니다&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>index</span> <span class=o>&lt;=</span> <span class=n>self</span><span class=p>.</span><span class=nl>size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>self</span><span class=p>.</span><span class=n>tree</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>+=</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>            <span class=cp># 다음 담당 구간으로 이동 (마지막 1비트를 더함)
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=n>index</span> <span class=o>+=</span> <span class=n>index</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>def</span> <span class=n>prefix_sum</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>index</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;&#34;&#34;1부터 index까지의 구간 합을 반환합니다&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>+=</span> <span class=n>self</span><span class=p>.</span><span class=n>tree</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=cp># 이전 담당 구간으로 이동 (마지막 1비트를 뺌)
</span></span></span><span class=line><span class=cl><span class=cp></span>            <span class=n>index</span> <span class=o>-=</span> <span class=n>index</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>def</span> <span class=n>range_sum</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;&#34;&#34;left부터 right까지의 구간 합을 반환합니다&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>self</span><span class=p>.</span><span class=n>prefix_sum</span><span class=p>(</span><span class=n>right</span><span class=p>)</span> <span class=o>-</span> <span class=n>self</span><span class=p>.</span><span class=n>prefix_sum</span><span class=p>(</span><span class=n>left</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실제-사용-예시>실제 사용 예시<a hidden class=anchor aria-hidden=true href=#실제-사용-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Fenwick Tree 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>ft</span> <span class=o>=</span> <span class=n>FenwickTree</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 배열 [3, 2, 4, 5, 1, 1, 2, 3, 4, 1]을 표현</span>
</span></span><span class=line><span class=cl><span class=n>initial_array</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>initial_array</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=n>ft</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>initial_array</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 구간 합 계산 예시</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>ft</span><span class=o>.</span><span class=n>range_sum</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>))</span>  <span class=c1># 인덱스 1~5의 합: 3+2+4+5+1 = 15</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>ft</span><span class=o>.</span><span class=n>range_sum</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>  <span class=c1># 인덱스 3~7의 합: 4+5+1+1+2 = 13</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 값 업데이트 예시</span>
</span></span><span class=line><span class=cl><span class=n>ft</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>  <span class=c1># 인덱스 4의 값을 2만큼 증가</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/data-structure/>Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-primitive-data-structure/>Non-Primitive-Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-linear-data-structure/>Non-Linear-Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/range-query/>Range-Query</a></li><li><a href=https://buenhyden.github.io/tags/fenwick-tree/>Fenwick-Tree</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/><span class=title>« Prev</span><br><span>트라이 (Trie)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/><span class=title>Next »</span><br><span>Segment Tree</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>