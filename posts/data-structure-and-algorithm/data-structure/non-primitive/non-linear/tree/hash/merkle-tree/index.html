<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Merkle Tree | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Data-Structure,Non-Primitive-data-structure,Non-Linear-Data-Structure,Tree,Hash"><meta name=description content="Merkle Tree
머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.
머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.
계층적 해시 구조

Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256).
Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화.
Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표.

예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Merkle Tree"><meta property="og:description" content="Merkle Tree 머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.
머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.
계층적 해시 구조 Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256). Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화. Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표. 예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-11T08:04:00+00:00"><meta property="article:modified_time" content="2024-10-11T08:04:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Data-Structure"><meta property="article:tag" content="Non-Primitive-Data-Structure"><meta property="article:tag" content="Non-Linear-Data-Structure"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Hash"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Merkle Tree"><meta name=twitter:description content="Merkle Tree
머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.
머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.
계층적 해시 구조

Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256).
Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화.
Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표.

예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"Data Structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/"},{"@type":"ListItem","position":4,"name":"Non-Primitive data structure","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/"},{"@type":"ListItem","position":6,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/"},{"@type":"ListItem","position":7,"name":"Hash","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/"},{"@type":"ListItem","position":8,"name":"Merkle Tree","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Merkle Tree","name":"Merkle Tree","description":"Merkle Tree 머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.\n블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.\n머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.\n데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.\n계층적 해시 구조 Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256). Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화. Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표. 예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성\n","keywords":["Data-Structure-and-Algorithm","Data-Structure","Non-Primitive-data-structure","Non-Linear-Data-Structure","Tree","Hash"],"articleBody":"Merkle Tree 머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.\n블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.\n머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.\n데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.\n계층적 해시 구조 Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256). Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화. Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표. 예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성\n1 2 3 4 5 H(ABCD) / \\ H(AB) H(CD) / \\ / \\ H(A) H(B) H(C) H(D) 데이터 변조 검출 메커니즘 특징: 단일 데이터 변경 → 모든 상위 노드 해시 값 변경 → Merkle Root 불일치. 예시: 트랜잭션 B가 B’로 변조되면 H(B) → H(B’), H(AB) → H(AB’), H(ABCD) → H(AB’CD). 핵심 장점 항목 설명 빠른 검증 특정 데이터 검증 시 전체 데이터 불필요 (O(log N) 시간 복잡도) 공간 효율 Merkle Root(32바이트)만으로 전체 데이터 무결성 확인 가능 분산 시스템 적합 부분적 데이터 전송에서도 무결성 검증 가능 (예: BitTorrent) 한계 및 개선 방향 거대 데이터셋: 트리 높이 증가 → 검증 경로 길어짐. 동적 업데이트: 기존 구조는 삭제/수정에 비효율적 → Merkle Patricia Trie로 해결. 표준화 부족: 구현마다 해시 함수, 트리 구조 차이 (예: Bitcoin-SHA256, Ethereum-Keccak). 블록체인에서의 활용 비트코인 역할: 블록 헤더에 Merkle Root 저장 → 트랜잭션 집합의 무결성 보장. SPV(Simplified Payment Verification): 라이트 노드가 풀 노드 없이 특정 트랜잭션 검증 가능. 검증 프로세스:\n라이트 노드가 풀 노드에 Merkle Proof 요청 (H(C), H(D), H(AB)). H(C) + H(D) → H(CD), H(AB) + H(CD) → H(ABCD) 계산. 블록 헤더의 Merkle Root와 비교. 이더리움 (Merkle Patricia Tree) 개선점: 머클 트리 + 패트리샤 트리 → 계정 상태 효율적 관리. 특징: 변경된 노드만 업데이트 → 저장 공간 절약. 이더리움 전체 상태를 단일 Merkle Root로 표현 (State Root). 실제 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import hashlib def sha256(data): return hashlib.sha256(data.encode()).hexdigest() class MerkleTree: def __init__(self, transactions): self.transactions = transactions self.tree = self.build_tree() def build_tree(self): tree = [ [tx for tx in self.transactions] ] layer = 0 while len(tree[layer]) \u003e 1: layer_nodes = [] for i in range(0, len(tree[layer]), 2): left = tree[layer][i] right = tree[layer][i+1] if i+1 \u003c len(tree[layer]) else left combined = sha256(left + right) layer_nodes.append(combined) tree.append(layer_nodes) layer += 1 return tree def get_root(self): return self.tree[-1][0] # 사용 예시 transactions = ['tx1', 'tx2', 'tx3', 'tx4'] merkle_tree = MerkleTree(transactions) print(\"Merkle Root:\", merkle_tree.get_root()) 출력:\n1 Merkle Root: 1a3d4f... (64자리 해시 값) 다른 자료구조와의 비교 구조 목적 장점 단점 머클 트리 데이터 무결성 검증 변조 탐지, 부분 검증 가능 삭제/수정 복잡 해시 테이블 빠른 데이터 조회 O(1) 접근 속도 충돌 처리 필요 B-Tree 대용량 데이터 관리 균형 잡힌 트리 구조 무결성 검증 미지원 참고 및 출처 ","wordCount":"483","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-11T08:04:00Z","dateModified":"2024-10-11T08:04:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/>Data Structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/>Non-Primitive data structure</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/>Hash</a></div><h1 class="post-title entry-hint-parent">Merkle Tree</h1><div class=post-meta><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;483 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structure%20and%20Algorithm/Data%20Structure/Non-Primitive/Non-Linear/Tree/Hash/Merkle-Tree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#merkle-tree>Merkle Tree</a><ul><li><a href=#계층적-해시-구조>계층적 해시 구조</a></li><li><a href=#데이터-변조-검출-메커니즘>데이터 변조 검출 메커니즘</a></li><li><a href=#핵심-장점>핵심 장점</a></li><li><a href=#한계-및-개선-방향>한계 및 개선 방향</a></li><li><a href=#블록체인에서의-활용>블록체인에서의 활용</a></li><li><a href=#실제-구현-예시>실제 구현 예시</a></li><li><a href=#다른-자료구조와의-비교>다른 자료구조와의 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=merkle-tree>Merkle Tree<a hidden class=anchor aria-hidden=true href=#merkle-tree>#</a></h2><p>머클 트리(Merkle Tree)는 <strong>암호화된 해시 값</strong>을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.<br>블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, <strong>데이터 변조 탐지</strong>와 <strong>검증 효율성</strong>이 핵심 강점이다.</p><p>머클 트리는 <strong>분산 환경의 신뢰 문제</strong>를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.<br>데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.</p><h3 id=계층적-해시-구조>계층적 해시 구조<a hidden class=anchor aria-hidden=true href=#계층적-해시-구조>#</a></h3><ul><li><strong>Leaf Node</strong>: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256).</li><li><strong>Non-Leaf Node</strong>: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화.</li><li><strong>Merkle Root</strong>: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표.</li></ul><p><strong>예시</strong>: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        H(ABCD)  
</span></span><span class=line><span class=cl>       /      \  
</span></span><span class=line><span class=cl>   H(AB)      H(CD)  
</span></span><span class=line><span class=cl>  /    \     /    \  
</span></span><span class=line><span class=cl>H(A) H(B) H(C) H(D)
</span></span></code></pre></td></tr></table></div></div><h3 id=데이터-변조-검출-메커니즘>데이터 변조 검출 메커니즘<a hidden class=anchor aria-hidden=true href=#데이터-변조-검출-메커니즘>#</a></h3><ul><li><strong>특징</strong>: 단일 데이터 변경 → 모든 상위 노드 해시 값 변경 → Merkle Root 불일치.</li><li><strong>예시</strong>: 트랜잭션 B가 B&rsquo;로 변조되면 H(B) → H(B&rsquo;), H(AB) → H(AB&rsquo;), H(ABCD) → H(AB&rsquo;CD).</li></ul><h3 id=핵심-장점>핵심 장점<a hidden class=anchor aria-hidden=true href=#핵심-장점>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>빠른 검증</strong></td><td>특정 데이터 검증 시 전체 데이터 불필요 (O(log N) 시간 복잡도)</td></tr><tr><td><strong>공간 효율</strong></td><td>Merkle Root(32바이트)만으로 전체 데이터 무결성 확인 가능</td></tr><tr><td><strong>분산 시스템 적합</strong></td><td>부분적 데이터 전송에서도 무결성 검증 가능 (예: BitTorrent)</td></tr></tbody></table><h3 id=한계-및-개선-방향>한계 및 개선 방향<a hidden class=anchor aria-hidden=true href=#한계-및-개선-방향>#</a></h3><ul><li><strong>거대 데이터셋</strong>: 트리 높이 증가 → 검증 경로 길어짐.</li><li><strong>동적 업데이트</strong>: 기존 구조는 삭제/수정에 비효율적 → <strong>Merkle Patricia Trie</strong>로 해결.</li><li><strong>표준화 부족</strong>: 구현마다 해시 함수, 트리 구조 차이 (예: Bitcoin-SHA256, Ethereum-Keccak).</li></ul><h3 id=블록체인에서의-활용>블록체인에서의 활용<a hidden class=anchor aria-hidden=true href=#블록체인에서의-활용>#</a></h3><h4 id=비트코인>비트코인<a hidden class=anchor aria-hidden=true href=#비트코인>#</a></h4><ul><li><strong>역할</strong>: 블록 헤더에 Merkle Root 저장 → 트랜잭션 집합의 무결성 보장.</li><li><strong>SPV(Simplified Payment Verification)</strong>: 라이트 노드가 풀 노드 없이 특정 트랜잭션 검증 가능.</li></ul><p><strong>검증 프로세스</strong>:</p><ol><li>라이트 노드가 풀 노드에 <strong>Merkle Proof</strong> 요청 (H(C), H(D), H(AB)).</li><li>H(C) + H(D) → H(CD), H(AB) + H(CD) → H(ABCD) 계산.</li><li>블록 헤더의 Merkle Root와 비교.</li></ol><h4 id=이더리움-merkle-patricia-tree>이더리움 (Merkle Patricia Tree)<a hidden class=anchor aria-hidden=true href=#이더리움-merkle-patricia-tree>#</a></h4><ul><li><strong>개선점</strong>: 머클 트리 + 패트리샤 트리 → 계정 상태 효율적 관리.</li><li><strong>특징</strong>:<ul><li>변경된 노드만 업데이트 → 저장 공간 절약.</li><li>이더리움 전체 상태를 단일 Merkle Root로 표현 (State Root).</li></ul></li></ul><h3 id=실제-구현-예시>실제 구현 예시<a hidden class=anchor aria-hidden=true href=#실제-구현-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>hashlib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>sha256</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>hashlib</span><span class=o>.</span><span class=n>sha256</span><span class=p>(</span><span class=n>data</span><span class=o>.</span><span class=n>encode</span><span class=p>())</span><span class=o>.</span><span class=n>hexdigest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MerkleTree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transactions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transactions</span> <span class=o>=</span> <span class=n>transactions</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tree</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>build_tree</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>build_tree</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>tree</span> <span class=o>=</span> <span class=p>[</span> <span class=p>[</span><span class=n>tx</span> <span class=k>for</span> <span class=n>tx</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>transactions</span><span class=p>]</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>layer</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>tree</span><span class=p>[</span><span class=n>layer</span><span class=p>])</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>layer_nodes</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>tree</span><span class=p>[</span><span class=n>layer</span><span class=p>]),</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>=</span> <span class=n>tree</span><span class=p>[</span><span class=n>layer</span><span class=p>][</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>=</span> <span class=n>tree</span><span class=p>[</span><span class=n>layer</span><span class=p>][</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>tree</span><span class=p>[</span><span class=n>layer</span><span class=p>])</span> <span class=k>else</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>                <span class=n>combined</span> <span class=o>=</span> <span class=n>sha256</span><span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>layer_nodes</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>combined</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>tree</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>layer_nodes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>layer</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_root</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>tree</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>transactions</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;tx1&#39;</span><span class=p>,</span> <span class=s1>&#39;tx2&#39;</span><span class=p>,</span> <span class=s1>&#39;tx3&#39;</span><span class=p>,</span> <span class=s1>&#39;tx4&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>merkle_tree</span> <span class=o>=</span> <span class=n>MerkleTree</span><span class=p>(</span><span class=n>transactions</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Merkle Root:&#34;</span><span class=p>,</span> <span class=n>merkle_tree</span><span class=o>.</span><span class=n>get_root</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>출력</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Merkle Root: 1a3d4f... (64자리 해시 값)
</span></span></code></pre></td></tr></table></div></div><h3 id=다른-자료구조와의-비교>다른 자료구조와의 비교<a hidden class=anchor aria-hidden=true href=#다른-자료구조와의-비교>#</a></h3><table><thead><tr><th><strong>구조</strong></th><th><strong>목적</strong></th><th><strong>장점</strong></th><th><strong>단점</strong></th></tr></thead><tbody><tr><td><strong>머클 트리</strong></td><td>데이터 무결성 검증</td><td>변조 탐지, 부분 검증 가능</td><td>삭제/수정 복잡</td></tr><tr><td><strong>해시 테이블</strong></td><td>빠른 데이터 조회</td><td>O(1) 접근 속도</td><td>충돌 처리 필요</td></tr><tr><td><strong>B-Tree</strong></td><td>대용량 데이터 관리</td><td>균형 잡힌 트리 구조</td><td>무결성 검증 미지원</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/data-structure/>Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-primitive-data-structure/>Non-Primitive-Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-linear-data-structure/>Non-Linear-Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/hash/>Hash</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/><span class=title>« Prev</span><br><span>K-d Tree</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/quad-tree/><span class=title>Next »</span><br><span>Quad Tree</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>