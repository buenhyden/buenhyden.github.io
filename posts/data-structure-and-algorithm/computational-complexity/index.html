<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>계산 복잡도 (Computational Complexity) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Time-Complexity,Space-Complexity,Computational-Complexity"><meta name=description content="알고리즘의 효율성을 분석하고 문제의 난이도를 분류하는 이론"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="계산 복잡도 (Computational Complexity)"><meta property="og:description" content="알고리즘의 효율성을 분석하고 문제의 난이도를 분류하는 이론"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="계산 복잡도 (Computational Complexity)"><meta name=twitter:description content="알고리즘의 효율성을 분석하고 문제의 난이도를 분류하는 이론"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/"},{"@type":"ListItem","position":3,"name":"계산 복잡도 (Computational Complexity)","item":"https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structure-and-algorithm/>Data Structure and Algorithm</a></div><h1>계산 복잡도 (Computational Complexity)</h1><div class=post-description>알고리즘의 효율성을 분석하고 문제의 난이도를 분류하는 이론</div></header><div class=post-content><h2 id=계산-복잡도-computational-complexity>계산 복잡도 (Computational Complexity)<a hidden class=anchor aria-hidden=true href=#계산-복잡도-computational-complexity>#</a></h2><p>계산 복잡도 이론은 컴퓨터 과학의 중요한 분야로, 알고리즘과 문제의 효율성을 분석하고 분류하는 데 사용된다. 이는 알고리즘이나 문제를 해결하는 데 필요한 자원의 양을 측정하는 것으로, 주로 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 나누어 분석한다.</p><p>계산 복잡도 이론은 다음과 같은 주요 특징을 가진다:</p><ol><li>문제 해결에 필요한 자원의 양을 정량화한다.</li><li>알고리즘의 효율성을 평가하고 비교한다.</li><li>문제를 복잡도 클래스로 분류한다.</li><li>주로 최악의 경우 시나리오를 고려한다.</li></ol><h3 id=시간복잡도와-공간복잡도-time-complexity-and-space-complexity>시간복잡도와 공간복잡도 (Time Complexity and Space Complexity)<a hidden class=anchor aria-hidden=true href=#시간복잡도와-공간복잡도-time-complexity-and-space-complexity>#</a></h3><p>시간복잡도와 공간복잡도는 알고리즘의 효율성을 평가하는 중요한 개념으로, 이를 이해하고 최적화하는 것은 효율적인 알고리즘 설계의 핵심이다. 알고리즘의 효율성을 개선하기 위해서는 다양한 알고리즘 설계 기법을 이해하고 적용할 필요가 있으며, 이를 통해 더 나은 알고리즘을 개발할 수 있다.</p><h3 id=시간복잡도-time-complexity>시간복잡도 (Time Complexity)<a hidden class=anchor aria-hidden=true href=#시간복잡도-time-complexity>#</a></h3><p>시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 측정한다:</p><ul><li>입력 크기에 따른 연산 횟수로 표현된다.</li><li>주로 빅오(Big O) 표기법을 사용합니다.</li><li>예: O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)<br>시간 복잡도는 알고리즘의 실행 속도를 나타내며, 주로 반복문의 수행 횟수에 큰 영향을 받는다.</li></ul><h4 id=주요-종류-big-o-표기법>주요 종류 (Big O 표기법)<a hidden class=anchor aria-hidden=true href=#주요-종류-big-o-표기법>#</a></h4><h5 id=o1---상수-시간>O(1) - 상수 시간<a hidden class=anchor aria-hidden=true href=#o1---상수-시간>#</a></h5><ul><li>입력 크기와 관계없이 항상 같은 시간이 걸린다.</li><li>가장 효율적인 시간복잡도</li><li>예: 배열의 첫 번째 요소 접근, 스택의 push/pop 연산</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>constant_time</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;배열의 첫 번째 요소를 반환하는 함수&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>if</span> <span class=n>arr</span> <span class=k>else</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=olog-n---로그-시간>O(log n) - 로그 시간<a hidden class=anchor aria-hidden=true href=#olog-n---로그-시간>#</a></h5><ul><li>입력 크기가 증가할 때마다 처리 시간이 로그만큼만 증가</li><li>매우 효율적이며, 큰 데이터셋에서도 좋은 성능을 보인다.</li><li>예: 이진 탐색, 균형 이진 트리에서의 검색</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;정렬된 배열에서 이진 검색 수행&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=on---선형-시간>O(n) - 선형 시간<a hidden class=anchor aria-hidden=true href=#on---선형-시간>#</a></h5><ul><li>입력 크기에 비례하여 실행 시간이 증가합니다.</li><li>적절한 효율성을 가지며, 많은 기본 알고리즘의 시간복잡도.</li><li>예: 배열의 모든 요소 순회, 선형 탐색</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_time</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;배열의 모든 요소를 순회하며 합계를 계산&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>:</span>  <span class=c1># n번 반복</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=n>num</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=on-log-n---선형-로그-시간>O(n Log n) - 선형 로그 시간<a hidden class=anchor aria-hidden=true href=#on-log-n---선형-로그-시간>#</a></h5><ul><li>선형-로그 시간으로, 효율적인 정렬 알고리즘의 시간복잡도.</li><li>대규모 데이터 정렬에 적합</li><li>예: 퀵 정렬, 병합 정렬</li></ul><h5 id=on2---이차-시간>O(n^2) - 이차 시간<a hidden class=anchor aria-hidden=true href=#on2---이차-시간>#</a></h5><ul><li>입력 크기의 제곱에 비례하여 실행 시간이 증가한다.</li><li>작은 입력에는 괜찮지만, 큰 데이터셋에서는 비효율적</li><li>예: 버블 정렬, 선택 정렬</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quadratic_time</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;모든 가능한 숫자 쌍의 합을 계산&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>  <span class=c1># n번 반복</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>  <span class=c1># 각각에 대해 n번 반복</span>
</span></span><span class=line><span class=cl>            <span class=n>results</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>results</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=o2n---지수-시간>O(2^n) - 지수 시간<a hidden class=anchor aria-hidden=true href=#o2n---지수-시간>#</a></h5><ul><li>가장 비효율적인 시간복잡도</li><li>입력이 하나 증가할 때마다 실행 시간이 두 배로 증가하는 알고리즘</li><li>재귀적인 문제나 백트래킹 문제에서 발생</li><li>예시: 피보나치 수열을 계산하는 단순 재귀 알고리즘.</li></ul><h5 id=on---팩토리얼-시간-복잡도>O(n!) - 팩토리얼 시간 복잡도<a hidden class=anchor aria-hidden=true href=#on---팩토리얼-시간-복잡도>#</a></h5><ul><li>매우 비효율적인 시간복잡도</li><li>데이터의 모든 가능한 순열을 확인해야 하는 경우</li><li>예시: 순열을 전부 확인하는 완전 탐색 알고리즘</li></ul><h3 id=공간복잡도-space-complexity>공간복잡도 (Space Complexity)<a hidden class=anchor aria-hidden=true href=#공간복잡도-space-complexity>#</a></h3><p>공간 복잡도는 알고리즘이 실행되는 동안 사용하는 메모리의 양을 측정한다:</p><ul><li>고정 공간: 입력 크기와 무관한 공간 (변수, 상수 등)</li><li>가변 공간: 입력 크기에 따라 변하는 공간 (동적 할당 메모리, 재귀 호출 스택 등)<br>공간 복잡도는 S(P) = c + Sp(n) 형태로 표현되며, c는 고정 공간, Sp(n)은 가변 공간을 나타낸다.</li></ul><h4 id=주요-종류>주요 종류<a hidden class=anchor aria-hidden=true href=#주요-종류>#</a></h4><h5 id=o1---상수-공간>O(1) - 상수 공간<a hidden class=anchor aria-hidden=true href=#o1---상수-공간>#</a></h5><ul><li>입력 크기와 관계없이 일정한 추가 공간만 사용한다.</li><li>메모리 효율이 가장 좋다.</li><li>예시: 간단한 변수 몇 개만 사용하는 경우</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>space_constant</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;입력 크기와 관계없이 일정한 추가 공간만 사용&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>+=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=on---선형-공간>O(n) - 선형 공간<a hidden class=anchor aria-hidden=true href=#on---선형-공간>#</a></h5><ul><li>입력 크기에 비례하는 추가 공간이 필요하다.</li><li>많은 알고리즘의 일반적인 공간복잡도.</li><li>예시: 입력 크기만큼의 새로운 배열을 생성하는 경우</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>space_linear</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;입력 크기에 비례하는 추가 공간 사용&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 크기 n의 새로운 배열 생성</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>results</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=on2---이차-공간>O(n^2) - 이차 공간<a hidden class=anchor aria-hidden=true href=#on2---이차-공간>#</a></h5><ul><li>입력 크기의 제곱에 비례하는 공간이 필요.</li><li>큰 입력에 대해 많은 메모리가 필요.</li><li>예시: n×n 크기의 2차원 행렬을 생성하는 경우</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8>8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>space_quadratic</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;2차원 행렬 생성&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>matrix</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>row</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>matrix</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>matrix</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=시간-복잡도와-공간-복잡도의-관계>시간 복잡도와 공간 복잡도의 관계<a hidden class=anchor aria-hidden=true href=#시간-복잡도와-공간-복잡도의-관계>#</a></h3><p>시간 복잡도와 공간 복잡도는 종종 상호 관련이 있지만, 항상 반비례 관계에 있는 것은 아니다:</p><ol><li>일반적으로 시간을 절약하기 위해 더 많은 공간을 사용하거나, 공간을 절약하기 위해 더 많은 시간을 소비하는 경향이 있다.</li><li>현대 컴퓨팅에서는 메모리가 상대적으로 풍부해져 시간 복잡도에 더 중점을 두는 경향이 있다.</li></ol><h3 id=계산-복잡도의-중요성>계산 복잡도의 중요성<a hidden class=anchor aria-hidden=true href=#계산-복잡도의-중요성>#</a></h3><ol><li>알고리즘 효율성 평가: 다양한 알고리즘의 성능을 객관적으로 비교할 수 있다.</li><li>자원 사용 예측: 대규모 데이터 처리 시 필요한 시간과 메모리를 예측할 수 있다.</li><li>알고리즘 설계: 효율적인 알고리즘을 개발하는 데 지침을 제공한다.</li><li>문제 분류: NP-완전 문제와 같은 복잡도 클래스를 통해 문제의 난이도를 분류한다.</li></ol><h3 id=최적화하는-방법>최적화하는 방법<a hidden class=anchor aria-hidden=true href=#최적화하는-방법>#</a></h3><p>시간 복잡도와 공간 복잡도 사이에는 종종 트레이드오프 관계가 있으므로, 상황에 따라 적절한 균형을 찾는 것이 중요하다. 또한 실제 성능 측정을 통해 최적화의 효과를 확인하고, 필요한 수준의 성능과 자원 사용을 고려하여 균형을 맞추는 것이 중요하다.</p><blockquote><p>트레이드 오프(Trade-off)<br>두 개의 대안이 있을 때, 어느 하나를 선택하면 다른 하나의 성과가 줄어드는 상황.<br>즉, 한 쪽을 추구하면 다른 쪽을 희생해야 하는 관계를 의미한다.</p></blockquote><p>시간 복잡도와 공간 복잡도를 최적화하는 방법은 다음과 같다:</p><h4 id=시간-복잡도-최적화>시간 복잡도 최적화<a hidden class=anchor aria-hidden=true href=#시간-복잡도-최적화>#</a></h4><ol><li><p>효율적인 알고리즘 선택</p><ul><li>정렬이 필요한 경우 O(n log n) 시간 복잡도를 가진 퀵 정렬이나 병합 정렬 사용</li><li>탐색 시 이진 탐색 등의 O(log n) 알고리즘 활용</li></ul></li><li><p>반복문 최적화</p><ul><li>중첩 반복문 줄이기</li><li>불필요한 반복 제거</li></ul></li><li><p>적절한 자료구조 사용</p><ul><li>해시 테이블을 이용한 O(1) 시간 복잡도의 검색 구현</li><li>균형 이진 트리를 이용한 O(log n) 시간 복잡도의 삽입/삭제/검색 구현</li></ul></li><li><p>캐싱과 메모이제이션</p><ul><li>이미 계산된 결과를 저장하여 재사용</li></ul></li><li><p>동적 프로그래밍</p><ul><li>큰 문제를 작은 부분 문제로 나누어 해결</li></ul></li></ol><h4 id=공간-복잡도-최적화>공간 복잡도 최적화<a hidden class=anchor aria-hidden=true href=#공간-복잡도-최적화>#</a></h4><ol><li><p>인플레이스(In-place) 알고리즘 사용</p><ul><li>추가 메모리 사용을 최소화하는 알고리즘 선택</li></ul></li><li><p>메모리 재사용</p><ul><li>불필요한 변수 제거 및 변수 재사용</li></ul></li><li><p>적절한 자료구조 선택</p><ul><li>상황에 맞는 효율적인 자료구조 사용 (예: 연결 리스트 대신 배열)</li></ul></li><li><p>재귀 대신 반복문 사용</p><ul><li>재귀 호출로 인한 스택 메모리 사용 줄이기</li></ul></li><li><p>비트 연산 활용</p><ul><li>정수형 변수를 비트 마스크로 활용하여 메모리 사용 줄이기</li></ul></li><li><p>메모리 풀링</p><ul><li>객체 재사용을 통한 메모리 할당/해제 최소화</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비결정성 (Non-determinism)</h2></header><div class=entry-content><p>비결정성 (Non-determinism) 알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성
특징 다중 선택: 각 단계에서 여러 가능한 다음 단계 중 하나를 임의로 선택할 수 있다. 병렬 처리: 여러 가능한 경로를 동시에 탐색할 수 있는 개념적 모델을 제공한다. 결정성과의 차이: 결정성 알고리즘은 각 단계에서 다음 단계가 유일하게 결정되는 반면, 비결정성 알고리즘은 그렇지 않다. 비결정성 알고리즘 비결정성 알고리즘은 다음과 같은 특징을 가진다.
실행 경로의 다양성: 동일한 입력에 대해 여러 가능한 실행 경로가 존재한다. 비결정도: 각 단계에서 선택 가능한 다음 단계의 최대 개수를 비결정도라고 한다. 계산 능력: 비결정성 알고리즘과 결정성 알고리즘의 계산 능력은 동일하다. 응용 NP 문제: 비결정성 알고리즘으로 다항식 시간 내에 해결 가능한 결정형 문제를 NP 문제라고 한다. 유한 오토마타: 비결정적 유한 오토마타(NFA)는 탐색과 백트래킹 기법을 통해 모든 가능한 선택을 시도한다. 탐색 및 백트래킹 알고리즘: 비결정성은 여러 가지 경우를 순차적으로 계산하며 최적값을 갱신하는 백트래킹 기법의 모델로 사용된다. 장점 간결한 표현: 복잡한 언어나 시스템을 비결정성을 통해 더 간결하게 정의할 수 있다. 논증 간소화: 비결정성을 통해 공식적인 논증을 간단히 할 수 있다. 모델링 유연성: 실제 세계의 불확실성이나 복잡성을 모델링하는 데 유용하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import random import threading # 결정적인 함수의 예 def deterministic_sum(a, b): return a + b # 항상 같은 입력에 대해 같은 결과 # 비결정적인 함수의 예 def non_deterministic_choice(options): return random.choice(options) # 매번 다른 결과가 나올 수 있음 # 비결정적인 멀티스레딩 예제 shared_counter = 0 lock = threading.Lock() def increment_counter(): global shared_counter current = shared_counter # 의도적으로 경쟁 조건을 만듦 threading.Thread(target=lambda: None).start() shared_counter = current + 1 def run_concurrent_increments(n): threads = [] for _ in range(n): t = threading.Thread(target=increment_counter) threads.append(t) t.start() for t in threads: t.join() return shared_counter 다양한 상황에서 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-25 09:18:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;701 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비결정성 (Non-determinism)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Big O 표기법 (Big O notation)</h2></header><div class=entry-content><p>Big O 표기법 (Big O notation) 알고리즘의 성능과 효율성을 수학적으로 표현하는 방법으로, 주로 알고리즘이 처리해야 할 데이터의 크기(n)가 늘어날 때, 실행 시간이나 메모리 사용량이 어떻게 증가하는지를 나타낸다.
주요 특징:
최악의 경우 시나리오를 나타낸다. 상수와 계수를 무시한다. 가장 빠르게 증가하는 항만 고려한다. Big O 표기의 예시:
O(1) - 상수 시간
1 2 def get_first_element(arr): return arr[0] # 배열의 크기와 관계없이 항상 첫 번째 요소에 즉시 접근 이 함수는 배열의 크기와 관계없이 항상 동일한 시간이 걸린다.
입력 크기가 증가해도 실행 시간은 변하지 않습니다.
...</p></div><footer class=entry-footer><span title='2024-10-26 01:32:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Big O 표기법 (Big O notation)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>환원 가능성 (Reducibility)</h2></header><div class=entry-content><p>환원 가능성 (Reducibility) 환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.
더 구체적으로, 문제 A를 문제 B로 환원한다는 것은 문제 A를 해결하기 위해 문제 B의 해결 방법을 사용할 수 있다는 의미이다.
환원의 목적 문제의 난이도 비교: 환원을 통해 두 문제의 상대적 난이도를 비교할 수 있다. 알고리즘 재사용: 이미 해결 방법을 알고 있는 문제로 환원함으로써 새로운 문제를 해결할 수 있다. 복잡도 클래스 간의 관계 이해: 환원을 통해 다양한 복잡도 클래스 간의 관계를 파악할 수 있다. 환원의 예시 ‘2로 나누어 떨어지는지 확인하는 문제’를 ‘짝수인지 확인하는 문제’로 환원
...</p></div><footer class=entry-footer><span title='2024-10-24 12:03:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 환원 가능성 (Reducibility)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>튜링 기계 (Turing Machine)</h2></header><div class=entry-content><p>튜링 기계 (Turing Machine) 튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.
튜링 기계는 무한한 길이의 테이프, 읽기/쓰기 헤드, 그리고 상태 제어 장치로 구성된다.
튜링 기계는 다음과 같은 요소로 구성된다:
무한한 길이의 테이프: 계산에 필요한 데이터를 저장한다. 읽기/쓰기 헤드: 테이프의 심볼을 읽고 쓸 수 있다. 상태 레지스터: 현재 기계의 상태를 저장한다. 유한한 규칙 집합: 기계의 동작을 정의한다. 튜링 기계의 작동 원리:
...</p></div><footer class=entry-footer><span title='2024-10-24 10:07:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1047 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 튜링 기계 (Turing Machine)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>복잡도 클래스(Complexity Classes)</h2></header><div class=entry-content><p>복잡도 클래스(Complexity Classes) 복잡도 클래스(Complexity Classes)는 계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.
이는 문제를 해결하는 데 필요한 자원(시간 또는 공간)의 양에 따라 문제들을 분류한다.
Source: https://www.geeksforgeeks.org/types-of-complexity-classes-p-np-conp-np-hard-and-np-complete/
P (Polynomial Time) 결정론적 튜링 기계(Deterministic Turing Machine, DTM)로 다항 시간 내에 해결 가능한 문제들의 집합이다.
이 문제는 단순히 배열을 한 번 순회하면 되므로, 입력 크기에 비례하는 시간이 소요된다.
효율적으로 해결 가능한 문제들이 포함되며 대부분의 실용적인 문제들이 여기에 속한다.
예시:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:54:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;863 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 복잡도 클래스(Complexity Classes)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>