<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevOps-and-Infrastructure | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/devops-and-infrastructure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/devops-and-infrastructure/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/devops-and-infrastructure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/devops-and-infrastructure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="DevOps-and-Infrastructure"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="DevOps-and-Infrastructure"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>DevOps-and-Infrastructure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Snapshot vs. Delta</h2></header><div class=entry-content><p>Snapshot vs. Delta 스냅샷(Snapshot)과 델타(Delta)는 데이터 변화를 관리하는 두 가지 근본적인 접근 방식이다.
스냅샷: 특정 시점의 전체 시스템 상태를 저장한다. Git이 대표적으로, 각 커밋 시 프로젝트 전체의 파일 상태를 기록한다. 델타: 이전 버전 대비 변경된 부분만 저장한다. SVN, CVS 등 전통적 VCS에서 사용되며, 저장 공간 효율성이 장점이다. 이 두 방식은 저장 효율성, 성능, 복구 속도에서 차이를 보이며, 현대 시스템에서는 버전 관리 시스템(Git, SVN 등), 백업 솔루션, 데이터베이스 시스템 등 여러 컴퓨팅 분야에서 중요하게 사용된다. 또한, 두 방식의 혼합하여 사용하는 하이브리드 접근법(예: Git의 git gc를 통한 델타 압축)도 활용된다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:01:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Snapshot vs. Delta" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/git-fundamentals/snapshot-vs-delta/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VCS comparison</h2></header><div class=entry-content><p>VCS Comparison 버전 관리 시스템(VCS, Version Control System)은 소스 코드의 변경 이력을 추적하고 관리하는 도구이다. 이를 통해 개발자는 코드의 변경 사항을 기록하고, 이전 버전으로의 복원, 병합, 분기 등의 작업을 효율적으로 수행할 수 있다.
VCS는 중앙 집중형(Centralized)과 분산형(Distributed)으로 구분되며, 각각의 시스템은 특정한 아키텍처와 기능을 제공한다. 대표적인 VCS로는 RCS, CVS, SVN, Git, Mercurial 등이 있으며, 각 시스템은 개발 환경과 팀의 요구 사항에 따라 선택된다.
이 시스템들은 시간적으로 진화해왔으며, 각기 다른 아키텍처와 접근 방식을 가지고 있다. RCS는 1980년대 초에 등장한 가장 초기의 시스템으로 단일 파일의 버전 관리에 중점을 두었다. CVS는 RCS를 기반으로 하되 다중 파일과 다중 개발자 지원을 추가했다. SVN은 CVS의 제한사항을 극복하기 위해 개발되었으며, 디렉토리 구조 관리와 원자적 커밋을 도입했다.
...</p></div><footer class=entry-footer><span title='2024-09-28 04:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;<span>14 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to VCS comparison" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/git-fundamentals/vcs-comparison/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Submodule vs. Subtree</h2></header><div class=entry-content><p>Git Submodule vs. Subtree 깃 (Git) 은 소프트웨어 개발에서 널리 사용되는 분산형 버전 관리 시스템으로, 복잡한 프로젝트를 효율적으로 관리할 수 있게 해준다. 대규모 프로젝트에서는 종종 여러 저장소 (repository) 에 분산된 코드를 하나의 프로젝트 내에서 통합해야 하는 필요성이 생긴다. 이러한 필요성을 해결하기 위해 깃은 두 가지 주요 접근 방식인 서브모듈 (Submodule) 과 서브트리 (Subtree) 를 제공한다.
Git Submodule 과 Git Subtree 는 모두 하나의 Git 프로젝트 안에서 다른 Git 저장소를 하위 프로젝트처럼 관리하기 위한 방식이다. 하지만 방법은 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Git Submodule vs. Subtree" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/advanced-topics/submodule-vs-subtree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Conflict Resolution</h2></header><div class=entry-content><p>Conflict Resolution Git 충돌 해결 (Conflict Resolution) 은 협업 개발 과정에서 발생하는 코드 충돌을 식별하고 해결하는 프로세스로, 3-way merge 알고리즘을 기반으로 한다. 여러 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고, 해결하는 전략과 도구, 워크플로우를 포함한다. 주요 단계는 충돌 탐지 → 수동/자동 해결 → 검증으로 구성되며, 최근 AI 기반 자동화 도구들이 주목받고 있다.
핵심 개념 Git 충돌 해결 (Conflict Resolution) 은 두 개 이상의 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고 해결하는 과정이다. 충돌은 Git 이 변경사항을 자동으로 병합할 수 없을 때 발생하며, 개발자가 수동으로 어떤 변경사항을 유지할지 결정해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:57:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Conflict Resolution" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/git-fundamentals/conflict-resolution/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VMware</h2></header><div class=entry-content><p>VMware 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구
회사 및 라이선스:
VMware, Inc.에서 개발 대부분 유료 소프트웨어이며, 일부 제품(VMware Workstation Player)만 개인용으로 무료 제공 성능 및 기능:
일반적으로 성능이 우수하며, 최적화된 자원 관리 제공 고급 기능(스냅샷, 클론, 3D 가속, 암호화된 VM 등) 지원 vSphere를 통한 고급 네트워크 기능 제공 호환성:
Windows, macOS (Fusion), Linux 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
직관적이고 사용하기 쉬운 인터페이스 제공 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 12:55:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to VMware" href=https://buenhyden.github.io/posts/software-development/system-components/platform--execution-infrastructure/virtualization/vm-platforms/vmware/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Envoy</h2></header><div class=entry-content><p>Envoy Envoy는 Kubernetes 환경에서 널리 사용되는 고성능 프록시 서버.
Envoy는 C++로 작성된 고성능 분산 프록시로, 대규모 마이크로서비스 아키텍처를 위해 설계되었다.
주요 특징 다양한 프로토콜 지원: HTTP, TCP, gRPC 등을 지원한다. 고급 로드 밸런싱: 다양한 로드 밸런싱 알고리즘을 제공한다. 동적 구성: 실행 중에 설정을 변경할 수 있는 동적 구성을 지원한다. 관찰 가능성: 상세한 메트릭과 로그를 제공하여 시스템 모니터링을 용이하게 한다. Kubernetes에서의 Envoy 활용 Kubernetes 환경에서 Envoy는 주로 다음과 같은 방식으로 활용된다:
...</p></div><footer class=entry-footer><span title='2024-11-11 11:03:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Envoy" href=https://buenhyden.github.io/posts/software-development/system-components/access--network-entry/proxy/reverse-proxy/implementations/envoy/envoy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VirtualBox</h2></header><div class=entry-content><p>Virtual Box 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구.
회사 및 라이선스:
Oracle Corporation에서 개발 오픈 소스 소프트웨어로, 기본 버전은 무료로 사용 가능 성능 및 기능:
VMware에 비해 성능이 다소 떨어질 수 있음 기본적인 가상화 기능(스냅샷, 클론, 3D 가속 등) 제공 일부 고급 기능은 확장 팩 설치 필요 호환성:
Windows, macOS, Linux, Solaris 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
비교적 간단한 인터페이스 제공, 일부 기능은 탐색이 어려울 수 있음 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 04:54:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to VirtualBox" href=https://buenhyden.github.io/posts/software-development/system-components/platform--execution-infrastructure/virtualization/vm-platforms/virtualbox/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P2P and Hybrid VCS</h2></header><div class=entry-content><p>P2P And Hybrid VCS P2P VCS 는 Git 과 같은 분산형 버전 관리 시스템의 진화된 형태로 노드 간 직접 통신으로 센서리스 아키텍처를 구현하며, 하이브리드 VCS 는 메타데이터 관리를 중앙서버에서 처리한다. 주요 구성 요소로 DHT(분산 해시 테이블), 암호화 검증 계층, 자동 동기화 엔진이 포함된다. 도전 과제로 네트워크 지연 시간 최적화와 대규모 분산 트랜잭션 관리가 존재한다.
Radicle 과 같은 솔루션은 분산 네트워크에서 Git 기반 협업을, Perforce Helix 와 같은 시스템은 하이브리드 접근 방식을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-26 06:17:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;<span>24 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to P2P and Hybrid VCS" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/git-fundamentals/p2p-and-hybrid-vcs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitOps and IaC</h2></header><div class=entry-content><p>GitOps and IaC GitOps 와 IaC(Infrastructure as Code) 는 현대 DevOps 환경에서 인프라스트럭처 관리를 자동화하고 코드화하는 핵심 방법론이다.
GitOps 는 Git 을 단일 진실의 소스 (Single Source of Truth) 로 활용하여 애플리케이션과 인프라의 배포를 자동화하는 접근 방식이다. IaC 는 인프라를 코드로 정의하여 자동화된 프로비저닝과 관리를 가능하게 한다. 이 두 가지 개념은 클라우드 네이티브 환경에서 자동화된 배포 파이프라인, 선언적 인프라 정의, 버전 관리 및 감사 기능을 통해 인프라와 애플리케이션 관리를 혁신하고 있다. 이 두 방법론을 결합하여 조직은 인프라스트럭처 프로비저닝, 애플리케이션 배포, 구성 관리를 자동화하고 일관성 있게 유지하며, 변경 사항을 추적하고 필요시 롤백할 수 있다.
ArgoCD 와 FluxCD 는 Kubernetes 환경에서 GitOps 를 구현하는 주요 도구이며, Terraform 은 다양한 클라우드 환경에서 IaC 를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:15:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;<span>20 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to GitOps and IaC" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/advanced-topics/gitops-and-iac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CI/CD Principles</h2></header><div class=entry-content><p>CI/CD Principles CI/CD 원칙은 지속적 통합 (CI) 과 지속적 배포 (CD) 를 기반으로 코드 변경 사항을 빠르게 통합, 테스트, 배포하는 자동화된 프로세스를 강조한다.
CI/CD 는 DevOps 문화의 중심에 있으며, 개발팀이 더 자주, 더 안정적으로 코드를 통합하고 배포할 수 있게 해준다.
핵심 개념 CI/CD 는 두 가지 연관된 개념의 조합이다:
지속적 통합 (Continuous Integration, CI): 개발자들이 코드 변경사항을 중앙 리포지토리에 자주 통합하는 개발 방식으로, 보통 하루에 여러 번 이루어진다. 각 통합은 자동화된 빌드와 테스트로 검증되어 통합 문제를 빠르게 식별한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:24:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;<span>31 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to CI/CD Principles" href=https://buenhyden.github.io/posts/software-development/engineering-operations/devops--ci-cd/ci-cd-fundamentals/ci-cd-principles/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/devops-and-infrastructure/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/devops-and-infrastructure/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>