<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevOps-and-Infrastructure | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/devops-and-infrastructure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/devops-and-infrastructure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/devops-and-infrastructure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/devops-and-infrastructure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="DevOps-and-Infrastructure"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="DevOps-and-Infrastructure"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>DevOps-and-Infrastructure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Open Source Contribution</h2></header><div class=entry-content><p>Open Source Contribution 오픈소스 기여 (Open Source Contribution) 는 공개된 소프트웨어 프로젝트에 개인이나 조직이 코드, 문서, 테스트, 버그 리포트 등을 통해 참여하는 활동이다. 이는 버전 관리 시스템 (특히 Git) 을 중심으로 이루어지며, Fork-Clone- 수정 -Pull Request 로 이어지는 표준화된 워크플로우를 통해 진행된다. 오픈소스 기여는 소프트웨어 개발 생태계의 지속 가능성을 유지하고, 개발자 간 지식 공유와 협업을 촉진하며, 개인 개발자에게는 실무 경험과 평판을 쌓을 기회를 제공한다.
핵심 개념 오픈소스 기여는 공개된 소프트웨어 프로젝트에 개발자가 자발적으로 참여하여 코드, 문서, 디자인, 테스트 등을 통해 가치를 더하는 활동이다.
...</p></div><footer class=entry-footer><span title='2024-10-01 06:07:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Open Source Contribution" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/collaboration/open-source-contribution/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Large-scale Management</h2></header><div class=entry-content><p>Large-scale Management 대규모 버전 관리 시스템 (Version Control Systems) 의 엔터프라이즈 활용은 수백 명의 개발자와 수십 기가바이트 이상의 코드베이스를 효율적으로 관리하기 위한 전략과 기술을 포함한다. Git 과 같은 분산 버전 관리 시스템 (DVCS) 은 유연성과 확장성을 제공하지만, 대규모 환경에서는 성능 최적화, 브랜칭 전략, 접근 제어, 코드 소유권 관리 등 추가적인 고려사항이 필요하다. 이를 위해 Partial Clone, Shallow Clone, Submodule, CODEOWNERS 파일 등의 기능이 활용되며, 팀 규모에 따른 브랜칭 전략도 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 06:20:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Large-scale Management" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/enterprise-usage/large-scale-management/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MonoRepo vs. MultiRepo</h2></header><div class=entry-content><p>MonoRepo vs. MultiRepo 모노레포 (Monorepo) 와 멀티레포 (Multirepo) 는 소프트웨어 개발에서 코드베이스를 관리하는 대표적인 두 가지 전략이다. MonoRepo는 여러 프로젝트를 하나의 저장소에서 관리하는 방식으로, 코드 공유와 일관된 개발 환경을 제공한다. 반면, MultiRepo는 각 프로젝트를 별도의 저장소에서 관리하여 독립성과 유연성을 강조한다.
이 두 접근 방식은 코드 공유, 종속성 관리, 빌드 시스템, 팀 협업, 확장성 등의 측면에서 서로 다른 장단점을 가지고 있다. 프로젝트의 규모, 팀 구조, 회사 문화, 기술 스택 등 다양한 요소에 따라 적합한 방식이 달라질 수 있으며, 최근에는 두 방식의 장점을 결합한 하이브리드 접근법이나 각 방식의 단점을 보완하는 도구들도 등장하고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-30 06:18:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MonoRepo vs. MultiRepo" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/enterprise-usage/monorepo-vs-multirepo/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/monitoring-and-observability/observability-vs-monitoring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Metric</h2></header><div class=entry-content><p>Metric Metric는 시스템의 상태와 성능을 수치화하여 측정하는 중요한 관측 도구이다.
Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값이다.
예를 들어, 웹 서버의 응답 시간, CPU 사용률, 메모리 사용량 등이 Metric가 될 수 있다.
장점 효율적인 저장: 숫자 데이터는 저장 공간을 적게 차지한다. 빠른 쿼리: 시계열 데이터베이스를 사용하여 빠른 검색과 분석이 가능하다. 장기 추세 분석: 오랜 기간 동안의 데이터를 저장하고 분석할 수 있다. 시각화 용이성: 그래프나 대시보드로 쉽게 표현할 수 있다. 단점 초기 설정에 시간과 노력이 필요하다 너무 많은 Metric는 오히려 혼란을 줄 수 있다 저장 공간과 처리 리소스가 필요하다 Metric의 중요성 성능 모니터링: 시스템의 전반적인 성능을 지속적으로 모니터링할 수 있다. 문제 감지: 비정상적인 패턴이나 임계값 초과를 빠르게 감지할 수 있다. 용량 계획: 리소스 사용량 추세를 분석하여 미래의 용량을 계획할 수 있다. 최적화: 성능 병목 현상을 식별하고 최적화할 수 있는 기회를 제공한다. Metric의 구성 요소 일반적인 Metric는 다음 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metric" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/monitoring-and-observability/fundamentals/three-pillars-of-observability/metrics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Trace</h2></header><div class=entry-content><p>Trace Trace는 분산 시스템에서 요청의 흐름을 추적하고 시각화하는 데 사용된다.
Trace는 분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것이다.
각 Trace는 하나 이상의 span으로 구성되며, 첫 번째 span은 root span이라고 한다.
Trace의 목적 분산 시스템에서의 요청 흐름 이해 성능 병목 지점 식별 서비스 간 의존성 파악 오류 및 지연의 근본 원인 분석 Trace의 구성 요소 트레이스는 다음과 같은 구성 요소들로 이루어진다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 트레이스 시작 Span rootSpan = tracer.spanBuilder("checkout-process") .setSpanKind(SpanKind.SERVER) .startSpan(); try (Scope scope = rootSpan.makeCurrent()) { // 자식 스팬 생성 Span paymentSpan = tracer.spanBuilder("process-payment") .setParent(Context.current().with(rootSpan)) .startSpan(); try { processPayment(); paymentSpan.setStatus(StatusCode.OK); } catch (Exception e) { paymentSpan.setStatus(StatusCode.ERROR, e.getMessage()); throw e; } finally { paymentSpan.end(); } } finally { rootSpan.end(); } 트레이스 구성의 핵심 요소들:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trace" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/monitoring-and-observability/fundamentals/three-pillars-of-observability/tracing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log</h2></header><div class=entry-content><p>Log Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.
문제가 발생했을 때 무슨 일이 있었는지 추적할 수 있게 해주며, 시스템의 동작을 이해하는 데 필수적인 정보를 제공한다.
로그 구조를 설계할 때는 다음과 같은 원칙들을 고려해야 한다:
일관성(Consistency): 모든 로그 항목은 동일한 구조와 형식을 따라야 한다. 이는 로그 파싱과 분석을 용이하게 만든다. 검색 가능성(Searchability): 주요 필드들은 쉽게 검색하고 필터링할 수 있는 형태여야 한다. 확장성(Extensibility): 새로운 정보를 추가할 필요가 생겼을 때 기존 구조를 해치지 않고 확장할 수 있어야 한다. 상세도 조절(Verbosity Control): 로그 레벨을 통해 필요한 상세도를 조절할 수 있어야 한다. 로그 구조를 효과적으로 설계하면 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/monitoring-and-observability/fundamentals/three-pillars-of-observability/logging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shadow Deployment</h2></header><div class=entry-content><p>Shadow Deployment 실제 트래픽을 복제해 신규 환경에 적용, 영향 분석 미러링된 트래픽으로 실환경 테스트 로그 분석을 통한 기능 안정성 검증 트래픽 복제 시 개인정보 마스킹 이슈 처리 Shadow Deployment 는 소프트웨어 배포 전략 중 하나로, 새로운 버전의 애플리케이션을 기존 버전과 병행하여 실행하되 사용자에게는 영향을 주지 않는 방식이다.
Shadow Deployment 는 새로운 버전의 애플리케이션을 프로덕션 환경에 배포하고 실제 트래픽을 복제하여 새 버전으로 전송하지만, 그 결과는 사용자에게 반환하지 않는 방식이다. 이는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2024-09-23 12:47:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shadow Deployment" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/ci-cd/deployment-and-operations/deployment-strategies/shadow-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Feature Flags</h2></header><div class=entry-content><p>Feature Flags Feature flags(또는 feature toggles)는 소프트웨어 개발에서 중요한 배포 전략 중 하나이다.
이 기술을 통해 개발자는 코드 변경 없이 런타임에 특정 기능을 활성화하거나 비활성화할 수 있다.
Feature flags는 조건문을 사용하여 코드의 특정 부분을 동적으로 제어하는 소프트웨어 개발 기법이다.
이를 통해 배포와 릴리스를 분리하고, 위험을 최소화하며 유연한 기능 관리가 가능해진다.
Feature flags는 현대적인 소프트웨어 개발에서 중요한 도구이다. 이를 효과적으로 사용하면 더 안전하고 유연한 배포 프로세스를 구축할 수 있다. 하지만 적절한 관리와 주의가 필요하며, 팀의 요구사항과 프로젝트의 특성에 맞게 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 12:36:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Feature Flags" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/ci-cd/deployment-and-operations/deployment-strategies/feature-flags/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A/B Testing</h2></header><div class=entry-content><p>A/B Testing 사용자 그룹별로 다른 버전 제공, 실험적 배포 피처 플래그 (Feature Flag) 시스템 도입 사용자 그룹 분리 기반 실험 결과 측정 지표 (Conversion, Retention 등) A/B Testing 은 소프트웨어 배포 전략 중 하나로, 두 가지 이상의 버전을 사용자에게 제공하여 어떤 버전이 더 효과적인지 비교하는 방법이다.
A/B Testing 은 두 가지 이상의 버전 (A 와 B) 을 사용자 그룹에게 무작위로 제공하여 각 버전의 성능을 비교하는 실험적 접근 방식이다. 이는 웹사이트, 모바일 앱, 마케팅 캠페인 등 다양한 분야에서 사용된다.
...</p></div><footer class=entry-footer><span title='2024-09-23 02:14:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to A/B Testing" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/ci-cd/deployment-and-operations/deployment-strategies/a-b-testing-deployment/a-b-testing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/devops-and-infrastructure/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/devops-and-infrastructure/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>