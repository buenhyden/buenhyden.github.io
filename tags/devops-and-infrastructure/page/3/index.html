<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevOps-and-Infrastructure | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/devops-and-infrastructure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/devops-and-infrastructure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/devops-and-infrastructure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/devops-and-infrastructure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="DevOps-and-Infrastructure"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="DevOps-and-Infrastructure"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>DevOps-and-Infrastructure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VirtualBox</h2></header><div class=entry-content><p>Virtual Box 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구.
회사 및 라이선스:
Oracle Corporation에서 개발 오픈 소스 소프트웨어로, 기본 버전은 무료로 사용 가능 성능 및 기능:
VMware에 비해 성능이 다소 떨어질 수 있음 기본적인 가상화 기능(스냅샷, 클론, 3D 가속 등) 제공 일부 고급 기능은 확장 팩 설치 필요 호환성:
Windows, macOS, Linux, Solaris 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
비교적 간단한 인터페이스 제공, 일부 기능은 탐색이 어려울 수 있음 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 04:54:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VirtualBox" href=https://buenhyden.github.io/posts/system-design/system-components/platform-and-execution-infrastructure/virtualization/virtualization-platforms/virtualbox/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Hooks</h2></header><div class=entry-content><p>Git Hooks Git Hooks 는 Git 워크플로우의 특정 이벤트 (커밋, 푸시 등) 가 발생할 때 자동으로 실행되는 사용자 정의 스크립트이다. 이 스크립트들은 소스 코드 관리, 품질 보증, 배포 자동화 등 다양한 목적으로 활용된다. Git Hooks 는 클라이언트 측과 서버 측으로 나뉘며, 로컬 개발 환경에서의 코드 검증부터 원격 저장소에서의 배포 자동화까지 광범위한 워크플로우를 지원한다. 이를 통해 개발자들은 코딩 표준 준수, 테스트 자동화, 지속적 통합/배포 등을 효율적으로 구현할 수 있다.
핵심 개념 Git Hooks 는 Git 작업 이벤트 트리거에 반응하는 자동화 스크립트이다. .git/hooks 디렉토리에 위치하며, 실행 가능한 권한이 부여된 스크립트 파일 형태로 존재한다. 이벤트는 커밋 생성, 브랜치 전환, 원격 저장소로의 푸시 등 Git 워크플로우의 다양한 시점에서 발생할 수 있으며 사전/사후 작업을 실행한다.
...</p></div><footer class=entry-footer><span title='2024-10-28 12:38:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Hooks" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/git-workflow/git-hooks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P2P and Hybrid VCS</h2></header><div class=entry-content><p>P2P And Hybrid VCS P2P VCS 는 Git 과 같은 분산형 버전 관리 시스템의 진화된 형태로 노드 간 직접 통신으로 센서리스 아키텍처를 구현하며, 하이브리드 VCS 는 메타데이터 관리를 중앙서버에서 처리한다. 주요 구성 요소로 DHT(분산 해시 테이블), 암호화 검증 계층, 자동 동기화 엔진이 포함된다. 도전 과제로 네트워크 지연 시간 최적화와 대규모 분산 트랜잭션 관리가 존재한다.
Radicle 과 같은 솔루션은 분산 네트워크에서 Git 기반 협업을, Perforce Helix 와 같은 시스템은 하이브리드 접근 방식을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-26 06:17:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P2P and Hybrid VCS" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/advanced-topics/p2p-and-hybrid-vcs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitOps and IaC</h2></header><div class=entry-content><p>GitOps and IaC GitOps 와 IaC(Infrastructure as Code) 는 현대 DevOps 환경에서 인프라스트럭처 관리를 자동화하고 코드화하는 핵심 방법론이다.
GitOps 는 Git 을 단일 진실의 소스 (Single Source of Truth) 로 활용하여 애플리케이션과 인프라의 배포를 자동화하는 접근 방식이다. IaC 는 인프라를 코드로 정의하여 자동화된 프로비저닝과 관리를 가능하게 한다. 이 두 가지 개념은 클라우드 네이티브 환경에서 자동화된 배포 파이프라인, 선언적 인프라 정의, 버전 관리 및 감사 기능을 통해 인프라와 애플리케이션 관리를 혁신하고 있다. 이 두 방법론을 결합하여 조직은 인프라스트럭처 프로비저닝, 애플리케이션 배포, 구성 관리를 자동화하고 일관성 있게 유지하며, 변경 사항을 추적하고 필요시 롤백할 수 있다.
ArgoCD 와 FluxCD 는 Kubernetes 환경에서 GitOps 를 구현하는 주요 도구이며, Terraform 은 다양한 클라우드 환경에서 IaC 를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:15:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitOps and IaC" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/advanced-topics/gitops-and-iac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CI/CD Principles</h2></header><div class=entry-content><p>CI/CD Principles CI/CD 원칙은 지속적 통합 (CI) 과 지속적 배포 (CD) 를 기반으로 코드 변경 사항을 빠르게 통합, 테스트, 배포하는 자동화된 프로세스를 강조한다.
CI/CD 는 DevOps 문화의 중심에 있으며, 개발팀이 더 자주, 더 안정적으로 코드를 통합하고 배포할 수 있게 해준다.
핵심 개념 CI/CD 는 두 가지 연관된 개념의 조합이다:
지속적 통합 (Continuous Integration, CI): 개발자들이 코드 변경사항을 중앙 리포지토리에 자주 통합하는 개발 방식으로, 보통 하루에 여러 번 이루어진다. 각 통합은 자동화된 빌드와 테스트로 검증되어 통합 문제를 빠르게 식별한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:24:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD Principles" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-fundamentals/ci-cd-principles/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI</h2></header><div class=entry-content><p>Gitlab CI .gitlab-ci.yml 구조 Stage/Job 구성 및 GitLab Pages 활용 Multi-Project 파이프라인 Auto DevOps 설정 Kubernetes 배포 자동화 GitLab에 내장된 지속적 통합/배포 도구로, .gitlab-ci.yml 파일을 통해 파이프라인을 정의하고 관리 특징 통합성: GitLab 저장소와 긴밀하게 통합되어 있어 별도의 도구 없이 CI/CD 파이프라인을 구축할 수 있습니다. 유연성: YAML 파일을 통해 파이프라인을 구성할 수 있어 다양한 프로젝트 요구사항에 맞춤 설정이 가능합니다. 확장성: 다양한 Runner 유형을 지원하여 다양한 환경에서 작업을 실행할 수 있습니다. 가시성: 파이프라인 실행 상태와 결과를 GitLab 인터페이스에서 쉽게 확인할 수 있습니다. 기능 자동 빌드 및 테스트: 코드 변경 시 자동으로 빌드 및 테스트를 실행합니다. 환경 배포: 다양한 환경(개발, 스테이징, 프로덕션 등)에 자동으로 배포할 수 있습니다. 아티팩트 관리: 빌드 결과물을 저장하고 관리할 수 있습니다. 병렬 실행: 여러 작업을 동시에 실행하여 파이프라인 속도를 향상시킵니다. 환경 변수 관리: 민감한 정보를 안전하게 저장하고 사용할 수 있습니다. 구성요소 .gitlab-ci.yml: 파이프라인 구성 파일 Runners: 작업을 실행하는 에이전트 Jobs: 실행할 개별 작업 Stages: 작업의 실행 순서를 정의하는 단계 Pipeline: 전체 CI/CD 프로세스 장점 GitLab과의 긴밀한 통합 쉬운 설정과 사용 확장성과 유연성 무료로 사용 가능한 기능이 많음 단점 GitLab에 종속적 복잡한 워크플로우의 경우 설정이 복잡해질 수 있음 일부 고급 기능은 유료 버전에서만 사용 가능 설정 방법 프로젝트 루트에.gitlab-ci.yml 파일 생성 YAML 형식으로 파이프라인 구성 작성 변경사항을 커밋하고 푸시 GitLab에서 파이프라인 실행 확인 .gitlab-ci.yml 파일의 기본 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 stages: - build - test - deploy job1: stage: build script: - echo "Building the project..." job2: stage: test script: - echo "Running tests..." job3: stage: deploy script: - echo "Deploying to production..." 주요 구성 요소 stages: 파이프라인의 실행 단계를 정의합니다. 각 단계는 순차적으로 실행됩니다. jobs: 각 작업을 정의합니다. 작업은 특정 단계에 속하며, 실행할 스크립트를 포함합니다. script: 작업에서 실행할 명령어들을 정의합니다. image: 작업을 실행할 Docker 이미지를 지정합니다. artifacts: 작업 결과물을 저장하고 다른 작업에서 사용할 수 있게 합니다. cache: 작업 간에 공유할 파일이나 디렉토리를 지정합니다. 고급 구성 옵션 only/except: 특정 브랜치나 태그에서만 작업을 실행하거나 제외할 수 있습니다. variables: 파이프라인 전체 또는 특정 작업에서 사용할 변수를 정의합니다. before_script/after_script: 작업 실행 전후에 실행할 스크립트를 정의합니다. environment: 배포 환경을 지정합니다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 파이프라인 단계 정의 stages: - build - test - deploy # 캐시 설정: node_modules 폴더를 캐시하여 빌드 속도 향상 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build image: node:14 # Node.js 14 버전 이미지 사용 script: - npm install # 의존성 설치 - npm run build # 프로젝트 빌드 artifacts: paths: - dist/ # 빌드 결과물 저장 # 테스트 작업 정의 test: stage: test image: node:14 script: - npm install # 의존성 설치 - npm test # 테스트 실행 # 배포 작업 정의 deploy: stage: deploy image: alpine:latest script: - apk add --no-cache rsync openssh # 배포에 필요한 도구 설치 - mkdir -p ~/.ssh - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_SERVER_IP:/path/to/deployment/ only: - master # master 브랜치에 푸시될 때만 실행 stages: 파이프라인의 단계를 정의합니다. 여기서는 build, test, deploy 세 단계로 구성됩니다. cache: node_modules 폴더를 캐시하여 빌드 속도를 향상시킵니다. build 작업: stage: build로 빌드 단계에 할당합니다. Node.js 14 버전 이미지를 사용합니다. npm install로 의존성을 설치하고, npm run build로 프로젝트를 빌드합니다. artifacts를 사용하여 빌드 결과물을 저장합니다. test 작업: stage: test로 테스트 단계에 할당합니다. npm test 명령으로 테스트를 실행합니다. deploy 작업: stage: deploy로 배포 단계에 할당합니다. Alpine Linux 이미지를 사용하여 가벼운 환경을 구성합니다. SSH 키를 설정하고 rsync를 사용하여 빌드 결과물을 서버에 배포합니다. only: - master로 master 브랜치에 푸시될 때만 실행되도록 설정합니다. 기본 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # GitLab CI의 기본 설정 예시 image: node:16 # 기본 Docker 이미지 지정 # 파이프라인 스테이지 정의 stages: - build - test - deploy # 캐시 설정 - node_modules 디렉토리를 캐시 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build # 속한 스테이지 지정 script: - npm install # 의존성 설치 - npm run build # 빌드 실행 artifacts: # 빌드 결과물 저장 paths: - dist/ # 테스트 작업 정의 test: stage: test script: - npm run test # 테스트 실행 dependencies: # build 작업의 결과물 사용 - build # 배포 작업 정의 deploy: stage: deploy script: - echo "Deploying application…" - npm run deploy only: # main 브랜치에서만 실행 - main 고급 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 환경변수와 조건부 실행이 포함된 고급 설정 예시 variables: DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG # Docker 이미지 태그 정의 # 커스텀 도커 이미지 빌드 build_image: image: docker:20.10.16 services: - docker:20.10.16-dind # Docker-in-Docker 서비스 stage: build script: # Docker 레지스트리 로그인 - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Docker 이미지 빌드 및 푸시 - docker build -t $DOCKER_IMAGE . - docker push $DOCKER_IMAGE rules: - if: $CI_COMMIT_BRANCH == "main" # main 브랜치에서만 실행 when: always - when: never # 그 외의 경우 실행하지 않음 # 보안 스캔 작업 security_scan: image: security-scanner stage: test script: - scan-dependencies # 의존성 취약점 검사 - scan-code # 코드 보안 검사 allow_failure: true # 실패해도 파이프라인 계속 진행 # 스테이징 환경 배포 deploy_staging: stage: deploy environment: name: staging script: - deploy-to-kubernetes.sh --env staging rules: - if: $CI_COMMIT_BRANCH == "develop" 환경별 배포 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 환경별 배포 구성 예시 .deploy_template: &amp;deploy_template # 재사용 가능한 배포 템플릿 정의 script: - echo "Deploying to $CI_ENVIRONMENT_NAME" - kubectl apply -f k8s/$CI_ENVIRONMENT_NAME/ deploy_dev: &lt;&lt;: *deploy_template # 템플릿 상속 environment: name: development rules: - if: $CI_COMMIT_BRANCH == "develop" deploy_prod: &lt;&lt;: *deploy_template environment: name: production rules: - if: $CI_COMMIT_BRANCH == "main" when: manual # 수동 승인 후 배포 병렬 작업 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 병렬 테스트 실행 예시 test: parallel: 3 # 3개의 병렬 작업 생성 script: - npm run test -- --split=$CI_NODE_INDEX/$CI_NODE_TOTAL # 매트릭스 작업 정의 test_matrix: parallel: matrix: - NODE_VERSION: ["14", "16", "18"] DB_TYPE: ["mysql", "postgres"] script: - docker-compose run --rm -e NODE_VERSION=$NODE_VERSION -e DB_TYPE=$DB_TYPE test 캐시와 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 캐시와 아티팩트 관리 예시 build: cache: key: ${CI_COMMIT_REF_SLUG} # 브랜치별 캐시 키 paths: - node_modules/ - .npm/ policy: pull-push # 캐시 정책 설정 artifacts: paths: - dist/ # 빌드 결과물 - coverage/ # 테스트 커버리지 리포트 reports: junit: test-results.xml # 테스트 결과 리포트 coverage: coverage/lcov.info # 커버리지 리포트 expire_in: 1 week # 아티팩트 유효 기간 이러한 설정들은 프로젝트의 요구사항과 규모에 따라 적절히 조정하여 사용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-10-02 03:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gitlab CI" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-platforms/gitlab-ci-cd/gitlab-ci/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CI vs. CD vs. CD</h2></header><div class=entry-content><p>CI(지속적 통합) Vs. CD(지속적 전달) vs. CD(지속적 배포) CI/CD 는 현대 소프트웨어 개발 방법론의 핵심으로, 개발 과정을 자동화하고 신속하게 가치를 전달하는 데 중점을 둔다. 지속적 통합 (CI) 은 개발자가 코드 변경 사항을 자주 통합하고 검증하는 과정을 말하며, 지속적 전달 (CD) 은 검증된 코드를 자동으로 프로덕션 환경에 배포 가능한 상태로 준비하는 과정을, 지속적 배포 (CD) 는 검증된 코드를 자동으로 프로덕션 환경에 배포하는 과정을, 각각 자동화하는 방법론이다. 이 세 가지 접근 방식의 주요 차이점은 코드 변경 사항이 프로덕션 환경에 도달하는 자동화 수준과 사람의 개입 정도에 있다. CI/CD 파이프라인은 코드 품질 향상, 출시 주기 단축, 팀 협업 강화 등 다양한 이점을 제공하며, 최신 트렌드로는 GitOps, AIOps, 보안 통합 (DevSecOps) 등이 있다.
...</p></div><footer class=entry-footer><span title='2024-10-02 01:43:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI vs. CD vs. CD" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>History and Evolution of CI/CD</h2></header><div class=entry-content><p>History and Evolution of CI/CD CI/CD(지속적 통합/지속적 배포) 의 역사와 발전은 소프트웨어 개발 방법론의 진화를 보여주는 중요한 여정입니다. 1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념이 시작점이었으며, 이후 애자일 방법론의 부상과 함께 발전했다. 워터폴 모델의 한계를 극복하기 위해 등장한 CI/CD 는 개발자들이 코드 변경사항을 빈번하게 통합하고 자동화된 테스트를 수행하는 방식으로 진화했다. 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장은 CI/CD 도구의 대중화를 이끌었고, 이후 클라우드와 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 도구들이 등장했다. 현재 CI/CD 는 GitOps, AIOps, 보안 통합 (DevSecOps) 등의 최신 트렌드를 포함하며 계속 발전하고 있다. 이 발전 과정은 수동적이고 경직된 개발 프로세스에서 자동화되고 유연한 방식으로의 전환을 보여주며, 소프트웨어 산업의 혁신과 속도를 가속화하는 데 중요한 역할을 하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-02 00:51:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to History and Evolution of CI/CD" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Code Review Best Practices</h2></header><div class=entry-content><p>Code Review Best Practices **Version Control Systems (VCS)**에서 Code Review Best Practices는 코드 품질 향상과 팀 협업 강화를 위한 핵심 프로세스입니다. 소프트웨어 개발 과정에서 동료 개발자가 작성한 코드를 검토하여 품질을 향상시키고, 버그를 사전에 방지하며, 지식 공유를 촉진하는 역할을 한다. 2025 년 현재 AI 통합, 자동화된 검토 도구, 지표 기반 평가가 주요 트렌드로 부상하며, Git 을 중심으로 한 워크플로우 최적화가 중요시된다.
핵심 개념 및 목적 코드 리뷰는 한 개발자가 작성한 코드를 다른 개발자가 검토하는 체계적인 프로세스이다. 주로 풀 리퀘스트 (Pull Request) 또는 머지 리퀘스트 (Merge Request) 를 통해 이루어지며, 코드의 품질, 가독성, 기능성 및 표준 준수 여부를 평가한다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Review Best Practices" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/collaboration/code-review-best-practices/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Release Management</h2></header><div class=entry-content><p>Release Management 릴리스 관리 (Release Management) 는 소프트웨어 개발 프로세스에서 코드 변경사항을 개발 환경에서 프로덕션 환경으로 안전하고 체계적으로 배포하는 전체 과정을 관리하는 방법론이다. 이는 버전 관리 시스템과 긴밀하게 연계되어 코드 변경사항의 추적, 버전 관리, 배포 프로세스 자동화 등을 포함한다. 효과적인 릴리스 관리는 소프트웨어의 품질 보장, 배포 위험 최소화, 사용자 경험 향상, 개발 팀의 생산성 증대에 기여한다.
2025 년 현재 DevOps 및 CI/CD 도구와의 통합을 통해 지속적 배포 자동화가 강화되고 있으며, AI 기반 위험 관리 및 클라우드 네이티브 아키텍처 지원이 주목받고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Release Management" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/collaboration/release-management/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/devops-and-infrastructure/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/devops-and-infrastructure/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>