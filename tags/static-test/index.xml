<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Static-Test</title><link>https://buenhyden.github.io/tags/static-test/</link><description>Recent content in Static-Test on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 28 Nov 2024 02:35:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/tags/static-test/index.xml" rel="self" type="application/rss+xml"/><item><title>동적테스트(Dynamic Test)와 정적테스트(Static Test)</title><link>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</link><pubDate>Thu, 28 Nov 2024 02:35:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</guid><description>
&lt;h2>동적테스트(Dynamic Test)와 정적테스트(Static Test)&lt;/h2>&lt;p>동적테스트 (Dynamic Test)과 정적테스트(Static Test)&lt;/p>
&lt;p>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.&lt;br>
이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.&lt;/p>
&lt;p>효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.&lt;br>
예를 들어:&lt;/p>
&lt;ol>
&lt;li>개발 초기 단계:
&lt;ul>
&lt;li>정적 테스팅으로 기본적인 문제 해결&lt;/li>
&lt;li>코드 리뷰로 설계 문제 조기 발견&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 중기:
&lt;ul>
&lt;li>단위 테스트로 개별 기능 검증&lt;/li>
&lt;li>통합 테스트로 모듈 간 상호작용 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 후기:
&lt;ul>
&lt;li>시스템 테스트로 전체 기능 검증&lt;/li>
&lt;li>성능 테스트로 실제 환경 적합성 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>동적 테스트 (Dynamic Test)&lt;/h3>&lt;p>소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.&lt;br>
소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.&lt;br>
소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.&lt;/p>
&lt;h4>동적 테스팅의 기본 원리&lt;/h4>&lt;p>동적 테스팅은 실행 시점의 프로그램 행동을 관찰한다.&lt;br>
프로그램이 실제 환경에서 어떻게 동작하는지, 어떤 결과를 출력하는지, 얼마나 빠르게 처리하는지 등을 직접적으로 확인할 수 있다.&lt;br>
예를 들어, 웹 애플리케이션을 테스트할 때 실제 사용자처럼 로그인을 시도하고 데이터를 입력하면서 시스템의 반응을 검증한다.&lt;/p>
&lt;h4>동적 테스팅의 특징&lt;/h4>&lt;ol>
&lt;li>실행 기반: 프로그램을 실제로 실행하여 메모리 사용, 성능, 보안 취약점, 오류 등을 분석한다.&lt;/li>
&lt;li>테스트 환경: 소프트웨어가 실행될 실제 또는 가상 환경에서 분석이 이루어진다.&lt;/li>
&lt;li>런타임 문제 발견: 메모리 누수, 경쟁 조건, 예외 처리 문제 등 실행 중에만 드러나는 문제를 발견할 수 있다.&lt;/li>
&lt;li>실제 사용 환경 반영: 소프트웨어가 실제로 어떻게 동작하는지, 실제 환경에서의 성능과 안정성을 평가할 수 있다.&lt;/li>
&lt;/ol>
&lt;h4>동적 테스팅의 장점&lt;/h4>&lt;ol>
&lt;li>오류 탐색 정확도 높음: 실제 실행 환경에서 테스트하므로 오류를 정확하게 찾아낼 수 있다.&lt;/li>
&lt;li>실제 사용 시나리오 검증: 사용자 관점에서 소프트웨어의 동작을 검증할 수 있다.&lt;/li>
&lt;li>복잡한 버그 발견: 여러 컴포넌트 간의 상호작용에서 발생하는 복잡한 버그를 찾아낼 수 있다.&lt;/li>
&lt;li>성능 및 보안 평가: 실제 운영 환경에서의 성능을 측정하고 보안 취약점을 발견할 수 있다.&lt;/li>
&lt;li>사용자 경험 검증: 실제 사용자 상호작용을 시뮬레이션하여 사용자 경험을 검증할 수 있다.&lt;/li>
&lt;li>조기 피드백: 개발 과정 초기에 문제를 발견하여 효과적인 개선이 가능하다.&lt;/li>
&lt;/ol>
&lt;h4>동적 테스팅 비교 분석&lt;/h4>&lt;p>각 테스트 방법은 소프트웨어 개발 생명주기의 다른 단계에서 중요한 역할을 한다:&lt;/p>
&lt;ol>
&lt;li>단위 테스트는 개발 초기 단계에서 개별 코드 단위의 정확성을 확인한다.&lt;/li>
&lt;li>통합 테스트는 여러 모듈이 결합될 때 정상적으로 작동하는지 검증한다.&lt;/li>
&lt;li>기능 테스트는 소프트웨어의 기능적 요구사항 충족 여부를 확인한다.&lt;/li>
&lt;li>보안 테스트는 시스템의 취약점을 식별하고 보안 위협을 방지한다.&lt;/li>
&lt;li>성능 테스트는 시스템의 속도, 안정성, 확장성 등을 평가한다.&lt;/li>
&lt;li>수용 테스트는 최종 사용자 관점에서 요구사항 충족 여부를 확인한다.&lt;/li>
&lt;li>스모크 테스트는 빌드의 기본적인 안정성을 빠르게 확인한다.&lt;/li>
&lt;li>엔드투엔드 테스트는 전체 시스템의 흐름을 처음부터 끝까지 검증한다.&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>테스트 유형&lt;/th>
&lt;th>주요 목적&lt;/th>
&lt;th>테스트 범위&lt;/th>
&lt;th>수행 시점&lt;/th>
&lt;th>수행 주체&lt;/th>
&lt;th>특징&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>단위테스트&lt;/td>
&lt;td>개별 구성 요소의 정확성 검증&lt;/td>
&lt;td>함수, 메서드, 클래스 단위&lt;/td>
&lt;td>개발 단계&lt;/td>
&lt;td>개발자&lt;/td>
&lt;td>자동화가 용이, 빠른 피드백 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>통합테스트&lt;/td>
&lt;td>모듈 간 상호작용 검증&lt;/td>
&lt;td>여러 모듈의 결합&lt;/td>
&lt;td>단위테스트 이후&lt;/td>
&lt;td>개발자/QA&lt;/td>
&lt;td>모듈 간 인터페이스 검증에 중점&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>기능테스트&lt;/td>
&lt;td>기능적 요구사항 충족 확인&lt;/td>
&lt;td>개별 기능 단위&lt;/td>
&lt;td>개발 완료 후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>사용자 시나리오 기반 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보안테스트&lt;/td>
&lt;td>보안 취약점 발견&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 후반/운영 중&lt;/td>
&lt;td>보안 전문가&lt;/td>
&lt;td>주기적인 수행 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능테스트&lt;/td>
&lt;td>시스템 성능 검증&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 후반&lt;/td>
&lt;td>성능 테스트 전문가&lt;/td>
&lt;td>특수 도구 활용 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수용테스트&lt;/td>
&lt;td>사용자 요구사항 충족 확인&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 완료 후&lt;/td>
&lt;td>최종 사용자/고객&lt;/td>
&lt;td>실제 사용자 참여 필수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>스모크테스트&lt;/td>
&lt;td>기본 기능 동작 확인&lt;/td>
&lt;td>핵심 기능&lt;/td>
&lt;td>빌드 직후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>빠른 수행, 간단한 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>엔드투엔드테스트&lt;/td>
&lt;td>전체 비즈니스 프로세스 검증&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>통합 완료 후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>실제 환경과 유사한 조건에서 수행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>정적 테스트(Static Test)&lt;/h3>&lt;p>프로그램을 실행하지 않고 수행하는 테스트 방식&lt;br>
소프트웨어 개발 과정에서 생산되는 문서(코드, 설계서, 분석서, 계획서, 표준)에 대한 검토를 통해 오류를 발견하는 비실행 기반 테스트.&lt;/p>
&lt;h4>정적 테스팅의 기본 원리&lt;/h4>&lt;p>정적 테스팅은 소프트웨어의 정적 측면, 즉 실행하지 않고도 확인할 수 있는 특성들을 검사한다.&lt;br>
예를 들어, 코딩 표준 준수 여부, 변수 명명 규칙, 들여쓰기 등의 코드 스타일부터 메모리 누수 가능성이나 보안 취약점과 같은 잠재적 문제까지 다양한 측면을 검토한다.&lt;/p>
&lt;h4>정적 테스팅의 특징&lt;/h4>&lt;ol>
&lt;li>코드 실행 없이 수행: 프로그램을 실행하지 않고 소스 코드나 문서를 검토&lt;/li>
&lt;li>조기 결함 발견: 개발 초기 단계에서 잠재적 문제를 식별&lt;/li>
&lt;li>다양한 검토 대상: 코드, 요구사항 문서, 설계 문서 등 다양한 산출물 검토&lt;/li>
&lt;li>수동 및 자동화 방식: 인력에 의한 리뷰와 도구를 이용한 자동 분석 병행&lt;/li>
&lt;li>코딩 표준 준수 확인: 코딩 규칙, 가이드라인 준수 여부 검사&lt;/li>
&lt;/ol>
&lt;h4>정적 테스팅의 장점&lt;/h4>&lt;ol>
&lt;li>조기 결함 발견: 개발 초기에 문제를 발견하여 수정 비용과 시간 절감&lt;/li>
&lt;li>비용 효율성: 동적 테스팅에 비해 적은 비용으로 결함 발견 가능&lt;/li>
&lt;li>코드 품질 향상: 코딩 표준 준수와 구조적 문제 해결로 전반적인 코드 품질 개선&lt;/li>
&lt;li>보안성 강화: 보안 취약점을 조기에 발견하고 수정 가능&lt;/li>
&lt;li>개발 생산성 향상: 결함의 조기 발견으로 개발 과정의 효율성 증대&lt;/li>
&lt;li>협업 개선: 코드 리뷰를 통한 팀원 간 지식 공유와 의사소통 촉진&lt;/li>
&lt;li>테스트 범위 확대: 동적 테스팅으로 발견하기 어려운 결함 식별 가능&lt;/li>
&lt;/ol>
&lt;h4>정적 테스팅 비교 분석&lt;/h4>&lt;h5>Reviews (리뷰)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Informal Review&lt;/td>
&lt;td>• 공식적인 절차 없이 진행되는 검토 방식&lt;br>• 개발자 간 자유로운 토론과 피드백&lt;/td>
&lt;td>• 절차와 문서화 최소화&lt;br>• 빠른 피드백&lt;br>• 자유로운 의견 교환&lt;/td>
&lt;td>• 즉각적인 피드백 가능&lt;br>• 팀 내 지식 공유 촉진&lt;br>• 낮은 진입 장벽&lt;/td>
&lt;td>• 체계적인 추적이 어려움&lt;br>• 검토 누락 가능성&lt;br>• 품질 보증의 공식적 증거로 부족&lt;/td>
&lt;td>• 일상적인 코드 검토&lt;br>• quick fix 검증&lt;br>• 소규모 변경사항 검토&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Technical Review&lt;/td>
&lt;td>• 기술적 관점에서의 상세 검토&lt;br>• 동료 검토 중심의 체계적 접근&lt;/td>
&lt;td>• 기술적 완성도 중점&lt;br>• 대안 제시&lt;br>• 체크리스트 활용&lt;/td>
&lt;td>• 기술적 결함 조기 발견&lt;br>• 설계 개선 기회 제공&lt;br>• 기술 표준 준수 확인&lt;/td>
&lt;td>• 많은 시간과 자원 소요&lt;br>• 참여자의 전문성 필요&lt;br>• 범위 설정의 어려움&lt;/td>
&lt;td>• 아키텍처 검토&lt;br>• 성능 최적화 검증&lt;br>• 보안 취약점 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Walkthrough&lt;/td>
&lt;td>• 작성자가 주도하는 단계별 검토&lt;br>• 교육적 효과 중시&lt;/td>
&lt;td>• 시나리오 기반 검토&lt;br>• 상호 학습 기회&lt;br>• 단계별 설명&lt;/td>
&lt;td>• 지식 전파 효과적&lt;br>• 팀 이해도 향상&lt;br>• 새로운 관점 발견&lt;/td>
&lt;td>• 작성자 편향 가능성&lt;br>• 시간 소요가 큼&lt;br>• 객관성 확보 어려움&lt;/td>
&lt;td>• 신규 팀원 교육&lt;br>• 복잡한 로직 설명&lt;br>• 프로세스 이해&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Inspection&lt;/td>
&lt;td>• 가장 공식적이고 체계적인 검토&lt;br>• 철저한 문서화와 추적&lt;/td>
&lt;td>• 역할 분담 명확&lt;br>• 체계적 절차&lt;br>• 상세한 문서화&lt;/td>
&lt;td>• 높은 결함 발견율&lt;br>• 품질 보증 증거 확보&lt;br>• 체계적 개선 가능&lt;/td>
&lt;td>• 높은 비용과 시간&lt;br>• 과도한 문서화 부담&lt;br>• 유연성 부족&lt;/td>
&lt;td>• 중요 시스템 검증&lt;br>• 품질 인증 준비&lt;br>• 규제 준수 확인&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>Static Analysis (정적 분석)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Syntax Analysis&lt;/td>
&lt;td>• 코드의 문법적 오류 검출&lt;br>• 컴파일러 수준의 검사&lt;/td>
&lt;td>• 자동화된 검사&lt;br>• 즉각적 피드백&lt;br>• 기본적 오류 검출&lt;/td>
&lt;td>• 빠른 오류 발견&lt;br>• 개발 생산성 향상&lt;br>• 기본적 품질 보장&lt;/td>
&lt;td>• 의미적 오류 발견 불가&lt;br>• 단순 오류만 검출&lt;br>• 컨텍스트 이해 부족&lt;/td>
&lt;td>• 컴파일 전 검사&lt;br>• IDE 통합 검사&lt;br>• 기본 코드 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Data Flow Analysis&lt;/td>
&lt;td>• 데이터의 흐름과 사용 패턴 분석&lt;br>• 변수 사용의 적절성 검증&lt;/td>
&lt;td>• 변수 추적&lt;br>• 초기화 검사&lt;br>• 사용 패턴 분석&lt;/td>
&lt;td>• 데이터 관련 버그 발견&lt;br>• 메모리 누수 방지&lt;br>• 안정성 향상&lt;/td>
&lt;td>• 분석 비용 높음&lt;br>• 오탐 가능성&lt;br>• 복잡한 패턴 분석 어려움&lt;/td>
&lt;td>• 메모리 관리 검증&lt;br>• 변수 사용 분석&lt;br>• 초기화 오류 검출&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Control Flow Analysis&lt;/td>
&lt;td>• 프로그램 실행 경로 분석&lt;br>• 로직 흐름 검증&lt;/td>
&lt;td>• 경로 분석&lt;br>• 도달성 검사&lt;br>• 순환 복잡도 측정&lt;/td>
&lt;td>• 논리적 오류 발견&lt;br>• 코드 복잡도 관리&lt;br>• 실행 경로 최적화&lt;/td>
&lt;td>• 동적 경로 예측 한계&lt;br>• 복잡한 조건 분석 어려움&lt;br>• 성능 오버헤드&lt;/td>
&lt;td>• 분기문 검증&lt;br>• 데드코드 탐지&lt;br>• 복잡도 측정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Code Quality Analysis&lt;/td>
&lt;td>• 코딩 표준 준수 여부 검사&lt;br>• 품질 메트릭스 측정&lt;/td>
&lt;td>• 표준 준수 검사&lt;br>• 메트릭스 측정&lt;br>• 품질 지표 산출&lt;/td>
&lt;td>• 일관된 코드 품질&lt;br>• 유지보수성 향상&lt;br>• 객관적 품질 평가&lt;/td>
&lt;td>• 맥락 이해 부족&lt;br>• 과도한 규칙 적용&lt;br>• 거짓 양성 보고&lt;/td>
&lt;td>• 코딩 표준 검증&lt;br>• 품질 지표 측정&lt;br>• 리팩토링 대상 식별&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>Formal Methods (정형 기법)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Model Checking&lt;/td>
&lt;td>• 시스템 모델의 수학적 검증&lt;br>• 상태 공간 탐색&lt;/td>
&lt;td>• 형식적 검증&lt;br>• 전수 검사&lt;br>• 자동화된 분석&lt;/td>
&lt;td>• 완벽한 검증 가능&lt;br>• 중요 속성 보장&lt;br>• 숨은 오류 발견&lt;/td>
&lt;td>• 높은 복잡도&lt;br>• 전문성 요구&lt;br>• 큰 시스템에 적용 어려움&lt;/td>
&lt;td>• 안전중심 시스템&lt;br>• 프로토콜 검증&lt;br>• 동시성 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Theorem Proving&lt;/td>
&lt;td>• 수학적 증명을 통한 검증&lt;br>• 논리적 정확성 입증&lt;/td>
&lt;td>• 수학적 엄밀성&lt;br>• 형식적 명세&lt;br>• 증명 기반 접근&lt;/td>
&lt;td>• 절대적 정확성&lt;br>• 핵심 속성 보장&lt;br>• 수학적 완전성&lt;/td>
&lt;td>• 매우 높은 비용&lt;br>• 전문가 필요&lt;br>• 실용성 제한적&lt;/td>
&lt;td>• 핵심 알고리즘 검증&lt;br>• 보안 프로토콜&lt;br>• 미션크리티컬 시스템&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item></channel></rss>