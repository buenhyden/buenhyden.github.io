<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>System-Design on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/system-design/</link>
    <description>Recent content in System-Design on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.7</generator>
    <language>en</language>
    <lastBuildDate>Sun, 18 May 2025 12:46:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/system-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Performance vs Scalability</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/performance-vs-scalability/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/performance-vs-scalability/</guid>
      <description>성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 상호 보완적이면서도 때로는 상충하는 핵심 속성이다.  성능은 단일 작업을 얼마나 빠르게 처리할 수 있는지를 나타내는 반면, 확장성은 부하가 증가할 때 시스템이 이를 효과적으로 처리할 수 있는 능력을 의미한다.  성능이 좋은 시스템이 반드시 확장성이 좋은 것은 아니며, 그 반대도 마찬가지이다. 이 두 특성의 균형을 맞추는 것은 현대 시스템 설계의 핵심 과제로, 분산 시스템, 로드 밸런싱, 캐싱, 데이터베이스 샤딩 등의 기술을 통해 해결할 수 있다.</description>
    </item>
    <item>
      <title>Latency vs Throughput</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/</guid>
      <description>지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다.</description>
    </item>
    <item>
      <title>Availability vs Consistency</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability-vs-consistency/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability-vs-consistency/</guid>
      <description>가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다.</description>
    </item>
    <item>
      <title>Consistency Patterns</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/</link>
      <pubDate>Wed, 09 Oct 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/</guid>
      <description>분산 시스템에서 **일관성 패턴**은 시스템의 요구사항, 성능, 가용성, 지연 시간 간의 균형을 맞추기 위한 핵심 전략이다. 대표적인 패턴으로는 **Strong, Eventual, Causal, Weak Consistency** 등이 있으며, 시스템 요구 사항에 따라 다르게 적용되며 서로 다른 트레이드오프를 제공한다. 실무에서는 하이브리드 일관성 모델을 활용하거나, 동적으로 일관성을 조정하는 구조가 확대되고 있다. 2025 년에는 AI 기반 예측, Adaptive Consistency, 규제 대응 설계 전략 등이 주목받고 있다.</description>
    </item>
    <item>
      <title>Availability Patterns</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-patterns/</link>
      <pubDate>Wed, 09 Oct 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-patterns/</guid>
      <description>가용성 패턴은 분산 시스템과 클라우드 환경에서 서비스의 안정적인 운영을 보장하기 위한 설계 패턴이다. 이 패턴들은 시스템의 일부가 실패하더라도 전체 시스템의 가용성을 유지하고, 장애에 대한 복원력을 제공하며, 사용자에게 지속적인 서비스를 제공하는 것을 목표로 한다. 서킷 브레이커, 벌크헤드, 헬스 엔드포인트 모니터링 등 다양한 패턴을 포함한다.</description>
    </item>
    <item>
      <title>Background Jobs</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/background-jobs/</link>
      <pubDate>Wed, 09 Oct 2024 04:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/background-jobs/</guid>
      <description>백그라운드 작업 (Background Jobs) 은 사용자 요청 처리 흐름에서 분리되어 비동기적으로 실행되는 작업으로 시스템의 응답성과 확장성을 향상시킨다. 이러한 작업은 대용량 데이터 처리, 장기 실행 워크플로우, 실패 재시도, 이벤트 기반 트리거 등 다양한 시나리오에서 활용된다.</description>
    </item>
    <item>
      <title>E-Commerce Service</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/e-commerce-service/</link>
      <pubDate>Tue, 03 Dec 2024 12:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/e-commerce-service/</guid>
      <description>물품 구매 서비스를 구현하기 위해 필요한 사항들을 정리한다.</description>
    </item>
    <item>
      <title>Enterprise Resource Planning</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/enterprise-resource-planning/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/enterprise-resource-planning/</guid>
      <description>ERP(Enterprise Resource Planning)는 기업의 모든 자원을 통합적으로 관리하고 운영하기 위한 시스템</description>
    </item>
    <item>
      <title>Warehouse Management System</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-management-system/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-management-system/</guid>
      <description>WMS(Warehouse Management System)는 창고 관리 시스템으로, 창고 내의 물류 프로세스를 최적화하고 효율적으로 관리하기 위한 소프트웨어 애플리케이션을 말한다</description>
    </item>
    <item>
      <title>Cache Strategy vs Cache Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy-vs-cache-policy/</link>
      <pubDate>Mon, 30 Sep 2024 15:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy-vs-cache-policy/</guid>
      <description>캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.</description>
    </item>
    <item>
      <title>Failback vs. Fail Over</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback-vs-fail-over/</link>
      <pubDate>Sun, 18 May 2025 12:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback-vs-fail-over/</guid>
      <description>Failover 는 주 시스템에 장애 발생 시 대기 시스템으로 자동 전환하여 서비스 연속성을 유지하는 방식이며, Failback 은 주 시스템이 복구된 후 원래 상태로 되돌리는 과정이다. 이 두 메커니즘은 고가용성 시스템에서 다운타임을 최소화하고 비즈니스 연속성을 보장하는 필수적인 재해 복구 전략을 구성한다.</description>
    </item>
    <item>
      <title>Failback</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback/</link>
      <pubDate>Sun, 18 May 2025 12:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback/</guid>
      <description>Failback 은 장애 발생 시 예비 시스템으로 전환된 (Failover) 서비스를 원본 시스템으로 복구하는 프로세스이다. 데이터 동기화, 서비스 재개, 자원 재배치 등을 통해 시스템의 정상 운영 상태를 복원하며, 계획된 유지보수나 비상 복구 시나리오에서 필수적으로 적용된다.</description>
    </item>
    <item>
      <title>Horizontal vs. Vertical Scaling</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/</link>
      <pubDate>Thu, 03 Apr 2025 15:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/</guid>
      <description>수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다.</description>
    </item>
    <item>
      <title>PACELC Theorem</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/pacelc-theorem/</link>
      <pubDate>Sat, 22 Mar 2025 06:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/pacelc-theorem/</guid>
      <description>PACELC 정리는 CAP 이론을 확장하여 네트워크 분할 (Partition) 발생 시 **A(가용성) vs C(일관성)**, 정상 시 **L(지연 시간) vs C(일관성)** 간 트레이드오프를 명시하는 이론이다. 이는 시스템 설계 시 필연적인 선택과 트레이드오프를 요구한다. 2025 년 현재 초대규모 분산 시스템에서 동적 리소스 할당과 AI 기반 자동 최적화 기술에 필수적으로 적용되며, 클라우드 네이티브 아키텍처 설계의 핵심 원칙으로 작용한다.</description>
    </item>
    <item>
      <title>CAP Theorem</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/cap-theorem/</link>
      <pubDate>Thu, 20 Feb 2025 00:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/cap-theorem/</guid>
      <description>CAP 이론은 분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 파티션 내성 (Partition Tolerance) 세 가지 속성 중 동시에 두 가지만 보장할 수 있다는 원칙이다. 네트워크 파티션 발생 시 시스템은 일관성과 가용성 중 하나를 선택해야 하며, 이는 분산 데이터베이스와 같은 시스템 설계에 중요한 영향을 미친다. 파티션 내성은 현실적인 분산 환경에서 필수적이므로 실제로는 일관성과 가용성 사이의 트레이드오프가 핵심이다.</description>
    </item>
    <item>
      <title>Fail Over</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failover/</link>
      <pubDate>Tue, 18 Feb 2025 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failover/</guid>
      <description>페일오버(Failover)는 시스템의 주요 구성 요소가 실패했을 때 자동으로 대체 구성 요소로 전환하여 서비스 연속성을 보장하는 고가용성 아키텍처 패턴으로 장애 감지, 전환 메커니즘, 데이터 동기화가 핵심 요소이다. 단일 장애점을 해결하기 위해 중복성을 도입하고, 액티브 - 패시브, 액티브 - 액티브, N&#43;1 등 다양한 구현 방식을 통해 시스템 다운타임을 최소화하고 비즈니스 연속성을 유지한다.  현대 IT 환경에서는 클라우드 기반 페일오버, 컨테이너화된 환경의 자동화된 페일오버, AI 기반 사전 예측 페일오버 등으로 진화하고 있으며, 비즈니스 연속성과 사용자 경험 보장에 필수적이다.</description>
    </item>
    <item>
      <title>Replication</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/replication/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/replication/</guid>
      <description>복제 (Replication) 는 데이터나 서비스의 사본을 여러 노드나 시스템에 분산 저장하는 기법으로, 시스템의 가용성, 내결함성, 확장성을 향상시킨다. 주로 마스터 - 슬레이브, 다중 마스터, 액티브 - 액티브와 같은 아키텍처로 구현되며, 동기식 또는 비동기식 복제 방식을 사용한다. CAP 이론에 따라 일관성과 가용성 사이의 균형을 고려해 설계된다.</description>
    </item>
    <item>
      <title>Ambassador</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/ambassador-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/ambassador-pattern/</guid>
      <description>Ambassador Pattern은 클라이언트와 마이크로서비스 사이에 별도의 서비스(Ambassador)를 두어 통신을 관리하는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/asynchronism/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/asynchronism/back-pressure/</guid>
      <description>시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Linearizability</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/linearizability/</link>
      <pubDate>Wed, 09 Oct 2024 08:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/linearizability/</guid>
      <description>선형화 가능성은 분산 시스템에서 동시에 발생하는 작업들이 마치 단일 시스템에서 순차적으로 실행된 것처럼 보이게 하는 강력한 일관성 모델이다. 이는 모든 작업이 실시간 순서를 준수하면서 단일 순차적 순서대로 실행되는 것처럼 동작하도록 보장하여, 분산 환경에서도 마치 하나의 시스템처럼 일관된 상태를 유지한다.</description>
    </item>
    <item>
      <title>Causal Consistency</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/causal-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 08:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/causal-consistency/</guid>
      <description>인과적 일관성은 분산 시스템에서 연산 간의 인과 관계를 유지하는 일관성 모델로, 관련된 연산은 동일한 순서로 보장하되, 독립적인 연산은 순서에 구애받지 않아 성능과 가용성을 향상시킨다.</description>
    </item>
    <item>
      <title>Eventual Consistency</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/eventual-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/eventual-consistency/</guid>
      <description>Eventual Consistency 는 분산 시스템에서 데이터가 즉시 일관되지 않아도 시간이 지나면 모든 노드가 동일한 상태로 수렴함을 보장하는 일관성 모델이다. 이는 높은 가용성과 확장성을 지원하지만, 일시적인 데이터 불일치와 충돌 해결이 필요하다</description>
    </item>
    <item>
      <title>Weak Consistency</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/weak-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/consistency-models/weak-consistency/</guid>
      <description>약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다.</description>
    </item>
  </channel>
</rss>
