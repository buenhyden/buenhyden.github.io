<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-and-Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-and-Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-and-Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-and-Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RDMA</h2></header><div class=entry-content><p>RDMA (Remote Direct Memory Access) 네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술
주요 특징:
낮은 지연 시간(Low Latency): CPU 개입 없이 메모리 간 직접 데이터 전송이 가능하므로, 전송 지연 시간이 매우 짧다. 높은 대역폭(High Bandwidth): 데이터 복사 과정이 없기 때문에 빠르고 효율적으로 대량의 데이터를 처리할 수 있다. 낮은 CPU 사용률(Low CPU Utilization): 데이터 전송 작업이 네트워크 어댑터(NIC)에서 이루어지기 때문에 CPU는 다른 작업에 집중할 수 있다. 제로-카피(Zero-Copy): 데이터가 중간 버퍼링 없이 메모리에서 바로 전송되므로, 데이터 복사로 인한 오버헤드가 없다. 효율성(Efficiency): 운영 체제와 CPU의 개입을 최소화하여 시스템 전체의 효율성을 높인다. 장점:
...</p></div><footer class=entry-footer><span title='2024-12-10 01:36:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDMA" href=https://buenhyden.github.io/posts/networking-and-communications/rdma/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>hop</h2></header><div class=entry-content><p>Hop 네트워크 계층에서 hop은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 각각의 네트워크 장치를 의미한다.
Hop은 데이터 패킷이 한 네트워크 세그먼트에서 다음 세그먼트로 이동하는 것을 나타내며, 주로 라우터나 게이트웨이와 같은 네트워크 장치를 통과할 때 발생한다.
Hop의 개념은 네트워크 통신의 효율성과 성능을 이해하는 데 중요한 역할을 하며, 특히 실시간 애플리케이션에서는 hop 수를 최소화하여 지연시간을 줄이는 것이 중요하다.
역할 데이터 패킷의 경로를 결정하고 다음 목적지로 전달한다. 네트워크 간 통신을 가능하게 하는 중요한 요소이다. Hop Count 출발지에서 목적지까지 패킷이 거치는 hop의 수를 나타낸다. 네트워크 거리를 측정하는 기본적인 방법이다. 일부 라우팅 프로토콜(예: RIP)에서는 hop count를 유일한 메트릭으로 사용한다. 특징 각 hop마다 지연시간이 발생하므로, hop 수가 많을수록 실시간 성능이 저하될 수 있다. TTL(Time To Live) 필드를 통해 패킷의 무한 루프를 방지한다. 유형 라우터 hop: 서로 다른 네트워크 간의 이동 스위치 hop: 같은 네트워크 내에서의 이동 가상 hop: 가상 네트워크에서의 이동 진단 ping이나 traceroute 명령어를 사용하여 목적지까지의 hop 수를 확인할 수 있다. 네트워크 문제 진단이나 라우팅 정확성 확인에 유용하다. 참고 및 출처 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-06 10:26:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;159 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to hop" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/hop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-12-06 10:18:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>쓰로틀링 (Throttling)</h2></header><div class=entry-content><p>쓰로틀링 (Throttling) 쓰로틀링(Throttling)은 시스템이나 리소스의 과도한 사용을 제어하고 관리하는 기술이다.
특정 시간 동안 처리할 수 있는 요청의 수나 데이터의 양을 제한함으로써 시스템의 과부하를 방지하고 안정적인 서비스를 제공하는 것이 주요 목적이다.
작동 방식 지정된 시간 간격 내에 허용된 요청 수를 초과하면 추가 요청을 거부하거나 지연시킨다. 예를 들어, 초당 1000개의 요청만 허용한다면 그 이상의 요청은 throttle된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ThrottlingController { private final int MAX_REQUESTS_PER_SECOND = 1000; private final Queue&lt;Long> requestTimestamps = new LinkedList&lt;>(); public boolean isRequestAllowed() { long currentTime = System.currentTimeMillis(); // 1초가 지난 타임스탬프 제거 while (!requestTimestamps.isEmpty() && requestTimestamps.peek() &lt; currentTime - 1000) { requestTimestamps.poll(); } // 현재 요청 수가 제한보다 적으면 허용 if (requestTimestamps.size() &lt; MAX_REQUESTS_PER_SECOND) { requestTimestamps.offer(currentTime); return true; } return false; } } 주요 용도 API 사용량 제한 서버 리소스 보호 DDoS 공격 방지 네트워크 트래픽 관리 쓰로틀링의 주요 유형 Rate Limiting (비율 제한)
...</p></div><footer class=entry-footer><span title='2024-12-06 04:14:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;590 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쓰로틀링 (Throttling)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events (SSE) 실시간 알림, 주식 시세, 실시간 점수 업데이트 등을 구현하기 위해서는 서버가 클라이언트에게 능동적으로 데이터를 보낼 수 있어야 한다.
이를 위한 기술 중 하나가 바로 SSE이다.
SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술이다.
WebSocket과 비교했을 때 더 단순하고 HTTP를 기반으로 하기 때문에 구현이 쉽다는 장점이 있다.
주요 특징 단방향 통신: SSE는 서버에서 클라이언트로의 단방향 통신만을 지원한다. HTTP 프로토콜 사용: SSE는 기존 HTTP 프로토콜을 사용하므로, 특별한 프로토콜이나 서버 설정이 필요하지 않다. 자동 재연결: 연결이 끊어졌을 때 브라우저가 자동으로 재연결을 시도한다. 개발자가 별도의 재연결 로직을 구현할 필요가 없다. 실시간 데이터 전송: 서버에서 발생하는 이벤트나 데이터 변경 사항을 클라이언트에게 실시간으로 전달할 수 있다. 장점 간단한 구현: WebSocket에 비해 구현이 더 간단하다. 브라우저 호환성: 대부분의 최신 브라우저에서 지원된다. 서버 부하 감소: HTTP 연결을 재사용하므로, WebSocket보다 서버 부하가 적을 수 있다. 방화벽 친화적: 기존 HTTP 프로토콜을 사용하므로 방화벽이나 프록시 서버와의 호환성이 좋다. 단점 단방향 통신: 양방향 통신이 필요한 경우에는 적합하지 않다. 연결 제한: 브라우저당 동시 SSE 연결 수에 제한이 있을 수 있다. IE 지원 부족: Internet Explorer에서는 지원되지 않는다. 동작 원리 클라이언트가 서버에 SSE 연결 요청을 보낸다. 서버는 클라이언트와 매핑되는 SSE 통신 객체(예: SseEmitter)를 생성한다. 서버에서 이벤트가 발생하면 해당 객체를 통해 클라이언트로 데이터를 전송한다. 활용사례 실시간 알림 시스템 주식 시세나 스포츠 점수 업데이트 소셜 미디어 피드 업데이트 로그 스트리밍 진행 상황 모니터링 고려사항 연결 관리:
...</p></div><footer class=entry-footer><span title='2024-11-30 06:18:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-and-communications/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/networking-and-communications/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>