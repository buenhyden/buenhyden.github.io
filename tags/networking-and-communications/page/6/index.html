<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-and-Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-and-Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-and-Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-and-Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-10-22 02:43:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프래그먼테이션 (Fragmentation)</h2></header><div class=entry-content><p>프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.
이는 다음과 같은 목적을 가진다:
다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.
이를 MTU(Maximum Transmission Unit)라고 한다.
예를 들어:
이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트
만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.
각 프래그먼트는:
...</p></div><footer class=entry-footer><span title='2024-10-22 02:40:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프래그먼테이션 (Fragmentation)" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/fragmentation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>encapsulation and decapsulation</h2></header><div class=entry-content><p>Encapsulation (캡슐화) and Decapsulation (역캡슐화) 데이터에 헤더 (Header) 를 붙이고 아래 계층에 보내는 것을 캡슐화 (Encapsulation), 데이터에 헤더를 제거하고 위 계층에 보내는 것을 역캡슐화 (Decapsulation) 데이터 전송시 캡슐화가 이뤄지고 수신시 역캡슐화 (Decapsulation) 가 이뤄진다. 데이터에 헤더 (Header) 를 붙이고 아래 계층에 보내는 것을 캡슐화 (Encapsulation), 데이터에 헤더를 제거하고 위 계층에 보내는 것을 역캡슐화 (Decapsulation) 라고 한다. 중요성 모듈성: 각 계층의 기능을 논리적으로 분리하여 네트워크 프로토콜의 모듈식 설계를 가능하게 한다. 추상화: 다른 통신 계층에서 전달되는 정보의 구조를 추상화한다. 효율성: 대량의 데이터를 효율적으로 전송할 수 있게 한다. 보안: 데이터의 안전한 전송을 보장하며, 암호화된 통신 채널을 구축하는 데 도움을 준다. 유연성: 다양한 네트워크 환경과 프로토콜에 적응할 수 있는 유연성을 제공한다. 오류 검출 및 수정: 각 계층에서 데이터의 무결성을 확인하고 필요한 경우 오류를 수정할 수 있다. Encapsulation (캡슐화) 데이터가 송신자로부터 수신자에게 전송될 때 발생하는 과정
...</p></div><footer class=entry-footer><span title='2024-10-22 02:03:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1020 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to encapsulation and decapsulation" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/encapsulation-and-decapsulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-21 07:35:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;698 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/networking-and-communications/apis/hateoas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>웹훅 (Webhook)</h2></header><div class=entry-content><p>웹훅 (Webhook) 웹훅은 웹 애플리케이션에서 특정 이벤트가 발생했을 때 다른 애플리케이션에 실시간으로 정보를 전달하는 방법이다.
쉽게 말해, 어떤 일이 일어났을 때 자동으로 알림을 보내는 시스템이라고 생각하면 된다.
웹훅의 작동 원리 애플리케이션 A가 특정 URL(콜백 URL)을 애플리케이션 B에 등록한다. 애플리케이션 B에서 중요한 이벤트가 발생한다. 애플리케이션 B는 등록된 URL로 HTTP POST 요청을 보낸다. 애플리케이션 A는 이 요청을 받아 필요한 작업을 수행한다. 웹훅의 장점 실시간 업데이트: 이벤트 발생 즉시 알림을 받을 수 있다. 효율성: 필요할 때만 통신하므로 리소스 사용이 적다. 자동화: 이벤트에 따른 작업을 자동으로 처리할 수 있다. 웹훅의 단점 보안 문제: 콜백 URL이 노출될 경우 악의적인 요청을 받을 수 있다. 신뢰성: 네트워크 문제로 알림이 손실될 수 있다. 단방향 통신: 서버에서 클라이언트로의 통신만 가능하다. 웹훅의 사용 사례 결제 시스템: 결제 완료 시 즉시 알림 소셜 미디어: 새 게시물 작성 시 연동 서비스에 알림 버전 관리 시스템: 코드 변경 시 자동 빌드 시작 IoT: 센서 데이터가 특정 값을 초과할 때 알림 웹훅 구현 시 주의사항 보안: 요청의 출처를 반드시 확인해야 한다. 에러 처리: 네트워크 문제 등으로 인한 실패에 대비해야 한다. 재시도 메커니즘: 전송 실패 시 재시도 로직을 구현해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-21 06:46:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 웹훅 (Webhook)" href=https://buenhyden.github.io/posts/networking-and-communications/apis/webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>WebRTC(Web Real-Time Communication) API</h2></header><div class=entry-content><p>WebRTC(Web Real-Time Communication) API WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술.
웹 브라우저 간에 실시간으로 음성, 영상, 데이터를 직접 주고받을 수 있게 해주는 기술로 기존의 웹 통신이 항상 서버를 거쳐야 했던 것과 달리, WebRTC는 브라우저 간 직접 통신(P2P)을 가능하게 한다.
핵심 구성 요소 WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술입니다. WebRTC API는 주로 세 가지 핵심 구성 요소로 이루어져 있습니다:
...</p></div><footer class=entry-footer><span title='2024-10-21 06:37:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebRTC(Web Real-Time Communication) API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/webrtc-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events (SSE) 실시간 알림, 주식 시세, 실시간 점수 업데이트 등을 구현하기 위해서는 서버가 클라이언트에게 능동적으로 데이터를 보낼 수 있어야 한다.
이를 위한 기술 중 하나가 바로 SSE이다.
SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술이다.
WebSocket과 비교했을 때 더 단순하고 HTTP를 기반으로 하기 때문에 구현이 쉽다는 장점이 있다.
주요 특징 단방향 통신: SSE는 서버에서 클라이언트로의 단방향 통신만을 지원한다. HTTP 프로토콜 사용: SSE는 기존 HTTP 프로토콜을 사용하므로, 특별한 프로토콜이나 서버 설정이 필요하지 않다. 자동 재연결: 연결이 끊어졌을 때 브라우저가 자동으로 재연결을 시도한다. 개발자가 별도의 재연결 로직을 구현할 필요가 없다. 실시간 데이터 전송: 서버에서 발생하는 이벤트나 데이터 변경 사항을 클라이언트에게 실시간으로 전달할 수 있다. 장점 간단한 구현: WebSocket에 비해 구현이 더 간단하다. 브라우저 호환성: 대부분의 최신 브라우저에서 지원된다. 서버 부하 감소: HTTP 연결을 재사용하므로, WebSocket보다 서버 부하가 적을 수 있다. 방화벽 친화적: 기존 HTTP 프로토콜을 사용하므로 방화벽이나 프록시 서버와의 호환성이 좋다. 단점 단방향 통신: 양방향 통신이 필요한 경우에는 적합하지 않다. 연결 제한: 브라우저당 동시 SSE 연결 수에 제한이 있을 수 있다. IE 지원 부족: Internet Explorer에서는 지원되지 않는다. 동작 원리 클라이언트가 서버에 SSE 연결 요청을 보낸다. 서버는 클라이언트와 매핑되는 SSE 통신 객체(예: SseEmitter)를 생성한다. 서버에서 이벤트가 발생하면 해당 객체를 통해 클라이언트로 데이터를 전송한다. 활용사례 실시간 알림 시스템 주식 시세나 스포츠 점수 업데이트 소셜 미디어 피드 업데이트 로그 스트리밍 진행 상황 모니터링 고려사항 연결 관리:
...</p></div><footer class=entry-footer><span title='2024-10-21 06:18:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>WebSocket API</h2></header><div class=entry-content><p>WebSocket API WebSocket API는 WebSocket 프로토콜을 사용하여 클라이언트와 서버 간의 양방향, 실시간 통신을 가능하게 하는 웹 API로, HTTP 프로토콜의 단방향 통신과 폴링 방식의 한계를 극복하고, 클라이언트와 서버 간의 실시간 양방향 통신을 제공하는 기술이다.
WebSocket API는 이 프로토콜을 웹 애플리케이션에서 사용할 수 있게 해주는 인터페이스이다.
주요 기능 및 특징 양방향 통신: 클라이언트와 서버가 동시에 데이터를 주고받을 수 있다. 지속적 연결: 한 번 연결이 수립되면 지속적으로 유지된다. 실시간 데이터 교환: 폴링 없이 즉시 데이터를 주고받을 수 있다. 효율적인 리소스 사용: 연결이 유지되므로 반복적인 HTTP 요청의 오버헤드가 줄어든다. WebSocket 객체 생성 및 기본 사용법 WebSocket 객체를 생성하여 연결을 시작합니다:
...</p></div><footer class=entry-footer><span title='2024-10-21 05:37:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;577 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/websocket-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GraphQL API</h2></header><div class=entry-content><p>GraphQL API GraphQL은 API를 위한 쿼리 언어이자 서버 측 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청하고 받을 수 있게 해주는 강력한 도구.
2012년 Facebook에서 개발되어 2015년 공개된 GraphQL은 REST API의 한계를 극복하고자 설계되었습니다.
GraphQL의 주요 특징 선언적 데이터 fetching: 클라이언트가 필요한 데이터의 구조를 정확히 명시할 수 있습니다. 단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 전송됩니다. 강력한 타입 시스템: 스키마를 통해 데이터 구조를 명확히 정의합니다. 실시간 업데이트: Subscription을 통해 실시간 데이터 업데이트를 지원합니다. 효율적인 데이터 전송: Over-fetching과 Under-fetching 문제를 해결합니다. GraphQL의 주요 구성 요소 스키마 (Schema)
GraphQL API의 타입 시스템을 정의합니다.
사용 가능한 쿼리, 뮤테이션, 구독 및 사용자 정의 타입을 명시합니다.
...</p></div><footer class=entry-footer><span title='2024-10-21 03:22:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;449 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/graphql-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC API</h2></header><div class=entry-content><p>gRPC API gRPC(gRPC Remote Procedure Call)는 Google에서 개발한 오픈소스 원격 프로시저 호출(RPC) 시스템.
이 시스템은 효율적이고 빠른 서비스 간 통신을 제공하며, 다양한 프로그래밍 언어와 플랫폼에서 사용할 수 있다.
gRPC는 특히 다음과 같은 상황에서 유용하다:
마이크로서비스 아키텍처 서비스 간 효율적인 통신 강력한 타입 안정성 뛰어난 성능 실시간 통신이 필요한 시스템 채팅 애플리케이션 실시간 모니터링 게임 서버 모바일 애플리케이션 효율적인 데이터 전송 배터리 사용량 최적화 네트워크 대역폭 절약 gRPC의 주요 특징 Protocol Buffers 사용: gRPC는 데이터 직렬화를 위해 Protocol Buffers를 사용합니다. 이는 JSON이나 XML보다 더 작고 빠른 데이터 포맷을 제공합니다. HTTP/2 기반: HTTP/2 프로토콜을 사용하여 높은 성능과 낮은 지연 시간을 제공합니다. 양방향 스트리밍: 클라이언트와 서버 간의 양방향 스트리밍을 지원하여 실시간 데이터 교환이 가능합니다. 다양한 언어 지원: Java, Python, Go, C++, Ruby 등 다양한 프로그래밍 언어를 지원합니다. 강력한 타입 시스템: Protocol Buffers를 통해 강력한 타입 시스템을 제공하여 타입 안정성을 보장합니다. gRPC 작동 방식 서비스 정의:.proto 파일에 서비스와 메시지 구조를 정의합니다. 코드 생성: Protocol Buffer 컴파일러를 사용하여 서버와 클라이언트 코드를 자동으로 생성합니다. 서버 구현: 생성된 코드를 기반으로 서버 비즈니스 로직을 구현합니다. 클라이언트 구현: 생성된 클라이언트 코드를 사용하여 서버와 통신합니다. gRPC의 통신 유형 Unary RPC: 클라이언트가 단일 요청을 보내고 서버가 단일 응답을 반환합니다.
...</p></div><footer class=entry-footer><span title='2024-10-21 03:22:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;344 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-and-communications/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/networking-and-communications/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>