<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-and-Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-and-Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-and-Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-and-Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 6. Presentation Layer</h2></header><div class=entry-content><p>Presentation Layer(프레젠테이션 계층) 프레젠테이션 계층은 OSI 모델의 6번째 계층으로, 데이터의 표현 방식을 담당한다.
이 계층은 응용 계층과 세션 계층 사이에 위치하며, 데이터의 형식과 구조를 결정한다.
프레젠테이션 계층은 네트워크 통신에서 데이터의 표현과 보안을 담당하는 중요한 계층으로, 다양한 시스템 간의 원활한 데이터 교환을 가능하게 한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 데이터 변환: 송신 측과 수신 측 사이에서 데이터 형식을 변환한다. 인코딩과 디코딩: 데이터를 다양한 형식으로 인코딩하고 디코딩한다. 암호화와 복호화: 데이터의 보안을 위해 암호화 및 복호화를 수행한다. 데이터 압축: 효율적인 전송을 위해 데이터를 압축하고 해제한다. 특징 데이터의 의미와 구문을 보존하면서 형식을 변환한다. 응용 계층의 부담을 덜어주는 역할을 한다. 다양한 데이터 형식을 지원한다 (예: JPEG, MPEG, ASCII, EBCDIC). 프레젠테이션 계층의 중요한 표준들 문자 인코딩:
...</p></div><footer class=entry-footer><span title='2024-10-16 07:17:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;244 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 6. Presentation Layer" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-6-presentation-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 7. Application Layer</h2></header><div class=entry-content><p>Application Layer(애플리케이션 계층) 애플리케이션 계층은 OSI 모델의 최상위 계층으로, 사용자와 직접 상호작용하는 소프트웨어를 지원하는 계층이다.
이 계층은 사용자가 네트워크 자원에 접근할 수 있도록 인터페이스를 제공한다.
애플리케이션 계층은 네트워크 통신의 최종 목적지로, 사용자의 요구사항을 네트워크 서비스로 연결하는 중요한 역할을 수행한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 사용자와 네트워크 간의 인터페이스 제공 다양한 네트워크 서비스 제공 (이메일, 파일 전송, 웹 브라우징 등) 사용자 데이터의 송수신 관리 네트워크 자원에 대한 접근 제어 특징 사용자 지향적: 사용자가 직접 상호작용하는 유일한 OSI 계층. 다양한 프로토콜: 각 애플리케이션의 요구사항에 맞는 다양한 프로토콜을 사용한다. 데이터 형식 관리: 애플리케이션 간에 교환되는 데이터의 형식을 관리한다. 보안 및 인증: 사용자 인증 및 데이터 암호화와 같은 보안 메커니즘을 구현한다. 하위 계층의 서비스를 활용하여 작동 데이터 단위 애플리케이션 계층의 데이터 단위는 “메시지” 또는 “데이터"라고 불린다.
...</p></div><footer class=entry-footer><span title='2024-10-16 07:16:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;185 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 7. Application Layer" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-7-application-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Websocket vs WebRTC</h2></header><div class=entry-content><p>Websocket Vs WebRTC WebSocket과 WebRTC는 실시간 웹 통신을 위한 중요한 기술이다.
WebSocket:
클라이언트와 서버 간의 양방향, 전이중 통신을 제공하는 프로토콜이다. TCP 연결을 기반으로 작동하며, 지속적인 연결을 유지한다. 주로 텍스트 및 바이너리 데이터 전송에 사용된다. 서버-클라이언트 모델을 따른다. WebRTC:
브라우저 간 직접적인 피어-투-피어(P2P) 통신을 가능하게 하는 기술이다. 오디오, 비디오, 데이터의 실시간 통신을 지원한다. UDP를 주로 사용하여 낮은 지연 시간을 제공한다. 브라우저에 내장된 API를 통해 구현된다. WebSocket과 WebRTC의 비교 분석:
특성 WebSocket WebRTC 통신 모델 클라이언트-서버 피어-투-피어 프로토콜 TCP 기반 주로 UDP 사용 (TCP도 가능) 주요 용도 실시간 데이터 교환, 채팅 음성/영상 통화, 파일 공유 지연 시간 상대적으로 높음 낮음 데이터 유형 텍스트, 바이너리 오디오, 비디오, 데이터 구현 복잡성 상대적으로 간단 복잡 (NAT 통과 등 고려) 보안 기본적인 보안 기능 내장된 암호화 기능 확장성 서버 기반으로 확장 용이 P2P로 인한 확장 제한 브라우저 지원 광범위한 지원 대부분의 최신 브라우저 지원 사용 사례 채팅, 실시간 업데이트 화상 통화, 화면 공유 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-19 05:53:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;150 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Websocket vs WebRTC" href=https://buenhyden.github.io/til/2024/10/19/websocket-vs-webrtc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming Vs Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-10-20 08:44:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;256 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/til/2024/10/20/streaming-vs-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</h2></header><div class=entry-content><p>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.
GraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:08:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC" href=https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Webhook vs Server-Sent Events</h2></header><div class=entry-content><p>Webhook Vs Server-Sent Events Webhook과 Server-Sent Events(SSE)는 실시간 데이터 전송을 위한 웹 기술이다.
Webhook은 특정 이벤트가 발생했을 때 HTTP POST 요청을 통해 다른 애플리케이션에 실시간으로 데이터를 전송하는 방식으로, 애플리케이션 간 실시간 통신을 가능하게 하며, 이벤트 기반 업데이트를 제공한다.
Server-Sent Events (SSE)은 서버에서 클라이언트로 단방향 실시간 데이터 스트림을 제공하는 기술로, 서버가 클라이언트에게 지속적으로 업데이트를 푸시할 수 있게 한다.
두 기술 모두 실시간 데이터 전송을 위해 사용되지만, 각각의 특성에 따라 적절한 상황에서 선택하여 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:04:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;180 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Webhook vs Server-Sent Events" href=https://buenhyden.github.io/til/2024/10/19/webhook-vs-server-sent-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Gateway</h2></header><div class=entry-content><p>API Gateway 클라이언트와 백엔드 서비스 사이에서 중개자 역할을 하는 서버로, 여러 마이크로서비스나 백엔드 시스템에 대한 단일 진입점을 제공하는 중요한 컴포넌트
주요 기능 요청 라우팅 및 프록시
API Gateway는 클라이언트의 요청을 받아 적절한 백엔드 서비스로 라우팅한다.
이는 여러 마이크로서비스의 엔드포인트를 단일화하여 관리를 용이하게 한다.
인증 및 권한 부여
클라이언트의 요청에 대한 인증(Authentication)과 권한 부여(Authorization)를 처리한다.
이를 통해 각 마이크로서비스에서 중복으로 보안 로직을 구현할 필요가 없어진다.
프로토콜 변환
클라이언트와 서버 간의 다양한 프로토콜을 지원하고 필요에 따라 변환한다.
예를 들어, REST API와 WebSocket API를 모두 지원할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-20 09:40:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Gateway" href=https://buenhyden.github.io/til/2024/10/20/api-gateway/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>폴링(Polling)</h2></header><div class=entry-content><p>폴링(Polling) 폴링(Polling)은 소프트웨어 개발에서 중요한 통신 기법으로, 클라이언트가 주기적으로 서버에 데이터나 상태 변경을 요청하는 방식이다.
이 방법은 실시간 또는 준실시간 업데이트가 필요한 애플리케이션에서 자주 사용된다.
폴링의 작동 원리 클라이언트가 서버에 주기적으로 요청을 보낸다. 서버는 요청을 받아 처리하고 응답을 반환한다. 클라이언트는 응답을 받아 필요한 작업을 수행한다. 일정 시간 후 클라이언트는 다시 요청을 보낸다. 이 과정은 지속적으로 반복된다.
폴링의 장점 구현의 용이성: 폴링은 상대적으로 간단하게 구현할 수 있다. 호환성: 대부분의 환경과 기술에서 사용 가능하다. 요청 빈도 제어: 개발자가 요청 주기를 조절할 수 있어 유연성이 높다. 비실시간 업데이트에 적합: 즉각적인 업데이트가 필요하지 않은 경우에 효과적이다. 폴링의 단점 서버 부하: 불필요한 요청으로 인해 서버에 부담을 줄 수 있다. 실시간성 부족: 폴링 주기에 따라 실시간 업데이트가 지연될 수 있다. 리소스 낭비: 변경사항이 없어도 지속적으로 요청을 보내므로 리소스가 낭비될 수 있다. 폴링의 사용 사례 이메일 클라이언트: 새 메일 확인을 위해 주기적으로 서버에 요청을 보낸다. 주식 시세 모니터링: 일정 간격으로 최신 주가 정보를 요청한다. 소셜 미디어 피드: 새로운 게시물이나 알림을 확인하기 위해 사용된다. IoT 디바이스 모니터링: 센서 데이터를 주기적으로 확인한다. 폴링의 구현 폴링은 주로 JavaScript의 setInterval() 함수나 setTimeout() 함수를 사용하여 구현한다.
예를 들어:
...</p></div><footer class=entry-footer><span title='2024-10-20 16:50:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;245 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 폴링(Polling)" href=https://buenhyden.github.io/til/2024/10/20/polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Transmission</h2></header><div class=entry-content><p>Data Transmission 데이터 전송 및 처리 방식은 다양한 기준에 따라 분류되며, 각 방식은 특정한 통신 환경과 요구 사항에 맞게 선택된다.
전송 방향에 따른 분류 단방향 전송 (Simplex)
데이터가 한 방향으로만 전송된다. 예: 라디오 방송, TV 방송 장점: 단순하고 효율적인 채널 사용 단점: 상호작용이 불가능 반이중 전송 (Half-Duplex)
양방향으로 데이터 전송이 가능하지만, 동시에는 불가능하다. 예: 무전기 장점: 양방향 통신 가능, 에러 감지에 유용 단점: 동시 통신 불가 전이중 전송 (Full-Duplex)
양방향으로 동시에 데이터 전송이 가능하다. 예: 전화 통화, 현대적인 컴퓨터 네트워크 장점: 실시간 양방향 통신 가능, 높은 효율성 단점: 복잡한 하드웨어 필요 비트 전송 방식에 따른 분류 직렬 전송 (Serial Transmission)
...</p></div><footer class=entry-footer><span title='2024-10-20 09:32:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;271 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Transmission" href=https://buenhyden.github.io/til/2024/10/20/data-transmission/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>스트리밍 (Streaming)</h2></header><div class=entry-content><p>스트리밍 (Streaming) 스트리밍은 인터넷을 통해 오디오, 비디오 및 기타 콘텐츠를 실시간으로 전송하고 재생하는 기술이다.
이 기술은 사용자가 콘텐츠를 완전히 다운로드하지 않고도 즉시 소비할 수 있게 해준다.
스트리밍의 작동 원리 스트리밍은 대용량 콘텐츠를 작은 데이터 조각으로 나누어 연속적으로 전송한다.
사용자의 기기는 이 데이터를 받아 실시간으로 처리하고 재생한다.
이 과정은 다음과 같이 진행된다:
콘텐츠를 작은 패킷으로 분할 패킷을 순차적으로 전송 수신 기기에서 패킷을 버퍼링하고 재생 나머지 패킷이 계속 전송되는 동안 재생 시작 스트리밍의 유형 프로그레시브 다운로드: VOD, 인터넷 강좌 등에 적합 RTSP/RTMP 스트리밍: 실시간 대화형 플랫폼에 적합 적응형 HTTP 스트리밍: 유튜브, 넷플릭스와 같은 비디오 플랫폼에 적합 스트리밍 프로토콜 스트리밍에는 다양한 프로토콜이 사용된다:
...</p></div><footer class=entry-footer><span title='2024-10-20 06:48:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;377 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스트리밍 (Streaming)" href=https://buenhyden.github.io/til/2024/10/20/streaming/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-and-communications/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/networking-and-communications/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>