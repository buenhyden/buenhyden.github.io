<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-and-Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-and-Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-and-Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-and-Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-22 10:18:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-22 10:18:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/routing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-22 09:19:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;225 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/network-hop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프록시(Proxy)</h2></header><div class=entry-content><p>프록시(Proxy) 프록시(Proxy)는 “대리” 또는 “대신"이라는 의미를 가진 개념으로, 네트워크 환경에서 중요한 역할을 수행한다.
프록시 서버는 클라이언트의 요청을 받아 대신 서버에 접속하여 데이터를 주고받는 중개자 역할을 한다.
이 과정에서 프록시 서버는 클라이언트의 IP 주소를 숨기고, 자신의 IP 주소를 사용하여 서버와 통신한다.
프록시의 주요 기능 익명성 제공: 클라이언트의 실제 IP 주소를 숨겨 개인정보를 보호한다. 캐싱: 자주 요청되는 데이터를 저장하여 네트워크 성능을 향상시킨다. 접근 제어: 특정 웹사이트나 콘텐츠에 대한 접근을 제한할 수 있다. 로깅 및 모니터링: 네트워크 트래픽을 기록하고 분석할 수 있다. 프록시 사용의 장점 보안 강화: 클라이언트와 서버 사이의 직접적인 연결을 차단하여 보안을 향상시킨다. 성능 최적화: 캐싱을 통해 반복적인 요청에 대한 응답 속도를 높인다. 접근 제어: 조직 내 네트워크 사용을 관리하고 제한할 수 있다. 익명성: 사용자의 실제 IP 주소와 위치를 숨길 수 있다. 프록시 사용의 주의점 속도 저하: 추가적인 네트워크 홉으로 인해 약간의 지연이 발생할 수 있다. 보안 위험: 잘못 구성된 프록시는 오히려 보안 취약점이 될 수 있다. 호환성 문제: 일부 애플리케이션이나 서비스와 호환되지 않을 수 있다. 프록시의 작동 방식 사용자(클라이언트)가 웹사이트에 접속하려고 할 때, 직접 웹사이트 서버에 연결하지 않고 프록시 서버에 연결한다. 프록시 서버는 사용자의 요청을 받아 웹사이트 서버에 전달한다. 웹사이트 서버는 프록시 서버에 응답을 보낸다. 프록시 서버는 받은 응답을 다시 사용자에게 전달한다. 프록시의 종류 특성 포워드 프록시 리버스 프록시 위치 클라이언트 앞에 위치 서버 앞에 위치 주요 목적 클라이언트 보호 및 요청 중계 서버 보호 및 부하 분산 클라이언트 인식 클라이언트가 프록시 존재를 인식 클라이언트가 프록시 존재를 모름 IP 주소 은닉 클라이언트의 IP 주소를 숨김 서버의 IP 주소를 숨김 주요 기능 캐싱, 콘텐츠 필터링, 익명성 제공 로드 밸런싱, SSL 종료, 캐싱 트래픽 방향 내부에서 외부로 외부에서 내부로 보안 초점 클라이언트 보안 강화 서버 보안 강화 확장성 클라이언트 측 확장에 유리 서버 측 확장에 유리 주요 사용 사례 기업 내부 네트워크, 학교 등 웹 서버, CDN, 마이크로서비스 ...</p></div><footer class=entry-footer><span title='2024-10-22 08:47:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;289 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프록시(Proxy)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/proxy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>쓰로틀링 (Throttling)</h2></header><div class=entry-content><p>쓰로틀링 (Throttling) 쓰로틀링(Throttling)은 시스템이나 리소스의 과도한 사용을 제어하고 관리하는 기술이다.
특정 시간 동안 처리할 수 있는 요청의 수나 데이터의 양을 제한함으로써 시스템의 과부하를 방지하고 안정적인 서비스를 제공하는 것이 주요 목적이다.
작동 방식 지정된 시간 간격 내에 허용된 요청 수를 초과하면 추가 요청을 거부하거나 지연시킨다. 예를 들어, 초당 1000개의 요청만 허용한다면 그 이상의 요청은 throttle된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ThrottlingController { private final int MAX_REQUESTS_PER_SECOND = 1000; private final Queue&lt;Long> requestTimestamps = new LinkedList&lt;>(); public boolean isRequestAllowed() { long currentTime = System.currentTimeMillis(); // 1초가 지난 타임스탬프 제거 while (!requestTimestamps.isEmpty() && requestTimestamps.peek() &lt; currentTime - 1000) { requestTimestamps.poll(); } // 현재 요청 수가 제한보다 적으면 허용 if (requestTimestamps.size() &lt; MAX_REQUESTS_PER_SECOND) { requestTimestamps.offer(currentTime); return true; } return false; } } 주요 용도 API 사용량 제한 서버 리소스 보호 DDoS 공격 방지 네트워크 트래픽 관리 쓰로틀링의 주요 유형 Rate Limiting (비율 제한)
...</p></div><footer class=entry-footer><span title='2024-10-22 04:14:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;590 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쓰로틀링 (Throttling)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-and-communications/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/networking-and-communications/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>