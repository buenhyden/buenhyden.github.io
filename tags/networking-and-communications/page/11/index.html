<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-and-Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-and-Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-and-Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-and-Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RESTful API</h2></header><div class=entry-content><p>RESTful API(Representational State Transfer API) 웹 서비스를 설계하고 구현하기 위한 아키텍처 스타일
RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 간의 통신을 위한 표준화된 방식을 제공한다.
RESTful API의 주요 특징 자원 중심 구조: URI를 통해 자원을 명확하게 표현합니다. HTTP 메서드 활용: GET, POST, PUT, DELETE 등의 HTTP 메서드를 사용하여 자원에 대한 CRUD 작업을 수행합니다. 무상태성(Stateless): 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 균일한 인터페이스: 일관된 방식으로 자원에 접근할 수 있습니다. 설계 원칙 자원 식별: URI를 통해 자원을 명확하게 식별합니다. HTTP 메서드 사용: 적절한 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다. 자체 설명적 메시지: 요청과 응답은 자체적으로 이해할 수 있어야 합니다. HATEOAS(Hypermedia as the Engine of Application State): 응답에 관련 리소스의 링크를 포함합니다. 주요 제약 조건 클라이언트-서버 구조를 통해 관심사를 분리합니다. 이는 클라이언트와 서버가 독립적으로 발전할 수 있게 해줍니다. 예를 들어, 서버는 데이터 저장 방식을 변경할 수 있고, 클라이언트는 사용자 인터페이스를 개선할 수 있습니다. 무상태성(Stateless)을 유지합니다. 각 요청은 이전 요청과 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 이는 시스템의 확장성을 높여주지만, 매 요청마다 필요한 모든 정보를 포함해야 한다는 의미이기도 합니다. 캐시 가능성을 제공합니다. HTTP의 캐싱 메커니즘을 활용하여 성능을 개선할 수 있습니다. 예를 들어, 자주 변경되지 않는 사용자 프로필 이미지는 클라이언트에서 캐시할 수 있습니다. RESTful API 구현 예시 다음은 Node.js와 Express.js를 사용한 간단한 RESTful API 예제입니다:
...</p></div><footer class=entry-footer><span title='2024-10-03 03:21:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;482 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SOAP API</h2></header><div class=entry-content><p>SOAP API SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜.
분산 환경에서 데이터를 교환하기 위해 설계된 웹 서비스 통신 방식.
SOAP API의 주요 특징 XML 기반: 모든 SOAP 메시지는 XML 형식으로 구성됩니다. 프로토콜 독립성: HTTP, SMTP 등 다양한 프로토콜을 통해 전송될 수 있습니다. 표준화: 잘 정의된 표준을 따르며, 이는 다양한 플랫폼과 언어 간의 호환성을 보장합니다. 보안성: WS-Security와 같은 웹 서비스 보안 표준을 지원합니다. SOAP 메시지 구조 SOAP 메시지는 다음과 같은 요소로 구성됩니다:
...</p></div><footer class=entry-footer><span title='2024-10-03 03:21:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Media Access Control Address (MAC Address)</h2></header><div class=entry-content><p>Media Access Control Address(MAC Address) 네트워크 장비를 식별하기 위한 고유한 하드웨어 주소.
구조 48비트(6바이트) 길이의 주소로, 16진수 형식으로 표현된다.
주로 6개의 2자리 16진수 그룹으로 표시되며, 콜론(:), 하이픈(-), 또는 점(.)으로 구분된다.
1 2 3 4 5 class MACAddress: def __init__(self, address): # MAC 주소 예시: "00:1A:2B:3C:4D:5E" self.oui = address[:8] # 조직 고유 식별자 (앞 3바이트) self.nic = address[9:] # 네트워크 인터페이스 식별자 (뒤 3바이트) MAC 주소의 첫 24비트(3바이트)는 OUI(Organizationally Unique Identifier)로, IEEE에서 제조업체에 할당하는 고유 번호 나머지 24비트는 제조업체가 각 장치에 할당하는 고유 번호. 용도 로컬 네트워크 내에서 장치를 고유하게 식별한다. 데이터 링크 계층(OSI 모델의 2계층)에서 사용된다. 네트워크 통신에서 데이터 패킷의 송신자와 수신자를 식별한다. 특징 제조업체에 의해 할당되며, 전 세계적으로 고유하다. 하드웨어에 고정되어 있어 일반적으로 변경할 수 없다. LAN 환경에서 장치 간 통신에 사용된다. IP 주소와의 차이 MAC 주소는 물리적 주소로, 로컬 네트워크 내에서만 사용된다. IP 주소는 논리적 주소로, 인터넷 상에서 전역적으로 사용된다. 기능 네트워크 진단 및 문제 해결에 사용된다. 네트워크 보안(MAC 주소 필터링 등)에 활용될 수 있다. MAC 주소의 종류 유니캐스트 주소 특정 단일 장치를 위한 주소.
...</p></div><footer class=entry-footer><span title='2024-10-02 12:19:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;635 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Media Access Control Address (MAC Address)" href=https://buenhyden.github.io/posts/networking-and-communications/media-access-control-address/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>TCP</h2></header><div class=entry-content><p>TCP (Transmission Control Protocol) 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로, IP(Internet Protocol)와 함께 TCP/IP로 널리 알려져 있다.
TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜이다.
OSI 7계층에서 TCP는 전송 계층(Transport Layer)인 4계층에 위치하며,
TCP/IP 4계층 모델에서도 마찬가지로 전송 계층에 해당한다.
이 위치에서 TCP는 데이터의 신뢰성 있는 전송을 담당하는 핵심적인 역할을 수행한다.
TCP의 가장 중요한 특징은 연결 지향성과 신뢰성이다.
연결 지향성이란 데이터를 주고받기 전에 먼저 연결을 설정하는 것을 의미하는데, 이는 3-way handshaking이라는 과정을 통해 이루어진다.
신뢰성은 데이터가 손실없이 순서대로 전달되는 것을 보장한다는 의미이다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:21:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;787 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UDP</h2></header><div class=entry-content><p>UDP (User Datagram Protocol) 인터넷 프로토콜 스위트의 핵심 전송 계층 프로토콜 중 하나로, 비연결형 통신 방식을 통해 데이터를 빠르고 효율적으로 전송한다.
TCP와 달리 연결 설정 과정 없이 데이터그램 단위로 전송하며, 신뢰성보다는 속도와 실시간 처리가 중요한 애플리케이션에서 주로 사용한다.
OSI 7계층의 전송 계층(4계층)에 속하며, TCP/IP 4계층에서도 전송 계층에 속한다.
추가적으로 알아야 할 내용:
포트 번호: UDP도 TCP와 마찬가지로 16비트 포트 번호를 사용하여 애플리케이션을 구분합니다. 체크섬: UDP는 선택적으로 체크섬을 사용하여 데이터 무결성을 확인할 수 있습니다. MTU(Maximum Transmission Unit): UDP 데이터그램의 크기가 네트워크의 MTU를 초과하면 IP 계층에서 단편화가 발생할 수 있습니다. 애플리케이션 레벨 신뢰성: UDP를 사용하는 애플리케이션은 필요한 경우 자체적으로 신뢰성 메커니즘을 구현해야 합니다. NAT 통과: UDP는 TCP에 비해 NAT(Network Address Translation) 통과가 더 쉬울 수 있습니다. 실시간 애플리케이션: 음성 통화, 비디오 스트리밍, 온라인 게임 등 실시간 애플리케이션에서 자주 사용됩니다. DNS: 도메인 네임 시스템(DNS)은 주로 UDP를 사용하여 쿼리를 처리합니다. QUIC(Quick UDP Internet Connections): Google이 개발한 프로토콜로, UDP 위에서 동작하며 TCP의 일부 특성을 구현합니다. 주요 특징 비연결성: UDP는 연결을 설정하지 않고 바로 데이터를 전송한다.
TCP의 3-way handshake와 같은 연결 설정 과정이 없다. 신속성: 연결 설정 과정이 없어 TCP보다 빠른 전송이 가능하다. 비신뢰성: 데이터 전달의 보증이나 순서를 보장하지 않는다. 패킷 손실이 발생할 수 있다. 효율성: 헤더가 단순하여 오버헤드가 적고, 네트워크 부하가 적다. 장점 빠른 데이터 전송 적은 지연 시간 간단한 구현 작은 헤더 크기로 인한 효율적인 대역폭 사용 브로드캐스트 및 멀티캐스트에 적합 동작 방식 애플리케이션이 데이터를 UDP에 전달 UDP가 데이터를 데이터그램으로 패키징 IP 계층을 통해 데이터그램 전송 수신측 UDP가 데이터그램을 받아 애플리케이션에 전달 데이터그램 UDP는 데이터를 데이터그램이라는 단위로 전송한다.
데이터그램은 독립적인 관계를 지니는 패킷을 의미한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:21:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;500 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UDP" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/udp/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-and-communications/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/networking-and-communications/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>