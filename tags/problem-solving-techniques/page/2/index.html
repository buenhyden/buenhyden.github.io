<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem-Solving-Techniques | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/problem-solving-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/problem-solving-techniques/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/problem-solving-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/problem-solving-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Problem-Solving-Techniques"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Problem-Solving-Techniques"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Problem-Solving-Techniques</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>tail Recursion vs. Non-tail Recursion</h2></header><div class=entry-content><p>Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.
특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.
꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to tail Recursion vs. Non-tail Recursion" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Traversal</h2></header><div class=entry-content><p>Back Tracking vs. Traversal 백트래킹과 트래버설은 컴퓨터 과학에서 문제 해결과 데이터 구조 탐색에 사용되는 중요한 알고리즘 패러다임이다.
두 기법은 겉보기에 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.
백트래킹과 트래버설은 서로 다른 목적과 접근 방식을 가지고 있지만, 많은 복잡한 문제 해결에서 상호 보완적으로 사용된다.
트래버설은 데이터 구조의 모든 요소를 효율적으로 방문하는 체계적인 방법을 제공하고, 백트래킹은 방대한 해결책 공간에서 효율적으로 유망한 해결책을 찾는 전략을 제공한다.
실제 문제 해결에서는 두 개념의 장점을 결합하여 사용하는 것이 효과적이다.
예를 들어, 그래프에서 특정 조건을 만족하는 경로를 찾기 위해 DFS나 BFS와 같은 트래버설 알고리즘으로 그래프를 탐색하면서, 백트래킹 기법을 활용하여 유망하지 않은 경로는 조기에 포기하는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-12-09 14:55:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Traversal" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 가장 직관적이고 단순한 문제 해결 기법으로, 가능한 모든 경우의 수를 철저하게 조사하여 문제의 해결책을 찾는 방법이다.
“무차별 대입법” 또는 “완전 탐색"이라고도 불리는 이 접근법은 컴퓨터 과학과 알고리즘 설계에서 기본적인 방법론으로 사용된다.
브루트 포스는 가장 직관적이고 단순한 문제 해결 접근법으로, 구현이 쉽고 모든 가능한 해결책을 검사하기 때문에 완전성을 보장한다. 그러나 시간 복잡도가 높아 큰 문제에는 적합하지 않다.
실제 응용에서는 브루트 포스를 단독으로 사용하기보다는 다른 최적화 기법과 함께 사용하거나, 더 효율적인 알고리즘이 없는 경우의 대안으로 활용한다. 또한, 브루트 포스는 문제 해결의 기본 접근법으로서 다른 고급 알고리즘의 기초가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Depth-First Search</h2></header><div class=entry-content><p>Back Tracking vs. Depth-First Search 백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.
DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.
백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.
깊이 우선 탐색(Depth-First Search, DFS) 깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:55:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Depth-First Search" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>슬라이딩 윈도우 기법 (Sliding Window Technique)</h2></header><div class=entry-content><p>슬라이딩 윈도우 기법 (Sliding Window Technique) 슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.
이 기법은 “창문(window)“처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.
슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-24 00:21:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 슬라이딩 윈도우 기법 (Sliding Window Technique)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Brute Force</h2></header><div class=entry-content><p>Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.
두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.
먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.
Divide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 세 가지 주요 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Brute Force" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Branch and Bound</h2></header><div class=entry-content><p>Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.
“Divide and Conquer"와 “Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.
분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.
두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Branch and Bound" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>최적 부분 구조(Optimal Substructure)</h2></header><div class=entry-content><p>최적 부분 구조(Optimal Substructure) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.
동적 계획법이 적용되기 위해서는 두 가지 핵심 특성이 필요하다:
중복되는 하위 문제(Overlapping Subproblems) 최적 부분 구조(Optimal Substructure)
이다. 최적 부분 구조는 효율적인 알고리즘 설계의 핵심 개념이다.
문제의 특성을 이해하고 최적 부분 구조를 식별할 수 있다면, 복잡한 문제도 동적 계획법이나 그리디 알고리즘을 통해 효율적으로 해결할 수 있다.
최적 부분 구조가 없는 문제는 다른 접근 방식(예: 분할 정복, 백트래킹)을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2025-01-22 14:02:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 최적 부분 구조(Optimal Substructure)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>중복되는 하위 문제(Overlapping Subproblems)</h2></header><div class=entry-content><p>중복되는 하위 문제(Overlapping Subproblems) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.
동적 계획법이 효과적으로 적용되기 위해서는 두 가지 핵심 특성이 필요하다:
최적 부분 구조(Optimal Substructure) 중복되는 하위 문제(Overlapping Subproblems)
이다. 중복되는 하위 문제(Overlapping Subproblems)의 기본 개념 중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.
즉, 문제를 해결하는 과정에서 같은 계산이 여러 번 수행되는 경우이다.
중복되는 하위 문제가 있을 때 동적 계획법은 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피함으로써 효율성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:02:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 중복되는 하위 문제(Overlapping Subproblems)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Greedy Algorithm vs. Divide and Conquer</h2></header><div class=entry-content><p>Divide and Conquer vs. Greedy Algorithm “Divide and Conquer"와 “Greedy Algorithm"은 문제 해결을 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.
분할 정복은 정확한 최적해를 보장하지만 구현이 복잡할 수 있고, 탐욕 알고리즘은 구현이 간단하고 효율적이지만 항상 최적해를 보장하지는 않는다. 문제의 특성을 잘 이해하고 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-28 10:55:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greedy Algorithm vs. Divide and Conquer" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/problem-solving-techniques/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/problem-solving-techniques/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>