<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem-Solving-Techniques | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/problem-solving-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/problem-solving-techniques/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/problem-solving-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/problem-solving-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Problem-Solving-Techniques"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Problem-Solving-Techniques"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Problem-Solving-Techniques</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>State Representation</h2></header><div class=entry-content><p>상태 표현(State Representation) 상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.
Branch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:
문제 공간 표현: 가능한 모든 해결책(solution space)을 체계적으로 표현한다. 탐색 진행 상황 추적: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다. 한계값(bound) 계산 지원: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다. 가지치기(pruning) 결정 기반: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다. 상태 표현의 주요 특성 및 고려 사항 상태 표현의 완전성(Completeness)
상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.
불완전한 상태 표현은 최적해를 놓치게 할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Representation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>가지치기(Pruning)</h2></header><div class=entry-content><p>가지치기(Pruning) 가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.
즉, 특정 경로가 해결책으로 이어질 가능성이 없다고 판단되면, 그 경로를 더 이상 탐색하지 않고 바로 다른 경로를 탐색합니다.
가지치기의 중요성 효율성 향상: 불필요한 탐색을 줄여 알고리즘의 실행 시간을 크게 단축한다. 자원 절약: 메모리 사용량을 줄이고 CPU 자원을 효율적으로 사용한다. 실용성 증대: 가지치기 없이는 현실적으로 해결하기 어려운 복잡한 문제도 해결 가능하게 만든다. 가지치기 적용 방법 가지치기를 적용하는 핵심은 ‘유망성 테스트(promising test)‘이다.
각 단계에서 현재 상태가 최종 해결책으로 이어질 가능성이 있는지를 판단하는 함수를 만들어 사용한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 14:00:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가지치기(Pruning)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Algorithmic Thinking</h2></header><div class=entry-content><p>Algorithmic Thinking 알고리즘적 사고는 현대 디지털 사회에서 문제 해결의 핵심이 되는 인지적 접근 방식.
이는 단순히 컴퓨터 프로그래밍에만 국한되지 않고, 다양한 분야에서 체계적이고 효율적인 문제 해결을 위한 사고 방식으로 발전해왔다.
정의와 본질 알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.
이는 다음과 같은 핵심 특성을 가진다:
단계적 분해: 복잡한 문제를 작고 관리 가능한 부분들로 나누는 능력 논리적 순서화: 문제 해결 단계를 효율적이고 논리적인 순서로 배열하는 능력 추상화: 문제의 본질을 파악하고 불필요한 세부사항을 제거하는 능력 패턴 인식: 문제들 사이의 공통점을 찾고 일반화하는 능력 효율성 고려: 자원(시간, 공간 등)을 최적화하는 해결책을 모색하는 능력 알고리즘적 사고의 구성 요소 문제 분해(Decomposition)
복잡한 문제를 더 작고 관리 가능한 부분들로 나누는 과정:
...</p></div><footer class=entry-footer><span title='2024-12-27 07:00:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Algorithmic Thinking" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/algorithmic-thinking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Branching Strategies</h2></header><div class=entry-content><p>Branching Strategies Branch and Bound(분기한정법)은 조합 최적화 문제를 해결하기 위한 알고리즘 패러다임으로, 가능한 해결책의 공간을 체계적으로 탐색하여 최적의 해를 찾는 방법이다.
이 알고리즘의 핵심 요소 중 하나가 바로 ‘분기 전략(Branching Strategies)‘이다.
분기 전략은 문제 공간을 어떻게 분할하고 탐색할 것인지를 결정하며, 이는 알고리즘의 효율성과 성능에 직접적인 영향을 미친다.
문제 구조를 이해하고 적절한 분기 전략을 선택하는 것은 효율적인 알고리즘 구현을 위해 필수적이다. 변수 기반, 제약 기반, 문제 특화 분기 등 다양한 전략을 이해하고, 문제의 특성에 맞게 적용하거나 조합하는 능력이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching Strategies" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/branching-strategies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Branch and Bound vs. Backtracking</h2></header><div class=entry-content><p>Back Tracking vs. Branch and Bound 백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.
두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.
백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.
백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2025-01-10 04:36:00 +0000 UTC'>January 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branch and Bound vs. Backtracking" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/branch-and-bound-vs-backtracking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>상태 공간 트리(State Space Tree)</h2></header><div class=entry-content><p>상태 공간 트리(State Space Tree) 백트래킹 알고리즘을 제대로 이해하기 위해서는 “상태 공간 트리(State Space Tree)“라는 개념을 먼저 파악하는 것이 매우 중요하다.
이 개념은 백트래킹의 이론적 기초가 되며, 문제 해결 과정을 시각적으로 표현하는 데 도움이 된다.
이 트리는 문제 해결 과정의 모든 가능한 경로를 체계적으로 표현하며, 백트래킹은 이 트리를 효율적으로 탐색하는 방법을 제공한다.
상태 공간 트리를 잘 이해하고 설계하면 복잡한 문제도 체계적으로 접근할 수 있다.
특히 상태 표현 방법, 유효성 검사 함수, 가지치기 전략을 최적화하는 것이 효율적인 백트래킹 알고리즘을 개발하는 핵심이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:59:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상태 공간 트리(State Space Tree)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/state-space-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비꼬리 재귀(Non-tail Recursion)</h2></header><div class=entry-content><p>비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.
이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.
비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.
이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.
그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비꼬리 재귀(Non-tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/non-tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Recursion vs. Iteration</h2></header><div class=entry-content><p>Recursion vs. Iteration Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration vs. Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 11:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Recursion vs. Iteration" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/recursion-vs-iteration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Brute Force</h2></header><div class=entry-content><p>Back Tracking vs. Brute Force 브루트 포스와 백트래킹은 모두 조합 최적화 문제를 해결하는 데 사용되는 중요한 알고리즘 패러다임이다.
브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.
브루트 포스(Brute Force) 브루트 포스는 가능한 모든 경우의 수를 전부 확인하는 완전 탐색 알고리즘이다.
이 방법은 문제 해결을 위해 가능한 모든 후보해를 체계적으로 나열하고 각각을 검사한다.
브루트 포스의 작동 방식:
...</p></div><footer class=entry-footer><span title='2024-12-29 14:02:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/problem-solving-techniques/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>