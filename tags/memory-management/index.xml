<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Memory-Management</title><link>https://buenhyden.github.io/tags/memory-management/</link><description>Recent content in Memory-Management on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 25 Dec 2024 06:59:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/tags/memory-management/index.xml" rel="self" type="application/rss+xml"/><item><title>Memory Management Techniques</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/</link><pubDate>Wed, 25 Dec 2024 06:59:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/</guid><description>
&lt;h2>Memory Management Techniques&lt;span class="hx-absolute -hx-mt-20" id="memory-management-techniques">&lt;/span>
&lt;a href="#memory-management-techniques" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>운영체제의 메모리 관리 기법(Memory Management Techniques)은 컴퓨터 시스템의 제한된 메모리 자원을 효율적으로 사용하기 위한 방법들이다.&lt;br>
주요 메모리 관리 기법은 다음과 같다:&lt;/p>
&lt;p>&lt;img src="memory_management_techniques.webp" alt="Memory Management Techniques" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/memory-management-in-operating-system/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/memory-management-in-operating-system/&lt;/a> _&lt;/p>
&lt;blockquote>
&lt;p>스와핑 (Swapping)&lt;br>
스와핑은 메모리가 부족할 때 실행 중인 프로세스의 일부 또는 전체를 디스크의 특별한 영역(스왑 공간)으로 임시로 내보내고, 필요할 때 다시 메모리로 가져오는 메모리 관리 기법이다.
이는 제한된 메모리를 효율적으로 사용하여 더 많은 프로세스를 동시에 실행할 수 있게 한다.
두 가지의 작동 방식을 가지고 있다:&lt;/p>
&lt;ul>
&lt;li>Swap Out: 프로세스를 RAM에서 하드 디스크로 이동시킨다.&lt;/li>
&lt;li>Swap In: 프로세스를 하드 디스크에서 RAM으로 다시 불러온다.
CPU 활용도를 높이고, 메모리 가용성을 개선한다.
우선순위 기반 스케줄링에 유용하다.
다만, 시스템 성능에 영향을 줄 수 있으며, 디스크 I/O가 증가할 수 있다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3>연속 메모리 할당 (Contiguous Memory Allocation)&lt;span class="hx-absolute -hx-mt-20" id="연속-메모리-할당-contiguous-memory-allocation">&lt;/span>
&lt;a href="#%ec%97%b0%ec%86%8d-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%95%a0%eb%8b%b9-contiguous-memory-allocation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가장 기본적인 메모리 관리 기법으로, 프로세스에 연속된 메모리 공간을 할당하는 방식이다.&lt;/p>
&lt;ol>
&lt;li>고정 분할 (Fixed Partitioning)
&lt;ul>
&lt;li>메모리를 고정된 크기의 파티션으로 나눈다.&lt;/li>
&lt;li>각 프로세스는 하나의 파티션에 할당된다.&lt;/li>
&lt;li>내부 단편화 문제가 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가변 분할 (Variable Partitioning)&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>프로세스 크기에 따라 동적으로 메모리를 할당한다.&lt;/li>
&lt;li>외부 단편화 문제가 발생할 수 있다.&lt;/li>
&lt;li>최초 적합(First-fit), 최적 적합(Best-fit), 최악 적합(Worst-fit) 등의 할당 알고리즘이 사용된다.&lt;/li>
&lt;/ul>
&lt;h4>할당 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="할당-알고리즘">&lt;/span>
&lt;a href="#%ed%95%a0%eb%8b%b9-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>할당 알고리즘인 최초 적합(First Fit), 최적 적합(Best Fit), 최악 적합(Worst Fit)은 메모리 관리에서 프로세스를 메모리의 빈 공간에 할당하는 방법을 결정하는 알고리즘이다.&lt;/p>
&lt;ol>
&lt;li>최초 적합 (First Fit)
&lt;ul>
&lt;li>메모리를 순차적으로 검색하여 프로세스가 들어갈 수 있는 첫 번째 빈 공간에 할당한다.&lt;/li>
&lt;li>가장 간단하고 빠른 방법으로, 대부분의 경우 효율적이다.&lt;/li>
&lt;li>검색을 최소화할 수 있어 빠른 할당이 가능하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적 적합 (Best Fit)
&lt;ul>
&lt;li>프로세스 크기와 가장 비슷한 빈 공간을 찾아 할당한다.&lt;/li>
&lt;li>모든 가용 공간을 검색해야 하므로 시간이 더 걸린다.&lt;/li>
&lt;li>외부 단편화를 최소화할 수 있지만, 작은 단편들이 많이 생길 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최악 적합 (Worst Fit)
&lt;ul>
&lt;li>가장 큰 빈 공간에 프로세스를 할당한다.&lt;/li>
&lt;li>남는 공간을 최대화하여 다른 프로세스들이 사용할 수 있는 여지를 남긴다.&lt;/li>
&lt;li>큰 빈 공간을 빠르게 소진할 수 있어 장기적으로는 비효율적일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>성능 비교
&lt;ul>
&lt;li>속도: 최초 적합 &amp;gt; 최적 적합 = 최악 적합&lt;/li>
&lt;li>메모리 이용률: 최초 적합 ≈ 최적 적합 &amp;gt; 최악 적합&lt;/li>
&lt;li>구현 복잡성: 최초 적합 &amp;lt; 최적 적합 = 최악 적합&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>각 알고리즘은 상황에 따라 장단점이 있으며, 시스템의 요구사항과 특성에 맞게 선택해야 한다.&lt;br>
일반적으로 최초 적합이 간단하면서도 효율적인 성능을 보이는 경우가 많다.&lt;/p>
&lt;h3>비연속 메모리 할당(Non-Contiguous Memory Allocation)&lt;span class="hx-absolute -hx-mt-20" id="비연속-메모리-할당non-contiguous-memory-allocation">&lt;/span>
&lt;a href="#%eb%b9%84%ec%97%b0%ec%86%8d-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%95%a0%eb%8b%b9non-contiguous-memory-allocation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>프로세스의 메모리를 여러 개의 작은 블록으로 나누어 물리적 메모리의 서로 다른 위치에 할당하는 메모리 관리 기법으로 메모리 사용의 효율성을 높이고 외부 단편화를 줄이는 데 도움이 된다.&lt;/p>
&lt;ol>
&lt;li>페이징 (Paging)&lt;br>
페이징은 물리 메모리를 고정 크기의 프레임으로, 논리 메모리를 같은 크기의 페이지로 나누는 기법이다.&lt;br>
- 외부 단편화 문제를 해결한다.&lt;br>
- 페이지 테이블을 사용하여 논리 주소를 물리 주소로 변환한다.&lt;br>
- 내부 단편화가 발생할 수 있지만, 그 크기는 페이지 크기보다 작다.&lt;/li>
&lt;li>세그멘테이션 (Segmentation)&lt;br>
세그멘테이션은 프로그램을 논리적 단위(세그먼트)로 나누어 관리하는 기법.&lt;br>
- 코드, 데이터, 스택 등 논리적 단위로 메모리를 관리한다.&lt;br>
- 세그먼트 테이블을 사용하여 주소 변환을 수행한다.&lt;br>
- 외부 단편화 문제가 발생할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>가상 메모리 (Virtual Memory)&lt;span class="hx-absolute -hx-mt-20" id="가상-메모리-virtual-memory">&lt;/span>
&lt;a href="#%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%ac-virtual-memory" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가상 메모리는 물리적 메모리 크기의 제약을 극복하기 위한 기법이다.&lt;/p>
&lt;ul>
&lt;li>프로세스의 일부만 메모리에 로드하여 실행한다.&lt;/li>
&lt;li>페이지 교체 알고리즘(LRU, FIFO 등)을 사용하여 필요한 페이지만 메모리에 유지한다.&lt;/li>
&lt;li>페이지 폴트 처리를 통해 필요한 페이지를 메모리로 로드한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>가상 메모리 (Virtual Memory)</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/</link><pubDate>Fri, 20 Dec 2024 13:37:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/</guid><description>
&lt;h2>가상 메모리 (Virtual Memory)&lt;span class="hx-absolute -hx-mt-20" id="가상-메모리-virtual-memory">&lt;/span>
&lt;a href="#%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%ac-virtual-memory" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.&lt;br>
실제 물리적 메모리(RAM)의 크기에 관계없이 프로그램이 사용할 수 있는 메모리 공간을 확장하며, 프로그램의 주소 공간을 실제 메모리에서 분리하여 가상 주소 공간을 제공한다.&lt;/p>
&lt;p>가상 메모리가 필요한 이유:&lt;/p>
&lt;ol>
&lt;li>메모리 제약 극복&lt;br>
프로그램의 크기가 실제 물리적 메모리보다 클 수 있다.&lt;br>
예를 들어 16GB RAM을 가진 컴퓨터에서 20GB가 필요한 프로그램을 실행할 수 있게 된다.&lt;/li>
&lt;li>메모리 보호&lt;br>
각 프로세스는 자신만의 가상 주소 공간을 가지므로, 다른 프로세스의 메모리에 접근할 수 없다.&lt;/li>
&lt;li>메모리 효율성&lt;br>
실제로 사용되는 부분만 물리적 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="../erx44XE.jpg" alt="Virtual Memory" loading="lazy" />&lt;br>
_Source: &lt;a href="https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette" target="_blank" rel="noopener">https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette&lt;/a> _&lt;/p>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>메모리 확장: 물리적 메모리보다 큰 프로그램 실행 가능&lt;/li>
&lt;li>메모리 보호: 각 프로세스에 독립된 가상 주소 공간 제공&lt;/li>
&lt;li>효율적 메모리 사용: 필요한 부분만 물리 메모리에 적재&lt;/li>
&lt;li>다중 프로세스 실행: 여러 프로그램의 동시 실행 지원&lt;/li>
&lt;/ol>
&lt;h3>동작 원리&lt;span class="hx-absolute -hx-mt-20" id="동작-원리">&lt;/span>
&lt;a href="#%eb%8f%99%ec%9e%91-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>페이징 시스템 사용: 프로그램을 일정 크기의 페이지로 나눔&lt;/li>
&lt;li>요구 페이징: 필요한 페이지만 메모리에 적재&lt;/li>
&lt;li>페이지 테이블: 가상 주소와 물리 주소 간 매핑 정보 저장&lt;/li>
&lt;li>MMU(Memory Management Unit): 주소 변환 담당 하드웨어&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가상 메모리의 주요 장점은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>확장된 메모리 공간: 물리적 메모리 크기에 구애받지 않고 더 큰 메모리 공간을 제공한다.&lt;/li>
&lt;li>메모리 보호: 각 프로세스에 독립적인 가상 주소 공간을 제공하여 다른 프로세스의 메모리 접근을 방지한다.&lt;/li>
&lt;li>효율적인 메모리 사용: 필요한 부분만 물리 메모리에 적재하여 메모리 사용 효율을 높인다.&lt;/li>
&lt;li>다중 프로세스 실행 지원: 여러 프로그램을 동시에 실행할 수 있도록 한다.&lt;/li>
&lt;li>프로그래밍 용이성: 프로그래머가 물리적 메모리 크기를 고려하지 않고 개발할 수 있다.&lt;/li>
&lt;li>메모리 관리의 단순화: 통일된 주소 공간을 제공하여 메모리 관리를 용이하게 한다.&lt;/li>
&lt;li>시스템 안정성 향상: 프로세스 간 메모리 침범을 방지하여 시스템의 안정성을 높인다.&lt;/li>
&lt;/ol>
&lt;h3>단점&lt;span class="hx-absolute -hx-mt-20" id="단점">&lt;/span>
&lt;a href="#%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가상 메모리의 주요 단점은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>성능 저하: 가상 메모리는 하드 디스크나 SSD를 사용하기 때문에 RAM보다 훨씬 느리다. 이로 인해 애플리케이션의 속도가 느려질 수 있다.&lt;/li>
&lt;li>디스크 공간 소비: 가상 메모리는 하드 디스크 공간을 사용하므로 사용 가능한 저장 공간이 줄어든다.&lt;/li>
&lt;li>시스템 안정성 저하: 과도한 가상 메모리 사용은 시스템의 전반적인 안정성을 떨어뜨릴 수 있다.&lt;/li>
&lt;li>애플리케이션 전환 지연: 가상 메모리를 사용할 때 애플리케이션 간 전환에 더 많은 시간이 소요될 수 있다.&lt;/li>
&lt;li>스레싱(Thrashing): 물리적 메모리가 부족할 경우, 시스템이 가상 메모리와 물리적 메모리 사이를 지속적으로 전환하면서 성능이 크게 저하될 수 있다.&lt;/li>
&lt;li>저장 장치 수명 단축: SSD와 같은 저장 장치를 가상 메모리로 사용할 경우, 잦은 읽기/쓰기 작업으로 인해 장치의 수명이 단축될 수 있다.&lt;/li>
&lt;li>복잡성 증가: 가상 메모리 관리 알고리즘의 구현이 복잡하며, 이는 시스템의 전반적인 복잡성을 증가시킨다.&lt;/li>
&lt;/ol>
&lt;h4>페이지 폴트 (Page Fault)&lt;span class="hx-absolute -hx-mt-20" id="페이지-폴트-page-fault">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%80-%ed%8f%b4%ed%8a%b8-page-fault" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>페이지 폴트(Page Fault)는 프로그램이 현재 물리적 메모리(RAM)에 없는 페이지에 접근하려고 할 때 발생하는 예외 상황이다. 이는 가상 메모리 시스템에서 중요한 메커니즘이다.&lt;/p>
&lt;p>발생원인:&lt;/p>
&lt;ul>
&lt;li>요구 페이징: 필요한 페이지가 아직 메모리에 로드되지 않은 경우&lt;/li>
&lt;li>유효하지 않은 메모리 접근: 프로그램이 할당되지 않은 메모리에 접근하려 할 때&lt;/li>
&lt;li>보호 위반: 읽기 전용 페이지에 쓰기를 시도하는 경우&lt;/li>
&lt;/ul>
&lt;p>처리 과정:&lt;/p>
&lt;ul>
&lt;li>CPU가 페이지 폴트를 감지하고 운영체제에 제어권을 넘깁니다.&lt;/li>
&lt;li>운영체제는 요청된 페이지의 디스크 위치를 확인합니다.&lt;/li>
&lt;li>필요한 경우 기존 페이지를 디스크로 스왑아웃합니다.&lt;/li>
&lt;li>요청된 페이지를 디스크에서 메모리로 로드합니다.&lt;/li>
&lt;li>페이지 테이블을 업데이트하여 새 페이지 위치를 반영합니다.&lt;/li>
&lt;li>프로그램 실행을 재개합니다.&lt;/li>
&lt;/ul>
&lt;p>페이지 폴트의 종류:&lt;/p>
&lt;ul>
&lt;li>경미한 페이지 폴트: 페이지가 이미 메모리에 있지만 페이지 테이블에 등록되지 않은 경우&lt;/li>
&lt;li>주요 페이지 폴트: 페이지를 디스크에서 메모리로 가져와야 하는 경우&lt;/li>
&lt;/ul>
&lt;p>성능 영향:&lt;/p>
&lt;ul>
&lt;li>페이지 폴트 처리는 상대적으로 시간이 많이 소요되는 작업입니다.&lt;/li>
&lt;li>과도한 페이지 폴트는 시스템 성능을 크게 저하시킬 수 있습니다(스레싱).&lt;/li>
&lt;/ul>
&lt;p>최적화 전략:&lt;/p>
&lt;ul>
&lt;li>작업 세트 모델 사용: 프로세스의 자주 사용되는 페이지들을 메모리에 유지&lt;/li>
&lt;li>페이지 교체 알고리즘 최적화: LRU(Least Recently Used) 등의 효율적인 알고리즘 사용&lt;/li>
&lt;li>메모리 용량 증가: 물리적 메모리를 늘려 페이지 폴트 발생 빈도 감소&lt;/li>
&lt;/ul>
&lt;h3>가상 메모리 구현시 필요한 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="가상-메모리-구현시-필요한-알고리즘">&lt;/span>
&lt;a href="#%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b5%ac%ed%98%84%ec%8b%9c-%ed%95%84%ec%9a%94%ed%95%9c-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가상 메모리를 구현할 때 필요한 주요 알고리즘은 다음과 같다:&lt;/p>
&lt;h4>페이지 교체 알고리즘 (Page Replacement Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="페이지-교체-알고리즘-page-replacement-algorithm">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%80-%ea%b5%90%ec%b2%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-page-replacement-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>페이지 교체 알고리즘(Page Replacement Algorithm)은 운영체제에서 페이징 기반의 가상 메모리 관리를 위해 사용되는 중요한 메커니즘이다.&lt;br>
이 알고리즘은 메모리가 가득 찼을 때 어떤 페이지를 교체할지 결정한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>FIFO (First-In-First-Out)&lt;/td>
&lt;td>가장 오래된 페이지를 교체&lt;/td>
&lt;td>- 구현이 간단&lt;/td>
&lt;td>- 성능이 좋지 않음&lt;br>- Belady의 모순 발생 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LRU (Least Recently Used)&lt;/td>
&lt;td>가장 오랫동안 사용되지 않은 페이지 교체&lt;/td>
&lt;td>- 효율적&lt;br>- 지역성 원리 활용&lt;/td>
&lt;td>- 구현이 복잡&lt;br>- 추가 데이터 구조 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Optimal&lt;/td>
&lt;td>가장 오랫동안 사용되지 않을 페이지 교체&lt;/td>
&lt;td>- 이론적으로 가장 효율적&lt;/td>
&lt;td>- 실제 구현 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Second Chance (Clock)&lt;/td>
&lt;td>FIFO의 변형, 참조 비트 사용&lt;/td>
&lt;td>- FIFO보다 성능 우수&lt;br>- 구현 비교적 간단&lt;/td>
&lt;td>- FIFO의 단점 일부 존재&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Random&lt;/td>
&lt;td>무작위로 페이지 선택하여 교체&lt;/td>
&lt;td>- 구현이 매우 간단&lt;/td>
&lt;td>- 성능 예측 어려움&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Belady의 모순(Belady&amp;rsquo;s Anomaly)&lt;br>
페이지 교체 알고리즘에서 발생하는 특이한 현상으로, 페이지 프레임의 수를 증가시켰을 때 오히려 페이지 폴트(page fault)의 수가 증가하는 현상을 말한다.&lt;/p>
&lt;ul>
&lt;li>발생 원인
&lt;ol>
&lt;li>주로 FIFO(First-In-First-Out) 페이지 교체 알고리즘에서 발생한다.&lt;/li>
&lt;li>메모리 크기 증가로 인해 일부 페이지가 예상보다 일찍 교체되어 나중에 다시 필요해질 때 페이지 폴트가 발생한다.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>특징
&lt;ol>
&lt;li>직관에 반하는 현상: 일반적으로 메모리 크기가 증가하면 성능이 향상될 것으로 예상되지만, 이 경우 오히려 성능이 저하된다.&lt;/li>
&lt;li>모든 알고리즘에서 발생하지 않음: LRU(Least Recently Used)나 Optimal 알고리즘과 같은 스택 기반 알고리즘에서는 발생하지 않는다.&lt;br>
예시:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>검색 결과에 제시된 예에서, 3개의 프레임을 사용했을 때 9번의 페이지 폴트가 발생했지만, 4개의 프레임을 사용했을 때 10번의 페이지 폴트가 발생했다.&lt;br>
중요성:&lt;/li>
&lt;li>Belady의 모순은 메모리 관리 알고리즘의 선택과 최적화에 중요한 영향을 미치며, 시스템 성능에 직접적인 영향을 줄 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4>기타&lt;span class="hx-absolute -hx-mt-20" id="기타">&lt;/span>
&lt;a href="#%ea%b8%b0%ed%83%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>
&lt;p>프레임 할당 알고리즘 (Frame Allocation Algorithm):&lt;/p>
&lt;ul>
&lt;li>여러 프로세스가 존재할 때 각 프로세스에 메모리 프레임을 어떻게 할당할지 결정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>요구 페이징 알고리즘 (Demand Paging Algorithm):&lt;/p>
&lt;ul>
&lt;li>필요한 페이지만 메모리에 적재하는 방식을 구현&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>페이지 테이블 관리 알고리즘:&lt;/p>
&lt;ul>
&lt;li>가상 주소를 물리 주소로 변환하는 페이지 테이블을 효율적으로 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>스레싱 방지 알고리즘:&lt;/p>
&lt;ul>
&lt;li>과도한 페이지 부재로 인한 성능 저하를 방지하기 위한 알고리즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>가상 메모리와 물리적 메모리의 비교&lt;span class="hx-absolute -hx-mt-20" id="가상-메모리와-물리적-메모리의-비교">&lt;/span>
&lt;a href="#%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%99%80-%eb%ac%bc%eb%a6%ac%ec%a0%81-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%9d%98-%eb%b9%84%ea%b5%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>가상 메모리&lt;/th>
&lt;th>물리적 메모리&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>실제 물리적 메모리보다 큰 메모리 공간을 제공하는 추상화된 메모리&lt;/td>
&lt;td>컴퓨터에 실제로 장착된 RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주소 체계&lt;/td>
&lt;td>논리적 주소 (가상 주소)&lt;/td>
&lt;td>물리적 주소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>크기&lt;/td>
&lt;td>CPU의 주소 지정 능력에 따라 결정 (예: 32비트 시스템에서 최대 4GB)&lt;/td>
&lt;td>실제 설치된 RAM의 크기로 제한&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>접근 속도&lt;/td>
&lt;td>상대적으로 느림 (페이지 폴트 발생 시)&lt;/td>
&lt;td>빠름&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 저장 위치&lt;/td>
&lt;td>RAM과 디스크의 스왑 영역&lt;/td>
&lt;td>RAM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프로세스 격리&lt;/td>
&lt;td>각 프로세스에 독립적인 주소 공간 제공&lt;/td>
&lt;td>직접적인 격리 기능 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 관리&lt;/td>
&lt;td>운영체제가 페이징 등의 기법으로 관리&lt;/td>
&lt;td>하드웨어 수준에서 직접 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 장점&lt;/td>
&lt;td>큰 주소 공간, 메모리 효율성, 프로세스 보호&lt;/td>
&lt;td>빠른 접근 속도&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 단점&lt;/td>
&lt;td>페이지 폴트로 인한 성능 저하 가능성&lt;/td>
&lt;td>크기 제한, 비용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡성&lt;/td>
&lt;td>높음 (페이지 테이블, MMU 등 필요)&lt;/td>
&lt;td>낮음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 공유&lt;/td>
&lt;td>쉬움 (같은 물리 메모리를 다른 가상 주소에 매핑 가능)&lt;/td>
&lt;td>직접적인 공유 어려움&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>
&lt;p>정의와 구현:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 실제 하드웨어 RAM으로, CPU가 직접 접근할 수 있는 메모리.&lt;/li>
&lt;li>가상 메모리: 운영 체제가 제공하는 추상화된 메모리 공간으로, 물리적 메모리의 한계를 극복하기 위해 사용된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>용량:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 실제 설치된 RAM의 크기로 제한된다.&lt;/li>
&lt;li>가상 메모리: 하드 디스크나 SSD를 활용하여 물리적 메모리보다 큰 용량을 제공할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>속도:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 빠른 데이터 접근 속도를 제공한다.&lt;/li>
&lt;li>가상 메모리: 디스크를 사용하기 때문에 물리적 메모리보다 접근 속도가 느리다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>주소 체계:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 직접적인 물리 주소를 사용한다.&lt;/li>
&lt;li>가상 메모리: 논리적 주소를 사용하며, 이는 MMU에 의해 물리 주소로 변환된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터 지속성:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 전원이 꺼지면 저장된 정보가 손실된다.&lt;/li>
&lt;li>가상 메모리: 디스크를 활용하므로 전원이 꺼져도 일부 정보를 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메모리 관리:&lt;/p>
&lt;ul>
&lt;li>물리적 메모리: 직접적인 관리가 필요하다.&lt;/li>
&lt;li>가상 메모리: 운영 체제가 페이징 등의 기법을 통해 자동으로 관리한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>세그먼테이션 (Segmentation)</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/</link><pubDate>Fri, 20 Dec 2024 13:37:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/</guid><description>
&lt;h2>세그먼테이션 (Segmentation)&lt;span class="hx-absolute -hx-mt-20" id="세그먼테이션-segmentation">&lt;/span>
&lt;a href="#%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%85%8c%ec%9d%b4%ec%85%98-segmentation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.&lt;/p>
&lt;p>세그먼테이션의 기본 개념을 이해하기 위해, 먼저 프로그램의 구조를 생각해보자.&lt;br>
일반적인 프로그램은 코드 영역, 데이터 영역, 스택 영역 등 서로 다른 목적을 가진 영역들로 구성된다.&lt;br>
세그먼테이션은 이러한 논리적 단위들을 각각의 세그먼트로 관리한다.&lt;/p>
&lt;p>
&lt;img src="../ezgifcom-gif-maker-%2816%29.webp" alt="Sengmenation" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/segmentation-in-operating-system/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/segmentation-in-operating-system/&lt;/a> _&lt;/p>
&lt;h3>세그먼테이션의 주요 구성 요소와 작동 방식&lt;span class="hx-absolute -hx-mt-20" id="세그먼테이션의-주요-구성-요소와-작동-방식">&lt;/span>
&lt;a href="#%ec%84%b8%ea%b7%b8%eb%a8%bc%ed%85%8c%ec%9d%b4%ec%85%98%ec%9d%98-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c%ec%99%80-%ec%9e%91%eb%8f%99-%eb%b0%a9%ec%8b%9d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>세그먼트 테이블(Segment Table):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">SegmentTableEntry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">base&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 세그먼트의 시작 주소
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 세그먼트의 크기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">present&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 메모리 존재 여부
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 읽기 권한
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">write&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 쓰기 권한
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">execute&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 실행 권한
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="n">protection&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>주소 변환 과정:&lt;br>
논리적 주소는 다음과 같이 구성된다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>논리적 주소 = &amp;lt;세그먼트 번호, 오프셋&amp;gt;
물리적 주소 = 세그먼트 기준 주소 &amp;#43; 오프셋&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>예를 들어, 주소 변환을 수행하는 코드를 다음과 같이 구현할 수 있습니다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">address_translation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">segment_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">offset&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 세그먼트 테이블 엔트리 조회&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">segment&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">segment_table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">segment_number&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 범위 체크&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">offset&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">segment&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">limit&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="n">SegmentationFault&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Offset exceeds segment limit&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 접근 권한 체크&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">segment&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">protection&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="n">ProtectionFault&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;No read permission&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 물리적 주소 계산&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">physical_address&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">segment&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">base&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">offset&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">physical_address&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>가변 크기 분할:&lt;/p>
&lt;ul>
&lt;li>프로세스를 다양한 크기의 세그먼트로 나눈다.&lt;/li>
&lt;li>세그먼트 크기는 프로그램의 논리적 단위(예: 함수, 데이터 테이블)에 따라 결정된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>세그먼트 테이블:&lt;/p>
&lt;ul>
&lt;li>각 세그먼트의 정보를 저장하는 테이블을 사용한다.&lt;/li>
&lt;li>주요 정보: 세그먼트의 기본 주소(base address)와 한계(limit)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>주소 변환:&lt;/p>
&lt;ul>
&lt;li>논리 주소는 세그먼트 번호와 오프셋으로 구성된다.&lt;/li>
&lt;li>세그먼트 테이블을 참조하여 물리 주소로 변환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메모리 보호:&lt;/p>
&lt;ul>
&lt;li>세그먼트 단위로 접근 권한을 설정할 수 있어 보안성이 향상된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>공유와 보호:&lt;/p>
&lt;ul>
&lt;li>세그먼트 단위로 프로세스 간 메모리 공유가 가능하다.&lt;/li>
&lt;li>코드 세그먼트 등을 여러 프로세스가 공유할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>사용자 관점에 가까운 메모리 관리&lt;/li>
&lt;li>내부 단편화 감소&lt;/li>
&lt;li>동적 크기 조정 가능&lt;/li>
&lt;li>효율적인 메모리 공유&lt;/li>
&lt;/ol>
&lt;h3>단점&lt;span class="hx-absolute -hx-mt-20" id="단점">&lt;/span>
&lt;a href="#%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>외부 단편화 발생 가능&lt;/li>
&lt;li>세그먼트 테이블 관리 오버헤드&lt;/li>
&lt;li>복잡한 메모리 할당 및 해제 과정&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>페이징 (Paging)</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/</link><pubDate>Fri, 20 Dec 2024 13:37:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/</guid><description>
&lt;h2>페이징 (Paging)&lt;span class="hx-absolute -hx-mt-20" id="페이징-paging">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95-paging" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>먼저 페이징이 필요한 배경을 이해해보자.&lt;br>
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.&lt;br>
이는 두 가지 큰 문제를 발생시켰다:&lt;/p>
&lt;ol>
&lt;li>큰 프로그램은 메모리에 적재하기 어려웠다.&lt;/li>
&lt;li>메모리 단편화(fragmentation)가 심각했다.&lt;br>
이러한 문제를 해결하기 위해 페이징이 도입되었다.&lt;/li>
&lt;/ol>
&lt;p>페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 &amp;lsquo;페이지(page)&amp;lsquo;라 하고, 물리적 메모리의 단위를 &amp;lsquo;프레임(frame)&amp;lsquo;이라고 한다.&lt;/p>
&lt;p>
&lt;img src="../paging.webp" alt="Paging" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/paging-in-operating-system/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/paging-in-operating-system/&lt;/a> _&lt;/p>
&lt;h3>페이징 시스템의 주요 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="페이징-시스템의-주요-구성-요소">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>페이지 테이블(Page Table):&lt;/p>
&lt;ul>
&lt;li>각 프로세스마다 존재하며, 논리적 페이지 번호와 물리적 프레임 번호의 매핑 정보를 저장한다.&lt;/li>
&lt;li>페이지 테이블 엔트리(PTE)에는 다음과 같은 정보가 포함된다:
&lt;ul>
&lt;li>Valid bit: 페이지가 물리 메모리에 있는지 여부&lt;/li>
&lt;li>Protection bit: 읽기/쓰기/실행 권한&lt;/li>
&lt;li>Modified bit (Dirty bit): 페이지 내용이 변경되었는지 여부&lt;/li>
&lt;li>Referenced bit: 최근에 접근했는지 여부&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>주소 변환 과정:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>논리적 주소 = 페이지 번호(p) &amp;#43; 오프셋(d)
물리적 주소 = 프레임 번호(f) × 페이지 크기 &amp;#43; 오프셋(d)&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>예를 들어, 페이지 크기가 4KB(2¹²)이고 32비트 주소 체계를 사용한다면:&lt;/p>
&lt;ul>
&lt;li>상위 20비트는 페이지 번호&lt;/li>
&lt;li>하위 12비트는 오프셋&lt;br>
이 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TLB(Translation Lookaside Buffer):&lt;br>
페이지 테이블 접근 시간을 줄이기 위한 캐시로, 최근에 사용된 페이지 테이블 엔트리를 저장한다.&lt;br>
주소 변환 과정은 다음과 같다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>1. CPU가 논리적 주소 생성
2. TLB 검색
3. TLB Hit: 바로 물리적 주소 변환
TLB Miss: 페이지 테이블 접근 필요
4. 페이지 테이블에서 프레임 번호 확인
5. 물리적 주소로 변환하여 메모리 접근&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>다단계 페이지 테이블:&lt;br>
큰 주소 공간을 효율적으로 관리하기 위해 페이지 테이블을 여러 단계로 구성한다.&lt;br>
예를 들어 2단계 페이지 테이블의 경우:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>논리적 주소 = 외부 페이지 번호 &amp;#43; 내부 페이지 번호 &amp;#43; 오프셋&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>페이지 부재 처리(Page Fault Handling):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">handle_page_fault&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logical_address&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">is_valid_address&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logical_address&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="n">SegmentationFault&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">page_number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_page_number&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logical_address&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">has_free_frame&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">victim_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">select_victim_page&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># 페이지 교체 알고리즘 사용&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">is_dirty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">victim_page&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write_to_disk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">victim_page&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">remove_page_table_entry&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">victim_page&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">free_frame&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">allocate_free_frame&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">load_page_from_disk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">free_frame&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">update_page_table&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">free_frame&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">restart_instruction&lt;/span>&lt;span class="p">()&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;h3>페이징의 주요 특징&lt;span class="hx-absolute -hx-mt-20" id="페이징의-주요-특징">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>메모리 분할:&lt;/p>
&lt;ul>
&lt;li>논리적 메모리(프로세스)를 동일한 크기의 페이지로 나눈다.&lt;/li>
&lt;li>물리적 메모리를 동일한 크기의 프레임으로 나눈다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>주소 변환:&lt;/p>
&lt;ul>
&lt;li>논리 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용한다.&lt;/li>
&lt;li>MMU(Memory Management Unit)가 주소 변환을 수행한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>비연속적 할당:&lt;/p>
&lt;ul>
&lt;li>프로세스의 페이지들은 물리 메모리의 여러 프레임에 분산되어 저장될 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>내부 단편화:&lt;/p>
&lt;ul>
&lt;li>페이지 크기가 고정되어 있어 프로세스의 마지막 페이지에서 내부 단편화가 발생할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>페이징의 작동 방식&lt;span class="hx-absolute -hx-mt-20" id="페이징의-작동-방식">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%ec%9e%91%eb%8f%99-%eb%b0%a9%ec%8b%9d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>프로세스가 메모리에 로드될 때, 운영체제는 프로세스를 페이지 단위로 나눈다.&lt;/li>
&lt;li>각 페이지는 사용 가능한 메모리 프레임에 할당된다.&lt;/li>
&lt;li>운영체제는 페이지 테이블을 생성하여 각 페이지와 해당 프레임 간의 매핑을 유지한다.&lt;/li>
&lt;li>CPU가 메모리에 접근할 때, 논리 주소는 페이지 번호와 오프셋으로 나뉜다.&lt;/li>
&lt;li>MMU는 페이지 테이블을 참조하여 페이지 번호를 프레임 번호로 변환한다.&lt;/li>
&lt;li>프레임 번호와 오프셋을 조합하여 실제 물리 주소를 생성한다.&lt;/li>
&lt;/ol>
&lt;h3>페이징의 장점&lt;span class="hx-absolute -hx-mt-20" id="페이징의-장점">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>외부 단편화 제거: 메모리를 고정 크기로 관리하여 외부 단편화를 방지한다.&lt;/li>
&lt;li>유연한 메모리 할당: 프로세스의 페이지들을 비연속적으로 할당할 수 있다.&lt;/li>
&lt;li>메모리 보호: 페이지 단위로 접근 권한을 설정할 수 있어 보안성이 향상된다.&lt;/li>
&lt;li>가상 메모리 지원: 실제 물리 메모리보다 큰 주소 공간을 제공할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>페이징의 단점&lt;span class="hx-absolute -hx-mt-20" id="페이징의-단점">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95%ec%9d%98-%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>내부 단편화: 페이지 크기가 고정되어 있어 마지막 페이지에서 낭비가 발생할 수 있다.&lt;/li>
&lt;li>페이지 테이블 오버헤드: 큰 프로세스의 경우 페이지 테이블이 많은 메모리를 차지할 수 있다.&lt;/li>
&lt;li>주소 변환 시간: 페이지 테이블 참조로 인한 추가적인 메모리 접근이 필요하다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>메모리 보호와 안전 (Memory Protection and Safety)</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-protection-and-safety/</link><pubDate>Thu, 19 Dec 2024 08:06:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-protection-and-safety/</guid><description>
&lt;h2>메모리 보호와 안전 (Memory Protection and Safety)&lt;span class="hx-absolute -hx-mt-20" id="메모리-보호와-안전-memory-protection-and-safety">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%eb%b3%b4%ed%98%b8%ec%99%80-%ec%95%88%ec%a0%84-memory-protection-and-safety" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>메모리 보호와 안전은 현대 컴퓨터 시스템에서 매우 중요한 요소이다.&lt;/p>
&lt;p>메모리 보호는 컴퓨터 시스템에서 프로세스가 허가되지 않은 메모리 영역에 접근하는 것을 방지하는 메커니즘이다.&lt;br>
주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>프로세스 간 격리 유지&lt;/li>
&lt;li>운영 체제 커널 보호&lt;/li>
&lt;li>버그나 악성 소프트웨어로부터 시스템 보호&lt;/li>
&lt;/ol>
&lt;h3>메모리 보호 기술&lt;span class="hx-absolute -hx-mt-20" id="메모리-보호-기술">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%eb%b3%b4%ed%98%b8-%ea%b8%b0%ec%88%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>하드웨어 기반 보호&lt;span class="hx-absolute -hx-mt-20" id="하드웨어-기반-보호">&lt;/span>
&lt;a href="#%ed%95%98%eb%93%9c%ec%9b%a8%ec%96%b4-%ea%b8%b0%eb%b0%98-%eb%b3%b4%ed%98%b8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>&lt;strong>메모리 관리 장치 (MMU)&lt;/strong>: 가상 주소를 물리적 주소로 변환하고 접근 권한을 확인한다.&lt;/li>
&lt;li>&lt;strong>보호 키&lt;/strong>: 메모리 영역에 키를 할당하여 접근을 제어한다.&lt;/li>
&lt;li>&lt;strong>보호 링&lt;/strong>: 권한 수준에 따라 메모리 접근을 제어한다.&lt;/li>
&lt;li>&lt;strong>세그먼테이션&lt;/strong>: 메모리를 논리적 세그먼트로 나누어 보호한다.&lt;/li>
&lt;/ol>
&lt;h4>소프트웨어 기반 보호&lt;span class="hx-absolute -hx-mt-20" id="소프트웨어-기반-보호">&lt;/span>
&lt;a href="#%ec%86%8c%ed%94%84%ed%8a%b8%ec%9b%a8%ec%96%b4-%ea%b8%b0%eb%b0%98-%eb%b3%b4%ed%98%b8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>&lt;strong>가상 메모리&lt;/strong>: 각 프로세스에 독립적인 주소 공간을 제공한다.&lt;/li>
&lt;li>&lt;strong>주소 공간 레이아웃 랜덤화 (ASLR)&lt;/strong>: 메모리 주소를 무작위화하여 공격을 어렵게 한다.&lt;/li>
&lt;li>&lt;strong>데이터 실행 방지 (DEP)&lt;/strong>: 데이터 영역에서 코드 실행을 방지한다.&lt;/li>
&lt;/ol>
&lt;h3>메모리 안전성 (Memory Safety)&lt;span class="hx-absolute -hx-mt-20" id="메모리-안전성-memory-safety">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%95%88%ec%a0%84%ec%84%b1-memory-safety" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>메모리 안전성은 프로그램이 할당된 메모리 범위 내에서만 작동하도록 보장하는 개념이다.&lt;/p>
&lt;p>주요 이슈와 해결책은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>버퍼 오버플로우&lt;/strong>: 할당된 메모리 범위를 벗어나는 쓰기 작업으로 인한 취약점.&lt;/p>
&lt;ul>
&lt;li>해결책: 경계 검사, 안전한 문자열 처리 함수 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>메모리 누수&lt;/strong>: 할당된 메모리를 해제하지 않아 발생하는 문제.&lt;/p>
&lt;ul>
&lt;li>해결책: 자동 메모리 관리 (가비지 컬렉션), 스마트 포인터 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Use-after-free&lt;/strong>: 해제된 메모리에 접근하는 문제.&lt;/p>
&lt;ul>
&lt;li>해결책: 안전한 메모리 할당/해제 패턴 사용, 정적 분석 도구 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>최신 트렌드와 기술&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-기술">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%ea%b8%b0%ec%88%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>메모리 안전 언어 사용&lt;/strong>: Rust, Go, Swift 등 메모리 안전성을 보장하는 언어의 채택이 증가하고 있다.&lt;/li>
&lt;li>&lt;strong>하드웨어 기반 메모리 보호 강화&lt;/strong>: Intel SGX, ARM TrustZone 등 하드웨어 수준의 보안 기술이 발전하고 있다.&lt;/li>
&lt;li>&lt;strong>동적 테인팅&lt;/strong>: 런타임에 데이터 흐름을 추적하여 메모리 접근을 제어하는 기술이 개발되고 있다.&lt;/li>
&lt;li>&lt;strong>CHERI (Capability Hardware Enhanced RISC Instructions)&lt;/strong>: 하드웨어 수준에서 메모리 보호를 강화하는 새로운 아키텍처가 연구 중이다.&lt;/li>
&lt;li>&lt;strong>멀티팩터 인증 (MFA) 기술의 발전&lt;/strong>: 메모리 보안을 포함한 전반적인 시스템 보안을 강화하는 데 기여하고 있다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Thrashing</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/thrashing/</link><pubDate>Wed, 18 Dec 2024 00:08:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/thrashing/</guid><description>
&lt;h2>스래싱 (Thrashing)&lt;span class="hx-absolute -hx-mt-20" id="스래싱-thrashing">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1-thrashing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>스래싱은 운영체제에서 발생하는 성능 저하 현상으로, 프로세스의 실제 작업 시간보다 페이지 교체(페이징)에 더 많은 시간을 소비하는 현상을 말한다.&lt;/p>
&lt;p>이를 더 쉽게 이해하기 위해 실생활의 예시를 들어보자.&lt;br>
작은 책상에서 여러 개의 큰 책을 동시에 참고하며 공부하는 상황을 상상해보자.&lt;br>
책상이 너무 작아서 한 번에 펼칠 수 있는 책의 수가 제한적이라, 새로운 책을 보기 위해서는 기존에 펼쳐져 있던 책을 닫고 치워야 한다. 만약 연관된 내용을 위해 계속해서 다른 책을 번갈아가며 봐야 한다면, 실제 공부하는 시간보다 책을 꺼내고 넣는 시간이 더 많아질 것이다. 이것이 바로 컴퓨터에서 일어나는 스래싱 현상과 유사하다.&lt;/p>
&lt;h3>스래싱이 발생하는 과정&lt;span class="hx-absolute -hx-mt-20" id="스래싱이-발생하는-과정">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1%ec%9d%b4-%eb%b0%9c%ec%83%9d%ed%95%98%eb%8a%94-%ea%b3%bc%ec%a0%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>시작 단계:&lt;/p>
&lt;ul>
&lt;li>시스템에서 다수의 프로세스가 실행된다.&lt;/li>
&lt;li>각 프로세스는 자신의 페이지를 메모리에 로드하려 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메모리 부족 발생:&lt;/p>
&lt;ul>
&lt;li>실제 물리 메모리보다 더 많은 페이지가 요구된다.&lt;/li>
&lt;li>운영체제는 페이지 교체를 시작한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>스래싱 발생:&lt;/p>
&lt;ul>
&lt;li>한 프로세스의 페이지를 내보내면, 다른 프로세스가 그 공간을 사용한다.&lt;/li>
&lt;li>하지만 곧 이전 프로세스가 내보낸 페이지가 다시 필요하게 된다.&lt;/li>
&lt;li>이러한 과정이 계속해서 반복된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>스래싱의 주요 특징과 영향&lt;span class="hx-absolute -hx-mt-20" id="스래싱의-주요-특징과-영향">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1%ec%9d%98-%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95%ea%b3%bc-%ec%98%81%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>시스템 성능:&lt;/p>
&lt;ul>
&lt;li>CPU 활용률이 급격히 감소합니다.&lt;/li>
&lt;li>디스크 I/O가 급증합니다.&lt;/li>
&lt;li>시스템 응답 시간이 현저히 늘어납니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>사용자 경험:`&lt;/p>
&lt;ul>
&lt;li>프로그램의 실행 속도가 매우 느려집니다.&lt;/li>
&lt;li>시스템이 멈춘 것처럼 보일 수 있습니다.&lt;/li>
&lt;li>전반적인 시스템 반응성이 떨어집니다.&lt;br>
`&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>스래싱 해결을 위한 방법들&lt;span class="hx-absolute -hx-mt-20" id="스래싱-해결을-위한-방법들">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1-%ed%95%b4%ea%b2%b0%ec%9d%84-%ec%9c%84%ed%95%9c-%eb%b0%a9%eb%b2%95%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>예방적 접근:&lt;/p>
&lt;ul>
&lt;li>적절한 메모리 할당 정책 수립&lt;/li>
&lt;li>프로세스 수의 제한&lt;/li>
&lt;li>작업 세트(Working Set) 모델 적용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>대응적 접근:&lt;/p>
&lt;ul>
&lt;li>페이지 부재 빈도(PFF) 모니터링&lt;/li>
&lt;li>로컬 교체 정책 사용&lt;/li>
&lt;li>메모리 증설 고려&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>운영체제 레벨의 해결책:&lt;/p>
&lt;ul>
&lt;li>프로세스 우선순위 조정&lt;/li>
&lt;li>페이지 교체 알고리즘 최적화&lt;/li>
&lt;li>메모리 관리 정책 개선&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>스래싱을 모니터링하는 방법&lt;span class="hx-absolute -hx-mt-20" id="스래싱을-모니터링하는-방법">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1%ec%9d%84-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>시스템 지표 관찰:&lt;/p>
&lt;ul>
&lt;li>페이지 폴트(Page Fault) 발생 빈도&lt;/li>
&lt;li>CPU 사용률 변화&lt;/li>
&lt;li>디스크 I/O 활동량&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 모니터링 도구 사용:&lt;/p>
&lt;ul>
&lt;li>운영체제의 성능 모니터&lt;/li>
&lt;li>리소스 모니터링 툴&lt;/li>
&lt;li>시스템 로그 분석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>스래싱 예방을 위한 실용적인 팁&lt;span class="hx-absolute -hx-mt-20" id="스래싱-예방을-위한-실용적인-팁">&lt;/span>
&lt;a href="#%ec%8a%a4%eb%9e%98%ec%8b%b1-%ec%98%88%eb%b0%a9%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%8b%a4%ec%9a%a9%ec%a0%81%ec%9d%b8-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>프로그램 설계 시:&lt;/p>
&lt;ul>
&lt;li>메모리 사용량을 최적화합니다.&lt;/li>
&lt;li>필요한 데이터만 메모리에 로드합니다.&lt;/li>
&lt;li>효율적인 메모리 관리 기법을 사용합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>시스템 운영 시:&lt;/p>
&lt;ul>
&lt;li>적절한 가상 메모리 크기를 설정합니다.&lt;/li>
&lt;li>동시 실행 프로세스 수를 제한합니다.&lt;/li>
&lt;li>주기적인 시스템 모니터링을 수행합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>메모리 관리 (Memory Management)</title><link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/</link><pubDate>Tue, 15 Oct 2024 17:18:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/</guid><description>
&lt;h2>메모리 관리 (Memory Management)&lt;span class="hx-absolute -hx-mt-20" id="메모리-관리-memory-management">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac-memory-management" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>운영체제의 핵심 기능 중 하나로, 컴퓨터의 주 메모리를 효율적으로 관리하는 역할을 한다.&lt;/p>
&lt;p>목적:&lt;/p>
&lt;ul>
&lt;li>프로세스 간 메모리 할당 및 해제&lt;/li>
&lt;li>사용 중인 메모리 공간 추적&lt;/li>
&lt;li>메모리 단편화 최소화&lt;/li>
&lt;li>주 메모리의 효율적 활용&lt;/li>
&lt;/ul>
&lt;h3>주요 메모리 관리 기법&lt;span class="hx-absolute -hx-mt-20" id="주요-메모리-관리-기법">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac-%ea%b8%b0%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>페이징 (Paging)&lt;span class="hx-absolute -hx-mt-20" id="페이징-paging">&lt;/span>
&lt;a href="#%ed%8e%98%ec%9d%b4%ec%a7%95-paging" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>물리 메모리를 고정 크기의 블록(페이지)으로 나눔&lt;/li>
&lt;li>프로세스의 가상 주소 공간도 같은 크기의 페이지로 나눔&lt;/li>
&lt;li>장점:&lt;br>
외부 단편화 문제 해결, 가상 메모리 구현 용이&lt;/li>
&lt;li>단점:&lt;br>
내부 단편화 발생 가능&lt;/li>
&lt;/ul>
&lt;h4>세그멘테이션 (Segmentation)&lt;span class="hx-absolute -hx-mt-20" id="세그멘테이션-segmentation">&lt;/span>
&lt;a href="#%ec%84%b8%ea%b7%b8%eb%a9%98%ed%85%8c%ec%9d%b4%ec%85%98-segmentation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>프로세스를 논리적 단위(세그먼트)로 나눔&lt;/li>
&lt;li>각 세그먼트는 서로 다른 크기를 가질 수 있음&lt;/li>
&lt;li>장점:&lt;br>
논리적 분할로 보안성 향상, 공유와 보호 용이&lt;/li>
&lt;li>단점:&lt;br>
외부 단편화 발생 가능&lt;/li>
&lt;/ul>
&lt;h4>가상 메모리 (Virtual Memory)&lt;span class="hx-absolute -hx-mt-20" id="가상-메모리-virtual-memory">&lt;/span>
&lt;a href="#%ea%b0%80%ec%83%81-%eb%a9%94%eb%aa%a8%eb%a6%ac-virtual-memory" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>물리적 메모리보다 큰 주소 공간 제공&lt;/li>
&lt;li>하드 디스크를 RAM의 확장으로 사용&lt;/li>
&lt;li>장점:&lt;br>
더 큰 프로그램 실행 가능, 멀티태스킹 효율 향상&lt;/li>
&lt;li>단점:&lt;br>
물리적 메모리보다 접근 속도 느림&lt;/li>
&lt;/ul>
&lt;h3>메모리 할당 방식&lt;span class="hx-absolute -hx-mt-20" id="메모리-할당-방식">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ed%95%a0%eb%8b%b9-%eb%b0%a9%ec%8b%9d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>연속 할당: 프로세스에 연속된 메모리 공간 할당&lt;/li>
&lt;li>비연속 할당: 프로세스를 여러 조각으로 나누어 할당 (페이징, 세그멘테이션)&lt;/li>
&lt;/ol>
&lt;h3>메모리 관리의 주요 문제와 해결 방안&lt;span class="hx-absolute -hx-mt-20" id="메모리-관리의-주요-문제와-해결-방안">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%eb%a6%ac%ec%9d%98-%ec%a3%bc%ec%9a%94-%eb%ac%b8%ec%a0%9c%ec%99%80-%ed%95%b4%ea%b2%b0-%eb%b0%a9%ec%95%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>메모리 단편화:&lt;/p>
&lt;ul>
&lt;li>외부 단편화: 프로그램들 사이에 발생하는 작은 빈 공간들&lt;/li>
&lt;li>내부 단편화: 할당된 메모리의 일부가 사용되지 않는 현상&lt;/li>
&lt;li>해결방안: 메모리 압축, 페이징 기법 사용&lt;/li>
&lt;/ul>
&lt;p>페이지 교체: 메모리가 부족할 때 어떤 페이지를 디스크로 내보낼지 결정해야 합니다. 다양한 교체 알고리즘(LRU, FIFO 등)이 사용된다.&lt;/p>
&lt;p>스래싱(Thrashing): 페이지 교체가 너무 빈번하게 일어나 실제 작업보다 페이지 교체에 더 많은 시간을 소요하는 현상. 적절한 메모리 할당과 프로세스 수 조절로 해결할 수 있습니다.&lt;/p>
&lt;p>현대적인 메모리 관리 기술:&lt;/p>
&lt;ul>
&lt;li>메모리 압축: 사용하지 않는 메모리 영역을 압축하여 더 많은 공간을 확보하는 기술입니다.&lt;/li>
&lt;li>대용량 페이지: 더 큰 크기의 페이지를 사용하여 페이지 테이블의 크기를 줄이고 성능을 향상시키는 기술입니다.&lt;/li>
&lt;li>NUMA(Non-Uniform Memory Access): 멀티프로세서 시스템에서 메모리 접근 시간을 최적화하는 기술입니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item></channel></rss>