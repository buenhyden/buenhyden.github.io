<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Version-Control-Systems | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/version-control-systems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/version-control-systems/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/version-control-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/version-control-systems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Version-Control-Systems"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Version-Control-Systems"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Version-Control-Systems</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Flow</h2></header><div class=entry-content><p>Git Flow Git Flow는 Vincent Driessen이 2010년 제안한 Git 브랜치 관리 전략으로, 프로젝트의 개발, 릴리스, 유지보수를 효과적으로 수행할 수 있도록 고안되었다. 각 브랜치의 역할을 명확히 정의하여 협업과 코드 품질을 향상시킨다. 주요 브랜치로는 main, develop, feature, release, hotfix가 있으며, 각 브랜치는 특정 목적에 따라 생성되고 병합된다.
핵심 개념 브랜치 기반의 워크플로우 모델로, 각 브랜치가 명확한 목적과 생명주기를 가지고 있다. 이를 통해 기능 개발, 릴리즈 준비, 버그 수정 등의 작업을 체계적으로 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/git-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git</h2></header><div class=entry-content><p>Git Git은 2005년 리누스 토르발스(Linus Torvalds)가 개발한 분산형 버전 관리 시스템으로, 코드 변경 이력을 체계적으로 추적하고 협업을 최적화한다. 각 개발자가 전체 저장소의 복사본을 로컬에 보유하며, 변경 사항을 로컬에서 커밋하고, 필요 시 원격 저장소와 동기화한다. 이를 통해 오프라인에서도 작업이 가능하며, 병합 및 분기 기능이 강력하여 협업에 유리하다.
Git의 핵심 설계 철학은 데이터를 일련의 스냅샷으로 저장하는 접근 방식으로, 다른 버전 관리 시스템과 차별화된다. 각 커밋은 프로젝트 파일의 전체 상태를 캡처하며, 변경되지 않은 파일은 이전 버전에 대한 링크로 효율적으로 저장된다. 이러한 구조는 빠른 성능, 데이터 무결성, 분산 작업 환경을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Basic Commands</h2></header><div class=entry-content><p>Git Basic Commands Git Basic Commands는 버전 관리 시스템인 Git을 사용하기 위한 필수 명령어들의 집합입니다. 이 명령어들은 코드의 버전 관리, 협업, 이력 추적을 가능하게 하는 기본 도구이다. init, clone, add, commit, push, pull 등의 핵심 명령어들은 모든 Git 사용자가 일상적으로 사용하는 작업의 기반을 형성한다. 이러한 기본 명령어들을 이해하고 숙달하는 것은 효과적인 소프트웨어 개발과 팀 협업의 필수 요소이다.
핵심 개념 Git Basic Commands는 저장소 초기화, 변경사항 추적, 커밋 생성, 원격 저장소와의 동기화를 수행하는 기본 명령어들의 집합이다. 예를 들어, git add는 변경된 파일을 커밋 대상으로 지정하고, git commit은 실제로 변경 사항을 저장소에 기록한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:12:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Basic Commands" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-basic-commands/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitHub Flow</h2></header><div class=entry-content><p>GitHub Flow GitHub Flow는 GitHub에서 제안한 브랜치 전략으로, 메인 브랜치(main)와 기능 브랜치(feature)만을 사용하여 개발과 배포를 진행한다. 각 기능은 별도의 브랜치에서 개발되며, Pull Request를 통해 코드 리뷰와 테스트를 거친 후 메인 브랜치에 병합된다. 이러한 방식은 빠른 피드백과 지속적인 배포를 가능하게 한다.
Git Flow의 복잡성을 제거하고 웹 기반 애플리케이션 개발에 최적화된 워크플로우로, main 브랜치를 중심으로 기능 브랜치를 활용하여 빠른 개발 주기와 안정적인 배포를 동시에 달성할 수 있다.
핵심 개념 메인 브랜치(main): 항상 배포 가능한 상태를 유지하는 브랜치이다. 기능 브랜치(feature): 새로운 기능이나 수정 사항을 개발하는 브랜치로, 작업 완료 후 Pull Request를 통해 메인 브랜치에 병합된다. 모든 작업은 설명적인 이름의 기능 브랜치에서 수행한다.
정기적인 커밋과 원격 저장소 푸시
승인 후 즉시 main 브랜치에 병합되며 즉시 배포된다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitHub Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/github-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Internals</h2></header><div class=entry-content><p>Git Git Internals는 Git 버전 관리 시스템의 내부 작동 원리와 구조를 다룬다. 이는 Git이 파일의 변경사항을 어떻게 추적하고, 저장하며, 관리하는지에 관한 심층적인 이해를 제공한다.
Git의 내부 구조는 객체 모델(Blob, Tree, Commit, Tag), 인덱스(Staging Area), 참조(References), 해시 함수(SHA-1) 등으로 구성된다. Git Internals를 이해함으로써 개발자는 더 효율적인 버전 관리와 협업을 수행할 수 있으며, 복잡한 Git 문제를 해결하고 Git을 최대한 활용할 수 있다. 이 주제는 Git의 표면적인 명령어 사용법을 넘어서, Git이 어떻게 설계되고 동작하는지에 대한 근본적인 이해를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-29 09:40:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Internals" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-internals/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitLab Flow</h2></header><div class=entry-content><p>GitLab Flow GitLab Flow는 GitLab에서 제안한 브랜치 전략으로, 기능 중심 개발과 이슈 추적을 통합하여 소프트웨어 개발을 간소화한다. 이는 GitFlow의 복잡성을 줄이고, GitHub Flow의 단순함을 유지하면서도 다양한 배포 환경을 지원하는 유연성을 제공한다.
핵심 개념 GitLab Flow의 핵심 개념은 다음과 같다:
업스트림 퍼스트(Upstream First): 항상 상위 환경으로 먼저 병합하는 원칙 이슈 추적 통합: GitLab 이슈와 머지 리퀘스트(MR)의 긴밀한 연계 상황별 워크플로우: 프로젝트 특성에 따라 선택 가능한 세 가지 모델 메인 브랜치: main: 배포 가능한 코드 보유. 환경 브랜치: 개발, 스테이징, 프로덕션 등 각 배포 환경에 대응하는 장수 브랜치 staging, pre-prod, production: 단계별 테스트 및 배포. 기능 브랜치: 새로운 기능 개발을 위한 단기 브랜치 feature/*: 기능 개발 후 main에 병합. 풀 리퀘스트: 코드 리뷰 및 병합 프로세스. graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|병합| staging[staging] staging -->|병합| pre-prod[pre-prod] pre-prod -->|병합| production[production] ▲ GitLab Flow 환경 브랜치 워크플로우[3][6]
https://www.linkedin.com/pulse/gitlab-flow-jadson-santos
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitLab Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/gitlab-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Branching and Merging</h2></header><div class=entry-content><p>Branching and Merging Branching and Merging은 Git 과 같은 분산 버전 관리 시스템에서 핵심적인 기능이다. 브랜칭은 독립적인 작업 공간을 생성하여 여러 개발자가 동시에 작업할 수 있게 하며, 머징은 이러한 작업 결과를 하나의 코드베이스로 통합한다. 이를 통해 병렬 개발, 기능 분리, 코드 안정성 유지 등이 가능해진다. Git, SVN, Mercurial 등 다양한 버전 관리 시스템에서 지원되며, 현대 소프트웨어 개발의 필수 요소이다.
핵심 개념 Branching (브랜칭): 코드베이스의 복사본 생성으로 기능 개발/버그 수정을 격리한다. Merging (머징): 분리된 변경 사항을 메인 코드베이스에 통합하는 과정이다. HEAD: 현재 작업 중인 브랜치의 최신 커밋을 가리키는 포인터이다. graph TD main[main] -->|분기| feature[feature/login] feature -->|머지| main main -->|배포| Production 목적 병렬 개발 환경 제공 코드 충돌 최소화 기능별/작업별 독립적 개발 지원 안정적인 배포 프로세스 구축 필요성 다수의 개발자가 동시에 작업하는 환경에서 협업 효율성 증대 프로덕션 코드의 안정성 보장 실험적 기능 개발과 버그 수정의 분리 코드 리뷰와 품질 관리 용이성 주요 기능 브랜치 생성/삭제 브랜치 전환 (Checkout) 코드 병합 (Merge) 리베이스 (Rebase) 충돌 해결 (Conflict Resolution) 특징 분산형 개발 지원 비선형적 개발 이력 관리 원격 저장소와의 동기화 다양한 병합 전략 제공 장점과 단점 구분 항목 설명 ✅ 장점 병렬 개발 여러 기능을 동시에 개발 가능 안정성 메인 브랜치의 안정성 유지 실험 용이성 실험적 기능을 안전하게 테스트 롤백 용이성 문제 발생 시 쉽게 이전 상태로 복구 ⚠ 단점 복잡성 브랜치가 많아지면 관리가 복잡 충돌 발생 병합 시 코드 충돌 가능성 학습 곡선 초보자에게 어려운 개념 리소스 사용 브랜치별 리소스 사용량 증가 주요 원리 구성 요소 기능 역할 HEAD 현재 브랜치 참조 현재 작업 중인 브랜치를 가리킴 Branch Pointer 커밋 참조 특정 커밋을 가리키는 포인터 Commit Object 변경사항 저장 코드 변경 내용과 메타데이터 저장 Tree Object 디렉토리 구조 파일과 디렉토리 구조 표현 Merge Base 공통 조상 커밋 브랜치 분기점 식별 Branching 브랜칭의 주요 원리는 포인터 기반의 참조 시스템이다:
...</p></div><footer class=entry-footer><span title='2024-09-28 09:56:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching and Merging" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branching-and-merging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SVN Mercurial Overview</h2></header><div class=entry-content><p>SVN Mercurial Overview SVN(Subversion)과 Mercurial은 소프트웨어 개발에서 코드의 변경 이력을 관리하고 협업을 지원하는 버전 관리 시스템이다. SVN은 중앙 집중형(Centralized) 시스템으로, 모든 버전 이력이 중앙 서버에 저장된다. 반면, Mercurial은 분산형(Distributed) 시스템으로, 각 개발자가 전체 저장소를 로컬에 복제하여 작업한다. 각 시스템은 저장 방식, 협업 모델, 성능 등에서 차이가 있으며, 프로젝트의 특성과 요구사항에 따라 적절한 시스템을 선택해야 한다.
핵심 개념 SVN (Subversion) SVN은 Apache Software Foundation에서 개발한 중앙 집중식 버전 관리 시스템이다.
핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-28 04:19:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SVN Mercurial Overview" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Trunk-based Development</h2></header><div class=entry-content><p>Trunk-based Development Trunk-based Development(TBD)는 모든 개발자가 단일 메인 브랜치(trunk)에 작고 빈번한 변경사항을 직접 통합하는 버전 관리 방법론이다. 이는 지속적 통합(CI)과 지속적 배포(CD)의 필수 전제조건으로, 현대 DevOps 환경에서 가장 효율적인 브랜치 전략으로 인정받고 있다. 긴 수명의 기능 브랜치 대신 짧은 수명의 브랜치나 직접 커밋을 통해 코드 통합의 마찰을 최소화하고, 항상 배포 가능한 상태의 코드베이스를 유지하는 것이 핵심이다.
핵심 개념 Trunk-based Development의 핵심 개념은 다음과 같다:
단일 메인 브랜치: 모든 개발이 하나의 trunk(main/master) 브랜치에 집중 작고 빈번한 커밋: 작업을 작은 단위로 나누어 자주 통합 짧은 수명의 브랜치: 필요한 경우 최대 1-2일 이내의 피처 브랜치 사용 지속적 통합: 하루에 여러 번 코드 통합 및 자동화된 테스트 항상 릴리스 가능한 상태: trunk는 언제나 프로덕션 배포가 가능한 상태 유지 피처 플래그: 미완성 기능을 main에 통합하되 런타임에 비활성화 graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|자동 배포| Production 목적 코드 통합의 복잡성과 병합 충돌 최소화 개발 및 배포 속도 극대화 지속적 통합/배포(CI/CD) 실현 팀 협업 효율성 향상 코드베이스의 일관성과 품질 유지 빠른 피드백 사이클 구현 필요성 현대 DevOps 및 애자일 개발 방법론의 요구사항 충족 마이크로서비스 아키텍처에서의 빠른 배포 필요 대규모 개발팀의 효율적인 협업 지원 병합 지옥(merge hell) 방지 지속적 배포를 통한 경쟁력 확보 고품질 소프트웨어의 빠른 출시 요구 역할 개발 프로세스 단순화: 복잡한 브랜치 모델 제거 배포 주기 가속화: 빠른 릴리스 사이클 지원 품질 보증: 지속적인 테스트를 통한 품질 유지 팀 협업 강화: 코드 리뷰와 페어 프로그래밍 촉진 기술 부채 방지: 장기 브랜치로 인한 기술 부채 최소화 특징 브랜치 최소화 통합의 빈도 극대화 Feature Toggle 사용 권장 Conflict를 예방하는 설계 주요 기능 직접 trunk 커밋: 소규모 팀의 경우 trunk에 직접 커밋 Pull Request 워크플로우: 코드 리뷰를 위한 짧은 수명의 브랜치 자동화된 테스트: 모든 커밋에 대한 자동 테스트 실행 피처 플래그: 기능의 점진적 롤아웃 지원 지속적 통합: 자동화된 빌드 및 테스트 파이프라인 브랜치별 CI: PR/브랜치 단위 자동화 검증 주요 원리 Trunk-based Development의 주요 원리는 다음 다이어그램으로 표현할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trunk-based Development" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/trunk-based-development/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Submodule</h2></header><div class=entry-content><p>Git Submodule Git Submodule 은 하나의 Git 저장소 안에 또 다른 Git 저장소를 포함시킬 수 있도록 하는 기능이다. 이는 외부 라이브러리, 공통 모듈, 또는 서드파티 코드 등을 독립적으로 유지하며 주 저장소와 연동하여 사용하는 데 활용된다.
서브모듈은 특정 커밋을 참조하는 방식으로 작동하며, 주 저장소 (부모 저장소) 와 서브모듈 저장소 (자식 저장소) 간의 명확한 경계를 유지한다.
복잡한 프로젝트 구조에서 모듈화를 실현하고, 공통 코드의 버전 동기화 및 유지관리를 용이하게 한다.
핵심 개념 Git Submodule은 한 Git 저장소 (부모 저장소) 내에 다른 Git 저장소 (자식 저장소) 를 현재 저장소의 하위 디렉토리로 포함시키는 방식이다. 서브모듈은 다른 외부 저장소의 특정 커밋을 가리키는 주 저장소 내의 기록이다. 서브모듈은 매우 정적이며 특정 커밋만 추적한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Submodule" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-submodule/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/version-control-systems/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>