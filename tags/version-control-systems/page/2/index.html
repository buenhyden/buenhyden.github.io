<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Version-Control-Systems | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/version-control-systems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/version-control-systems/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/version-control-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/version-control-systems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Version-Control-Systems"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Version-Control-Systems"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Version-Control-Systems</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Snapshot vs. Delta</h2></header><div class=entry-content><p>Snapshot vs. Delta 스냅샷(Snapshot)과 델타(Delta)는 데이터 변화를 관리하는 두 가지 근본적인 접근 방식이다.
스냅샷: 특정 시점의 전체 시스템 상태를 저장한다. Git이 대표적으로, 각 커밋 시 프로젝트 전체의 파일 상태를 기록한다. 델타: 이전 버전 대비 변경된 부분만 저장한다. SVN, CVS 등 전통적 VCS에서 사용되며, 저장 공간 효율성이 장점이다. 이 두 방식은 저장 효율성, 성능, 복구 속도에서 차이를 보이며, 현대 시스템에서는 버전 관리 시스템(Git, SVN 등), 백업 솔루션, 데이터베이스 시스템 등 여러 컴퓨팅 분야에서 중요하게 사용된다. 또한, 두 방식의 혼합하여 사용하는 하이브리드 접근법(예: Git의 git gc를 통한 델타 압축)도 활용된다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:01:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Snapshot vs. Delta" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/vcs-theory/snapshot-vs-delta/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Submodule</h2></header><div class=entry-content><p>Git Submodule Git Submodule 은 하나의 Git 저장소 안에 또 다른 Git 저장소를 포함시킬 수 있도록 하는 기능이다. 이는 외부 라이브러리, 공통 모듈, 또는 서드파티 코드 등을 독립적으로 유지하며 주 저장소와 연동하여 사용하는 데 활용된다.
서브모듈은 특정 커밋을 참조하는 방식으로 작동하며, 주 저장소 (부모 저장소) 와 서브모듈 저장소 (자식 저장소) 간의 명확한 경계를 유지한다.
복잡한 프로젝트 구조에서 모듈화를 실현하고, 공통 코드의 버전 동기화 및 유지관리를 용이하게 한다.
핵심 개념 Git Submodule은 한 Git 저장소 (부모 저장소) 내에 다른 Git 저장소 (자식 저장소) 를 현재 저장소의 하위 디렉토리로 포함시키는 방식이다. 서브모듈은 다른 외부 저장소의 특정 커밋을 가리키는 주 저장소 내의 기록이다. 서브모듈은 매우 정적이며 특정 커밋만 추적한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Submodule" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/git-workflow/git-submodule/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Subtree</h2></header><div class=entry-content><p>Git Subtree Git Subtree 는 Git 에서 제공하는 저장소 관리 도구로, 하나의 저장소 안에 다른 저장소를 포함시켜 관리할 수 있게 해주는 기능이다. 서브모듈 (Submodule) 의 대안으로 개발되었으며, 주요 저장소 (상위 저장소) 에 하위 저장소의 파일들을 직접 포함시키는 방식으로 작동한다. Git Subtree 는 복잡한 프로젝트 구조에서 코드 재사용, 공유 라이브러리 관리, 여러 저장소의 통합 관리에 유용하며, 특히 상위 저장소에서 하위 저장소의 코드를 직접 수정하고 원래 하위 저장소에 변경사항을 반영할 수 있다는 점이 큰 특징이다. 이러한 기능은 팀 협업, 라이브러리 관리, 마이크로서비스 구조의 개발 등에서 활용된다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:08:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Subtree" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/git-workflow/git-subtree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VCS comparison</h2></header><div class=entry-content><p>VCS Comparison 버전 관리 시스템(VCS, Version Control System)은 소스 코드의 변경 이력을 추적하고 관리하는 도구이다. 이를 통해 개발자는 코드의 변경 사항을 기록하고, 이전 버전으로의 복원, 병합, 분기 등의 작업을 효율적으로 수행할 수 있다.
VCS는 중앙 집중형(Centralized)과 분산형(Distributed)으로 구분되며, 각각의 시스템은 특정한 아키텍처와 기능을 제공한다. 대표적인 VCS로는 RCS, CVS, SVN, Git, Mercurial 등이 있으며, 각 시스템은 개발 환경과 팀의 요구 사항에 따라 선택된다.
이 시스템들은 시간적으로 진화해왔으며, 각기 다른 아키텍처와 접근 방식을 가지고 있다. RCS는 1980년대 초에 등장한 가장 초기의 시스템으로 단일 파일의 버전 관리에 중점을 두었다. CVS는 RCS를 기반으로 하되 다중 파일과 다중 개발자 지원을 추가했다. SVN은 CVS의 제한사항을 극복하기 위해 개발되었으며, 디렉토리 구조 관리와 원자적 커밋을 도입했다.
...</p></div><footer class=entry-footer><span title='2024-09-28 04:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VCS comparison" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/vcs-theory/vcs-comparison/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Submodule vs. Subtree</h2></header><div class=entry-content><p>Git Submodule vs. Subtree 깃 (Git) 은 소프트웨어 개발에서 널리 사용되는 분산형 버전 관리 시스템으로, 복잡한 프로젝트를 효율적으로 관리할 수 있게 해준다. 대규모 프로젝트에서는 종종 여러 저장소 (repository) 에 분산된 코드를 하나의 프로젝트 내에서 통합해야 하는 필요성이 생긴다. 이러한 필요성을 해결하기 위해 깃은 두 가지 주요 접근 방식인 서브모듈 (Submodule) 과 서브트리 (Subtree) 를 제공한다.
Git Submodule 과 Git Subtree 는 모두 하나의 Git 프로젝트 안에서 다른 Git 저장소를 하위 프로젝트처럼 관리하기 위한 방식이다. 하지만 방법은 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Submodule vs. Subtree" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/git-workflow/git-submodule-vs-subtree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Conflict Resolution</h2></header><div class=entry-content><p>Conflict Resolution Git 충돌 해결 (Conflict Resolution) 은 협업 개발 과정에서 발생하는 코드 충돌을 식별하고 해결하는 프로세스로, 3-way merge 알고리즘을 기반으로 한다. 여러 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고, 해결하는 전략과 도구, 워크플로우를 포함한다. 주요 단계는 충돌 탐지 → 수동/자동 해결 → 검증으로 구성되며, 최근 AI 기반 자동화 도구들이 주목받고 있다.
핵심 개념 Git 충돌 해결 (Conflict Resolution) 은 두 개 이상의 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고 해결하는 과정이다. 충돌은 Git 이 변경사항을 자동으로 병합할 수 없을 때 발생하며, 개발자가 수동으로 어떤 변경사항을 유지할지 결정해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:57:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Conflict Resolution" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/git-workflow/conflict-resolution/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Hooks</h2></header><div class=entry-content><p>Git Hooks Git Hooks 는 Git 워크플로우의 특정 이벤트 (커밋, 푸시 등) 가 발생할 때 자동으로 실행되는 사용자 정의 스크립트이다. 이 스크립트들은 소스 코드 관리, 품질 보증, 배포 자동화 등 다양한 목적으로 활용된다. Git Hooks 는 클라이언트 측과 서버 측으로 나뉘며, 로컬 개발 환경에서의 코드 검증부터 원격 저장소에서의 배포 자동화까지 광범위한 워크플로우를 지원한다. 이를 통해 개발자들은 코딩 표준 준수, 테스트 자동화, 지속적 통합/배포 등을 효율적으로 구현할 수 있다.
핵심 개념 Git Hooks 는 Git 작업 이벤트 트리거에 반응하는 자동화 스크립트이다. .git/hooks 디렉토리에 위치하며, 실행 가능한 권한이 부여된 스크립트 파일 형태로 존재한다. 이벤트는 커밋 생성, 브랜치 전환, 원격 저장소로의 푸시 등 Git 워크플로우의 다양한 시점에서 발생할 수 있으며 사전/사후 작업을 실행한다.
...</p></div><footer class=entry-footer><span title='2024-10-28 12:38:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Hooks" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/git-workflow/git-hooks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P2P and Hybrid VCS</h2></header><div class=entry-content><p>P2P And Hybrid VCS P2P VCS 는 Git 과 같은 분산형 버전 관리 시스템의 진화된 형태로 노드 간 직접 통신으로 센서리스 아키텍처를 구현하며, 하이브리드 VCS 는 메타데이터 관리를 중앙서버에서 처리한다. 주요 구성 요소로 DHT(분산 해시 테이블), 암호화 검증 계층, 자동 동기화 엔진이 포함된다. 도전 과제로 네트워크 지연 시간 최적화와 대규모 분산 트랜잭션 관리가 존재한다.
Radicle 과 같은 솔루션은 분산 네트워크에서 Git 기반 협업을, Perforce Helix 와 같은 시스템은 하이브리드 접근 방식을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-26 06:17:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P2P and Hybrid VCS" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/advanced-topics/p2p-and-hybrid-vcs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitOps and IaC</h2></header><div class=entry-content><p>GitOps and IaC GitOps 와 IaC(Infrastructure as Code) 는 현대 DevOps 환경에서 인프라스트럭처 관리를 자동화하고 코드화하는 핵심 방법론이다.
GitOps 는 Git 을 단일 진실의 소스 (Single Source of Truth) 로 활용하여 애플리케이션과 인프라의 배포를 자동화하는 접근 방식이다. IaC 는 인프라를 코드로 정의하여 자동화된 프로비저닝과 관리를 가능하게 한다. 이 두 가지 개념은 클라우드 네이티브 환경에서 자동화된 배포 파이프라인, 선언적 인프라 정의, 버전 관리 및 감사 기능을 통해 인프라와 애플리케이션 관리를 혁신하고 있다. 이 두 방법론을 결합하여 조직은 인프라스트럭처 프로비저닝, 애플리케이션 배포, 구성 관리를 자동화하고 일관성 있게 유지하며, 변경 사항을 추적하고 필요시 롤백할 수 있다.
ArgoCD 와 FluxCD 는 Kubernetes 환경에서 GitOps 를 구현하는 주요 도구이며, Terraform 은 다양한 클라우드 환경에서 IaC 를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:15:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitOps and IaC" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/advanced-topics/gitops-and-iac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Code Review Best Practices</h2></header><div class=entry-content><p>Code Review Best Practices **Version Control Systems (VCS)**에서 Code Review Best Practices는 코드 품질 향상과 팀 협업 강화를 위한 핵심 프로세스입니다. 소프트웨어 개발 과정에서 동료 개발자가 작성한 코드를 검토하여 품질을 향상시키고, 버그를 사전에 방지하며, 지식 공유를 촉진하는 역할을 한다. 2025 년 현재 AI 통합, 자동화된 검토 도구, 지표 기반 평가가 주요 트렌드로 부상하며, Git 을 중심으로 한 워크플로우 최적화가 중요시된다.
핵심 개념 및 목적 코드 리뷰는 한 개발자가 작성한 코드를 다른 개발자가 검토하는 체계적인 프로세스이다. 주로 풀 리퀘스트 (Pull Request) 또는 머지 리퀘스트 (Merge Request) 를 통해 이루어지며, 코드의 품질, 가독성, 기능성 및 표준 준수 여부를 평가한다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Review Best Practices" href=https://buenhyden.github.io/posts/software-engineering/devops-and-platform-engineering/version-control-systems/collaboration/code-review-best-practices/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/version-control-systems/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/version-control-systems/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>