<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Authentication-Methods | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/authentication-methods/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/authentication-methods/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/authentication-methods/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/authentication-methods/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Authentication-Methods"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Authentication-Methods"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Authentication-Methods</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/protocols/authorization-and-delegation/oauth/oauth-2.0/oauth-20-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/jwt/jwt-vs-oauth-20/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/token-based-authentication-vs-saml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. JWT</h2></header><div class=entry-content><p>Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.
기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. JWT" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/token-based-authentication-vs-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OAuth</h2></header><div class=entry-content><p>Token Authentication vs. OAuth 2.0 토큰 인증(Token Authentication)과 OAuth 2.0은 모두 사용자 인증 및 권한 부여를 처리하는 기술이지만, 목적과 구현 방식에 있어 중요한 차이점을 가지고 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자가 자격 증명(일반적으로 사용자 이름과 비밀번호)을 한 번 제공한 후, 서버가 생성한 토큰을 사용하여 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 토큰 인증의 핵심 아이디어는 사용자의 자격 증명을 한 번만 확인한 후, 서버가 서명된 토큰을 발급하여 클라이언트가 이 토큰을 사용해 자신을 인증하도록 하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OAuth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/token-based-authentication-vs-oauth-20/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OpenID Connect</h2></header><div class=entry-content><p>Token Authentication vs. OpenID Connect 현대 웹과 애플리케이션의 보안 생태계에서 인증과 권한 부여는 필수적인 요소이다. 토큰 인증(Token Authentication)과 OpenID Connect(OIDC)는 모두 이 영역에서 중요한 역할을 하지만, 목적과 기능 면에서 상당한 차이가 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 및 작동 원리 토큰 인증의 핵심 아이디어는 사용자가 로그인하면 서버가 서명된 토큰을 발급하고, 이후 모든 요청에 이 토큰을 포함시켜 사용자를 식별하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/token-based-authentication-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Cookie-Based Auth 토큰 인증(Token Authentication) 토큰 인증은 서버가 사용자의 인증 정보를 확인한 후 서명된 토큰을 발급하고, 클라이언트가 이 토큰을 이후의 요청에 포함시켜 자신을 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
작동 방식 사용자가 자격 증명(사용자 이름/비밀번호)을 서버에 제출한다. 서버는 자격 증명을 검증하고, 사용자 식별자와 권한 정보를 포함한 토큰을 생성한다. 서버는 비밀 키로 토큰에 서명하여 클라이언트에게 반환한다. 클라이언트는 이 토큰을 저장하고(주로 로컬 스토리지, 세션 스토리지 또는 메모리에 저장), 이후 요청의 Authorization 헤더에 포함시킨다. 서버는 토큰의 서명을 검증하고, 포함된 정보를 기반으로 사용자를 인증한다. 특징 무상태(Stateless): 서버는 클라이언트 상태 정보를 저장하지 않는다. 확장성: 여러 서버 간에 인증 정보를 공유할 필요가 없다. 플랫폼 독립적: 모바일 앱, SPA, API 등 다양한 클라이언트에서 사용 가능하다. 보안: 토큰에 서명을 통해 변조를 방지한다. 만료 시간 설정 가능: 토큰에 만료 시간을 포함할 수 있다. 쿠키 기반 인증(Cookie-Based Authentication) 쿠키 기반 인증은 서버가 사용자 인증 후 세션 ID를 포함한 쿠키를 클라이언트에 전송하고, 클라이언트가 이 쿠키를 모든 요청에 자동으로 포함시켜 인증하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:21:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/token-based-authentication-vs-cookie-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SAML vs. OpenID Connect</h2></header><div class=entry-content><p>SAML vs. OpenID Connect SAML(Security Assertion Markup Language)과 OpenID Connect는 모두 사용자 인증 및 권한 부여를 위한 핵심 프로토콜이지만, 역사, 구현 방식, 용도 면에서 중요한 차이점이 있다.
SAML (Security Assertion Markup Language) SAML은 2002년에 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 프레임워크이다.
핵심 특징 XML 형식으로 인증 정보를 교환 주로 엔터프라이즈 환경과 대기업에서 사용 복잡한 구현이지만 높은 보안성 제공 웹 기반 SSO(Single Sign-On)에 최적화 메타데이터를 통한 신뢰 관계 구축 작동 방식 사용자가 서비스 제공자(SP)에게 접근 요청 SP는 사용자를 신원 제공자(IdP)로 리디렉션 IdP는 사용자를 인증하고 SAML 어설션(assertion) 생성 사용자는 SAML 어설션과 함께 SP로 리디렉션 SP는 SAML 어설션을 검증하고 사용자 접근 허용 OpenID Connect (OIDC) OpenID Connect는 2014년에 OpenID Foundation에 의해 개발된 OAuth 2.0 위에 구축된 인증 레이어이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 05:36:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/protocols/federation-sso/saml/saml-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Basic Authentication</h2></header><div class=entry-content><p>Jwt vs. Basic Authentication JWT(JSON Web Token) 개요 JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA를 사용한 공개/개인 키 쌍으로 서명될 수 있다.
구조 JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분된다:
헤더(Header): 토큰 유형과 사용된 서명 알고리즘을 지정한다. 페이로드(Payload): 클레임(claim)이라고 불리는 엔티티와 추가 데이터를 포함한다. 서명(Signature): 헤더와 페이로드를 인코딩한 값과 비밀 키를 사용하여 생성된 서명이다. 결과적으로 JWT는 다음과 같은 형태를 가진다:
...</p></div><footer class=entry-footer><span title='2025-04-02 02:49:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Basic Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/jwt/jwt-vs-basic-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session-Based Auth vs. Basic Authentication</h2></header><div class=entry-content><p>Session-Based Auth vs. Basic Authentication 기본 인증(Basic Authentication) 기본 인증은 HTTP 프로토콜에 내장된 가장 단순한 인증 방식 중 하나이다. 1996년 RFC 2068에서 처음 소개되었으며, 현재는 RFC 7617에서 정의되고 있다.
작동 방식 클라이언트가 서버에 리소스를 요청한다. 인증이 필요한 리소스인 경우, 서버는 “401 Unauthorized” 응답과 함께 “WWW-Authenticate” 헤더를 전송한다. 클라이언트는 사용자 이름과 비밀번호를 콜론으로 결합한 후 Base64로 인코딩한다. 이 인코딩된 값을 “Authorization: Basic [인코딩된 값]” 형태로 헤더에 포함시켜 요청을 재전송한다. 서버는 이 헤더를 디코딩하여 사용자 이름과 비밀번호를 확인하고, 유효한 경우 리소스에 접근을 허용한다. 특징 구현이 매우 간단하다. 모든 HTTP 요청마다 인증 정보가 전송된다. Base64 인코딩은 암호화가 아니므로 HTTPS 없이는 보안에 취약하다. 사용자 세션 상태를 유지하지 않는다(Stateless) 로그아웃 메커니즘이 없다 세션 기반 인증(Session-Based Authentication) 세션 기반 인증은 서버 측에서 사용자의 상태를 유지하는 인증 방식이다. 1990년대 후반부터 웹 애플리케이션에서 널리 사용되기 시작했다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:49:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session-Based Auth vs. Basic Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/session-based-authentication/session-based-auth-vs-basic-authentication/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/authentication-methods/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>