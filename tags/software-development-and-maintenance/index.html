<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Development-and-Maintenance | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-development-and-maintenance/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-development-and-maintenance/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-development-and-maintenance/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-development-and-maintenance/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Development-and-Maintenance"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Development-and-Maintenance"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Development-and-Maintenance</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)</h2></header><div class=entry-content><p>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE) 사이트 신뢰성 엔지니어링(Site Reliability Engineering, SRE)은 IT 운영에 대한 소프트웨어 엔지니어링 접근 방식이다.
이 개념은 Google의 Ben Treynor Sloss가 2003년에 창안했으며, 소프트웨어 시스템의 안정성과 신뢰성을 유지하고 향상시키는 것을 목표로 한다.
예시를 들어, 설명해보면:
온라인 쇼핑몰을 운영하는 회사에서 SRE 팀이 다음과 같은 작업을 수행할 수 있다:
서비스 수준 목표 설정: 웹사이트 가용성 99.99%, 페이지 로드 시간 2초 이내 등의 목표를 정한다. 모니터링 시스템 구축: 실시간으로 웹사이트 트래픽, 서버 성능, 주문 처리 속도 등을 모니터링하는 대시보드를 만든다. 자동화: 서버 프로비저닝, 데이터베이스 백업, 보안 패치 적용 등의 작업을 자동화하는 스크립트를 개발한다. 장애 대응: 블랙프라이데이와 같은 대규모 세일 기간 동안 급증하는 트래픽에 대비한 대응 계획을 수립하고, 실제 장애 발생 시 신속하게 대응한다. 성능 최적화: 데이터베이스 쿼리 최적화, 캐싱 전략 수립, CDN 활용 등을 통해 웹사이트 성능을 지속적으로 개선한다. SRE는 개발팀과 운영팀 사이의 가교 역할을 하며, 소프트웨어의 안정성과 확장성을 보장하는 동시에 새로운 기능의 빠른 출시를 가능하게 한다.
이를 통해 기업은 고객에게 더 나은 서비스를 제공하고 비즈니스 목표를 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;761 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)" href=https://buenhyden.github.io/posts/devops/sre/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Twelve-Factor App methodology</h2></header><div class=entry-content><p>Twelve-Factor App Methodology 클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시한다.
12-Factor App 방법론은 다른 개발 방법론과 비교하여 다음과 같은 점에서 차별화된다:
클라우드 네이티브 애플리케이션에 최적화
12-Factor App 방법론은 클라우드 환경에서 실행되는 SaaS(Software-as-a-Service) 애플리케이션 개발에 특화되어 있다.
이는 클라우드의 확장성, 이식성, 배포 용이성을 최대한 활용할 수 있도록 설계되었다. 명확한 12가지 원칙 제시
다른 방법론들이 보다 광범위한 원칙을 제시하는 반면, 12-Factor App은 12가지 구체적인 원칙을 명확하게 정의한다. 이를 통해 개발자들은 실제 구현 시 명확한 가이드라인을 따를 수 있다. 환경 독립성 강조
12-Factor App은 코드베이스와 설정의 분리, 환경 간 격차 최소화 등을 통해 애플리케이션이 다양한 환경에서 일관되게 동작할 수 있도록 한다. 이는 개발, 스테이징, 프로덕션 환경 간의 차이를 최소화하여 배포 과정의 안정성을 높인다. 확장성과 유지보수성 중시
백엔드 서비스 분리, 프로세스 모델 적용, 포트 바인딩 등의 원칙을 통해 애플리케이션의 확장성과 유지보수성을 향상시킨다. 이는 대규모 시스템에서 특히 중요한 요소이다. 현대적인 개발 및 운영 관행 반영
지속적인 배포, 로그 처리, 관리 프로세스 등에 대한 원칙을 통해 현대적인 DevOps 관행을 자연스럽게 도입할 수 있도록 한다. 이는 애자일 방법론이나 DevOps와 잘 어울리면서도, 보다 구체적인 실천 방안을 제시한다. 12 Factors Codebase (코드베이스) 하나의 코드베이스를 버전 관리하고, 다양한 배포에 활용한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 01:40:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1170 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Twelve-Factor App methodology" href=https://buenhyden.github.io/til/2024/11/19/twelve-factor-app-methodology/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shadow Deployment</h2></header><div class=entry-content><p>Shadow Deployment Shadow Deployment는 소프트웨어 배포 전략 중 하나로, 새로운 버전의 애플리케이션을 기존 버전과 병행하여 실행하되 사용자에게는 영향을 주지 않는 방식이다.
Shadow Deployment는 새로운 버전의 애플리케이션을 프로덕션 환경에 배포하고 실제 트래픽을 복제하여 새 버전으로 전송하지만, 그 결과는 사용자에게 반환하지 않는 방식이다. 이는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있게 해준다.
Shadow Deployment는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있는 전략이다. 하지만 구현 복잡성과 리소스 사용 증가 등의 단점도 있으므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 12:47:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;508 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shadow Deployment" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/shadow-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Feature Flags</h2></header><div class=entry-content><p>Feature Flags Feature flags(또는 feature toggles)는 소프트웨어 개발에서 중요한 배포 전략 중 하나이다.
이 기술을 통해 개발자는 코드 변경 없이 런타임에 특정 기능을 활성화하거나 비활성화할 수 있다.
Feature flags는 조건문을 사용하여 코드의 특정 부분을 동적으로 제어하는 소프트웨어 개발 기법이다.
이를 통해 배포와 릴리스를 분리하고, 위험을 최소화하며 유연한 기능 관리가 가능해진다.
Feature flags는 현대적인 소프트웨어 개발에서 중요한 도구이다. 이를 효과적으로 사용하면 더 안전하고 유연한 배포 프로세스를 구축할 수 있다. 하지만 적절한 관리와 주의가 필요하며, 팀의 요구사항과 프로젝트의 특성에 맞게 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 12:36:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Feature Flags" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/feature-flags/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A/B Testing</h2></header><div class=entry-content><p>A/B Testing A/B Testing은 소프트웨어 배포 전략 중 하나로, 두 가지 이상의 버전을 사용자에게 제공하여 어떤 버전이 더 효과적인지 비교하는 방법이다.
A/B Testing은 두 가지 이상의 버전(A와 B)을 사용자 그룹에게 무작위로 제공하여 각 버전의 성능을 비교하는 실험적 접근 방식이다. 이는 웹사이트, 모바일 앱, 마케팅 캠페인 등 다양한 분야에서 사용된다.
A/B Testing은 데이터 기반의 의사결정을 가능하게 한다. 하지만 올바른 설계와 분석이 필수적이며, 단기적 결과에만 집중하지 않도록 주의해야 한다. 지속적인 학습과 개선을 통해 사용자 경험을 향상시키고 비즈니스 목표를 달성하는 데 큰 도움이 될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-28 02:14:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to A/B Testing" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/a-b-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blue-Green Deployment</h2></header><div class=entry-content><p>Blue-Green Deployment Blue-Green Deployment 은 무중단 배포 전략 중 하나로, 애플리케이션의 새 버전을 안전하고 효율적으로 배포하는 방법이다.
Blue-Green 배포는 두 개의 동일한 프로덕션 환경을 유지하는 방식이다:
Blue 환경: 현재 운영 중인 버전 Green 환경: 새로 배포할 버전
이 두 환경은 완전히 동일한 인프라와 설정을 가지고 있다. Blue-Green Deployment은 안전하고 효율적인 배포 전략이지만, 적절한 계획과 자동화가 필요하다. 조직의 요구사항과 인프라 환경에 맞게 적절히 조정하여 사용하는 것이 중요하다.
https://www.redhat.com/ko/topics/devops/what-is-blue-green-deployment
작동 원리 초기 상태: Blue 환경이 모든 프로덕션 트래픽을 처리한다. 새 버전 배포: Green 환경에 새 버전의 애플리케이션을 배포한다. 테스트: Green 환경에서 새 버전을 철저히 테스트한다. 전환: 트래픽을 Blue에서 Green으로 전환한다. 이는 보통 로드 밸런서 설정을 변경하여 수행한다. 모니터링: Green 환경을 모니터링하여 문제가 없는지 확인한다. 완료 또는 롤백: 문제가 없다면 Blue 환경을 새로운 버전으로 업데이트하거나, 문제가 있다면 Blue 환경으로 빠르게 롤백한다. 장점 무중단 배포: 사용자는 배포 과정에서 서비스 중단을 경험하지 않는다. 빠른 롤백: 문제 발생 시 즉시 이전 버전으로 전환할 수 있다. 실제 환경에서의 테스트: 프로덕션과 동일한 환경에서 새 버전을 테스트할 수 있다. 리스크 최소화: 새 버전의 문제를 사전에 발견하고 대응할 수 있다. 단점 리소스 비용: 두 개의 동일한 환경을 유지해야 하므로 비용이 증가한다. 데이터베이스 동기화: 두 환경 간 데이터베이스 동기화가 필요할 수 있다. 복잡성: 두 환경을 관리하고 전환하는 과정이 복잡할 수 있다. 구현 방법 인프라 준비: 동일한 두 환경(Blue와 Green)을 구성한다. 배포 자동화: CI/CD 파이프라인을 구축하여 Green 환경에 자동으로 배포한다. 테스트 자동화: Green 환경에서 자동화된 테스트를 실행한다. 트래픽 전환: 로드 밸런서 설정을 변경하여 트래픽을 Green으로 전환한다. 모니터링: 새 버전의 성능과 오류를 모니터링한다. 롤백 계획: 문제 발생 시 빠르게 Blue로 전환할 수 있는 계획을 수립한다. 사용 사례 웹 애플리케이션: 새로운 기능이나 UI 변경을 안전하게 배포할 때 유용하다. 마이크로서비스: 개별 서비스를 독립적으로 업데이트할 수 있다. 데이터베이스 마이그레이션: 스키마 변경이나 대규모 데이터 마이그레이션 시 활용할 수 있다. 도구 및 플랫폼 Kubernetes: 서비스와 인그레스 리소스를 활용하여 구현할 수 있다. AWS: Route 53과 Elastic Load Balancer를 사용하여 구현할 수 있다. Istio: 서비스 메시를 통해 트래픽을 제어하여 구현할 수 있다. ArgoCD: Kubernetes 환경에서 Blue-Green 배포를 자동화할 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-28 02:13:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blue-Green Deployment" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/blue-green-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Canary Deployment</h2></header><div class=entry-content><p>Canary Deployment 카나리 배포(Canary Deployment) 패턴은 새로운 버전의 애플리케이션을 점진적으로 배포하는 전략이다.
이 방식은 위험을 최소화하면서 새로운 기능이나 업데이트를 테스트할 수 있게 해준다.
카나리 배포라는 이름은 광부들이 유독 가스를 감지하기 위해 카나리아 새를 사용했던 관행에서 유래되었다.
소프트웨어 배포에서 이 개념은 다음과 같이 적용된다:
새로운 버전을 소수의 사용자 또는 서버에 먼저 배포한다. 이 ‘카나리’ 그룹의 성능과 안정성을 모니터링한다. 문제가 없다면 점진적으로 새 버전의 배포를 확대한다. https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3
Canary Deployment의 핵심 원리 점진적 롤아웃 새로운 버전의 애플리케이션을 전체 사용자가 아닌 작은 비율의 사용자 그룹에게만 먼저 제공한다.
예를 들어, 전체 트래픽의 5%만 새 버전으로 라우팅하는 것으로 시작할 수 있다. 모니터링 및 분석 새 버전으로 라우팅된 트래픽에 대해 다음과 같은 지표들을 면밀히 모니터링한다: 에러율 응답 시간 시스템 리소스 사용량 사용자 행동 패턴 비즈니스 메트릭스 점진적 확장 모니터링 결과가 긍정적이면 새 버전으로 가는 트래픽을 점진적으로 늘린다:
5% → 20% → 50% → 100%와 같은 방식으로 진행한다. 카나리 배포의 장점 위험 감소: 전체 사용자 기반에 영향을 주지 않고 실제 환경에서 새 버전을 테스트할 수 있다. 빠른 롤백: 문제 발생 시 신속하게 이전 버전으로 되돌릴 수 있다. 점진적 출시: 새 기능을 단계적으로 도입할 수 있어 시스템과 사용자에게 미치는 영향을 제어할 수 있다. 카나리 배포의 구현 단계 새 버전 준비: 배포할 새로운 버전의 애플리케이션을 준비한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 02:13:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;556 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Canary Deployment" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/canary-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rolling Deployment</h2></header><div class=entry-content><p>Rolling Deployment Rolling Deployment는 애플리케이션의 새 버전을 점진적으로 배포하는 무중단 배포 전략이다.
Rolling Deployment는 기존 버전의 인스턴스를 새 버전으로 점진적으로 교체하는 방식이다.
이 과정에서 서비스의 가용성을 유지하면서 새 버전을 배포할 수 있다.
주요 특징:
인스턴스를 하나씩 또는 작은 배치로 업데이트 전체 배포 과정 동안 서비스 유지 새 버전과 이전 버전이 일시적으로 공존 Rolling Deployment는 서비스의 연속성을 유지하면서 새 버전을 안전하게 배포할 수 있는 효과적인 전략이다.
그러나 버전 간 호환성과 데이터베이스 변경 관리에 주의가 필요하다.
조직의 요구사항과 애플리케이션 특성을 고려하여 적절히 구현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 02:13:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;264 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rolling Deployment" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/rolling-deployment/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>