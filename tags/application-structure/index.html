<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Application-Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/application-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/application-structure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/application-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/application-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Application-Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Application-Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Application-Structure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Configuration Management Patterns</h2></header><div class=entry-content><p>Configuration Management Patterns 구성 관리 패턴은 애플리케이션의 설정 정보를 효율적으로 관리하고 유지하기 위한 방법들을 정의한다.
적절한 구성 관리는 시스템의 안정성과 유연성을 보장하는 데 필수적이다.
이러한 패턴들은 다음과 같은 목적을 위해 사용된다:
유연성 향상: 애플리케이션을 재배포하지 않고도 구성을 변경할 수 있어 시스템의 유연성이 크게 향상된다. 일관성 유지: 중앙 집중식 구성 관리를 통해 여러 서비스와 환경에서 일관된 구성을 유지할 수 있다. 운영 효율성 증대: 구성 변경을 자동화하고 중앙에서 관리함으로써 운영 효율성이 높아진다. 보안 강화: 민감한 구성 정보를 애플리케이션 코드와 분리하여 관리함으로써 보안을 강화할 수 있다. 확장성 지원: 마이크로서비스 아키텍처에서 서비스의 수가 증가하더라도 효율적으로 구성을 관리할 수 있다. 버전 관리 및 추적성: 구성 변경 이력을 추적하고 필요시 이전 버전으로 롤백할 수 있다. 환경 간 이식성: 개발, 테스트, 프로덕션 등 다양한 환경에서 동일한 애플리케이션을 쉽게 실행할 수 있다. 빠른 배포 및 롤백: 구성 변경을 신속하게 적용하거나 문제 발생 시 빠르게 롤백할 수 있다. 특성 외부 구성 저장소 패턴 (External Configuration Store Pattern) Configuration-as-Code 패턴 Dynamic Configuration 패턴 정의 애플리케이션의 구성 정보를 외부 저장소로 분리하여 관리 시스템의 구성을 버전 관리가 가능한 소스 코드 형태로 정의하고 관리 애플리케이션의 구성을 런타임에 동적으로 변경할 수 있게 해주는 패턴 주요 목적 여러 환경에서 애플리케이션을 수정 없이 실행, 구성 데이터의 중앙 관리 구성의 일관성과 재현성 보장, 버전 관리를 통한 구성 변경 추적 시스템의 유연성 향상, 다운타임 없는 구성 변경 가능 구현 방법 환경 변수, 구성 파일, 전용 구성 서버, 클라우드 서비스 활용 YAML, JSON, HCL 등의 구조화된 형식 사용, 템플릿 엔진 활용 외부 구성 저장소 사용, 구성 변경 감지 메커니즘 구현 장점 환경별 구성 관리 용이, 보안 향상, 구성 정보의 버전 관리 가능 반복 가능성, 협업 개선, 감사 및 규정 준수 용이 빠른 기능 롤아웃 및 롤백, 운영 중 시스템 튜닝 가능 도전 과제 구성 저장소 접근 권한 관리, 장애 대응 필요 학습 곡선, 복잡성 관리, 보안 구성 데이터의 일관성 유지, 분산 시스템에서의 동기화 사용 사례 데이터베이스 연결 정보, API 키 관리 클라우드 인프라 구성, CI/CD 파이프라인 구성 기능 플래그 관리, 서비스 엔드포인트 동적 변경 도구 예시 Spring Cloud Config, AWS Systems Manager Parameter Store Ansible, Terraform, CloudFormation etcd, Consul, ZooKeeper 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-30 02:17:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;334 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Configuration Management Patterns" href=https://buenhyden.github.io/til/2024/12/configuration-management/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Communication Patterns</h2></header><div class=entry-content><p>Communication Patterns 통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다. 각 패턴은 특정 상황과 요구사항에 따라 선택되어 사용되며, 때로는 여러 패턴을 조합하여 사용하기도 한다.
비동기 통신 패턴과 메시지 기반 통신 패턴은 유사한 특성을 가지고 있으며, 둘 다 높은 확장성과 성능을 제공한다.
동기 통신 패턴은 구현이 간단하지만 확장성과 성능 면에서 제한적이다.
발행/구독 패턴은 가장 낮은 결합도와 높은 확장성을 제공하지만, 구현 복잡성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-28 12:41:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2083 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Communication Patterns" href=https://buenhyden.github.io/til/2024/12/communication-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Pattern</h2></header><div class=entry-content><p>Event-Driven Pattern 이 패턴은 시스템의 상태 변화를 이벤트로 표현하고, 이를 기반으로 서비스 간 통신을 구현하는 방식이다.
Event-Driven Pattern은 시스템에서 발생하는 중요한 변화나 행동을 이벤트로 정의하고, 이를 중심으로 시스템을 설계하는 아키텍처 패턴이다.
이 패턴에서는 이벤트의 생성, 전파, 처리가 시스템의 핵심 동작이 된다.
주요 특징:
비동기 통신을 기반으로 함 서비스 간 느슨한 결합 제공 실시간 데이터 처리와 반응성 향상 확장성과 유연성 증대 주요 구성 요소 Event-Driven Pattern의 주요 구성 요소는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-12-28 10:05:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1211 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Pattern" href=https://buenhyden.github.io/til/2024/12/event-driven-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>발행/구독 패턴 (Publisher-Subscriber Pattern)</h2></header><div class=entry-content><p>발행/구독 패턴 (Publisher-Subscriber Pattern) 발행/구독 패턴(Publisher-Subscriber Pattern)은 마이크로서비스 아키텍처(MSA)에서 통신 패턴 중 하나이다.
이 패턴은 컴포넌트 간의 느슨한 결합을 가능하게 하며, 확장성과 유연성을 제공한다.
발행/구독 패턴은 메시지를 생성하는 발행자(Publisher)와 메시지를 수신하는 구독자(Subscriber) 사이의 비동기 통신 모델이다.
이 패턴에서 발행자는 특정 수신자를 지정하지 않고 메시지를 발행하며, 구독자는 관심 있는 메시지 유형을 구독한다.
MSA에서의 활용 마이크로서비스 아키텍처에서 발행/구독 패턴은 다음과 같은 상황에서 유용하다:
이벤트 기반 아키텍처: 서비스 간 이벤트 전파에 사용된다. 비동기 통신: 서비스 간 느슨한 결합을 유지하면서 비동기 통신을 구현한다. 확장성: 새로운 마이크로서비스를 쉽게 추가하고 기존 서비스에 영향을 주지 않고 기능을 확장할 수 있다. 장점 낮은 결합도: 발행자와 구독자는 서로의 존재를 알 필요가 없다. 확장성: 새로운 구독자나 발행자를 쉽게 추가할 수 있다. 유연성: 다양한 컴포넌트가 메시지를 다른 방식으로 처리할 수 있다. 비동기 통신: 시스템 컴포넌트 간의 비동기 통신을 가능하게 한다. 단점 복잡성: 브로커의 로직이 복잡해질 수 있으며, 디버깅이 어려울 수 있다. 메시지 전달 보장: 일부 시스템에서는 메시지 전달을 완전히 보장하기 어려울 수 있다. 일관성: 발행자와 구독자 간의 관계 파악이 어려울 수 있다. 주요 구성 요소 발행자(Publisher): 메시지나 이벤트를 생성하고 브로커에게 전송한다. 구독자(Subscriber): 특정 유형의 메시지나 이벤트를 수신하고 처리한다. 메시지 브로커(Message Broker): 발행자와 구독자 사이에서 메시지를 중개하는 역할을 한다. 작동 방식 구독자는 메시지 브로커를 통해 관심 있는 토픽이나 메시지 유형을 구독한다. 발행자는 메시지를 생성하고 브로커에게 전송한다. 브로커는 수신한 메시지를 해당 토픽이나 유형을 구독한 모든 구독자에게 전달한다. 구독자는 수신한 메시지를 처리한다. flowchart TD Publisher-->|이벤트 발행|Topic[토픽/채널] Topic-->|구독|Subscriber1 Topic-->|구독|Subscriber2 Topic-->|구독|Subscriber3 style Topic fill:#f9f,stroke:#333,stroke-width:4px style Publisher fill:#bbf style Subscriber1 fill:#bfb style Subscriber2 fill:#bfb style Subscriber3 fill:#bfb 메시지 필터링 발행/구독 패턴에서는 두 가지 주요 필터링 방식이 있다:
...</p></div><footer class=entry-footer><span title='2024-12-28 07:05:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;723 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 발행/구독 패턴 (Publisher-Subscriber Pattern)" href=https://buenhyden.github.io/til/2024/12/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Request-Response Pattern</h2></header><div class=entry-content><p>Request-Response Pattern Request-Response Pattern은 마이크로서비스 아키텍처(MSA)에서 가장 기본적이고 널리 사용되는 통신 패턴 중 하나이다.
Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.
이는 동기식 통신의 대표적인 예로, 클라이언트는 서버로부터 응답을 받을 때까지 대기한다.
작동 방식 클라이언트가 서버에 요청을 보낸다. 서버는 요청을 받아 처리한다. 서버는 처리 결과를 응답으로 클라이언트에게 반환한다. 클라이언트는 응답을 받아 처리한다. sequenceDiagram participant Client participant Server Note over Client,Server: HTTP/REST 기반 통신 Client->>+Server: GET /users/123 Note right of Server: 리소스 처리 Server-->>-Client: 200 OK (사용자 데이터) Client->>+Server: POST /orders Note right of Server: 주문 생성 Server-->>-Client: 201 Created 구현 방식과 프로토콜 REST API 구현
REST API는 HTTP 프로토콜을 기반으로 하는 가장 보편적인 구현 방식이다.
REST는 다음과 같은 특징을 가진다:
...</p></div><footer class=entry-footer><span title='2024-12-28 06:18:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;467 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Request-Response Pattern" href=https://buenhyden.github.io/til/2024/12/request-response-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/application-structure/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>