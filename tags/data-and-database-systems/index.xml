<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data-and-Database-Systems on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/data-and-database-systems/</link>
    <description>Recent content in Data-and-Database-Systems on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.157.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 23 Sep 2025 03:56:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/data-and-database-systems/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lock Duration</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-duration/</link>
      <pubDate>Tue, 23 Sep 2025 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-duration/</guid>
      <description>락 지속시간은 트랜잭션이 특정 자원 락을 획득한 시점부터 해제·커밋으로 풀릴 때까지의 보유 기간이다. 격리수준, 2PL(Strict/Rigorous 여부), MVCC와 키-범위락, 락 에스컬레이션·타임아웃, 애플리케이션 로직이 이를 좌우한다. 지속시간은 동시성, 지연, 데드락 확률, 로그·복구 비용에 직접 영향을 준다.</description>
    </item>
    <item>
      <title>Intent Modes</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/intent-modes/</link>
      <pubDate>Mon, 22 Sep 2025 08:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/intent-modes/</guid>
      <description>의도 모드는 테이블–페이지–행 등 계층에서 하위 자원에 둘 S/X 잠금 계획을 상위에 신호해 충돌을 빠르게 판정하는 메커니즘이다. IS·IX·SIX로 탐색과 갱신이 뒤섞인 상황을 조율하고, 다중 그라뉼러리티·호환성 표·에스컬레이션과 결합해 동시성과 일관성을 높인다.</description>
    </item>
    <item>
      <title>Lock Compatibility Matrix</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/</link>
      <pubDate>Mon, 22 Sep 2025 08:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/</guid>
      <description>락 호환성 매트릭스는 DB 트랜잭션이 동일 자원에 대해 요청하는 잠금 모드의 동시 허용·차단 관계를 표로 정리한 것. S/X/U와 의도 잠금(IS/IX/SIX), 키-범위 잠금과 함께 사용되어 충돌 최소화, 팬텀 방지, 일관성과 성능의 균형 설계의 기준이 된다.</description>
    </item>
    <item>
      <title>Locking Protocols</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/</link>
      <pubDate>Mon, 22 Sep 2025 04:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/</guid>
      <description>락 프로토콜은 트랜잭션의 동시 접근을 제어해 일관성과 직렬성을 보장하는 규칙 집합이다. 대표적으로 Two-Phase Locking(공유·배타·업데이트·의도 락)과 범위 락이 있으며, MVCC·낙관적 기법과의 혼용으로 성능·무결성 간 트레이드오프를 관리한다.</description>
    </item>
    <item>
      <title>Lost Update</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/</link>
      <pubDate>Fri, 12 Sep 2025 03:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/</guid>
      <description>로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다.</description>
    </item>
    <item>
      <title>Phantom Read</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/</link>
      <pubDate>Fri, 12 Sep 2025 03:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/</guid>
      <description>팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다.</description>
    </item>
    <item>
      <title>Write Skew</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/</link>
      <pubDate>Fri, 12 Sep 2025 03:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/</guid>
      <description>Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다.</description>
    </item>
    <item>
      <title>Dirty Read</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/</link>
      <pubDate>Fri, 12 Sep 2025 03:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/</guid>
      <description>Dirty Read는 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경을 읽는 현상으로, 롤백 시 잘못된 값을 근거로 후속 연산이 발생해 무결성·재현성·감사 가능성을 해친다. 대다수 실무 환경에서는 기본 금지하고, 허용 시에는 읽기 복제본·스냅샷 사용 또는 엄격한 가드레일을 병행해야 한다.</description>
    </item>
    <item>
      <title>Serializable</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/serializable/</link>
      <pubDate>Fri, 12 Sep 2025 03:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/serializable/</guid>
      <description>Serializable은 트랜잭션 동시 실행 결과가 어떤 순차적 실행 결과와 동일하도록 보장하는 최고 격리 수준이다. 팬텀·쓰기 스큐 등 무결성 위협을 차단하지만, 락·검증·충돌 재시도로 성능 저하 및 재시도 비용이 증가하므로 핵심 업무에 선별 적용해야 한다.</description>
    </item>
    <item>
      <title>Read Committed</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/</link>
      <pubDate>Fri, 12 Sep 2025 03:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/</guid>
      <description>Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다.</description>
    </item>
    <item>
      <title>Read Uncommitted</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/</link>
      <pubDate>Fri, 12 Sep 2025 03:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/</guid>
      <description>Read Uncommitted는 SQL 표준의 최저 격리 수준으로 다른 트랜잭션의 커밋되지 않은 변경을 읽을 수 있게 허용한다. 락·스냅샷 오버헤드를 줄여 읽기 지연은 낮지만, Dirty Read·Non-repeatable Read·Phantom 같은 심각한 정합성 이상을 초래할 수 있다. 실제 영향은 DB 엔진(MVCC 여부 등)에 따라 달라지므로 사용 전 엔진 동작 확인과 재현 테스트가 필요하다.</description>
    </item>
    <item>
      <title>Repeatable Read</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/repeatable-read/</link>
      <pubDate>Fri, 12 Sep 2025 03:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/repeatable-read/</guid>
      <description>Repeatable Read는 트랜잭션 안에서 동일 쿼리의 결과가 반복되도록 보장해 Non-repeatable Read를 막는 격리 수준이다. 구현은 락(범위/next-key)과 MVCC(스냅샷) 방식으로 나뉘며, Phantom 억제 여부는 DBMS별 차이가 있어 실무 적용 전 벤더 동작과 성능 영향을 검증해야 한다.</description>
    </item>
    <item>
      <title>Lock Modes</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/</link>
      <pubDate>Wed, 27 Aug 2025 06:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/</guid>
      <description>락 모드는 자원 접근의 허용 범위를 규정해 일관성과 동시성을 관리한다. S/X/U와 Intent 계열은 계층적 락 조정에, gap/next-key/predicate 등 범위형 락은 팬텀을 방지한다. DBMS별 용어·정책 차이를 확인하고 트랜잭션 패턴에 맞춰 레벨·격리·인덱스를 조정하면 성능과 일관성 균형을 맞출 수 있다.</description>
    </item>
    <item>
      <title>MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/optimistic-concurrency-control/versioning/mvcc/</link>
      <pubDate>Wed, 27 Aug 2025 06:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/optimistic-concurrency-control/versioning/mvcc/</guid>
      <description>MVCC는 트랜잭션마다 일관된 스냅샷을 제공하기 위해 데이터의 여러 버전을 유지하는 동시성 제어 방식이다. 읽기는 기존 버전을 읽어 비차단으로 처리되고, 쓰기는 새 버전을 생성해 커밋 시 가시성이 바뀐다. 높은 읽기 동시성과 낮은 락 경합을 제공하지만 버전 누적으로 인한 저장·GC 부담과 일부 격리 이상(issue)이 존재한다.</description>
    </item>
    <item>
      <title>Data &amp; Database Systems</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/</link>
      <pubDate>Fri, 22 Aug 2025 06:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/</guid>
      <description></description>
    </item>
    <item>
      <title>Lock Granularity</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/</link>
      <pubDate>Tue, 12 Aug 2025 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/</guid>
      <description>잠금 세분성은 잠금을 적용하는 단위를 정의해 동시성 및 관리 오버헤드의 균형을 결정하는 핵심 설계 요소다. 세분화는 동시성을 높이나 메타데이터·추적 비용을 증가시키며, 의도잠금·계층적 잠금·에스컬레이션과 워크로드 기반 튜닝으로 실무적 트레이드오프를 관리한다.</description>
    </item>
    <item>
      <title>Transaction</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/</link>
      <pubDate>Sun, 10 Aug 2025 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/</guid>
      <description>**트랜잭션(Transaction)**은 데이터베이스에서 상태를 변화시키는 여러 작업을 하나의 논리적 단위로 묶어 처리하는 기술이다. ACID (Atomicity, Consistency, Isolation, Durability) 속성을 보장하여 시스템 오류나 동시성 문제에도 데이터의 무결성과 신뢰성을 유지한다. 트랜잭션의 **격리 수준(Isolation Level)**을 조절하여 데이터 일관성과 성능 사이의 균형을 맞추며, 분산 시스템에서는 2상 커밋(2-Phase Commit) 같은 프로토콜을 통해 여러 노드에 걸친 작업의 원자성을 보장한다. 이처럼 트랜잭션은 현대 소프트웨어의 안정적 데이터 관리에 필수적인 핵심 메커니즘이다.</description>
    </item>
    <item>
      <title>ACID Properties</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/acid-properties/</link>
      <pubDate>Thu, 15 May 2025 02:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/acid-properties/</guid>
      <description>ACID는 데이터베이스 트랜잭션이 전부 수행 또는 전부 취소(원자성), 일관된 규칙 준수(일관성), 동시 실행 간 간섭 방지(격리성), **결과 영구 저장(지속성)**을 보장하는 원칙이다. 이를 통해 장애나 동시성 경쟁 상황에서도 데이터 무결성과 신뢰성을 유지하며, 현대 DB·분산 환경 설계의 핵심 기반이 된다.</description>
    </item>
    <item>
      <title>Transaction Isolation</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/</link>
      <pubDate>Mon, 12 May 2025 14:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/</guid>
      <description>트랜잭션 격리(Transaction Isolation)는 ACID 속성 중 하나로, 동시에 실행되는 트랜잭션 간 간섭을 제어해 데이터 일관성을 보장한다. SQL 표준 격리 수준은 Read Uncommitted, Read Committed, Repeatable Read, Serializable로, 각 수준에 따라 Dirty/Non-Repeatable/Phantom Read 허용 여부와 성능이 달라진다.</description>
    </item>
    <item>
      <title>Replication</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-architecture/scalability--distribution/replication/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-architecture/scalability--distribution/replication/</guid>
      <description>복제 (Replication) 는 데이터나 서비스의 사본을 여러 노드나 시스템에 분산 저장하는 기법으로, 시스템의 가용성, 내결함성, 확장성을 향상시킨다. 주로 마스터 - 슬레이브, 다중 마스터, 액티브 - 액티브와 같은 아키텍처로 구현되며, 동기식 또는 비동기식 복제 방식을 사용한다. CAP 이론에 따라 일관성과 가용성 사이의 균형을 고려해 설계된다.</description>
    </item>
    <item>
      <title>Transaction Isolation Levels</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/</link>
      <pubDate>Thu, 06 Feb 2025 04:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/</guid>
      <description>트랜잭션 격리 수준(Transaction Isolation Level)은 DBMS가 동시에 실행되는 트랜잭션 간 데이터 접근·갱신 방식을 제어해 Dirty Read, Non-repeatable Read, Phantom Read 등을 방지하는 메커니즘이다. SQL-92 표준의 4단계(Read Uncommitted~Serializable)와 Lock·MVCC 기반 구현을 통해 성능과 일관성 간 균형을 조정한다.</description>
    </item>
    <item>
      <title>Locking</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/</link>
      <pubDate>Thu, 24 Oct 2024 15:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/</guid>
      <description>락킹은 동시 트랜잭션이 같은 데이터를 안전하게 다루게 하는 메커니즘으로, 공유·배타·의도락 등 다양한 모드와 행·페이지·테이블 단위로 접근을 제어한다. 2PL 계열은 직렬성을 보장하지만 데드락과 대기 비용이 생기므로 MVCC나 낙관적 기법과 조합해 성능·일관성의 균형을 맞춘다. 분산 환경에서는 네트워크·타임 동기 문제를 추가로 고려해야 한다.</description>
    </item>
    <item>
      <title>데이터베이스 최적화 (Database Optimization)</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/database-optimization/</link>
      <pubDate>Tue, 22 Oct 2024 06:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/database-optimization/</guid>
      <description>데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 다양한 기법과 프로세스를 의미한다.</description>
    </item>
    <item>
      <title>Indexing</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-modeling/physical-design/indexing/</link>
      <pubDate>Tue, 22 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-modeling/physical-design/indexing/</guid>
      <description>인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조</description>
    </item>
    <item>
      <title>Pessimistic Locking vs. Optimistic Concurrency Control(OCC)</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/</link>
      <pubDate>Wed, 02 Oct 2024 02:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/</guid>
      <description>Pessimistic Locking과 Optimistic Concurrency Control  데이터 무결성 보장을 위한 두 가지 대표 동시성 제어 전략이다. 전자는 충돌을 사전에 차단하고, 후자는 충돌 발생 시 검증한다. 충돌 빈도, 시스템 환경, 성능 요구에 따라 적절히 선택해야 한다.</description>
    </item>
  </channel>
</rss>
