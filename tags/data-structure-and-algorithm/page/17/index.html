<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structure-and-Algorithm | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structure-and-algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structure-and-algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structure-and-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structure-and-algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structure-and-Algorithm"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structure-and-Algorithm"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structure-and-Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>큐 (Queue)</h2></header><div class=entry-content><p>큐 (Queue) 큐 (Queue)는 “선입선출(FIFO: First In First Out)” 원칙을 따르는 데이터 구조이다.
즉, 가장 먼저 삽입된 요소가 가장 먼저 제거된다.
FIFO (First In First Out)
먼저 들어온 데이터가 가장 먼저 나가는 원칙
프로세스 스케줄링, 프린터 대기열, 네트워크 패킷 처리 등에 사용
실생활 예시: 은행 창구 대기열 프린터 인쇄 대기열 식당 주문 처리 작동 방식: Enqueue (삽입): 새로운 데이터는 큐의 뒤쪽(rear)에 추가됨 Dequeue (제거): 가장 먼저 들어온 데이터가 앞쪽(front)에서 제거됨 1 2 3 4 5 Enqueue(1) → [1] Enqueue(2) → [1,2] Enqueue(3) → [1,2,3] Dequeue() → 반환: 1, 큐: [2,3] Dequeue() → 반환: 2, 큐: [3] ![Queue Data Structure](Queue-Data-structure1.png “https://www.geeksforgeeks.org/queue-data-structure/?ref=outind _
...</p></div><footer class=entry-footer><span title='2024-11-08 05:53:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;729 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 큐 (Queue)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linear Data Structure vs Non-Linear Data Structure</h2></header><div class=entry-content><p>Linear Data Structure Vs Non-Linear Data Structure 데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.
측면 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적 또는 선형적으로 배열된 구조 데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조 구조 단일 레벨 구조 다중 레벨 구조 데이터 관계 요소 간 1:1 관계 요소 간 1:N 또는 N:N 관계 순회 단일 실행으로 모든 요소 순회 가능 단일 실행으로 모든 요소 순회 불가능 구현 복잡성 구현이 상대적으로 간단 구현이 상대적으로 복잡 메모리 사용 메모리 사용이 덜 효율적 메모리 사용이 더 효율적 시간 복잡도 입력 크기에 따라 증가 특정 작업에서 더 효율적 데이터 접근 순차적 접근 계층적 또는 네트워크 기반 접근 삽입/삭제 상대적으로 간단 더 복잡하지만 유연함 응용 분야 간단한 데이터 저장 및 처리 복잡한 관계 표현, AI, 이미지 처리 등 예시 배열, 연결 리스트, 스택, 큐 트리, 그래프, 해시 테이블, 힙 공통점:
...</p></div><footer class=entry-footer><span title='2024-11-06 11:00:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;641 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linear Data Structure vs Non-Linear Data Structure" href=https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Primitive data structure vs Non-Primitive data structure</h2></header><div class=entry-content><p>Primitive Data Structure Vs Non-Primitive Data Structure Primitive Data Structure Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.
주요 특징 단순성: 가장 기본적이고 이해하기 쉬운 데이터 타입이다. 고정 크기: 일반적으로 고정된 메모리 크기를 가진다. 효율성: 메모리 사용과 접근 시간 측면에서 매우 효율적이다. 직접 표현: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다. 값 의미론: 변수에 실제 값이 직접 저장된다. 스택 할당: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다. 주요 primitive data structure들을 비교 분석하여 정리한 표:
...</p></div><footer class=entry-footer><span title='2024-11-06 08:39:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1085 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Primitive data structure vs Non-Primitive data structure" href=https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>최적화 알고리즘 (Optimization Algorithms)</h2></header><div class=entry-content><p>최적화 알고리즘 (Optimization Algorithms) 주어진 문제에 대해 가장 효율적이거나 최적의 해결책을 찾기 위해 사용되는 방법론.
최적화 알고리즘은 특정 목적 함수(Objective Function)의 최대값이나 최소값을 찾는 데 사용된다.
머신러닝에서는 주로 손실 함수(Loss Function)를 최소화하여 모델의 성능을 향상시키는 데 활용된다.
장점:
복잡한 문제에 대한 효율적인 해결책 제공 자동화된 학습 과정 지원 다양한 분야에 적용 가능 계산 효율성 향상 단점:
일부 알고리즘은 지역 최적해(local optima)에 빠질 수 있음 하이퍼파라미터 조정의 어려움 계산 비용이 높을 수 있음 복잡한 문제에서 수렴 속도가 느릴 수 있음 특징 반복적인 과정을 통해 해를 개선 목적 함수의 특성에 따라 다양한 알고리즘 존재 그래디언트(기울기) 정보를 활용하는 경우가 많음 수렴 속도와 정확도 사이의 트레이드오프 존재 주요 종류 수학적 최적화 알고리즘 선형 계획법(Linear Programming) 선형 제약 조건과 목적 함수를 다룸
...</p></div><footer class=entry-footer><span title='2024-11-06 06:03:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;285 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 최적화 알고리즘 (Optimization Algorithms)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/optimization-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>암호화 알고리즘 (Encryption Algorithm)</h2></header><div class=entry-content><p>암호화 알고리즘 (Encryption Algorithm) 암호화는 평문(원본 데이터)을 암호문(암호화된 데이터)으로 변환하는 과정이다.
이 과정에서 특정 키를 사용하며, 이 키 없이는 암호문을 해독할 수 없도록 설계된다.
현대의 암호화 알고리즘은 수학적 원리를 기반으로 하여 매우 높은 수준의 보안을 제공한다.
특징 기밀성: 허가되지 않은 사용자가 데이터를 읽을 수 없도록 한다. 무결성: 데이터가 변조되지 않았음을 보장한다. 인증: 데이터의 출처를 확인할 수 있게 한다. 부인 방지: 송신자가 메시지 전송을 부인할 수 없게 한다. 주요 암호화 알고리즘 분류 대칭키 암호화 (Symmetric Key Encryption) 특징 동일한 키로 암호화와 복호화를 수행 빠른 처리 속도 비교적 단순한 구조 주요 알고리즘 AES (Advanced Encryption Standard) 가장 널리 사용되는 표준 암호화 알고리즘 128비트, 192비트, 256비트 키 크기 지원 높은 보안성과 효율성 활용: 금융 거래, 데이터 저장, 통신 보안 DES (Data Encryption Standard) 과거의 표준 암호화 알고리즘 56비트 키 사용 현재는 보안 강도가 낮아 권장되지 않음 역사적 중요성을 가짐 3DES (Triple DES) DES를 세 번 적용하여 보안성 강화 112비트 또는 168비트 키 사용 DES보다 안전하지만 속도가 느림 레거시 시스템에서 여전히 사용 비대칭키 암호화 (Asymmetric Key Encryption) 특징 공개키와 개인키 쌍을 사용 높은 보안성 키 교환 문제 해결 처리 속도가 상대적으로 느림 주요 알고리즘 RSA (Rivest-Shamir-Adleman) 가장 널리 사용되는 공개키 암호화 방식 소인수분해의 어려움을 기반으로 함 디지털 서명에도 사용 활용: SSL/TLS, 전자서명, 키 교환 ECC (Elliptic Curve Cryptography) 타원곡선의 수학적 특성을 이용 RSA보다 짧은 키로 동등한 보안성 제공 모바일 기기에 적합 활용: 모바일 보안, IoT 기기 해시 함수 (Hash Functions) 특징 단방향 암호화 고정된 길이의 출력 생성 충돌 저항성 주요 알고리즘 SHA (Secure Hash Algorithm) SHA-256, SHA-384, SHA-512 등 다양한 변형 높은 보안성 블록체인에서 널리 사용 활용: 패스워드 저장, 무결성 검증 MD5 (Message Digest Algorithm 5) 128비트 해시값 생성 현재는 취약점이 발견되어 보안용도로 권장되지 않음 무결성 검사에 제한적으로 사용 최신 트렌드와 미래 방향 양자 암호화
...</p></div><footer class=entry-footer><span title='2024-11-05 15:29:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;385 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 암호화 알고리즘 (Encryption Algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/encryption-algorithm/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/data-structure-and-algorithm/page/16/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/data-structure-and-algorithm/page/18/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>