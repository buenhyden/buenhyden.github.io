<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structure-and-Algorithm | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structure-and-algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structure-and-algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structure-and-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structure-and-algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structure-and-Algorithm"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structure-and-Algorithm"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structure-and-Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Hash Map vs Hash Map vs Hash Table</h2></header><div class=entry-content><p>Concurrent Hash Map Vs Hash Map Vs Hash Table 특성 Concurrent HashMap HashMap HashTable 동기화 세그먼트/버킷 단위의 부분 동기화 지원 동기화 지원하지 않음 메서드 단위의 전체 동기화 지원 동시성 높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능) 동시성 지원하지 않음 (단일 스레드 환경용) 낮은 동시성 (한 번에 하나의 스레드만 접근 가능) 성능 동시 접근 시 높은 성능 단일 스레드에서 가장 높은 성능 동기화로 인한 성능 저하 null 허용 key와 value 모두 null 불가 key는 하나만 null 허용, value는 여러 개 null 허용 key와 value 모두 null 불가 초기 용량 기본 16, 세그먼트 수는 16 기본 16 기본 11 적재율 기본 0.75 기본 0.75 기본 0.75 이터레이션 fail-safe 이터레이터 제공 fail-fast 이터레이터 제공 fail-fast 이터레이터 제공 생성 시기 Java 5 Java 1.2 Java 1.0 메모리 사용 세그먼트로 인한 추가 메모리 필요 가장 적은 메모리 사용 동기화로 인한 추가 메모리 필요 용도 멀티스레드 환경의 동시성이 필요한 경우 단일 스레드 환경의 일반적인 경우 레거시 코드 호환성이 필요한 경우 확장성 동적 확장 가능 동적 확장 가능 동적 확장 가능 순서 보장 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 동기화 비용 부분적 동기화로 중간 수준의 비용 동기화 비용 없음 전체 동기화로 높은 비용 스레드 안전성 스레드 안전 스레드 안전하지 않음 스레드 안전 키 충돌 처리 체이닝 방식 체이닝 방식 체이닝 방식 참고로 몇 가지 중요한 추가 설명을 하자면:
...</p></div><footer class=entry-footer><span title='2024-10-12 14:35:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Hash Map vs Hash Map vs Hash Table" href=https://buenhyden.github.io/til/2024/10/12/concurrent-hash-map-vs-hash-map-vs-hash-table/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Data Structure</h2></header><div class=entry-content><p>Concurrent Data Structure Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조이다.
전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.
Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계된 데이터 구조입니다.
Concurrent Data Structure는 일반적으로 다음과 같은 방식으로 구현된다:
세밀한 락(fine-grained locking) 사용 락 없는(lock-free) 알고리즘 대기 없는(wait-free) 알고리즘 지연된 삭제와 메모리 재사용 기법 이러한 구조는 고성능 멀티스레드 시스템, 데이터베이스, 운영체제, 네트워크 스택 등 다양한 분야에서 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-12 12:55:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;383 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Data Structure" href=https://buenhyden.github.io/til/2024/10/12/concurrent-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linear Data Structure vs Non-Linear Data Structure</h2></header><div class=entry-content><p>Non-Primitive Linear Data Structure Vs Non-Linear Data Structure 데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.
측면 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적 또는 선형적으로 배열된 구조 데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조 구조 단일 레벨 구조 다중 레벨 구조 데이터 관계 요소 간 1:1 관계 요소 간 1:N 또는 N:N 관계 순회 단일 실행으로 모든 요소 순회 가능 단일 실행으로 모든 요소 순회 불가능 구현 복잡성 구현이 상대적으로 간단 구현이 상대적으로 복잡 메모리 사용 메모리 사용이 덜 효율적 메모리 사용이 더 효율적 시간 복잡도 입력 크기에 따라 증가 특정 작업에서 더 효율적 데이터 접근 순차적 접근 계층적 또는 네트워크 기반 접근 삽입/삭제 상대적으로 간단 더 복잡하지만 유연함 응용 분야 간단한 데이터 저장 및 처리 복잡한 관계 표현, AI, 이미지 처리 등 예시 배열, 연결 리스트, 스택, 큐 트리, 그래프, 해시 테이블, 힙 공통점:
...</p></div><footer class=entry-footer><span title='2024-10-12 11:00:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linear Data Structure vs Non-Linear Data Structure" href=https://buenhyden.github.io/til/2024/10/12/linear-data-structure-vs-non-linear-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Primitive data structure vs Non-Primitive data structure</h2></header><div class=entry-content><p>Primitive Data Structure Vs Non-Primitive Data Structure Primitive Data Structure Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.
주요 특징 단순성: 가장 기본적이고 이해하기 쉬운 데이터 타입이다. 고정 크기: 일반적으로 고정된 메모리 크기를 가진다. 효율성: 메모리 사용과 접근 시간 측면에서 매우 효율적이다. 직접 표현: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다. 값 의미론: 변수에 실제 값이 직접 저장된다. 스택 할당: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다. 주요 primitive data structure들을 비교 분석하여 정리한 표:
...</p></div><footer class=entry-footer><span title='2024-10-12 08:39:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1085 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Primitive data structure vs Non-Primitive data structure" href=https://buenhyden.github.io/til/2024/10/12/primitive-data-structure-vs-non-primitive-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Suffix Array vs Suffix Tree vs Trie</h2></header><div class=entry-content><p>Suffix Array Vs Suffix Tree Vs Trie Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.
특성 Suffix Array Suffix Tree Trie 기본 구조 모든 접미사를 정렬하여 저장하는 1차원 배열 모든 접미사를 트리 형태로 저장하는 압축된 트리 구조 문자열을 문자 단위로 저장하는 트리 구조 메모리 효율성 O(n), 매우 효율적 O(n), 하지만 실제로는 4n 정도로 큼 O(ALPHABET_SIZE key_length n), 매우 큼 구축 시간 O(n log n) O(n) (Ukkonen’s Algorithm 사용 시) O(n * key_length) 검색 시간 O(m log n + occ), m은 패턴 길이 O(m + occ), m은 패턴 길이 O(m), m은 검색할 문자열 길이 구현 난이도 비교적 간단 매우 복잡 비교적 간단 LCP 계산 추가 배열 필요 트리 구조에서 직접 계산 가능 해당 없음 패턴 매칭 이진 검색 이용 트리 순회로 직접 검색 트리 순회로 직접 검색 공간 지역성 매우 좋음 (연속된 메모리) 보통 (포인터로 인한 흩어짐) 나쁨 (노드가 메모리에 흩어짐) 주요 응용 텍스트 검색, DNA 분석 문자열 처리, 바이오인포매틱스 사전 구현, 자동 완성 동적 업데이트 어려움 가능하나 복잡 쉬움 접두사 검색 어려움 가능하나 비효율적 매우 효율적 최장 공통 접두사 추가 작업 필요 직접 계산 가능 직접 계산 가능 최장 공통 부분 문자열 LCP 배열 필요 직접 계산 가능 부적합 압축 가능성 제한적 매우 좋음 있음 (압축 트라이) 캐시 성능 매우 좋음 보통 나쁨 실제 사용 사례 대용량 문자열 검색 시스템 생물정보학, 문자열 처리 자동 완성, 사전 검색 추가적인 중요 고려사항:
...</p></div><footer class=entry-footer><span title='2024-10-12 15:40:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Array vs Suffix Tree vs Trie" href=https://buenhyden.github.io/til/2024/10/12/suffix-array-vs-suffix-tree-vs-trie/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Memoization vs Tabulation</h2></header><div class=entry-content><p>Memoization Vs Tabulation Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.
Memoization(메모이제이션)은 “하향식(Top-down)” 접근 방식이다.
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.
Tabulation(타뷸레이션)은 “상향식(Bottom-up)” 접근 방식이다.
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.
특성 Tabulation Memoization 접근 방식 Bottom-up (상향식) Top-down (하향식) 구현 방법 반복문 (Iterative) 재귀 (Recursive) 메모리 사용 문제 크기만큼 고정 필요한 만큼 동적 할당 실행 순서 순차적으로 모든 하위 문제 해결 필요한 하위 문제만 해결 공간 효율성 예측 가능하고 일정함 재귀 호출로 인한 스택 공간 필요 시간 효율성 모든 경우를 계산 필요한 경우만 계산 코드 복잡도 일반적으로 더 단순 일반적으로 더 복잡 캐시 활용 배열/테이블 형태 해시 테이블/맵 형태 구현 예시 비교 피보나치 수열 계산의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Tabulation 방식 def fib_tabulation(n): # 테이블 초기화 table = [0] * (n + 1) table[1] = 1 # 순차적으로 값 채우기 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n] # Memoization 방식 def fib_memoization(n, memo={}): # 이미 계산된 값이면 반환 if n in memo: return memo[n] # 기본 케이스 if n &lt;= 1: return n # 결과 저장 및 반환 memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo) return memo[n] 세부 특성 Tabulation Memoization 적합한 상황 모든 하위 문제의 결과가 필요한 경우 일부 하위 문제의 결과만 필요한 경우 디버깅 난이도 상대적으로 쉬움 재귀로 인해 더 어려움 최적화 가능성 공간 최적화 쉬움 재귀 깊이 제한으로 인한 제약 병렬화 가능성 쉬움 (독립적인 계산) 어려움 (의존성 있는 호출) 초기화 오버헤드 더 큼 (전체 테이블) 더 작음 (필요시 할당) 메모리 예측성 높음 낮음 (실행 중 변동) 성능 특성 Tabulation Memoization 시간 복잡도 O(n) - 모든 경우 O(n) - 최악의 경우 공간 복잡도 O(n) - 테이블 크기 O(n) - 캐시 + 스택 캐시 적중률 100% (모든 값 계산) 상황에 따라 다름 초기 지연 시간 더 김 (테이블 초기화) 더 짧음 (즉시 시작) 메모리 사용량 예측 가능 변동적 이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.
일반적으로:
...</p></div><footer class=entry-footer><span title='2024-10-13 11:25:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memoization vs Tabulation" href=https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>보간 검색 (Interpolation Search)</h2></header><div class=entry-content><p>보간 검색 (Interpolation Search) 보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.
이진 탐색(Binary Search)과 유사하지만, 데이터 분포를 고려해 탐색 위치를 예측함으로써 평균적으로 더 빠른 성능을 보인다. 특히 균등한 데이터 분포에서 효과적이다.
보간 검색은 데이터 특성에 민감하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.
핵심 개념 데이터 균등성 가정: 배열의 값이 선형적으로 분포되어 있다고 가정한다.
예측 위치 계산: 탐색 위치를 다음 공식으로 계산한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 12:33:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;592 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보간 검색 (Interpolation Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬(Bubble Sort)은 인접한 요소를 반복적으로 비교하고 교환하여 정렬하는 간단한 알고리즘이다.
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, 구현이 쉽지만 성능이 낮은 특징을 가진다.
https://www.wscubetech.com/resources/dsa/bubble-sort
알고리즘 작동 원리 비교: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(arr[i]와 arr[i+1])를 비교한다. 교환: 순서가 잘못된 경우(arr[i] > arr[i+1]) 두 요소의 위치를 교환한다. 반복: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다. 패스 완료: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다. 예시: [5, 3, 8, 4, 2]
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.
병합 정렬은 데이터 무결성과 안정성이 중요한 시스템(예: 금융 거래 로그)에서 선호된다.
현대 프로그래밍 언어의 표준 라이브러리(예: Python sorted(), Java Collections.sort())에서도 하이브리드 방식으로 병합 정렬을 활용한다.
https://www.programiz.com/dsa/merge-sort
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;528 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.
삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
https://www.geeksforgeeks.org/insertion-sort-algorithm/
삽입 정렬의 작동 원리 초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다. 요소 선택: 정렬되지 않은 부분에서 요소를 선택한다. 비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다. 삽입: 찾은 위치에 요소를 삽입한다. 반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다. 예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;603 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/data-structure-and-algorithm/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>