<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data-Structure-and-Algorithm on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/data-structure-and-algorithm/</link>
    <description>Recent content in Data-Structure-and-Algorithm on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.143.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Oct 2024 12:33:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/data-structure-and-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data Structure</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</link>
      <pubDate>Mon, 07 Oct 2024 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</guid>
      <description>데이터를 효율적으로 저장, 관리, 접근하기 위한 방법</description>
    </item>
    <item>
      <title>계산 복잡도 (Computational Complexity)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/</link>
      <pubDate>Sun, 13 Oct 2024 01:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/</guid>
      <description>알고리즘의 효율성을 분석하고 문제의 난이도를 분류하는 이론</description>
    </item>
    <item>
      <title>알고리즘 설계 (Algorithm Design)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</link>
      <pubDate>Sun, 13 Oct 2024 05:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</guid>
      <description>알고리즘 설계는 주어진 문제를 효율적으로 해결하기 위한 체계적인 과정</description>
    </item>
    <item>
      <title>Algorithm</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</link>
      <pubDate>Mon, 14 Oct 2024 08:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</guid>
      <description>문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차</description>
    </item>
    <item>
      <title>Concurrent Hash Map vs Hash Map vs Hash Table</title>
      <link>https://buenhyden.github.io/til/2024/10/12/concurrent-hash-map-vs-hash-map-vs-hash-table/</link>
      <pubDate>Sat, 12 Oct 2024 14:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/concurrent-hash-map-vs-hash-map-vs-hash-table/</guid>
      <description>&lt;h2 id=&#34;concurrent-hash-map-vs-hash-map-vs-hash-table&#34;&gt;Concurrent Hash Map Vs Hash Map Vs Hash Table&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특성&lt;/th&gt;
          &lt;th&gt;Concurrent HashMap&lt;/th&gt;
          &lt;th&gt;HashMap&lt;/th&gt;
          &lt;th&gt;HashTable&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트/버킷 단위의 부분 동기화 지원&lt;/td&gt;
          &lt;td&gt;동기화 지원하지 않음&lt;/td&gt;
          &lt;td&gt;메서드 단위의 전체 동기화 지원&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동시성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능)&lt;/td&gt;
          &lt;td&gt;동시성 지원하지 않음 (단일 스레드 환경용)&lt;/td&gt;
          &lt;td&gt;낮은 동시성 (한 번에 하나의 스레드만 접근 가능)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동시 접근 시 높은 성능&lt;/td&gt;
          &lt;td&gt;단일 스레드에서 가장 높은 성능&lt;/td&gt;
          &lt;td&gt;동기화로 인한 성능 저하&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;null 허용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
          &lt;td&gt;key는 하나만 null 허용, value는 여러 개 null 허용&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;초기 용량&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 16, 세그먼트 수는 16&lt;/td&gt;
          &lt;td&gt;기본 16&lt;/td&gt;
          &lt;td&gt;기본 11&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;적재율&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;이터레이션&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;fail-safe 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;생성 시기&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Java 5&lt;/td&gt;
          &lt;td&gt;Java 1.2&lt;/td&gt;
          &lt;td&gt;Java 1.0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;메모리 사용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트로 인한 추가 메모리 필요&lt;/td&gt;
          &lt;td&gt;가장 적은 메모리 사용&lt;/td&gt;
          &lt;td&gt;동기화로 인한 추가 메모리 필요&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;용도&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;멀티스레드 환경의 동시성이 필요한 경우&lt;/td&gt;
          &lt;td&gt;단일 스레드 환경의 일반적인 경우&lt;/td&gt;
          &lt;td&gt;레거시 코드 호환성이 필요한 경우&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;순서 보장&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화 비용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;부분적 동기화로 중간 수준의 비용&lt;/td&gt;
          &lt;td&gt;동기화 비용 없음&lt;/td&gt;
          &lt;td&gt;전체 동기화로 높은 비용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;스레드 안전성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
          &lt;td&gt;스레드 안전하지 않음&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;키 충돌 처리&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;참고로 몇 가지 중요한 추가 설명을 하자면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Concurrent Data Structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/concurrent-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/concurrent-data-structure/</guid>
      <description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</description>
    </item>
    <item>
      <title>Linear Data Structure vs Non-Linear Data Structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/linear-data-structure-vs-non-linear-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/linear-data-structure-vs-non-linear-data-structure/</guid>
      <description>Linear Data Structure Vs Non-Linear Data Structure</description>
    </item>
    <item>
      <title>Primitive data structure vs Non-Primitive data structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/primitive-data-structure-vs-non-primitive-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 08:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/primitive-data-structure-vs-non-primitive-data-structure/</guid>
      <description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/til/2024/10/12/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Sat, 12 Oct 2024 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>Memoization vs Tabulation</title>
      <link>https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/</guid>
      <description>Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법</description>
    </item>
    <item>
      <title>보간 검색 (Interpolation Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</link>
      <pubDate>Tue, 15 Oct 2024 12:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</guid>
      <description>&lt;h2 id=&#34;보간-검색-interpolation-search&#34;&gt;보간 검색 (Interpolation Search)&lt;/h2&gt;
&lt;p&gt;보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.&lt;br&gt;
이진 탐색(Binary Search)과 유사하지만, &lt;strong&gt;데이터 분포를 고려해 탐색 위치를 예측&lt;/strong&gt;함으로써 평균적으로 더 빠른 성능을 보인다. 특히 &lt;strong&gt;균등한 데이터 분포&lt;/strong&gt;에서 효과적이다.&lt;/p&gt;
&lt;p&gt;보간 검색은 &lt;strong&gt;데이터 특성에 민감&lt;/strong&gt;하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.&lt;br&gt;
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;데이터 균등성 가정&lt;/strong&gt;: 배열의 값이 &lt;strong&gt;선형적으로 분포&lt;/strong&gt;되어 있다고 가정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;예측 위치 계산&lt;/strong&gt;: 탐색 위치를 다음 공식으로 계산한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</guid>
      <description>&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;p&gt;버블 정렬(Bubble Sort)은 &lt;strong&gt;인접한 요소를 반복적으로 비교하고 교환&lt;/strong&gt;하여 정렬하는 간단한 알고리즘이다.&lt;br&gt;
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, &lt;strong&gt;구현이 쉽지만 성능이 낮은&lt;/strong&gt; 특징을 가진다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Bubble Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Bubble-sort.webp&#34;&gt;&lt;figcaption&gt;https://www.wscubetech.com/resources/dsa/bubble-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비교&lt;/strong&gt;: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(&lt;code&gt;arr[i]&lt;/code&gt;와 &lt;code&gt;arr[i+1]&lt;/code&gt;)를 비교한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;교환&lt;/strong&gt;: 순서가 잘못된 경우(&lt;code&gt;arr[i] &amp;gt; arr[i+1]&lt;/code&gt;) 두 요소의 위치를 교환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;패스 완료&lt;/strong&gt;: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</guid>
      <description>&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;병합 정렬(Merge Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 방식을 사용하는 비교 기반 정렬 알고리즘이다.&lt;br&gt;
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.&lt;/p&gt;
&lt;p&gt;병합 정렬은 &lt;strong&gt;데이터 무결성과 안정성이 중요한 시스템&lt;/strong&gt;(예: 금융 거래 로그)에서 선호된다.&lt;br&gt;
현대 프로그래밍 언어의 표준 라이브러리(예: Python &lt;code&gt;sorted()&lt;/code&gt;, Java &lt;code&gt;Collections.sort()&lt;/code&gt;)에서도 하이브리드 방식으로 병합 정렬을 활용한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Merge Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/merge-sort-example_0.png&#34;&gt;&lt;figcaption&gt;https://www.programiz.com/dsa/merge-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</guid>
      <description>&lt;h2 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h2&gt;
&lt;p&gt;삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.&lt;br&gt;
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.&lt;/p&gt;
&lt;p&gt;삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.&lt;br&gt;
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Insertion Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Insertion-sorting.png&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/insertion-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;삽입-정렬의-작동-원리&#34;&gt;&lt;strong&gt;삽입 정렬의 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기화&lt;/strong&gt;: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;요소 선택&lt;/strong&gt;: 정렬되지 않은 부분에서 요소를 선택한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비교 및 이동&lt;/strong&gt;: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;삽입&lt;/strong&gt;: 찾은 위치에 요소를 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: 배열 &lt;code&gt;[5, 2, 4, 6, 1, 3]&lt;/code&gt;의 정렬 과정&lt;/p&gt;</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</guid>
      <description>&lt;h2 id=&#34;선택-정렬-selection-sort&#34;&gt;선택 정렬 (Selection Sort)&lt;/h2&gt;
&lt;p&gt;선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, &lt;strong&gt;작은 데이터 세트에서 효율적&lt;/strong&gt;이며 &lt;strong&gt;메모리 사용이 최소화&lt;/strong&gt;되는 특징을 갖는다.&lt;br&gt;
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 &lt;strong&gt;정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치&lt;/strong&gt;하는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;선택 정렬은 &lt;strong&gt;알고리즘의 기본 원리를 이해&lt;/strong&gt;하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Selection Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Selection-sort.png&#34;&gt;&lt;figcaption&gt;https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기화&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.&lt;/li&gt;
&lt;li&gt;초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;최솟값 탐색&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</guid>
      <description>&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;p&gt;퀵 정렬(Quick Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 전략을 사용하는 고성능 정렬 알고리즘이다. 1960년 Tony Hoare가 개발했으며, 평균적으로 **O(n log n)**의 시간 복잡도를 가지며 대규모 데이터셋 처리에 효율적이다.&lt;/p&gt;
&lt;p&gt;퀵 정렬은 &lt;strong&gt;실시간 시스템&lt;/strong&gt;과 &lt;strong&gt;고성능 컴퓨팅&lt;/strong&gt;에서 널리 사용되며, 알고리즘 최적화의 핵심 사례로 연구된다.&lt;br&gt;
피벗 선택 전략과 하이브리드 기법을 적용하면 현대 애플리케이션에서도 뛰어난 성능을 발휘한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Quick Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Heap-Sort-Recursive-Illustration.webp&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/quick-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;기본-원리&#34;&gt;기본 원리&lt;/h3&gt;
&lt;h4 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;피벗(Pivot) 선택&lt;/strong&gt;: 배열에서 하나의 요소를 선택한다. 피벗 선택 방법은 성능에 큰 영향을 미칩니다(예: 첫 번째/중간/랜덤 요소 또는 중앙값).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분할(Partitioning)&lt;/strong&gt;: 피벗을 기준으로 배열을 두 부분으로 나눈다. 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재귀적 정렬&lt;/strong&gt;: 분할된 서브 배열에 대해 동일한 과정을 재귀적으로 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;분할-과정-예시&#34;&gt;분할 과정 예시&lt;/h4&gt;
&lt;p&gt;배열 &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;에서 피벗을 중간 값인 &lt;code&gt;4&lt;/code&gt;로 선택:&lt;/p&gt;</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</guid>
      <description>&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;p&gt;힙 정렬(Heap Sort)은 &lt;strong&gt;이진 힙(binary heap)&lt;/strong&gt; 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.&lt;br&gt;
1964년 J. W. J. Williams가 개발한 이 알고리즘은 **최악, 평균, 최선의 경우 모두 O(n log n)**의 시간 복잡도를 보장하며, **메모리 효율성(O(1))**이 뛰어난 특징을 가진다.&lt;br&gt;
주로 대규모 데이터셋 처리와 안정적인 성능이 요구되는 시스템에서 활용된다.&lt;/p&gt;
&lt;p&gt;힙 정렬은 &lt;strong&gt;성능 예측이 중요한 시스템&lt;/strong&gt;에서 특히 유용하다. 최근에는 하이브리드 알고리즘(예: Introsort)에서 퀵 정렬의 최악 경우를 방지하기 위해 힙 정렬을 부분적으로 활용하기도 한다.&lt;br&gt;
데이터 특성과 시스템 요구사항에 따라 적절한 정렬 방식을 선택하는 것이 핵심이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>깊이 우선 탐색 (Depth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</guid>
      <description>그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.</description>
    </item>
    <item>
      <title>너비 우선 탐색 (Breadth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</guid>
      <description>BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘</description>
    </item>
    <item>
      <title>이진 검색 (Binary Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</guid>
      <description>리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다</description>
    </item>
    <item>
      <title>해시 검색 (Hash Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</guid>
      <description>해시 검색은 키(key)를 해시 함수(hash function)에 통과시켜 얻은 해시 값(hash value)을 인덱스로 사용하여 데이터에 직접 접근하는 방식.</description>
    </item>
    <item>
      <title>순차 검색 (Sequential Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</guid>
      <description>순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법으로 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.</description>
    </item>
    <item>
      <title>암호화 알고리즘 (Encryption Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/</guid>
      <description>데이터를 안전하게 보호하기 위해 사용되는 수학적 방법</description>
    </item>
    <item>
      <title>머신러닝 알고리즘 (Machine Learning Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 07:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/</guid>
      <description>컴퓨터가 명시적인 프로그래밍 없이 데이터로부터 패턴을 학습하고 예측이나 의사결정을 수행할 수 있게 하는 알고리즘</description>
    </item>
    <item>
      <title>최적화 알고리즘 (Optimization Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/</guid>
      <description>주어진 문제에 대해 가장 효율적이거나 최적의 해결책을 찾기 위해 사용되는 방법론</description>
    </item>
    <item>
      <title>기하 알고리즘 (Geometric Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/</guid>
      <description>2차원, 3차원 또는 더 높은 차원의 공간에 존재하는 점, 선, 다각형, 원 등의 기하학적 객체를 다루는 알고리즘</description>
    </item>
    <item>
      <title>문자열 알고리즘 (String Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/</guid>
      <description>문자열 알고리즘은 텍스트 데이터를 처리하고 분석하는 알고리즘의 집합</description>
    </item>
    <item>
      <title>수치 알고리즘 (Numerical Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/</guid>
      <description>수치해석학의 일부로, 복잡한 수학적 문제를 컴퓨터를 이용해 수치적으로 근사해서 해결하는 알고리즘</description>
    </item>
    <item>
      <title>그리디 알고리즘 (Greedy Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 02:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/</guid>
      <description>&amp;#34;탐욕적&amp;#34; 또는 &amp;#34;욕심쟁이&amp;#34; 알고리즘이라고도 불리며, 현재 상황에서 가장 최적의 선택을 하는 방식으로 문제를 해결하는 알고리즘</description>
    </item>
    <item>
      <title>검색 알고리즘 (Searching Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/</guid>
      <description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</description>
    </item>
    <item>
      <title>그래프 알고리즘 (Graph Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/</guid>
      <description>네트워크, 경로 찾기, 최적화 등 다양한 실제 문제를 해결하는 데 사용되는 중요한 알고리즘</description>
    </item>
    <item>
      <title>정렬 알고리즘 (Sorting Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/</guid>
      <description>정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</guid>
      <description>환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.</description>
    </item>
    <item>
      <title>메모이제이션 (Memoization)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</link>
      <pubDate>Sun, 13 Oct 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</guid>
      <description>메모이제이션(Memoization)은 컴퓨터 프로그래밍에서 사용되는 최적화 기법으로, 함수의 호출 결과를 저장해두고 재사용함으로써 프로그램의 실행 속도를 향상시키는 방법이다.</description>
    </item>
    <item>
      <title>테이블레이션(Tabulation)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</guid>
      <description>Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.</description>
    </item>
    <item>
      <title>튜링 기계 (Turing Machine)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</link>
      <pubDate>Sun, 13 Oct 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</guid>
      <description>튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.</description>
    </item>
    <item>
      <title>복잡도 클래스(Complexity Classes)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</link>
      <pubDate>Sun, 13 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</guid>
      <description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>브루트 포스 (Brute Force)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</link>
      <pubDate>Sun, 13 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</guid>
      <description>브루트 포스는 &amp;#34;무식한 힘&amp;#34;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>Algorithm Design techniques</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</link>
      <pubDate>Sun, 13 Oct 2024 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</guid>
      <description>알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.</description>
    </item>
    <item>
      <title>Approaches to algorithm design</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</link>
      <pubDate>Sun, 13 Oct 2024 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</guid>
      <description>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.</description>
    </item>
    <item>
      <title>랜덤화 알고리즘 (Randomized Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</guid>
      <description>랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다.</description>
    </item>
    <item>
      <title>근사 알고리즘 (Approximation algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</guid>
      <description>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &amp;#39;충분히 가까운&amp;#39; 해답을 찾는 알고리즘이다.</description>
    </item>
    <item>
      <title>동적 계획법 (Dynamic Programming)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/</guid>
      <description>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>백트래킹 (Backtracking)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</guid>
      <description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</description>
    </item>
    <item>
      <title>분기 한정법 (Branch and Bound)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</guid>
      <description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</description>
    </item>
    <item>
      <title>탐욕 알고리즘 (Greedy Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</guid>
      <description>문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다. 즉, &amp;#39;탐욕적&amp;#39;으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.</description>
    </item>
    <item>
      <title>분할 정복 (Divide and Conquer)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</link>
      <pubDate>Sun, 13 Oct 2024 05:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</guid>
      <description>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.</description>
    </item>
    <item>
      <title>Big O 표기법 (Big O notation)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</link>
      <pubDate>Sun, 13 Oct 2024 01:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</guid>
      <description>알고리즘의 성능과 효율성을 수학적으로 표현하는 방법으로, 주로 알고리즘이 처리해야 할 데이터의 크기(n)가 늘어날 때, 실행 시간이나 메모리 사용량이 어떻게 증가하는지를 나타낸다.</description>
    </item>
    <item>
      <title>Spatial Data partitioning</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/</link>
      <pubDate>Sat, 12 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/</guid>
      <description>&lt;h2 id=&#34;spatial-data-partitioning&#34;&gt;Spatial Data partitioning&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>string</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/</link>
      <pubDate>Sat, 12 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/</guid>
      <description>&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Octree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/octree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/octree/</guid>
      <description>Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.</description>
    </item>
    <item>
      <title>Splay Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/splay-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/splay-tree/</guid>
      <description>Splay Tree는 자체 균형 이진 검색 트리의 일종으로, 최근에 접근한 노드를 루트로 이동시키는 &amp;#34;splay&amp;#34; 연산을 통해 자가 조정되는 특징을 가진다.</description>
    </item>
    <item>
      <title>Fenwick Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/</guid>
      <description>Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.</description>
    </item>
    <item>
      <title>Range Query</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/</link>
      <pubDate>Fri, 11 Oct 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/</guid>
      <description>&lt;h2 id=&#34;range-query&#34;&gt;Range Query&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Segment Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/</guid>
      <description>세그먼트 트리는 배열의 특정 구간에 대한 정보를 빠르게 구할 수 있도록 설계된 이진 트리 기반의 자료구조</description>
    </item>
    <item>
      <title>AVL 트리 (AVL tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/</guid>
      <description>AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리이다.  각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.</description>
    </item>
    <item>
      <title>레드-블랙 트리 (red-black tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/red-black-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/red-black-tree/</guid>
      <description>Red-black tree는 각 노드에 추가적인 색상 속성(빨간색 또는 검은색)을 가진 자체 균형 이진 검색 트리로, 트리의 균형을 유지하여 효율적인 검색, 삽입, 삭제 연산을 보장한다.</description>
    </item>
    <item>
      <title>Balanced</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/</link>
      <pubDate>Fri, 11 Oct 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/</guid>
      <description>&lt;h2 id=&#34;balanced&#34;&gt;Balanced&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>BK-tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bk-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bk-tree/</guid>
      <description>&lt;h2 id=&#34;bk-tree&#34;&gt;BK-tree&lt;/h2&gt;
&lt;p&gt;BK-Tree(Burkhard-Keller Tree)는 &lt;strong&gt;메트릭 공간(metric space)에서 효율적인 근사 검색&lt;/strong&gt;을 위해 설계된 트리 기반 데이터 구조이다.&lt;br&gt;
주로 레벤슈타인 거리(Levenshtein Distance)를 활용한 문자열 유사성 검색, 맞춤법 검사, DNA 시퀀스 분석에 활용된다.&lt;/p&gt;
&lt;p&gt;BK-Tree는 &lt;strong&gt;유사성 검색이 필요한 분야&lt;/strong&gt;에서 여전히 유효하나, 최근에는 SymSpell 등 더 빠른 알고리즘도 등장했다.&lt;br&gt;
그러나 이론적 우아함과 구현 용이성으로 교육 및 소규모 시스템에서 널리 사용된다.&lt;/p&gt;
&lt;h3 id=&#34;bk-트리의-주요-특징&#34;&gt;BK-트리의 주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;메트릭 공간에서의 효율적인 검색:&lt;/strong&gt; BK-트리는 요소 간의 거리를 기반으로 데이터를 구성하여, 특정 요소와 유사한 요소를 빠르게 찾을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이산 메트릭 사용:&lt;/strong&gt; 주로 레벤슈타인 거리(편집 거리)와 같은 이산 메트릭을 사용하여 문자열 간의 유사성을 측정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bk-트리의-구조-및-동작-원리&#34;&gt;BK-트리의 구조 및 동작 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;노드 구성:&lt;/strong&gt; 각 노드는 하나의 요소를 저장하며, 자식 노드는 부모 노드와의 거리(d)를 기준으로 분류된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;삽입:&lt;/strong&gt; 새로운 요소를 삽입할 때, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 계산된 거리에 해당하는 자식 노드가 없으면 해당 위치에 새로운 노드를 추가하고, 있으면 해당 자식 노드로 이동하여 동일한 과정을 반복한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;검색:&lt;/strong&gt; 특정 요소와 유사한 요소를 찾기 위해, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 이 거리가 설정한 임계값 이하인 경우 해당 노드를 결과에 추가하고, 자식 노드들 중 현재 거리와 임계값의 차이 범위 내에 있는 노드들만 재귀적으로 탐색한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bk-트리의-예시&#34;&gt;BK-트리의 예시&lt;/h3&gt;
&lt;p&gt;단어 집합 {&amp;ldquo;book&amp;rdquo;, &amp;ldquo;books&amp;rdquo;, &amp;ldquo;cake&amp;rdquo;, &amp;ldquo;boo&amp;rdquo;, &amp;ldquo;boon&amp;rdquo;, &amp;ldquo;cook&amp;rdquo;, &amp;ldquo;cape&amp;rdquo;, &amp;ldquo;cart&amp;rdquo;}가 있을 때, 레벤슈타인 거리를 사용하여 BK-트리를 구성하면 다음과 같은 구조가 될 수 있다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>BSP Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/</guid>
      <description>BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것</description>
    </item>
    <item>
      <title>Hash</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/</guid>
      <description>&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>K-d Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/</guid>
      <description>K-d Tree는 k차원 공간에서 점들을 효율적으로 저장하고 검색하기 위한 이진 트리 기반의 공간 분할 데이터 구조로, K-d Tree는 k차원 공간을 재귀적으로 분할하여 표현하는 이진 트리이다.</description>
    </item>
    <item>
      <title>Merkle Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/</guid>
      <description>&lt;h2 id=&#34;merkle-tree&#34;&gt;Merkle Tree&lt;/h2&gt;
&lt;p&gt;머클 트리(Merkle Tree)는 &lt;strong&gt;암호화된 해시 값&lt;/strong&gt;을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.&lt;br&gt;
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, &lt;strong&gt;데이터 변조 탐지&lt;/strong&gt;와 &lt;strong&gt;검증 효율성&lt;/strong&gt;이 핵심 강점이다.&lt;/p&gt;
&lt;p&gt;머클 트리는 &lt;strong&gt;분산 환경의 신뢰 문제&lt;/strong&gt;를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.&lt;br&gt;
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.&lt;/p&gt;
&lt;h3 id=&#34;계층적-해시-구조&#34;&gt;계층적 해시 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Leaf Node&lt;/strong&gt;: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-Leaf Node&lt;/strong&gt;: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Merkle Root&lt;/strong&gt;: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성&lt;/p&gt;</description>
    </item>
    <item>
      <title>Quad Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/quad-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/quad-tree/</guid>
      <description>Quad Tree는 2차원 공간을 재귀적으로 4개의 영역으로 분할하여 표현하는 트리 기반의 데이터 구조로, 각 노드가 정확히 4개의 자식 노드를 갖는 트리 구조이다.</description>
    </item>
    <item>
      <title>R-tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/r-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/r-tree/</guid>
      <description>R-Tree는 다차원 공간 데이터를 효율적으로 저장하고 검색하기 위해 설계된 트리 기반의 데이터 구조로, 공간 인덱스 알고리즘이다.</description>
    </item>
    <item>
      <title>Rope</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/rope/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/rope/</guid>
      <description>Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조</description>
    </item>
    <item>
      <title>Set</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/</guid>
      <description>&lt;h2 id=&#34;set&#34;&gt;Set&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Suffix Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/suffix-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/suffix-tree/</guid>
      <description>Suffix Tree는 문자열의 모든 접미사를 효율적으로 저장하고 검색하는 특수한 트리 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>트라이 (Trie)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/</guid>
      <description>문자열을 효율적으로 저장하고 검색할 수 있는 트리 기반의 자료구조</description>
    </item>
    <item>
      <title>디스조인트 셋 (Disjoint-Set)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/disjoint-set/</link>
      <pubDate>Fri, 11 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/disjoint-set/</guid>
      <description>디스조인트 셋은 서로 겹치지 않는(disjoint) 부분 집합들로 나누어진 요소들의 집합을 표현하고 조작하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>B 트리 (B-tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/b-tree/</link>
      <pubDate>Fri, 11 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/b-tree/</guid>
      <description>균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조</description>
    </item>
    <item>
      <title>Hash Map</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-map/</guid>
      <description>HashMap은 해시 함수를 사용하여 키를 배열의 인덱스로 변환하고, 해당 인덱스에 값을 저장하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>Lock-free Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/</link>
      <pubDate>Wed, 09 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/</guid>
      <description>Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.</description>
    </item>
    <item>
      <title>Concurrent Hash Map</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/</guid>
      <description>여러 스레드가 동시에 데이터를 안전하게 접근하고 수정할 수 있도록 설계된 스레드 안전(thread-safe)한 해시 맵 구현체</description>
    </item>
    <item>
      <title>Cuckoo Hash Table</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-hash-table/</guid>
      <description>Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.</description>
    </item>
    <item>
      <title>Bloom filter</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/bloom-filter/</link>
      <pubDate>Wed, 09 Oct 2024 12:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/bloom-filter/</guid>
      <description>&lt;h2 id=&#34;블룸-필터-bloom-filter&#34;&gt;블룸 필터 (Bloom filter)&lt;/h2&gt;
&lt;p&gt;블룸 필터(Bloom Filter)는 &lt;strong&gt;공간 효율적인 확률적 데이터 구조&lt;/strong&gt;로, 원소가 집합에 속하는지 여부를 빠르게 확인하는 데 사용된다.&lt;br&gt;
1970년 Burton Howard Bloom이 고안한 이 구조는 **거짓 양성(false positive)**은 허용하지만 **거짓 음성(false negative)**은 절대 발생하지 않는다.&lt;/p&gt;
&lt;p&gt;블룸 필터는 &lt;strong&gt;빠른 검색과 극도의 공간 효율&lt;/strong&gt;이 필요한 시스템에서 필수적이다.&lt;br&gt;
특히 대용량 데이터 처리, 실시간 애플리케이션, 메모리 제약 환경에서 강력한 성능을 발휘한다.&lt;br&gt;
다만 정확성이 절대적이라면 전통적 해시 테이블이 더 적합하다.&lt;/p&gt;
&lt;h3 id=&#34;핵심-구성-요소&#34;&gt;핵심 구성 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;비트 배열(Bit Array)&lt;/strong&gt;: 모든 비트가 0으로 초기화된 배열 (크기 &lt;code&gt;m&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;해시 함수(Hash Functions)&lt;/strong&gt;: 원소를 비트 배열의 인덱스로 매핑하는 &lt;code&gt;k&lt;/code&gt;개의 독립적 해시 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-과정&#34;&gt;동작 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;삽입(Add)&lt;br&gt;
원소를 &lt;code&gt;k&lt;/code&gt;개의 해시 함수로 해싱 → 각 결과값을 비트 배열의 인덱스로 사용 → 해당 위치의 비트를 1로 설정.&lt;br&gt;
&lt;strong&gt;예시&lt;/strong&gt;: 원소 &amp;ldquo;apple&amp;quot;을 3개의 해시 함수로 해싱 → 인덱스 1, 4, 7 → 비트 배열 &lt;code&gt;[0,1,0,1,0,0,1,0,0,0]&lt;/code&gt; 갱신.&lt;/p&gt;</description>
    </item>
    <item>
      <title>해시 테이블(Hash Table)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-table/</guid>
      <description>키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 키를 인덱스로 변환</description>
    </item>
    <item>
      <title>스택 (Stack)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/</link>
      <pubDate>Wed, 09 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/</guid>
      <description>LIFO(Last In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>Concurrent Skip List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/</guid>
      <description>Concurrent Skip List는 Skip List 자료구조를 기반으로 하여 멀티스레드 환경에서 동시에 삽입, 삭제, 검색 작업을 수행할 수 있도록 구현된 동시성 자료구조이다.</description>
    </item>
    <item>
      <title>Read-Copy-Update List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/</guid>
      <description>RCU List는 Read-Copy-Update 메커니즘을 사용하여 구현된 동시성 연결 리스트로 읽기 작업에 대해 락을 사용하지 않으면서도 동시에 업데이트를 수행할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Lock-free Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/lock-free-queue/</link>
      <pubDate>Tue, 08 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/lock-free-queue/</guid>
      <description>Lock-free Queue는 락(lock)을 사용하지 않고 동시성을 제공하는 FIFO(First-In-First-Out) 자료구조이다.</description>
    </item>
    <item>
      <title>Suffix Array</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/suffix-array/</link>
      <pubDate>Tue, 08 Oct 2024 13:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/suffix-array/</guid>
      <description>Suffix Array는 문자열의 모든 접미사를 효율적으로 저장하고 관리하는 특수한 배열 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>Circular Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-linked-list/</guid>
      <description>Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.</description>
    </item>
    <item>
      <title>Circular Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/circular-queue/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/circular-queue/</guid>
      <description>Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.</description>
    </item>
    <item>
      <title>Doubly Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/doubly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/doubly-linked-list/</guid>
      <description>Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.</description>
    </item>
    <item>
      <title>Skip List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/skip-list/</guid>
      <description>Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다</description>
    </item>
    <item>
      <title>Deque</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/deque/</link>
      <pubDate>Tue, 08 Oct 2024 12:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/deque/</guid>
      <description>Deque는 양쪽 끝에서 삽입과 삭제가 가능한 선형 데이터 구조로, 큐와 스택의 특성을 모두 가지고 있다.</description>
    </item>
    <item>
      <title>동적 배열 (Dynamic Array)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/dynamic-array/</link>
      <pubDate>Tue, 08 Oct 2024 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/dynamic-array/</guid>
      <description>동적 배열은 크기가 가변적인 배열 형태의 데이터 구조이다.</description>
    </item>
    <item>
      <title>Basic</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/</link>
      <pubDate>Mon, 07 Oct 2024 12:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/</guid>
      <description>&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>이진 검색 트리 (Binary Search Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-search-tree/</link>
      <pubDate>Mon, 07 Oct 2024 12:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-search-tree/</guid>
      <description>BST는 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용되는 특수한 이진 트리 구조이다.</description>
    </item>
    <item>
      <title>논리값 (Boolean)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/boolean/</link>
      <pubDate>Mon, 07 Oct 2024 07:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/boolean/</guid>
      <description>Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.</description>
    </item>
    <item>
      <title>Integer</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/integer/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/integer/</guid>
      <description>정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.</description>
    </item>
    <item>
      <title>문자 (Character)과 문자열 (String)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/character-and-string/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/character-and-string/</guid>
      <description>문자 (Character)는 단일 문자를 표현하는 데이터 타입이고,문자열 (String)은 문자들의 배열 또는 시퀀스</description>
    </item>
    <item>
      <title>부동 소수점 (Float)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/float/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/float/</guid>
      <description>부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.</description>
    </item>
    <item>
      <title>이진 트리 (Binary Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/</link>
      <pubDate>Mon, 07 Oct 2024 07:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/</guid>
      <description>이진 트리는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 데이터 구조로, 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용된다.</description>
    </item>
    <item>
      <title>그래프 (Graph)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/</link>
      <pubDate>Mon, 07 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/</guid>
      <description>노드(정점)와 엣지(간선)로 구성된 비선형 데이터 구조</description>
    </item>
    <item>
      <title>힙 (Heap)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/</link>
      <pubDate>Mon, 07 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/</guid>
      <description>부모 노드와 자식 노드 간의 대소 관계가 일정한 규칙을 따르는 자료구조</description>
    </item>
    <item>
      <title>연결 리스트 (Linked List)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/</guid>
      <description>각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조</description>
    </item>
    <item>
      <title>큐 (Queue)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/</guid>
      <description>FIFO(First In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>트리 (Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/</guid>
      <description>계층적 구조를 가진 비선형 데이터 구조로, 노드들이 부모-자식 관계로 연결되어 있다</description>
    </item>
    <item>
      <title>배열 (Array)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/</link>
      <pubDate>Mon, 07 Oct 2024 05:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/</guid>
      <description>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.</description>
    </item>
    <item>
      <title>해시 (Hash)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/</link>
      <pubDate>Mon, 07 Oct 2024 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/</guid>
      <description>임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변환하는 과정</description>
    </item>
  </channel>
</rss>
