<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Software-Design-and-Architecture on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/software-design-and-architecture/</link>
    <description>Recent content in Software-Design-and-Architecture on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.145.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 28 Feb 2025 05:26:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/software-design-and-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>클린 코드 (Clean Code)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/</guid>
      <description>프로그램의 동작을 보장하면서도 가독성이 뛰어나고 유지보수가 쉬운 코드</description>
    </item>
    <item>
      <title>Data Pipeline Pattern</title>
      <link>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</guid>
      <description>데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.</description>
    </item>
    <item>
      <title>MVC pattern vs MVVC pattern vs MVP pattern</title>
      <link>https://buenhyden.github.io/til/2024/09/27/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/27/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/</guid>
      <description>MVC, MVP, MVVM 아키텍처 패턴은 모두 **관심사 분리(SoC)** 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.</description>
    </item>
    <item>
      <title>보안 코딩 (Secure Coding)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/secure-coding/</link>
      <pubDate>Thu, 19 Sep 2024 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/secure-coding/</guid>
      <description>Secure Coding은 소프트웨어 개발 과정에서 보안 취약점을 최소화하고 안전한 소프트웨어를 만들기 위한 코딩 기법이다.</description>
    </item>
    <item>
      <title>Software Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/</link>
      <pubDate>Wed, 25 Sep 2024 07:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/</guid>
      <description>자주 발생하는 문제들을 해결하기 위한 재사용 가능한 설계 템플릿</description>
    </item>
    <item>
      <title>Programming Paradigm</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/</link>
      <pubDate>Sun, 22 Sep 2024 04:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/</guid>
      <description>코드를 효율적이고 유지보수가 용이하게 작성하기 위한 다양한 접근 방식</description>
    </item>
    <item>
      <title>MSA 패턴 유형별 비교</title>
      <link>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Tue, 19 Nov 2024 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</guid>
      <description>MSA의 주요 패턴 유형들을 체계적으로 정리한 것.</description>
    </item>
    <item>
      <title>Software Architecture Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/</link>
      <pubDate>Thu, 26 Sep 2024 05:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/</guid>
      <description>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</description>
    </item>
    <item>
      <title>Software Architecture Principles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/</link>
      <pubDate>Mon, 23 Sep 2024 05:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/</guid>
      <description>Software Architecture Principles는 효율적이고 유지보수가 용이한 소프트웨어 시스템을 설계하기 위한 핵심 지침이다. 이러한 원칙들을 적절히 적용함으로써, 개발자들은 유지보수가 용이하고, 확장 가능하며, 재사용성이 높은 소프트웨어 시스템을 설계할 수 있다.</description>
    </item>
    <item>
      <title>Software Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/</link>
      <pubDate>Fri, 28 Feb 2025 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/</guid>
      <description>&lt;h2 id=&#34;software-design-patterns&#34;&gt;Software Design Patterns&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>MSA Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/</link>
      <pubDate>Mon, 11 Nov 2024 09:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/</guid>
      <description>마이크로서비스 아키텍처의 주요 패턴</description>
    </item>
    <item>
      <title>Architectural Principles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/</link>
      <pubDate>Fri, 28 Feb 2025 05:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/</guid>
      <description>&lt;h2 id=&#34;architectural-principles&#34;&gt;Architectural Principles&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Architectural Styles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/</link>
      <pubDate>Fri, 28 Feb 2025 05:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/</guid>
      <description>&lt;h2 id=&#34;architectural-styles&#34;&gt;Architectural Styles&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Software Design and Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/</link>
      <pubDate>Fri, 20 Sep 2024 10:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/</guid>
      <description>Software Architecture란 소프트웨어 시스템의 기본적인 구조와 조직을 정의하는 것이다.</description>
    </item>
    <item>
      <title>Architectural Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/</link>
      <pubDate>Fri, 28 Feb 2025 05:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/</guid>
      <description>&lt;h2 id=&#34;architectural-patterns&#34;&gt;Architectural Patterns&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Enterprise Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/enterprise-patterns/</link>
      <pubDate>Fri, 28 Feb 2025 05:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/enterprise-patterns/</guid>
      <description>&lt;h2 id=&#34;enterprise-patterns&#34;&gt;Enterprise Patterns&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Interface vs Abstract class</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/</link>
      <pubDate>Sun, 22 Sep 2024 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/</guid>
      <description>인터페이스는 클래스가 &amp;#39;무엇을 해야 하는지&amp;#39;를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.</description>
    </item>
    <item>
      <title>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</guid>
      <description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description>
    </item>
    <item>
      <title>Shared Database vs Shared Database Per Service</title>
      <link>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 08:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</guid>
      <description>MSA(Microservices Architecture)에서 **Shared Database**와 **Shared Database Per Service** 패턴은 데이터 관리 전략의 일환으로 활용되며, 각각의 특징과 적용 시나리오가 뚜렷하게 구분된다.</description>
    </item>
    <item>
      <title>Software Architecture pattern vs Software Design Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-pattern-vs-software-design-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-pattern-vs-software-design-pattern/</guid>
      <description>Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다. 이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.</description>
    </item>
    <item>
      <title>Mediator Pattern vs Observer Pattern</title>
      <link>https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/</guid>
      <description>Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.</description>
    </item>
    <item>
      <title>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/</link>
      <pubDate>Wed, 25 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/</guid>
      <description>소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리</description>
    </item>
    <item>
      <title>Boundaries</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/boundaries/boundaries/</link>
      <pubDate>Fri, 28 Feb 2025 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/boundaries/boundaries/</guid>
      <description>&lt;h2 id=&#34;boundaries&#34;&gt;Boundaries&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Component Principles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/component-principles/component-principles/</link>
      <pubDate>Fri, 28 Feb 2025 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/component-principles/component-principles/</guid>
      <description>&lt;h2 id=&#34;component-principles&#34;&gt;Component Principles&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Coupling and Cohesion</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/coupling-and-cohesion/coupling-and-cohesion/</link>
      <pubDate>Fri, 28 Feb 2025 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/coupling-and-cohesion/coupling-and-cohesion/</guid>
      <description>&lt;h2 id=&#34;coupling-and-cohesion&#34;&gt;Coupling and Cohesion&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Policy vs Detail</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/policy-vs-detail/policy-vs-detail/</link>
      <pubDate>Fri, 28 Feb 2025 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-principles/policy-vs-detail/policy-vs-detail/</guid>
      <description>&lt;h2 id=&#34;policy-vs-detail&#34;&gt;Policy vs Detail&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Publish Subscribe</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/publish-subscribe/publish-subscribe/</link>
      <pubDate>Fri, 28 Feb 2025 04:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/publish-subscribe/publish-subscribe/</guid>
      <description>&lt;h2 id=&#34;publish-subscribe&#34;&gt;Publish Subscribe&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Polling publisher</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</link>
      <pubDate>Tue, 19 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</guid>
      <description>&lt;h2 id=&#34;polling-publisher&#34;&gt;Polling Publisher&lt;/h2&gt;
&lt;p&gt;Polling publisher는 마이크로서비스 아키텍처(MSA)에서 트랜잭셔널 메시징을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 Transactional Outbox 패턴과 함께 사용되어 데이터 일관성을 유지하면서 메시지를 안정적으로 발행하는 데 도움을 준다.&lt;/p&gt;
&lt;p&gt;Polling publisher는 특히 소규모 시스템이나 간단한 구현이 필요한 경우에 적합한 방식이다. 그러나 대규모 시스템이나 실시간성이 중요한 경우에는 Transaction Log Tailing과 같은 다른 방식을 고려할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;기본-개념&#34;&gt;기본 개념&lt;/h3&gt;
&lt;p&gt;Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.&lt;br&gt;
데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transaction log tailing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</guid>
      <description>&lt;h2 id=&#34;transaction-log-tailing&#34;&gt;Transaction Log Tailing&lt;/h2&gt;
&lt;p&gt;Transaction log tailing은 마이크로서비스 아키텍처(MSA)에서 Transactional Messaging을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.&lt;/p&gt;
&lt;p&gt;Transaction log tailing은 Polling publisher 방식과 비교될 수 있다. Polling은 주기적으로 데이터베이스를 조회하는 반면, log tailing은 실시간으로 변경사항을 감지한다. 이로 인해 log tailing이 더 빠르고 효율적이지만, 구현이 더 복잡할 수 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 사용할 때는 메시지의 중복 발행 가능성을 고려해야 하며, 소비자 측에서 멱등성을 보장하는 방식으로 구현해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transactional Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/</guid>
      <description>&lt;h2 id=&#34;transactional-messaging&#34;&gt;Transactional Messaging&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Transactional Outbox</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</guid>
      <description>&lt;h2 id=&#34;transactional-outbox&#34;&gt;Transactional Outbox&lt;/h2&gt;
&lt;p&gt;Transactional Outbox 패턴은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성과 메시지 전달의 신뢰성을 보장하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 데이터베이스 업데이트와 메시지 발행을 원자적으로 처리하기 위한 방법으로, 데이터베이스 트랜잭션과 메시지 발행 사이의 일관성을 보장하는 것을 목적으로 한다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 분산 시스템에서 데이터 일관성과 메시지 전달의 신뢰성을 높이는 효과적인 방법이다. 이 패턴을 통해 개발자는 복잡한 분산 트랜잭션 문제를 해결하고, 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-방식&#34;&gt;작동 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 업데이트와 함께 발행할 메시지를 &amp;lsquo;outbox&amp;rsquo; 테이블에 저장한다.&lt;/li&gt;
&lt;li&gt;이 두 작업은 하나의 데이터베이스 트랜잭션으로 처리된다.&lt;/li&gt;
&lt;li&gt;별도의 프로세스(Message Relay)가 outbox 테이블에서 메시지를 읽어 실제 메시지 브로커로 전송한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Outbox 테이블: 발행할 메시지를 임시로 저장하는 데이터베이스 테이블&lt;/li&gt;
&lt;li&gt;Message Relay: outbox 테이블에서 메시지를 읽어 메시지 브로커로 전송하는 프로세스&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;p&gt;a. Polling Publisher:&lt;br&gt;
- 주기적으로 outbox 테이블을 폴링하여 미발행 메시지를 조회하고 발행한다.&lt;br&gt;
- 구현이 간단하지만 실시간성이 떨어질 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side UI composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</guid>
      <description>이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.</description>
    </item>
    <item>
      <title>Server-side page fragment composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</guid>
      <description>&lt;h2 id=&#34;server-side-page-fragment-composition&#34;&gt;Server-side Page Fragment Composition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Server-side page fragment composition&lt;/strong&gt;은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.&lt;/p&gt;
&lt;p&gt;Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>UI</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/</guid>
      <description>&lt;h2 id=&#34;ui&#34;&gt;UI&lt;/h2&gt;
&lt;h2 id=&#34;client-side-composition-vs-server-side-composition&#34;&gt;&lt;strong&gt;Client-side Composition Vs Server-side Composition&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특징&lt;/th&gt;
          &lt;th&gt;Client-side Composition&lt;/th&gt;
          &lt;th&gt;Server-side Composition&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;렌더링 위치&lt;/td&gt;
          &lt;td&gt;브라우저(클라이언트)&lt;/td&gt;
          &lt;td&gt;서버&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;초기 로딩 속도&lt;/td&gt;
          &lt;td&gt;느림&lt;/td&gt;
          &lt;td&gt;빠름&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SEO&lt;/td&gt;
          &lt;td&gt;불리함&lt;/td&gt;
          &lt;td&gt;유리함&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;서버 부하&lt;/td&gt;
          &lt;td&gt;낮음&lt;/td&gt;
          &lt;td&gt;높음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;실시간 업데이트&lt;/td&gt;
          &lt;td&gt;유리함&lt;/td&gt;
          &lt;td&gt;제한적&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;복잡성&lt;/td&gt;
          &lt;td&gt;프론트엔드 복잡성 증가&lt;/td&gt;
          &lt;td&gt;백엔드 복잡성 증가&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Twelve-Factor App methodology</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/</guid>
      <description>클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</guid>
      <description>&lt;h2 id=&#34;api-key-authentication&#34;&gt;API Key Authentication&lt;/h2&gt;
&lt;p&gt;API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</guid>
      <description>CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Mutual TLS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</guid>
      <description>클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</guid>
      <description>&lt;h2 id=&#34;oauth2oidc-openid-connect&#34;&gt;OAuth2/OIDC (OpenID Connect)&lt;/h2&gt;
&lt;p&gt;MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;oauth-20&#34;&gt;OAuth 2.0&lt;/h3&gt;
&lt;p&gt;OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.&lt;br&gt;
주요 특징은 다음과 같다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</guid>
      <description>클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.</description>
    </item>
    <item>
      <title>Secret Management</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</guid>
      <description>&lt;h2 id=&#34;secret-management&#34;&gt;Secret Management&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Secret Management&lt;/strong&gt;는 MSA(Microservices Architecture) 환경에서 &lt;strong&gt;민감한 자격 증명(API 키, 데이터베이스 비밀번호, 토큰 등)을 안전하게 저장, 관리, 배포&lt;/strong&gt;하는 핵심 보안 메커니즘이다.&lt;br&gt;
분산 시스템의 특성상 각 서비스가 독립적으로 동작하기 때문에 &lt;strong&gt;중앙 집중식 보안 관리&lt;/strong&gt;가 필수적이다.&lt;/p&gt;
&lt;p&gt;Secret Management는 &lt;strong&gt;MSA 보안의 핵심 인프라&lt;/strong&gt;로, 올바른 도구 선택과 체계적인 정책 수립이 필수적이다.&lt;br&gt;
2025년 현재 &lt;strong&gt;AI 기반 이상 탐지&lt;/strong&gt; 기능이 도입되며, 지속적인 모니터링과 자동화가 강화되는 추세이다.&lt;/p&gt;
&lt;h3 id=&#34;시크릿-관리의-중요성&#34;&gt;시크릿 관리의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;보안 강화:&lt;/strong&gt; 시크릿이 노출되면 악의적인 사용자가 시스템에 무단 접근하거나 데이터를 탈취할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;규제 준수:&lt;/strong&gt; 산업 표준과 규제는 민감한 정보의 안전한 관리를 요구한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;운영 효율성:&lt;/strong&gt; 중앙에서 시크릿을 관리하면 변경 시 각 서비스나 애플리케이션을 수정할 필요 없이 일괄적으로 업데이트할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;secret-management의-핵심-기능&#34;&gt;Secret Management의 핵심 기능&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;암호화 저장&lt;/strong&gt;: 모든 비밀 정보는 &lt;strong&gt;AES-256&lt;/strong&gt; 또는 **KMS(Key Management Service)**를 통해 암호화되어 저장된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Access Token</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</guid>
      <description>&lt;h2 id=&#34;access-token&#34;&gt;Access Token&lt;/h2&gt;
&lt;p&gt;Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.&lt;br&gt;
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;access-token의-특징&#34;&gt;Access Token의 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다.&lt;/li&gt;
&lt;li&gt;Stateless: 서버에 상태를 저장하지 않아 확장성이 높다.&lt;/li&gt;
&lt;li&gt;암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다.&lt;/li&gt;
&lt;li&gt;포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-동작-방식&#34;&gt;Access Token의 동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다.&lt;/li&gt;
&lt;li&gt;토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지).&lt;/li&gt;
&lt;li&gt;요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다.&lt;/li&gt;
&lt;li&gt;서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-장점&#34;&gt;Access Token의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;확장성: Stateless 특성으로 서버 확장이 용이하다.&lt;/li&gt;
&lt;li&gt;보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다.&lt;/li&gt;
&lt;li&gt;효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-단점&#34;&gt;Access Token의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다.&lt;/li&gt;
&lt;li&gt;제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token과-refresh-token&#34;&gt;Access Token과 Refresh Token&lt;/h3&gt;
&lt;p&gt;보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Security</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/</guid>
      <description>&lt;h2 id=&#34;security&#34;&gt;Security&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Consumer-side contract test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</link>
      <pubDate>Mon, 18 Nov 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</guid>
      <description>&lt;h2 id=&#34;consumer-side-contract-test&#34;&gt;Consumer-side Contract Test&lt;/h2&gt;
&lt;p&gt;Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다.&lt;/li&gt;
&lt;li&gt;테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다.&lt;/li&gt;
&lt;li&gt;테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다.&lt;/li&gt;
&lt;li&gt;명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다.&lt;/li&gt;
&lt;li&gt;유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다.&lt;/li&gt;
&lt;li&gt;완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Consumer-Driven Contract Testing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</guid>
      <description>&lt;h2 id=&#34;consumer-driven-contract-testing&#34;&gt;Consumer-Driven Contract Testing&lt;/h2&gt;
&lt;p&gt;Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.&lt;br&gt;
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.&lt;/p&gt;
&lt;p&gt;CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.&lt;/p&gt;
&lt;p&gt;CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 중심: 소비자가 테스트의 주도권을 가진다.&lt;/li&gt;
&lt;li&gt;실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다.&lt;/li&gt;
&lt;li&gt;제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음.&lt;/li&gt;
&lt;li&gt;계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도구&#34;&gt;도구&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pact: CDC 테스팅을 위한 대표적인 도구.&lt;/li&gt;
&lt;li&gt;Testsigma: CDC 테스팅을 지원하는 또 다른 도구.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service Component Test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</guid>
      <description>&lt;h2 id=&#34;service-component-test&#34;&gt;Service Component Test&lt;/h2&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.&lt;br&gt;
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다.&lt;/li&gt;
&lt;li&gt;경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다.&lt;/li&gt;
&lt;li&gt;집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다.&lt;/li&gt;
&lt;li&gt;반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;테스트 환경 설정:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Testing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/</guid>
      <description>&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</guid>
      <description>&lt;h2 id=&#34;back-pressure&#34;&gt;Back Pressure&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Back Pressure&amp;quot;는 마이크로서비스 아키텍처(MSA)의 Reliability 패턴 중 하나로, 시스템의 안정성과 성능을 유지하기 위한 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.&lt;br&gt;
이는 과부하 상태에서 시스템이 완전히 실패하는 것을 방지하고, 가능한 한 많은 요청을 처리할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 MSA의 Reliability를 향상시키는 중요한 패턴이다.&lt;br&gt;
이를 효과적으로 구현하면 시스템의 안정성과 성능을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;back-pressure의-필요성&#34;&gt;Back Pressure의 필요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;시스템 안정성 유지: 과도한 요청으로 인한 시스템 다운을 방지한다.&lt;/li&gt;
&lt;li&gt;리소스 관리: 제한된 리소스를 효율적으로 사용할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;서비스 품질 유지: 일부 요청을 거부하더라도 전체적인 서비스 품질을 유지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;back-pressure-구현-방법&#34;&gt;Back Pressure 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;요청 큐잉&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bulkhead</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</guid>
      <description>Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</guid>
      <description>&lt;h2 id=&#34;cache-aside&#34;&gt;Cache-Aside&lt;/h2&gt;
&lt;p&gt;Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.&lt;br&gt;
이 패턴은 &amp;ldquo;Lazy Loading&amp;rdquo; 또는 &amp;ldquo;Look Aside&amp;rdquo; 패턴으로도 알려져 있다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Cache-aside&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/cache-aside-diagram.png&#34;&gt;&lt;figcaption&gt;https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;애플리케이션이 데이터를 요청한다.&lt;/li&gt;
&lt;li&gt;캐시를 먼저 확인한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서 가져온 데이터를 캐시에 저장한다.&lt;/li&gt;
&lt;li&gt;데이터를 애플리케이션에 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다.&lt;/li&gt;
&lt;li&gt;TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다.&lt;/li&gt;
&lt;li&gt;캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다.&lt;/li&gt;
&lt;li&gt;동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다.&lt;/li&gt;
&lt;li&gt;추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;동시성 처리와 오류 복구를 포함한 버전&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fail Fast</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</guid>
      <description>&lt;h2 id=&#34;fail-fast&#34;&gt;Fail Fast&lt;/h2&gt;
&lt;p&gt;Fail Fast는 MSA의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
잠재적인 문제를 조기에 발견하고 빠르게 대응함으로써 전체 시스템의 안정성과 신뢰성을 향상시킬 수 있다.&lt;/p&gt;
&lt;p&gt;Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙이다.&lt;br&gt;
이는 잠재적인 오류를 조기에 감지하고 빠르게 대응하여 시스템의 안정성을 높이는 데 목적이 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하기 위해서는 철저한 모니터링과 로깅, 적절한 알림 시스템, 그리고 자동화된 복구 메커니즘이 함께 구현되어야 한다. 또한 각 서비스의 특성에 맞는 임계값과 정책을 설정하고, 지속적으로 이를 개선해 나가는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reliability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/</guid>
      <description>&lt;h2 id=&#34;reliability&#34;&gt;Reliability&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</guid>
      <description>이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.</description>
    </item>
    <item>
      <title>Refactoring to services</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/</guid>
      <description>&lt;h2 id=&#34;anti-corruption-layer&#34;&gt;Anti-Corruption Layer&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Circuit Breaker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</link>
      <pubDate>Sun, 17 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</guid>
      <description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Timeout Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</link>
      <pubDate>Sun, 17 Nov 2024 02:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</guid>
      <description>&lt;h2 id=&#34;timeout-pattern&#34;&gt;Timeout Pattern&lt;/h2&gt;
&lt;p&gt;Timeout Pattern은 마이크로서비스 간 통신에서 응답 지연이나 실패를 관리하기 위한 전략이다.&lt;br&gt;
이 패턴은 서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.&lt;/p&gt;
&lt;p&gt;Timeout Pattern은 MSA 환경에서 서비스 간 통신의 신뢰성을 높이고 시스템의 전반적인 안정성을 향상시키는 중요한 전략이다. 적절히 구현된 Timeout Pattern은 마이크로서비스 아키텍처의 장점을 극대화하고 잠재적인 문제를 최소화하는 데 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;타임아웃-패턴의-필요성&#34;&gt;타임아웃 패턴의 필요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 여러 서비스가 네트워크를 통해 상호 작용하므로, 다음과 같은 이유로 타임아웃 패턴이 필요하다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</link>
      <pubDate>Sun, 17 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</guid>
      <description>&lt;h2 id=&#34;retry-pattern&#34;&gt;Retry Pattern&lt;/h2&gt;
&lt;p&gt;Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.&lt;br&gt;
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.&lt;/p&gt;
&lt;p&gt;Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;retry-pattern의-주요-특징&#34;&gt;Retry Pattern의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;재시도 횟수&lt;/strong&gt;: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 간격&lt;/strong&gt;: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백오프 전략&lt;/strong&gt;: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건부 재시도&lt;/strong&gt;: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;retry-pattern-구현-방법&#34;&gt;Retry Pattern 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Retry 사용&lt;/strong&gt;: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resilience4j 사용&lt;/strong&gt;: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스텀 구현&lt;/strong&gt;: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;재시도-패턴-구현-시-고려사항&#34;&gt;재시도 패턴 구현 시 고려사항&lt;/h3&gt;
&lt;p&gt;재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Strangler Application</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</link>
      <pubDate>Sun, 17 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</guid>
      <description>&lt;h2 id=&#34;strangler-application&#34;&gt;Strangler Application&lt;/h2&gt;
&lt;p&gt;Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.&lt;br&gt;
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Application metrics</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</guid>
      <description>Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.</description>
    </item>
    <item>
      <title>Log deployments and changes</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</guid>
      <description>&lt;h2 id=&#34;log-deployments-and-changes&#34;&gt;Log Deployments and Changes&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.&lt;/p&gt;
&lt;h3 id=&#34;패턴의-정의와-목적&#34;&gt;패턴의 정의와 목적&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.&lt;br&gt;
이 패턴의 주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템 변경사항과 문제 발생 간의 상관관계 파악&lt;/li&gt;
&lt;li&gt;문제 해결 시간 단축&lt;/li&gt;
&lt;li&gt;시스템 동작에 대한 이해도 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/</guid>
      <description>&lt;h2 id=&#34;observability&#34;&gt;Observability&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>API Composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</guid>
      <description>이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.</description>
    </item>
    <item>
      <title>Querying</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/</guid>
      <description>&lt;h2 id=&#34;querying&#34;&gt;Querying&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/cqrs/</guid>
      <description>CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.</description>
    </item>
    <item>
      <title>Audit Logging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</link>
      <pubDate>Sat, 16 Nov 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</guid>
      <description>&lt;h2 id=&#34;audit-logging&#34;&gt;Audit Logging&lt;/h2&gt;
&lt;p&gt;Audit Logging은 시스템 내에서 발생하는 중요한 이벤트와 변경사항을 기록하는 프로세스이다.&lt;br&gt;
이는 사용자 활동, 시스템 변경, 데이터 접근 등을 포함하며, 시스템의 동작을 이해하고 문제를 해결하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Audit Logging은 MSA 환경에서 시스템의 투명성, 보안성, 그리고 문제 해결 능력을 크게 향상시킨다. 적절히 구현된 Audit Logging 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;
&lt;h3 id=&#34;기본-구성-요소&#34;&gt;기본 구성 요소&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Audit Log 엔티티 예시&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Entity&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AuditLog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Long&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 이벤트 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 식별자&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 ID&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 수행된 작업&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 전 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 후 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 발생 시간&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// IP 주소&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userAgent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 에이전트&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// getters, setters&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;audit-logging의-중요성&#34;&gt;Audit Logging의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;규정 준수&lt;/strong&gt;: PCI DSS, SOC 2 등의 산업 표준 및 규제 요구사항을 충족하는 데 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;: 비정상적인 활동을 감지하고 보안 위협을 조사하는 데 도움이 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 시스템 장애나 오류의 원인을 파악하는 데 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 행동 이해&lt;/strong&gt;: 고객 지원, 시스템 개선을 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-방법&#34;&gt;Audit Logging 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 로깅 서비스&lt;/strong&gt;: 모든 마이크로서비스의 로그를 한 곳에서 수집하고 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화된 로그 형식&lt;/strong&gt;: 일관된 형식을 사용하여 로그 분석을 용이하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 및 접근 제어&lt;/strong&gt;: 로그 데이터의 무결성과 기밀성을 보장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 대량의 로그 데이터를 효율적으로 처리할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-시-고려사항&#34;&gt;Audit Logging 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;과도한 로깅 vs 부족한 로깅&lt;/strong&gt;: 적절한 수준의 로깅을 유지해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: 로깅이 시스템 성능에 미치는 영향을 최소화해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 보존 정책&lt;/strong&gt;: 로그 데이터의 보존 기간과 방법을 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 모니터링&lt;/strong&gt;: 중요한 이벤트에 대한 실시간 알림 시스템을 구축해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-도구-및-기술&#34;&gt;Audit Logging 도구 및 기술&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Elasticsearch, Logstash, Kibana (ELK) 스택&lt;/strong&gt;: 로그 수집, 저장, 시각화에 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serilog&lt;/strong&gt;:.NET 환경에서 구조화된 로깅을 위한 프레임워크이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka&lt;/strong&gt;: 대규모 로그 스트림 처리에 적합한 메시징 시스템이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud-native 솔루션&lt;/strong&gt;: AWS CloudWatch, Google Cloud Logging 등이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging을-효과적으로-구현하기-위한-방법&#34;&gt;Audit Logging을 효과적으로 구현하기 위한 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비즈니스 로직 내에 로깅 코드 추가&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 구현이 비교적 간단하며, 특정 이벤트에 대한 상세한 로깅이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 비즈니스 로직과 로깅 코드가 혼재되어 코드의 가독성과 유지보수성이 저하될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOP(Aspect-Oriented Programming) 활용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 비즈니스 로직과 로깅 기능을 분리하여 코드의 모듈성을 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 메서드명이나 인수에만 접근할 수 있어, 비즈니스 컨텍스트에 따른 상세한 로깅에는 한계가 있을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 소싱(Event Sourcing) 사용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 시스템의 상태 변화를 이벤트 형태로 저장하여, 모든 변경 이력을 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 쿼리 작업은 이벤트로 기록되지 않으므로, 이러한 작업에 대한 로깅은 별도의 방법을 통해 구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상관 관계 ID 사용&lt;/strong&gt;: 마이크로서비스 간 요청 추적을 위해 고유 ID를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 정보 포함&lt;/strong&gt;: 사용자 ID, 서비스 이름, 요청 ID 등을 로그에 포함한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;민감한 정보 보호&lt;/strong&gt;: 개인정보나 보안 관련 데이터는 마스킹 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로그 레벨 구분&lt;/strong&gt;: 중요도에 따라 로그 레벨을 적절히 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Exception Tracking</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</link>
      <pubDate>Sat, 16 Nov 2024 02:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</guid>
      <description>Exception Tracking은 분산 시스템 전반에 걸쳐 발생하는 예외를 중앙에서 수집, 집계, 분석하는 패턴이다.</description>
    </item>
    <item>
      <title>Distributed Tracing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</guid>
      <description>&lt;h2 id=&#34;distributed-tracing&#34;&gt;Distributed Tracing&lt;/h2&gt;
&lt;p&gt;Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고유 식별자 할당&lt;/strong&gt;: 각 요청에 고유한 Trace ID를 부여한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스팬 생성&lt;/strong&gt;: 요청이 각 서비스를 통과할 때마다 &amp;lsquo;스팬&amp;rsquo;이라는 작업 단위가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;계층 구조&lt;/strong&gt;: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메타데이터 수집&lt;/strong&gt;: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;distributed-tracing의-중요성&#34;&gt;Distributed Tracing의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 관리&lt;/strong&gt;: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 이해&lt;/strong&gt;: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-사용-사례&#34;&gt;주요 사용 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 병목 식별&lt;/strong&gt;: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오류 추적&lt;/strong&gt;: 실패한 요청의 정확한 실패 지점과 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 의존성 분석&lt;/strong&gt;: 서비스 간 통신 패턴과 의존성을 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화&lt;/strong&gt;: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;계측&lt;/strong&gt;: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 수집&lt;/strong&gt;: 각 요청에 대한 스팬 데이터를 수집한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분석 및 시각화&lt;/strong&gt;: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-도구&#34;&gt;주요 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Jaeger&lt;/strong&gt;: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zipkin&lt;/strong&gt;: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Datadog APM&lt;/strong&gt;: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New Relic&lt;/strong&gt;: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;샘플링 전략 수립&lt;/strong&gt;: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 전파&lt;/strong&gt;: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화&lt;/strong&gt;: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시각화 도구 활용&lt;/strong&gt;: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Health Check API</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</guid>
      <description>&lt;h2 id=&#34;health-check-api&#34;&gt;Health Check API&lt;/h2&gt;
&lt;p&gt;Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.&lt;br&gt;
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.&lt;br&gt;
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.&lt;/p&gt;
&lt;h3 id=&#34;health-check-api의-중요성&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고가용성 보장&lt;/strong&gt;: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 조기 발견&lt;/strong&gt;: 서비스의 이상을 조기에 감지하여 대응할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api의-주요-기능&#34;&gt;Health Check API의 주요 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상태 확인:&lt;/strong&gt; 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;종속성 검사:&lt;/strong&gt; 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 모니터링:&lt;/strong&gt; 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api의-중요성-1&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장애 감지:&lt;/strong&gt; 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리 통합:&lt;/strong&gt; 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상:&lt;/strong&gt; 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api-구현-방법&#34;&gt;Health Check API 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;엔드포인트 생성&lt;/strong&gt;: 일반적으로 &lt;code&gt;/health&lt;/code&gt; 또는 &lt;code&gt;/ping&lt;/code&gt; 경로로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;응답 코드&lt;/strong&gt;: 정상 상태일 때 HTTP 200 OK를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 정보 포함&lt;/strong&gt;: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-유형&#34;&gt;Health Check 유형&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Passive Health Checks&lt;/strong&gt;: 실제 요청에 대한 응답을 모니터링한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active Health Checks&lt;/strong&gt;: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent-based Health Checks&lt;/strong&gt;: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-구현-도구&#34;&gt;Health Check API 구현 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot Actuator&lt;/strong&gt;: 자동으로 &lt;code&gt;/actuator/health&lt;/code&gt; 엔드포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes Probes&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Liveness Probe: 애플리케이션이 살아있는지 확인&lt;/li&gt;
&lt;li&gt;Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인&lt;/li&gt;
&lt;li&gt;Startup Probe: 애플리케이션의 시작이 완료되었는지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-모범-사례&#34;&gt;Health Check API 모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상세한 상태 정보&lt;/strong&gt;: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스터마이징&lt;/strong&gt;: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Log Aggregation</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</link>
      <pubDate>Sat, 16 Nov 2024 01:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</guid>
      <description>&lt;h2 id=&#34;log-aggregation&#34;&gt;Log Aggregation&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.&lt;br&gt;
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dead Letter Queue</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</guid>
      <description>&lt;h2 id=&#34;dead-letter-queue&#34;&gt;Dead Letter Queue&lt;/h2&gt;
&lt;p&gt;Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;데드-레터-큐에-메시지가-전달되는-일반적인-상황&#34;&gt;데드 레터 큐에 메시지가 전달되는 일반적인 상황&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;존재하지 않는 큐로의 메시지 전송&lt;/strong&gt;: 메시지가 존재하지 않는 큐로 전송될 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;큐의 최대 길이 초과&lt;/strong&gt;: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 크기 제한 초과&lt;/strong&gt;: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 만료&lt;/strong&gt;: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 거부&lt;/strong&gt;: 다른 큐나 교환기에 의해 메시지가 거부되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;과도한 재시도 실패&lt;/strong&gt;: 메시지가 여러 번 처리되었지만 계속해서 실패할 때.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq의-주요-특징&#34;&gt;DLQ의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분리 저장&lt;/strong&gt;: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재처리 가능성&lt;/strong&gt;: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 문제가 있는 메시지로 인한 시스템 장애를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모니터링 및 알림&lt;/strong&gt;: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-구현-방법&#34;&gt;DLQ 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;큐 생성&lt;/strong&gt;: 일반 큐와 별도로 DLQ를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 정책 설정&lt;/strong&gt;: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLQ 연결&lt;/strong&gt;: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-활용-전략&#34;&gt;DLQ 활용 전략&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분석 및 디버깅&lt;/strong&gt;: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 재처리&lt;/strong&gt;: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;알림 설정&lt;/strong&gt;: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;보존 기간 설정&lt;/strong&gt;: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: DLQ 처리로 인한 시스템 부하를 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;데드-레터-큐를-지원하는-주요-메시징-시스템&#34;&gt;데드 레터 큐를 지원하는 주요 메시징 시스템&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Amazon SQS&lt;/strong&gt;: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apache Kafka&lt;/strong&gt;: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;Node.js와 RabbitMQ를 사용&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Broker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</guid>
      <description>메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.</description>
    </item>
    <item>
      <title>Competing Consumers</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</guid>
      <description>&lt;h2 id=&#34;competing-consumers&#34;&gt;Competing Consumers&lt;/h2&gt;
&lt;p&gt;Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.&lt;/p&gt;
&lt;p&gt;Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다.&lt;/li&gt;
&lt;li&gt;메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다.&lt;/li&gt;
&lt;li&gt;경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메시지 생산자(Producer)&lt;/strong&gt;: 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐(Message Queue)&lt;/strong&gt;: 게시된 메시지는 큐에 저장되어 대기한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 소비자(Consumer)&lt;/strong&gt;: 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 구조를 통해 시스템은 &lt;strong&gt;작업 부하를 여러 소비자 인스턴스에 분산&lt;/strong&gt;시켜 병목 현상을 방지하고, &lt;strong&gt;동시 처리 능력&lt;/strong&gt;을 향상시킨다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Filter</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</guid>
      <description>&lt;h2 id=&#34;message-filter&#34;&gt;Message Filter&lt;/h2&gt;
&lt;p&gt;Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.&lt;br&gt;
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;단일 입력 채널과 단일 출력 채널을 가진다.&lt;/li&gt;
&lt;li&gt;정의된 기준에 따라 메시지를 평가한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하는 메시지만 출력 채널로 전달한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하지 않는 메시지는 폐기된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;필터 조건 정의: 메시지를 평가할 기준을 설정한다.&lt;/li&gt;
&lt;li&gt;메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다.&lt;/li&gt;
&lt;li&gt;메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방식&#34;&gt;구현 방식&lt;/h3&gt;
&lt;p&gt;메시지 필터는 주로 다음과 같은 방식으로 구현된다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Router</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</guid>
      <description>Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/</guid>
      <description>&lt;h2 id=&#34;messaging&#34;&gt;Messaging&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</guid>
      <description>&lt;h2 id=&#34;idempotent-consumer&#34;&gt;Idempotent Consumer&lt;/h2&gt;
&lt;p&gt;Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Domain event</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</link>
      <pubDate>Fri, 15 Nov 2024 11:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</guid>
      <description>&lt;h2 id=&#34;domain-event&#34;&gt;Domain Event&lt;/h2&gt;
&lt;p&gt;도메인 이벤트(Domain Event)는 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하고 시스템 간 의존성을 줄이며 확장성을 높이는 데 중요한 개념이다.&lt;br&gt;
도메인 이벤트는 주로 &lt;strong&gt;도메인 주도 설계(DDD)&lt;/strong&gt; 의 개념에서 비롯되었으며, 비즈니스 로직과 시스템 상태 변화의 핵심을 나타낸다.&lt;br&gt;
이를 통해 분산 시스템에서 데이터 일관성과 비즈니스 흐름을 효과적으로 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;도메인 이벤트는 &lt;strong&gt;도메인 내에서 발생한 중요한 상태 변화&lt;/strong&gt;를 나타내는 객체이다.&lt;br&gt;
이는 과거에 발생한 사건을 기술하며, 다른 모듈이나 시스템이 해당 이벤트를 구독하고 적절히 반응할 수 있도록 설계된다. 예를 들어, 전자상거래 시스템에서 &amp;ldquo;주문이 생성됨(Order Created)&amp;ldquo;이나 &amp;ldquo;결제가 완료됨(Payment Completed)&amp;rdquo; 같은 사건이 도메인 이벤트로 표현될 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Saga Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</link>
      <pubDate>Fri, 15 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</guid>
      <description>Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Aggregate Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</link>
      <pubDate>Fri, 15 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</guid>
      <description>Aggregate 패턴은 도메인 주도 설계(DDD)에서 유래한 개념으로, 관련된 객체들을 하나의 단위로 묶어 데이터 변경 시 일관성을 유지한다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-sourcing/</guid>
      <description>&lt;h2 id=&#34;event-sourcing&#34;&gt;Event Sourcing&lt;/h2&gt;
&lt;p&gt;Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.&lt;br&gt;
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.&lt;/p&gt;
&lt;p&gt;Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;event-sourcing의-핵심-개념&#34;&gt;Event Sourcing의 핵심 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 중심 저장&lt;/strong&gt;: 시스템의 모든 상태 변경을 이벤트로 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;불변성&lt;/strong&gt;: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 순서&lt;/strong&gt;: 이벤트는 발생한 순서대로 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성&lt;/strong&gt;: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-장점&#34;&gt;Event Sourcing의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;완전한 감사 추적&lt;/strong&gt;: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 여행 가능&lt;/strong&gt;: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-구현-방법&#34;&gt;Event Sourcing의 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 정의&lt;/strong&gt;: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 저장소&lt;/strong&gt;: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 핸들러&lt;/strong&gt;: 각 이벤트 유형에 대한 처리 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성 로직&lt;/strong&gt;: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-주의사항&#34;&gt;Event Sourcing의 주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 버전 관리&lt;/strong&gt;: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최종 일관성&lt;/strong&gt;: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;이벤트-소싱의-구현-시-고려사항&#34;&gt;이벤트 소싱의 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;이벤트 저장소(Event Store)&lt;/strong&gt;: 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Maintaining Data Consistency</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/</link>
      <pubDate>Fri, 15 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/</guid>
      <description>&lt;h2 id=&#34;maintaining-data-consistency&#34;&gt;Maintaining Data Consistency&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>External API</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/</link>
      <pubDate>Thu, 14 Nov 2024 18:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/</guid>
      <description>&lt;h2&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>3rd party registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</guid>
      <description>이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.</description>
    </item>
    <item>
      <title>Self registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</guid>
      <description>&lt;h2 id=&#34;self-registration&#34;&gt;Self Registration&lt;/h2&gt;
&lt;p&gt;Self Registration은 각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다. 서비스가 시작될 때 자동으로 등록되고, 종료될 때 해제되는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;Self Registration 패턴은 마이크로서비스 환경에서 동적으로 변화하는 서비스 인스턴스를 효과적으로 관리할 수 있게 해주는 중요한 패턴이다. 하지만 구현의 복잡성과 유지보수 측면에서 주의가 필요하며, 프로젝트의 규모와 요구사항에 따라 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;자동 등록&lt;/strong&gt;: 서비스 인스턴스가 시작될 때 자신의 정보(호스트, IP 주소, 포트 등)를 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 해제&lt;/strong&gt;: 서비스가 종료될 때 레지스트리에서 자신의 정보를 제거한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;헬스체크&lt;/strong&gt;: 주기적으로 레지스트리에 헬스체크 신호를 보내 자신이 살아있음을 알린다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 관리&lt;/strong&gt;: 서비스 인스턴스가 자신의 상태를 가장 잘 알기 때문에, UP/DOWN 외에도 STARTING, AVAILABLE 등 더 복잡한 상태 모델을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 레지스트리 설정: Eureka, Consul, ZooKeeper 등의 도구를 사용하여 중앙 레지스트리를 구축한다.&lt;/li&gt;
&lt;li&gt;서비스 등록 코드 구현: 각 마이크로서비스에 자신을 레지스트리에 등록하는 코드를 추가한다.&lt;/li&gt;
&lt;li&gt;헬스체크 메커니즘 구현: 주기적으로 레지스트리에 헬스체크 신호를 보내는 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리 클라이언트 구현: 다른 서비스들이 등록된 서비스를 찾고 통신할 수 있도록 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;구현이 비교적 간단하다.&lt;/li&gt;
&lt;li&gt;추가적인 시스템 컴포넌트가 필요하지 않다.&lt;/li&gt;
&lt;li&gt;서비스가 자신의 상태를 가장 잘 알기 때문에 정확한 정보를 제공할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스와 레지스트리 간의 결합도가 높아진다.&lt;/li&gt;
&lt;li&gt;각 프로그래밍 언어와 프레임워크마다 등록 로직을 구현해야 한다.&lt;/li&gt;
&lt;li&gt;서비스가 비정상적으로 종료될 경우 레지스트리에서 자동으로 제거되지 않을 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Netflix Eureka&lt;/strong&gt;는 셀프 등록 패턴의 대표적인 예시이다.&lt;br&gt;
Eureka 클라이언트는 다음과 같은 방식으로 동작한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Server-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</guid>
      <description>&lt;h2 id=&#34;server-side-discovery&#34;&gt;Server-side Discovery&lt;/h2&gt;
&lt;p&gt;Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.&lt;/p&gt;
&lt;p&gt;Server-side Discovery는 클라이언트를 단순화하고 중앙 집중식 관리를 가능하게 하는 장점이 있지만, 추가 인프라와 관리가 필요한 단점도 있다. 프로젝트의 요구사항과 팀의 역량을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 등록: 각 서비스 인스턴스는 시작 시 자신의 정보를 서비스 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;클라이언트 요청: 클라이언트는 서비스의 실제 위치를 모르고, 로드 밸런서에 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;서비스 조회: 로드 밸런서는 서비스 레지스트리에서 해당 서비스의 가용한 인스턴스 정보를 조회한다.&lt;/li&gt;
&lt;li&gt;요청 라우팅: 로드 밸런서는 적절한 서비스 인스턴스를 선택하여 요청을 전달한다.&lt;/li&gt;
&lt;li&gt;응답 반환: 서비스의 응답은 로드 밸런서를 통해 클라이언트에게 전달된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트 단순화: 클라이언트는 서비스 디스커버리 로직을 구현할 필요가 없어 단순해진다.&lt;/li&gt;
&lt;li&gt;언어 중립성: 클라이언트 측 구현이 필요 없어 다양한 프로그래밍 언어로 개발된 서비스들을 쉽게 통합할 수 있다.&lt;/li&gt;
&lt;li&gt;보안 강화: 로드 밸런서 수준에서 추가적인 보안 계층을 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;중앙 집중식 관리: 서비스 디스커버리와 로드 밸런싱을 중앙에서 관리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;추가 인프라 필요: 로드 밸런서나 프록시 서버와 같은 추가 인프라가 필요하다.&lt;/li&gt;
&lt;li&gt;단일 실패 지점: 로드 밸런서가 단일 실패 지점이 될 수 있어 고가용성 설계가 중요하다.&lt;/li&gt;
&lt;li&gt;복잡성 증가: 전체 시스템의 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AWS Elastic Load Balancer (ELB)&lt;/strong&gt;: 클라이언트는 ELB의 DNS 이름을 통해 요청을 보내며, ELB는 등록된 EC2 인스턴스나 ECS 컨테이너 사이에서 부하를 분산한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes의 kube-proxy&lt;/strong&gt;: Kubernetes에서는 각 노드에서 실행되는 kube-proxy가 서비스 디스커버리와 로드 밸런싱을 담당하며, 클러스터 내의 서비스 요청을 적절한 파드(Pod)로 전달한다.&lt;/li&gt;
&lt;li&gt;Node.js를 사용한 Server-side Discovery 구현 예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-21&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-21&#34;&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-22&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-22&#34;&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-23&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-23&#34;&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-24&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-24&#34;&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-25&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-25&#34;&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-26&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-26&#34;&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-27&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-27&#34;&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-28&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-28&#34;&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-29&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-29&#34;&gt;29&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-30&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-30&#34;&gt;30&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-31&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-31&#34;&gt;31&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-32&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-32&#34;&gt;32&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-33&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-33&#34;&gt;33&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-34&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-34&#34;&gt;34&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-35&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-35&#34;&gt;35&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-36&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-36&#34;&gt;36&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-37&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-37&#34;&gt;37&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-38&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-38&#34;&gt;38&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-39&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-39&#34;&gt;39&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-40&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-40&#34;&gt;40&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-41&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-41&#34;&gt;41&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-42&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-42&#34;&gt;42&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-43&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-43&#34;&gt;43&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-44&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-44&#34;&gt;44&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-45&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-45&#34;&gt;45&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-46&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-46&#34;&gt;46&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-47&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-47&#34;&gt;47&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-48&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-48&#34;&gt;48&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-49&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-49&#34;&gt;49&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-50&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-50&#34;&gt;50&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-51&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-51&#34;&gt;51&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-52&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-52&#34;&gt;52&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 서버 사이드 디스커버리 라우터 구현
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServiceRouter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://service-registry:8500&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 30초
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extractServiceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 서비스 인스턴스 찾기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 요청 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 응답 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handleError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 캐시된 서비스 확인
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getCachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 서비스 레지스트리 조회
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;queryRegistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;updateCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buildTargetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service registry</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</guid>
      <description>&lt;h2 id=&#34;service-registry&#34;&gt;Service Registry&lt;/h2&gt;
&lt;p&gt;Service Registry는 마이크로서비스 환경에서 각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스이다.&lt;br&gt;
이는 동적으로 변화하는 마이크로서비스 환경에서 서비스 디스커버리를 가능하게 하는 핵심 요소이다.&lt;/p&gt;
&lt;p&gt;Service Registry는 MSA 환경에서 서비스 디스커버리를 가능하게 하는 핵심 컴포넌트이다. 이를 통해 동적이고 확장 가능한 마이크로서비스 아키텍처를 구현할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;서비스-레지스트리의-중요성&#34;&gt;서비스 레지스트리의 중요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 서비스 인스턴스가 자동 확장, 장애 복구, 배포 등의 이유로 동적으로 생성되고 소멸되며, 이에 따라 네트워크 위치가 변경된다.&lt;br&gt;
이러한 동적인 특성으로 인해, 서비스 레지스트리는 다음과 같은 역할을 수행한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</guid>
      <description>&lt;h2 id=&#34;client-side-discovery&#34;&gt;Client-side Discovery&lt;/h2&gt;
&lt;p&gt;Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.&lt;/p&gt;
&lt;p&gt;Client-side Discovery는 마이크로서비스 환경에서 유연하고 확장 가능한 서비스 디스커버리 방식을 제공한다. 그러나 클라이언트의 복잡도가 증가하는 단점이 있으므로, 프로젝트의 요구사항과 팀의 기술 스택을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;서비스 레지스트리(Service Registry)&lt;/strong&gt;: 각 서비스 인스턴스의 네트워크 위치(예: IP 주소, 포트)를 저장하고 관리하는 데이터베이스이다. 서비스 인스턴스는 시작 시 자신의 정보를 레지스트리에 등록하고, 종료 시 등록을 해제한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Backend for Frontend Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</link>
      <pubDate>Thu, 14 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</guid>
      <description>BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다.</description>
    </item>
    <item>
      <title>Service Discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/</link>
      <pubDate>Thu, 14 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/</guid>
      <description>&lt;h2 id=&#34;service-discovery&#34;&gt;Service Discovery&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Service Discovery는 핵심적인 패턴 중 하나이다.&lt;br&gt;
이 패턴은 동적으로 변화하는 분산 환경에서 서비스 간 통신을 가능하게 하는 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Service Discovery는 네트워크 상의 서비스 위치(IP 주소와 포트)를 자동으로 감지하고 관리하는 프로세스이다.&lt;br&gt;
이는 클라우드 환경이나 컨테이너 기반 아키텍처에서 특히 중요한데, 서비스 인스턴스가 동적으로 생성되고 제거되는 상황에서 효과적인 통신을 가능하게 한다.&lt;/p&gt;
&lt;h3 id=&#34;필요성&#34;&gt;필요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;동적 환경 대응: 클라우드 및 컨테이너 기반 환경에서 서비스의 IP 주소와 포트가 동적으로 변경된다.&lt;/li&gt;
&lt;li&gt;자동 스케일링: 서비스 인스턴스가 자동으로 추가되거나 제거될 때 이를 감지하고 관리해야 한다.&lt;/li&gt;
&lt;li&gt;장애 대응: 서비스 장애 시 자동으로 대체 인스턴스로 전환할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;service-discovery의-주요-구성-요소&#34;&gt;Service Discovery의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;서비스 레지스트리&lt;/strong&gt;: 사용 가능한 서비스 인스턴스의 네트워크 위치를 저장하는 데이터베이스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 등록&lt;/strong&gt;: 서비스 인스턴스가 시작될 때 자신의 정보를 레지스트리에 등록하는 프로세스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 발견&lt;/strong&gt;: 클라이언트가 필요한 서비스의 위치를 레지스트리에서 조회하는 프로세스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 모니터링&lt;/strong&gt;: 등록된 서비스의 상태를 주기적으로 확인하는 메커니즘&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;service-discovery-패턴의-종류&#34;&gt;Service Discovery 패턴의 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Client-Side Discovery: 클라이언트가 직접 서비스 레지스트리에 질의하여 서비스 위치를 찾는 방식.&lt;br&gt;
장점:&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Gateway Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway-pattern/</link>
      <pubDate>Thu, 14 Nov 2024 01:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway-pattern/</guid>
      <description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</description>
    </item>
    <item>
      <title>Service deployment platform</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</guid>
      <description>&lt;h2 id=&#34;service-deployment-platform&#34;&gt;Service Deployment Platform&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service deployment platform&amp;quot;은 마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼이다. 이 플랫폼은 개발자들이 마이크로서비스를 쉽게 개발, 배포, 운영할 수 있도록 지원하는 종합적인 환경을 제공한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;자동화된 배포: Service deployment platform은 CI/CD (지속적 통합/지속적 배포) 파이프라인을 통해 자동화된 배포 프로세스를 제공한다. 이를 통해 개발자는 코드 변경사항을 빠르고 안정적으로 프로덕션 환경에 반영할 수 있다.&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션: 대부분의 Service deployment platform은 쿠버네티스와 같은 컨테이너 오케스트레이션 도구를 기반으로 한다. 이를 통해 마이크로서비스의 확장성, 가용성, 복원력을 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리: 플랫폼은 서비스 디스커버리 메커니즘을 제공하여 마이크로서비스 간의 통신을 용이하게 한다. 이를 통해 동적으로 변화하는 환경에서도 서비스 간 연결을 유지할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅: Service deployment platform은 통합된 모니터링 및 로깅 기능을 제공한다. 이를 통해 개발자와 운영팀은 서비스의 성능을 실시간으로 모니터링하고 문제를 신속하게 진단할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 레지스트리: 서비스의 컨테이너 이미지를 저장하고 관리하는 중앙 저장소이다.&lt;/li&gt;
&lt;li&gt;오케스트레이션 엔진: 쿠버네티스와 같은 도구로, 컨테이너의 배포, 스케일링, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;API 게이트웨이: 클라이언트 요청을 적절한 마이크로서비스로 라우팅하고 인증, 로드 밸런싱 등의 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;서비스 메시: 마이크로서비스 간의 통신을 관리하고 모니터링하는 인프라 레이어이다.&lt;/li&gt;
&lt;li&gt;설정 관리: 다양한 환경(개발, 테스트, 프로덕션)에 대한 설정을 중앙에서 관리한다.&lt;/li&gt;
&lt;li&gt;로깅 및 모니터링 도구: 서비스의 성능과 상태를 추적하고 분석하는 도구들이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;개발 생산성 향상: 개발자가 인프라 관리보다는 비즈니스 로직 개발에 집중할 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;빠른 배포 및 롤백: 자동화된 프로세스를 통해 신속한 배포와 문제 발생 시 빠른 롤백이 가능하다.&lt;/li&gt;
&lt;li&gt;확장성: 트래픽 증가에 따라 서비스를 쉽게 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;운영 효율성: 자동화된 모니터링과 관리 도구를 통해 운영 효율성을 높일 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;대표적인-서비스-배포-플랫폼&#34;&gt;대표적인 서비스 배포 플랫폼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;쿠버네티스(Kubernetes):&lt;/strong&gt; 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 플랫폼으로, MSA 환경에서 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오픈시프트(OpenShift):&lt;/strong&gt; 레드햇에서 개발한 쿠버네티스 기반의 엔터프라이즈급 애플리케이션 플랫폼으로, 추가적인 개발자 및 운영자 도구를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이스티오(Istio):&lt;/strong&gt; 서비스 메시(Service Mesh) 구현체로, 서비스 간의 통신, 보안, 모니터링, 트래픽 관리를 지원하여 MSA의 운영 복잡성을 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도입-시-고려사항&#34;&gt;도입 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;러닝 커브:&lt;/strong&gt; 새로운 플랫폼 도입에 따른 학습 곡선이 있을 수 있으므로, 충분한 교육과 학습 기간이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인프라 요구사항:&lt;/strong&gt; 플랫폼이 요구하는 인프라 자원을 사전에 평가하고, 이에 맞게 인프라를 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; 플랫폼 자체의 보안 기능과 더불어, 조직의 보안 정책에 부합하는지 검토해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커뮤니티 및 지원:&lt;/strong&gt; 플랫폼의 커뮤니티 활성도와 지원 체계를 확인하여, 문제 발생 시 신속한 대응이 가능한지 판단해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</guid>
      <description>&lt;h2 id=&#34;service-per-vm&#34;&gt;Service per VM&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; (VM당 서비스) 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식이다. 이 패턴의 주요 특징과 장단점을 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; 패턴은 강력한 격리와 리소스 관리를 제공하지만, 리소스 오버헤드와 관리 복잡성 증가라는 대가가 따른다. 이 패턴은 높은 수준의 격리가 필요하거나 서비스 간 리소스 경쟁을 최소화해야 하는 경우에 적합하다.&lt;br&gt;
그러나 리소스 효율성과 빠른 배포가 중요한 경우에는 다른 배포 패턴을 고려해볼 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</guid>
      <description>&lt;h2 id=&#34;multiple-services-per-host&#34;&gt;Multiple Services per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Multiple Services per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;이 패턴에서는 하나 이상의 물리적 또는 가상 호스트를 준비하고, 각 호스트에 여러 개의 서비스 인스턴스를 실행한다. 이는 전통적인 애플리케이션 배포 방식을 반영한 것이다.&lt;/p&gt;
&lt;p&gt;이 패턴은 리소스 효율성과 배포 용이성이라는 장점이 있지만, 복잡성 증가와 서비스 간 격리 부족이라는 단점도 있다. 따라서 프로젝트의 요구사항과 규모에 따라 신중하게 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per-Container</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</guid>
      <description>&lt;h2 id=&#34;service-per-container&#34;&gt;Service per-Container&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-Container&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;독립성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;경량화&lt;/strong&gt;: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이식성&lt;/strong&gt;: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 &amp;ldquo;한 번 빌드하고 어디서나 실행&amp;quot;이라는 원칙을 실현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;버전 관리&lt;/strong&gt;: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장애 격리&lt;/strong&gt;: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기술 스택 다양성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;배포 유연성&lt;/strong&gt;: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 오버헤드&lt;/strong&gt;: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;통신 오버헤드&lt;/strong&gt;: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컨테이너 오케스트레이션&lt;/strong&gt;: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리&lt;/strong&gt;: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;컨테이너 이미지 최적화
&lt;ol&gt;
&lt;li&gt;기반 이미지 최소화&lt;/li&gt;
&lt;li&gt;멀티 스테이지 빌드 적용&lt;/li&gt;
&lt;li&gt;캐시 레이어 최적화&lt;/li&gt;
&lt;li&gt;불필요한 파일 제거&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;네트워킹
&lt;ol&gt;
&lt;li&gt;서비스간 통신 설정&lt;/li&gt;
&lt;li&gt;네트워크 보안 정책&lt;/li&gt;
&lt;li&gt;로드 밸런싱&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 이미지 생성:
&lt;ul&gt;
&lt;li&gt;각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다.&lt;/li&gt;
&lt;li&gt;Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션:
&lt;ul&gt;
&lt;li&gt;Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅 설정:
&lt;ul&gt;
&lt;li&gt;Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;p&gt;예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</guid>
      <description>&lt;h2 id=&#34;single-service-per-host&#34;&gt;Single Service per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Single Service per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</guid>
      <description>&lt;h2 id=&#34;serverless-deployment&#34;&gt;Serverless Deployment&lt;/h2&gt;
&lt;p&gt;Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 혁신적인 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.&lt;/p&gt;
&lt;p&gt;결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</guid>
      <description>&lt;h2 id=&#34;self-contained-service&#34;&gt;Self-contained Service&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;self-contained service&amp;rdquo; 패턴은 서비스의 자율성과 독립성을 극대화하는 중요한 개념이다.&lt;/p&gt;
&lt;p&gt;Self-contained Service는 단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.&lt;br&gt;
이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.&lt;/p&gt;
&lt;p&gt;Self-contained Service 패턴은 MSA의 핵심 원칙을 구현하는 방법 중 하나로, 서비스의 자율성과 독립성을 극대화하여 시스템의 유연성과 확장성을 높이는 데 기여한다. 하지만 이 패턴을 적용할 때는 시스템의 복잡성 증가와 데이터 일관성 관리 등의 도전 과제를 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</guid>
      <description>&lt;h2 id=&#34;service-per-team&#34;&gt;Service per Team&lt;/h2&gt;
&lt;p&gt;Service per team 패턴은 각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식이다.&lt;br&gt;
이 패턴에서는 각 팀이 특정 비즈니스 기능을 담당하며, 해당 기능의 코드베이스를 소유한다.&lt;/p&gt;
&lt;p&gt;Service per team 패턴은 팀의 자율성과 책임감을 높이는 동시에 마이크로서비스 아키텍처의 이점을 최대화할 수 있는 효과적인 접근 방식이다. 그러나 이 패턴을 성공적으로 구현하기 위해서는 조직 문화, 팀 구조, 그리고 기술적 인프라 등 여러 측면에서의 신중한 고려가 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성&lt;/strong&gt;: 각 팀은 자신의 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 중심 협업&lt;/strong&gt;: 팀들은 주로 API를 통해 상호작용하며, 다른 팀과의 협업을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소규모 팀&lt;/strong&gt;: 일반적으로 &amp;ldquo;two-pizza team&amp;rdquo; 크기의 소규모 팀이 각 서비스를 담당한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인지 부하 감소&lt;/strong&gt;: 팀원들이 전체 시스템이 아닌 특정 서비스에만 집중할 수 있어 인지 부하가 감소한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성 강화&lt;/strong&gt;: 각 팀이 독립적으로 의사 결정을 내릴 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;느슨한 결합&lt;/strong&gt;: 팀 간의 의존성이 줄어들어 더 유연한 개발이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;코드 품질 향상&lt;/strong&gt;: 장기적인 코드 소유권으로 인해 코드 품질이 개선된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빠른 개발 및 배포&lt;/strong&gt;: 작은 팀이 독립적으로 개발하고 배포할 수 있어 시장 변화에 빠르게 대응할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡한 프로젝트 조정&lt;/strong&gt;: 여러 서비스에 걸친 복잡한 프로젝트의 경우 팀 간 조정이 어려워질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;높은 WIP (Work in Progress)&lt;/strong&gt;: 각 팀이 항상 바쁘게 유지되어야 하므로 진행 중인 작업이 많아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;좁은 가치 흐름&lt;/strong&gt;: 이상적인 구현에서는 팀들이 완전히 분리되어 있어, 조직 전체의 가치 흐름이 좁아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화되지 않은 우선순위 지정&lt;/strong&gt;: 팀의 가용성이 프로젝트 우선순위 결정의 주요 요인이 될 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 구성&lt;/strong&gt;: 각 서비스를 담당할 수 있는 cross-functional 팀을 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 경계 정의&lt;/strong&gt;: 비즈니스 기능과 하위 도메인을 기반으로 서비스 경계를 명확히 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀 간 커뮤니케이션&lt;/strong&gt;: API 설계와 변경에 대한 팀 간 효과적인 커뮤니케이션 채널을 구축해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 새로운 팀을 추가하거나 기존 서비스를 분할할 때의 전략을 미리 수립해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;&lt;strong&gt;예시:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;대규모 전자상거래 플랫폼을 운영하는 기업을 예로 들어보자.&lt;br&gt;
이 기업은 다음과 같은 주요 비즈니스 기능을 가지고 있다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Service Mesh</title>
      <link>https://buenhyden.github.io/posts/devops/service-mesh/</link>
      <pubDate>Wed, 13 Nov 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops/service-mesh/</guid>
      <description>마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하기 위한 인프라 계층</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</guid>
      <description>&lt;h2 id=&#34;decompose-by-business-capability&#34;&gt;Decompose by Business Capability&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Business Capability&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴이다.&lt;br&gt;
이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.&lt;/p&gt;
&lt;p&gt;이 패턴은 조직의 비즈니스 능력을 기반으로 마이크로서비스를 정의한다.&lt;br&gt;
비즈니스 능력은 조직이 가치를 창출하기 위해 수행하는 특정 기능이나 프로세스를 의미한다.&lt;/p&gt;
&lt;p&gt;주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비즈니스 목표와 소프트웨어 개발의 정렬&lt;/li&gt;
&lt;li&gt;독립적으로 개발 및 유지보수 가능한 서비스 생성&lt;/li&gt;
&lt;li&gt;조직 구조와 시스템 아키텍처의 일치&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 조직의 비즈니스 도메인에 대한 깊은 이해가 필요하며, 지속적인 비즈니스 분석과 서비스 경계의 조정이 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</guid>
      <description>&lt;h2 id=&#34;decompose-by-subdomain&#34;&gt;Decompose by Subdomain&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Subdomain&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴 중 하나이다.&lt;br&gt;
이 패턴은 도메인 주도 설계(DDD)의 개념을 기반으로 하며, 비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법이다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 비즈니스 도메인에 대한 깊은 이해와 지속적인 분석이 필요하다. 또한, 하위 도메인 간의 상호작용을 고려하여 서비스 간 통신을 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 중심 접근: 기술적 세부사항보다 비즈니스 기능에 초점을 맞춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하위 도메인 분류:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;핵심(Core): 비즈니스의 핵심 차별화 요소&lt;/li&gt;
&lt;li&gt;지원(Supporting): 비즈니스 관련이지만 차별화 요소는 아님&lt;/li&gt;
&lt;li&gt;일반(Generic): 비즈니스 특화되지 않은 일반적 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경계 설정: 각 하위 도메인은 명확한 경계(Bounded Context)를 가진다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decomposition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/</guid>
      <description>&lt;h2 id=&#34;decomposition&#34;&gt;Decomposition&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Deployment</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/</guid>
      <description>&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Database</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/</guid>
      <description>&lt;h2 id=&#34;database&#34;&gt;Database&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Domain-specific</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</guid>
      <description>Domain-specific 프로토콜은 특정 도메인이나 비즈니스 영역에 특화된 통신 프로토콜을 의미한다.  이 프로토콜은 일반적인 통신 프로토콜보다 해당 도메인의 특성과 요구사항에 더 적합하게 설계되어 있다.</description>
    </item>
    <item>
      <title>Remote-Procedure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</guid>
      <description>Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.</description>
    </item>
    <item>
      <title>Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</link>
      <pubDate>Tue, 12 Nov 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</guid>
      <description>Messaging은 서비스들이 메시지를 통해 비동기적으로 통신하는 방식이다. 서비스들은 메시지 브로커를 통해 메시지를 주고받으며, 이를 통해 느슨한 결합(loose coupling)을 실현한다.</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Microservice Chassis</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</guid>
      <description>&lt;h2 id=&#34;microservice-chassis&#34;&gt;Microservice Chassis&lt;/h2&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 프레임워크나 라이브러리 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 개발에 필요한 공통 기능을 제공하는 기본 프레임워크이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공통 기능의 추상화:&lt;/strong&gt; 인증 및 권한 부여, 로깅, 설정 관리, 헬스 체크, 메트릭 수집, 분산 추적 등 여러 서비스에 걸쳐 공통적으로 필요한 기능들을 섀시에서 제공하여 코드 중복을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관된 빌드 및 배포 프로세스:&lt;/strong&gt; 빌드 로직과 배포 설정을 섀시에서 관리하여, 모든 서비스가 일관된 방식으로 빌드되고 배포될 수 있도록 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 새로운 서비스 개발 시 섀시를 기반으로 빠르게 시작할 수 있으며, 공통 기능의 변경이 필요할 경우 섀시를 업데이트하여 모든 서비스에 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Microservice Chassis는 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service Template</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</link>
      <pubDate>Tue, 12 Nov 2024 11:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</guid>
      <description>&lt;h2 id=&#34;service-template&#34;&gt;Service Template&lt;/h2&gt;
&lt;p&gt;Service Template 패턴은 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 중요한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 템플릿 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Service Template은 마이크로서비스 개발에 필요한 공통 기능과 구조를 제공하는 기본 템플릿이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;재사용 가능한 코드 기반:&lt;/strong&gt; 서비스 템플릿은 빌드 로직, 공통 설정, 크로스커팅 관심사(예: 로깅, 보안, 설정 관리 등)를 포함한 실행 가능한 간단한 서비스를 제공한다. 이를 통해 새로운 서비스를 시작할 때 필요한 기본 구조를 빠르게 구축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관성 유지:&lt;/strong&gt; 모든 서비스가 동일한 템플릿을 기반으로 생성되므로, 코드 구조와 설정이 일관되어 유지보수성과 가독성이 향상된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Service Template은 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Database per Service Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</guid>
      <description>&lt;h2 id=&#34;shared-database&#34;&gt;Shared Database&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;Shared Database&amp;rdquo; 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Communication style</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/</link>
      <pubDate>Tue, 12 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/</guid>
      <description>&lt;h2 id=&#34;communication-style&#34;&gt;Communication style&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Cross-Cutting Concern Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/</link>
      <pubDate>Tue, 12 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/</guid>
      <description>Ambassador pattern, Service Discovery pattern, Service Mesh pattern, 그리고 Sidecar pattern은 모두 마이크로서비스 아키텍처에서 발생하는 cross-cutting concern(횡단 관심사)를 해결하기 위한 디자인 패턴들이다.</description>
    </item>
    <item>
      <title>멀티 테넌시(Multi-tenancy)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/</link>
      <pubDate>Fri, 27 Sep 2024 14:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/</guid>
      <description>하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.</description>
    </item>
    <item>
      <title>Rate Limiting Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/</guid>
      <description>&lt;h2 id=&#34;rate-limiting-pattern&#34;&gt;Rate Limiting Pattern&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Rate Limiting Pattern&amp;quot;은 소프트웨어 아키텍처에서 &lt;strong&gt;서비스의 과도한 사용을 방지&lt;/strong&gt;하고 자원을 공정하게 분배하기 위한 핵심 전략이다.&lt;br&gt;
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rate Limiting&lt;/strong&gt;은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.&lt;br&gt;
주로 다음 목적을 위해 사용된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;서비스 장애 예방&lt;/strong&gt;: DDoS 공격, API 오용, 리소스 고갈 방지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비용 관리&lt;/strong&gt;: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;공정한 자원 분배&lt;/strong&gt;: 특정 사용자가 시스템을 독점하지 않도록 제어.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless Architecture</title>
      <link>https://buenhyden.github.io/posts/devops/serverless/serverless-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops/serverless/serverless-architecture/</guid>
      <description>Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.</description>
    </item>
    <item>
      <title>Publisher-Subscriber Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/</guid>
      <description>이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/retry-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/retry-pattern/</guid>
      <description>분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.</description>
    </item>
    <item>
      <title>Model-View-ViewModel Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/</guid>
      <description>MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.</description>
    </item>
    <item>
      <title>Monolithic Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/monolithic/monolithic-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/monolithic/monolithic-pattern/</guid>
      <description>애플리케이션의 모든 구성 요소가 단일 코드베이스와 단일 실행 단위로 통합된 형태</description>
    </item>
    <item>
      <title>Service-oriented architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/service-oriented-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/service-oriented-architecture/</guid>
      <description>**Service-Oriented Architecture(SOA)**는 기업의 복잡한 IT 시스템을 **비즈니스 기능 단위의 서비스**로 모듈화하고, 이를 조합해 유연한 애플리케이션을 구축하는 소프트웨어 설계 패턴이다.</description>
    </item>
    <item>
      <title>Model–view–presenter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/modelviewpresenter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 09:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/modelviewpresenter-pattern/</guid>
      <description>Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.</description>
    </item>
    <item>
      <title>Message Queues and Streams</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/message-queues-and-streams/</link>
      <pubDate>Fri, 27 Sep 2024 09:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/message-queues-and-streams/</guid>
      <description>메시지 큐는 작업의 안정적인 처리와 시스템 간 결합도 감소에 적합하며, 스트림은 실시간 데이터 처리와 분석에 더 적합하다.</description>
    </item>
    <item>
      <title>Microkernel Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/</guid>
      <description>시스템의 핵심 기능을 최소화하고 확장성과 유연성을 극대화하는 설계 방식</description>
    </item>
    <item>
      <title>Repository Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/</guid>
      <description>데이터 접근 로직을 추상화하고 캡슐화하여 비즈니스 로직과 데이터 저장소 간의 의존성을 줄이는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Space-Based Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/space-based-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/space-based-architecture/</guid>
      <description>분산 컴퓨팅 시스템을 위한 소프트웨어 아키텍처 패턴으로, 복잡성을 증가시키지 않으면서 애플리케이션과 시스템의 확장성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Master-Slave Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/</guid>
      <description>하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다</description>
    </item>
    <item>
      <title>Model-View-Controller Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-controller-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-controller-pattern/</guid>
      <description>애플리케이션을 세 가지 주요 구성 요소로 분리하여 개발의 유연성과 유지보수성을 향상시킨다.</description>
    </item>
    <item>
      <title>Peer-to-Peer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/peer-to-peer/peer-to-peer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/peer-to-peer/peer-to-peer-pattern/</guid>
      <description>분산 네트워크 아키텍처의 한 형태로, 각 노드(피어)가 클라이언트와 서버의 역할을 동시에 수행하는 구조</description>
    </item>
    <item>
      <title>Pipe-Filter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/</guid>
      <description>데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/producer-consumer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/producer-consumer-pattern/</guid>
      <description>이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.</description>
    </item>
    <item>
      <title>Component-Based Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/component-based/component-based-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 11:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/component-based/component-based-architecture/</guid>
      <description>애플리케이션을 독립적이고 재사용 가능한 단위인 &amp;#39;컴포넌트&amp;#39;로 구성하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Event-Driven Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/event-driven/event-driven-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 11:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/event-driven/event-driven-architecture/</guid>
      <description>Event-Driven Architecture (EDA)는 현대 소프트웨어 아키텍처 패턴 중 하나로, 시스템 내에서 발생하는 이벤트를 중심으로 동작하는 설계 방식이다.</description>
    </item>
    <item>
      <title>Event Sourcing Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 11:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/</guid>
      <description>Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.</description>
    </item>
    <item>
      <title>CQRS 패턴 (Command Query Responsibility Segregation)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/</guid>
      <description>애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Domain-Driven Design</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/</guid>
      <description>복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론</description>
    </item>
    <item>
      <title>Hexagonal Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/</guid>
      <description>애플리케이션의 핵심 비즈니스 로직을 외부 요소로부터 분리하여 유연하고 유지보수가 용이한 시스템을 구축하는 것을 목표로 한다</description>
    </item>
    <item>
      <title>Blackboard Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/blackboard-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/blackboard-pattern/</guid>
      <description>Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴으로 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.</description>
    </item>
    <item>
      <title>Broker Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/</guid>
      <description>분산 시스템에서 컴포넌트들 간의 통신을 조정하고 중개하는 구조적 패턴</description>
    </item>
    <item>
      <title>Event-Bus Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/</guid>
      <description>소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴</description>
    </item>
    <item>
      <title>Client-Server Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/client-server/client-server-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/client-server/client-server-pattern/</guid>
      <description>서비스를 제공하는 서버와 서비스를 요청하는 클라이언트로 구성되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Layered Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/layered/layered-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/layered/layered-pattern/</guid>
      <description>애플리케이션의 구성 요소를 수평적 계층으로 조직화하여 각 계층이 특정 기능을 담당하도록 한다.</description>
    </item>
    <item>
      <title>Factory Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/factory-method-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/factory-method-pattern/</guid>
      <description>객체 생성을 위한 인터페이스를 정의하지만, 실제 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정하도록 하는 디자인 패턴</description>
    </item>
    <item>
      <title>Singleton Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/singleton-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/singleton-pattern/</guid>
      <description>클래스의 인스턴스가 프로그램 전체에서 오직 하나만 생성되도록 보장하는 소프트웨어 디자인 패턴.</description>
    </item>
    <item>
      <title>Creational Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/</guid>
      <description>&lt;h2 id=&#34;creational-design-patterns&#34;&gt;Creational Design Patterns&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Structural Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/</guid>
      <description>&lt;h2 id=&#34;structural-design-patterns&#34;&gt;Structural Design Patterns&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Flyweight Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/flyweight-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/flyweight-pattern/</guid>
      <description>플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.  간단히 말하면 캐시(Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성(extrinsic)과 변하지 않는 속성(intrinsic)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.</description>
    </item>
    <item>
      <title>Composite Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/composite-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/composite-pattern/</guid>
      <description>Composite Pattern은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴이다.</description>
    </item>
    <item>
      <title>Bridge Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/bridge-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/bridge-pattern/</guid>
      <description>복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴</description>
    </item>
    <item>
      <title>Decorator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/decorator-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/decorator-pattern/</guid>
      <description>객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Facade Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/facade-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/facade-pattern/</guid>
      <description>복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Proxy Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/proxy-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/proxy-pattern/</guid>
      <description>객체에 대한 접근을 제어하기 위한 대리인(또는 대변인) 역할을 하는 객체를 제공하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Adapter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/adapter-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/adapter-pattern/</guid>
      <description>호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있도록 하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Abstract Factory Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/abstract-factory-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/abstract-factory-pattern/</guid>
      <description>구체적인 클래스를 지정하지 않고도 관련된 객체들의 집합을 생성할 수 있게 해주는 생성 패턴</description>
    </item>
    <item>
      <title>Builder Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/builder-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/builder-pattern/</guid>
      <description>복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 생성 패턴</description>
    </item>
    <item>
      <title>Prototype Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/prototype-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/prototype-pattern/</guid>
      <description>기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴</description>
    </item>
    <item>
      <title>Interpreter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/interpreter-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/interpreter-pattern/</guid>
      <description>Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.</description>
    </item>
    <item>
      <title>Visitor Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/visitor-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/visitor-pattern/</guid>
      <description>Visitor Pattern은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Behavioral Design Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/</guid>
      <description>행동 디자인 패턴(Behavioral Design Pattern)은 객체들 사이의 알고리즘과 책임 할당에 관한 패턴이다. 이 패턴들은 객체나 클래스 사이의 상호작용과 책임 분배 방법을 정의한다.</description>
    </item>
    <item>
      <title>Chain of Responsibility</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/chain-of-responsibility/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/chain-of-responsibility/</guid>
      <description>Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Mediator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/mediator-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/mediator-pattern/</guid>
      <description>Mediator Pattern(중재자 패턴)은 소프트웨어 디자인 패턴 중 하나로, 객체 간의 상호작용을 캡슐화하여 서로 직접 통신하지 않고 중재자 객체를 통해서만 소통하도록 설계된 행동 패턴이다.</description>
    </item>
    <item>
      <title>Memento Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/memento-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/memento-pattern/</guid>
      <description>Mediator 패턴은 객체 지향 소프트웨어 디자인 패턴 중 하나로, 객체들 간의 복잡한 상호작용을 캡슐화하여 객체 간 결합도를 낮추는 행위 패턴이다.</description>
    </item>
    <item>
      <title>Command Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/command-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/command-pattern/</guid>
      <description>요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>State Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/state-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/state-pattern/</guid>
      <description>객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Strategy Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/strategy-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/strategy-pattern/</guid>
      <description>알고리즘의 집합을 정의하고, 각각을 캡슐화하여 교환 가능하게 만드는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Template Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/template-method-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/template-method-pattern/</guid>
      <description>알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Observer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/observer-pattern/</guid>
      <description>객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴</description>
    </item>
    <item>
      <title>프로그램 설계 방법론</title>
      <link>https://buenhyden.github.io/til/2024/09/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95%EB%A1%A0/</link>
      <pubDate>Tue, 24 Sep 2024 05:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95%EB%A1%A0/</guid>
      <description>소프트웨어 개발 과정에서 시스템을 구조화하고 모듈화하는 체계적인 접근 방식</description>
    </item>
    <item>
      <title>Access Modifiers</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/access-modifiers/</link>
      <pubDate>Mon, 23 Sep 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/access-modifiers/</guid>
      <description>객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다.</description>
    </item>
    <item>
      <title>KISS Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/</link>
      <pubDate>Mon, 23 Sep 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/</guid>
      <description>시스템이나 코드의 복잡성을 최소화하라.</description>
    </item>
    <item>
      <title>YAGNI Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/</link>
      <pubDate>Mon, 23 Sep 2024 00:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/</guid>
      <description>당장 필요하지 않은 기능을 미리 구현하지 마라.</description>
    </item>
    <item>
      <title>DRY Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/</link>
      <pubDate>Mon, 23 Sep 2024 00:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/</guid>
      <description>코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/</guid>
      <description>객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.</description>
    </item>
    <item>
      <title>동시성 프로그래밍 (Concurrency Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/</link>
      <pubDate>Sun, 22 Sep 2024 23:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/</guid>
      <description>여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법</description>
    </item>
    <item>
      <title>Class and Instance</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/</link>
      <pubDate>Sun, 22 Sep 2024 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/</guid>
      <description>클래스란 객체를 생성하기 위한 템플릿 또는 청사진이고, 인스턴스는 클래스를 기반으로 생성된 실제 객체</description>
    </item>
    <item>
      <title>Class and Object and Instance</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-object-and-instance/</link>
      <pubDate>Sun, 22 Sep 2024 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-object-and-instance/</guid>
      <description>&lt;h2 id=&#34;class-and-object-and-instance&#34;&gt;Class and Object and Instance&lt;/h2&gt;
&lt;p&gt;객체 지향 프로그래밍(Object-Oriented Programming, OOP)에서 클래스(Class)와 객체(Object), 그리고 인스턴스(Instance)는 핵심적인 개념이다.&lt;/p&gt;
&lt;h3 id=&#34;클래스class&#34;&gt;클래스(Class)&lt;/h3&gt;
&lt;p&gt;클래스는 객체를 생성하기 위한 템플릿 또는 청사진이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정의: 객체를 정의해놓은 것 또는 객체의 설계도/틀&lt;/li&gt;
&lt;li&gt;용도: 객체를 생성하는데 사용됨&lt;/li&gt;
&lt;li&gt;구성: 연관된 데이터(속성)와 메서드(행동)의 집합&lt;/li&gt;
&lt;li&gt;특징:
&lt;ul&gt;
&lt;li&gt;메모리를 차지하지 않음&lt;/li&gt;
&lt;li&gt;한 번만 선언됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어, &amp;lsquo;자동차&amp;rsquo; 클래스는 모든 자동차의 공통적인 특성(브랜드, 모델, 색상 등)과 행동(시동 걸기, 가속하기 등)을 정의한다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Car&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 생성자: 객체가 생성될 때 초기화하는 메서드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;brand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;year&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;brand&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;brand&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# 브랜드 속성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;# 색상 속성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;year&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;year&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;# 연식 속성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine_on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 시동 상태&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 시동 걸기 메서드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start_engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine_on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;brand&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; 차량의 시동을 겁니다.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;객체object&#34;&gt;객체(Object)&lt;/h3&gt;
&lt;p&gt;객체는 클래스를 기반으로 생성된 실체.&lt;/p&gt;</description>
    </item>
    <item>
      <title>다형성 (Polymorphism)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/polymorphism/</link>
      <pubDate>Sun, 22 Sep 2024 10:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/polymorphism/</guid>
      <description>다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, &amp;#34;여러 가지 형태를 가질 수 있는 능력&amp;#34;을 의미한다</description>
    </item>
    <item>
      <title>상속 (Inheritance)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/inheritance/</link>
      <pubDate>Sun, 22 Sep 2024 10:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/inheritance/</guid>
      <description>상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘</description>
    </item>
    <item>
      <title>객체 지향 프로그래밍 (Object-Oriented Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/</guid>
      <description>현실 세계의 개체를 소프트웨어 객체로 모델링하는 프로그래밍 방식으로 데이터(속성)와 그 데이터를 처리하는 메서드(행동)를 하나의 단위인 객체로 묶는다.</description>
    </item>
    <item>
      <title>구조적 프로그래밍 (Structured Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/</guid>
      <description>구조적 프로그래밍은 1960년대에 등장한 프로그래밍 패러다임으로, 프로그램을 순차, 선택, 반복의 세 가지 기본 제어 구조로 구성하여 코드의 흐름을 체계적으로 관리하는 방식</description>
    </item>
    <item>
      <title>절차적 프로그래밍 (Procedural Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/procedural-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/procedural-programming/</guid>
      <description>프로그램의 실행 흐름을 일련의 절차나 함수로 구성하는 프로그래밍 패러다임</description>
    </item>
    <item>
      <title>제약 프로그래밍 (Constraint programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/constraint-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/constraint-programming/</guid>
      <description>문제를 변수와 이들 변수에 대한 제약 조건의 형태로 표현하는 프로그래밍 방식</description>
    </item>
    <item>
      <title>논리 프로그래밍 (Logic Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/</guid>
      <description>형식 논리에 기반한 프로그래밍 패러다임</description>
    </item>
    <item>
      <title>함수형 프로그래밍 (Functional Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/</guid>
      <description>프로그램을 순수 함수들의 조합으로 구성하는 방식</description>
    </item>
    <item>
      <title>추상화 (Abstraction)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/abstraction/</link>
      <pubDate>Sun, 22 Sep 2024 06:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/abstraction/</guid>
      <description>프로그래밍에서 핵심적인 개념으로, 복잡한 시스템이나 데이터를 단순화하여 필수적인 특징만을 강조하는 과정</description>
    </item>
    <item>
      <title>Abstract Classes</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/paradigm-features/abstract-classes/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/paradigm-features/abstract-classes/</guid>
      <description>추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다. 추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.</description>
    </item>
    <item>
      <title>Interfaces</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/paradigm-features/interfaces/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/paradigm-features/interfaces/</guid>
      <description>소프트웨어나 애플리케이션에서 인터페이스(Interface)는 두 개의 시스템, 프로그램, 장치 또는 구성 요소 간의 상호 작용을 가능하게 하는 연결점 또는 접점을 의미한다.</description>
    </item>
    <item>
      <title>오버라이딩(Overriding)과 오버로딩(Overloading)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/</guid>
      <description>오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 알아보고 비교 분석해보자.</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/encapsulation/</link>
      <pubDate>Sun, 22 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/encapsulation/</guid>
      <description>캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶고, 외부로부터 접근을 제한하는 것을 의미한다.</description>
    </item>
  </channel>
</rss>
