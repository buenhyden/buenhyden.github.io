<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>클린 코드 (Clean Code)</h2></header><div class=entry-content><p>클린 코드 (Clean Code) 프로그램의 동작을 보장하면서도 가독성이 뛰어나고 유지보수가 쉬운 코드를 의미한다.
코드의 품질을 향상시켜 개발 속도를 높이고, 버그를 줄이며, 팀 내 협업을 원활하게 한다.
Robert C. Martin(일명 Uncle Bob)이 2008년에 출간한 “Clean Code: A Handbook of Agile Software Craftsmanship” 책을 통해 널리 알려졌다.
Clean Code의 중요성 가독성과 유지보수성 향상: 깨끗한 코드는 다른 개발자들이 쉽게 이해하고 수정할 수 있게 한다. 팀 협업 개선: 일관된 코딩 표준을 따르면 팀원 간 의사소통과 협업이 더 원활해진다. 디버깅과 문제 해결 용이: 명확하고 단순한 구조는 이슈를 더 쉽게 찾고 해결할 수 있게 한다. 코드 품질과 신뢰성 향상: 잘 구조화된 코드는 오류 발생 위험을 줄이고 더 높은 품질의 소프트웨어로 이어진다. 클린 코드를 작성하기 위한 주요 원칙 의미 있는 이름 사용 변수, 함수, 클래스 등의 이름은 그 목적과 기능을 명확히 나타내야 한다.
일관된 명명 규칙을 적용하고, 약어 사용은 자제한다.
...</p></div><footer class=entry-footer><span title='2024-09-19 05:44:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1710 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 클린 코드 (Clean Code)" href=https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern Vs MVVC Pattern Vs MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 1 2 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;586 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/til/2024/09/27/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;738 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interface vs Abstract class</h2></header><div class=entry-content><p>Interface Vs Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.
모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.
이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.
추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.
일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 05:39:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interface vs Abstract class" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;626 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Database vs Shared Database Per Service</h2></header><div class=entry-content><p>Shared Database Vs Shared Database Per Service MSA(Microservices Architecture)에서 Shared Database와 Shared Database Per Service 패턴은 데이터 관리 전략의 일환으로 활용되며, 각각의 특징과 적용 시나리오가 뚜렷하게 구분된다.
두 패턴 모두 단일 데이터베이스 의존성으로 인한 리스크가 존재하므로, 장기적 관점에서는 Database Per Service로의 전환을 고려해야 한다. 특히 클라우드 환경(AWS RDS, Aurora)에서는 논리적 분리가 용이하나, 트랜잭션 격리와 확장성 측면에서 trade-off를 신중히 평가해야 한다.
Shared Database 패턴 정의 및 특징 여러 마이크로서비스가 단일 데이터베이스를 공유하며, 서비스 간 자유로운 테이블 접근 허용. 직접적인 ACID 트랜잭션을 통해 데이터 일관성 유지. 간단한 아키텍처로 시작 단계에서 빠른 개발 가능. 동작 방식 1 2 3 4 5 -- OrderService가 CustomerService의 테이블 직접 접근 예시 BEGIN TRANSACTION; SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID = 123; INSERT INTO ORDERS (CUSTOMER_ID, AMOUNT) VALUES (123, 50000); COMMIT; 서비스 간 스키마 변경 시 협업 필요 (예: Customer 테이블 컬럼 추가 → OrderService 코드 수정). 장단점 장점 단점 - 복잡한 분산 트랜잭션 불필요 - 서비스 간 강한 결합성 발생 - 데이터 조인 및 통합 쿼리 용이 - 단일 데이터베이스 병목 현상 (SPOF) - 기존 모놀리식 시스템 전환 용이 - 스키마 변경 시 전체 서비스 영향도 검토 필요 적합한 시나리오 소규모 팀에서 신속한 프로토타이핑 필요 시. 레거시 시스템을 MSA로 점진적 전환하는 과정에서 임시 활용. 강한 ACID 트랜잭션 요구사항이 있는 금융/결제 시스템. Shared Database Per Service 패턴 정의 및 특징 단일 물리적 데이터베이스 인스턴스를 공유하지만, 서비스별 논리적 분리 (스키마/테이블 격리). 핫 테이블(Hot Table) 방지를 통해 성능 저하 최소화. 하위 호환성 유지가 필수적이며, 스키마 변경 시 모든 서비스 영향도 검토. 동작 방식 1 2 3 -- Sales 서비스: sales_db.sales_table -- Customer 서비스: sales_db.customer_table (논리적 분리) GRANT SELECT, INSERT ON sales_db.customer_table TO 'customer_service'@'%'; IAM 정책 또는 DB 권한 제어를 통해 서비스별 접근 범위 제한. 장단점 장점 단점 - 물리적 인프라 비용 절감 - 여전히 런타임 결합성 존재 - 부분적 스키마 독립성 보장 - 장기적 유지보수 복잡성 증가 - 데이터 중복 최소화 - 확장성 제약 (CPU/IO 리소스 경쟁) 적합한 시나리오 제한된 리소스 환경에서 다중 서비스 운영 필요 시. 기존 데이터 레이어 재설계 없이 MSA 도입 시. 규제 준수 요구사항으로 단일 데이터베이스 유지해야 하는 경우. 비교 분석표 항목 공유 데이터베이스 (Shared Database) 서비스별 전용 데이터베이스 (Database per Service) 데이터 격리 수준 테이블 수준 공유 스키마/테이블 논리적 분리 데이터 일관성 유지 ACID 트랜잭션을 통해 데이터 일관성을 쉽게 유지할 수 있습니다. 분산된 데이터로 인해 데이터 일관성 유지가 복잡해질 수 있으며, 이를 위해 사가(Saga) 패턴 등의 사용이 필요할 수 있습니다. 스키마 변경 영향도 모든 서비스 영향 관련 서비스만 영향 결합도 높음 (직접 테이블 접근) 중간 (권한 제어를 통한 제한적 접근) 서비스 독립성 데이터베이스 스키마 변경 시 여러 서비스 간 조율이 필요하여 서비스 간 결합도가 높아집니다. 각 서비스가 독립적인 데이터베이스를 소유하므로 서비스 간 결합도가 낮아 독립적인 개발, 배포, 확장이 가능합니다. 데이터베이스 선택 모든 서비스가 동일한 데이터베이스를 사용하므로 개별 서비스의 특수한 데이터 저장 요구 사항을 충족하기 어렵습니다. 각 서비스는 자신의 요구에 맞는 데이터베이스 유형을 선택할 수 있어 폴리글랏 퍼시스턴스(Polyglot Persistence)를 구현할 수 있습니다. 운영 복잡성 단일 데이터베이스를 관리하므로 운영이 단순합니다. 여러 개의 데이터베이스를 관리해야 하므로 운영 복잡성이 증가합니다. 트랜잭션 관리 로컬 ACID 트랜잭션 가능.
단일 데이터베이스 내에서 트랜잭션을 관리하므로 구현이 용이합니다. 로컬 ACID 트랜잭션 가능.
분산 트랜잭션 관리가 필요할 수 있으며, 이는 구현의 복잡성을 증가시킵니다. 확장성 단일 데이터베이스의 확장에 한계가 있을 수 있으며, 특정 서비스의 확장이 다른 서비스에 영향을 미칠 수 있습니다. 각 서비스가 독립적으로 확장 가능하므로 시스템 전체의 확장성이 향상됩니다. 보안 모든 서비스가 전체 데이터 접근 가능 권한 제어로 접근 범위 제한 패턴 선택 가이드 Shared Database 선택 시: 개발 초기 단계에서 빠른 출시를 목표로 할 때. 팀 규모가 작고 데이터 복잡도가 낮은 경우. Shared Database Per Service 선택 시: 기존 모놀리식 DB를 유지하며 MSA를 도입해야 할 때. 데이터 중복을 최소화해야 하지만 완전 분리가 어려운 경우. Database Per Service 권장 시: 대규모 시스템에서 완전한 독립성과 확장성이 필요할 때. 서비스별 폴리글랏 퍼시스턴스 적용이 필요한 경우. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 08:02:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database vs Shared Database Per Service" href=https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-pattern-vs-software-design-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern vs Observer Pattern</h2></header><div class=entry-content><p>Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.
Mediator 패턴:
객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:
객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;453 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern vs Observer Pattern" href=https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>