<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dead Letter Queue</h2></header><div class=entry-content><p>Dead Letter Queue Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.
Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.
Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.
데드 레터 큐에 메시지가 전달되는 일반적인 상황 존재하지 않는 큐로의 메시지 전송: 메시지가 존재하지 않는 큐로 전송될 때. 큐의 최대 길이 초과: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때. 메시지 크기 제한 초과: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때. 메시지 만료: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때. 메시지 거부: 다른 큐나 교환기에 의해 메시지가 거부되었을 때. 과도한 재시도 실패: 메시지가 여러 번 처리되었지만 계속해서 실패할 때. DLQ의 주요 특징 분리 저장: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다. 재처리 가능성: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다. 시스템 안정성 향상: 문제가 있는 메시지로 인한 시스템 장애를 방지한다. 모니터링 및 알림: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다. DLQ 구현 방법 큐 생성: 일반 큐와 별도로 DLQ를 생성한다. 재시도 정책 설정: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다. DLQ 연결: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다. DLQ 활용 전략 분석 및 디버깅: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다. 자동 재처리: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다. 알림 설정: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다. 로깅 및 모니터링: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다. 주의사항 보존 기간 설정: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다. 보안: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다. 성능 영향: DLQ 처리로 인한 시스템 부하를 고려해야 한다. 데드 레터 큐를 지원하는 주요 메시징 시스템 Amazon SQS: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다. Apache Kafka: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다. RabbitMQ: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다. 구현 예시 Node.js와 RabbitMQ를 사용
...</p></div><footer class=entry-footer><span title='2024-10-02 12:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dead Letter Queue" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker 메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.
메시지 브로커는 **생산자(Producer)**와 소비자(Consumer) 간의 메시지를 중개하여 전달하는 소프트웨어이다. 이를 통해 서로 다른 애플리케이션이나 서비스가 직접 통신하지 않고도 데이터를 교환할 수 있다. 메시지 브로커는 주로 비동기 통신과 데이터 전달 신뢰성을 보장하기 위해 사용된다.
메시지 브로커의 주요 역할 메시지 전달: 생산자가 생성한 메시지를 소비자에게 전달한다. 메시지 큐잉(Message Queuing): 메시지를 임시로 저장하여 소비자가 준비되었을 때 처리할 수 있도록 한다. 비동기 통신 지원: 실시간 응답을 기다리지 않고 독립적으로 작업을 처리할 수 있도록 지원한다. 라우팅(Routing): 특정 조건에 따라 메시지를 적절한 소비자에게 전달한다. 신뢰성 보장: 메시지가 손실되지 않도록 저장 및 재전송 기능을 제공한다. 확장성(Scalability): 시스템이 더 많은 메시지를 처리할 수 있도록 확장성을 제공한다. 메시지 브로커의 동작 방식 생산자(Producer): 메시지를 생성하고 브로커에 전달한다. 브로커(Broker): 메시지를 임시 저장하고, 특정 규칙에 따라 적절한 소비자에게 전달한다. 소비자(Consumer): 브로커에서 전달받은 메시지를 처리한다. 큐(Queue): 메시지가 순서대로 저장되는 대기열이다. 토픽(Topic): 여러 소비자가 동일한 메시지를 구독할 수 있는 주제 기반 구조이다. 메시지 브로커의 장점 서비스 간 느슨한 결합: 서비스들이 직접 통신하지 않고 브로커를 통해 데이터를 주고받아 독립성을 유지할 수 있다. 비동기 처리: 생산자와 소비자가 동시에 작동하지 않아도 작업이 진행될 수 있다. 확장성: 필요에 따라 브로커를 확장하여 더 많은 메시지를 처리할 수 있다. 신뢰성: 메시지가 손실되지 않도록 보장하며, 실패 시 재전송 기능을 제공한다. 유연한 통신 패턴 지원: 1:1(Point-to-Point), 1:N(Pub/Sub) 등 다양한 통신 방식을 지원한다. 메시지 브로커의 단점 운영 복잡성 증가: 추가적인 소프트웨어 구성 요소를 설치하고 관리해야 한다. 단일 장애 지점(Single Point of Failure): 브로커가 고장 나면 전체 시스템이 영향을 받을 수 있으므로 고가용성 설계가 필요하다. 병목현상 가능성: 처리량이 높은 경우 브로커가 병목현상이 될 수 있다. 주요 메시지 브로커 도구 RabbitMQ:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;600 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Competing Consumers</h2></header><div class=entry-content><p>Competing Consumers Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.
Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.
작동 원리 메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다. 메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다. 경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다. 동작 방식 메시지 생산자(Producer): 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다. 메시지 큐(Message Queue): 게시된 메시지는 큐에 저장되어 대기한다. 메시지 소비자(Consumer): 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다. 이러한 구조를 통해 시스템은 작업 부하를 여러 소비자 인스턴스에 분산시켜 병목 현상을 방지하고, 동시 처리 능력을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;560 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Competing Consumers" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Filter</h2></header><div class=entry-content><p>Message Filter 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Filter" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Router</h2></header><div class=entry-content><p>Message Router 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Router" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3rd party registration</h2></header><div class=entry-content><p>3rd Party Registration 3rd Party Registration은 마이크로서비스 아키텍처에서 서비스 디스커버리를 위한 패턴 중 하나이다.
이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.
주요 특징:
서비스 인스턴스와 레지스트리 간의 결합도 감소 중앙 집중식 서비스 관리 다양한 언어와 프레임워크에 대한 일관된 등록 메커니즘 제공 3rd Party Registration 패턴은 마이크로서비스 아키텍처에서 서비스 디스커버리를 효과적으로 관리할 수 있는 방법이지만, 추가적인 복잡성을 감수해야 하므로, 시스템의 규모와 요구사항을 고려하여 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;263 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 3rd party registration" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Self registration</h2></header><div class=entry-content><p>Self Registration Self Registration은 각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다. 서비스가 시작될 때 자동으로 등록되고, 종료될 때 해제되는 방식으로 동작한다.
Self Registration 패턴은 마이크로서비스 환경에서 동적으로 변화하는 서비스 인스턴스를 효과적으로 관리할 수 있게 해주는 중요한 패턴이다. 하지만 구현의 복잡성과 유지보수 측면에서 주의가 필요하며, 프로젝트의 규모와 요구사항에 따라 적절히 선택해야 한다.
주요 특징 자동 등록: 서비스 인스턴스가 시작될 때 자신의 정보(호스트, IP 주소, 포트 등)를 레지스트리에 등록한다. 자동 해제: 서비스가 종료될 때 레지스트리에서 자신의 정보를 제거한다. 헬스체크: 주기적으로 레지스트리에 헬스체크 신호를 보내 자신이 살아있음을 알린다. 상태 관리: 서비스 인스턴스가 자신의 상태를 가장 잘 알기 때문에, UP/DOWN 외에도 STARTING, AVAILABLE 등 더 복잡한 상태 모델을 구현할 수 있다. 구현 방법 서비스 레지스트리 설정: Eureka, Consul, ZooKeeper 등의 도구를 사용하여 중앙 레지스트리를 구축한다. 서비스 등록 코드 구현: 각 마이크로서비스에 자신을 레지스트리에 등록하는 코드를 추가한다. 헬스체크 메커니즘 구현: 주기적으로 레지스트리에 헬스체크 신호를 보내는 로직을 구현한다. 서비스 디스커버리 클라이언트 구현: 다른 서비스들이 등록된 서비스를 찾고 통신할 수 있도록 한다. 장점 구현이 비교적 간단하다. 추가적인 시스템 컴포넌트가 필요하지 않다. 서비스가 자신의 상태를 가장 잘 알기 때문에 정확한 정보를 제공할 수 있다. 단점 서비스와 레지스트리 간의 결합도가 높아진다. 각 프로그래밍 언어와 프레임워크마다 등록 로직을 구현해야 한다. 서비스가 비정상적으로 종료될 경우 레지스트리에서 자동으로 제거되지 않을 수 있다. 구현 예시 Netflix Eureka는 셀프 등록 패턴의 대표적인 예시이다.
Eureka 클라이언트는 다음과 같은 방식으로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;499 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Self registration" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-side discovery</h2></header><div class=entry-content><p>Server-side Discovery Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.
Server-side Discovery는 클라이언트를 단순화하고 중앙 집중식 관리를 가능하게 하는 장점이 있지만, 추가 인프라와 관리가 필요한 단점도 있다. 프로젝트의 요구사항과 팀의 역량을 고려하여 적절히 선택해야 한다.
작동 원리 서비스 등록: 각 서비스 인스턴스는 시작 시 자신의 정보를 서비스 레지스트리에 등록한다. 클라이언트 요청: 클라이언트는 서비스의 실제 위치를 모르고, 로드 밸런서에 요청을 보낸다. 서비스 조회: 로드 밸런서는 서비스 레지스트리에서 해당 서비스의 가용한 인스턴스 정보를 조회한다. 요청 라우팅: 로드 밸런서는 적절한 서비스 인스턴스를 선택하여 요청을 전달한다. 응답 반환: 서비스의 응답은 로드 밸런서를 통해 클라이언트에게 전달된다. 장점 클라이언트 단순화: 클라이언트는 서비스 디스커버리 로직을 구현할 필요가 없어 단순해진다. 언어 중립성: 클라이언트 측 구현이 필요 없어 다양한 프로그래밍 언어로 개발된 서비스들을 쉽게 통합할 수 있다. 보안 강화: 로드 밸런서 수준에서 추가적인 보안 계층을 구현할 수 있다. 중앙 집중식 관리: 서비스 디스커버리와 로드 밸런싱을 중앙에서 관리할 수 있다. 단점 추가 인프라 필요: 로드 밸런서나 프록시 서버와 같은 추가 인프라가 필요하다. 단일 실패 지점: 로드 밸런서가 단일 실패 지점이 될 수 있어 고가용성 설계가 중요하다. 복잡성 증가: 전체 시스템의 복잡성이 증가할 수 있다. 구현 예시 AWS Elastic Load Balancer (ELB): 클라이언트는 ELB의 DNS 이름을 통해 요청을 보내며, ELB는 등록된 EC2 인스턴스나 ECS 컨테이너 사이에서 부하를 분산한다. Kubernetes의 kube-proxy: Kubernetes에서는 각 노드에서 실행되는 kube-proxy가 서비스 디스커버리와 로드 밸런싱을 담당하며, 클러스터 내의 서비스 요청을 적절한 파드(Pod)로 전달한다. Node.js를 사용한 Server-side Discovery 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 서버 사이드 디스커버리 라우터 구현 class ServiceRouter { constructor(options = {}) { this.registryUrl = options.registryUrl || 'http://service-registry:8500'; this.serviceCache = new Map(); this.cacheTimeout = options.cacheTimeout || 30000; // 30초 this.loadBalancer = new LoadBalancer(); } async handleRequest(req, res) { const serviceName = this.extractServiceName(req); try { // 서비스 인스턴스 찾기 const serviceInstance = await this.findServiceInstance(serviceName); // 요청 전달 const response = await this.forwardRequest(req, serviceInstance); // 응답 전달 this.sendResponse(res, response); } catch (error) { this.handleError(res, error); } } async findServiceInstance(serviceName) { // 캐시된 서비스 확인 const cachedInstances = this.getCachedInstances(serviceName); if (cachedInstances && cachedInstances.length > 0) { return this.loadBalancer.selectInstance(cachedInstances); } // 서비스 레지스트리 조회 const instances = await this.queryRegistry(serviceName); this.updateCache(serviceName, instances); return this.loadBalancer.selectInstance(instances); } async forwardRequest(req, serviceInstance) { const targetUrl = this.buildTargetUrl(serviceInstance, req.path); return await fetch(targetUrl, { method: req.method, headers: req.headers, body: req.body, timeout: 5000 }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-side discovery" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service registry</h2></header><div class=entry-content><p>Service Registry Service Registry는 마이크로서비스 환경에서 각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스이다.
이는 동적으로 변화하는 마이크로서비스 환경에서 서비스 디스커버리를 가능하게 하는 핵심 요소이다.
Service Registry는 MSA 환경에서 서비스 디스커버리를 가능하게 하는 핵심 컴포넌트이다. 이를 통해 동적이고 확장 가능한 마이크로서비스 아키텍처를 구현할 수 있다.
서비스 레지스트리의 중요성 MSA 환경에서는 서비스 인스턴스가 자동 확장, 장애 복구, 배포 등의 이유로 동적으로 생성되고 소멸되며, 이에 따라 네트워크 위치가 변경된다.
이러한 동적인 특성으로 인해, 서비스 레지스트리는 다음과 같은 역할을 수행한다:
...</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;530 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service registry" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Client-side discovery</h2></header><div class=entry-content><p>Client-side Discovery Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.
Client-side Discovery는 마이크로서비스 환경에서 유연하고 확장 가능한 서비스 디스커버리 방식을 제공한다. 그러나 클라이언트의 복잡도가 증가하는 단점이 있으므로, 프로젝트의 요구사항과 팀의 기술 스택을 고려하여 적절히 선택해야 한다.
주요 구성 요소 서비스 레지스트리(Service Registry): 각 서비스 인스턴스의 네트워크 위치(예: IP 주소, 포트)를 저장하고 관리하는 데이터베이스이다. 서비스 인스턴스는 시작 시 자신의 정보를 레지스트리에 등록하고, 종료 시 등록을 해제한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 11:46:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;551 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-side discovery" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-and-architecture/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>