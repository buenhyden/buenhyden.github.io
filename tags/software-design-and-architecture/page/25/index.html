<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Discovery Pattern</h2></header><div class=entry-content><p>Service Discovery Pattern 이 패턴은 동적으로 변화하는 분산 환경에서 서비스 인스턴스의 위치를 효과적으로 관리하고 찾는 방법을 제공한다.
Service Discovery Pattern은 클라이언트가 서비스의 정확한 위치(IP 주소와 포트)를 알지 못해도 서비스를 호출할 수 있게 해주는 메커니즘이다.
서비스 디스커버리는 각 서비스의 위치(호스트, 포트)를 관리하고 필요할 때 이 정보를 제공한다.
주요 목적은 다음과 같다:
서비스 위치의 동적 관리 로드 밸런싱 지원 서비스 헬스 체크 및 장애 대응 서비스 확장성 향상 핵심 구성 요소 서비스 레지스트리: 사용 가능한 서비스 인스턴스의 네트워크 위치를 저장하는 데이터베이스 서비스 등록: 서비스 인스턴스가 시작될 때 레지스트리에 자신을 등록하는 프로세스 서비스 검색: 클라이언트가 서비스를 호출하기 위해 레지스트리에서 서비스 위치를 조회하는 프로세스 구현 방법 Service Discovery는 주로 두 가지 방식으로 구현된다다:
...</p></div><footer class=entry-footer><span title='2024-11-19 10:06:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;410 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Discovery Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-discovery-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Mesh</h2></header><div class=entry-content><p>서비스 메시 (Service Mesh) 마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하기 위한 인프라 계층.
현대의 마이크로서비스 아키텍처에서는 수많은 서비스들이 서로 통신하면서 복잡한 네트워크를 형성한다.
이러한 환경에서 서비스 간 통신의 안정성, 보안, 관찰 가능성을 확보하는 것이 매우 중요한 과제가 되었고, 이러한 문제들을 해결하고 애플리케이션 코드 변경 없이 인프라 수준에서 통신을 제어하기 위해 서비스 메시가 등장하였다.
서비스 메시는 사이드카 프록시(Sidecar Proxy)를 사용하여 서비스 간 통신을 처리한다.
각 서비스 인스턴스 옆에 프록시가 배치되어, 마치 오토바이의 사이드카처럼 함께 동작한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 09:47:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;217 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Mesh" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-mesh/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding)과 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩(Overriding)과 오버로딩(Overloading) 기본 개념 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 정의 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것 같은 클래스 내에서 동일한 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것 목적 상속 관계에서 메서드의 구현을 변경하기 위해 사용 비슷한 기능을 하는 메서드를 하나의 이름으로 여러 가지 방식으로 사용하기 위해 사용 다형성 유형 런타임 다형성 (동적 바인딩) 컴파일 타임 다형성 (정적 바인딩) 핵심 특징 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 이름 반드시 동일해야 함 반드시 동일해야 함 매개변수 부모 메서드와 동일해야 함 타입이나 개수가 달라야 함 반환 타입 부모 메서드와 동일하거나 공변 반환 타입이어야 함 다를 수 있음 접근 제어자 부모 메서드보다 더 제한적일 수 없음 자유롭게 지정 가능 예외 처리 부모 메서드보다 더 큰 범위의 예외를 던질 수 없음 자유롭게 지정 가능 코드 예시 비교 오버라이딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 부모 클래스 class Animal { public void makeSound() { System.out.println("동물이 소리를 냅니다"); } } // 자식 클래스 class Dog extends Animal { @Override // 오버라이딩 명시 public void makeSound() { System.out.println("멍멍!"); } } class Cat extends Animal { @Override public void makeSound() { System.out.println("야옹!"); } } 오버로딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculator { // 정수 덧셈 public int add(int a, int b) { return a + b; } // 실수 덧셈 public double add(double a, double b) { return a + b; } // 세 정수의 덧셈 public int add(int a, int b, int c) { return a + b + c; } // 배열의 덧셈 public int add(int[] numbers) { int sum = 0; for (int num : numbers) { sum += num; } return sum; } } 실행 시점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 결정 시점 런타임에 결정 컴파일 타임에 결정 바인딩 동적 바인딩 정적 바인딩 성능 영향 약간의 오버헤드 발생 가능 오버헤드 없음 사용 목적 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 주요 용도 • 부모 클래스 메서드의 동작 변경
• 다형성 구현
• 특화된 기능 구현 • 메서드 이름의 재사용
• 다양한 매개변수 처리
• 코드의 간결성 향상 활용 상황 • 추상 메서드 구현
• 인터페이스 구현
• 상속받은 메서드 수정 • 생성자 다중 정의
• 유틸리티 메서드 구현
• API 설계 제약사항 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 제약 • final 메서드는 오버라이드 불가
• private 메서드는 오버라이드 불가
• static 메서드는 오버라이드 불가 • 매개변수만 다르면 됨
• 반환 타입만 다른 것은 불가
• 접근 제어자 제약 없음 상속 관계 반드시 상속 관계가 있어야 함 상속 관계 불필요 기타 제약 • 부모의 메서드보다 접근성을 좁힐 수 없음
• 부모보다 더 큰 예외 선언 불가 • 매개변수 순서만 다른 경우 주의 필요
• 모호한 호출 가능성 주의 장단점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 장점 • 다형성 구현 가능
• 코드 재사용성 향상
• 유연한 설계 가능 • 직관적인 메서드명 사용
• 코드 가독성 향상
• API 사용 편의성 증가 단점 • 런타임 오버헤드
• 복잡한 상속 관계시 추적 어려움
• 잘못 사용시 부모 클래스 동작 훼손 • 과도한 사용시 복잡도 증가
• 타입 변환 오류 가능성
• 모호한 메서드 호출 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 04:56:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;535 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding)과 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Command Pattern</h2></header><div class=entry-content><p>Command Pattern 요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴
요청을 하는 객체와 그 요청을 수행하는 객체를 분리합니다. 이를 통해 요청을 큐에 저장하거나, 로그를 남기거나, 작업을 취소하는 등의 부가적인 기능을 쉽게 추가할 수 있다.
특징 요청을 객체로 캡슐화하여 매개변수화합니다. 요청 발신자와 수신자를 분리합니다. 주요 구성요소
Command: 실행될 작업을 캡슐화하는 인터페이스 ConcreteCommand: Command 인터페이스를 구현하여 특정 작업을 수행하는 클래스 Invoker: Command 객체를 실행하는 클래스 Receiver: 실제 작업을 수행하는 클래스 Client: Command 객체를 생성하고 Invoker에게 전달하는 클래스 사용사례 GUI 버튼 및 메뉴 항목의 액션 구현 트랜잭션 시스템에서의 작업 큐 관리 매크로 기록 및 실행 기능 구현 장점 느슨한 결합: 명령을 실행하는 객체와 실제 작업을 수행하는 객체가 분리되어 있어, 시스템의 유연성이 향상됩니다. 확장성: 새로운 Command 클래스를 추가하는 것만으로 새로운 기능을 쉽게 추가할 수 있습니다. 작업 취소/재실행: Command 객체가 이전 상태를 저장할 수 있어, Undo/Redo 기능을 쉽게 구현할 수 있습니다. 작업 큐잉과 로깅: Command 객체를 저장하고 나중에 실행하거나, 실행 이력을 보관할 수 있습니다. 단점 클래스 증가: 각 명령마다 별도의 클래스가 필요하므로, 클래스의 수가 증가할 수 있습니다. 복잡성: 간단한 작업의 경우에도 Command 객체를 생성해야 하므로, 불필요한 복잡성이 추가될 수 있습니다. 메모리 사용: 작업 이력을 저장할 경우 메모리 사용량이 증가할 수 있습니다. 주의사항 및 고려사항 Command 인터페이스 설계: Command 인터페이스는 가능한 한 단순하게 유지하되, 필요한 모든 작업을 수행할 수 있어야 합니다. 일반적으로 execute()와 undo() 메서드를 포함합니다. 상태 관리: Undo/Redo 기능을 구현할 경우, Command 객체는 이전 상태를 적절히 저장하고 복원할 수 있어야 합니다. 복합 Command: 여러 Command를 그룹화하여 하나의 Command처럼 실행할 수 있는 MacroCommand를 구현할 수 있습니다. 예외 처리: Command 실행 중 발생할 수 있는 예외 상황을 적절히 처리해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 from abc import ABC, abstractmethod from typing import List import time # Receiver 클래스들 class Light: def __init__(self, location: str): self.location = location self.is_on = False self.brightness = 0 def turn_on(self) -> None: self.is_on = True print(f"{self.location} light is now on") def turn_off(self) -> None: self.is_on = False print(f"{self.location} light is now off") def dim(self, level: int) -> None: self.brightness = level print(f"{self.location} light dimmed to {level}%") class Thermostat: def __init__(self, location: str): self.location = location self.temperature = 20 def set_temperature(self, temperature: float) -> None: self.temperature = temperature print(f"{self.location} thermostat set to {temperature}°C") # Command 인터페이스 class Command(ABC): @abstractmethod def execute(self) -> None: pass @abstractmethod def undo(self) -> None: pass # Concrete Command 클래스들 class LightOnCommand(Command): def __init__(self, light: Light): self.light = light self._prev_state = None def execute(self) -> None: self._prev_state = self.light.is_on self.light.turn_on() def undo(self) -> None: if self._prev_state is False: self.light.turn_off() class LightDimCommand(Command): def __init__(self, light: Light, level: int): self.light = light self.level = level self._prev_level = None def execute(self) -> None: self._prev_level = self.light.brightness self.light.dim(self.level) def undo(self) -> None: if self._prev_level is not None: self.light.dim(self._prev_level) class SetThermostatCommand(Command): def __init__(self, thermostat: Thermostat, temperature: float): self.thermostat = thermostat self.temperature = temperature self._prev_temperature = None def execute(self) -> None: self._prev_temperature = self.thermostat.temperature self.thermostat.set_temperature(self.temperature) def undo(self) -> None: if self._prev_temperature is not None: self.thermostat.set_temperature(self._prev_temperature) # Invoker 클래스 class SmartHomeController: def __init__(self): self._command_history: List[Command] = [] self._current_command = None def execute_command(self, command: Command) -> None: self._current_command = command command.execute() self._command_history.append(command) def undo_last_command(self) -> None: if self._command_history: command = self._command_history.pop() command.undo() # 클라이언트 코드 def main(): # Receiver 객체들 생성 living_room_light = Light("Living Room") bedroom_light = Light("Bedroom") living_room_thermostat = Thermostat("Living Room") # Command 객체들 생성 light_on = LightOnCommand(living_room_light) bedroom_light_dim = LightDimCommand(bedroom_light, 50) set_temp = SetThermostatCommand(living_room_thermostat, 22.5) # Invoker 생성 및 커맨드 실행 controller = SmartHomeController() print("=== Executing commands ===") controller.execute_command(light_on) time.sleep(1) # 실행 간격을 위한 지연 controller.execute_command(bedroom_light_dim) time.sleep(1) controller.execute_command(set_temp) print("\n=== Undoing commands ===") time.sleep(1) controller.undo_last_command() # 온도 설정 취소 time.sleep(1) controller.undo_last_command() # 조명 밝기 조절 취소 time.sleep(1) controller.undo_last_command() # 조명 켜기 취소 if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // Receiver 클래스들 class Light { constructor(location) { this.location = location; this.isOn = false; this.brightness = 0; } turnOn() { this.isOn = true; console.log(`${this.location} light is now on`); } turnOff() { this.isOn = false; console.log(`${this.location} light is now off`); } dim(level) { this.brightness = level; console.log(`${this.location} light dimmed to ${level}%`); } } class Thermostat { constructor(location) { this.location = location; this.temperature = 20; } setTemperature(temperature) { this.temperature = temperature; console.log(`${this.location} thermostat set to ${temperature}°C`); } } // Command 인터페이스 class Command { execute() { throw new Error('execute method must be implemented'); } undo() { throw new Error('undo method must be implemented'); } } // Concrete Command 클래스들 class LightOnCommand extends Command { constructor(light) { super(); this.light = light; this._prevState = null; } execute() { this._prevState = this.light.isOn; this.light.turnOn(); } undo() { if (this._prevState === false) { this.light.turnOff(); } } } class LightDimCommand extends Command { constructor(light, level) { super(); this.light = light; this.level = level; this._prevLevel = null; } execute() { this._prevLevel = this.light.brightness; this.light.dim(this.level); } undo() { if (this._prevLevel !== null) { this.light.dim(this._prevLevel); } } } class SetThermostatCommand extends Command { constructor(thermostat, temperature) { super(); this.thermostat = thermostat; this.temperature = temperature; this._prevTemperature = null; } execute() { this._prevTemperature = this.thermostat.temperature; this.thermostat.setTemperature(this.temperature); } undo() { if (this._prevTemperature !== null) { this.thermostat.setTemperature(this._prevTemperature); } } } // Invoker 클래스 class SmartHomeController { constructor() { this._commandHistory = []; this._currentCommand = null; } executeCommand(command) { this._currentCommand = command; command.execute(); this._commandHistory.push(command); } undoLastCommand() { if (this._commandHistory.length > 0) { const command = this._commandHistory.pop(); command.undo(); } } } // 클라이언트 코드 async function main() { // Receiver 객체들 생성 const livingRoomLight = new Light("Living Room"); const bedroomLight = new Light("Bedroom"); const livingRoomThermostat = new Thermostat("Living Room"); // Command 객체들 생성 const lightOn = new LightOnCommand(livingRoomLight); const bedroomLightDim = new LightDimCommand(bedroomLight, 50); const setTemp = new SetThermostatCommand(livingRoomThermostat, 22.5); // Invoker 생성 및 커맨드 실행 const controller = new SmartHomeController(); console.log("=== Executing commands ==="); controller.executeCommand(lightOn); await new Promise(resolve => setTimeout(resolve, 1000)); // 실행 간격을 위한 지연 controller.executeCommand(bedroomLightDim); await new Promise(resolve => setTimeout(resolve, 1000)); controller.executeCommand(setTemp); console.log("\n=== Undoing commands ==="); await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 온도 설정 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 밝기 조절 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 켜기 취소 } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:17:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1265 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Command Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/command-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>State Pattern</h2></header><div class=entry-content><p>State Pattern 객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴
상태별 동작을 별도의 클래스로 분리하고, 현재 상태를 나타내는 객체에게 행동을 위임하는 것
특징 객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다. 상태 전이를 명시적으로 표현합니다. 각 상태를 별도의 클래스로 캡슐화합니다. 유한 상태 기계(Finite-State Machine)의 개념과 유사합니다. 사용사례 문서 처리 시스템: 문서가 초안, 검토 중, 승인됨, 게시됨 등의 상태를 가지며 각 상태에서 허용되는 작업이 다릅니다. 주문 처리 시스템: 주문이 생성됨, 결제 완료, 배송 중, 배송 완료 등의 상태를 거치며, 각 상태에서 가능한 작업이 달라집니다. 게임 캐릭터: 캐릭터가 서있음, 걷기, 달리기, 점프 등 다양한 상태를 가지며, 각 상태에서의 동작이 다릅니다. 네트워크 연결: 연결 중, 연결됨, 연결 끊김 등의 상태에 따라 다른 동작을 수행합니다. 장점 상태별 동작의 명확한 분리: 각 상태의 동작이 별도의 클래스로 캡슐화되어 코드의 구조가 명확해집니다. 상태 전환 로직의 체계화: 상태 전환이 명시적으로 이루어지며, 각 상태 클래스에서 가능한 전환을 정의할 수 있습니다. 새로운 상태 추가의 용이성: 기존 코드를 수정하지 않고도 새로운 상태를 추가할 수 있어 개방-폐쇄 원칙을 만족합니다. 단점 클래스 수의 증가: 각 상태마다 새로운 클래스가 필요하므로 클래스 수가 많아질 수 있습니다. 상태 전환 로직의 복잡성: 상태 간의 전환이 복잡할 경우 관리가 어려워질 수 있습니다. Context와 State 간의 결합: State 클래스들이 Context를 참조해야 하는 경우가 있어 결합도가 높아질 수 있습니다. 주의사항 및 고려사항 상태 전환의 일관성: 상태 전환이 일관되게 이루어지도록 주의해야 하며, 잘못된 전환을 방지해야 합니다. 메모리 관리: 상태 객체들을 적절히 재사용하거나 관리하지 않으면 메모리 사용량이 증가할 수 있습니다. 순환 참조 방지: Context와 State 간의 순환 참조가 발생하지 않도록 주의해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from abc import ABC, abstractmethod # State 인터페이스 class MediaPlayerState(ABC): @abstractmethod def play(self, player) -> None: pass @abstractmethod def pause(self, player) -> None: pass @abstractmethod def stop(self, player) -> None: pass @abstractmethod def get_state_name(self) -> str: pass # 구체적인 State 클래스들 class PlayingState(MediaPlayerState): def play(self, player) -> None: print("이미 재생 중입니다.") def pause(self, player) -> None: print("재생을 일시정지합니다.") player.change_state(PausedState()) def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "재생 중" class PausedState(MediaPlayerState): def play(self, player) -> None: print("재생을 재개합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("이미 일시정지 상태입니다.") def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "일시정지" class StoppedState(MediaPlayerState): def play(self, player) -> None: print("재생을 시작합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("중지 상태에서는 일시정지할 수 없습니다.") def stop(self, player) -> None: print("이미 중지 상태입니다.") def get_state_name(self) -> str: return "중지됨" # Context 클래스 class MediaPlayer: def __init__(self): # 초기 상태는 중지 상태 self._state = StoppedState() print(f"미디어 플레이어가 {self._state.get_state_name()} 상태로 시작됩니다.") def change_state(self, state: MediaPlayerState) -> None: self._state = state print(f"상태가 {self._state.get_state_name()}(으)로 변경되었습니다.") def play(self) -> None: self._state.play(self) def pause(self) -> None: self._state.pause(self) def stop(self) -> None: self._state.stop(self) # 사용 예시 def main(): player = MediaPlayer() # 재생 시작 player.play() # 중지 -> 재생 # 일시정지 player.pause() # 재생 -> 일시정지 # 재생 재개 player.play() # 일시정지 -> 재생 # 중지 player.stop() # 재생 -> 중지 # 일시정지 시도 (중지 상태에서는 불가능) player.pause() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // State 인터페이스 interface OrderState { processPayment(order: Order): void; shipOrder(order: Order): void; cancelOrder(order: Order): void; getStateName(): string; } // 구체적인 State 클래스들 class PendingState implements OrderState { processPayment(order: Order): void { console.log("결제를 진행합니다."); order.changeState(new PaidState()); } shipOrder(order: Order): void { console.log("결제가 필요합니다. 배송을 시작할 수 없습니다."); } cancelOrder(order: Order): void { console.log("주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 대기"; } } class PaidState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("배송을 시작합니다."); order.changeState(new ShippedState()); } cancelOrder(order: Order): void { console.log("결제가 환불되었습니다. 주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 완료"; } } class ShippedState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("이미 배송 중입니다."); } cancelOrder(order: Order): void { console.log("배송이 시작된 주문은 취소할 수 없습니다."); } getStateName(): string { return "배송 중"; } } class CancelledState implements OrderState { processPayment(order: Order): void { console.log("취소된 주문은 결제할 수 없습니다."); } shipOrder(order: Order): void { console.log("취소된 주문은 배송할 수 없습니다."); } cancelOrder(order: Order): void { console.log("이미 취소된 주문입니다."); } getStateName(): string { return "주문 취소"; } } // Context 클래스 class Order { private state: OrderState; private readonly orderId: string; constructor(orderId: string) { this.orderId = orderId; this.state = new PendingState(); console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 생성되었습니다.`); } public changeState(state: OrderState): void { this.state = state; console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 변경되었습니다.`); } public processPayment(): void { this.state.processPayment(this); } public shipOrder(): void { this.state.shipOrder(this); } public cancelOrder(): void { this.state.cancelOrder(this); } } // 사용 예시 function main() { const order = new Order("ORD-2024-001"); // 정상적인 주문 프로세스 console.log("\n=== 정상적인 주문 프로세스 ==="); order.processPayment(); // 결제 대기 -> 결제 완료 order.shipOrder(); // 결제 완료 -> 배송 중 // 취소된 주문 시나리오 console.log("\n=== 취소된 주문 시나리오 ==="); const cancelledOrder = new Order("ORD-2024-002"); cancelledOrder.cancelOrder(); // 결제 대기 -> 취소됨 cancelledOrder.processPayment(); // 결제 시도 (실패) cancelledOrder.shipOrder(); // 배송 시도 (실패) } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:17:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1040 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/state-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-and-architecture/page/24/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/26/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>