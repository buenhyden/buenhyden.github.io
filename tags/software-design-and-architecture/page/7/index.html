<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Externalized configuration</h2></header><div class=entry-content><p>Externalized Configuration Externalized Configuration 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.
이 패턴은 애플리케이션의 구성 정보를 외부 저장소에 보관하고, 런타임에 이를 읽어오는 방식으로 동작한다.
구성 정보는 데이터베이스, 파일 시스템, 환경 변수 등 다양한 외부 저장소에 보관될 수 있다.
이를 통해 각 환경(개발, 테스트, 운영 등)에 따라 다른 설정을 적용할 수 있으며, 설정 변경 시 애플리케이션을 재배포하지 않아도 된다.
Externalized Configuration 패턴은 마이크로서비스 아키텍처에서 구성 관리의 복잡성을 줄이고, 시스템의 유연성과 확장성을 높이는 데 크게 기여한다. 이 패턴을 효과적으로 사용하면 다양한 환경에서 애플리케이션을 쉽게 배포하고 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:10:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Externalized configuration" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/cloud-patterns/externalized-configuration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Microservice Chassis</h2></header><div class=entry-content><p>Microservice Chassis Microservice Chassis는 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 패턴이다.
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 프레임워크나 라이브러리 형태로 제공한다.
Microservice Chassis는 마이크로서비스 개발에 필요한 공통 기능을 제공하는 기본 프레임워크이다.
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.
주요 특징 공통 기능의 추상화: 인증 및 권한 부여, 로깅, 설정 관리, 헬스 체크, 메트릭 수집, 분산 추적 등 여러 서비스에 걸쳐 공통적으로 필요한 기능들을 섀시에서 제공하여 코드 중복을 최소화한다. 일관된 빌드 및 배포 프로세스: 빌드 로직과 배포 설정을 섀시에서 관리하여, 모든 서비스가 일관된 방식으로 빌드되고 배포될 수 있도록 지원한다. 확장성: 새로운 서비스 개발 시 섀시를 기반으로 빠르게 시작할 수 있으며, 공통 기능의 변경이 필요할 경우 섀시를 업데이트하여 모든 서비스에 적용할 수 있다. 주요 기능 Microservice Chassis는 다음과 같은 Cross-Cutting Concern을 처리한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:10:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Microservice Chassis" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/cross-cutting-concern/microservice-chassis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Template</h2></header><div class=entry-content><p>Service Template Service Template 패턴은 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 중요한 패턴이다.
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 템플릿 형태로 제공한다.
Service Template은 마이크로서비스 개발에 필요한 공통 기능과 구조를 제공하는 기본 템플릿이다.
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.
주요 특징 재사용 가능한 코드 기반: 서비스 템플릿은 빌드 로직, 공통 설정, 크로스커팅 관심사(예: 로깅, 보안, 설정 관리 등)를 포함한 실행 가능한 간단한 서비스를 제공한다. 이를 통해 새로운 서비스를 시작할 때 필요한 기본 구조를 빠르게 구축할 수 있다. 일관성 유지: 모든 서비스가 동일한 템플릿을 기반으로 생성되므로, 코드 구조와 설정이 일관되어 유지보수성과 가독성이 향상된다. 주요 기능 Service Template은 다음과 같은 Cross-Cutting Concern을 처리한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:09:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Template" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/cloud-patterns/service-template/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Database per Service Pattern</h2></header><div class=entry-content><p>Database per Service Pattern “Database per Service Pattern"은 마이크로서비스 아키텍처에서 중요한 디자인 패턴 중 하나이다.
Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.
이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.
주요 특징:
각 서비스는 자신만의 전용 데이터베이스를 가짐 서비스 간 데이터 접근은 API를 통해서만 가능 각 서비스는 자신의 요구사항에 가장 적합한 데이터베이스 기술을 선택할 수 있음 Database per Service Pattern은 마이크로서비스 아키텍처에서 서비스 간 독립성과 확장성을 높인다.
하지만 이를 효과적으로 구현하기 위해서는 신중한 설계와 다양한 기술적 도전을 해결해야 한다.
각 서비스의 특성과 전체 시스템의 요구사항을 고려하여 이 패턴의 적용 여부를 결정해야 하며, 필요에 따라 다른 패턴들과 조합하여 사용하는 것이 좋다.
...</p></div><footer class=entry-footer><span title='2024-11-12 10:05:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Database per Service Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/database/database-per-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Database</h2></header><div class=entry-content><p>Shared Database 마이크로서비스 아키텍처(MSA)에서 “Shared Database” 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.
Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.
Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 07:39:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/database/shared-database/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/security/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Publisher-Subscriber Pattern</h2></header><div class=entry-content><p>Publisher-Subscriber Pattern Publisher-Subscriber Pattern(게시자-구독자 패턴)은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 분산 시스템에서 비동기 통신을 구현하는 데 널리 사용된다.
이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.
이 패턴은 컴포넌트 간의 느슨한 결합을 제공하여 확장성과 유연성을 높이는 데 기여한다.
https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber
기본 개념 Publisher-Subscriber 패턴의 핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:40:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publisher-Subscriber Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/event-and-messaging-architectures/publisher-subscriber/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.
네트워크 불안정, 일시적인 서비스 중단 등 일시적인 실패 상황에서 시스템의 복원력(Resilience)을 강화하는 데 목적을 둔다.
이 패턴은 분산 시스템의 안정성을 높이는 필수 도구이지만, 남용할 경우 역효과를 낼 수 있으므로 신중한 정책 수립이 필요하다.
Retry Pattern의 핵심 개념 작동 원리
실패한 작업 자동 재시도: API 호출, 데이터베이스 접근 등 실패 가능성이 있는 작업을 정의된 정책에 따라 재시도한다. 일시적 오류 감지: 네트워크 타임아웃, HTTP 5xx 에러, 데이터베이스 연결 실패 등 일시적인 오류만 대상으로 한다. 주요 구성 요소
...</p></div><footer class=entry-footer><span title='2024-09-27 11:31:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/retry/retry-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/master-slave-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pipe-Filter Pattern</h2></header><div class=entry-content><p>Pipe-Filter Pattern 파이프-필터 패턴(Pipe-Filter Pattern)은 데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 복잡한 처리 과정을 독립적인 단계로 나누어 모듈화하고, 이들을 순차적으로 연결하여 데이터를 처리한다.
주요 구성 요소 필터(Filter):
단일 작업을 수행하는 처리 컴포넌트입니다 입력을 받아 처리하고 출력을 생성합니다 독립적으로 동작하며 다른 필터에 대해 알지 못합니다 재사용이 가능하고 조합할 수 있어야 합니다 파이프(Pipe):
필터 간의 데이터 전달을 담당합니다 데이터 버퍼링과 동기화를 처리합니다 필터들을 느슨하게 결합시킵니다 대개 큐나 스트림으로 구현됩니다 파이프라인(Pipeline):
...</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-Filter Pattern" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/event-and-messaging-architectures/pipes-and-filters/pipe-filter-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-and-architecture/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>