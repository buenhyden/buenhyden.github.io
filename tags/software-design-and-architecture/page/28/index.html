<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Singleton Pattern</h2></header><div class=entry-content><p>Singleton Pattern 클래스의 인스턴스가 프로그램 전체에서 오직 하나만 생성되도록 보장하는 소프트웨어 디자인 패턴.
공유 리소스나 전역 상태를 관리할 때 특히 유용하다.
특징 클래스는 자신의 유일한 인스턴스를 직접 관리합니다. 전역적인 접근점을 제공합니다. 인스턴스의 생성을 지연시킬 수 있습니다(lazy initialization). 생성자가 private이나 protected로 선언되어 외부에서 직접 인스턴스를 생성할 수 없습니다. 지연 초기화(lazy initialization) 객체의 생성이나 값의 계산 또는 비용이 많이 드는 프로세스를 필요한 시점까지 미루는 프로그래밍 기법
리소스를 많이 사용하는 객체나 초기화에 시간이 많이 걸리는 객체를 다룰 대 유용하다.
특정 프로그래밍 패
사용 사례:
...</p></div><footer class=entry-footer><span title='2024-10-11 18:21:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2292 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Singleton Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/singleton-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-10-11 12:38:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Abstract Factory Pattern</h2></header><div class=entry-content><p>Abstract Factory Pattern 구체적인 클래스를 지정하지 않고도 관련된 객체들의 집합을 생성할 수 있게 해주는 생성 패턴
특징 제품군의 생성을 캡슐화합니다 관련된 객체들이 함께 동작하도록 보장합니다 구체적인 클래스에 의존하지 않고 인터페이스에 의존합니다 제품군을 쉽게 교체할 수 있습니다 사용사례 여러 제품군 중 하나를 선택해 시스템을 설정해야 할 때 관련된 객체들이 함께 사용되어야 할 때 제품에 대한 클래스 라이브러리를 제공하고 구현이 아닌 인터페이스만 노출하고 싶을 때 실제 예:
크로스 플랫폼 UI 컴포넌트 생성 다양한 데이터베이스 시스템 지원 여러 운영체제에 대한 서비스 구현 다양한 게임 캐릭터와 아이템 생성 문서 포맷 변환 시스템 장점 제품군의 일관성 보장 구체적인 클래스와의 결합도 감소 제품군 교체가 용이 새로운 제품 추가가 용이 단점 코드가 복잡해질 수 있음 새로운 종류의 제품을 추가하기 어려움 불필요한 추상화로 인한 오버헤드 가능성 주의사항 및 고려사항 확장성 고려 새로운 제품군 추가를 고려한 설계 인터페이스 설계 시 신중한 고려 복잡성 관리 적절한 추상화 수준 유지 명확한 책임 분리 성능 최적화 객체 생성 비용 고려 캐싱 전략 검토 테스트 용이성 목 객체 생성 방법 고려 테스트 시나리오 설계 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 from abc import ABC, abstractmethod # 추상 제품 클래스들 class Button(ABC): @abstractmethod def render(self): pass @abstractmethod def handle_click(self): pass class Checkbox(ABC): @abstractmethod def render(self): pass @abstractmethod def toggle(self): pass # 구체적인 제품 클래스들 - Light Theme class LightButton(Button): def render(self): return "밝은 테마 버튼을 렌더링합니다" def handle_click(self): return "밝은 테마 버튼 클릭을 처리합니다" class LightCheckbox(Checkbox): def render(self): return "밝은 테마 체크박스를 렌더링합니다" def toggle(self): return "밝은 테마 체크박스 상태를 토글합니다" # 구체적인 제품 클래스들 - Dark Theme class DarkButton(Button): def render(self): return "어두운 테마 버튼을 렌더링합니다" def handle_click(self): return "어두운 테마 버튼 클릭을 처리합니다" class DarkCheckbox(Checkbox): def render(self): return "어두운 테마 체크박스를 렌더링합니다" def toggle(self): return "어두운 테마 체크박스 상태를 토글합니다" # 추상 팩토리 class UIFactory(ABC): @abstractmethod def create_button(self) -> Button: pass @abstractmethod def create_checkbox(self) -> Checkbox: pass # 구체적인 팩토리들 class LightThemeFactory(UIFactory): def create_button(self) -> Button: return LightButton() def create_checkbox(self) -> Checkbox: return LightCheckbox() class DarkThemeFactory(UIFactory): def create_button(self) -> Button: return DarkButton() def create_checkbox(self) -> Checkbox: return DarkCheckbox() # 클라이언트 코드 class Application: def __init__(self, factory: UIFactory): self.factory = factory self.button = None self.checkbox = None def create_ui(self): self.button = self.factory.create_button() self.checkbox = self.factory.create_checkbox() def paint(self): print(self.button.render()) print(self.checkbox.render()) # 사용 예시 if __name__ == "__main__": # 밝은 테마 사용 print("밝은 테마 적용:") app = Application(LightThemeFactory()) app.create_ui() app.paint() print("\n어두운 테마 적용:") # 어두운 테마로 전환 app = Application(DarkThemeFactory()) app.create_ui() app.paint() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // 추상 제품 클래스들 class Vehicle { constructor() { if (this.constructor === Vehicle) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getSpecifications() { throw new Error("추상 메서드는 구현해야 합니다."); } } class Engine { constructor() { if (this.constructor === Engine) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getDetails() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 제품 클래스들 - 스포츠카 class SportsCar extends Vehicle { getSpecifications() { return "스포츠카: 고성능, 2인승"; } } class SportsEngine extends Engine { getDetails() { return "스포츠카 엔진: V8, 500hp"; } } // 구체적인 제품 클래스들 - SUV class SUV extends Vehicle { getSpecifications() { return "SUV: 실용성, 7인승"; } } class SUVEngine extends Engine { getDetails() { return "SUV 엔진: V6, 280hp"; } } // 추상 팩토리 class VehicleFactory { createVehicle() { throw new Error("추상 메서드는 구현해야 합니다."); } createEngine() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 팩토리들 class SportsCarFactory extends VehicleFactory { createVehicle() { return new SportsCar(); } createEngine() { return new SportsEngine(); } } class SUVFactory extends VehicleFactory { createVehicle() { return new SUV(); } createEngine() { return new SUVEngine(); } } // 클라이언트 코드 class CarDealer { constructor(factory) { this.factory = factory; } orderCar() { const vehicle = this.factory.createVehicle(); const engine = this.factory.createEngine(); console.log("새로운 차량 주문:"); console.log(vehicle.getSpecifications()); console.log(engine.getDetails()); } } // 사용 예시 function main() { console.log("스포츠카 주문:"); const sportsCarDealer = new CarDealer(new SportsCarFactory()); sportsCarDealer.orderCar(); console.log("\nSUV 주문:"); const suvDealer = new CarDealer(new SUVFactory()); suvDealer.orderCar(); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-11 06:09:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;849 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract Factory Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/abstract-factory-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Prototype Pattern</h2></header><div class=entry-content><p>Prototype Pattern 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴
특징 객체 생성 비용이 높거나 복잡한 경우에 유용합니다. 원본 객체의 정확한 복사본을 제공합니다. 클라이언트가 객체의 타입을 미리 알 수 없는 경우에 사용됩니다. 사용사례 데이터베이스에서 가져온 큰 객체를 여러 번 사용해야 할 때 GUI 애플리케이션에서 복사-붙여넣기 기능을 구현할 때 게임에서 비슷한 특성을 가진 캐릭터나 아이템을 생성할 때 설정이나 구성 객체를 약간씩 다르게 여러 개 만들어야 할 때 장점 복잡한 객체를 처음부터 생성하는 비용을 절약할 수 있습니다 런타임에 동적으로 객체를 추가하거나 삭제할 수 있습니다 새로운 객체를 만들 때 상속 대신 복제를 사용하여 유연성을 높일 수 있습니다 단점 순환 참조가 있는 복잡한 객체의 경우 복제가 어려울 수 있습니다 깊은 복사(Deep Copy)를 구현할 때 모든 중첩된 객체들도 복제 가능해야 합니다 주의사항 및 고려사항 깊은 복사와 얕은 복사를 구분하여 사용해야 합니다. 객체가 다른 객체를 참조하는 경우, 깊은 복사를 사용하지 않으면 예상치 못한 부작용이 발생할 수 있습니다. 복제 과정에서 생성자가 호출되지 않음을 주의해야 합니다. 필요한 경우 초기화 로직을 별도의 메서드로 분리하여 복제 후 호출해야 합니다. 프로토타입 등록과 관리를 위한 레지스트리나 팩토리 클래스를 만들어 중앙에서 관리하는 것이 좋습니다. 복제된 객체의 식별자나 유니크한 속성들은 복제 후에 새로운 값으로 설정해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from copy import deepcopy from typing import Dict, Any class Character: def __init__(self, name: str, level: int, stats: Dict[str, int]): self.name = name self.level = level self.stats = stats def clone(self) -> 'Character': """Create a deep copy of the character""" return deepcopy(self) def __str__(self) -> str: return f"Character(name={self.name}, level={self.level}, stats={self.stats})" class CharacterPrototype: """Prototype manager class that stores and creates character templates""" def __init__(self): self._characters: Dict[str, Character] = {} def register_character(self, name: str, character: Character): """Register a character template""" self._characters[name] = character def unregister_character(self, name: str): """Remove a character template""" del self._characters[name] def clone(self, name: str, **kwargs: Any) -> Character: """Clone a character and optionally modify its attributes""" prototype = self._characters.get(name) if not prototype: raise ValueError(f"Character prototype '{name}' not found") character = prototype.clone() # Update any attributes specified in kwargs for key, value in kwargs.items(): if hasattr(character, key): setattr(character, key, value) return character # Usage example if __name__ == "__main__": # Create prototype manager prototype_manager = CharacterPrototype() # Register base warrior template warrior = Character( name="Warrior", level=1, stats={"strength": 15, "agility": 10, "intelligence": 5} ) prototype_manager.register_character("warrior", warrior) # Clone warriors with different names and levels warrior1 = prototype_manager.clone("warrior", name="Bob", level=5) warrior2 = prototype_manager.clone("warrior", name="Alice", level=7) print(warrior1) # Character(name=Bob, level=5, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) print(warrior2) # Character(name=Alice, level=7, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class DocumentTemplate { constructor(type, content, metadata) { this.type = type; this.content = content; this.metadata = metadata; } clone() { // Deep clone the object const clonedMetadata = JSON.parse(JSON.stringify(this.metadata)); return new DocumentTemplate(this.type, this.content, clonedMetadata); } customize(updates) { Object.assign(this, updates); return this; } } class DocumentPrototypeRegistry { constructor() { this.prototypes = new Map(); } registerTemplate(name, template) { this.prototypes.set(name, template); } unregisterTemplate(name) { this.prototypes.delete(name); } createDocument(templateName, customization = {}) { const template = this.prototypes.get(templateName); if (!template) { throw new Error(`Template '${templateName}' not found`); } return template.clone().customize(customization); } } // Usage example const registry = new DocumentPrototypeRegistry(); // Register some document templates const letterTemplate = new DocumentTemplate( 'letter', 'Dear {recipient},\n\n{body}\n\nBest regards,\n{sender}', { created: new Date(), version: '1.0', style: 'formal' } ); registry.registerTemplate('business_letter', letterTemplate); // Create customized documents from template const myLetter1 = registry.createDocument('business_letter', { content: 'Dear John,\n\nThank you for your inquiry.\n\nBest regards,\nJane' }); const myLetter2 = registry.createDocument('business_letter', { content: 'Dear Mary,\n\nPlease find attached our proposal.\n\nBest regards,\nBob', metadata: { version: '1.1', style: 'semiformal' } }); console.log(myLetter1); console.log(myLetter2); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-11 06:09:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;699 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prototype Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>구조적 프로그래밍 (Structured Programming)</h2></header><div class=entry-content><p>구조적 프로그래밍 (Structured Programming) 구조적 프로그래밍은 1960년대에 등장한 프로그래밍 패러다임으로, 프로그램을 순차, 선택, 반복의 세 가지 기본 제어 구조로 구성하여 코드의 흐름을 체계적으로 관리하는 방식.
이 접근 방식은 코드를 모듈화하고 위에서 아래로 실행되는 절차적인 흐름을 강조한다.
특징 순차적 실행: 코드가 위에서 아래로 순서대로 실행됩니다. 모듈화: 프로그램을 작은 기능 단위로 나누어 구성합니다. 제어 구조: 순차, 선택(if-else, switch), 반복(for, while) 구조를 사용합니다. 단일 진입점과 단일 종료점: 각 모듈은 하나의 시작점과 끝점을 가집니다. GOTO문 사용 제한: 무분별한 흐름 제어를 방지합니다 장점 코드 가독성 향상: 체계적인 구조로 인해 코드 이해가 쉬워집니다. 유지보수 용이성: 모듈화된 구조로 인해 수정과 디버깅이 쉬워집니다. 개발 시간 단축: 모듈 재사용으로 개발 효율성이 증가합니다. 문제 중심 접근: 기계 중심이 아닌 문제 해결에 초점을 맞춥니다. 단점 실행 효율성 감소: 모듈 호출로 인한 오버헤드가 발생할 수 있습니다. 메모리 사용량 증가: 모듈 인터페이스로 인해 메모리 사용이 증가할 수 있습니다. 기계어 변환 시간: 고급 언어에서 기계어로의 변환에 시간이 소요됩니다. 개발 시간 증가: 언어 의존적인 특성으로 인해 개발에 더 많은 시간이 필요할 수 있습니다. 주의사항 및 고려사항 적절한 모듈화: 과도한 모듈화는 성능 저하를 초래할 수 있으므로 균형을 유지해야 합니다. 데이터 구조 설계: 프로그램의 데이터 구조를 신중히 설계해야 합니다. 재사용성 고려: 모듈을 설계할 때 재사용 가능성을 고려해야 합니다. 문서화: 각 모듈의 기능과 인터페이스를 명확히 문서화해야 합니다. 예시 Python 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # Python으로 구현한 학생 성적 관리 시스템 def get_student_info(): """사용자로부터 학생 정보를 입력받는 함수""" name = input("학생 이름을 입력하세요: ") scores = [] for subject in ["수학", "영어", "과학"]: while True: try: score = int(input(f"{subject} 점수를 입력하세요 (0-100): ")) if 0 &lt;= score &lt;= 100: scores.append(score) break print("점수는 0에서 100 사이여야 합니다.") except ValueError: print("숫자를 입력해주세요.") return name, scores def calculate_average(scores): """점수 리스트의 평균을 계산하는 함수""" return sum(scores) / len(scores) def determine_grade(average): """평균 점수를 기반으로 등급을 결정하는 함수""" if average >= 90: return 'A' elif average >= 80: return 'B' elif average >= 70: return 'C' elif average >= 60: return 'D' else: return 'F' def generate_report(name, scores, average, grade): """성적 보고서를 생성하는 함수""" report = f"\n성적 보고서\n" report += f"학생 이름: {name}\n" subjects = ["수학", "영어", "과학"] for subject, score in zip(subjects, scores): report += f"{subject}: {score}점\n" report += f"평균: {average:f}점\n" report += f"등급: {grade}" return report def main(): """메인 프로그램 함수""" try: # 학생 정보 입력 받기 name, scores = get_student_info() # 평균 계산 average = calculate_average(scores) # 등급 결정 grade = determine_grade(average) # 보고서 생성 report = generate_report(name, scores, average, grade) # 결과 출력 print(report) except Exception as e: print(f"오류가 발생했습니다: {str(e)}") if __name__ == "__main__": main() Javascript 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Node.js로 구현한 학생 성적 관리 시스템 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); function promptQuestion(question) { return new Promise((resolve) => { rl.question(question, (answer) => { resolve(answer); }); }); } async function getStudentInfo() { const name = await promptQuestion("학생 이름을 입력하세요: "); const scores = []; const subjects = ["수학", "영어", "과학"]; for (const subject of subjects) { while (true) { const scoreStr = await promptQuestion(`${subject} 점수를 입력하세요 (0-100): `); const score = parseInt(scoreStr); if (!isNaN(score) && score >= 0 && score &lt;= 100) { scores.push(score); break; } console.log("올바른 점수를 입력해주세요 (0-100)"); } } return { name, scores }; } function calculateAverage(scores) { return scores.reduce((sum, score) => sum + score, 0) / scores.length; } function determineGrade(average) { if (average >= 90) return 'A'; if (average >= 80) return 'B'; if (average >= 70) return 'C'; if (average >= 60) return 'D'; return 'F'; } function generateReport(name, scores, average, grade) { const subjects = ["수학", "영어", "과학"]; let report = "\n성적 보고서\n"; report += `학생 이름: ${name}\n`; subjects.forEach((subject, index) => { report += `${subject}: ${scores[index]}점\n`; }); report += `평균: ${average.toFixed(2)}점\n`; report += `등급: ${grade}`; return report; } async function main() { try { // 학생 정보 입력 받기 const { name, scores } = await getStudentInfo(); // 평균 계산 const average = calculateAverage(scores); // 등급 결정 const grade = determineGrade(average); // 보고서 생성 const report = generateReport(name, scores, average, grade); // 결과 출력 console.log(report); } catch (error) { console.error("오류가 발생했습니다:", error.message); } finally { rl.close(); } } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-09 09:06:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;922 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 구조적 프로그래밍 (Structured Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-and-architecture/page/27/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/29/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>