<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-and-Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-and-Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-and-Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-and-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model–view–presenter Pattern</h2></header><div class=entry-content><p>Model–view–presenter Pattern Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, 관심사 분리 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.
MVC 패턴에서 파생되었으며, 주로 Windows Forms, ASP.NET, Java Swing 애플리케이션에서 활용된다.
이 패턴은 1990년대 Taligent사에서 처음 도입되었으며, 현재까지 엔터프라이즈급 애플리케이션에서 구조적 안정성을 제공하는 핵심 아키텍처로 자리잡았다. UI 복잡도가 높은 프로젝트에서 체계적인 관리를 원한다면 MVP 구현을 적극 고려해볼 만하다.
https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/
핵심 구성 요소 Model: 데이터 저장/관리 및 비즈니스 로직 처리 담당. 데이터베이스 연동, API 통신, 캐싱 기능 수행. UI와 독립적으로 동작하여 재사용성 향상. View: 사용자 인터페이스 표시 및 입력 이벤트 전달. 수동적(passive)으로 Presenter에 이벤트 전송. 데이터 표시 형식만 관리(예: 텍스트 박스 값 표시). Presenter: Model과 View의 중재자 역할. 사용자 입력 처리 → Model 업데이트 → 변경 사항 View 반영. 복잡한 UI 로직 캡슐화로 테스트 용이성 증대. 작동 메커니즘 사용자가 View와 상호작용하여 이벤트를 발생시킨다(예: 로그인). View → Presenter에 이벤트 전달 Presenter가 Model에서 데이터 검증/처리 처리 결과를 View에 반영(예: “로그인 성공” 메시지 표시) 주요 장점 유지보수성 향상:
...</p></div><footer class=entry-footer><span title='2024-09-27 09:10:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model–view–presenter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/modelviewpresenter-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/master-slave-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pipe-Filter Pattern</h2></header><div class=entry-content><p>Pipe-Filter Pattern 파이프-필터 패턴(Pipe-Filter Pattern)은 데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 복잡한 처리 과정을 독립적인 단계로 나누어 모듈화하고, 이들을 순차적으로 연결하여 데이터를 처리한다.
주요 구성 요소 필터(Filter):
단일 작업을 수행하는 처리 컴포넌트입니다 입력을 받아 처리하고 출력을 생성합니다 독립적으로 동작하며 다른 필터에 대해 알지 못합니다 재사용이 가능하고 조합할 수 있어야 합니다 파이프(Pipe):
필터 간의 데이터 전달을 담당합니다 데이터 버퍼링과 동기화를 처리합니다 필터들을 느슨하게 결합시킵니다 대개 큐나 스트림으로 구현됩니다 파이프라인(Pipeline):
...</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-Filter Pattern" href=https://buenhyden.github.io/posts/system-design/cloud-design-patterns/messaging/pipes-and-filters/pipe-filter-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Producer-Consumer Pattern</h2></header><div class=entry-content><p>Producer-Consumer Pattern Producer-Consumer Pattern은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 주로 동시성 프로그래밍과 분산 시스템에서 사용된다.
이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.
https://jenkov.com/tutorials/java-concurrency/producer-consumer.html
주요 구성 요소 프로듀서 (Producer): 데이터나 작업을 생성하는 엔티티. 컨슈머 (Consumer): 프로듀서가 생성한 데이터나 작업을 처리하는 엔티티. 버퍼 (Buffer): 프로듀서와 컨슈머 사이에서 데이터를 임시 저장하는 공유 자원. 주로 큐(Queue)의 형태로 구현된다. 작동 방식 프로듀서는 데이터나 작업을 생성하여 버퍼에 추가한다. 컨슈머는 버퍼에서 데이터나 작업을 가져와 처리한다. 버퍼는 프로듀서와 컨슈머 사이의 중간 저장소 역할을 하며, 동기화를 관리한다. 주요 특징 비동기 처리: 프로듀서와 컨슈머가 독립적으로 작동하여 비동기 처리가 가능하다. 버퍼링: 버퍼를 통해 생산과 소비 속도의 차이를 조절할 수 있다. 병렬 처리: 여러 프로듀서와 컨슈머가 동시에 작업할 수 있어 병렬 처리가 가능하다. 느슨한 결합: 프로듀서와 컨슈머는 서로에 대해 직접적인 의존성이 없다. 장점 처리량 향상: 생산과 소비를 병렬로 수행하여 전체 시스템의 처리량을 높일 수 있다. 유연성: 프로듀서와 컨슈머를 독립적으로 확장할 수 있다. 부하 분산: 버퍼를 통해 작업 부하를 균등하게 분산시킬 수 있다. 피크 부하 관리: 일시적인 부하 증가를 버퍼를 통해 완화할 수 있다. 단점 복잡성: 동기화와 버퍼 관리로 인해 시스템 복잡도가 증가할 수 있다. 메모리 사용: 버퍼가 큰 경우 메모리 사용량이 증가할 수 있다. 지연 가능성: 버퍼가 가득 차거나 비어있을 때 지연이 발생할 수 있다. 적용 사례 작업 큐 시스템: 백그라운드 작업 처리, 이메일 발송 등의 비동기 작업 관리 로그 처리 시스템: 대량의 로그 데이터를 효율적으로 수집하고 분석 스트리밍 데이터 처리: 실시간 데이터 스트림의 처리 및 분석 멀티스레드 애플리케이션: 스레드 간 작업 분배 및 동기화 구현 시 고려사항 동기화 메커니즘: 버퍼 접근 시 적절한 동기화 방법(예: 세마포어, 뮤텍스) 사용 버퍼 크기 조정: 시스템 요구사항에 맞는 적절한 버퍼 크기 설정 예외 처리: 버퍼 오버플로우, 언더플로우 등의 예외 상황 관리 종료 조건: 프로듀서와 컨슈머의 적절한 종료 시점 및 방법 정의 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:12:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Producer-Consumer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain-Driven Design</h2></header><div class=entry-content><p>Domain-Driven Design 복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론.
이 패턴은 Eric Evans가 2003년에 출간한 책 “Domain-Driven Design: Tackling Complexity in the Heart of Software"에서 처음 소개되었다.
DDD의 핵심 개념 유비쿼터스 언어 (Ubiquitous Language)
DDD에서는 개발자와 도메인 전문가 사이의 의사소통을 위해 공통의 언어를 사용하는 것을 강조한다.
이 언어는 코드, 문서, 대화 등 모든 곳에서 일관되게 사용되어야 한다.
이를 통해 도메인 지식을 정확히 소프트웨어에 반영할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-26 08:30:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-Driven Design" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/domain-driven-design/domain-driven-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Bus Pattern</h2></header><div class=entry-content><p>Event-Bus Pattern 소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴이다.
이 패턴은 발행-구독(Publish-Subscribe) 모델을 기반으로 하며, 컴포넌트 간의 느슨한 결합을 촉진한다.
장점 느슨한 결합: 컴포넌트 간 직접적인 의존성이 줄어들어 시스템의 유연성이 향상된다. 확장성: 새로운 컴포넌트를 쉽게 추가하거나 제거할 수 있어 시스템 확장이 용이한다. 비동기 통신: 이벤트 기반의 비동기 통신으로 시스템의 반응성과 성능이 향상된다. 단순화된 통신: 복잡한 컴포넌트 간 통신 로직을 단순화할 수 있다. 단점 복잡성 증가: 시스템 전체의 흐름을 파악하기 어려울 수 있다. 메모리 사용 증가: 모든 구독자에게 이벤트가 전달되므로 메모리 사용량이 증가할 수 있다. 디버깅의 어려움: 비동기적 특성으로 인해 문제 추적이 어려울 수 있다. 핵심 구성요소 https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5 Event Bus with multiple subscribers(green arrows) and notifiers(red arrows)
...</p></div><footer class=entry-footer><span title='2024-09-26 08:28:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Bus Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-bus-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Client-Server Pattern 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나눈다:
서비스를 제공하는 서버 서비스를 요청하는 클라이언트.
이들은 네트워크를 통해 서로 통신하며, 각자 명확한 역할과 책임을 가지고 있다. 클라이언트-서버 패턴 (Client-Server Pattern) 클라이언트-서버 패턴은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴이다.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나뉜다:
서비스를 제공하는 서버와 서비스를 요청하는 클라이언트이다.
주요 구성 요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
클라이언트 (Client):
...</p></div><footer class=entry-footer><span title='2024-09-26 08:27:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to " href=https://buenhyden.github.io/posts/software-design-and-architecture/client-server-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Factory Method Pattern</h2></header><div class=entry-content><p>Factory Method Pattern 객체 생성을 위한 인터페이스를 정의하지만, 실제 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정하도록 하는 디자인 패턴
객체 생성 로직을 캡슐화하여 코드의 유연성과 재사용성을 높이는데 도움을 준다.
특징 객체 생성을 서브클래스에 위임하여 결합도를 낮춘다. 부모 클래스에서 객체 생성을 위한 인터페이스를 제공하고, 서브클래스에서 구체적인 객체 생성을 담당한다. 클라이언트 코드와 구체적인 클래스 사이의 결합도를 낮춘다. 사용 사례 생성할 객체 타입을 예측할 수 없을 때 객체 생성의 책임을 서브클래스에 위임하고자 할 때 객체 생성 로직을 중앙화하여 코드 중복을 피하고자 할 때 실제 예:
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Factory Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/factory-method-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Singleton Pattern</h2></header><div class=entry-content><p>Singleton Pattern 클래스의 인스턴스가 프로그램 전체에서 오직 하나만 생성되도록 보장하는 소프트웨어 디자인 패턴.
공유 리소스나 전역 상태를 관리할 때 특히 유용하다.
특징 클래스는 자신의 유일한 인스턴스를 직접 관리합니다. 전역적인 접근점을 제공합니다. 인스턴스의 생성을 지연시킬 수 있습니다(lazy initialization). 생성자가 private이나 protected로 선언되어 외부에서 직접 인스턴스를 생성할 수 없습니다. 지연 초기화(lazy initialization) 객체의 생성이나 값의 계산 또는 비용이 많이 드는 프로세스를 필요한 시점까지 미루는 프로그래밍 기법
리소스를 많이 사용하는 객체나 초기화에 시간이 많이 걸리는 객체를 다룰 대 유용하다.
특정 프로그래밍 패
사용 사례:
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Singleton Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/singleton-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Flyweight Pattern</h2></header><div class=entry-content><p>Flyweight Pattern Flyweight 패턴은 구조적 디자인 패턴 중 하나로, 객체를 공유하여 메모리 사용을 최소화하는 패턴이다.
플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.
간단히 말하면 캐시(Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성(extrinsic)과 변하지 않는 속성(intrinsic)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.
Flyweight 패턴의 주요 구성 요소 Flyweight: 경량 객체를 묶는 인터페이스. ConcreteFlyweight: 공유 가능하여 재사용되는 객체로, intrinsic state를 포함한다. UnsahredConcreteFlyweight: 공유 불가능한 객체로, extrinsic state를 포함한다. FlyweightFactory: 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스. Client: FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다. Flyweight 패턴의 동작 방식 FlyweightFactory는 Flyweight 객체들을 생성하고 관리한다. GetFlyweight() 메서드는 팩토리 메서드 역할을 한다. 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다. Flyweight 패턴의 장점 많은 객체를 만들 때 성능을 향상시킬 수 있다. 많은 객체를 만들 때 메모리를 줄일 수 있다. 메모리 절약: 대규모 객체 시스템에서 상당한 메모리 절감 효과를 얻을 수 있다. 중복 최소화: 공유를 통해 객체의 중복 생성을 방지한다. Flyweight 패턴의 단점 특정 인스턴스를 다르게 처리하는 것이 힘들어진다. 코드 복잡성 증가: 객체를 공유하는 방식은 구현을 복잡하게 만들 수 있다. 런타임 비용: 객체 상태를 관리하는 데 런타임 비용이 발생할 수 있다. Flyweight 패턴의 사용 시기 대량의 작은 객체를 생성해야 할 때 유용하다. 객체의 상태를 자주 변하는 속성(Extrinsic)과 변하지 않는 속성(Intrinsic)으로 분리할 수 있을 때 적합하다. 공통된 내재 상태를 공유함으로써 메모리 사용을 줄일 수 있을 때 사용한다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Dict # Flyweight 클래스: 공유될 객체의 내부 상태를 정의 class CharacterStyle: def __init__(self, font_name: str, font_size: int, bold: bool): self.font_name = font_name self.font_size = font_size self.bold = bold def render(self, char: str, position: tuple) -> None: print(f"Rendering '{char}' at {position} with {self.font_name}, " f"size {self.font_size}, {'bold' if self.bold else 'normal'}") # Flyweight 팩토리: Flyweight 객체들을 관리하고 공유 class CharacterStyleFactory: def __init__(self): self._styles: Dict[str, CharacterStyle] = {} def get_style(self, font_name: str, font_size: int, bold: bool) -> CharacterStyle: # 스타일을 식별하기 위한 키 생성 key = f"{font_name}-{font_size}-{bold}" # 스타일이 존재하지 않으면 새로 생성 if key not in self._styles: self._styles[key] = CharacterStyle(font_name, font_size, bold) print(f"Creating new style: {key}") return self._styles[key] def get_style_count(self) -> int: return len(self._styles) # 문자 객체: Flyweight를 사용하는 클래스 class Character: def __init__(self, char: str, style: CharacterStyle, position: tuple): self.char = char # 외부 상태 (extrinsic state) self.style = style # 공유 상태 (intrinsic state) self.position = position # 외부 상태 def render(self) -> None: self.style.render(self.char, self.position) 실제 사용 예시
...</p></div><footer class=entry-footer><span title='2024-09-25 08:25:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flyweight Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/flyweight-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-and-architecture/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-and-architecture/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>