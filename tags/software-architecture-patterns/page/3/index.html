<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Architecture-Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Architecture-Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Architecture-Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Architecture-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Monolithic Pattern</h2></header><div class=entry-content><p>Monolithic Pattern 모놀리식 패턴(Monolithic Pattern)은 소프트웨어 아키텍처에서 가장 전통적이고 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 모든 구성 요소가 단일 코드베이스와 단일 실행 단위로 통합된 형태를 취한다.
주요 특징 단일 코드베이스: 모든 기능과 모듈이 하나의 코드베이스에 통합되어 있습니다. 단일 배포 단위: 전체 애플리케이션이 하나의 단위로 빌드되고 배포됩니다. 공유 데이터베이스: 일반적으로 하나의 중앙 집중식 데이터베이스를 사용합니다. 통합된 구성 요소: UI, 비즈니스 로직, 데이터 접근 계층 등이 모두 하나의 애플리케이션 내에 포함됩니다. 주요 구성 요소 ![Monolithic Architecture](1_HuM5OTnmQNUC2oIwiOn22A.webp “https://medium.com/design-microservices-architecture-with-patterns/monolithic-to-microservices-architecture-with-patterns-best-practices-a768272797b2_
...</p></div><footer class=entry-footer><span title='2024-09-25 11:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1254 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monolithic Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/monolithic-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Queues and Streams</h2></header><div class=entry-content><p>Message Queues and Streams 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 09:01:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queues and Streams" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/message-queues-and-streams/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CQRS 패턴 (Command Query Responsibility Segregation)</h2></header><div class=entry-content><p>CQRS 패턴 (Command Query Responsibility Segregation) 애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴
이 패턴은 데이터를 변경하는 작업과 데이터를 읽는 작업을 별도의 모델로 분리하여 처리한다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from dataclasses import dataclass from datetime import datetime from typing import List, Optional # 도메인 모델 @dataclass class Product: id: str name: str price: float stock: int created_at: datetime updated_at: datetime # Command 모델 (쓰기 작업) @dataclass class CreateProductCommand: name: str price: float stock: int @dataclass class UpdateProductStockCommand: product_id: str stock: int # Query 모델 (읽기 작업) @dataclass class ProductDetailsQuery: product_id: str @dataclass class ProductListQuery: page: int page_size: int # Command 핸들러 (쓰기 작업 처리) class ProductCommandHandler: def __init__(self, command_db): self.command_db = command_db def handle_create_product(self, command: CreateProductCommand) -> str: product = Product( id=generate_id(), name=command.name, price=command.price, stock=command.stock, created_at=datetime.now(), updated_at=datetime.now() ) self.command_db.save(product) # 이벤트 발행 (읽기 데이터베이스 동기화를 위함) publish_event("ProductCreated", product) return product.id def handle_update_stock(self, command: UpdateProductStockCommand): product = self.command_db.get_by_id(command.product_id) if not product: raise ValueError("Product not found") product.stock = command.stock product.updated_at = datetime.now() self.command_db.update(product) publish_event("ProductStockUpdated", product) # Query 핸들러 (읽기 작업 처리) class ProductQueryHandler: def __init__(self, query_db): self.query_db = query_db def handle_product_details(self, query: ProductDetailsQuery) -> Optional[Product]: return self.query_db.get_by_id(query.product_id) def handle_product_list(self, query: ProductListQuery) -> List[Product]: return self.query_db.get_page(query.page, query.page_size) # API 레이어 class ProductAPI: def __init__(self, command_handler: ProductCommandHandler, query_handler: ProductQueryHandler): self.command_handler = command_handler self.query_handler = query_handler def create_product(self, name: str, price: float, stock: int) -> str: command = CreateProductCommand(name=name, price=price, stock=stock) return self.command_handler.handle_create_product(command) def update_stock(self, product_id: str, stock: int): command = UpdateProductStockCommand(product_id=product_id, stock=stock) self.command_handler.handle_update_stock(command) def get_product(self, product_id: str) -> Optional[Product]: query = ProductDetailsQuery(product_id=product_id) return self.query_handler.handle_product_details(query) def list_products(self, page: int, page_size: int) -> List[Product]: query = ProductListQuery(page=page, page_size=page_size) return self.query_handler.handle_product_list(query) 주요 구성 요소 https://junuuu.tistory.com/891
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS 패턴 (Command Query Responsibility Segregation)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain-Driven Design</h2></header><div class=entry-content><p>Domain-Driven Design 복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론.
이 패턴은 Eric Evans가 2003년에 출간한 책 “Domain-Driven Design: Tackling Complexity in the Heart of Software"에서 처음 소개되었다.
DDD의 핵심 개념 유비쿼터스 언어 (Ubiquitous Language)
DDD에서는 개발자와 도메인 전문가 사이의 의사소통을 위해 공통의 언어를 사용하는 것을 강조한다.
이 언어는 코드, 문서, 대화 등 모든 곳에서 일관되게 사용되어야 한다.
이를 통해 도메인 지식을 정확히 소프트웨어에 반영할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;718 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-Driven Design" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Microkernel Architecture</h2></header><div class=entry-content><p>Microkernel Architecture 마이크로커널 패턴(Microkernel Pattern)은 소프트웨어 아키텍처 패턴 중 하나로, 시스템의 핵심 기능을 최소화하고 확장성과 유연성을 극대화하는 설계 방식.
이 패턴은 때로 ‘플러그인 아키텍처’라고도 불린다.
핵심 구성요소 https://www.alibabacloud.com/blog/what-is-microkernel-architecture-design_597605
마이크로커널(Core System):
시스템의 가장 기본적이고 필수적인 기능만을 포함합니다 확장 기능과 통신하기 위한 인터페이스를 제공합니다 플러그인의 생명주기를 관리합니다 이벤트나 메시지를 통해 플러그인과 통신합니다 플러그인 인터페이스:
플러그인이 구현해야 하는 표준 인터페이스를 정의합니다 커널과 플러그인 간의 계약을 명시합니다 일관된 확장 방식을 제공합니다 플러그인(Extensions):
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;898 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Microkernel Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hexagonal Architecture</h2></header><div class=entry-content><p>Hexagonal Architecture 헥사고날 아키텍처(Hexagonal Architecture)는 소프트웨어 설계 패턴 중 하나로, 애플리케이션의 핵심 비즈니스 로직을 외부 요소로부터 분리하여 유연하고 유지보수가 용이한 시스템을 구축하는 것을 목표로 한다.
이 아키텍처는 Alistair Cockburn에 의해 제안되었으며, ‘포트와 어댑터 아키텍처(Ports and Adapters Architecture)‘라고도 불린다.
핵심 원칙 의존성 방향:
모든 의존성은 도메인 계층을 향해 안쪽으로 흐른다.
도메인 계층은 외부를 전혀 알지 못하며, 포트를 통해서만 통신한다. 관심사의 분리:
각 계층은 명확한 책임을 가지며, 다른 계층의 구현 세부사항을 알지 못한다.
이는 시스템의 유지보수성과 테스트 용이성을 향상시킨다. 인터페이스 기반 설계:
포트는 인터페이스로 정의되어, 구체적인 구현체(어댑터)를 쉽게 교체할 수 있게 한다. 주요 구성 요소 ![](1682416486628.png “https://www.linkedin.com/pulse/whats-hexagonal-architecture-luis-soares-m-sc-/ _
...</p></div><footer class=entry-footer><span title='2024-09-25 08:29:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;827 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hexagonal Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blackboard Pattern</h2></header><div class=entry-content><p>Blackboard Pattern Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴.
이 패턴은 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.
기본 개념은 실제 교실의 칠판과 매우 유사하다.
여러 전문가들이 함께 모여 칠판에 정보를 공유하고, 문제를 해결해나가는 과정을 소프트웨어 아키텍처로 구현한 것.
Blackboard 패턴은 다음과 같은 상황에서 특히 유용하다:
명확한 해결 알고리즘이 없는 복잡한 문제 여러 전문 분야의 지식이 필요한 문제 다양한 해결 접근 방식을 시도해볼 필요가 있는 경우 Blackboard 패턴은 다음과 같은 분야에서 주로 사용된다:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blackboard Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Broker Pattern</h2></header><div class=entry-content><p>Broker Pattern 이 패턴은 클라이언트와 서버 간의 직접적인 상호작용을 줄이고, 브로커라는 중개자를 통해 통신을 관리한다.
이를 통해 시스템의 유연성 및 확장성을 높이고, 다양한 서비스가 서로 원활하게 협력할 수 있도록 한다.
다음과 같은 상황에서 사용된다:
분산 시스템: 여러 컴포넌트가 서로 다른 위치에 존재하며, 원격 서비스 호출을 통해 상호작용할 필요가 있는 경우. 서비스의 캡슐화: 클라이언트가 서비스의 구체적인 구현이나 위치를 알 필요 없이 요청할 수 있도록 하여, 시스템의 복잡성을 줄인다. 동적 구성: 런타임에 컴포넌트를 추가하거나 교체할 수 있어 시스템의 유연성을 제공한다. 장점 느슨한 결합(Loose Coupling): 클라이언트와 서버가 서로를 직접 알 필요가 없어 시스템의 유연성이 증가합니다. 확장성: 새로운 서버나 서비스를 쉽게 추가할 수 있습니다. 중앙화된 관리: 보안, 로깅, 로드 밸런싱 등을 중앙에서 처리할 수 있습니다. 시스템 독립성: 다른 플랫폼이나 언어로 작성된 컴포넌트들도 브로커를 통해 통신할 수 있습니다. 실제 활용 사례 메시지 큐 시스템: Apache Kafka, RabbitMQ 등 마이크로서비스 아키텍처의 API 게이트웨이 IoT 시스템의 메시지 브로커 클라우드 서비스의 로드 밸런서 주의할 점 브로커가 단일 실패 지점(Single Point of Failure)이 될 수 있습니다. 브로커를 통한 간접 통신으로 인해 약간의 성능 오버헤드가 발생할 수 있습니다. 시스템의 복잡성이 증가할 수 있습니다. 작동 방식 서버 등록: 서버는 자신의 기능과 서비스를 브로커에 등록합니다. 서비스 요청: 클라이언트는 브로커에 특정 서비스 요청을 보냅니다. 요청 전달: 브로커는 클라이언트의 요청을 적절한 서버로 전달합니다. 응답 반환: 서버는 요청을 처리한 후 결과를 브로커에 반환하고, 브로커는 이 결과를 다시 클라이언트에게 전달합니다. 주요 구성요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;408 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Broker Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Bus Pattern</h2></header><div class=entry-content><p>Event-Bus Pattern 소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴이다.
이 패턴은 발행-구독(Publish-Subscribe) 모델을 기반으로 하며, 컴포넌트 간의 느슨한 결합을 촉진한다.
장점 느슨한 결합: 컴포넌트 간 직접적인 의존성이 줄어들어 시스템의 유연성이 향상된다. 확장성: 새로운 컴포넌트를 쉽게 추가하거나 제거할 수 있어 시스템 확장이 용이한다. 비동기 통신: 이벤트 기반의 비동기 통신으로 시스템의 반응성과 성능이 향상된다. 단순화된 통신: 복잡한 컴포넌트 간 통신 로직을 단순화할 수 있다. 단점 복잡성 증가: 시스템 전체의 흐름을 파악하기 어려울 수 있다. 메모리 사용 증가: 모든 구독자에게 이벤트가 전달되므로 메모리 사용량이 증가할 수 있다. 디버깅의 어려움: 비동기적 특성으로 인해 문제 추적이 어려울 수 있다. 핵심 구성요소 https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5 Event Bus with multiple subscribers(green arrows) and notifiers(red arrows)
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Bus Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;742 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-architecture-patterns/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-architecture-patterns/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>