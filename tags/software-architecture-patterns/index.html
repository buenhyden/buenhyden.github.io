<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Architecture-Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Architecture-Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Architecture-Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Architecture-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern vs. MVVC Pattern vs. MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Pattern</h2></header><div class=entry-content><p>Event-Driven Pattern 이 패턴은 시스템의 상태 변화를 이벤트로 표현하고, 이를 기반으로 서비스 간 통신을 구현하는 방식이다.
Event-Driven Pattern은 시스템에서 발생하는 중요한 변화나 행동을 이벤트로 정의하고, 이를 중심으로 시스템을 설계하는 아키텍처 패턴이다.
이 패턴에서는 이벤트의 생성, 전파, 처리가 시스템의 핵심 동작이 된다.
주요 특징:
비동기 통신을 기반으로 함 서비스 간 느슨한 결합 제공 실시간 데이터 처리와 반응성 향상 확장성과 유연성 증대 주요 구성 요소 Event-Driven Pattern의 주요 구성 요소는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-12-28 10:05:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/event-driven/event-driven-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Anti-Corruption Layer</h2></header><div class=entry-content><p>Anti-Corruption Layer Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.
ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.
주요 목적은 다음과 같다:
시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다. 도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다. 데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다. ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 10:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Anti-Corruption Layer" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/refactoring-to-services/anti-corruption-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Strangler Application</h2></header><div class=entry-content><p>Strangler Application Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.
Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.
Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 01:20:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strangler Application" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/refactoring-to-services/strangler-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멀티 테넌시(Multi-tenancy)</h2></header><div class=entry-content><p>멀티 테넌시(Multi-tenancy) 멀티 테넌시(Multi-tenancy)는 소프트웨어 아키텍처의 한 형태로, 단일 소프트웨어 인스턴스가 여러 사용자 그룹(테넌트)에게 서비스를 제공하는 구조를 말한다. 즉, 하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.
각 테넌트는 공통 인프라를 공유하면서도 자신만의 독립된 환경을 가진 것처럼 작동한다.
주요 특징:
단일 인스턴스로 여러 사용자 그룹 서비스 데이터와 구성의 논리적 분리 각 테넌트에 대한 개별화된 사용자 경험 제공 https://www.linkedin.com/pulse/saas-architecture-right-way-sk-reddy-2ozuc/
멀티 테넌시의 유형 멀티 테넌시는 다양한 형태로 구현될 수 있다:
단일 인스턴스, 단일 데이터베이스: 모든 테넌트가 동일한 애플리케이션 인스턴스와 데이터베이스를 공유한다. 비용 효율적이지만 확장성에 제한이 있을 수 있다. 단일 인스턴스, 다중 데이터베이스: 애플리케이션 인스턴스는 공유하지만 각 테넌트가 별도의 데이터베이스를 가진다. 데이터 격리 수준이 높아진다. 다중 인스턴스, 다중 데이터베이스: 각 테넌트가 독립된 애플리케이션 인스턴스와 데이터베이스를 가진다. 가장 높은 수준의 격리를 제공하지만 비용이 증가한다. 멀티 테넌시의 장점 비용 효율성: 인프라와 리소스를 공유함으로써 개발, 유지보수, 운영 비용을 절감할 수 있다. 효율적인 리소스 관리: 여러 고객이 동일한 인프라를 공유하므로 리소스 활용도가 높아진다. 간편한 업데이트와 유지보수: 단일 인스턴스를 업데이트하면 모든 테넌트에게 동시에 적용되어 관리가 용이하다. 확장성: 사용자 수나 데이터 양이 증가할 때 쉽게 확장할 수 있다. 데이터 통합 용이성: 모든 테넌트의 데이터가 중앙 집중화되어 있어 분석과 인사이트 도출이 용이하다. 멀티 테넌시의 단점과 과제 보안과 데이터 격리: 여러 테넌트의 데이터가 공존하므로 데이터 유출 위험이 있다. 철저한 보안 조치가 필요하다. 복잡한 아키텍처: 개인화와 데이터 격리를 위해 복잡한 설계가 필요하다. 성능 관리: 한 테넌트의 과도한 리소스 사용이 다른 테넌트에게 영향을 줄 수 있다. 규정 준수: 다양한 테넌트의 데이터를 처리할 때 각종 법적 규정과 프라이버시 요구사항을 준수해야 한다. 커스터마이징의 한계: 각 테넌트별로 세부적인 커스터마이징에 제한이 있을 수 있다. 멀티 테넌시 구현 시 고려사항 데이터 모델 설계: 테넌트 간 데이터 격리를 위한 효과적인 데이터 모델 설계가 필요하다. 보안 메커니즘: 강력한 인증, 권한 부여, 암호화 등의 보안 메커니즘 구현이 중요하다. 확장성 계획: 테넌트 수와 데이터 양 증가에 대비한 확장 계획을 수립해야 한다. 성능 모니터링: 각 테넌트의 리소스 사용량을 모니터링하고 최적화하는 시스템이 필요하다. 백업 및 복구 전략: 테넌트별 데이터 백업 및 복구 전략을 수립해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 14:06:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멀티 테넌시(Multi-tenancy)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serverless Architecture</h2></header><div class=entry-content><p>Serverless Architecture Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.
Serverless Architecture는 빠른 개발 속도와 비용 효율성으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless Architecture" href=https://buenhyden.github.io/posts/devops/serverless/serverless-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/software-architecture-patterns/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>