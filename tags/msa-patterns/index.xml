<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MSA-Patterns on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/msa-patterns/</link>
    <description>Recent content in MSA-Patterns on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.142.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Nov 2024 11:46:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/msa-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data Pipeline Pattern</title>
      <link>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</guid>
      <description>데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.</description>
    </item>
    <item>
      <title>MSA 패턴 유형별 비교</title>
      <link>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Tue, 19 Nov 2024 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</guid>
      <description>MSA의 주요 패턴 유형들을 체계적으로 정리한 것.</description>
    </item>
    <item>
      <title>Shared Database vs Shared Database Per Service</title>
      <link>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 08:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</guid>
      <description>&lt;h2 id=&#34;shared-database-vs-shared-database-per-service&#34;&gt;Shared Database vs Shared Database Per Service&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Polling publisher</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</link>
      <pubDate>Tue, 19 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</guid>
      <description>&lt;h2 id=&#34;polling-publisher&#34;&gt;Polling Publisher&lt;/h2&gt;
&lt;p&gt;Polling publisher는 마이크로서비스 아키텍처(MSA)에서 트랜잭셔널 메시징을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 Transactional Outbox 패턴과 함께 사용되어 데이터 일관성을 유지하면서 메시지를 안정적으로 발행하는 데 도움을 준다.&lt;/p&gt;
&lt;p&gt;Polling publisher는 특히 소규모 시스템이나 간단한 구현이 필요한 경우에 적합한 방식이다. 그러나 대규모 시스템이나 실시간성이 중요한 경우에는 Transaction Log Tailing과 같은 다른 방식을 고려할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;기본-개념&#34;&gt;기본 개념&lt;/h3&gt;
&lt;p&gt;Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.&lt;br&gt;
데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transaction log tailing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</guid>
      <description>&lt;h2 id=&#34;transaction-log-tailing&#34;&gt;Transaction Log Tailing&lt;/h2&gt;
&lt;p&gt;Transaction log tailing은 마이크로서비스 아키텍처(MSA)에서 Transactional Messaging을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.&lt;/p&gt;
&lt;p&gt;Transaction log tailing은 Polling publisher 방식과 비교될 수 있다. Polling은 주기적으로 데이터베이스를 조회하는 반면, log tailing은 실시간으로 변경사항을 감지한다. 이로 인해 log tailing이 더 빠르고 효율적이지만, 구현이 더 복잡할 수 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 사용할 때는 메시지의 중복 발행 가능성을 고려해야 하며, 소비자 측에서 멱등성을 보장하는 방식으로 구현해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transactional Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/</guid>
      <description>&lt;h2 id=&#34;transactional-messaging&#34;&gt;Transactional Messaging&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Transactional Outbox</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</guid>
      <description>&lt;h2 id=&#34;transactional-outbox&#34;&gt;Transactional Outbox&lt;/h2&gt;
&lt;p&gt;Transactional Outbox 패턴은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성과 메시지 전달의 신뢰성을 보장하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 데이터베이스 업데이트와 메시지 발행을 원자적으로 처리하기 위한 방법으로, 데이터베이스 트랜잭션과 메시지 발행 사이의 일관성을 보장하는 것을 목적으로 한다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 분산 시스템에서 데이터 일관성과 메시지 전달의 신뢰성을 높이는 효과적인 방법이다. 이 패턴을 통해 개발자는 복잡한 분산 트랜잭션 문제를 해결하고, 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-방식&#34;&gt;작동 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 업데이트와 함께 발행할 메시지를 &amp;lsquo;outbox&amp;rsquo; 테이블에 저장한다.&lt;/li&gt;
&lt;li&gt;이 두 작업은 하나의 데이터베이스 트랜잭션으로 처리된다.&lt;/li&gt;
&lt;li&gt;별도의 프로세스(Message Relay)가 outbox 테이블에서 메시지를 읽어 실제 메시지 브로커로 전송한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Outbox 테이블: 발행할 메시지를 임시로 저장하는 데이터베이스 테이블&lt;/li&gt;
&lt;li&gt;Message Relay: outbox 테이블에서 메시지를 읽어 메시지 브로커로 전송하는 프로세스&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;p&gt;a. Polling Publisher:&lt;br&gt;
- 주기적으로 outbox 테이블을 폴링하여 미발행 메시지를 조회하고 발행한다.&lt;br&gt;
- 구현이 간단하지만 실시간성이 떨어질 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side UI composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</guid>
      <description>&lt;h2 id=&#34;client-side-ui-composition&#34;&gt;Client-side UI Composition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Client-side UI Composition&lt;/strong&gt;은 마이크로서비스 아키텍처(MSA)에서 클라이언트(주로 브라우저)가 여러 마이크로서비스로부터 데이터를 직접 가져와 사용자 인터페이스(UI)를 구성하는 패턴이다.&lt;br&gt;
이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;이 패턴에서는 클라이언트(브라우저)가 여러 마이크로서비스로부터 데이터를 요청하고, 해당 데이터를 기반으로 UI를 렌더링한다. 각 마이크로서비스는 자신만의 UI 컴포넌트(HTML, CSS, JavaScript 등)를 제공하며, 클라이언트는 이러한 컴포넌트를 조합해 전체 화면을 구성한다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전자상거래 웹사이트의 상품 상세 페이지를 생각해보면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Server-side page fragment composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</guid>
      <description>&lt;h2 id=&#34;server-side-page-fragment-composition&#34;&gt;Server-side Page Fragment Composition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Server-side page fragment composition&lt;/strong&gt;은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.&lt;/p&gt;
&lt;p&gt;Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>UI</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/</guid>
      <description>&lt;h2 id=&#34;ui&#34;&gt;UI&lt;/h2&gt;
&lt;h2 id=&#34;client-side-composition-vs-server-side-composition&#34;&gt;&lt;strong&gt;Client-side Composition Vs Server-side Composition&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특징&lt;/th&gt;
          &lt;th&gt;Client-side Composition&lt;/th&gt;
          &lt;th&gt;Server-side Composition&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;렌더링 위치&lt;/td&gt;
          &lt;td&gt;브라우저(클라이언트)&lt;/td&gt;
          &lt;td&gt;서버&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;초기 로딩 속도&lt;/td&gt;
          &lt;td&gt;느림&lt;/td&gt;
          &lt;td&gt;빠름&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SEO&lt;/td&gt;
          &lt;td&gt;불리함&lt;/td&gt;
          &lt;td&gt;유리함&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;서버 부하&lt;/td&gt;
          &lt;td&gt;낮음&lt;/td&gt;
          &lt;td&gt;높음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;실시간 업데이트&lt;/td&gt;
          &lt;td&gt;유리함&lt;/td&gt;
          &lt;td&gt;제한적&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;복잡성&lt;/td&gt;
          &lt;td&gt;프론트엔드 복잡성 증가&lt;/td&gt;
          &lt;td&gt;백엔드 복잡성 증가&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</guid>
      <description>&lt;h2 id=&#34;api-key-authentication&#34;&gt;API Key Authentication&lt;/h2&gt;
&lt;p&gt;API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</guid>
      <description>&lt;h2 id=&#34;cors&#34;&gt;CORS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.&lt;/p&gt;
&lt;h3 id=&#34;cors의-작동-원리&#34;&gt;CORS의 작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다.&lt;/li&gt;
&lt;li&gt;서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다.&lt;/li&gt;
&lt;li&gt;브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Origin의 정의&lt;br&gt;
Origin은 다음 세 가지 요소로 구성된다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mutual TLS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</guid>
      <description>&lt;h2 id=&#34;mutual-tls&#34;&gt;Mutual TLS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.&lt;/p&gt;
&lt;p&gt;Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;mTLS&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/how_mtls_works-what_is_mutual_tls.webp&#34;&gt;&lt;figcaption&gt;https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;일반-tls와의-차이점&#34;&gt;일반 TLS와의 차이점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다.&lt;/li&gt;
&lt;li&gt;mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mtls의-작동-원리&#34;&gt;mTLS의 작동 원리&lt;/h3&gt;
&lt;p&gt;mTLS는 다음과 같은 단계로 작동한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</guid>
      <description>&lt;h2 id=&#34;oauth2oidc-openid-connect&#34;&gt;OAuth2/OIDC (OpenID Connect)&lt;/h2&gt;
&lt;p&gt;MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;oauth-20&#34;&gt;OAuth 2.0&lt;/h3&gt;
&lt;p&gt;OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.&lt;br&gt;
주요 특징은 다음과 같다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</guid>
      <description>&lt;h2 id=&#34;rate-limiting&#34;&gt;Rate Limiting&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Secret Management</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</guid>
      <description>&lt;h2 id=&#34;secret-management&#34;&gt;Secret Management&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Access Token</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</guid>
      <description>&lt;h2 id=&#34;access-token&#34;&gt;Access Token&lt;/h2&gt;
&lt;p&gt;Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.&lt;br&gt;
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;access-token의-특징&#34;&gt;Access Token의 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다.&lt;/li&gt;
&lt;li&gt;Stateless: 서버에 상태를 저장하지 않아 확장성이 높다.&lt;/li&gt;
&lt;li&gt;암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다.&lt;/li&gt;
&lt;li&gt;포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-동작-방식&#34;&gt;Access Token의 동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다.&lt;/li&gt;
&lt;li&gt;토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지).&lt;/li&gt;
&lt;li&gt;요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다.&lt;/li&gt;
&lt;li&gt;서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-장점&#34;&gt;Access Token의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;확장성: Stateless 특성으로 서버 확장이 용이하다.&lt;/li&gt;
&lt;li&gt;보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다.&lt;/li&gt;
&lt;li&gt;효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-단점&#34;&gt;Access Token의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다.&lt;/li&gt;
&lt;li&gt;제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token과-refresh-token&#34;&gt;Access Token과 Refresh Token&lt;/h3&gt;
&lt;p&gt;보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Security</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/</guid>
      <description>&lt;h2 id=&#34;security&#34;&gt;Security&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Consumer-side contract test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</link>
      <pubDate>Mon, 18 Nov 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</guid>
      <description>&lt;h2 id=&#34;consumer-side-contract-test&#34;&gt;Consumer-side Contract Test&lt;/h2&gt;
&lt;p&gt;Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다.&lt;/li&gt;
&lt;li&gt;테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다.&lt;/li&gt;
&lt;li&gt;테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다.&lt;/li&gt;
&lt;li&gt;명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다.&lt;/li&gt;
&lt;li&gt;유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다.&lt;/li&gt;
&lt;li&gt;완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Consumer-Driven Contract Testing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</guid>
      <description>&lt;h2 id=&#34;consumer-driven-contract-testing&#34;&gt;Consumer-Driven Contract Testing&lt;/h2&gt;
&lt;p&gt;Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.&lt;br&gt;
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.&lt;/p&gt;
&lt;p&gt;CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.&lt;/p&gt;
&lt;p&gt;CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 중심: 소비자가 테스트의 주도권을 가진다.&lt;/li&gt;
&lt;li&gt;실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다.&lt;/li&gt;
&lt;li&gt;제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음.&lt;/li&gt;
&lt;li&gt;계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도구&#34;&gt;도구&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pact: CDC 테스팅을 위한 대표적인 도구.&lt;/li&gt;
&lt;li&gt;Testsigma: CDC 테스팅을 지원하는 또 다른 도구.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service Component Test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</guid>
      <description>&lt;h2 id=&#34;service-component-test&#34;&gt;Service Component Test&lt;/h2&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.&lt;br&gt;
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다.&lt;/li&gt;
&lt;li&gt;경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다.&lt;/li&gt;
&lt;li&gt;집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다.&lt;/li&gt;
&lt;li&gt;반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;테스트 환경 설정:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Testing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/</guid>
      <description>&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</guid>
      <description>&lt;h2 id=&#34;back-pressure&#34;&gt;Back Pressure&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Back Pressure&amp;quot;는 마이크로서비스 아키텍처(MSA)의 Reliability 패턴 중 하나로, 시스템의 안정성과 성능을 유지하기 위한 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.&lt;br&gt;
이는 과부하 상태에서 시스템이 완전히 실패하는 것을 방지하고, 가능한 한 많은 요청을 처리할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 MSA의 Reliability를 향상시키는 중요한 패턴이다.&lt;br&gt;
이를 효과적으로 구현하면 시스템의 안정성과 성능을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;back-pressure의-필요성&#34;&gt;Back Pressure의 필요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;시스템 안정성 유지: 과도한 요청으로 인한 시스템 다운을 방지한다.&lt;/li&gt;
&lt;li&gt;리소스 관리: 제한된 리소스를 효율적으로 사용할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;서비스 품질 유지: 일부 요청을 거부하더라도 전체적인 서비스 품질을 유지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;back-pressure-구현-방법&#34;&gt;Back Pressure 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;요청 큐잉&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bulkhead</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</guid>
      <description>Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</guid>
      <description>&lt;h2 id=&#34;cache-aside&#34;&gt;Cache-Aside&lt;/h2&gt;
&lt;p&gt;Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.&lt;br&gt;
이 패턴은 &amp;ldquo;Lazy Loading&amp;rdquo; 또는 &amp;ldquo;Look Aside&amp;rdquo; 패턴으로도 알려져 있다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Cache-aside&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/cache-aside-diagram.png&#34;&gt;&lt;figcaption&gt;https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;애플리케이션이 데이터를 요청한다.&lt;/li&gt;
&lt;li&gt;캐시를 먼저 확인한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서 가져온 데이터를 캐시에 저장한다.&lt;/li&gt;
&lt;li&gt;데이터를 애플리케이션에 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다.&lt;/li&gt;
&lt;li&gt;TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다.&lt;/li&gt;
&lt;li&gt;캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다.&lt;/li&gt;
&lt;li&gt;동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다.&lt;/li&gt;
&lt;li&gt;추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;동시성 처리와 오류 복구를 포함한 버전&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fail Fast</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</guid>
      <description>&lt;h2 id=&#34;fail-fast&#34;&gt;Fail Fast&lt;/h2&gt;
&lt;p&gt;Fail Fast는 MSA의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
잠재적인 문제를 조기에 발견하고 빠르게 대응함으로써 전체 시스템의 안정성과 신뢰성을 향상시킬 수 있다.&lt;/p&gt;
&lt;p&gt;Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙이다.&lt;br&gt;
이는 잠재적인 오류를 조기에 감지하고 빠르게 대응하여 시스템의 안정성을 높이는 데 목적이 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하기 위해서는 철저한 모니터링과 로깅, 적절한 알림 시스템, 그리고 자동화된 복구 메커니즘이 함께 구현되어야 한다. 또한 각 서비스의 특성에 맞는 임계값과 정책을 설정하고, 지속적으로 이를 개선해 나가는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reliability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/</guid>
      <description>&lt;h2 id=&#34;reliability&#34;&gt;Reliability&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</guid>
      <description>&lt;h2 id=&#34;anti-corruption-layer&#34;&gt;Anti-Corruption Layer&lt;/h2&gt;
&lt;p&gt;Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.&lt;br&gt;
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.&lt;/p&gt;
&lt;p&gt;ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.&lt;br&gt;
주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다.&lt;/li&gt;
&lt;li&gt;도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다.&lt;/li&gt;
&lt;li&gt;데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.&lt;br&gt;
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Refactoring to services</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/</guid>
      <description>&lt;h2 id=&#34;anti-corruption-layer&#34;&gt;Anti-Corruption Layer&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Circuit Breaker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</link>
      <pubDate>Sun, 17 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</guid>
      <description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Timeout Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</link>
      <pubDate>Sun, 17 Nov 2024 02:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</guid>
      <description>&lt;h2 id=&#34;timeout-pattern&#34;&gt;Timeout Pattern&lt;/h2&gt;
&lt;p&gt;Timeout Pattern은 마이크로서비스 간 통신에서 응답 지연이나 실패를 관리하기 위한 전략이다.&lt;br&gt;
이 패턴은 서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.&lt;/p&gt;
&lt;p&gt;Timeout Pattern은 MSA 환경에서 서비스 간 통신의 신뢰성을 높이고 시스템의 전반적인 안정성을 향상시키는 중요한 전략이다. 적절히 구현된 Timeout Pattern은 마이크로서비스 아키텍처의 장점을 극대화하고 잠재적인 문제를 최소화하는 데 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;타임아웃-패턴의-필요성&#34;&gt;타임아웃 패턴의 필요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 여러 서비스가 네트워크를 통해 상호 작용하므로, 다음과 같은 이유로 타임아웃 패턴이 필요하다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</link>
      <pubDate>Sun, 17 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</guid>
      <description>&lt;h2 id=&#34;retry-pattern&#34;&gt;Retry Pattern&lt;/h2&gt;
&lt;p&gt;Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.&lt;br&gt;
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.&lt;/p&gt;
&lt;p&gt;Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;retry-pattern의-주요-특징&#34;&gt;Retry Pattern의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;재시도 횟수&lt;/strong&gt;: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 간격&lt;/strong&gt;: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백오프 전략&lt;/strong&gt;: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건부 재시도&lt;/strong&gt;: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;retry-pattern-구현-방법&#34;&gt;Retry Pattern 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Retry 사용&lt;/strong&gt;: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resilience4j 사용&lt;/strong&gt;: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스텀 구현&lt;/strong&gt;: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;재시도-패턴-구현-시-고려사항&#34;&gt;재시도 패턴 구현 시 고려사항&lt;/h3&gt;
&lt;p&gt;재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Strangler Application</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</link>
      <pubDate>Sun, 17 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</guid>
      <description>&lt;h2 id=&#34;strangler-application&#34;&gt;Strangler Application&lt;/h2&gt;
&lt;p&gt;Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.&lt;br&gt;
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Application metrics</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</guid>
      <description>&lt;h2 id=&#34;application-metrics&#34;&gt;Application Metrics&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴에서 Observability는 매우 중요한 개념이며, 그 중 Application Metrics는 핵심적인 요소이다.&lt;br&gt;
Application Metrics는 애플리케이션의 성능과 동작을 이해하고 문제를 해결하는 데 필수적인 도구이다.&lt;/p&gt;
&lt;p&gt;Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.&lt;br&gt;
이는 개별 작업에 대한 통계를 수집하고, 이를 중앙 집중식 메트릭 서비스에 집계하여 보고 및 경고를 제공하는 패턴을 말한다.&lt;/p&gt;
&lt;p&gt;Application Metrics는 MSA 환경에서 Observability를 달성하는 데 핵심적인 역할을 한다.&lt;br&gt;
이를 통해 개발자와 운영팀은 복잡한 시스템을 더 잘 이해하고, 문제를 신속하게 해결하며, 시스템의 성능을 지속적으로 개선할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Log deployments and changes</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</guid>
      <description>&lt;h2 id=&#34;log-deployments-and-changes&#34;&gt;Log Deployments and Changes&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.&lt;/p&gt;
&lt;h3 id=&#34;패턴의-정의와-목적&#34;&gt;패턴의 정의와 목적&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.&lt;br&gt;
이 패턴의 주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템 변경사항과 문제 발생 간의 상관관계 파악&lt;/li&gt;
&lt;li&gt;문제 해결 시간 단축&lt;/li&gt;
&lt;li&gt;시스템 동작에 대한 이해도 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/</guid>
      <description>&lt;h2 id=&#34;observability&#34;&gt;Observability&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>API Composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</guid>
      <description>이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.</description>
    </item>
    <item>
      <title>Querying</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/</guid>
      <description>&lt;h2 id=&#34;querying&#34;&gt;Querying&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/cqrs/</guid>
      <description>&lt;h2 id=&#34;cqrs&#34;&gt;CQRS&lt;/h2&gt;
&lt;p&gt;CQRS(Command Query Responsibility Segregation)는 마이크로서비스 아키텍처(MSA)에서 중요한 패턴 중 하나이다.&lt;br&gt;
CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.&lt;/p&gt;
&lt;p&gt;CQRS는 다음과 같은 핵심 개념을 가지고 있다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;명령(Command)&lt;/strong&gt;: 시스템의 상태를 변경하는 작업 (예: 주문하기, 회원가입)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조회(Query)&lt;/strong&gt;: 시스템의 상태를 조회하는 작업 (예: 주문 목록 조회, 회원 정보 조회)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;책임 분리(Responsibility Segregation)&lt;/strong&gt;: 명령과 조회 작업을 별도의 모델로 분리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CQRS 패턴은 시스템의 성능, 확장성, 유지보수성을 향상시킬 수 있는 강력한 도구이다. 하지만 모든 시스템에 적합한 것은 아니므로, 프로젝트의 요구사항과 특성을 고려하여 적용 여부를 신중히 결정해야 한다.&lt;br&gt;
CQRS를 효과적으로 구현하기 위해서는 명령과 조회 모델의 분리, 데이터 동기화 전략, 그리고 전체 시스템 아키텍처에 대한 깊은 이해가 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Audit Logging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</link>
      <pubDate>Sat, 16 Nov 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</guid>
      <description>&lt;h2 id=&#34;audit-logging&#34;&gt;Audit Logging&lt;/h2&gt;
&lt;p&gt;Audit Logging은 시스템 내에서 발생하는 중요한 이벤트와 변경사항을 기록하는 프로세스이다.&lt;br&gt;
이는 사용자 활동, 시스템 변경, 데이터 접근 등을 포함하며, 시스템의 동작을 이해하고 문제를 해결하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Audit Logging은 MSA 환경에서 시스템의 투명성, 보안성, 그리고 문제 해결 능력을 크게 향상시킨다. 적절히 구현된 Audit Logging 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;
&lt;h3 id=&#34;기본-구성-요소&#34;&gt;기본 구성 요소&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Audit Log 엔티티 예시&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Entity&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AuditLog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Long&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 이벤트 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 식별자&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 ID&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 수행된 작업&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 전 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 후 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 발생 시간&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// IP 주소&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userAgent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 에이전트&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// getters, setters&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;audit-logging의-중요성&#34;&gt;Audit Logging의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;규정 준수&lt;/strong&gt;: PCI DSS, SOC 2 등의 산업 표준 및 규제 요구사항을 충족하는 데 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;: 비정상적인 활동을 감지하고 보안 위협을 조사하는 데 도움이 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 시스템 장애나 오류의 원인을 파악하는 데 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 행동 이해&lt;/strong&gt;: 고객 지원, 시스템 개선을 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-방법&#34;&gt;Audit Logging 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 로깅 서비스&lt;/strong&gt;: 모든 마이크로서비스의 로그를 한 곳에서 수집하고 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화된 로그 형식&lt;/strong&gt;: 일관된 형식을 사용하여 로그 분석을 용이하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 및 접근 제어&lt;/strong&gt;: 로그 데이터의 무결성과 기밀성을 보장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 대량의 로그 데이터를 효율적으로 처리할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-시-고려사항&#34;&gt;Audit Logging 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;과도한 로깅 vs 부족한 로깅&lt;/strong&gt;: 적절한 수준의 로깅을 유지해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: 로깅이 시스템 성능에 미치는 영향을 최소화해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 보존 정책&lt;/strong&gt;: 로그 데이터의 보존 기간과 방법을 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 모니터링&lt;/strong&gt;: 중요한 이벤트에 대한 실시간 알림 시스템을 구축해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-도구-및-기술&#34;&gt;Audit Logging 도구 및 기술&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Elasticsearch, Logstash, Kibana (ELK) 스택&lt;/strong&gt;: 로그 수집, 저장, 시각화에 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serilog&lt;/strong&gt;:.NET 환경에서 구조화된 로깅을 위한 프레임워크이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka&lt;/strong&gt;: 대규모 로그 스트림 처리에 적합한 메시징 시스템이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud-native 솔루션&lt;/strong&gt;: AWS CloudWatch, Google Cloud Logging 등이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging을-효과적으로-구현하기-위한-방법&#34;&gt;Audit Logging을 효과적으로 구현하기 위한 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비즈니스 로직 내에 로깅 코드 추가&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 구현이 비교적 간단하며, 특정 이벤트에 대한 상세한 로깅이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 비즈니스 로직과 로깅 코드가 혼재되어 코드의 가독성과 유지보수성이 저하될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOP(Aspect-Oriented Programming) 활용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 비즈니스 로직과 로깅 기능을 분리하여 코드의 모듈성을 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 메서드명이나 인수에만 접근할 수 있어, 비즈니스 컨텍스트에 따른 상세한 로깅에는 한계가 있을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 소싱(Event Sourcing) 사용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 시스템의 상태 변화를 이벤트 형태로 저장하여, 모든 변경 이력을 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 쿼리 작업은 이벤트로 기록되지 않으므로, 이러한 작업에 대한 로깅은 별도의 방법을 통해 구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상관 관계 ID 사용&lt;/strong&gt;: 마이크로서비스 간 요청 추적을 위해 고유 ID를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 정보 포함&lt;/strong&gt;: 사용자 ID, 서비스 이름, 요청 ID 등을 로그에 포함한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;민감한 정보 보호&lt;/strong&gt;: 개인정보나 보안 관련 데이터는 마스킹 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로그 레벨 구분&lt;/strong&gt;: 중요도에 따라 로그 레벨을 적절히 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Exception Tracking</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</link>
      <pubDate>Sat, 16 Nov 2024 02:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</guid>
      <description>&lt;h2 id=&#34;exception-tracking&#34;&gt;Exception Tracking&lt;/h2&gt;
&lt;p&gt;Exception Tracking은 분산 시스템 전반에 걸쳐 발생하는 예외를 중앙에서 수집, 집계, 분석하는 패턴이다.&lt;br&gt;
이 패턴은 복잡한 마이크로서비스 환경에서 오류를 효과적으로 모니터링하고 디버깅하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Exception Tracking은 MSA 환경에서 시스템의 안정성을 유지하고 문제를 신속하게 해결하는 데 필수적인 도구이다.&lt;br&gt;
이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고 사용자 경험을 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 예외 로거&lt;/strong&gt;: 여러 마이크로서비스에서 발생하는 예외 데이터를 수집하고 저장하는 전용 서비스나 도구이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예외 처리 미들웨어&lt;/strong&gt;: 각 마이크로서비스에 구현되어 예외를 캐치하고 중앙 로거로 전달하는 컴포넌트이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상관 관계 ID&lt;/strong&gt;: 여러 서비스에 걸친 요청 흐름과 관련 예외를 추적하는 데 사용되는 고유 식별자이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;알림 및 모니터링&lt;/strong&gt;: 중요한 문제에 대해 개발 및 운영 팀에 실시간으로 알리는 통합 모니터링 도구이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;대시보드&lt;/strong&gt;: 예외의 빈도, 심각도, 잠재적 영향 등에 대한 인사이트와 분석을 제공하는 사용자 인터페이스이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;exception-tracking의-중요성&#34;&gt;Exception Tracking의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 관리&lt;/strong&gt;: 수많은 서비스로 구성된 시스템에서 오류의 흐름을 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신속한 문제 해결&lt;/strong&gt;: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 이해 향상&lt;/strong&gt;: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 로깅 서비스 구축&lt;/strong&gt;: ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 사용하여 모든 마이크로서비스의 로그를 한 곳에서 수집하고 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;고유 요청 ID 생성&lt;/strong&gt;: 각 요청에 고유한 ID를 할당하여 여러 서비스에 걸친 예외 추적을 가능하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화된 예외 형식 사용&lt;/strong&gt;: 일관된 형식을 사용하여 예외 데이터를 수집하고 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 알림 설정&lt;/strong&gt;: 중요한 예외 발생 시 개발팀에 즉시 알림을 보내도록 구성한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Feign Error Decoder 활용&lt;/strong&gt;: Spring Cloud Openfeign을 사용하는 경우, Feign Error Decoder를 구현하여 마이크로서비스 간 통신 중 발생하는 예외를 효과적으로 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;예외 분류 및 우선순위 지정&lt;/strong&gt;: 예외의 심각도와 영향도에 따라 분류하고 우선순위를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 정보 포함&lt;/strong&gt;: 예외 로그에 사용자 정보, 요청 세부 사항 등 충분한 컨텍스트 정보를 포함시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정기적인 분석 및 개선&lt;/strong&gt;: 수집된 예외 데이터를 정기적으로 분석하여 시스템 안정성을 지속적으로 개선한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fail Fast 원칙 적용&lt;/strong&gt;: 문제를 조기에 감지하고 신속하게 대응할 수 있도록 Fail Fast 원칙을 적용한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Distributed Tracing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</guid>
      <description>&lt;h2 id=&#34;distributed-tracing&#34;&gt;Distributed Tracing&lt;/h2&gt;
&lt;p&gt;Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고유 식별자 할당&lt;/strong&gt;: 각 요청에 고유한 Trace ID를 부여한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스팬 생성&lt;/strong&gt;: 요청이 각 서비스를 통과할 때마다 &amp;lsquo;스팬&amp;rsquo;이라는 작업 단위가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;계층 구조&lt;/strong&gt;: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메타데이터 수집&lt;/strong&gt;: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;distributed-tracing의-중요성&#34;&gt;Distributed Tracing의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 관리&lt;/strong&gt;: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 이해&lt;/strong&gt;: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-사용-사례&#34;&gt;주요 사용 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 병목 식별&lt;/strong&gt;: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오류 추적&lt;/strong&gt;: 실패한 요청의 정확한 실패 지점과 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 의존성 분석&lt;/strong&gt;: 서비스 간 통신 패턴과 의존성을 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화&lt;/strong&gt;: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;계측&lt;/strong&gt;: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 수집&lt;/strong&gt;: 각 요청에 대한 스팬 데이터를 수집한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분석 및 시각화&lt;/strong&gt;: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-도구&#34;&gt;주요 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Jaeger&lt;/strong&gt;: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zipkin&lt;/strong&gt;: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Datadog APM&lt;/strong&gt;: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New Relic&lt;/strong&gt;: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;샘플링 전략 수립&lt;/strong&gt;: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 전파&lt;/strong&gt;: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화&lt;/strong&gt;: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시각화 도구 활용&lt;/strong&gt;: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Health Check API</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</guid>
      <description>&lt;h2 id=&#34;health-check-api&#34;&gt;Health Check API&lt;/h2&gt;
&lt;p&gt;Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.&lt;br&gt;
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.&lt;br&gt;
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.&lt;/p&gt;
&lt;h3 id=&#34;health-check-api의-중요성&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고가용성 보장&lt;/strong&gt;: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 조기 발견&lt;/strong&gt;: 서비스의 이상을 조기에 감지하여 대응할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api의-주요-기능&#34;&gt;Health Check API의 주요 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상태 확인:&lt;/strong&gt; 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;종속성 검사:&lt;/strong&gt; 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 모니터링:&lt;/strong&gt; 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api의-중요성-1&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장애 감지:&lt;/strong&gt; 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리 통합:&lt;/strong&gt; 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상:&lt;/strong&gt; 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api-구현-방법&#34;&gt;Health Check API 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;엔드포인트 생성&lt;/strong&gt;: 일반적으로 &lt;code&gt;/health&lt;/code&gt; 또는 &lt;code&gt;/ping&lt;/code&gt; 경로로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;응답 코드&lt;/strong&gt;: 정상 상태일 때 HTTP 200 OK를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 정보 포함&lt;/strong&gt;: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-유형&#34;&gt;Health Check 유형&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Passive Health Checks&lt;/strong&gt;: 실제 요청에 대한 응답을 모니터링한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active Health Checks&lt;/strong&gt;: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent-based Health Checks&lt;/strong&gt;: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-구현-도구&#34;&gt;Health Check API 구현 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot Actuator&lt;/strong&gt;: 자동으로 &lt;code&gt;/actuator/health&lt;/code&gt; 엔드포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes Probes&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Liveness Probe: 애플리케이션이 살아있는지 확인&lt;/li&gt;
&lt;li&gt;Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인&lt;/li&gt;
&lt;li&gt;Startup Probe: 애플리케이션의 시작이 완료되었는지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-모범-사례&#34;&gt;Health Check API 모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상세한 상태 정보&lt;/strong&gt;: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스터마이징&lt;/strong&gt;: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Log Aggregation</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</link>
      <pubDate>Sat, 16 Nov 2024 01:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</guid>
      <description>&lt;h2 id=&#34;log-aggregation&#34;&gt;Log Aggregation&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.&lt;br&gt;
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dead Letter Queue</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</guid>
      <description>&lt;h2 id=&#34;dead-letter-queue&#34;&gt;Dead Letter Queue&lt;/h2&gt;
&lt;p&gt;Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;데드-레터-큐에-메시지가-전달되는-일반적인-상황&#34;&gt;데드 레터 큐에 메시지가 전달되는 일반적인 상황&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;존재하지 않는 큐로의 메시지 전송&lt;/strong&gt;: 메시지가 존재하지 않는 큐로 전송될 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;큐의 최대 길이 초과&lt;/strong&gt;: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 크기 제한 초과&lt;/strong&gt;: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 만료&lt;/strong&gt;: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 거부&lt;/strong&gt;: 다른 큐나 교환기에 의해 메시지가 거부되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;과도한 재시도 실패&lt;/strong&gt;: 메시지가 여러 번 처리되었지만 계속해서 실패할 때.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq의-주요-특징&#34;&gt;DLQ의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분리 저장&lt;/strong&gt;: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재처리 가능성&lt;/strong&gt;: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 문제가 있는 메시지로 인한 시스템 장애를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모니터링 및 알림&lt;/strong&gt;: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-구현-방법&#34;&gt;DLQ 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;큐 생성&lt;/strong&gt;: 일반 큐와 별도로 DLQ를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 정책 설정&lt;/strong&gt;: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLQ 연결&lt;/strong&gt;: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-활용-전략&#34;&gt;DLQ 활용 전략&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분석 및 디버깅&lt;/strong&gt;: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 재처리&lt;/strong&gt;: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;알림 설정&lt;/strong&gt;: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;보존 기간 설정&lt;/strong&gt;: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: DLQ 처리로 인한 시스템 부하를 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;데드-레터-큐를-지원하는-주요-메시징-시스템&#34;&gt;데드 레터 큐를 지원하는 주요 메시징 시스템&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Amazon SQS&lt;/strong&gt;: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apache Kafka&lt;/strong&gt;: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;Node.js와 RabbitMQ를 사용&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Broker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</guid>
      <description>&lt;h2 id=&#34;message-broker&#34;&gt;Message Broker&lt;/h2&gt;
&lt;p&gt;메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.&lt;/p&gt;
&lt;p&gt;메시지 브로커는 **생산자(Producer)**와 &lt;strong&gt;소비자(Consumer)&lt;/strong&gt; 간의 메시지를 중개하여 전달하는 소프트웨어이다. 이를 통해 서로 다른 애플리케이션이나 서비스가 직접 통신하지 않고도 데이터를 교환할 수 있다. 메시지 브로커는 주로 &lt;strong&gt;비동기 통신&lt;/strong&gt;과 &lt;strong&gt;데이터 전달 신뢰성&lt;/strong&gt;을 보장하기 위해 사용된다.&lt;/p&gt;
&lt;h3 id=&#34;메시지-브로커의-주요-역할&#34;&gt;&lt;strong&gt;메시지 브로커의 주요 역할&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메시지 전달&lt;/strong&gt;: 생산자가 생성한 메시지를 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐잉(Message Queuing)&lt;/strong&gt;: 메시지를 임시로 저장하여 소비자가 준비되었을 때 처리할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비동기 통신 지원&lt;/strong&gt;: 실시간 응답을 기다리지 않고 독립적으로 작업을 처리할 수 있도록 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;라우팅(Routing)&lt;/strong&gt;: 특정 조건에 따라 메시지를 적절한 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신뢰성 보장&lt;/strong&gt;: 메시지가 손실되지 않도록 저장 및 재전송 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성(Scalability)&lt;/strong&gt;: 시스템이 더 많은 메시지를 처리할 수 있도록 확장성을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-동작-방식&#34;&gt;&lt;strong&gt;메시지 브로커의 동작 방식&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;생산자(Producer)&lt;/strong&gt;: 메시지를 생성하고 브로커에 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;브로커(Broker)&lt;/strong&gt;: 메시지를 임시 저장하고, 특정 규칙에 따라 적절한 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소비자(Consumer)&lt;/strong&gt;: 브로커에서 전달받은 메시지를 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;큐(Queue)&lt;/strong&gt;: 메시지가 순서대로 저장되는 대기열이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;토픽(Topic)&lt;/strong&gt;: 여러 소비자가 동일한 메시지를 구독할 수 있는 주제 기반 구조이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-장점&#34;&gt;메시지 브로커의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;서비스 간 느슨한 결합&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;서비스들이 직접 통신하지 않고 브로커를 통해 데이터를 주고받아 독립성을 유지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비동기 처리&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;생산자와 소비자가 동시에 작동하지 않아도 작업이 진행될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;필요에 따라 브로커를 확장하여 더 많은 메시지를 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;메시지가 손실되지 않도록 보장하며, 실패 시 재전송 기능을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연한 통신 패턴 지원&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;1:1(Point-to-Point), 1:N(Pub/Sub) 등 다양한 통신 방식을 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-단점&#34;&gt;메시지 브로커의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;운영 복잡성 증가&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;추가적인 소프트웨어 구성 요소를 설치하고 관리해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단일 장애 지점(Single Point of Failure)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;브로커가 고장 나면 전체 시스템이 영향을 받을 수 있으므로 고가용성 설계가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;병목현상 가능성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;처리량이 높은 경우 브로커가 병목현상이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-메시지-브로커-도구&#34;&gt;주요 메시지 브로커 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Competing Consumers</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</guid>
      <description>&lt;h2 id=&#34;competing-consumers&#34;&gt;Competing Consumers&lt;/h2&gt;
&lt;p&gt;Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.&lt;/p&gt;
&lt;p&gt;Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다.&lt;/li&gt;
&lt;li&gt;메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다.&lt;/li&gt;
&lt;li&gt;경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메시지 생산자(Producer)&lt;/strong&gt;: 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐(Message Queue)&lt;/strong&gt;: 게시된 메시지는 큐에 저장되어 대기한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 소비자(Consumer)&lt;/strong&gt;: 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 구조를 통해 시스템은 &lt;strong&gt;작업 부하를 여러 소비자 인스턴스에 분산&lt;/strong&gt;시켜 병목 현상을 방지하고, &lt;strong&gt;동시 처리 능력&lt;/strong&gt;을 향상시킨다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Filter</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</guid>
      <description>&lt;h2 id=&#34;message-filter&#34;&gt;Message Filter&lt;/h2&gt;
&lt;p&gt;Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.&lt;br&gt;
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;단일 입력 채널과 단일 출력 채널을 가진다.&lt;/li&gt;
&lt;li&gt;정의된 기준에 따라 메시지를 평가한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하는 메시지만 출력 채널로 전달한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하지 않는 메시지는 폐기된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;필터 조건 정의: 메시지를 평가할 기준을 설정한다.&lt;/li&gt;
&lt;li&gt;메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다.&lt;/li&gt;
&lt;li&gt;메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방식&#34;&gt;구현 방식&lt;/h3&gt;
&lt;p&gt;메시지 필터는 주로 다음과 같은 방식으로 구현된다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Router</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</guid>
      <description>&lt;h2 id=&#34;message-router&#34;&gt;Message Router&lt;/h2&gt;
&lt;p&gt;Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Message Router는 MSA 환경에서 메시지 흐름을 효과적으로 관리하고 시스템의 유연성을 높이는 중요한 패턴이다. 적절히 구현하면 시스템의 확장성과 유지보수성을 크게 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;message-router의-주요-특징&#34;&gt;Message Router의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메시지 내용 기반 라우팅: 메시지의 페이로드나 헤더를 분석하여 라우팅 결정을 내린다.&lt;/li&gt;
&lt;li&gt;동적 라우팅: 런타임에 라우팅 규칙을 변경할 수 있어 시스템의 유연성을 높인다.&lt;/li&gt;
&lt;li&gt;다중 목적지 지원: 하나의 메시지를 여러 목적지로 라우팅할 수 있다.&lt;/li&gt;
&lt;li&gt;메시지 변환: 필요에 따라 메시지 형식을 변환할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router의-종류&#34;&gt;Message Router의 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;콘텐츠 기반 라우터: 메시지 내용을 분석하여 라우팅한다.&lt;/li&gt;
&lt;li&gt;헤더 값 라우터: 메시지 헤더의 특정 값을 기준으로 라우팅한다.&lt;/li&gt;
&lt;li&gt;수신자 목록 라우터: 미리 정의된 수신자 목록에 따라 메시지를 분배한다.&lt;/li&gt;
&lt;li&gt;동적 라우터: 외부 조건이나 설정에 따라 라우팅 로직을 동적으로 변경한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router의-장점&#34;&gt;Message Router의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;유연성: 시스템 구성 요소 간의 결합도를 낮추어 유연성을 높인다.&lt;/li&gt;
&lt;li&gt;확장성: 새로운 처리 로직이나 목적지를 쉽게 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;트래픽 관리: 메시지 흐름을 제어하여 시스템 부하를 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;비즈니스 로직 분리: 라우팅 로직을 중앙화하여 비즈니스 로직과 분리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;복잡성 관리: 라우팅 규칙이 복잡해질수록 관리가 어려워질 수 있다.&lt;/li&gt;
&lt;li&gt;성능 고려: 복잡한 라우팅 로직은 시스템 성능에 영향을 줄 수 있다.&lt;/li&gt;
&lt;li&gt;오류 처리: 라우팅 실패 시의 오류 처리 전략이 필요하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router-구현-예시&#34;&gt;Message Router 구현 예시&lt;/h3&gt;
&lt;p&gt;Node.js를 사용한 Message Filter&lt;/p&gt;</description>
    </item>
    <item>
      <title>Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/</guid>
      <description>&lt;h2 id=&#34;messaging&#34;&gt;Messaging&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</guid>
      <description>&lt;h2 id=&#34;idempotent-consumer&#34;&gt;Idempotent Consumer&lt;/h2&gt;
&lt;p&gt;Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Domain event</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</link>
      <pubDate>Fri, 15 Nov 2024 11:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</guid>
      <description>&lt;h2 id=&#34;domain-event&#34;&gt;Domain Event&lt;/h2&gt;
&lt;p&gt;도메인 이벤트(Domain Event)는 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하고 시스템 간 의존성을 줄이며 확장성을 높이는 데 중요한 개념이다.&lt;br&gt;
도메인 이벤트는 주로 &lt;strong&gt;도메인 주도 설계(DDD)&lt;/strong&gt; 의 개념에서 비롯되었으며, 비즈니스 로직과 시스템 상태 변화의 핵심을 나타낸다.&lt;br&gt;
이를 통해 분산 시스템에서 데이터 일관성과 비즈니스 흐름을 효과적으로 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;도메인 이벤트는 &lt;strong&gt;도메인 내에서 발생한 중요한 상태 변화&lt;/strong&gt;를 나타내는 객체이다.&lt;br&gt;
이는 과거에 발생한 사건을 기술하며, 다른 모듈이나 시스템이 해당 이벤트를 구독하고 적절히 반응할 수 있도록 설계된다. 예를 들어, 전자상거래 시스템에서 &amp;ldquo;주문이 생성됨(Order Created)&amp;ldquo;이나 &amp;ldquo;결제가 완료됨(Payment Completed)&amp;rdquo; 같은 사건이 도메인 이벤트로 표현될 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Saga Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</link>
      <pubDate>Fri, 15 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</guid>
      <description>Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Aggregate Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</link>
      <pubDate>Fri, 15 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</guid>
      <description>Aggregate 패턴은 도메인 주도 설계(DDD)에서 유래한 개념으로, 관련된 객체들을 하나의 단위로 묶어 데이터 변경 시 일관성을 유지한다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/</guid>
      <description>&lt;h2 id=&#34;event-sourcing&#34;&gt;Event Sourcing&lt;/h2&gt;
&lt;p&gt;Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.&lt;br&gt;
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.&lt;/p&gt;
&lt;p&gt;Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;event-sourcing의-핵심-개념&#34;&gt;Event Sourcing의 핵심 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 중심 저장&lt;/strong&gt;: 시스템의 모든 상태 변경을 이벤트로 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;불변성&lt;/strong&gt;: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 순서&lt;/strong&gt;: 이벤트는 발생한 순서대로 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성&lt;/strong&gt;: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-장점&#34;&gt;Event Sourcing의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;완전한 감사 추적&lt;/strong&gt;: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 여행 가능&lt;/strong&gt;: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-구현-방법&#34;&gt;Event Sourcing의 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 정의&lt;/strong&gt;: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 저장소&lt;/strong&gt;: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 핸들러&lt;/strong&gt;: 각 이벤트 유형에 대한 처리 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성 로직&lt;/strong&gt;: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-주의사항&#34;&gt;Event Sourcing의 주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 버전 관리&lt;/strong&gt;: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최종 일관성&lt;/strong&gt;: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;이벤트-소싱의-구현-시-고려사항&#34;&gt;이벤트 소싱의 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;이벤트 저장소(Event Store)&lt;/strong&gt;: 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Maintaining Data Consistency</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/</link>
      <pubDate>Fri, 15 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/</guid>
      <description>&lt;h2 id=&#34;maintaining-data-consistency&#34;&gt;Maintaining Data Consistency&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/</link>
      <pubDate>Thu, 14 Nov 2024 18:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>3rd party registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</guid>
      <description>이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.</description>
    </item>
    <item>
      <title>Self registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</guid>
      <description>&lt;h2 id=&#34;self-registration&#34;&gt;Self Registration&lt;/h2&gt;
&lt;p&gt;Self Registration은 각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다. 서비스가 시작될 때 자동으로 등록되고, 종료될 때 해제되는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;Self Registration 패턴은 마이크로서비스 환경에서 동적으로 변화하는 서비스 인스턴스를 효과적으로 관리할 수 있게 해주는 중요한 패턴이다. 하지만 구현의 복잡성과 유지보수 측면에서 주의가 필요하며, 프로젝트의 규모와 요구사항에 따라 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;자동 등록&lt;/strong&gt;: 서비스 인스턴스가 시작될 때 자신의 정보(호스트, IP 주소, 포트 등)를 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 해제&lt;/strong&gt;: 서비스가 종료될 때 레지스트리에서 자신의 정보를 제거한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;헬스체크&lt;/strong&gt;: 주기적으로 레지스트리에 헬스체크 신호를 보내 자신이 살아있음을 알린다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 관리&lt;/strong&gt;: 서비스 인스턴스가 자신의 상태를 가장 잘 알기 때문에, UP/DOWN 외에도 STARTING, AVAILABLE 등 더 복잡한 상태 모델을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 레지스트리 설정: Eureka, Consul, ZooKeeper 등의 도구를 사용하여 중앙 레지스트리를 구축한다.&lt;/li&gt;
&lt;li&gt;서비스 등록 코드 구현: 각 마이크로서비스에 자신을 레지스트리에 등록하는 코드를 추가한다.&lt;/li&gt;
&lt;li&gt;헬스체크 메커니즘 구현: 주기적으로 레지스트리에 헬스체크 신호를 보내는 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리 클라이언트 구현: 다른 서비스들이 등록된 서비스를 찾고 통신할 수 있도록 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;구현이 비교적 간단하다.&lt;/li&gt;
&lt;li&gt;추가적인 시스템 컴포넌트가 필요하지 않다.&lt;/li&gt;
&lt;li&gt;서비스가 자신의 상태를 가장 잘 알기 때문에 정확한 정보를 제공할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스와 레지스트리 간의 결합도가 높아진다.&lt;/li&gt;
&lt;li&gt;각 프로그래밍 언어와 프레임워크마다 등록 로직을 구현해야 한다.&lt;/li&gt;
&lt;li&gt;서비스가 비정상적으로 종료될 경우 레지스트리에서 자동으로 제거되지 않을 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Netflix Eureka&lt;/strong&gt;는 셀프 등록 패턴의 대표적인 예시이다.&lt;br&gt;
Eureka 클라이언트는 다음과 같은 방식으로 동작한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Server-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</guid>
      <description>&lt;h2 id=&#34;server-side-discovery&#34;&gt;Server-side Discovery&lt;/h2&gt;
&lt;p&gt;Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.&lt;/p&gt;
&lt;p&gt;Server-side Discovery는 클라이언트를 단순화하고 중앙 집중식 관리를 가능하게 하는 장점이 있지만, 추가 인프라와 관리가 필요한 단점도 있다. 프로젝트의 요구사항과 팀의 역량을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 등록: 각 서비스 인스턴스는 시작 시 자신의 정보를 서비스 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;클라이언트 요청: 클라이언트는 서비스의 실제 위치를 모르고, 로드 밸런서에 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;서비스 조회: 로드 밸런서는 서비스 레지스트리에서 해당 서비스의 가용한 인스턴스 정보를 조회한다.&lt;/li&gt;
&lt;li&gt;요청 라우팅: 로드 밸런서는 적절한 서비스 인스턴스를 선택하여 요청을 전달한다.&lt;/li&gt;
&lt;li&gt;응답 반환: 서비스의 응답은 로드 밸런서를 통해 클라이언트에게 전달된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트 단순화: 클라이언트는 서비스 디스커버리 로직을 구현할 필요가 없어 단순해진다.&lt;/li&gt;
&lt;li&gt;언어 중립성: 클라이언트 측 구현이 필요 없어 다양한 프로그래밍 언어로 개발된 서비스들을 쉽게 통합할 수 있다.&lt;/li&gt;
&lt;li&gt;보안 강화: 로드 밸런서 수준에서 추가적인 보안 계층을 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;중앙 집중식 관리: 서비스 디스커버리와 로드 밸런싱을 중앙에서 관리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;추가 인프라 필요: 로드 밸런서나 프록시 서버와 같은 추가 인프라가 필요하다.&lt;/li&gt;
&lt;li&gt;단일 실패 지점: 로드 밸런서가 단일 실패 지점이 될 수 있어 고가용성 설계가 중요하다.&lt;/li&gt;
&lt;li&gt;복잡성 증가: 전체 시스템의 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AWS Elastic Load Balancer (ELB)&lt;/strong&gt;: 클라이언트는 ELB의 DNS 이름을 통해 요청을 보내며, ELB는 등록된 EC2 인스턴스나 ECS 컨테이너 사이에서 부하를 분산한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes의 kube-proxy&lt;/strong&gt;: Kubernetes에서는 각 노드에서 실행되는 kube-proxy가 서비스 디스커버리와 로드 밸런싱을 담당하며, 클러스터 내의 서비스 요청을 적절한 파드(Pod)로 전달한다.&lt;/li&gt;
&lt;li&gt;Node.js를 사용한 Server-side Discovery 구현 예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-21&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-21&#34;&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-22&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-22&#34;&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-23&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-23&#34;&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-24&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-24&#34;&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-25&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-25&#34;&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-26&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-26&#34;&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-27&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-27&#34;&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-28&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-28&#34;&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-29&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-29&#34;&gt;29&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-30&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-30&#34;&gt;30&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-31&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-31&#34;&gt;31&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-32&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-32&#34;&gt;32&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-33&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-33&#34;&gt;33&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-34&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-34&#34;&gt;34&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-35&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-35&#34;&gt;35&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-36&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-36&#34;&gt;36&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-37&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-37&#34;&gt;37&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-38&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-38&#34;&gt;38&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-39&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-39&#34;&gt;39&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-40&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-40&#34;&gt;40&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-41&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-41&#34;&gt;41&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-42&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-42&#34;&gt;42&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-43&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-43&#34;&gt;43&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-44&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-44&#34;&gt;44&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-45&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-45&#34;&gt;45&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-46&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-46&#34;&gt;46&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-47&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-47&#34;&gt;47&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-48&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-48&#34;&gt;48&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-49&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-49&#34;&gt;49&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-50&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-50&#34;&gt;50&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-51&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-51&#34;&gt;51&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-52&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-52&#34;&gt;52&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 서버 사이드 디스커버리 라우터 구현
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServiceRouter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://service-registry:8500&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 30초
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extractServiceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 서비스 인스턴스 찾기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 요청 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 응답 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handleError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 캐시된 서비스 확인
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getCachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 서비스 레지스트리 조회
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;queryRegistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;updateCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buildTargetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service registry</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</guid>
      <description>&lt;h2 id=&#34;service-registry&#34;&gt;Service Registry&lt;/h2&gt;
&lt;p&gt;Service Registry는 마이크로서비스 환경에서 각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스이다.&lt;br&gt;
이는 동적으로 변화하는 마이크로서비스 환경에서 서비스 디스커버리를 가능하게 하는 핵심 요소이다.&lt;/p&gt;
&lt;p&gt;Service Registry는 MSA 환경에서 서비스 디스커버리를 가능하게 하는 핵심 컴포넌트이다. 이를 통해 동적이고 확장 가능한 마이크로서비스 아키텍처를 구현할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;서비스-레지스트리의-중요성&#34;&gt;서비스 레지스트리의 중요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 서비스 인스턴스가 자동 확장, 장애 복구, 배포 등의 이유로 동적으로 생성되고 소멸되며, 이에 따라 네트워크 위치가 변경된다.&lt;br&gt;
이러한 동적인 특성으로 인해, 서비스 레지스트리는 다음과 같은 역할을 수행한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</guid>
      <description>&lt;h2 id=&#34;client-side-discovery&#34;&gt;Client-side Discovery&lt;/h2&gt;
&lt;p&gt;Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.&lt;/p&gt;
&lt;p&gt;Client-side Discovery는 마이크로서비스 환경에서 유연하고 확장 가능한 서비스 디스커버리 방식을 제공한다. 그러나 클라이언트의 복잡도가 증가하는 단점이 있으므로, 프로젝트의 요구사항과 팀의 기술 스택을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;서비스 레지스트리(Service Registry)&lt;/strong&gt;: 각 서비스 인스턴스의 네트워크 위치(예: IP 주소, 포트)를 저장하고 관리하는 데이터베이스이다. 서비스 인스턴스는 시작 시 자신의 정보를 레지스트리에 등록하고, 종료 시 등록을 해제한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Backend for Frontend Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</link>
      <pubDate>Thu, 14 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</guid>
      <description>BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다.</description>
    </item>
    <item>
      <title>Service Discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/</link>
      <pubDate>Thu, 14 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/</guid>
      <description>&lt;h2 id=&#34;service-discovery&#34;&gt;Service Discovery&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Service Discovery는 핵심적인 패턴 중 하나이다.&lt;br&gt;
이 패턴은 동적으로 변화하는 분산 환경에서 서비스 간 통신을 가능하게 하는 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Service Discovery는 네트워크 상의 서비스 위치(IP 주소와 포트)를 자동으로 감지하고 관리하는 프로세스이다.&lt;br&gt;
이는 클라우드 환경이나 컨테이너 기반 아키텍처에서 특히 중요한데, 서비스 인스턴스가 동적으로 생성되고 제거되는 상황에서 효과적인 통신을 가능하게 한다.&lt;/p&gt;
&lt;h3 id=&#34;필요성&#34;&gt;필요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;동적 환경 대응: 클라우드 및 컨테이너 기반 환경에서 서비스의 IP 주소와 포트가 동적으로 변경된다.&lt;/li&gt;
&lt;li&gt;자동 스케일링: 서비스 인스턴스가 자동으로 추가되거나 제거될 때 이를 감지하고 관리해야 한다.&lt;/li&gt;
&lt;li&gt;장애 대응: 서비스 장애 시 자동으로 대체 인스턴스로 전환할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;service-discovery의-주요-구성-요소&#34;&gt;Service Discovery의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;서비스 레지스트리&lt;/strong&gt;: 사용 가능한 서비스 인스턴스의 네트워크 위치를 저장하는 데이터베이스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 등록&lt;/strong&gt;: 서비스 인스턴스가 시작될 때 자신의 정보를 레지스트리에 등록하는 프로세스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 발견&lt;/strong&gt;: 클라이언트가 필요한 서비스의 위치를 레지스트리에서 조회하는 프로세스&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 모니터링&lt;/strong&gt;: 등록된 서비스의 상태를 주기적으로 확인하는 메커니즘&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;service-discovery-패턴의-종류&#34;&gt;Service Discovery 패턴의 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Client-Side Discovery: 클라이언트가 직접 서비스 레지스트리에 질의하여 서비스 위치를 찾는 방식.&lt;br&gt;
장점:&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Gateway Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway/</link>
      <pubDate>Thu, 14 Nov 2024 01:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway/</guid>
      <description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</description>
    </item>
    <item>
      <title>Service deployment platform</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</guid>
      <description>&lt;h2 id=&#34;service-deployment-platform&#34;&gt;Service Deployment Platform&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service deployment platform&amp;quot;은 마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼이다. 이 플랫폼은 개발자들이 마이크로서비스를 쉽게 개발, 배포, 운영할 수 있도록 지원하는 종합적인 환경을 제공한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;자동화된 배포: Service deployment platform은 CI/CD (지속적 통합/지속적 배포) 파이프라인을 통해 자동화된 배포 프로세스를 제공한다. 이를 통해 개발자는 코드 변경사항을 빠르고 안정적으로 프로덕션 환경에 반영할 수 있다.&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션: 대부분의 Service deployment platform은 쿠버네티스와 같은 컨테이너 오케스트레이션 도구를 기반으로 한다. 이를 통해 마이크로서비스의 확장성, 가용성, 복원력을 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리: 플랫폼은 서비스 디스커버리 메커니즘을 제공하여 마이크로서비스 간의 통신을 용이하게 한다. 이를 통해 동적으로 변화하는 환경에서도 서비스 간 연결을 유지할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅: Service deployment platform은 통합된 모니터링 및 로깅 기능을 제공한다. 이를 통해 개발자와 운영팀은 서비스의 성능을 실시간으로 모니터링하고 문제를 신속하게 진단할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 레지스트리: 서비스의 컨테이너 이미지를 저장하고 관리하는 중앙 저장소이다.&lt;/li&gt;
&lt;li&gt;오케스트레이션 엔진: 쿠버네티스와 같은 도구로, 컨테이너의 배포, 스케일링, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;API 게이트웨이: 클라이언트 요청을 적절한 마이크로서비스로 라우팅하고 인증, 로드 밸런싱 등의 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;서비스 메시: 마이크로서비스 간의 통신을 관리하고 모니터링하는 인프라 레이어이다.&lt;/li&gt;
&lt;li&gt;설정 관리: 다양한 환경(개발, 테스트, 프로덕션)에 대한 설정을 중앙에서 관리한다.&lt;/li&gt;
&lt;li&gt;로깅 및 모니터링 도구: 서비스의 성능과 상태를 추적하고 분석하는 도구들이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;개발 생산성 향상: 개발자가 인프라 관리보다는 비즈니스 로직 개발에 집중할 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;빠른 배포 및 롤백: 자동화된 프로세스를 통해 신속한 배포와 문제 발생 시 빠른 롤백이 가능하다.&lt;/li&gt;
&lt;li&gt;확장성: 트래픽 증가에 따라 서비스를 쉽게 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;운영 효율성: 자동화된 모니터링과 관리 도구를 통해 운영 효율성을 높일 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;대표적인-서비스-배포-플랫폼&#34;&gt;대표적인 서비스 배포 플랫폼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;쿠버네티스(Kubernetes):&lt;/strong&gt; 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 플랫폼으로, MSA 환경에서 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오픈시프트(OpenShift):&lt;/strong&gt; 레드햇에서 개발한 쿠버네티스 기반의 엔터프라이즈급 애플리케이션 플랫폼으로, 추가적인 개발자 및 운영자 도구를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이스티오(Istio):&lt;/strong&gt; 서비스 메시(Service Mesh) 구현체로, 서비스 간의 통신, 보안, 모니터링, 트래픽 관리를 지원하여 MSA의 운영 복잡성을 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도입-시-고려사항&#34;&gt;도입 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;러닝 커브:&lt;/strong&gt; 새로운 플랫폼 도입에 따른 학습 곡선이 있을 수 있으므로, 충분한 교육과 학습 기간이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인프라 요구사항:&lt;/strong&gt; 플랫폼이 요구하는 인프라 자원을 사전에 평가하고, 이에 맞게 인프라를 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; 플랫폼 자체의 보안 기능과 더불어, 조직의 보안 정책에 부합하는지 검토해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커뮤니티 및 지원:&lt;/strong&gt; 플랫폼의 커뮤니티 활성도와 지원 체계를 확인하여, 문제 발생 시 신속한 대응이 가능한지 판단해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</guid>
      <description>&lt;h2 id=&#34;service-per-vm&#34;&gt;Service per VM&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; (VM당 서비스) 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식이다. 이 패턴의 주요 특징과 장단점을 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; 패턴은 강력한 격리와 리소스 관리를 제공하지만, 리소스 오버헤드와 관리 복잡성 증가라는 대가가 따른다. 이 패턴은 높은 수준의 격리가 필요하거나 서비스 간 리소스 경쟁을 최소화해야 하는 경우에 적합하다.&lt;br&gt;
그러나 리소스 효율성과 빠른 배포가 중요한 경우에는 다른 배포 패턴을 고려해볼 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</guid>
      <description>&lt;h2 id=&#34;multiple-services-per-host&#34;&gt;Multiple Services per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Multiple Services per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;이 패턴에서는 하나 이상의 물리적 또는 가상 호스트를 준비하고, 각 호스트에 여러 개의 서비스 인스턴스를 실행한다. 이는 전통적인 애플리케이션 배포 방식을 반영한 것이다.&lt;/p&gt;
&lt;p&gt;이 패턴은 리소스 효율성과 배포 용이성이라는 장점이 있지만, 복잡성 증가와 서비스 간 격리 부족이라는 단점도 있다. 따라서 프로젝트의 요구사항과 규모에 따라 신중하게 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per-Container</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</guid>
      <description>&lt;h2 id=&#34;service-per-container&#34;&gt;Service per-Container&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-Container&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;독립성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;경량화&lt;/strong&gt;: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이식성&lt;/strong&gt;: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 &amp;ldquo;한 번 빌드하고 어디서나 실행&amp;quot;이라는 원칙을 실현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;버전 관리&lt;/strong&gt;: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장애 격리&lt;/strong&gt;: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기술 스택 다양성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;배포 유연성&lt;/strong&gt;: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 오버헤드&lt;/strong&gt;: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;통신 오버헤드&lt;/strong&gt;: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컨테이너 오케스트레이션&lt;/strong&gt;: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리&lt;/strong&gt;: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;컨테이너 이미지 최적화
&lt;ol&gt;
&lt;li&gt;기반 이미지 최소화&lt;/li&gt;
&lt;li&gt;멀티 스테이지 빌드 적용&lt;/li&gt;
&lt;li&gt;캐시 레이어 최적화&lt;/li&gt;
&lt;li&gt;불필요한 파일 제거&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;네트워킹
&lt;ol&gt;
&lt;li&gt;서비스간 통신 설정&lt;/li&gt;
&lt;li&gt;네트워크 보안 정책&lt;/li&gt;
&lt;li&gt;로드 밸런싱&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 이미지 생성:
&lt;ul&gt;
&lt;li&gt;각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다.&lt;/li&gt;
&lt;li&gt;Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션:
&lt;ul&gt;
&lt;li&gt;Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅 설정:
&lt;ul&gt;
&lt;li&gt;Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;p&gt;예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</guid>
      <description>&lt;h2 id=&#34;single-service-per-host&#34;&gt;Single Service per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Single Service per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</guid>
      <description>&lt;h2 id=&#34;serverless-deployment&#34;&gt;Serverless Deployment&lt;/h2&gt;
&lt;p&gt;Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 혁신적인 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.&lt;/p&gt;
&lt;p&gt;결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</guid>
      <description>&lt;h2 id=&#34;self-contained-service&#34;&gt;Self-contained Service&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;self-contained service&amp;rdquo; 패턴은 서비스의 자율성과 독립성을 극대화하는 중요한 개념이다.&lt;/p&gt;
&lt;p&gt;Self-contained Service는 단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.&lt;br&gt;
이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.&lt;/p&gt;
&lt;p&gt;Self-contained Service 패턴은 MSA의 핵심 원칙을 구현하는 방법 중 하나로, 서비스의 자율성과 독립성을 극대화하여 시스템의 유연성과 확장성을 높이는 데 기여한다. 하지만 이 패턴을 적용할 때는 시스템의 복잡성 증가와 데이터 일관성 관리 등의 도전 과제를 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</guid>
      <description>&lt;h2 id=&#34;service-per-team&#34;&gt;Service per Team&lt;/h2&gt;
&lt;p&gt;Service per team 패턴은 각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식이다.&lt;br&gt;
이 패턴에서는 각 팀이 특정 비즈니스 기능을 담당하며, 해당 기능의 코드베이스를 소유한다.&lt;/p&gt;
&lt;p&gt;Service per team 패턴은 팀의 자율성과 책임감을 높이는 동시에 마이크로서비스 아키텍처의 이점을 최대화할 수 있는 효과적인 접근 방식이다. 그러나 이 패턴을 성공적으로 구현하기 위해서는 조직 문화, 팀 구조, 그리고 기술적 인프라 등 여러 측면에서의 신중한 고려가 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성&lt;/strong&gt;: 각 팀은 자신의 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 중심 협업&lt;/strong&gt;: 팀들은 주로 API를 통해 상호작용하며, 다른 팀과의 협업을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소규모 팀&lt;/strong&gt;: 일반적으로 &amp;ldquo;two-pizza team&amp;rdquo; 크기의 소규모 팀이 각 서비스를 담당한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인지 부하 감소&lt;/strong&gt;: 팀원들이 전체 시스템이 아닌 특정 서비스에만 집중할 수 있어 인지 부하가 감소한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성 강화&lt;/strong&gt;: 각 팀이 독립적으로 의사 결정을 내릴 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;느슨한 결합&lt;/strong&gt;: 팀 간의 의존성이 줄어들어 더 유연한 개발이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;코드 품질 향상&lt;/strong&gt;: 장기적인 코드 소유권으로 인해 코드 품질이 개선된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빠른 개발 및 배포&lt;/strong&gt;: 작은 팀이 독립적으로 개발하고 배포할 수 있어 시장 변화에 빠르게 대응할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡한 프로젝트 조정&lt;/strong&gt;: 여러 서비스에 걸친 복잡한 프로젝트의 경우 팀 간 조정이 어려워질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;높은 WIP (Work in Progress)&lt;/strong&gt;: 각 팀이 항상 바쁘게 유지되어야 하므로 진행 중인 작업이 많아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;좁은 가치 흐름&lt;/strong&gt;: 이상적인 구현에서는 팀들이 완전히 분리되어 있어, 조직 전체의 가치 흐름이 좁아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화되지 않은 우선순위 지정&lt;/strong&gt;: 팀의 가용성이 프로젝트 우선순위 결정의 주요 요인이 될 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 구성&lt;/strong&gt;: 각 서비스를 담당할 수 있는 cross-functional 팀을 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 경계 정의&lt;/strong&gt;: 비즈니스 기능과 하위 도메인을 기반으로 서비스 경계를 명확히 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀 간 커뮤니케이션&lt;/strong&gt;: API 설계와 변경에 대한 팀 간 효과적인 커뮤니케이션 채널을 구축해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 새로운 팀을 추가하거나 기존 서비스를 분할할 때의 전략을 미리 수립해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;&lt;strong&gt;예시:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;대규모 전자상거래 플랫폼을 운영하는 기업을 예로 들어보자.&lt;br&gt;
이 기업은 다음과 같은 주요 비즈니스 기능을 가지고 있다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Service Mesh</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-mesh/</link>
      <pubDate>Wed, 13 Nov 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-mesh/</guid>
      <description>마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하기 위한 인프라 계층</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</guid>
      <description>&lt;h2 id=&#34;decompose-by-business-capability&#34;&gt;Decompose by Business Capability&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Business Capability&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴이다.&lt;br&gt;
이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.&lt;/p&gt;
&lt;p&gt;이 패턴은 조직의 비즈니스 능력을 기반으로 마이크로서비스를 정의한다.&lt;br&gt;
비즈니스 능력은 조직이 가치를 창출하기 위해 수행하는 특정 기능이나 프로세스를 의미한다.&lt;/p&gt;
&lt;p&gt;주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비즈니스 목표와 소프트웨어 개발의 정렬&lt;/li&gt;
&lt;li&gt;독립적으로 개발 및 유지보수 가능한 서비스 생성&lt;/li&gt;
&lt;li&gt;조직 구조와 시스템 아키텍처의 일치&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 조직의 비즈니스 도메인에 대한 깊은 이해가 필요하며, 지속적인 비즈니스 분석과 서비스 경계의 조정이 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</guid>
      <description>&lt;h2 id=&#34;decompose-by-subdomain&#34;&gt;Decompose by Subdomain&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Subdomain&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴 중 하나이다.&lt;br&gt;
이 패턴은 도메인 주도 설계(DDD)의 개념을 기반으로 하며, 비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법이다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 비즈니스 도메인에 대한 깊은 이해와 지속적인 분석이 필요하다. 또한, 하위 도메인 간의 상호작용을 고려하여 서비스 간 통신을 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 중심 접근: 기술적 세부사항보다 비즈니스 기능에 초점을 맞춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하위 도메인 분류:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;핵심(Core): 비즈니스의 핵심 차별화 요소&lt;/li&gt;
&lt;li&gt;지원(Supporting): 비즈니스 관련이지만 차별화 요소는 아님&lt;/li&gt;
&lt;li&gt;일반(Generic): 비즈니스 특화되지 않은 일반적 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경계 설정: 각 하위 도메인은 명확한 경계(Bounded Context)를 가진다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decomposition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/</guid>
      <description>&lt;h2 id=&#34;decomposition&#34;&gt;Decomposition&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Deployment</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/</guid>
      <description>&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Database</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/</guid>
      <description>&lt;h2 id=&#34;database&#34;&gt;Database&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Domain-specific</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</guid>
      <description>&lt;h2 id=&#34;domain-specific&#34;&gt;Domain-specific&lt;/h2&gt;
&lt;p&gt;Domain-specific 프로토콜은 특정 도메인이나 비즈니스 영역에 특화된 통신 프로토콜을 의미한다.&lt;br&gt;
이 프로토콜은 일반적인 통신 프로토콜보다 해당 도메인의 특성과 요구사항에 더 적합하게 설계되어 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;도메인 주도 설계(DDD)와의 연계:&lt;/strong&gt; 도메인 주도 설계는 복잡한 소프트웨어를 개발할 때 도메인 모델을 중심으로 설계하는 접근 방식이다. MSA에서 도메인별 통신 스타일을 적용하면, 각 도메인의 비즈니스 로직과 데이터가 해당 서비스 내에서 캡슐화되어 독립성을 유지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;통신 프로토콜의 선택:&lt;/strong&gt; 각 도메인의 특성에 따라 적합한 통신 프로토콜을 선택한다. 예를 들어, 실시간성이 중요한 도메인에서는 gRPC나 GraphQL과 같은 프로토콜을, 비동기 처리가 적합한 도메인에서는 Kafka나 AMQP와 같은 메시징 프로토콜을 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Remote-Procedure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</guid>
      <description>&lt;h2 id=&#34;remote-procedure&#34;&gt;Remote-Procedure&lt;/h2&gt;
&lt;p&gt;Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.&lt;/p&gt;
&lt;h3 id=&#34;rpc의-작동-원리&#34;&gt;RPC의 작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 로컬 프로시저를 호출한다.&lt;/li&gt;
&lt;li&gt;클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다.&lt;/li&gt;
&lt;li&gt;클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다.&lt;/li&gt;
&lt;li&gt;서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다.&lt;/li&gt;
&lt;li&gt;서버 스텁이 파라미터를 언마샬링(unmarshalling)한다.&lt;/li&gt;
&lt;li&gt;서버 스텁이 서버 프로시저를 호출한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-특징&#34;&gt;RPC의 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다.&lt;/li&gt;
&lt;li&gt;높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다.&lt;/li&gt;
&lt;li&gt;위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpi-패턴의-주요-구성-요소&#34;&gt;RPI 패턴의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다.&lt;/li&gt;
&lt;li&gt;서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-장점&#34;&gt;RPC의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;효율성: 도메인 특화 기능으로 통신 효율성이 높아진다.&lt;/li&gt;
&lt;li&gt;구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-단점&#34;&gt;RPC의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다.&lt;/li&gt;
&lt;li&gt;복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다.&lt;/li&gt;
&lt;li&gt;호환성 문제: 다른 시스템과의 통합이 어려울 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpi-패턴-구현-시-고려해야-할-사항&#34;&gt;RPI 패턴 구현 시 고려해야 할 사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다.&lt;/li&gt;
&lt;li&gt;확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;msa에서의-rpc-활용&#34;&gt;MSA에서의 RPC 활용&lt;/h3&gt;
&lt;p&gt;마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</link>
      <pubDate>Tue, 12 Nov 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</guid>
      <description>&lt;h2 id=&#34;messaging&#34;&gt;Messaging&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Messaging은 중요한 Communication style 중 하나이다.&lt;br&gt;
Messaging은 서비스 간 비동기 통신을 가능하게 하며, 시스템의 확장성과 유연성을 향상시킨다.&lt;/p&gt;
&lt;p&gt;Messaging은 서비스들이 메시지를 통해 비동기적으로 통신하는 방식이다. 서비스들은 메시지 브로커를 통해 메시지를 주고받으며, 이를 통해 느슨한 결합(loose coupling)을 실현한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비동기 통신&lt;/strong&gt;: 서비스는 메시지를 보내고 즉시 다른 작업을 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;느슨한 결합&lt;/strong&gt;: 서비스들은 직접적인 연결 없이 메시지를 통해 통신한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 구조&lt;/strong&gt;: 메시지는 일반적으로 헤더(header)와 바디(message body)로 구성된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;채널 기반 통신&lt;/strong&gt;: 메시지는 채널을 통해 전달된다. point-to-point 채널과 publish-subscribe 채널이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;messaging-패턴&#34;&gt;Messaging 패턴&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Request/Response&lt;/strong&gt;: 서비스가 요청 메시지를 보내고 응답을 기다린다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Notifications&lt;/strong&gt;: 서비스가 메시지를 보내지만 응답을 기대하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Publish/Subscribe&lt;/strong&gt;: 서비스가 메시지를 발행하면 여러 수신자가 구독할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event-Driven&lt;/strong&gt;: 서비스가 이벤트를 발행하고 다른 서비스들이 이에 반응한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;messaging-패턴의-주요-구성-요소&#34;&gt;Messaging 패턴의 주요 구성 요소&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;메시지 구조:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Microservice Chassis</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</guid>
      <description>&lt;h2 id=&#34;microservice-chassis&#34;&gt;Microservice Chassis&lt;/h2&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 프레임워크나 라이브러리 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 개발에 필요한 공통 기능을 제공하는 기본 프레임워크이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공통 기능의 추상화:&lt;/strong&gt; 인증 및 권한 부여, 로깅, 설정 관리, 헬스 체크, 메트릭 수집, 분산 추적 등 여러 서비스에 걸쳐 공통적으로 필요한 기능들을 섀시에서 제공하여 코드 중복을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관된 빌드 및 배포 프로세스:&lt;/strong&gt; 빌드 로직과 배포 설정을 섀시에서 관리하여, 모든 서비스가 일관된 방식으로 빌드되고 배포될 수 있도록 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 새로운 서비스 개발 시 섀시를 기반으로 빠르게 시작할 수 있으며, 공통 기능의 변경이 필요할 경우 섀시를 업데이트하여 모든 서비스에 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Microservice Chassis는 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service Template</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</link>
      <pubDate>Tue, 12 Nov 2024 11:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</guid>
      <description>&lt;h2 id=&#34;service-template&#34;&gt;Service Template&lt;/h2&gt;
&lt;p&gt;Service Template 패턴은 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 중요한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 템플릿 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Service Template은 마이크로서비스 개발에 필요한 공통 기능과 구조를 제공하는 기본 템플릿이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;재사용 가능한 코드 기반:&lt;/strong&gt; 서비스 템플릿은 빌드 로직, 공통 설정, 크로스커팅 관심사(예: 로깅, 보안, 설정 관리 등)를 포함한 실행 가능한 간단한 서비스를 제공한다. 이를 통해 새로운 서비스를 시작할 때 필요한 기본 구조를 빠르게 구축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관성 유지:&lt;/strong&gt; 모든 서비스가 동일한 템플릿을 기반으로 생성되므로, 코드 구조와 설정이 일관되어 유지보수성과 가독성이 향상된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Service Template은 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Database per Service Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</guid>
      <description>&lt;h2 id=&#34;shared-database&#34;&gt;Shared Database&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;Shared Database&amp;rdquo; 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Communication style</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/</link>
      <pubDate>Tue, 12 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/</guid>
      <description>&lt;h2 id=&#34;communication-style&#34;&gt;Communication style&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Cross-Cutting Concern Patterns</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/</link>
      <pubDate>Tue, 12 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/</guid>
      <description>Ambassador pattern, Service Discovery pattern, Service Mesh pattern, 그리고 Sidecar pattern은 모두 마이크로서비스 아키텍처에서 발생하는 cross-cutting concern(횡단 관심사)를 해결하기 위한 디자인 패턴들이다.</description>
    </item>
  </channel>
</rss>
