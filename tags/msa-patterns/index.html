<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA-Patterns | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA-Patterns"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA-Patterns"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>MSA-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-engineering/data-pipeline/data-pipeline-design/data-pipeline-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/system-design/use-cases/industry-patterns/msa-pattern-comparison/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Client-side UI composition</h2></header><div class=entry-content><p>Client-side UI Composition Client-side UI Composition은 마이크로서비스 아키텍처(MSA)에서 클라이언트(주로 브라우저)가 여러 마이크로서비스로부터 데이터를 직접 가져와 사용자 인터페이스(UI)를 구성하는 패턴이다.
이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.
이 패턴에서는 클라이언트(브라우저)가 여러 마이크로서비스로부터 데이터를 요청하고, 해당 데이터를 기반으로 UI를 렌더링한다. 각 마이크로서비스는 자신만의 UI 컴포넌트(HTML, CSS, JavaScript 등)를 제공하며, 클라이언트는 이러한 컴포넌트를 조합해 전체 화면을 구성한다.
예를 들어, 전자상거래 웹사이트의 상품 상세 페이지를 생각해보면:
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-side UI composition" href=https://buenhyden.github.io/posts/system-design/use-cases/integration-patterns/ui-integration/client-side-ui-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-side page fragment composition</h2></header><div class=entry-content><p>Server-side Page Fragment Composition Server-side page fragment composition은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.
Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.
예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-side page fragment composition" href=https://buenhyden.github.io/posts/system-design/use-cases/integration-patterns/ui-integration/server-side-page-fragment-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Key Authentication</h2></header><div class=entry-content><p>API Key Authentication API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.
API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.
API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Key Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/application-and-software-security/api-security/best-practices/api-keys/api-key-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.
CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.
CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.
CORS의 작동 원리 브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다. 서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다. 브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다. Origin의 정의
Origin은 다음 세 가지 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/application-and-software-security/web-security/client-side/cors/cors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mutual TLS</h2></header><div class=entry-content><p>Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutual TLS" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/infrastructure-and-cloud-security/network-security/data-protection-protocols/tls/mutual-tls/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth2/OIDC (OpenID Connect)</h2></header><div class=entry-content><p>OAuth2/OIDC (OpenID Connect) MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.
OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.
OAuth 2.0 OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth2/OIDC (OpenID Connect)" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/protocols/authorization-and-delegation/oauth/oauth-2.0/oauth2-oidc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Access Token</h2></header><div class=entry-content><p>Access Token Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.
Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.
Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
Access Token의 특징 유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다. Stateless: 서버에 상태를 저장하지 않아 확장성이 높다. 암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다. 포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다. Access Token의 동작 방식 사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다. 토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지). 요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다. 서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다. Access Token의 장점 확장성: Stateless 특성으로 서버 확장이 용이하다. 보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다. 효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다. Access Token의 단점 토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다. 제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다. Access Token과 Refresh Token 보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-18 11:22:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Token" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/session-and-token-management/token-based-authentication/access-token/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fail Fast</h2></header><div class=entry-content><p>Fail Fast 아래는 Fail Fast Pattern에 대한 1~5 단계 정리입니다. 이후 단계도 반영 준비 완료되었어요!
1. 태그 (Tags) Fail-Fast-Pattern
Resilience-Patterns
Rapid-Failure-Detection
Defensive-Programming
2. 분류 구조 적절성 검토 “Fail Fast Pattern” 은 “Software Engineering > Design and Architecture > Architecture Patterns > Resilience Patterns” 안에 잘 맞습니다.
근거: 분산 시스템이나 모듈 내에서 오류가 발생하면 즉시 실패를 감지하고 전파하여, 지연 오류 (cascading failure) 와 상태 부정확성을 방지하는 탄력성 전략입니다 (blog.bernd-ruecker.com, arxiv.org, arxiv.org). 3. 요약 (200 자 내외) Fail Fast Pattern 은 시스템 내에서 예상치 못한 오류나 불일치 상태가 발생했을 때, 가능한 한 빨리 실패를 감지하고 처리하며 중단함으로써 오류 확산과 디버깅 어려움을 줄이는 소프트웨어 설계 원칙입니다. 초기 오류 발견과 명시적인 실패는 안정성과 유지보수성을 크게 높입니다 .
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fail Fast" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture-patterns/resilience-and-reliability/fault-tolerance/failure-isolation/fail-fast-pattern/fail-fast/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/msa-patterns/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>