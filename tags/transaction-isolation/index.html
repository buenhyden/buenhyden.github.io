<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Transaction-Isolation | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/transaction-isolation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/transaction-isolation/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/transaction-isolation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/transaction-isolation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Transaction-Isolation"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Transaction-Isolation"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Transaction-Isolation</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Lost Update</h2></header><div class=entry-content><p>Lost Update Lost Update 는 여러 트랜잭션이 같은 행을 동시에 읽어 수정할 때 한쪽 갱신이 나중 갱신에 의해 덮여 사라지는 현상이다.
MVCC(스냅샷) 는 일부 읽기 문제를 막지만, 클라이언트 측에서 Read–Modify–Write 패턴을 쓰면 여전히 발생할 수 있다.
실무 대응은
가능한 경우 UPDATE … SET v = v + 1 처럼 원자적 SQL 사용 충돌이 잦지 않으면 낙관적 잠금(버전/타임스탬프 비교) 으로 충돌 감지 후 재시도 핫스팟엔 비관적 잠금(SELECT … FOR UPDATE) 사용 강제 일관성이 필요하면 DBMS 의 Serializable/SSI 선택이다 운영에서는 충돌률·재시도율·락 대기 시간을 관측하고 재시도·백오프 정책을 설계해야 한다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;44 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lost Update" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Phantom Read</h2></header><div class=entry-content><p>Phantom Read Phantom Read 는 한 트랜잭션이 같은 조건으로 반복 조회할 때, 다른 트랜잭션의 삽입·삭제로 인해 결과 행 집합이 달라지는 현상이다.
예컨대 " 잔여 재고가 0 이면 주문 허용 " 을 검사할 때 다른 트랜잭션이 새 주문을 추가하면 최초 조건이 깨질 수 있다.
전통적 2PL 은 키 - 범위 잠금으로 갭을 막아 phantom 을 예방하고, MVCC 기반 DB 는 **스냅샷 + 직렬화 (Serializable/SSI)**로 충돌을 감지해 해결한다. 하지만 강한 격리는 동시성·지연·교착 비용을 키우므로, 실무에서는 위험 쿼리를 먼저 식별하고 (업무 불변식), 범위 인덱스·명시적 락·트랜잭션 경계 재설계 또는 애플리케이션 레벨 보완을 조합해 적용하는 것이 현실적이다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;47 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Phantom Read" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Write Skew</h2></header><div class=entry-content><p>Write Skew Write Skew 는 두 트랜잭션이 같은 **판단 (읽기)**을 하고 각자 다른 레코드를 갱신해서 결과적으로 비즈니스 규칙이 깨지는 현상이다.
예: 두 의사가 동시에 당직 해제 판단 → 최종적으로 아무도 남지 않는 상황. Snapshot Isolation 은 읽기는 스냅샷에서 빠르게 처리하고 쓰기 충돌 (같은 행을 동시에 쓰는 경우) 만 검사하기 때문에 이런 상황을 허용할 수 있다.
예방은 DB 수준 (Serializable/SSI, predicate/next-key locks) 이나 애플리케이션 수준 (guard row, 명시적 락, 집계 테이블) 으로 수행하며, 운영적으로는 직렬화 오류율을 모니터링하고 재시도 정책을 설계해야 한다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;41 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Write Skew" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dirty Read</h2></header><div class=entry-content><p>Dirty Read Dirty Read 는 한 트랜잭션이 커밋하지 않은 변경을 다른 트랜잭션이 읽는 현상으로, 잘못된 집계·오판·롤백 후 부정합을 초래한다.
대부분의 실무에서는 정확성 우선 업무에는 금지하고, 로그·집계처럼 정확성 요구가 낮은 영역에만 제한적으로 허용한다.
완화책으로는 MVCC 기반 스냅샷 격리 (RCSI/SI), 읽기 전용 리플리카 (CQRS), 쿼리 힌트·화이트리스트 적용, 모니터링 및 재현 테스트가 있다.
DB 엔진별 동작이 다르니 적용 전 반드시 벤더별 테스트와 정책 문서화를 수행하라.
Dirty Read 개념·관계·실무 적용 Dirty Read 는 아직 확정되지 않은 (커밋되지 않은) 변경을 읽는 상황 을 말한다.
이로 인해 나중에 원 트랜잭션이 취소되면 읽은 값이 허위가 되어 잘못된 계산·보고가 발생할 수 있다.
따라서 대부분 운영 시스템은 기본적으로 Dirty Read 를 차단하는 READ COMMITTED 이상을 사용하고, 로그·모니터링 등 정확성에 덜 민감한 경로만 별도 복제본이나 스냅샷을 통해 읽도록 분리한다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:48:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;47 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dirty Read" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serializable</h2></header><div class=entry-content><p>Serializable Serializable 은 트랜잭션 동시성에서 가장 강한 격리 수준으로, 실행 결과가 어떤 순차적 실행과 같도록 보장해 Dirty Read·Non-Repeatable Read·Phantom 등 모든 이상현상을 차단한다.
구현 방식은 잠금 (Strict 2PL), MVCC 기반의 직렬성 검증 (SSI), 또는 낙관적 검증 (OCC) 등이며, 분산 환경에서는 2PC·분산 합의·외부 시계 같은 추가 메커니즘이 필요하다.
실무에서는 데이터 무결성이 절대적일 때 우선 적용하되 성능 저하·교착·재시도 비용을 인덱스 튜닝, 트랜잭션 단축, 백오프/재시도 설계, 부분적 격리 상향 (핵심 경로만) 으로 완화하는 것이 핵심 전략이다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:47:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serializable" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/serializable/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Read Committed</h2></header><div class=entry-content><p>Read Committed Read Committed(읽기 커밋) 는 실무에서 널리 쓰이는 기본 격리 수준으로, 항상 커밋된 데이터만 읽게 해 Dirty Read 를 차단한다.
다만 트랜잭션 내 여러 문장은 서로 다른 시점의 커밋 상태를 볼 수 있어 Non-repeatable Read 와 Phantom이 발생할 수 있다.
내부 구현은 DB 마다 달라 (PostgreSQL/Oracle 은 MVCC 스냅샷 기반, SQL Server 는 기본 락 기반에 RCSI 옵션 존재) 동일 명칭이라도 동작이 다르므로 DB 별로 테스트·검증해야 한다.
일반 웹·OLTP 는 Read Committed 가 성능·정합성의 균형이지만, 회계·결제 등 강한 일관성이 필요한 도메인에서는 Repeatable Read 나 Serializable 을 사용하는 것이 추천된다.
운영 시 장기 트랜잭션 회피, 락 대기·데드락 모니터링, 읽기 풀 설계로 위험을 완화하는 것이 추천된다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Read Committed" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Read Uncommitted</h2></header><div class=entry-content><p>Read Uncommitted Read Uncommitted(읽기 미확정) 는 트랜잭션 격리에서 가장 낮은 수준으로, 다른 트랜잭션의 커밋되지 않은 변경 (Dirty Read) 을 허용해 읽기 처리량을 최대화하려는 목적이다.
SQL 표준상 정의되지만, 많은 상용 DB 는 이를 진짜로 지원하지 않거나 내부적으로 Read Committed 로 승격하기 때문에 기대 동작을 DB 별로 확인해야 한다.
실무에서는 로그 집계·대략적 통계·탐색 쿼리처럼 정확성보다 속도가 우선인 경우에만 제한적으로 사용하며, 읽기 전용 커넥션 분리·금지 쿼리 목록·롤백 탐지·재검증 같은 가드레일을 반드시 둬야 안전하다.
읽기 성능이 필요하면 레플리카 기반 읽기, MVCC 스냅샷 격리 또는 샘플링을 우선 고려하는 편이 바람직하다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Read Uncommitted" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Repeatable Read</h2></header><div class=entry-content><p>Repeatable Read Repeatable Read(반복 읽기) 는 트랜잭션 내에서 같은 조회가 항상 동일한 결과를 반환하도록 보장해 재현성을 확보한다.
구현은 MVCC(스냅샷 기반) 또는 잠금 (범위·next-key) 방식으로 나뉘며, 두 방식은 가시성·충돌 처리·성능 특성이 다르다.
RR 은 Dirty Read 와 Non-repeatable Read 를 방지하지만 Phantom(범위 삽입/삭제) 은 엔진별로 다르게 처리된다.
따라서 금융·결산 같은 재현성이 중요한 워크로드에 유리하되, 실제 적용 전 DB 별 동작 확인, 재현 테스트, 성능·교착 검증, 필요 시 부분적 상향 (Serializable) 또는 리포트 분리가 필요하다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Repeatable Read" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/repeatable-read/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>