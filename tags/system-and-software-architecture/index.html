<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System-and-Software-Architecture | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/system-and-software-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/system-and-software-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/system-and-software-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/system-and-software-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System-and-Software-Architecture"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System-and-Software-Architecture"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>System-and-Software-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Framework vs. Library</h2></header><div class=entry-content><p>Framework vs. Library 프레임워크와 라이브러리는 소프트웨어 개발에서 필수적인 구성 요소로, 각각의 목적과 사용 방식이 다르다. 라이브러리는 특정 기능을 제공하는 코드 집합으로 개발자가 직접 호출해 사용한다. 반면, 프레임워크는 애플리케이션의 구조와 흐름을 정의하며, 개발자가 작성한 코드를 필요에 따라 호출하는 ’ 제어의 역전 ’ 원칙을 따른다. 이 차이는 시스템 설계의 핵심 원리와 실무 적용에 큰 영향을 미치며, 각 도구의 장단점, 적용 사례, 최적화 및 실무 적용 시 고려사항 등에서 뚜렷하게 드러난다.
핵심 개념 제어의 역전 (Inversion of Control, IoC): 프로그램의 제어 흐름이 전통적인 방식과 반대로 동작하는 설계 원칙 Hollywood Principle: “Don’t call us, we’ll call you” - 프레임워크가 개발자 코드를 호출 의존성 주입 (Dependency Injection): 객체의 의존성을 외부에서 주입하는 방식 애플리케이션 프레임워크 (Application Framework): 특정 도메인의 애플리케이션 개발을 위한 포괄적인 구조 코드 라이브러리 (Code Library): 재사용 가능한 함수와 클래스의 집합 Framework vs. Library 비교 구분 프레임워크 (Framework) 라이브러리 (Library) 정의 애플리케이션 개발을 위한 구조와 제어 흐름을 제공하는 소프트웨어 플랫폼 특정 기능을 수행하는 코드 집합으로, 필요 시 개발자가 직접 호출 제어 흐름 (Control Flow) 프레임워크가 전체 흐름을 제어하며, 개발자의 코드를 호출 (제어의 역전: IoC) 개발자가 라이브러리를 직접 호출하여 제어 흐름을 관리 사용 방식 프레임워크의 구조에 맞춰 코드를 작성하고, 확장 지점을 통해 기능 구현 필요한 기능만 선택적으로 가져와 호출 구조 제공 애플리케이션의 아키텍처 및 구성 방식을 정의 구조에 영향을 주지 않음 확장성 명확한 확장 포인트 제공 (예: Hook, 인터페이스 등) 함수 단위로 조합하여 사용 가능 유연성 프레임워크의 구조를 따르므로 상대적으로 유연성은 낮음 특정 기능 단위로 자유롭게 사용 가능 재사용성 특정 프레임워크에 종속적일 수 있음 다양한 프로젝트에서 재사용 가능함 예시 Spring, Angular, Django, React (의견 분분하지만 구조 제공 시 프레임워크로 분류되기도 함) Lodash, NumPy, jQuery, Requests 사용 시나리오 비교 구분 Framework Library 적합한 프로젝트 대규모, 복잡한 애플리케이션 특정 기능이 필요한 프로젝트 팀 규모 대규모 팀 (일관성 중요) 소규모 팀 (유연성 중요) 유지보수 프레임워크 업데이트에 의존 개별적으로 관리 가능 테스트 프레임워크 테스트 환경 사용 독립적인 단위 테스트 구조 및 아키텍처 Framework 아키텍처 graph TD A[Framework Core] --> B[Application Lifecycle] A --> C[Dependency Injection Container] A --> D[Configuration Management] A --> E[Plugin System] B --> F[Initialization] B --> G[Execution] B --> H[Cleanup] C --> I[Bean Factory] C --> J[Dependency Resolution] D --> K[XML/Annotation Config] D --> L[Environment Properties] E --> M[Extension Points] E --> N[Custom Components] F --> O[Developer Code] G --> O H --> O Framework 구성요소:
...</p></div><footer class=entry-footer><span title='2024-11-20 06:47:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Framework vs. Library" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/inversion-of-control/framework-vs.-library/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-engineering/data-pipeline-design/data-pipeline-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern vs. MVVC Pattern vs. MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 1 2 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles/layered-architecture/presentation-patterns/mvc/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>보안 코딩 (Secure Coding)</h2></header><div class=entry-content><p>보안 코딩 (Secure Coding) 아래는 요청하신 " 보안 코딩 (Secure Coding)" 주제에 대한 체계적이고 심층적인 분석입니다.
1. 적절한 태그 Secure-Coding Application-Security Software-Engineering Cyber-Security 2. 카테고리 계층 구조 분석 분류:
Computer Science and Engineering > Software Engineering > Software Engineering Foundations
근거 및 분석:
보안 코딩 (Secure Coding) 은 소프트웨어의 보안 취약점을 사전에 방지하는 실천법으로, 소프트웨어 공학 (Software Engineering) 의 핵심 원칙 중 하나입니다. 소프트웨어 공학은 소프트웨어 개발의 전체 생명주기 (Software Development Life Cycle, SDLC) 를 다루며, 그 안에 소프트웨어 공학 기초 (Software Engineering Foundations) 가 포함됩니다. 보안 코딩은 SDLC 전반에 걸쳐 적용되어야 하므로, 이 분류는 적절합니다 [1][2][3].
...</p></div><footer class=entry-footer><span title='2024-09-19 01:33:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;70 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보안 코딩 (Secure Coding)" href=https://buenhyden.github.io/posts/software-engineering/software-development/software-development-fundamentals/secure-coding/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/use-cases/industry-patterns/msa-pattern-comparison/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interface vs Abstract class</h2></header><div class=entry-content><p>Interface vs. Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.
모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.
이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.
추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.
일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 05:39:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interface vs Abstract class" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/object-oriented-programming/interface-vs-abstract-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Decompose by Business Capability vs Decompose by Subdomain</h2></header><div class=entry-content><p>Decompose by Business Capability vs. Decompose by Subdomain Decompose by Business Capability
정의: 비즈니스의 기능적 역량을 중심으로 시스템을 분해하는 방식으로, 조직의 주요 기능(예: 판매, 마케팅, 고객 서비스 등)에 따라 모듈을 나누는 방법. 특징: 비즈니스의 주요 역량을 중심으로 서비스나 모듈을 설계. 시스템의 경계가 기능적인 책임(Functional Responsibility)에 맞춰 설정됨. 기술적으로 독립적이고 명확한 책임 분리가 가능. 조직 구조와 자연스럽게 연계되므로 비즈니스와 IT의 연계성이 높아짐. 비즈니스의 장기적 확장성과 변화를 쉽게 수용할 수 있음. 예시: 주문 관리 시스템(Order Management System), 재고 관리 시스템(Inventory Management System) 등으로 분할. Decompose by Subdomain
...</p></div><footer class=entry-footer><span title='2024-11-13 01:13:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decompose by Business Capability vs Decompose by Subdomain" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles/distributed-architecture/microservices-architecture/service-decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GRASP vs. SOLID</h2></header><div class=entry-content><p>GRASP vs. SOLID GRASP 와 SOLID 는 상호 보완적인 객체지향 설계 원칙으로, GRASP 는 " 누가 무엇을 해야 하는가 " 에 대한 구체적인 책임 할당 패턴을 제공하고, SOLID 는 " 어떻게 설계해야 하는가 " 에 대한 포괄적인 설계 원칙을 제시한다. 두 원칙 모두 낮은 결합도, 높은 응집도, 확장성, 유지보수성을 목표로 하며, 현대 소프트웨어 개발에서 필수적인 설계 가이드라인이다.
핵심 개념 구분 항목 정의/설명 설계 목적 및 효과 GRASP 정의 객체지향 설계에서 책임 할당과 객체 간 협력을 효과적으로 하기 위한 9 가지 설계 패턴 세트 책임 분산, 구조적 안정성 확보, 결합도 최소화 핵심 패턴 - Information Expert
- Creator
- Controller
- Low Coupling
- High Cohesion
- Polymorphism
- Pure Fabrication
- Indirection
- Protected Variations 객체 간 책임 할당 원칙, 협력 방식 정의 주요 설계 방향 객체에 적절한 책임 부여, 변화에 강한 유연한 구조 설계 응집도 ↑, 결합도 ↓, 변경 영향 최소화 SOLID 정의 객체지향 설계에서 유지보수성과 확장성을 높이기 위한 5 가지 원칙을 나타내는 약어 확장 가능하고 견고한 소프트웨어 구조 확립 핵심 원칙 - SRP (단일 책임 원칙)
- OCP (개방 - 폐쇄 원칙)
- LSP (리스코프 치환 원칙)
- ISP (인터페이스 분리 원칙)
- DIP (의존 역전 원칙) 클래스와 모듈 단위의 구조 품질 향상 주요 설계 방향 변화에 유연한 클래스 설계, 테스트 용이성 강화, 인터페이스 기반 추상화 유지보수성 ↑, 재사용성 ↑, 확장성 ↑ GRASP vs. SOLID 비교 GRASP 와 SOLID 는 객체지향 설계에서 서로 다른 측면을 강조한다. GRASP 는 객체에 책임을 어떻게 할당할지를 중심으로 하며, SOLID 는 클래스 설계의 원칙을 통해 코드의 유연성과 유지보수성을 강조한다.
...</p></div><footer class=entry-footer><span title='2025-06-03 03:02:00 +0000 UTC'>June 3, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GRASP vs. SOLID" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/grasp/grasp-vs-solid/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)</h2></header><div class=entry-content><p>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming) 명령형 프로그래밍과 선언적 프로그래밍은 소프트웨어 개발에서 가장 기본적인 두 가지 프로그래밍 패러다임이다.
이들은 문제를 해결하는 접근 방식과 코드 작성 철학에서 근본적인 차이를 보인다.
명령형 프로그래밍과 선언적 프로그래밍은 서로 배타적이지 않으며, 각각 고유한 장점과 적합한 사용 사례가 있다.
현대 소프트웨어 개발에서는 두 패러다임을 상황에 맞게 적절히 조합하여 사용하는 것이 일반적이다.
명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다. 개발자로서 두 패러다임 모두를 이해하고 적절히 활용할 수 있다면, 다양한 문제 영역에서 효과적인 솔루션을 구축할 수 있을 것이다.
...</p></div><footer class=entry-footer><span title='2025-02-09 12:38:00 +0000 UTC'>February 9, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/imperative-programming/imperative-programming-vs-declarative-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hollywood Principle</h2></header><div class=entry-content><p>Hollywood Principle Hollywood Principle 은 객체지향 설계 및 프레임워크 설계에서 널리 쓰이는 원칙으로, “Don’t call us, we’ll call you” 라는 문구로 대표된다. 이 원칙은 저수준 (구현) 모듈이 고수준 (프레임워크, 추상화) 모듈을 직접 호출하는 것이 아니라, 고수준 모듈이 저수준 모듈을 필요할 때 호출하도록 구조를 설계한다. 이를 통해 의존성 부패 (Dependency Rot) 를 방지하고, 시스템의 유연성, 확장성, 테스트 용이성을 높인다. 대표적으로 Inversion of Control, Dependency Injection, Observer, Template Method, Strategy 패턴 등에서 적용된다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hollywood Principle" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/inversion-of-control/hollywood-principle/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/system-and-software-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>