<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>System-and-Software-Architecture on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/system-and-software-architecture/</link>
    <description>Recent content in System-and-Software-Architecture on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 05:43:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/system-and-software-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Architecture Principles</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/</link>
      <pubDate>Sat, 21 Dec 2024 05:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/</guid>
      <description>아키텍처 원칙은 소프트웨어 시스템의 품질, 지속 가능성, 적응성을 보장하기 위한 근본적인 지침과 규칙의 집합으로, SOLID, DRY, KISS와 같은 설계 원칙부터 클라우드 네이티브, 마이크로서비스 원칙까지 다양한 측면을 포괄한다. 이러한 원칙들은 비즈니스 목표와 기술적 제약 사이의 균형을 맞추며, 일관된 설계 결정과 효과적인 커뮤니케이션을 통해 복잡한 시스템의 성공적인 구현과 진화를 가능하게 한다.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/</guid>
      <description>SOLID 는 객체지향 설계의 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 으로, 소프트웨어의 유지보수성과 확장성을 높이고 코드의 품질을 개선한다. 각 원칙은 단일 책임, 확장성, 대체 가능성, 인터페이스 분리, 의존성 역전을 강조한다.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/</guid>
      <description>SOLID 는 객체지향 설계의 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 으로, 소프트웨어의 유지보수성과 확장성을 높이고 코드의 품질을 개선한다. 각 원칙은 단일 책임, 확장성, 대체 가능성, 인터페이스 분리, 의존성 역전을 강조한다.</description>
    </item>
    <item>
      <title>Clean Code</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/code-quality/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/code-quality/clean-code/</guid>
      <description>클린 코드는 읽기 쉽고, 이해와 유지보수가 용이한 코드를 작성하는 원칙과 기법을 의미한다. 명확한 네이밍, 단순화, 일관성, 중복 최소화, 테스트 가능성 등 다양한 원칙을 통해 소프트웨어 품질과 개발 생산성을 높이며, 협업과 장기적인 유지보수에 큰 이점을 제공한다.</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>Data Pipeline Pattern</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-pipeline-development/data-pipeline-patterns/</link>
      <pubDate>Tue, 19 Nov 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-pipeline-development/data-pipeline-patterns/</guid>
      <description>데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.</description>
    </item>
    <item>
      <title>DRY Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/dry/</link>
      <pubDate>Mon, 23 Sep 2024 00:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/dry/</guid>
      <description>DRY 원칙은 &amp;#34; 모든 지식이나 로직은 시스템 내에서 단일하고 명확하며 권위 있는 표현을 가져야 한다 &amp;#34; 는 소프트웨어 개발 원칙이다. 코드 중복을 제거하여 유지보수성과 일관성을 향상시키고, 오류 발생 가능성을 줄이며, 개발 효율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>보안 코딩 (Secure Coding)</title>
      <link>https://buenhyden.github.io/posts/security--compliance/application-security/secure-development/secure-coding/</link>
      <pubDate>Thu, 19 Sep 2024 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security--compliance/application-security/secure-development/secure-coding/</guid>
      <description>Secure Coding은 소프트웨어 개발 과정에서 보안 취약점을 최소화하고 안전한 소프트웨어를 만들기 위한 코딩 기법이다.</description>
    </item>
    <item>
      <title>YAGNI Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/</link>
      <pubDate>Mon, 23 Sep 2024 00:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/</guid>
      <description>YAGNI 는 &amp;#34;You Ain&amp;#39;t Gonna Need It&amp;#34; 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>Design Principles</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/</link>
      <pubDate>Thu, 29 May 2025 03:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/</guid>
      <description>Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다.</description>
    </item>
    <item>
      <title>Law of Demeter</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/law-of-demeter/</link>
      <pubDate>Tue, 04 Feb 2025 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/law-of-demeter/</guid>
      <description>Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 &amp;#39; 최소 지식의 원칙 &amp;#39; 이다.</description>
    </item>
    <item>
      <title>Inversion of Control</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/</link>
      <pubDate>Tue, 03 Jun 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/</guid>
      <description>Inversion of Control(제어의 역전) 은 소프트웨어 구성 요소 간 결합도를 낮추고, 제어 흐름을 외부 프레임워크나 컨테이너에 위임함으로써 유연성, 확장성, 테스트 용이성을 높이는 설계 원칙이다. 주로 의존성 주입 (Dependency Injection) 등으로 구현되며, 모듈화와 유지보수성 향상에 핵심적 역할을 한다.</description>
    </item>
    <item>
      <title>Decompose by Business Capability vs Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</guid>
      <description>Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.</description>
    </item>
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/dip/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/dip/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/dip/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/dip/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/isp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/isp/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/isp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/isp/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/lsp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/lsp/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/lsp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/lsp/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/ocp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/ocp/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/ocp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/ocp/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/srp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/srp/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/srp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/srp/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>Convention over Configuration</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/convention-over-configuration/</link>
      <pubDate>Sat, 31 May 2025 07:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/convention-over-configuration/</guid>
      <description>Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다.</description>
    </item>
    <item>
      <title>GRASP</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/</link>
      <pubDate>Fri, 30 May 2025 12:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/</guid>
      <description>GRASP 는 객체지향 설계에서 객체와 클래스에 책임을 효과적으로 할당하기 위한 9 가지 실용적 설계 원칙의 집합이다.  Information Expert, Creator, Controller, Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations 로 구성되어 있으며 각 원칙은 객체의 역할, 책임, 협력, 결합도, 응집도 등 시스템의 구조적 품질을 높이기 위해 사용된다.</description>
    </item>
    <item>
      <title>Cloud-Native Architecture</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/</link>
      <pubDate>Sun, 27 Apr 2025 07:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/</guid>
      <description>Cloud‑Native Architecture 는 컨테이너, 마이크로서비스, 자동화, 선언형 인터페이스를 이용해 클라우드의 유연성, 확장성, 관찰성, 복원력을 최대한 활용하는 현대 애플리케이션 설계 방식이다. 이를 통해 빠른 배포, 운영 자동화, 장애 복구, 비용 최적화를 지원한다.</description>
    </item>
    <item>
      <title>Serverless Architecture</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/</link>
      <pubDate>Wed, 19 Mar 2025 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/serverless/</guid>
      <description>Serverless Architecture 는 개발자가 인프라 관리 없이 코드 (함수) 를 클라우드에 배포하고, 이벤트 기반으로 자동 실행·확장하며 **비용 효율성**, **운영 오버헤드 감소**, **빠른 시장 출시**를 달성하는 클라우드 네이티브 구성이며, FaaS 와 BaaS 가 핵심이다.</description>
    </item>
    <item>
      <title>Primary Principles</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/</link>
      <pubDate>Wed, 19 Feb 2025 08:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/</guid>
      <description>객체 지향 프로그래밍의 기본 원칙은 캡슐화, 상속, 다형성, 추상화의 네 가지 핵심 원칙으로 구성된다. 이러한 원칙들은 코드의 재사용성, 확장성, 유지보수성을 높이고 복잡한 시스템을 객체 단위로 분리하여 개발을 용이하게 한다. 이 원칙들은 현대 소프트웨어 개발의 근간이 되며, 다양한 프로그래밍 언어에서 구현되어 사용된다.</description>
    </item>
    <item>
      <title>명령형 (Imperative) vs. 선언적 (Declarative) 프로그래밍</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-vs-declarative-programming/</link>
      <pubDate>Sun, 09 Feb 2025 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-vs-declarative-programming/</guid>
      <description>명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다.</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
    <item>
      <title>Program Against Abstractions</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/</guid>
      <description>Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다.</description>
    </item>
    <item>
      <title>Composition Over Inheritance</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/composition-over-inheritance/</link>
      <pubDate>Tue, 04 Feb 2025 14:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/composition-over-inheritance/</guid>
      <description>&amp;#34;Composition Over Inheritance&amp;#34; 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 &amp;#34;is-a&amp;#34; 관계보다 &amp;#34;has-a&amp;#34; 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.</description>
    </item>
    <item>
      <title>Encapsulate What Varies</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/encapsulate-what-varies/</link>
      <pubDate>Tue, 04 Feb 2025 14:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/encapsulate-what-varies/</guid>
      <description>Encapsulate What Varies(변하는 것을 캡슐화하라) 는 시스템에서 자주 변경되거나 확장될 가능성이 있는 부분을 별도의 모듈, 클래스, 인터페이스 등으로 분리해 관리하는 설계 원칙이다. 이를 통해 코드의 유연성, 유지보수성, 확장성을 효과적으로 높일 수 있다.</description>
    </item>
    <item>
      <title>Architectue Patterns</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/overview/architectue-pattern/</link>
      <pubDate>Sat, 21 Dec 2024 05:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/overview/architectue-pattern/</guid>
      <description>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</description>
    </item>
    <item>
      <title>Boundaries</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/monolithic-architecture/modular-monolithic/boundaries/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/monolithic-architecture/modular-monolithic/boundaries/</guid>
      <description>경계 (Boundaries) 는 소프트웨어 아키텍처에서 서로 다른 구성 요소 간의 분리선과 계약을 정의하는 핵심 원칙으로, 단일 책임 원칙과 느슨한 결합을 통해 시스템의 모듈성, 유지보수성, 확장성을 향상시키며, 도메인 주도 설계와 마이크로서비스 아키텍처에서 특히 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Component Principles</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/component-principles/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/component-principles/</guid>
      <description>컴포넌트 원칙 (Component Principles)은 소프트웨어를 재사용 가능하고 독립적으로 배포할 수 있는 단위로 분할하는 아키텍처 설계 지침이다. 주요 원칙은 재사용/릴리즈 동등성, 공통 폐쇄, 공통 재사용, 안정적 의존성, 안정적 추상화 등으로, 시스템의 유지보수성, 확장성, 품질을 크게 높인다.</description>
    </item>
    <item>
      <title>Coupling and Cohesion</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/quality-attributes/design-attributes/coupling-and-cohesion/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/quality-attributes/design-attributes/coupling-and-cohesion/</guid>
      <description>커플링과 응집도는 소프트웨어 모듈 간의 상호의존성 정도와 모듈 내부 요소들의 기능적 연관성을 측정하는 핵심 설계 원칙이다. 낮은 커플링과 높은 응집도를 통해 유지보수가 용이하고 확장 가능한 시스템을 구축할 수 있으며, 이는 모든 우수한 소프트웨어 아키텍처의 기반이 된다.</description>
    </item>
    <item>
      <title>Policy vs. Detail</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/policy-vs-detail/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/policy-vs-detail/</guid>
      <description>Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다.</description>
    </item>
    <item>
      <title>Cloud Native Principles</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/cloud-native-principles/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/cloud-native-principles/</guid>
      <description>클라우드 네이티브 원칙(Cloud Native Principles)는 클라우드 환경에서 애플리케이션을 설계하고 운영하는 핵심 원칙을 정의한다. 마이크로서비스, 컨테이너화, 불변 인프라, 선언적 API, 서비스 메시, 자동화 등을 통해 느슨하게 결합된 복원력 있는 시스템을 구현하여 비즈니스 민첩성과 운영 효율성을 극대화하는 아키텍처 접근법이다.</description>
    </item>
    <item>
      <title>Twelve-Factor App methodology</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/cloud-native-principles/12-factor-app/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/cloud-native-architecture/cloud-native-principles/12-factor-app/</guid>
      <description>Twelve-Factor App Methodology 는 클라우드 환경에서 확장 가능하고 유지보수하기 쉬운 애플리케이션을 개발하기 위한 12 가지 원칙을 제시한다. 이 원칙들은 코드베이스 관리, 구성 설정, 종속성 선언 등 다양한 측면을 포괄하며, 현대 소프트웨어 개발의 모범 사례로 널리 채택되고 있다.</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/security--compliance/application-security/api-security/api-gateway-security/api-keys/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security--compliance/application-security/api-security/api-gateway-security/api-keys/api-key-authentication/</guid>
      <description>API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/security--compliance/application-security/web-application-security/client-side-security/cors/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security--compliance/application-security/web-application-security/client-side-security/cors/cors/</guid>
      <description>CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.</description>
    </item>
    <item>
      <title>mTLS</title>
      <link>https://buenhyden.github.io/posts/security--compliance/infrastructure-security/network-security/secure-communications/mtls/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security--compliance/infrastructure-security/network-security/secure-communications/mtls/</guid>
      <description>클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/authentication-implementation/oauth-2.0/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/authentication-implementation/oauth-2.0/oauth2-oidc/</guid>
      <description>분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Secret Management</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/service-integration/configuration-management/secret-management/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/service-integration/configuration-management/secret-management/</guid>
      <description>민감한 자격 증명(API 키, 데이터베이스 비밀번호, 토큰 등)을 안전하게 저장, 관리, 배포하는 핵심 보안 메커니즘이다.</description>
    </item>
    <item>
      <title>Access Token</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-types/access-token/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-types/access-token/</guid>
      <description>Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다</description>
    </item>
    <item>
      <title>Bulkhead</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/bulkhead/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/bulkhead/</guid>
      <description>Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Fail Fast</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/fail-fast/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/fail-fast/</guid>
      <description>Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙</description>
    </item>
    <item>
      <title>Circuit Breaker</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/circuit-breaker/</link>
      <pubDate>Sun, 17 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/circuit-breaker/</guid>
      <description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Timeout Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/timeout/</link>
      <pubDate>Sun, 17 Nov 2024 02:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/fault-tolerance/timeout/</guid>
      <description>서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/retry/</link>
      <pubDate>Sun, 17 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/retry/</guid>
      <description>Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.</description>
    </item>
    <item>
      <title>Dead Letter Queue</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-reliability/dead-letter-queue-pattern/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-reliability/dead-letter-queue-pattern/</guid>
      <description>Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐</description>
    </item>
    <item>
      <title>Competing Consumers</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-endpoints/competing-consumers/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-endpoints/competing-consumers/</guid>
      <description>여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.</description>
    </item>
    <item>
      <title>Message Filter</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-routing/message-filter/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-routing/message-filter/</guid>
      <description>Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-processing/idempotent-processing/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-processing/idempotent-processing/idempotent-consumer/</guid>
      <description>Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다</description>
    </item>
    <item>
      <title>Aggregate Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/domain-modeling/domain-driven-design/aggregate/</link>
      <pubDate>Fri, 15 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/domain-modeling/domain-driven-design/aggregate/</guid>
      <description>Aggregate 패턴은 도메인 주도 설계(DDD)에서 유래한 개념으로, 관련된 객체들을 하나의 단위로 묶어 데이터 변경 시 일관성을 유지한다.</description>
    </item>
    <item>
      <title>3rd party registration</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/third-party-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/third-party-registration/</guid>
      <description>이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.</description>
    </item>
    <item>
      <title>Self registration</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/self-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/self-registration/</guid>
      <description>각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다</description>
    </item>
    <item>
      <title>Server-side discovery</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/server-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/server-side-discovery/</guid>
      <description>Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.</description>
    </item>
    <item>
      <title>Service registry</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/service-registry/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/service-registry/</guid>
      <description>각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스</description>
    </item>
    <item>
      <title>Client-side discovery</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/client-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/cross-cutting-concerns/service-discovery/discovery-patterns/client-side-discovery/</guid>
      <description>Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.</description>
    </item>
    <item>
      <title>Service deployment platform</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/infrastructure-management/service-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/infrastructure-management/service-deployment/</guid>
      <description>마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-vm/</guid>
      <description>각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/multiple-services-per-host/</guid>
      <description>하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다</description>
    </item>
    <item>
      <title>Service per Container</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/service-per-container/</guid>
      <description>각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/single-service-per-host/</guid>
      <description>각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/deployment-architecture/service-deployment-patterns/serverless-deployment/</guid>
      <description>Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다.</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/self-contained-service/</guid>
      <description>단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.  이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/service-per-team/</guid>
      <description>각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability/</guid>
      <description>이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-subdomain/</guid>
      <description>비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/service-integration/configuration-management/external-configuration-store/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/service-integration/configuration-management/external-configuration-store/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Publisher-Subscriber Pattern</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/event-driven/publish-subscribe/publish-subscribe/publisher-subscriber-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/event-driven/publish-subscribe/publish-subscribe/publisher-subscriber-pattern/</guid>
      <description>이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/retry/retry-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/retry/retry-pattern/</guid>
      <description>분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.</description>
    </item>
    <item>
      <title>Event Bus Pattern</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/event-driven/event-patterns/event-bus-pattern/event-bus-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/event-driven/event-patterns/event-bus-pattern/event-bus-pattern/</guid>
      <description>소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴</description>
    </item>
    <item>
      <title>Client Server Architecture</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/traditional-patterns/client-server/</link>
      <pubDate>Thu, 26 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/traditional-patterns/client-server/</guid>
      <description>Client‑Server Architecture 는 클라이언트가 요청 (request) 을 보내면 서버가 응답 (response) 하는 구조로, 역할과 책임을 분리하고 중앙화된 자원 관리, 보안성, 확장성을 제공한다. 웹, 데이터베이스, 이메일 시스템 등 대부분의 네트워크 기반 애플리케이션의 기본 모델이다.</description>
    </item>
    <item>
      <title>Access Modifiers</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/access-modifiers/</link>
      <pubDate>Mon, 23 Sep 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/access-modifiers/</guid>
      <description>객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다.</description>
    </item>
    <item>
      <title>KISS Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/kiss/</link>
      <pubDate>Mon, 23 Sep 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/kiss/</guid>
      <description>KISS(Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 불필요한 복잡성을 피하고, 가능한 한 단순하게 설계·구현하라는 설계 원칙이다. 이를 통해 코드의 가독성, 유지보수성, 확장성을 높이고, 오류 발생 가능성을 줄일 수 있다.</description>
    </item>
    <item>
      <title>다형성 (Polymorphism)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/</link>
      <pubDate>Sun, 22 Sep 2024 10:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/</guid>
      <description>다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, &amp;#34;여러 가지 형태를 가질 수 있는 능력&amp;#34;을 의미한다</description>
    </item>
    <item>
      <title>상속 (Inheritance)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/inheritance/</link>
      <pubDate>Sun, 22 Sep 2024 10:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/inheritance/</guid>
      <description>상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘</description>
    </item>
    <item>
      <title>객체 지향 프로그래밍 (Object-Oriented Programming)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/</guid>
      <description>객체 지향 프로그래밍 (Object-Oriented Programming, OOP) 은 실세계의 사물을 객체로 모델링하여 프로그램을 설계하는 방법론이다. 추상화, 캡슐화, 상속, 다형성이라는 네 가지 핵심 특징을 통해 코드의 재사용성과 유지보수성을 향상시키며, 대규모 소프트웨어 개발에 적합한 프로그래밍 패러다임이다.</description>
    </item>
    <item>
      <title>함수형 프로그래밍 (Functional Programming)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/declarative-paradigms/functional-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/declarative-paradigms/functional-programming/</guid>
      <description>프로그램을 순수 함수들의 조합으로 구성하는 방식</description>
    </item>
    <item>
      <title>명령형 프로그래밍(Imperative Programming)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/</link>
      <pubDate>Sun, 22 Sep 2024 08:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/</guid>
      <description>프로그램이 &amp;#39;어떻게&amp;#39; 작업을 수행해야 하는지를 명확하게 서술하는 프로그래밍 패러다임이다</description>
    </item>
    <item>
      <title>선언적 프로그래밍(Declarative Programming)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/declarative-paradigms/</link>
      <pubDate>Sun, 22 Sep 2024 08:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/declarative-paradigms/</guid>
      <description>계산의 로직을 표현하되, 그것이 어떻게 수행되는지에 대한 제어 흐름은 추상화한다.</description>
    </item>
    <item>
      <title>추상화 (Abstraction)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/abstraction/</link>
      <pubDate>Sun, 22 Sep 2024 06:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/abstraction/</guid>
      <description>추상화는 복잡한 시스템에서 핵심적인 개념이나 기능만을 모델링하고 불필요한 세부사항을 감추어 단순화하는 컴퓨터 과학의 근본 원리이다. 데이터 추상화, 절차 추상화, 제어 추상화로 구분되며, 복잡성 관리와 재사용성 향상을 통해 소프트웨어 개발의 생산성과 유지보수성을 크게 향상시킨다.</description>
    </item>
    <item>
      <title>Abstract Classes</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</guid>
      <description>추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다. 추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.</description>
    </item>
    <item>
      <title>Interfaces</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/interfaces/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/interfaces/</guid>
      <description>소프트웨어나 애플리케이션에서 인터페이스(Interface)는 두 개의 시스템, 프로그램, 장치 또는 구성 요소 간의 상호 작용을 가능하게 하는 연결점 또는 접점을 의미한다.</description>
    </item>
    <item>
      <title>오버라이딩(Overriding) vs. 오버로딩(Overloading)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/overriding-vs-overloading/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/overriding-vs-overloading/</guid>
      <description>오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 알아보고 비교 분석해보자.</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/</link>
      <pubDate>Sun, 22 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/</guid>
      <description>캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶고, 외부로부터 접근을 제한하는 것을 의미한다.</description>
    </item>
  </channel>
</rss>
