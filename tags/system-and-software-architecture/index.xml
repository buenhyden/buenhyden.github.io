<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>System-and-Software-Architecture on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/system-and-software-architecture/</link>
    <description>Recent content in System-and-Software-Architecture on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.157.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 03:02:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/system-and-software-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Clean Code</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/code-quality/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/code-quality/clean-code/</guid>
      <description>클린 코드는 읽기 쉽고, 이해와 유지보수가 용이한 코드를 작성하는 원칙과 기법을 의미한다. 명확한 네이밍, 단순화, 일관성, 중복 최소화, 테스트 가능성 등 다양한 원칙을 통해 소프트웨어 품질과 개발 생산성을 높이며, 협업과 장기적인 유지보수에 큰 이점을 제공한다.</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>Decompose by Business Capability vs Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</guid>
      <description>Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>명령형 (Imperative) vs. 선언적 (Declarative) 프로그래밍</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-vs-declarative-programming/</link>
      <pubDate>Sun, 09 Feb 2025 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-vs-declarative-programming/</guid>
      <description>명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다.</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
    <item>
      <title>Architectue Patterns</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture--design/overview/architectue-pattern/</link>
      <pubDate>Sat, 21 Dec 2024 05:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture--design/overview/architectue-pattern/</guid>
      <description>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/software-development/application-security/api-security/api-gateway-security/api-keys/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/application-security/api-security/api-gateway-security/api-keys/api-key-authentication/</guid>
      <description>API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/software-development/application-security/web-application-security/client-side-security/cors/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/application-security/web-application-security/client-side-security/cors/cors/</guid>
      <description>CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/oauth-2.x/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/oauth-2.x/oauth2-oidc/</guid>
      <description>분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-processing/idempotent-processing/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-processing/idempotent-processing/idempotent-consumer/</guid>
      <description>Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/service-per-vm/</guid>
      <description>각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/multiple-services-per-host/</guid>
      <description>하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다</description>
    </item>
    <item>
      <title>Service per Container</title>
      <link>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/service-per-container/</guid>
      <description>각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/single-service-per-host/</guid>
      <description>각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/deployment-architecture/service-deployment-patterns/serverless-deployment/</guid>
      <description>Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다.</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/self-contained-service/</guid>
      <description>단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.  이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/service-per-team/</guid>
      <description>각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-business-capability/</guid>
      <description>이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/architecture-styles/distributed-architecture/microservices/service-decomposition/decompose-by-subdomain/</guid>
      <description>비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/software-development/distributed-systems/service-integration/configuration-management/external-configuration-store/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/distributed-systems/service-integration/configuration-management/external-configuration-store/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Publisher-Subscriber Pattern</title>
      <link>https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/event-driven/publish-subscribe/publish-subscribe/publisher-subscriber-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/event-driven/publish-subscribe/publish-subscribe/publisher-subscriber-pattern/</guid>
      <description>이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-development/distributed-systems/reliability--resilience/recovery-patterns/retry/retry-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/distributed-systems/reliability--resilience/recovery-patterns/retry/retry-pattern/</guid>
      <description>분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.</description>
    </item>
    <item>
      <title>Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-processing/producer-consumer/producer-consumer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-processing/producer-consumer/producer-consumer-pattern/</guid>
      <description>이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.</description>
    </item>
    <item>
      <title>Event Bus Pattern</title>
      <link>https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/event-driven/event-patterns/event-bus-pattern/event-bus-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/event-driven/event-patterns/event-bus-pattern/event-bus-pattern/</guid>
      <description>소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴</description>
    </item>
    <item>
      <title>Access Modifiers</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/access-modifiers/</link>
      <pubDate>Mon, 23 Sep 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/access-modifiers/</guid>
      <description>객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다.</description>
    </item>
    <item>
      <title>Abstract Classes</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</guid>
      <description>추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다. 추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.</description>
    </item>
    <item>
      <title>Interfaces</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/interfaces/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/paradigm-features/interfaces/</guid>
      <description>소프트웨어나 애플리케이션에서 인터페이스(Interface)는 두 개의 시스템, 프로그램, 장치 또는 구성 요소 간의 상호 작용을 가능하게 하는 연결점 또는 접점을 의미한다.</description>
    </item>
    <item>
      <title>오버라이딩(Overriding) vs. 오버로딩(Overloading)</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/overriding-vs-overloading/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/overriding-vs-overloading/</guid>
      <description>오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 알아보고 비교 분석해보자.</description>
    </item>
  </channel>
</rss>
