<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System-and-Software-Architecture | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/system-and-software-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/system-and-software-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/system-and-software-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/system-and-software-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System-and-Software-Architecture"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System-and-Software-Architecture"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>System-and-Software-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth2/OIDC (OpenID Connect)</h2></header><div class=entry-content><p>OAuth2/OIDC (OpenID Connect) MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.
OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.
OAuth 2.0 OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth2/OIDC (OpenID Connect)" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/oauth2-oidc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Secret Management</h2></header><div class=entry-content><p>Secret Management Secret Management는 MSA(Microservices Architecture) 환경에서 민감한 자격 증명(API 키, 데이터베이스 비밀번호, 토큰 등)을 안전하게 저장, 관리, 배포하는 핵심 보안 메커니즘이다.
분산 시스템의 특성상 각 서비스가 독립적으로 동작하기 때문에 중앙 집중식 보안 관리가 필수적이다.
Secret Management는 MSA 보안의 핵심 인프라로, 올바른 도구 선택과 체계적인 정책 수립이 필수적이다.
2025년 현재 AI 기반 이상 탐지 기능이 도입되며, 지속적인 모니터링과 자동화가 강화되는 추세이다.
시크릿 관리의 중요성 보안 강화: 시크릿이 노출되면 악의적인 사용자가 시스템에 무단 접근하거나 데이터를 탈취할 수 있다. 규제 준수: 산업 표준과 규제는 민감한 정보의 안전한 관리를 요구한다. 운영 효율성: 중앙에서 시크릿을 관리하면 변경 시 각 서비스나 애플리케이션을 수정할 필요 없이 일괄적으로 업데이트할 수 있다. Secret Management의 핵심 기능 암호화 저장: 모든 비밀 정보는 AES-256 또는 **KMS(Key Management Service)**를 통해 암호화되어 저장된다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Secret Management" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/secret-management/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Access Token</h2></header><div class=entry-content><p>Access Token Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.
Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.
Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
Access Token의 특징 유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다. Stateless: 서버에 상태를 저장하지 않아 확장성이 높다. 암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다. 포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다. Access Token의 동작 방식 사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다. 토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지). 요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다. 서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다. Access Token의 장점 확장성: Stateless 특성으로 서버 확장이 용이하다. 보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다. 효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다. Access Token의 단점 토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다. 제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다. Access Token과 Refresh Token 보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-18 11:22:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Token" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/access-token/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache-Aside</h2></header><div class=entry-content><p>Cache-Aside Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.
Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.
이 패턴은 “Lazy Loading” 또는 “Look Aside” 패턴으로도 알려져 있다.
Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside
동작 방식 애플리케이션이 데이터를 요청한다. 캐시를 먼저 확인한다. 캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다. 캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다. 데이터베이스에서 가져온 데이터를 캐시에 저장한다. 데이터를 애플리케이션에 반환한다. 구현 시 고려사항 캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다. TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다. 캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다. 동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다. 장점 성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다. 데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다. 유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다. 장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다. 단점 초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다. 데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다. 추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다. 사용 예시 동시성 처리와 오류 복구를 포함한 버전
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache-Aside" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/caching-subsystems/caching-strategies-and-patterns/cache-aside/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fail Fast</h2></header><div class=entry-content><p>Fail Fast 아래는 Fail Fast Pattern에 대한 1~5 단계 정리입니다. 이후 단계도 반영 준비 완료되었어요!
1. 태그 (Tags) Fail-Fast-Pattern
Resilience-Patterns
Rapid-Failure-Detection
Defensive-Programming
2. 분류 구조 적절성 검토 “Fail Fast Pattern” 은 “Software Engineering > Design and Architecture > Architecture Patterns > Resilience Patterns” 안에 잘 맞습니다.
근거: 분산 시스템이나 모듈 내에서 오류가 발생하면 즉시 실패를 감지하고 전파하여, 지연 오류 (cascading failure) 와 상태 부정확성을 방지하는 탄력성 전략입니다 (blog.bernd-ruecker.com, arxiv.org, arxiv.org). 3. 요약 (200 자 내외) Fail Fast Pattern 은 시스템 내에서 예상치 못한 오류나 불일치 상태가 발생했을 때, 가능한 한 빨리 실패를 감지하고 처리하며 중단함으로써 오류 확산과 디버깅 어려움을 줄이는 소프트웨어 설계 원칙입니다. 초기 오류 발견과 명시적인 실패는 안정성과 유지보수성을 크게 높입니다 .
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fail Fast" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/fail-fast/fail-fast/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Timeout Pattern</h2></header><div class=entry-content><p>Timeout Pattern 아래는 “Timeout Pattern”에 대한 체계적이고 심층적인 조사, 분석, 정리입니다.
1. 태그 (Tag) Resilience-Pattern Latency-Control Distributed-Systems Fault-Tolerance 2. 분류 구조 적합성 분석 현재 분류 구조
1 2 3 4 5 Computer Science and Engineering └─ Software Engineering └─ Design and Architecture └─ Architecture Patterns └─ Resilience Patterns 분석 및 근거
Timeout Pattern은 시스템의 내결함성(resilience)과 신뢰성(reliability)을 높이기 위해 사용되는 설계 패턴으로, 주로 분산 시스템 및 마이크로서비스 환경에서 네트워크 지연, 서비스 장애 등에 대응하는 데 필수적입니다.
이 패턴은 “Architecture Patterns > Resilience Patterns”에 포함되어야 하며, “Software Engineering > Design and Architecture” 계층 아래에 위치하는 것이 적절합니다13.
따라서, 현재 분류 구조는 주제의 특성과 실무적 중요성 모두를 반영하고 있습니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 02:21:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Timeout Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/timeout/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dead Letter Queue</h2></header><div class=entry-content><p>Dead Letter Queue Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.
Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.
Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.
데드 레터 큐에 메시지가 전달되는 일반적인 상황 존재하지 않는 큐로의 메시지 전송: 메시지가 존재하지 않는 큐로 전송될 때. 큐의 최대 길이 초과: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때. 메시지 크기 제한 초과: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때. 메시지 만료: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때. 메시지 거부: 다른 큐나 교환기에 의해 메시지가 거부되었을 때. 과도한 재시도 실패: 메시지가 여러 번 처리되었지만 계속해서 실패할 때. DLQ의 주요 특징 분리 저장: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다. 재처리 가능성: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다. 시스템 안정성 향상: 문제가 있는 메시지로 인한 시스템 장애를 방지한다. 모니터링 및 알림: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다. DLQ 구현 방법 큐 생성: 일반 큐와 별도로 DLQ를 생성한다. 재시도 정책 설정: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다. DLQ 연결: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다. DLQ 활용 전략 분석 및 디버깅: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다. 자동 재처리: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다. 알림 설정: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다. 로깅 및 모니터링: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다. 주의사항 보존 기간 설정: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다. 보안: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다. 성능 영향: DLQ 처리로 인한 시스템 부하를 고려해야 한다. 데드 레터 큐를 지원하는 주요 메시징 시스템 Amazon SQS: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다. Apache Kafka: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다. RabbitMQ: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다. 구현 예시 Node.js와 RabbitMQ를 사용
...</p></div><footer class=entry-footer><span title='2024-11-15 12:10:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dead Letter Queue" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/message-channels/dead-letter-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Competing Consumers</h2></header><div class=entry-content><p>Competing Consumers Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.
Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.
작동 원리 메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다. 메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다. 경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다. 동작 방식 메시지 생산자(Producer): 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다. 메시지 큐(Message Queue): 게시된 메시지는 큐에 저장되어 대기한다. 메시지 소비자(Consumer): 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다. 이러한 구조를 통해 시스템은 작업 부하를 여러 소비자 인스턴스에 분산시켜 병목 현상을 방지하고, 동시 처리 능력을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Competing Consumers" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/message-endpoints/competing-consumers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Filter</h2></header><div class=entry-content><p>Message Filter Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.
Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.
주요 특징 단일 입력 채널과 단일 출력 채널을 가진다. 정의된 기준에 따라 메시지를 평가한다. 기준을 충족하는 메시지만 출력 채널로 전달한다. 기준을 충족하지 않는 메시지는 폐기된다. 구현 방법 필터 조건 정의: 메시지를 평가할 기준을 설정한다. 메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다. 메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다. 구현 방식 메시지 필터는 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Filter" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/message-routing/message-filter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Router</h2></header><div class=entry-content><p>Message Router Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.
Message Router는 MSA 환경에서 메시지 흐름을 효과적으로 관리하고 시스템의 유연성을 높이는 중요한 패턴이다. 적절히 구현하면 시스템의 확장성과 유지보수성을 크게 향상시킬 수 있다.
Message Router의 주요 특징 메시지 내용 기반 라우팅: 메시지의 페이로드나 헤더를 분석하여 라우팅 결정을 내린다. 동적 라우팅: 런타임에 라우팅 규칙을 변경할 수 있어 시스템의 유연성을 높인다. 다중 목적지 지원: 하나의 메시지를 여러 목적지로 라우팅할 수 있다. 메시지 변환: 필요에 따라 메시지 형식을 변환할 수 있다. Message Router의 종류 콘텐츠 기반 라우터: 메시지 내용을 분석하여 라우팅한다. 헤더 값 라우터: 메시지 헤더의 특정 값을 기준으로 라우팅한다. 수신자 목록 라우터: 미리 정의된 수신자 목록에 따라 메시지를 분배한다. 동적 라우터: 외부 조건이나 설정에 따라 라우팅 로직을 동적으로 변경한다. Message Router의 장점 유연성: 시스템 구성 요소 간의 결합도를 낮추어 유연성을 높인다. 확장성: 새로운 처리 로직이나 목적지를 쉽게 추가할 수 있다. 트래픽 관리: 메시지 흐름을 제어하여 시스템 부하를 관리할 수 있다. 비즈니스 로직 분리: 라우팅 로직을 중앙화하여 비즈니스 로직과 분리할 수 있다. 주의사항 복잡성 관리: 라우팅 규칙이 복잡해질수록 관리가 어려워질 수 있다. 성능 고려: 복잡한 라우팅 로직은 시스템 성능에 영향을 줄 수 있다. 오류 처리: 라우팅 실패 시의 오류 처리 전략이 필요하다. Message Router 구현 예시 Node.js를 사용한 Message Filter
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Router" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/message-routing/message-router/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/system-and-software-architecture/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/system-and-software-architecture/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>