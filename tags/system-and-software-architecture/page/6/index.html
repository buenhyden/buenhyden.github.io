<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System-and-Software-Architecture | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/system-and-software-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/system-and-software-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/system-and-software-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/system-and-software-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="System-and-Software-Architecture"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="System-and-Software-Architecture"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>System-and-Software-Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding) vs. 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩 (Overriding) vs. 오버로딩 (Overloading) 1. 주제 분류의 적절성 분석 " 오버라이딩 (Overriding) vs. 오버로딩 (Overloading)" 은 객체지향 프로그래밍 (Object-Oriented Programming, OOP) 에서 다형성 (polymorphism) 을 실현하는 핵심 개념입니다. 이 두 기능은 메서드의 재정의와 다중 정의를 통해 소프트웨어 아키텍처의 유연성과 확장성을 높이며, 시스템 및 소프트웨어 아키텍처의 원칙과 밀접하게 연관되어 있습니다. 따라서 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming” 분류는 매우 적절합니다 [1][7][19].
...</p></div><footer class=entry-footer><span title='2024-09-22 04:56:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding) vs. 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/overriding-vs-overloading/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Encapsulation</h2></header><div class=entry-content><p>캡슐화 (Encapsulation) 1. 주제의 분류 적절성 평가 캡슐화 (Encapsulation) 는 객체지향 프로그래밍 (Object-Oriented Programming, OOP) 의 4 대 핵심 원리 중 하나로, 복잡한 시스템을 단순화하고 구현 세부사항을 숨겨 인터페이스 중심의 설계를 가능하게 합니다. 이는 소프트웨어 아키텍처의 설계 원칙과 프로그래밍 패러다임 분류에 부합하며, 객체지향 프로그래밍 내에서 필수적인 개념이기 때문에 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming > Primary Principles” 분류는 매우 적절합니다.
...</p></div><footer class=entry-footer><span title='2024-09-22 02:26:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulation" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Architecture and System Design</h2></header><div class=entry-content><p>Architecture and System Design 소프트웨어 아키텍처와 시스템 아키텍처는 상호 보완적 관계에 있는 설계 개념이다. 시스템 아키텍처는 하드웨어, 네트워크, 소프트웨어 등 IT 시스템 전체의 구성요소와 상호작용을 통합적으로 설계하며, 소프트웨어 아키텍처는 소프트웨어 시스템의 구조, 컴포넌트, 인터페이스, 품질 속성에 집중한다. 설계 측면에서는 시스템 설계가 요구사항 분석 후 구체적인 시스템 사양을 결정하고, 소프트웨어 설계가 개별 모듈의 구현 세부사항을 다룬다. 이들은 상호 보완적으로 작용하여, 복잡한 IT 시스템의 품질, 확장성, 유지보수성, 효율성 확보에 필수적이다.
핵심 개념 개념 정의 주요 초점 설계 수준 관련 요소 시스템 아키텍처 (System Architecture) 전체 시스템의 구조, 상호작용, 데이터 흐름을 정의하는 고수준 설계 체계 성능, 신뢰성, 확장성, 통합성 고수준 하드웨어, 네트워크, 소프트웨어, UI 등 소프트웨어 아키텍처 (Software Architecture) 소프트웨어 시스템의 구조, 컴포넌트, 인터페이스, 품질 속성을 정의 유지보수성, 재사용성, 품질 고수준 모듈, 서비스, API, 데이터 흐름 등 시스템 설계 (System Design) 시스템 아키텍처를 바탕으로 구성 요소의 상세 설계 및 구현 방안 구성 요소 간 상호작용, 통신, 데이터 흐름 중수준~상세 DB 설계, 통신 방식, 데이터 경로 등 소프트웨어 설계 (Software Design) 소프트웨어 아키텍처 기반의 내부 상세 설계 (모듈, 함수 등) 구조화, 최적화, 코드 품질 상세 클래스, 알고리즘, 인터페이스 등 아키텍처 스타일 (Architecture Style) 시스템 구조를 규정하는 일반적인 구성 형태 구성요소 관계 정의 고수준 계층형, 이벤트 기반, 클라이언트 - 서버 등 아키텍처 패턴 (Architecture Pattern) 반복되는 아키텍처 문제의 일반적인 해결책 시스템 구조 설계 고수준 마이크로서비스, 헥사고날, SOA 등 설계 패턴 (Design Pattern) 코드 수준의 설계 문제에 대한 재사용 가능한 솔루션 모듈화, 유연성, 확장성 상세 싱글톤, 팩토리, 옵저버, 전략 등 품질 속성 (Quality Attributes) 성능, 보안, 확장성 등 비기능 요구사항 시스템 신뢰성과 품질 전반적 가용성, 응답시간, 유지보수성 등 graph TD %% 최상위 개념 SystemArchitecture["시스템 아키텍처 (System Architecture)"] SoftwareArchitecture["소프트웨어 아키텍처 (Software Architecture)"] %% 시스템 아키텍처와 소프트웨어 아키텍처의 관계 SystemArchitecture -->|포함| SoftwareArchitecture SystemArchitecture -->|구현 상세화| SystemDesign["시스템 설계 (System Design)"] SoftwareArchitecture -->|구현 상세화| SoftwareDesign["소프트웨어 설계 (Software Design)"] %% 아키텍처 스타일, 패턴, 설계 패턴 SoftwareArchitecture -->|구성 원리| ArchitectureStyle["아키텍처 스타일 (Architecture Style)"] SoftwareArchitecture -->|구성 원리| ArchitecturePattern["아키텍처 패턴 (Architecture Pattern)"] SoftwareDesign -->|구현 기법| DesignPattern["설계 패턴 (Design Pattern)"] %% 아키텍처 스타일과 패턴의 관계 ArchitectureStyle -->|구체화| ArchitecturePattern %% 설명 노드 classDef concept fill:#f9f,stroke:#333,stroke-width:1px; classDef relation fill:#fff,stroke:#333,stroke-width:1px,font-style:italic; class SystemArchitecture,SoftwareArchitecture,SystemDesign,SoftwareDesign,ArchitectureStyle,ArchitecturePattern,DesignPattern concept; 시스템 아키텍처는 시스템 전체의 구조와 원리를 정의하며, 그 하위에 소프트웨어 아키텍처가 있다. 시스템 설계는 시스템 아키텍처를 바탕으로 전체 시스템의 상세 구현 방안을 설계한다. 소프트웨어 설계는 소프트웨어 아키텍처를 바탕으로 소프트웨어 내부의 상세한 구현을 설계한다. 아키텍처 스타일은 소프트웨어 아키텍처의 구조적 특성을 정의하는 상위 개념이며, 여러 아키텍처 패턴을 포괄한다. 아키텍처 패턴은 소프트웨어 아키텍처의 구체적인 구조와 규칙을 제공한다. 설계 패턴은 소프트웨어 설계 단계에서 코드 수준의 반복적 문제를 해결하는 구체적 방법이다. 개요 소프트웨어 아키텍처와 시스템 아키텍처는 모두 시스템의 구조를 정의하지만, 그 범위와 초점에서 차이가 있다. 소프트웨어 아키텍처는 소프트웨어 시스템의 내부 구조와 구성 요소 간의 관계를 중점적으로 다루며, 시스템 아키텍처는 하드웨어, 소프트웨어, 네트워크 등 전체 시스템의 구성 요소와 그 관계를 포괄적으로 다룬다.
...</p></div><footer class=entry-footer><span title='2024-09-19 10:14:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Architecture and System Design" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-and-software-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/system-and-software-architecture/page/5/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>