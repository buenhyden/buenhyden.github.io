<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/til/2024/09/27/software-architecture-pattern-vs-software-design-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern vs Observer Pattern</h2></header><div class=entry-content><p>Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.
Mediator 패턴:
객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:
객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;453 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern vs Observer Pattern" href=https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/til/2024/09/25/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Factory Method Pattern</h2></header><div class=entry-content><p>Factory Method Pattern 객체 생성을 위한 인터페이스를 정의하지만, 실제 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정하도록 하는 디자인 패턴
객체 생성 로직을 캡슐화하여 코드의 유연성과 재사용성을 높이는데 도움을 준다.
특징 객체 생성을 서브클래스에 위임하여 결합도를 낮춘다. 부모 클래스에서 객체 생성을 위한 인터페이스를 제공하고, 서브클래스에서 구체적인 객체 생성을 담당한다. 클라이언트 코드와 구체적인 클래스 사이의 결합도를 낮춘다. 사용 사례 생성할 객체 타입을 예측할 수 없을 때 객체 생성의 책임을 서브클래스에 위임하고자 할 때 객체 생성 로직을 중앙화하여 코드 중복을 피하고자 할 때 실제 예:
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1036 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Factory Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/factory-method-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Singleton Pattern</h2></header><div class=entry-content><p>Singleton Pattern 클래스의 인스턴스가 프로그램 전체에서 오직 하나만 생성되도록 보장하는 소프트웨어 디자인 패턴.
공유 리소스나 전역 상태를 관리할 때 특히 유용하다.
특징 클래스는 자신의 유일한 인스턴스를 직접 관리합니다. 전역적인 접근점을 제공합니다. 인스턴스의 생성을 지연시킬 수 있습니다(lazy initialization). 생성자가 private이나 protected로 선언되어 외부에서 직접 인스턴스를 생성할 수 없습니다. 지연 초기화(lazy initialization) 객체의 생성이나 값의 계산 또는 비용이 많이 드는 프로세스를 필요한 시점까지 미루는 프로그래밍 기법
리소스를 많이 사용하는 객체나 초기화에 시간이 많이 걸리는 객체를 다룰 대 유용하다.
특정 프로그래밍 패
사용 사례:
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2292 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Singleton Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/singleton-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Flyweight Pattern</h2></header><div class=entry-content><p>Flyweight Pattern Flyweight 패턴은 구조적 디자인 패턴 중 하나로, 객체를 공유하여 메모리 사용을 최소화하는 패턴이다.
플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.
간단히 말하면 캐시(Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성(extrinsic)과 변하지 않는 속성(intrinsic)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.
Flyweight 패턴의 주요 구성 요소 Flyweight: 경량 객체를 묶는 인터페이스. ConcreteFlyweight: 공유 가능하여 재사용되는 객체로, intrinsic state를 포함한다. UnsahredConcreteFlyweight: 공유 불가능한 객체로, extrinsic state를 포함한다. FlyweightFactory: 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스. Client: FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다. Flyweight 패턴의 동작 방식 FlyweightFactory는 Flyweight 객체들을 생성하고 관리한다. GetFlyweight() 메서드는 팩토리 메서드 역할을 한다. 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다. Flyweight 패턴의 장점 많은 객체를 만들 때 성능을 향상시킬 수 있다. 많은 객체를 만들 때 메모리를 줄일 수 있다. 메모리 절약: 대규모 객체 시스템에서 상당한 메모리 절감 효과를 얻을 수 있다. 중복 최소화: 공유를 통해 객체의 중복 생성을 방지한다. Flyweight 패턴의 단점 특정 인스턴스를 다르게 처리하는 것이 힘들어진다. 코드 복잡성 증가: 객체를 공유하는 방식은 구현을 복잡하게 만들 수 있다. 런타임 비용: 객체 상태를 관리하는 데 런타임 비용이 발생할 수 있다. Flyweight 패턴의 사용 시기 대량의 작은 객체를 생성해야 할 때 유용하다. 객체의 상태를 자주 변하는 속성(Extrinsic)과 변하지 않는 속성(Intrinsic)으로 분리할 수 있을 때 적합하다. 공통된 내재 상태를 공유함으로써 메모리 사용을 줄일 수 있을 때 사용한다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Dict # Flyweight 클래스: 공유될 객체의 내부 상태를 정의 class CharacterStyle: def __init__(self, font_name: str, font_size: int, bold: bool): self.font_name = font_name self.font_size = font_size self.bold = bold def render(self, char: str, position: tuple) -> None: print(f"Rendering '{char}' at {position} with {self.font_name}, " f"size {self.font_size}, {'bold' if self.bold else 'normal'}") # Flyweight 팩토리: Flyweight 객체들을 관리하고 공유 class CharacterStyleFactory: def __init__(self): self._styles: Dict[str, CharacterStyle] = {} def get_style(self, font_name: str, font_size: int, bold: bool) -> CharacterStyle: # 스타일을 식별하기 위한 키 생성 key = f"{font_name}-{font_size}-{bold}" # 스타일이 존재하지 않으면 새로 생성 if key not in self._styles: self._styles[key] = CharacterStyle(font_name, font_size, bold) print(f"Creating new style: {key}") return self._styles[key] def get_style_count(self) -> int: return len(self._styles) # 문자 객체: Flyweight를 사용하는 클래스 class Character: def __init__(self, char: str, style: CharacterStyle, position: tuple): self.char = char # 외부 상태 (extrinsic state) self.style = style # 공유 상태 (intrinsic state) self.position = position # 외부 상태 def render(self) -> None: self.style.render(self.char, self.position) 실제 사용 예시
...</p></div><footer class=entry-footer><span title='2024-09-25 08:25:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;776 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flyweight Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/flyweight-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Composite Pattern</h2></header><div class=entry-content><p>Composite Pattern Composite Pattern은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴이다.
Composite Pattern은 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층 구조를 만든다. 이 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 동일하게 다룰 수 있다.
Composite Pattern은 복잡한 트리 구조를 간단하게 다룰 수 있게 해주는 강력한 도구이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 요구사항과 구조를 고려하여 적절히 사용해야 한다.
주요 구성 요소 Composite Pattern은 다음과 같은 주요 구성 요소로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:24:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;718 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composite Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/composite-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Bridge Pattern</h2></header><div class=entry-content><p>Bridge Pattern 복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴
TV 제조사가 다양하고(구현), 리모컨의 종류도 다양(추상화)하지만, 이들은 서로 독립적으로 발전하면서도 함께 잘 동작할 수 있다.
특징 추상화와 구현을 두 개의 독립적인 클래스 계층으로 분리합니다. 구현부에 대한 참조를 통해 추상화와 구현을 연결합니다. 런타임에 구현을 교체할 수 있는 유연성을 제공합니다. 사용사례 그래픽 시스템에서 다양한 플랫폼(Windows, macOS, Linux)에서 동작하는 다양한 도형(원, 사각형, 삼각형)을 그려야 할 때 여러 데이터베이스 시스템과 연동되는 다양한 타입의 로깅 시스템을 구현할 때 다양한 디바이스에서 실행되는 여러 종류의 사용자 인터페이스를 개발할 때 여러 종류의 메시지(이메일, SMS, 푸시알림)를 다양한 포맷(HTML, 텍스트, JSON)으로 전송해야 할 때 장점 추상화와 구현의 분리로 인한 높은 유연성과 확장성을 제공합니다. 새로운 추상화나 구현을 추가할 때 기존 코드를 수정하지 않아도 됩니다. 각 계층이 독립적으로 발전할 수 있어 시스템의 진화가 용이합니다. 구현 세부사항을 클라이언트로부터 숨길 수 있습니다. 단점 추상화와 구현 사이에 간접 계층이 추가되어 복잡도가 증가할 수 있습니다. 설계 초기에 브리지 패턴을 적용하지 않으면 나중에 리팩터링하기 어려울 수 있습니다. 작은 규모의 시스템에서는 오버엔지니어링이 될 수 있습니다. 주의사항 및 고려사항 브리지 패턴을 적용하기 전에 시스템이 정말로 이러한 유연성을 필요로 하는지 검토해야 합니다. 추상화와 구현 계층 사이의 의존성을 최소화하도록 인터페이스를 설계해야 합니다. 각 계층의 책임 범위를 명확히 정의하고, 단일 책임 원칙을 지키도록 해야 합니다. 성능에 민감한 시스템에서는 추가되는 간접 계층으로 인한 오버헤드를 고려해야 합니다. 브리지 패턴은 초기 설계 단계에서 적용하는 것이 가장 효과적입니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod # Implementation interface class MessageSender(ABC): @abstractmethod def send(self, message: str, recipient: str) -> bool: pass # Concrete implementations class EmailSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending email to {recipient}") print(f"Email content: {message}") return True class SMSSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending SMS to {recipient}") print(f"SMS content: {message}") return True class PushNotificationSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending push notification to device {recipient}") print(f"Notification content: {message}") return True # Abstraction class Message(ABC): def __init__(self, sender: MessageSender): self.sender = sender @abstractmethod def send(self, recipient: str) -> bool: pass # Refined Abstractions class SimpleMessage(Message): def __init__(self, sender: MessageSender, content: str): super().__init__(sender) self.content = content def send(self, recipient: str) -> bool: return self.sender.send(self.content, recipient) class HTMLMessage(Message): def __init__(self, sender: MessageSender, html_content: str): super().__init__(sender) self.html_content = html_content def send(self, recipient: str) -> bool: formatted_content = f"&lt;html>&lt;body>{self.html_content}&lt;/body>&lt;/html>" return self.sender.send(formatted_content, recipient) class EncryptedMessage(Message): def __init__(self, sender: MessageSender, content: str, encryption_key: str): super().__init__(sender) self.content = content self.encryption_key = encryption_key def send(self, recipient: str) -> bool: # Simulate encryption encrypted_content = f"ENCRYPTED[{self.content}] WITH KEY {self.encryption_key}" return self.sender.send(encrypted_content, recipient) # Message Factory for convenience class MessageFactory: @staticmethod def create_simple_message(sender: MessageSender, content: str) -> SimpleMessage: return SimpleMessage(sender, content) @staticmethod def create_html_message(sender: MessageSender, html_content: str) -> HTMLMessage: return HTMLMessage(sender, html_content) @staticmethod def create_encrypted_message( sender: MessageSender, content: str, key: str ) -> EncryptedMessage: return EncryptedMessage(sender, content, key) # Usage example if __name__ == "__main__": # Create senders email_sender = EmailSender() sms_sender = SMSSender() push_sender = PushNotificationSender() # Create message factory factory = MessageFactory() # Create and send different types of messages using different senders simple_email = factory.create_simple_message( email_sender, "Hello from Python!" ) simple_email.send("user@example.com") html_email = factory.create_html_message( email_sender, "&lt;h1>Hello&lt;/h1>&lt;p>This is HTML email&lt;/p>" ) html_email.send("user@example.com") encrypted_sms = factory.create_encrypted_message( sms_sender, "Secret message", "encryption_key_123" ) encrypted_sms.send("+1234567890") simple_push = factory.create_simple_message( push_sender, "New notification!" ) simple_push.send("device_token_123") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // Implementation interface class LogStorage { save(logEntry) { throw new Error('save method must be implemented'); } retrieve(id) { throw new Error('retrieve method must be implemented'); } } // Concrete implementations class FileLogStorage extends LogStorage { constructor(filepath) { super(); this.filepath = filepath; this.logs = new Map(); console.log(`Initializing File Storage at ${filepath}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to file: ${this.filepath}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class DatabaseLogStorage extends LogStorage { constructor(connectionString) { super(); this.connectionString = connectionString; this.logs = new Map(); console.log(`Connecting to database: ${connectionString}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to database: ${this.connectionString}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class CloudLogStorage extends LogStorage { constructor(cloudProvider, region) { super(); this.cloudProvider = cloudProvider; this.region = region; this.logs = new Map(); console.log(`Connecting to ${cloudProvider} in ${region}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to ${this.cloudProvider} cloud storage in ${this.region}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } // Abstraction class Logger { constructor(storage) { this.storage = storage; } log(message) { throw new Error('log method must be implemented'); } getLog(id) { return this.storage.retrieve(id); } } // Refined Abstractions class SimpleLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO' }; return this.storage.save(entry); } } class DetailedLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO', processId: process.pid, hostname: require('os').hostname(), memory: process.memoryUsage() }; return this.storage.save(entry); } } class SecurityLogger extends Logger { constructor(storage, encryptionKey) { super(storage); this.encryptionKey = encryptionKey; } log(message) { const entry = { timestamp: new Date().toISOString(), message: this.encrypt(message), level: 'SECURE', encryptionVersion: '1.0' }; return this.storage.save(entry); } encrypt(message) { // Simulate encryption return `ENCRYPTED[${message}] WITH KEY ${this.encryptionKey}`; } } // Usage example // Create different storage implementations const fileStorage = new FileLogStorage('/var/log/app.log'); const dbStorage = new DatabaseLogStorage('mongodb://localhost:27017/logs'); const cloudStorage = new CloudLogStorage('AWS', 'us-east-1'); // Create different types of loggers with different storage backends const simpleFileLogger = new SimpleLogger(fileStorage); const detailedDbLogger = new DetailedLogger(dbStorage); const secureCloudLogger = new SecurityLogger(cloudStorage, 'secret-key-123'); // Use the loggers const fileLogId = simpleFileLogger.log('Simple file log message'); console.log('Retrieved file log:', simpleFileLogger.getLog(fileLogId)); const dbLogId = detailedDbLogger.log('Detailed database log message'); console.log('Retrieved database log:', detailedDbLogger.getLog(dbLogId)); const cloudLogId = secureCloudLogger.log('Secure cloud log message'); console.log('Retrieved cloud log:', secureCloudLogger.getLog(cloudLogId)); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bridge Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/bridge-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Decorator Pattern</h2></header><div class=entry-content><p>Decorator Pattern 객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴
“래퍼(wrapper)” 개념으로 각 데코레이터는 원본 객체를 감싸면서 추가 기능을 제공한다.
여러 데코레이터를 겹겹이 쌓을 수 있으며, 각 계층은 이전 계층의 기능을 확장한다.
특징 기존 객체의 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 상속 대신 구성(composition)을 사용하여 객체의 기능을 확장합니다. 객체를 여러 데코레이터로 감싸 기능을 조합할 수 있습니다. 사용사례 파일 입출력 시스템에서 압축, 암호화, 버퍼링 등의 기능을 조합할 때 웹 서비스에서 로깅, 캐싱, 인증 등의 기능을 동적으로 추가할 때 GUI 컴포넌트에 테두리, 스크롤바, 색상 등의 시각적 요소를 조합할 때 게임 캐릭터에 아이템, 버프, 상태 효과 등을 적용할 때 장점 객체의 기능을 동적으로 확장할 수 있어 매우 유연합니다. 단일 책임 원칙을 지키면서 기능을 조합할 수 있습니다. 상속을 통한 확장보다 더 유연한 방식을 제공합니다. 런타임에 객체의 행동을 변경할 수 있습니다. 단점 데코레이터를 너무 많이 사용하면 코드가 복잡해질 수 있습니다. 데코레이터들의 순서가 결과에 영향을 미칠 수 있어 주의가 필요합니다. 작은 객체들이 많이 생성되어 코드를 이해하기 어려울 수 있습니다. 주의사항 및 고려사항 데코레이터의 순서를 신중하게 고려해야 합니다. 예를 들어, 텍스트 처리에서 HTML 이스케이프를 마크다운 변환 전에 하면 원하는 결과를 얻을 수 없습니다. 데코레이터 체인이 너무 길어지지 않도록 주의해야 합니다. 필요한 경우 자주 사용되는 조합을 별도의 클래스로 만드는 것을 고려하세요. 데코레이터들 간의 상호작용을 고려해야 합니다. 한 데코레이터의 출력이 다른 데코레이터의 입력으로 적절한지 확인해야 합니다. 성능에 민감한 상황에서는 데코레이터 체인으로 인한 오버헤드를 고려해야 합니다. 디버깅이 어려울 수 있으므로, 로깅이나 모니터링 기능을 추가하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 from abc import ABC, abstractmethod from typing import List # Component interface class Coffee(ABC): """Base Coffee interface""" @abstractmethod def get_cost(self) -> float: pass @abstractmethod def get_ingredients(self) -> List[str]: pass @abstractmethod def get_description(self) -> str: pass # Concrete component class SimpleCoffee(Coffee): """Basic coffee implementation""" def get_cost(self) -> float: return 2.0 def get_ingredients(self) -> List[str]: return ["Coffee"] def get_description(self) -> str: return "Simple coffee" # Base decorator class CoffeeDecorator(Coffee): """Base decorator class""" def __init__(self, coffee: Coffee): self._coffee = coffee def get_cost(self) -> float: return self._coffee.get_cost() def get_ingredients(self) -> List[str]: return self._coffee.get_ingredients() def get_description(self) -> str: return self._coffee.get_description() # Concrete decorators class MilkDecorator(CoffeeDecorator): """Adds milk to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.5 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Milk"] def get_description(self) -> str: return f"{super().get_description()}, with steamed milk" class WhipDecorator(CoffeeDecorator): """Adds whipped cream to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.7 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Whipped Cream"] def get_description(self) -> str: return f"{super().get_description()}, topped with whipped cream" class CaramelDecorator(CoffeeDecorator): """Adds caramel to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.6 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Caramel"] def get_description(self) -> str: return f"{super().get_description()}, drizzled with caramel" class ExtraShotDecorator(CoffeeDecorator): """Adds an extra shot of espresso""" def get_cost(self) -> float: return super().get_cost() + 1.0 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Extra Espresso Shot"] def get_description(self) -> str: return f"{super().get_description()}, with an extra shot" # Order management class CoffeeOrder: """Manages coffee orders and provides order summary""" def __init__(self): self.coffee = None def create_order(self) -> None: """Creates a new coffee order starting with simple coffee""" self.coffee = SimpleCoffee() def add_milk(self) -> None: self.coffee = MilkDecorator(self.coffee) def add_whip(self) -> None: self.coffee = WhipDecorator(self.coffee) def add_caramel(self) -> None: self.coffee = CaramelDecorator(self.coffee) def add_extra_shot(self) -> None: self.coffee = ExtraShotDecorator(self.coffee) def get_order_summary(self) -> str: """Generates a summary of the current order""" return f""" Order Summary: Description: {self.coffee.get_description()} Ingredients: {', '.join(self.coffee.get_ingredients())} Total Cost: ${self.coffee.get_cost():f} """ # Usage example if __name__ == "__main__": # Create a new order order = CoffeeOrder() order.create_order() # Customize the coffee with various additions order.add_milk() order.add_extra_shot() order.add_whip() order.add_caramel() # Print the order summary print(order.get_order_summary()) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // Component interface class TextProcessor { constructor() { if (this.constructor === TextProcessor) { throw new Error("Abstract class cannot be instantiated"); } } process(text) { throw new Error("Method 'process' must be implemented"); } } // Concrete component class SimpleTextProcessor extends TextProcessor { process(text) { return text; } } // Base decorator class TextProcessorDecorator extends TextProcessor { constructor(processor) { super(); this._processor = processor; } process(text) { return this._processor.process(text); } } // Concrete decorators class CapitalizeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.toUpperCase(); } } class TrimDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.trim(); } } class HTMLEscapeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/&/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/>/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); } } class MarkdownToHTMLDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/\*\*(.*?)\*\*/g, '&lt;strong>$1&lt;/strong>') .replace(/\*(.*?)\*/g, '&lt;em>$1&lt;/em>') .replace(/\[(.*?)\]\((.*?)\)/g, '&lt;a href="$2">$1&lt;/a>') .replace(/^# (.*$)/gm, '&lt;h1>$1&lt;/h1>') .replace(/^## (.*$)/gm, '&lt;h2>$1&lt;/h2>'); } } class ValidationDecorator extends TextProcessorDecorator { constructor(processor, maxLength = 1000) { super(processor); this.maxLength = maxLength; } process(text) { if (!text) { throw new Error("Text cannot be empty"); } if (text.length > this.maxLength) { throw new Error(`Text length exceeds maximum limit of ${this.maxLength} characters`); } return this._processor.process(text); } } // Text processing manager class TextProcessingManager { constructor() { this.processor = new SimpleTextProcessor(); this.history = []; } addCapitalization() { this.processor = new CapitalizeDecorator(this.processor); return this; } addTrimming() { this.processor = new TrimDecorator(this.processor); return this; } addHTMLEscaping() { this.processor = new HTMLEscapeDecorator(this.processor); return this; } addMarkdownProcessing() { this.processor = new MarkdownToHTMLDecorator(this.processor); return this; } addValidation(maxLength) { this.processor = new ValidationDecorator(this.processor, maxLength); return this; } process(text) { const result = this.processor.process(text); this.history.push({ input: text, output: result, timestamp: new Date() }); return result; } getProcessingHistory() { return this.history; } } // Usage example const manager = new TextProcessingManager(); // Configure text processing chain manager .addValidation(2000) .addTrimming() .addMarkdownProcessing() .addHTMLEscaping(); // Process some text try { const input = ` # Welcome to Text Processing This is a **bold** and *italic* text example. [Click here](https://example.com) to learn more. `; const result = manager.process(input); console.log("Processed text:"); console.log(result); console.log("\nProcessing history:"); console.log(manager.getProcessingHistory()); } catch (error) { console.error("Error processing text:", error.message); } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1240 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decorator Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/decorator-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Facade Pattern</h2></header><div class=entry-content><p>Facade Pattern 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조적 디자인 패턴
TV, 오디오, 조명 등 복잡한 홈시어터 시스템이 있을 때, 리모컨 하나로 이 모든 것을 간단히 제어할 수 있게 해주는 것처럼, 퍼사드 패턴은 복잡한 시스템을 간단한 인터페이스로 감싸주는 패턴
특징 복잡한 서브시스템을 감싸는 단순한 인터페이스를 제공합니다. 클라이언트와 서브시스템 간의 결합도를 낮춥니다. 고수준 인터페이스를 정의하여 서브시스템을 더 쉽게 사용할 수 있게 합니다. 사용사례 복잡한 라이브러리나 프레임워크를 간단하게 사용해야 할 때 레거시 코드를 새로운 인터페이스로 감싸야 할 때 서브시스템을 계층화할 때 장점 결합도 감소: 클라이언트는 복잡한 서브시스템 대신 Facade와만 상호작용하므로, 시스템 간의 결합도가 낮아집니다. 코드 가독성 향상: 복잡한 로직을 Facade 뒤로 숨김으로써 클라이언트 코드가 더 깔끔하고 이해하기 쉬워집니다. 유지보수성 증가: 서브시스템의 변경이 Facade 내부에 국한되므로, 클라이언트 코드를 수정할 필요가 없어집니다. 계층화된 구조: 복잡한 시스템을 계층화하여 관리할 수 있게 해줍니다. 단점 Facade 클래스가 과도한 책임을 지게 될 수 있습니다. 성능 저하가 발생할 수 있습니다. 서브시스템의 모든 기능을 사용할 수 없을 수 있습니다. 주의사항 및 고려사항 인터페이스 설계: Facade의 인터페이스는 가능한 한 단순하고 직관적이어야 합니다. 위 예제에서처럼 복잡한 프로세스를 하나의 메서드로 단순화하는 것이 좋습니다. 의존성 관리: Facade는 서브시스템 컴포넌트들과의 의존성을 잘 관리해야 합니다. 필요한 경우 의존성 주입을 사용하여 유연성을 확보할 수 있습니다. 테스트 용이성: Facade 패턴을 사용하면 복잡한 시스템을 테스트하기가 더 쉬워집니다. 단일 진입점을 통해 전체 시스템을 테스트할 수 있기 때문입니다. 확장성: 시스템이 발전함에 따라 새로운 기능을 추가해야 할 수 있습니다. Facade는 이러한 변화를 수용할 수 있도록 설계되어야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 복잡한 서브시스템 클래스들 class VideoFile: def __init__(self, filename): self.filename = filename self.codec = self.detect_codec() def detect_codec(self): return self.filename.split(".")[1] class CompressionCodec: def __init__(self, type): self.type = type class MPEG4CompressionCodec(CompressionCodec): def __init__(self): super().__init__("mp4") class OGGCompressionCodec(CompressionCodec): def __init__(self): super().__init__("ogg") class CodecFactory: @staticmethod def extract_codec(file): type = file.codec if type == "mp4": return MPEG4CompressionCodec() else: return OGGCompressionCodec() class BitrateReader: @staticmethod def read(filename, codec): print(f"BitrateReader: reading file {filename} with codec {codec.type}") return f"video_data_{filename}" @staticmethod def convert(buffer, codec): print(f"BitrateReader: writing file with codec {codec.type}") return f"converted_data_{buffer}" # Facade 클래스 class VideoConverter: def convert(self, filename, target_format): video_file = VideoFile(filename) source_codec = CodecFactory.extract_codec(video_file) if target_format == "mp4": destination_codec = MPEG4CompressionCodec() else: destination_codec = OGGCompressionCodec() buffer = BitrateReader.read(filename, source_codec) result = BitrateReader.convert(buffer, destination_codec) return result # 클라이언트 코드 def main(): converter = VideoConverter() mp4 = converter.convert("funny-cats.ogg", "mp4") print(f"VideoConverter: conversion completed -> {mp4}") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 복잡한 서브시스템 클래스들 class VideoFile { constructor(filename) { this.filename = filename; this.codec = this.detectCodec(); } detectCodec() { return this.filename.split(".")[1]; } } class CompressionCodec { constructor(type) { this.type = type; } } class MPEG4CompressionCodec extends CompressionCodec { constructor() { super("mp4"); } } class OGGCompressionCodec extends CompressionCodec { constructor() { super("ogg"); } } class CodecFactory { static extractCodec(file) { const type = file.codec; if (type === "mp4") { return new MPEG4CompressionCodec(); } return new OGGCompressionCodec(); } } class BitrateReader { static read(filename, codec) { console.log(`BitrateReader: reading file ${filename} with codec ${codec.type}`); return `video_data_${filename}`; } static convert(buffer, codec) { console.log(`BitrateReader: writing file with codec ${codec.type}`); return `converted_data_${buffer}`; } } // Facade 클래스 class VideoConverter { convert(filename, targetFormat) { const videoFile = new VideoFile(filename); const sourceCodec = CodecFactory.extractCodec(videoFile); const destinationCodec = targetFormat === "mp4" ? new MPEG4CompressionCodec() : new OGGCompressionCodec(); const buffer = BitrateReader.read(filename, sourceCodec); const result = BitrateReader.convert(buffer, destinationCodec); return result; } } // 클라이언트 코드 function main() { const converter = new VideoConverter(); const mp4 = converter.convert("funny-cats.ogg", "mp4"); console.log(`VideoConverter: conversion completed -> ${mp4}`); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;684 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Facade Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/facade-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/software-design-patterns/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>