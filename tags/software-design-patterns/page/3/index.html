<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Design-Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Design-Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Design-Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Design-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>State Pattern</h2></header><div class=entry-content><p>State Pattern 객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴
상태별 동작을 별도의 클래스로 분리하고, 현재 상태를 나타내는 객체에게 행동을 위임하는 것
특징 객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다. 상태 전이를 명시적으로 표현합니다. 각 상태를 별도의 클래스로 캡슐화합니다. 유한 상태 기계(Finite-State Machine)의 개념과 유사합니다. 사용사례 문서 처리 시스템: 문서가 초안, 검토 중, 승인됨, 게시됨 등의 상태를 가지며 각 상태에서 허용되는 작업이 다릅니다. 주문 처리 시스템: 주문이 생성됨, 결제 완료, 배송 중, 배송 완료 등의 상태를 거치며, 각 상태에서 가능한 작업이 달라집니다. 게임 캐릭터: 캐릭터가 서있음, 걷기, 달리기, 점프 등 다양한 상태를 가지며, 각 상태에서의 동작이 다릅니다. 네트워크 연결: 연결 중, 연결됨, 연결 끊김 등의 상태에 따라 다른 동작을 수행합니다. 장점 상태별 동작의 명확한 분리: 각 상태의 동작이 별도의 클래스로 캡슐화되어 코드의 구조가 명확해집니다. 상태 전환 로직의 체계화: 상태 전환이 명시적으로 이루어지며, 각 상태 클래스에서 가능한 전환을 정의할 수 있습니다. 새로운 상태 추가의 용이성: 기존 코드를 수정하지 않고도 새로운 상태를 추가할 수 있어 개방-폐쇄 원칙을 만족합니다. 단점 클래스 수의 증가: 각 상태마다 새로운 클래스가 필요하므로 클래스 수가 많아질 수 있습니다. 상태 전환 로직의 복잡성: 상태 간의 전환이 복잡할 경우 관리가 어려워질 수 있습니다. Context와 State 간의 결합: State 클래스들이 Context를 참조해야 하는 경우가 있어 결합도가 높아질 수 있습니다. 주의사항 및 고려사항 상태 전환의 일관성: 상태 전환이 일관되게 이루어지도록 주의해야 하며, 잘못된 전환을 방지해야 합니다. 메모리 관리: 상태 객체들을 적절히 재사용하거나 관리하지 않으면 메모리 사용량이 증가할 수 있습니다. 순환 참조 방지: Context와 State 간의 순환 참조가 발생하지 않도록 주의해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from abc import ABC, abstractmethod # State 인터페이스 class MediaPlayerState(ABC): @abstractmethod def play(self, player) -> None: pass @abstractmethod def pause(self, player) -> None: pass @abstractmethod def stop(self, player) -> None: pass @abstractmethod def get_state_name(self) -> str: pass # 구체적인 State 클래스들 class PlayingState(MediaPlayerState): def play(self, player) -> None: print("이미 재생 중입니다.") def pause(self, player) -> None: print("재생을 일시정지합니다.") player.change_state(PausedState()) def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "재생 중" class PausedState(MediaPlayerState): def play(self, player) -> None: print("재생을 재개합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("이미 일시정지 상태입니다.") def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "일시정지" class StoppedState(MediaPlayerState): def play(self, player) -> None: print("재생을 시작합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("중지 상태에서는 일시정지할 수 없습니다.") def stop(self, player) -> None: print("이미 중지 상태입니다.") def get_state_name(self) -> str: return "중지됨" # Context 클래스 class MediaPlayer: def __init__(self): # 초기 상태는 중지 상태 self._state = StoppedState() print(f"미디어 플레이어가 {self._state.get_state_name()} 상태로 시작됩니다.") def change_state(self, state: MediaPlayerState) -> None: self._state = state print(f"상태가 {self._state.get_state_name()}(으)로 변경되었습니다.") def play(self) -> None: self._state.play(self) def pause(self) -> None: self._state.pause(self) def stop(self) -> None: self._state.stop(self) # 사용 예시 def main(): player = MediaPlayer() # 재생 시작 player.play() # 중지 -> 재생 # 일시정지 player.pause() # 재생 -> 일시정지 # 재생 재개 player.play() # 일시정지 -> 재생 # 중지 player.stop() # 재생 -> 중지 # 일시정지 시도 (중지 상태에서는 불가능) player.pause() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // State 인터페이스 interface OrderState { processPayment(order: Order): void; shipOrder(order: Order): void; cancelOrder(order: Order): void; getStateName(): string; } // 구체적인 State 클래스들 class PendingState implements OrderState { processPayment(order: Order): void { console.log("결제를 진행합니다."); order.changeState(new PaidState()); } shipOrder(order: Order): void { console.log("결제가 필요합니다. 배송을 시작할 수 없습니다."); } cancelOrder(order: Order): void { console.log("주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 대기"; } } class PaidState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("배송을 시작합니다."); order.changeState(new ShippedState()); } cancelOrder(order: Order): void { console.log("결제가 환불되었습니다. 주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 완료"; } } class ShippedState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("이미 배송 중입니다."); } cancelOrder(order: Order): void { console.log("배송이 시작된 주문은 취소할 수 없습니다."); } getStateName(): string { return "배송 중"; } } class CancelledState implements OrderState { processPayment(order: Order): void { console.log("취소된 주문은 결제할 수 없습니다."); } shipOrder(order: Order): void { console.log("취소된 주문은 배송할 수 없습니다."); } cancelOrder(order: Order): void { console.log("이미 취소된 주문입니다."); } getStateName(): string { return "주문 취소"; } } // Context 클래스 class Order { private state: OrderState; private readonly orderId: string; constructor(orderId: string) { this.orderId = orderId; this.state = new PendingState(); console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 생성되었습니다.`); } public changeState(state: OrderState): void { this.state = state; console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 변경되었습니다.`); } public processPayment(): void { this.state.processPayment(this); } public shipOrder(): void { this.state.shipOrder(this); } public cancelOrder(): void { this.state.cancelOrder(this); } } // 사용 예시 function main() { const order = new Order("ORD-2024-001"); // 정상적인 주문 프로세스 console.log("\n=== 정상적인 주문 프로세스 ==="); order.processPayment(); // 결제 대기 -> 결제 완료 order.shipOrder(); // 결제 완료 -> 배송 중 // 취소된 주문 시나리오 console.log("\n=== 취소된 주문 시나리오 ==="); const cancelledOrder = new Order("ORD-2024-002"); cancelledOrder.cancelOrder(); // 결제 대기 -> 취소됨 cancelledOrder.processPayment(); // 결제 시도 (실패) cancelledOrder.shipOrder(); // 배송 시도 (실패) } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:17:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1040 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/state-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Strategy Pattern</h2></header><div class=entry-content><p>Strategy Pattern 알고리즘의 집합을 정의하고, 각각을 캡슐화하여 교환 가능하게 만드는 행동 디자인 패턴
알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.
특징 알고리즘 집합을 정의하고 각각을 별도의 클래스로 캡슐화합니다. 런타임에 알고리즘을 동적으로 교체할 수 있습니다. 컨텍스트 클래스가 전략 객체에 작업을 위임합니다. 세 가지 주요 구성 요소로 이루어진다.
Context(문맥): 전략을 사용하는 클래스로, 클라이언트가 전략을 지정할 수 있는 인터페이스를 제공합니다. Strategy(전략): 지원하는 모든 알고리즘에 대한 공통 인터페이스를 정의합니다. Concrete Strategies(구체적 전략): Strategy 인터페이스의 구체적인 구현체들입니다. 사용사례 결제 시스템: 신용카드, 페이팔, 은행 이체 등 다양한 결제 방식을 처리할 때 각각을 전략으로 구현합니다. 데이터 압축: 다양한 압축 알고리즘(ZIP, RAR, 7Z 등)을 전략으로 구현하여 상황에 따라 적절한 압축 방식을 선택합니다. 텍스트 포매팅: 마크다운, HTML, 일반 텍스트 등 다양한 출력 형식을 전략으로 구현합니다. 정렬 알고리즘: 퀵정렬, 병합정렬, 버블정렬 등 다양한 정렬 알고리즘을 상황에 따라 선택적으로 사용합니다. 장점 알고리즘의 재사용성: 동일한 알고리즘을 다양한 컨텍스트에서 재사용할 수 있습니다. 런타임 시 알고리즘 교체: 프로그램 실행 중에도 알고리즘을 동적으로 변경할 수 있습니다. 코드 중복 감소: 유사한 알고리즘들의 공통 부분을 하나의 클래스로 관리할 수 있습니다. 확장성: 새로운 전략을 추가하기 쉽습니다. 단점 클래스 수 증가: 각 전략마다 새로운 클래스가 필요하므로 클래스 수가 증가합니다. 클라이언트의 전략 인지: 클라이언트가 서로 다른 전략의 차이점을 이해해야 합니다. 오버헤드: 간단한 알고리즘의 경우 패턴 사용으로 인한 복잡도 증가가 있을 수 있습니다. 주의사항 및 고려사항 전략 선택의 기준: 언제 어떤 전략을 사용할지에 대한 명확한 기준이 필요합니다. 전략 간 데이터 공유: 전략들 간에 공유해야 하는 데이터가 있다면 이를 효율적으로 관리해야 합니다. 불필요한 복잡성 회피: 단순한 조건문으로 해결될 수 있는 상황에서는 Strategy Pattern을 사용하지 않는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from abc import ABC, abstractmethod from typing import List, Dict # Strategy 인터페이스 class ExportStrategy(ABC): @abstractmethod def export_data(self, data: List[Dict]) -> str: pass # Concrete Strategy 클래스들 class JSONExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: import json return json.dumps(data, indent=2) class CSVExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: import csv from io import StringIO output = StringIO() if not data: return "" writer = csv.DictWriter(output, fieldnames=data[0].keys()) writer.writeheader() writer.writerows(data) return output.getvalue() class XMLExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: def dict_to_xml(d: Dict, indent: str = "") -> str: xml = [] for key, value in d.items(): if isinstance(value, dict): xml.append(f"{indent}&lt;{key}>") xml.append(dict_to_xml(value, indent + " ")) xml.append(f"{indent}&lt;/{key}>") else: xml.append(f"{indent}&lt;{key}>{value}&lt;/{key}>") return "\n".join(xml) xml_lines = ['&lt;?xml version="1.0" encoding="UTF-8"?>', "&lt;data>"] for item in data: xml_lines.append(" &lt;item>") xml_lines.append(dict_to_xml(item, " ")) xml_lines.append(" &lt;/item>") xml_lines.append("&lt;/data>") return "\n".join(xml_lines) # Context 클래스 class DataExporter: def __init__(self, export_strategy: ExportStrategy): self._strategy = export_strategy def set_strategy(self, export_strategy: ExportStrategy): self._strategy = export_strategy def export(self, data: List[Dict]) -> str: return self._strategy.export_data(data) # 사용 예시 def main(): # 테스트 데이터 data = [ {"id": 1, "name": "John Doe", "email": "john@example.com"}, {"id": 2, "name": "Jane Smith", "email": "jane@example.com"} ] # 각각의 전략으로 데이터 내보내기 exporter = DataExporter(JSONExporter()) print("JSON 형식으로 내보내기:") print(exporter.export(data)) print("\n" + "="*50 + "\n") exporter.set_strategy(CSVExporter()) print("CSV 형식으로 내보내기:") print(exporter.export(data)) print("\n" + "="*50 + "\n") exporter.set_strategy(XMLExporter()) print("XML 형식으로 내보내기:") print(exporter.export(data)) if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 // Strategy 인터페이스 interface PaymentStrategy { pay(amount: number): void; validate(): boolean; } // Concrete Strategy 클래스들 class CreditCardPayment implements PaymentStrategy { private readonly cardNumber: string; private readonly cardHolder: string; private readonly expiryDate: string; private readonly cvv: string; constructor(cardNumber: string, cardHolder: string, expiryDate: string, cvv: string) { this.cardNumber = cardNumber; this.cardHolder = cardHolder; this.expiryDate = expiryDate; this.cvv = cvv; } pay(amount: number): void { if (this.validate()) { console.log(`신용카드로 ${amount}원을 결제합니다.`); console.log(`카드 번호: ${this.maskCardNumber()}`); console.log(`카드 소유자: ${this.cardHolder}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidCardNumber = this.cardNumber.length === 16; const isValidCVV = this.cvv.length === 3; if (!isValidCardNumber) { console.log("잘못된 카드 번호입니다."); return false; } if (!isValidCVV) { console.log("잘못된 CVV입니다."); return false; } return true; } private maskCardNumber(): string { return this.cardNumber.slice(-4).padStart(16, '*'); } } class PayPalPayment implements PaymentStrategy { private readonly email: string; private readonly password: string; constructor(email: string, password: string) { this.email = email; this.password = password; } pay(amount: number): void { if (this.validate()) { console.log(`PayPal로 ${amount}원을 결제합니다.`); console.log(`PayPal 계정: ${this.email}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidEmail = this.email.includes('@'); const isValidPassword = this.password.length >= 8; if (!isValidEmail) { console.log("잘못된 이메일 형식입니다."); return false; } if (!isValidPassword) { console.log("비밀번호는 8자 이상이어야 합니다."); return false; } return true; } } class BankTransferPayment implements PaymentStrategy { private readonly bankCode: string; private readonly accountNumber: string; private readonly accountHolder: string; constructor(bankCode: string, accountNumber: string, accountHolder: string) { this.bankCode = bankCode; this.accountNumber = accountNumber; this.accountHolder = accountHolder; } pay(amount: number): void { if (this.validate()) { console.log(`계좌이체로 ${amount}원을 결제합니다.`); console.log(`은행 코드: ${this.bankCode}`); console.log(`계좌 번호: ${this.maskAccountNumber()}`); console.log(`예금주: ${this.accountHolder}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidBankCode = this.bankCode.length === 3; const isValidAccountNumber = this.accountNumber.length >= 10; if (!isValidBankCode) { console.log("잘못된 은행 코드입니다."); return false; } if (!isValidAccountNumber) { console.log("잘못된 계좌번호입니다."); return false; } return true; } private maskAccountNumber(): string { return this.accountNumber.slice(-4).padStart(this.accountNumber.length, '*'); } } // Context 클래스 class PaymentProcessor { private strategy: PaymentStrategy; constructor(strategy: PaymentStrategy) { this.strategy = strategy; } setStrategy(strategy: PaymentStrategy): void { this.strategy = strategy; } processPayment(amount: number): void { this.strategy.pay(amount); } } // 사용 예시 function main() { // 결제 프로세서 생성 (초기 전략: 신용카드) const processor = new PaymentProcessor( new CreditCardPayment("1234567890123456", "John Doe", "12/25", "123") ); console.log("=== 신용카드 결제 ==="); processor.processPayment(50000); console.log("\n=== PayPal 결제로 변경 ==="); processor.setStrategy( new PayPalPayment("john@example.com", "password123") ); processor.processPayment(30000); console.log("\n=== 계좌이체로 변경 ==="); processor.setStrategy( new BankTransferPayment("002", "1234567890", "John Doe") ); processor.processPayment(100000); // 잘못된 데이터로 결제 시도 console.log("\n=== 잘못된 신용카드 정보로 결제 시도 ==="); processor.setStrategy( new CreditCardPayment("123", "John Doe", "12/25", "12") ); processor.processPayment(50000); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:17:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1159 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strategy Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/strategy-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Template Method Pattern</h2></header><div class=entry-content><p>Template Method Pattern 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴
특징 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 합니다. 공통 로직은 상위 클래스에서 정의하고, 변화가 필요한 부분만 하위 클래스에서 구현합니다. 알고리즘의 구조를 변경하지 않고 특정 단계를 재정의할 수 있습니다. 두 가지 주요 부분으로 구성된다.
추상 클래스(Abstract Class): 알고리즘의 골격을 정의하는 템플릿 메서드를 포함 서브클래스에서 구현해야 하는 추상 메서드 정의 선택적으로 오버라이드할 수 있는 훅(hook) 메서드 제공 구체 클래스(Concrete Class): 추상 클래스를 상속받아 추상 메서드를 실제로 구현 필요한 경우 훅 메서드를 오버라이드하여 알고리즘을 커스터마이즈 사용사례 프레임워크에서 기본 동작을 정의하고 사용자가 일부를 커스터마이즈해야 할 때 데이터 마이닝 작업에서 데이터 처리 파이프라인을 구현할 때 리포트 생성 시스템에서 다양한 형식의 리포트를 생성할 때 장점 코드 재사용성이 높아집니다 알고리즘의 공통 부분을 한 곳에서 관리할 수 있습니다 확장성이 좋아 새로운 변형을 쉽게 추가할 수 있습니다 단점 템플릿 메소드가 복잡해질수록 유지보수가 어려워질 수 있습니다 하위 클래스에서 상위 클래스의 메소드를 실수로 오버라이드할 수 있습니다 알고리즘 단계가 많아지면 클래스 계층 구조가 복잡해질 수 있습니다 주의사항 및 고려사항 템플릿 메소드는 final로 선언하여 하위 클래스가 override하지 못하도록 해야 합니다. Python에서는 관례적으로 메소드 이름 앞에 언더스코어를 붙여 protected임을 나타냅니다. 추상 메소드(반드시 구현해야 하는 메소드)와 훅 메소드(선택적으로 구현할 수 있는 메소드)를 명확히 구분해야 합니다. 상속 계층이 깊어지지 않도록 주의해야 합니다. 일반적으로 추상 클래스와 구체 클래스의 2단계 정도가 적절합니다. 템플릿 메소드가 너무 많은 단계를 가지지 않도록 해야 합니다. 복잡한 알고리즘은 더 작은 단위로 분리하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from abc import ABC, abstractmethod class DataMiner(ABC): """데이터 마이닝을 위한 템플릿 메소드 패턴 구현""" def mine_data(self, path: str) -> None: """템플릿 메소드: 데이터 마이닝의 전체 프로세스를 정의""" raw_data = self._read_file(path) cleaned_data = self._clean_data(raw_data) analyzed_data = self._analyze_data(cleaned_data) self._send_report(analyzed_data) @abstractmethod def _read_file(self, path: str) -> list: """파일을 읽어오는 추상 메소드""" pass def _clean_data(self, data: list) -> list: """데이터 정제를 위한 훅 메소드""" return data @abstractmethod def _analyze_data(self, data: list) -> dict: """데이터 분석을 위한 추상 메소드""" pass def _send_report(self, data: dict) -> None: """분석 결과 보고를 위한 훅 메소드""" print("기본 보고서 생성:", data) class PDFDataMiner(DataMiner): """PDF 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"PDF 파일 읽기: {path}") return ["PDF 데이터 1", "PDF 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "PDF", "results": data} def _clean_data(self, data: list) -> list: # PDF 특화 데이터 정제 로직 return [item.strip() for item in data] class CSVDataMiner(DataMiner): """CSV 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"CSV 파일 읽기: {path}") return ["CSV 데이터 1", "CSV 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "CSV", "results": data} # 사용 예시 if __name__ == "__main__": pdf_miner = PDFDataMiner() csv_miner = CSVDataMiner() pdf_miner.mine_data("sample.pdf") csv_miner.mine_data("sample.csv") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BeverageMaker { /** * 음료 제조를 위한 템플릿 메소드 * @returns {void} */ prepare() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } this.serve(); } /** * 물을 끓이는 공통 메소드 * @private */ boilWater() { console.log('물을 끓입니다'); } /** * 음료를 우리는 추상 메소드 * @abstract * @private */ brew() { throw new Error('brew 메소드를 구현해야 합니다'); } /** * 컵에 따르는 공통 메소드 * @private */ pourInCup() { console.log('컵에 따릅니다'); } /** * 고객이 첨가물을 원하는지 확인하는 훅 메소드 * @returns {boolean} */ customerWantsCondiments() { return true; } /** * 첨가물을 추가하는 추상 메소드 * @abstract * @private */ addCondiments() { throw new Error('addCondiments 메소드를 구현해야 합니다'); } /** * 음료를 서빙하는 공통 메소드 * @private */ serve() { console.log('음료가 준비되었습니다'); } } class CoffeeMaker extends BeverageMaker { brew() { console.log('커피를 우립니다'); } addCondiments() { console.log('설탕과 우유를 추가합니다'); } customerWantsCondiments() { // 고객 선호도에 따라 첨가물 추가 여부 결정 return Math.random() > 0.5; } } class TeaMaker extends BeverageMaker { brew() { console.log('차를 우립니다'); } addCondiments() { console.log('레몬을 추가합니다'); } } // 사용 예시 const coffee = new CoffeeMaker(); const tea = new TeaMaker(); console.log('=== 커피 준비 ==='); coffee.prepare(); console.log('\n=== 차 준비 ==='); tea.prepare(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:17:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;786 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Template Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/template-method-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Observer Pattern</h2></header><div class=entry-content><p>Observer Pattern 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
특징 객체 간 일대다 관계를 정의합니다. 주체(Subject)와 관찰자(Observer)로 구성됩니다. 느슨한 결합을 제공하여 유연성을 높입니다. 발행/구독 모델로도 알려져 있습니다. 두 가지 인터페이스로 이루어진다.
Subject
Observer들을 등록(attach)하고 제거(detach)할 수 있으며, 상태 변경 시 모든 Observer에게 알림을 보낸다. Observer
Subject로부터 받은 알림을 처리하는 update 메서드를 구현 사용사례 이벤트 처리 시스템: GUI 애플리케이션에서 버튼 클릭이나 키보드 입력 등의 이벤트 처리 뉴스 구독 서비스: 새로운 뉴스가 발행되면 구독자들에게 알림 소셜 미디어 피드: 새로운 게시물이 등록되면 팔로워들에게 알림 주식 시장 모니터링: 주식 가격 변동을 실시간으로 관심 있는 투자자들에게 알림 장점 느슨한 결합(Loose Coupling): Subject와 Observer는 서로의 구체적인 구현을 알 필요가 없음 유연한 객체 관계: 실행 시점에 동적으로 Observer를 추가하거나 제거 가능 개방-폐쇄 원칙(OCP) 준수: 기존 코드 수정 없이 새로운 Observer 추가 가능 단점 순서 보장의 어려움: 다수의 Observer에게 알림이 전달될 때 실행 순서 보장이 어려움 메모리 누수 가능성: Observer 해제를 제대로 하지 않으면 메모리 누수 발생 위험 복잡성 증가: Observer가 많아질수록 디버깅과 테스트가 어려워질 수 있음 주의사항 및 고려사항 순환 참조 방지: Observer가 Subject를 다시 업데이트하는 순환 참조 상황 주의 메모리 관리: Observer 등록 해제를 확실히 처리 상태 일관성 유지: 다수의 Observer가 있을 때 상태 일관성 보장 비동기 처리 고려: 많은 Observer가 있을 경우 비동기 처리 검토 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from abc import ABC, abstractmethod from typing import List # Observer 인터페이스 class NewsObserver(ABC): @abstractmethod def update(self, news: str) -> None: pass # Subject(Observable) 클래스 class NewsAgency: def __init__(self): self._observers: List[NewsObserver] = [] self._latest_news: str = "" def attach(self, observer: NewsObserver) -> None: if observer not in self._observers: self._observers.append(observer) def detach(self, observer: NewsObserver) -> None: self._observers.remove(observer) def notify_observers(self) -> None: for observer in self._observers: observer.update(self._latest_news) def publish_news(self, news: str) -> None: self._latest_news = news self.notify_observers() # Concrete Observer 클래스들 class NewsChannel(NewsObserver): def __init__(self, name: str): self.name = name def update(self, news: str) -> None: print(f"{self.name} received news: {news}") class NewsApp(NewsObserver): def __init__(self, app_name: str): self.app_name = app_name def update(self, news: str) -> None: print(f"{self.app_name} pushing notification: {news}") # 사용 예시 def main(): # Subject 생성 news_agency = NewsAgency() # Observer 생성 bbc = NewsChannel("BBC") cnn = NewsChannel("CNN") news_app = NewsApp("Breaking News App") # Observer 등록 news_agency.attach(bbc) news_agency.attach(cnn) news_agency.attach(news_app) # 뉴스 발행 news_agency.publish_news("Breaking: Major tech breakthrough announced!") # Observer 제거 news_agency.detach(cnn) # 새로운 뉴스 발행 news_agency.publish_news("Update: More details on tech breakthrough…") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Observer 인터페이스 (TypeScript 스타일) interface WeatherObserver { update(temperature: number, humidity: number): void; } // Subject(Observable) 클래스 class WeatherStation { private observers: WeatherObserver[] = []; private temperature: number = 0; private humidity: number = 0; public attach(observer: WeatherObserver): void { const isExist = this.observers.includes(observer); if (!isExist) { this.observers.push(observer); } } public detach(observer: WeatherObserver): void { const observerIndex = this.observers.indexOf(observer); if (observerIndex !== -1) { this.observers.splice(observerIndex, 1); } } public notify(): void { for (const observer of this.observers) { observer.update(this.temperature, this.humidity); } } public setMeasurements(temperature: number, humidity: number): void { this.temperature = temperature; this.humidity = humidity; this.notify(); } } // Concrete Observer 클래스들 class WeatherDisplay implements WeatherObserver { private name: string; constructor(name: string) { this.name = name; } public update(temperature: number, humidity: number): void { console.log( `${this.name} Display: Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } class WeatherLogger implements WeatherObserver { public update(temperature: number, humidity: number): void { console.log( `Logging - Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } // 사용 예시 function main() { // Subject 생성 const weatherStation = new WeatherStation(); // Observer 생성 const phoneDisplay = new WeatherDisplay("Phone"); const tabletDisplay = new WeatherDisplay("Tablet"); const logger = new WeatherLogger(); // Observer 등록 weatherStation.attach(phoneDisplay); weatherStation.attach(tabletDisplay); weatherStation.attach(logger); // 날씨 정보 업데이트 console.log("First weather update:"); weatherStation.setMeasurements(24, 65); // Observer 제거 weatherStation.detach(tabletDisplay); // 새로운 날씨 정보 업데이트 console.log("\nSecond weather update:"); weatherStation.setMeasurements(27, 70); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-13 06:16:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;779 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/observer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Bridge Pattern</h2></header><div class=entry-content><p>Bridge Pattern 복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴
TV 제조사가 다양하고(구현), 리모컨의 종류도 다양(추상화)하지만, 이들은 서로 독립적으로 발전하면서도 함께 잘 동작할 수 있다.
특징 추상화와 구현을 두 개의 독립적인 클래스 계층으로 분리합니다. 구현부에 대한 참조를 통해 추상화와 구현을 연결합니다. 런타임에 구현을 교체할 수 있는 유연성을 제공합니다. 사용사례 그래픽 시스템에서 다양한 플랫폼(Windows, macOS, Linux)에서 동작하는 다양한 도형(원, 사각형, 삼각형)을 그려야 할 때 여러 데이터베이스 시스템과 연동되는 다양한 타입의 로깅 시스템을 구현할 때 다양한 디바이스에서 실행되는 여러 종류의 사용자 인터페이스를 개발할 때 여러 종류의 메시지(이메일, SMS, 푸시알림)를 다양한 포맷(HTML, 텍스트, JSON)으로 전송해야 할 때 장점 추상화와 구현의 분리로 인한 높은 유연성과 확장성을 제공합니다. 새로운 추상화나 구현을 추가할 때 기존 코드를 수정하지 않아도 됩니다. 각 계층이 독립적으로 발전할 수 있어 시스템의 진화가 용이합니다. 구현 세부사항을 클라이언트로부터 숨길 수 있습니다. 단점 추상화와 구현 사이에 간접 계층이 추가되어 복잡도가 증가할 수 있습니다. 설계 초기에 브리지 패턴을 적용하지 않으면 나중에 리팩터링하기 어려울 수 있습니다. 작은 규모의 시스템에서는 오버엔지니어링이 될 수 있습니다. 주의사항 및 고려사항 브리지 패턴을 적용하기 전에 시스템이 정말로 이러한 유연성을 필요로 하는지 검토해야 합니다. 추상화와 구현 계층 사이의 의존성을 최소화하도록 인터페이스를 설계해야 합니다. 각 계층의 책임 범위를 명확히 정의하고, 단일 책임 원칙을 지키도록 해야 합니다. 성능에 민감한 시스템에서는 추가되는 간접 계층으로 인한 오버헤드를 고려해야 합니다. 브리지 패턴은 초기 설계 단계에서 적용하는 것이 가장 효과적입니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod # Implementation interface class MessageSender(ABC): @abstractmethod def send(self, message: str, recipient: str) -> bool: pass # Concrete implementations class EmailSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending email to {recipient}") print(f"Email content: {message}") return True class SMSSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending SMS to {recipient}") print(f"SMS content: {message}") return True class PushNotificationSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending push notification to device {recipient}") print(f"Notification content: {message}") return True # Abstraction class Message(ABC): def __init__(self, sender: MessageSender): self.sender = sender @abstractmethod def send(self, recipient: str) -> bool: pass # Refined Abstractions class SimpleMessage(Message): def __init__(self, sender: MessageSender, content: str): super().__init__(sender) self.content = content def send(self, recipient: str) -> bool: return self.sender.send(self.content, recipient) class HTMLMessage(Message): def __init__(self, sender: MessageSender, html_content: str): super().__init__(sender) self.html_content = html_content def send(self, recipient: str) -> bool: formatted_content = f"&lt;html>&lt;body>{self.html_content}&lt;/body>&lt;/html>" return self.sender.send(formatted_content, recipient) class EncryptedMessage(Message): def __init__(self, sender: MessageSender, content: str, encryption_key: str): super().__init__(sender) self.content = content self.encryption_key = encryption_key def send(self, recipient: str) -> bool: # Simulate encryption encrypted_content = f"ENCRYPTED[{self.content}] WITH KEY {self.encryption_key}" return self.sender.send(encrypted_content, recipient) # Message Factory for convenience class MessageFactory: @staticmethod def create_simple_message(sender: MessageSender, content: str) -> SimpleMessage: return SimpleMessage(sender, content) @staticmethod def create_html_message(sender: MessageSender, html_content: str) -> HTMLMessage: return HTMLMessage(sender, html_content) @staticmethod def create_encrypted_message( sender: MessageSender, content: str, key: str ) -> EncryptedMessage: return EncryptedMessage(sender, content, key) # Usage example if __name__ == "__main__": # Create senders email_sender = EmailSender() sms_sender = SMSSender() push_sender = PushNotificationSender() # Create message factory factory = MessageFactory() # Create and send different types of messages using different senders simple_email = factory.create_simple_message( email_sender, "Hello from Python!" ) simple_email.send("user@example.com") html_email = factory.create_html_message( email_sender, "&lt;h1>Hello&lt;/h1>&lt;p>This is HTML email&lt;/p>" ) html_email.send("user@example.com") encrypted_sms = factory.create_encrypted_message( sms_sender, "Secret message", "encryption_key_123" ) encrypted_sms.send("+1234567890") simple_push = factory.create_simple_message( push_sender, "New notification!" ) simple_push.send("device_token_123") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // Implementation interface class LogStorage { save(logEntry) { throw new Error('save method must be implemented'); } retrieve(id) { throw new Error('retrieve method must be implemented'); } } // Concrete implementations class FileLogStorage extends LogStorage { constructor(filepath) { super(); this.filepath = filepath; this.logs = new Map(); console.log(`Initializing File Storage at ${filepath}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to file: ${this.filepath}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class DatabaseLogStorage extends LogStorage { constructor(connectionString) { super(); this.connectionString = connectionString; this.logs = new Map(); console.log(`Connecting to database: ${connectionString}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to database: ${this.connectionString}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class CloudLogStorage extends LogStorage { constructor(cloudProvider, region) { super(); this.cloudProvider = cloudProvider; this.region = region; this.logs = new Map(); console.log(`Connecting to ${cloudProvider} in ${region}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to ${this.cloudProvider} cloud storage in ${this.region}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } // Abstraction class Logger { constructor(storage) { this.storage = storage; } log(message) { throw new Error('log method must be implemented'); } getLog(id) { return this.storage.retrieve(id); } } // Refined Abstractions class SimpleLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO' }; return this.storage.save(entry); } } class DetailedLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO', processId: process.pid, hostname: require('os').hostname(), memory: process.memoryUsage() }; return this.storage.save(entry); } } class SecurityLogger extends Logger { constructor(storage, encryptionKey) { super(storage); this.encryptionKey = encryptionKey; } log(message) { const entry = { timestamp: new Date().toISOString(), message: this.encrypt(message), level: 'SECURE', encryptionVersion: '1.0' }; return this.storage.save(entry); } encrypt(message) { // Simulate encryption return `ENCRYPTED[${message}] WITH KEY ${this.encryptionKey}`; } } // Usage example // Create different storage implementations const fileStorage = new FileLogStorage('/var/log/app.log'); const dbStorage = new DatabaseLogStorage('mongodb://localhost:27017/logs'); const cloudStorage = new CloudLogStorage('AWS', 'us-east-1'); // Create different types of loggers with different storage backends const simpleFileLogger = new SimpleLogger(fileStorage); const detailedDbLogger = new DetailedLogger(dbStorage); const secureCloudLogger = new SecurityLogger(cloudStorage, 'secret-key-123'); // Use the loggers const fileLogId = simpleFileLogger.log('Simple file log message'); console.log('Retrieved file log:', simpleFileLogger.getLog(fileLogId)); const dbLogId = detailedDbLogger.log('Detailed database log message'); console.log('Retrieved database log:', detailedDbLogger.getLog(dbLogId)); const cloudLogId = secureCloudLogger.log('Secure cloud log message'); console.log('Retrieved cloud log:', secureCloudLogger.getLog(cloudLogId)); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-12 06:14:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bridge Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/bridge-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-design-patterns/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-design-patterns/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>