<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Solid on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/solid/</link>
    <description>Recent content in Solid on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.9</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 05:43:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/solid/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/dependency-inversion-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/dependency-inversion-principle/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/interface-segregation-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/interface-segregation-principle/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/liskov-substitution-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/liskov-substitution-principle/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/open-closed-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/open-closed-principle/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/single-responsibility-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/design-principles/solid/single-responsibility-principle/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
  </channel>
</rss>
