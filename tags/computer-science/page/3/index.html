<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-Science | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-science/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-science/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-science/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-science/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-Science"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-Science"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-Science</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rabin-Karp’s algorithm</h2></header><div class=entry-content><p>Rabin-Karp’s algorithm 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-16 03:58:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rabin-Karp’s algorithm" href=https://buenhyden.github.io/posts/computer-science/string-search-and-manipulations/substring-search/rabin-karps-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화(Lazy Initialization) 지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법이다.
지연 초기화는 리소스 사용을 최적화하고 애플리케이션의 시작 시간을 개선하는 강력한 도구이지만 무분별한 적용은 오히려 코드를 복잡하게 만들고 성능 문제를 야기할 수 있다.
지연 초기화의 기본 개념 지연 초기화는 객체나 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 설계 패턴이다.
이는 “필요할 때까지 만들지 말라"는 원칙에 기반한다.
기본 원리 즉시 초기화(Eager Initialization): 객체가 생성될 때 모든 의존성과 리소스를 즉시 초기화 지연 초기화(Lazy Initialization): 객체의 특정 부분이 실제로 사용될 때 해당 부분만 초기화 지연 초기화가 유용한 상황 비용이 많이 드는 연산: 메모리 사용량이 큰 객체, 계산 비용이 높은 값, 데이터베이스 연결 등 사용되지 않을 수 있는 컴포넌트: 애플리케이션의 모든 실행 경로에서 필요하지 않은 리소스 초기화 의존성 문제 해결: 순환 참조 같은 의존성 문제를 해결하기 위한 방법 지연 초기화의 구현 패턴 기본 지연 초기화 패턴 가장 단순한 형태의 지연 초기화 구현.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3465 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/lazy-initialization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Little Endian</h2></header><div class=entry-content><p>Little Endian 리틀 엔디안(Little Endian)은 컴퓨터 시스템에서 메모리에 데이터를 저장하는 중요한 바이트 순서 방식이다.
엔디안은 컴퓨터가 여러 바이트로 구성된 데이터(예: 정수, 부동소수점)를 메모리에 저장하는 순서를 나타내는 용어이다.
리틀 엔디안은 현대 컴퓨터 시스템에서 가장 널리 사용되는 바이트 순서 방식이다.
대부분의 개발자는 리틀 엔디안 시스템에서 작업하게 될 가능성이 높지만, 네트워크 프로그래밍이나 다양한 플랫폼 간의 데이터 교환에서는 엔디안 차이를 인식하고 적절히 처리하는 것이 중요하다.
엔디안 관련 문제는 종종 디버깅하기 어려운 미묘한 버그를 발생시킬 수 있으므로, 바이너리 데이터를 처리할 때 항상 엔디안을 고려하는 습관을 들이는 것이 좋다. 다행히 대부분의 현대 프로그래밍 언어와 라이브러리는 엔디안 변환을 위한 도구를 제공하므로, 이러한 도구를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:20:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;431 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Little Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/little-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Big Endian</h2></header><div class=entry-content><p>Big Endian 빅 엔디안(Big Endian)은 컴퓨터 시스템에서 데이터를 저장하는 바이트 순서 방식 중 하나이다.
엔디안은 컴퓨터가 메모리에 다중 바이트 데이터를 저장하는 순서를 의미한다. 모든 데이터는 결국 바이트 단위로 저장되는데, 2바이트 이상의 데이터(예: 정수, 부동소수점)를 저장할 때 바이트 배열 순서가 중요해진다.
빅 엔디안은 다중 바이트 데이터에서 가장 중요한 바이트를 먼저 저장하는 방식으로, 특히 네트워크 프로그래밍이나 크로스 플랫폼 개발에서 중요하다. 개발자는 데이터 교환 시 엔디안 차이를 인식하고 적절히 변환하는 것이 중요하다. 현대 프로그래밍 언어와 라이브러리는 대부분 이러한 변환을 위한 도구를 제공하므로, 이를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Big Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/big-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비대칭키 암호화 (Asymmetric Encryption)</h2></header><div class=entry-content><p>비대칭키 암호화 (Asymmetric Encryption) 비대칭키 암호화는 공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식.
장점:
키 분배가 용이하다 (공개키는 공개적으로 공유 가능) 높은 보안성을 제공한다. 디지털 서명 등 다양한 보안 기능 구현이 가능하다. 단점:
대칭키 암호화에 비해 처리 속도가 느리다. 더 많은 컴퓨팅 자원이 필요하다. 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes class AsymmetricEncryption: def __init__(self): # 키 쌍 생성 self.private_key = rsa.generate_private_key( public_exponent=65537, # 일반적으로 사용되는 공개 지수 key_size=2048 # 보안을 위한 충분한 키 크기 ) # 개인키로부터 공개키 추출 self.public_key = self.private_key.public_key() def encrypt_message(self, message): """공개키로 메시지 암호화""" encrypted = self.public_key.encrypt( message.encode(), padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return encrypted def decrypt_message(self, encrypted_message): """개인키로 메시지 복호화""" decrypted = self.private_key.decrypt( encrypted_message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return decrypted.decode() 주요 특징 키 분배 문제 해결: 안전하지 않은 채널에서도 키를 교환할 수 있다. 높은 보안성: 공개키가 노출되어도 개인키가 안전하면 전체 시스템이 안전하다. 디지털 서명 가능: 메시지의 무결성과 발신자 인증에 사용된다. 느린 처리 속도: 대칭키 암호화에 비해 연산 속도가 느리다. 작동 원리 공개키와 개인키라는 두 개의 키를 사용한다.
공개키로 암호화한 데이터는 개인키로만 복호화할 수 있다.
개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:22:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비대칭키 암호화 (Asymmetric Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/asymmetric-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>대칭키 암호화 (Symmetric Encryption)</h2></header><div class=entry-content><p>대칭키 암호화 (Symmetric Encryption) 대칭키 암호화는 동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식.
구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from cryptography.fernet import Fernet class SymmetricEncryption: def __init__(self): # 대칭키 생성 self.key = Fernet.generate_key() self.cipher_suite = Fernet(self.key) def encrypt(self, data): """데이터 암호화""" if isinstance(data, str): data = data.encode() return self.cipher_suite.encrypt(data) def decrypt(self, encrypted_data): """데이터 복호화""" decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode() # 사용 예시 encryptor = SymmetricEncryption() message = "Hello, World!" encrypted = encryptor.encrypt(message) decrypted = encryptor.decrypt(encrypted) 주요 특징 암호화와 복호화에 같은 키를 사용한다. 혼돈(confusion)과 확산(diffusion)의 원리를 이용하여 평문을 암호화한다. 주로 치환(substitution)과 순열(permutation) 연산을 포함한 라운드를 반복하는 구조로 설계된다. 데이터 변환 방식에 따라 블록 암호와 스트림 암호로 구분된다. 혼돈(confusion)과 확산(diffusion)의 원리 혼돈(confusion)
암호문과 키 사이의 관계를 숨기는 것.
키의 단일 비트 변화가 암호문의 많은 비트를 변화시킴.
주로 치환(substitution) 연산을 통해 달성. 확산(diffusion)
암호문과 평문 사이의 관계를 숨기는 것.
평문의 통계적 특성을 암호문 전체에 분산시킴.
주로 순열(permutation) 연산을 통해 달성. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def confusion_example(input_data, key): # 혼돈(Confusion) 예시: XOR 연산을 사용하여 입력 데이터와 키를 결합 # 각 문자를 키와 XOR 연산하여 암호화 return [chr(ord(char) ^ key) for char in input_data] def diffusion_example(input_data): # 확산(Diffusion) 예시: 간단한 순열 연산을 사용 # 입력 데이터를 뒤집어 확산 효과를 시뮬레이션 return input_data[::-1] # 예시 데이터와 키 input_data = "HELLO" key = 3 # 혼돈 적용 confused_data = confusion_example(input_data, key) # 확산 적용 diffused_data = diffusion_example(confused_data) # 결과 출력 print("원본 데이터:", input_data) print("혼돈 적용 후:", ''.join(confused_data)) print("확산 적용 후:", ''.join(diffused_data)) 라운드 반복 구조 치환과 순열 연산을 포함한 기본 구조(라운드)를 여러 번 반복하는 방식.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:21:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;806 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 대칭키 암호화 (Symmetric Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/symmetric-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동형 암호화(Homomorphic Encryption)</h2></header><div class=entry-content><p>동형 암호화(Homomorphic Encryption) 동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술.
일반적인 암호화 방식에서는 데이터를 처리하기 위해서는 먼저 복호화를 해야 하지만, 동형 암호화에서는 암호화된 상태 그대로 데이터를 처리할 수 있다.
예를 들어, 두 개의 숫자 3과 4를 동형 암호화했다고 가정해보자.
이 암호화된 값들을 더하면, 그 결과를 복호화했을 때 7(즉, 3+4)이 나오게 된다.
동형 암호화의 종류 부분 동형 암호화(Partial Homomorphic Encryption, PHE):
하나의 연산만 지원(덧셈 또는 곱셈).
- 대표적인 예로 Paillier 암호화(덧셈 지원)와 RSA(곱셈 지원)가 있다.
- 구현이 비교적 간단하고 성능이 우수합니다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;340 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동형 암호화(Homomorphic Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/homomorphic-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>양자 암호화(quantum cryptography)</h2></header><div class=entry-content><p>양자 암호화(quantum cryptography) 양자 암호화는 양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술.
전통적인 암호화가 수학적 복잡성에 기반한다면, 양자 암호화는 양자역학의 기본 법칙을 활용하여 이론적으로 해독이 불가능한 보안을 제공한다.
양자 암호화의 핵심 원리 양자 암호화의 가장 중요한 원리는 양자역학의 기본 특성들을 활용한다:
관측 효과: 양자 상태를 측정하면 그 상태가 변화한다. 이는 도청자가 통신을 엿들으려 할 때 필연적으로 흔적을 남기게 됨을 의미한다. 복제 불가능성: 양자 상태는 완벽하게 복제할 수 없다는 ‘양자 복제 불가 정리’를 기반으로 한다. 이는 도청자가 양자 정보를 완벽하게 복사할 수 없음을 보장한다. 중첩 상태: 양자는 동시에 여러 상태를 가질 수 있으며, 측정 전까지는 확률적인 상태로 존재한다. 이러한 특성은 암호키 생성에 활용된다. 양자 암호화의 구현 방식 양자키분배(Quantum Key Distribution, QKD)는 가장 대표적인 양자 암호화 구현 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 양자 암호화(quantum cryptography)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/quantum-cryptography/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:10:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>The Open Web Application Security Project</h2></header><div class=entry-content><p>The Open Web Application Security Project Top 10 (OWASP Top 10) 웹 애플리케이션의 가장 심각한 보안 위험 10가지를 정리한 보고서.
이 프로젝트는 전 세계 보안 전문가들의 연구와 실제 데이터를 기반으로 주기적으로 업데이트된다.
주요 특징:
정기적인 업데이트: OWASP Top 10은 3~4년 주기로 업데이트되며, 가장 최근 버전은 2021년에 발표되었다. 데이터 기반 선정: 취약점 순위는 공격 가능성과 기술적 영향을 기준으로 매겨진다 커뮤니티 참여: 업계 전문가들의 설문조사와 사용자 제공 데이터 분석을 통해 선정된다. 목적:
...</p></div><footer class=entry-footer><span title='2024-11-09 11:54:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1082 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to The Open Web Application Security Project" href=https://buenhyden.github.io/posts/computer-science/security/the-open-web-application-security-project/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-science/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/computer-science/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>