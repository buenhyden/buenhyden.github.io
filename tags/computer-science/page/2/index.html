<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-Science | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-science/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-science/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-science/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-science/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-Science"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-Science"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-Science</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CCE(Common Configuration Enumeration)</h2></header><div class=entry-content><p>CCE(Common Configuration Enumeration) CCE(Common Configuration Enumeration)는 시스템의 보안 설정과 관련된 취약점을 식별하고 관리하기 위한 표준화된 명명 체계이다.
시스템 구성 문제에 고유 ID를 제공하여 여러 정보 소스와 도구 간에 구성 데이터를 빠르고 정확하게 상관시키는 것을 목적으로 한다.
이를 통해 시스템의 보안 설정을 일관되게 관리하고 평가할 수 있다.
주요 특징 표준화된 식별: 각 보안 설정에 고유한 CCE ID를 부여한다. 설정 중심: 시스템의 구성 설정에 초점을 맞춘다. 다양한 플랫폼 지원: 서버, 네트워크 장치, 방화벽 등 다양한 IT 인프라에 적용 가능하다. CCE의 중요성 일관성 유지: 여러 도구와 플랫폼에서 동일한 보안 설정을 일관되게 식별할 수 있다. 자동화 지원: 자동화된 보안 도구에서 CCE를 활용하여 효율적인 취약점 관리가 가능하다. 규정 준수: 다양한 보안 표준과 규정 준수를 위한 기준으로 활용된다. CCE의 구조와 형식 CCE 식별자는 ‘CCE-XXXX-X’ 형식을 따르며, 각 식별자는 특정 보안 구성 설정을 고유하게 식별한다.
예를 들어, ‘CCE-27277-8’은 Windows 시스템에서 최소 암호 길이 설정을 나타낸다.
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE(Common Configuration Enumeration)" href=https://buenhyden.github.io/posts/security/security-attacks/security-vulnerability/management-frameworks/cce/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CVE</h2></header><div class=entry-content><p>CVE CVE는 공개적으로 알려진 사이버 보안 취약점들에 대한 표준화된 식별자를 제공하는 목록이다.
이는 보안 취약점에 대한 일관된 명명과 식별을 가능하게 하여, 서로 다른 보안 도구와 서비스 간의 데이터 공유와 취약점 관리를 용이하게 한다.
1999년 MITRE Corporation에 의해 만들어졌으며, 주요 목적은 다음과 같다:
보안 취약점에 대한 표준화된 식별자 제공 취약점 정보의 공유 및 협업 촉진 보안 도구 및 서비스 간의 데이터 공유 개선 CVE ID 구조 CVE ID는 다음과 같은 형식을 가진다:
CVE-[연도]-[일련번호]
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVE" href=https://buenhyden.github.io/posts/security/security-attacks/security-vulnerability/management-frameworks/cve/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CVSS(Common Vulnerability Scoring System)</h2></header><div class=entry-content><p>CVSS(Common Vulnerability Scoring System) CVSS는 “공통 취약점 등급 시스템"의 약자로, 소프트웨어 취약점의 특성과 심각도를 파악하는 데 도움이 되는 표준화된 시스템이다.
주요 목적 취약점의 심각도를 표준화된 방식으로 평가 취약점 대응의 우선순위 결정에 도움 조직 간 취약점 정보 공유 및 소통 촉진 CVSS 점수 체계 CVSS 점수는 0.0에서 10.0 사이의 값으로 표현되며, 다음과 같이 분류된다:
0.0-3.9: 낮음 4.0-6.9: 중간 7.0-8.9: 높음 9.0-10.0: 심각 CVSS 메트릭 그룹 CVSS 점수는 다음 세 가지 메트릭 그룹으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVSS(Common Vulnerability Scoring System)" href=https://buenhyden.github.io/posts/security/security-attacks/security-vulnerability/management-frameworks/cvss/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CWE(Common Weakness Enumeration)</h2></header><div class=entry-content><p>CWE(Common Weakness Enumeration) CWE는 소프트웨어와 하드웨어의 설계, 디자인, 코드 구현에서 발생할 수 있는 결함, 버그, 에러 등의 보안 약점을 카탈로그화한 것이다.
주요 목적 보안 약점에 대한 공통 언어 제공 소프트웨어 보안 도구 간의 호환성 향상 보안 약점 식별 및 완화를 위한 기준 제공 표기 방식 ID 체계
CWE는 'CWE-XXX' 형식으로 표기된다.
예:
CWE-119: 버퍼 오버플로우 CWE-89: SQL 인젝션 CWE-79: 크로스 사이트 스크립팅 상세 정보 구조
각 CWE 항목은 다음과 같은 정보를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CWE(Common Weakness Enumeration)" href=https://buenhyden.github.io/posts/security/security-attacks/security-vulnerability/management-frameworks/cwe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rope</h2></header><div class=entry-content><p>Rope Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조로, 각 리프 노드(끝 노드)는 문자열과 길이(“weight"라고도 함)를 저장하고, 트리의 상위 노드들은 왼쪽 서브트리의 모든 리프 노드 길이의 합을 저장한다.
https://www.geeksforgeeks.org/ropes-data-structure-fast-string-concatenation/
특징 트리 구조: Rope는 이진 트리 형태를 가진다. 분할 저장: 큰 문자열을 작은 조각으로 나누어 저장한다. 가중치: 각 노드는 왼쪽 서브트리의 문자열 길이를 저장한다. 불변성: 일반적으로 Rope의 노드들은 불변(immutable) 객체로 취급된다. 장점 효율적인 연산: 문자열 연결, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있다. 메모리 효율성: 대규모 문자열 조작 시 추가 메모리 사용이 적다. 지속성: 비파괴적 연산을 사용하면 여러 단계의 실행 취소를 쉽게 지원할 수 있다. 단점 복잡성: 구조가 복잡하여 구현과 관리가 어려울 수 있다. 오버헤드: 작은 문자열에 대해서는 일반 문자열보다 성능이 떨어질 수 있다. 메모리 사용: 부모 노드 저장을 위해 추가 메모리가 필요하다. 응용 텍스트 에디터: Sublime Text 등의 텍스트 에디터에서 대용량 텍스트 처리에 사용된다. 이메일 시스템: Gmail과 같은 이메일 시스템에서 메시지 처리에 활용된다. 프로그래밍 환경: Cedar 프로그래밍 환경에서 사용된다. 동작 원리 문자열 분할: 큰 문자열을 작은 조각으로 나누어 트리의 리프 노드에 저장한다. 트리 구성: 리프 노드들을 이진 트리 형태로 구성한다. 가중치 계산: 각 내부 노드는 왼쪽 서브트리의 문자열 길이 합을 저장한다. 연산 수행: 트리 구조를 활용하여 효율적인 문자열 연산을 수행한다. 구성 요소 리프 노드: 실제 문자열 조각과 그 길이를 저장한다. 내부 노드: 왼쪽 서브트리의 길이(가중치)를 저장한다. 루트 노드: 전체 Rope의 시작점이다. 링크: 노드 간의 연결을 나타낸다. 구현 방식 Rope의 기본적인 구현은 이진 트리를 기반으로 한다.
다음은 Python을 사용한 간단한 Rope 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rope" href=https://buenhyden.github.io/posts/computer-science/fundamentals/string-search-and-manipulations/data-structures/rope/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Suffix Tree</h2></header><div class=entry-content><p>Suffix Tree Suffix Tree는 주어진 문자열의 모든 접미사(suffix)를 압축된 트라이(trie) 형태로 표현한 트리 구조로, 각 간선은 문자열의 부분 문자열을 나타내며, 리프 노드는 접미사의 시작 위치를 나타낸다.
https://www.geeksforgeeks.org/pattern-searching-using-suffix-tree/
특징 모든 접미사를 트리 형태로 표현한다. 공통 접두사를 공유하여 압축된 형태로 저장한다. 트리의 높이는 항상 O(n)을 유지한다. 장점 패턴 매칭, 최장 공통 부분 문자열 찾기 등의 연산을 효율적으로 수행한다. 검색 시간이 O(m)으로 매우 빠릅니다(m은 찾는 패턴의 길이). 다양한 문자열 관련 문제를 해결하는 데 활용될 수 있다. 단점 구현이 복잡하고 메모리 사용량이 많다. 구축 비용이 높다. 응용 문자열 검색 및 패턴 매칭 DNA 시퀀싱 및 생물정보학 분석 데이터 압축 알고리즘 텍스트 인덱싱 및 전체 텍스트 검색 동작 원리 문자열의 모든 접미사를 트리에 삽입한다. 공통 접두사를 공유하는 노드를 압축한다. 각 리프 노드에 접미사의 시작 위치를 저장한다. 구성 요소 루트 노드: 트리의 시작점 내부 노드: 공통 접두사를 나타내는 노드 리프 노드: 접미사의 끝을 나타내는 노드 간선: 노드 사이를 연결하며 부분 문자열을 나타냄 구현 방식 Suffix Tree는 일반적으로 Ukkonen’s 알고리즘을 사용하여 선형 시간에 구축할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Tree" href=https://buenhyden.github.io/posts/computer-science/fundamentals/string-search-and-manipulations/data-structures/suffix-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>트라이 (Trie)</h2></header><div class=entry-content><p>트라이 (Trie) 문자열을 효율적으로 저장하고 검색할 수 있는 트리 기반의 자료구조
prefix tree 또는 digital tree라고도 불린다.
https://www.geeksforgeeks.org/introduction-to-trie-data-structure-and-algorithm-tutorials/?ref=shm
특징 각 노드가 문자를 저장 루트 노드는 비어 있음 자식 노드들이 다음 문자를 나타냄 노드들이 연결되어 하나의 단어를 형성 공통 접두사를 공유하는 단어들을 효율적으로 저장 장점 빠른 검색 속도: 단어 검색 시간 복잡도가 O(m)으로, m은 검색하는 단어의 길이. 공통 접두사 활용: 공간 효율성이 높음. 자동 완성 기능: 특정 접두사를 포함하는 모든 단어를 쉽게 찾을 수 있음 정렬된 데이터 저장: 사전 순으로 데이터를 저장하고 검색 가능 해시 충돌 없음: 안정적인 성능 보장 단점 높은 메모리 사용: 각 노드가 여러 자식에 대한 링크를 가지고 있어 저장 공간을 많이 사용 복잡한 구현: 기본적인 이진 트리에 비해 구현이 다소 복잡 고정된 문자 집합: 보통 알파벳이나 특정 문자 집합을 기반으로 설계되어 다양한 문자 집합 지원을 위해 추가 구현 필요 예시: 각 노드는 문자를 키로 하는 자식 노드들의 맵을 가지고 있다. Python에서는 딕셔너리를, JavaScript에서는 Map을 사용함. 노드마다 그 노드가 단어의 끝인지를 나타내는 플래그(is_end_of_word/isEndOfWord)를 가지고 있다.
이를 통해 “app"과 “apple” 같이 하나가 다른 것의 접두사인 경우도 정확히 구분할 수 있다. count 변수를 통해 각 노드를 지나는 단어의 수를 추적할 수 있다. 이는 자동완성 시스템에서 추천 단어의 빈도수를 계산하는 데 유용하다. 접두사 검색 기능(starts_with/startsWith)을 통해 특정 문자열로 시작하는 단어가 존재하는지 빠르게 확인할 수 있다. get_words_with_prefix/getWordsWithPrefix 메서드를 통해 특정 접두사로 시작하는 모든 단어를 찾을 수 있다. 이는 자동완성 기능 구현에 직접적으로 활용될 수 있다. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class TrieNode: def __init__(self): self.children = {} # 자식 노드를 저장하는 딕셔너리 self.is_end_of_word = False # 단어의 끝을 표시하는 플래그 self.count = 0 # 이 노드를 지나는 단어의 수를 저장 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: """단어를 트라이에 삽입하는 메서드""" node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.count += 1 # 이 노드를 지나는 단어 수 증가 node.is_end_of_word = True def search(self, word: str) -> bool: """단어가 트라이에 존재하는지 검색하는 메서드""" node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: """주어진 접두사로 시작하는 단어가 있는지 확인하는 메서드""" node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def get_words_with_prefix(self, prefix: str) -> list: """주어진 접두사로 시작하는 모든 단어를 찾는 메서드""" result = [] node = self.root # 접두사에 해당하는 노드까지 이동 for char in prefix: if char not in node.children: return result node = node.children[char] # 현재 노드부터 DFS로 모든 단어 찾기 self._find_words(node, prefix, result) return result def _find_words(self, node: TrieNode, current_word: str, result: list) -> None: """DFS로 현재 노드부터 가능한 모든 단어를 찾는 보조 메서드""" if node.is_end_of_word: result.append(current_word) for char, child in node.children.items(): self._find_words(child, current_word + char, result) # 사용 예시 if __name__ == "__main__": trie = Trie() # 단어 삽입 words = ["apple", "app", "apricot", "banana", "bat"] for word in words: trie.insert(word) # 검색 예시 print(f"'apple' exists: {trie.search('apple')}") # True print(f"'app' exists: {trie.search('app')}") # True print(f"'appl' exists: {trie.search('appl')}") # False # 접두사 검색 예시 print(f"Words with prefix 'ap': {trie.get_words_with_prefix('ap')}") # ['apple', 'app', 'apricot'] Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class TrieNode { constructor() { this.children = new Map(); // 자식 노드를 저장하는 Map this.isEndOfWord = false; // 단어의 끝을 표시하는 플래그 this.count = 0; // 이 노드를 지나는 단어의 수를 저장 } } class Trie { constructor() { this.root = new TrieNode(); } insert(word) { let node = this.root; for (const char of word) { if (!node.children.has(char)) { node.children.set(char, new TrieNode()); } node = node.children.get(char); node.count++; } node.isEndOfWord = true; } search(word) { let node = this.root; for (const char of word) { if (!node.children.has(char)) { return false; } node = node.children.get(char); } return node.isEndOfWord; } startsWith(prefix) { let node = this.root; for (const char of prefix) { if (!node.children.has(char)) { return false; } node = node.children.get(char); } return true; } getWordsWithPrefix(prefix) { const result = []; let node = this.root; // 접두사에 해당하는 노드까지 이동 for (const char of prefix) { if (!node.children.has(char)) { return result; } node = node.children.get(char); } // 현재 노드부터 DFS로 모든 단어 찾기 this._findWords(node, prefix, result); return result; } _findWords(node, currentWord, result) { if (node.isEndOfWord) { result.push(currentWord); } for (const [char, child] of node.children) { this._findWords(child, currentWord + char, result); } } } // 사용 예시 const trie = new Trie(); // 단어 삽입 const words = ["apple", "app", "apricot", "banana", "bat"]; words.forEach(word => trie.insert(word)); // 검색 예시 console.log(`'apple' exists: ${trie.search('apple')}`); // true console.log(`'app' exists: ${trie.search('app')}`); // true console.log(`'appl' exists: ${trie.search('appl')}`); // false // 접두사 검색 예시 console.log(`Words with prefix 'ap': ${trie.getWordsWithPrefix('ap')}`); // ['apple', 'app', 'apricot'] 사용하기 적절한 곳 자동 완성 및 추천 시스템 사전 구현 DNA 서열 분석 IP 라우팅 검색어 자동완성 텍스트 편집기 검색 엔진 최적화 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 트라이 (Trie)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/string-search-and-manipulations/data-structures/trie/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Suffix Array</h2></header><div class=entry-content><p>Suffix Array Suffix Array는 주어진 문자열의 모든 접미사(suffix)를 사전순으로 정렬한 배열로, 각 요소는 접미사의 시작 위치를 나타내는 정수이다.
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
특징 모든 접미사를 사전순으로 정렬하여 저장한다. 공간 효율적인 구조를 가진다. 빠른 문자열 검색을 가능하게 한다. 장점 효율적인 문자열 검색과 패턴 매칭이 가능하다. 공간 복잡도가 O(n)으로 효율적이다. 다양한 문자열 관련 문제 해결에 활용될 수 있다. 단점 구축 과정이 복잡할 수 있다. 기본 구현의 시간 복잡도가 O(n^2 log n)으로 높다. 응용 문자열 검색 및 패턴 매칭 생물정보학에서의 DNA 시퀀싱 분석 데이터 압축 알고리즘 텍스트 인덱싱 및 전체 텍스트 검색 동작 원리 문자열의 모든 접미사를 생성한다. 생성된 접미사들을 사전순으로 정렬한다. 정렬된 접미사의 시작 위치를 배열에 저장한다. 구성 요소 원본 문자열 정수 배열 (접미사의 시작 위치를 저장) (선택적으로) LCP(Longest Common Prefix) 배열 구현 방식 일반적으로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 13:01:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Array" href=https://buenhyden.github.io/posts/computer-science/fundamentals/string-search-and-manipulations/data-structures/suffix-array/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-science/computer-system/computer-architecture/types/harvard-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Von Neumann architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.
Source: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/
특징 순차적 실행:
명령어를 메모리에서 한 번에 하나씩 순차적으로 가져와 실행 레지스터:
프로그램 카운터 (PC): 다음 실행할 명령어의 주소 저장 명령어 레지스터 (CIR): 현재 실행 중인 명령어 저장 메모리 주소 레지스터 (MAR): 접근할 메모리 주소 저장 메모리 데이터 레지스터 (MDR): 메모리와 주고받는 데이터 저장 누산기 (Accumulator): 연산 결과 임시 저장 버스 시스템:
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann architecture" href=https://buenhyden.github.io/posts/computer-science/computer-system/computer-architecture/types/von-neumann-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-science/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>