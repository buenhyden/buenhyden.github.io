<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Algorithm-Design</title><link>https://buenhyden.github.io/tags/algorithm-design/</link><description>Recent content in Algorithm-Design on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 13 Jan 2025 11:25:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/tags/algorithm-design/index.xml" rel="self" type="application/rss+xml"/><item><title>알고리즘 설계 (Algorithm Design)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</link><pubDate>Mon, 28 Oct 2024 05:15:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</guid><description>
&lt;h2>알고리즘 설계 (Algorithm Design)&lt;span class="hx-absolute -hx-mt-20" id="알고리즘-설계-algorithm-design">&lt;/span>
&lt;a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84-algorithm-design" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계는 주어진 문제를 효율적으로 해결하기 위한 체계적인 과정이다.&lt;/p>
&lt;p>알고리즘 설계의 주요 단계와 각 단계별 특징은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>문제 정의 및 분석&lt;br>
이 단계에서는 해결해야 할 문제를 명확하게 이해하고 정의한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 문제의 본질을 파악하고 요구사항을 명확히 한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>문제의 입력과 출력을 구체적으로 분석한다.&lt;/li>
&lt;li>문제의 제약 조건과 범위를 파악한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계는 알고리즘 설계의 기초가 되며, 문제를 정확히 이해하지 못하면 잘못된 해결책을 도출할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 설계&lt;br>
문제 해결을 위한 구체적인 단계와 절차를 개발하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 문제를 해결하기 위한 효율적이고 체계적인 방법을 고안합니다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>문제를 더 작은 하위 문제로 분해한다.&lt;/li>
&lt;li>문제 해결을 위한 논리적 단계를 구성한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계에서는 다양한 알고리즘 설계 기법(분할 정복, 동적 프로그래밍, 탐욕 알고리즘 등)을 활용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 표현&lt;br>
설계한 알고리즘을 명확하게 표현하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘을 다른 사람이 이해할 수 있도록 명확하게 기술한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>의사코드(pseudocode) 작성&lt;/li>
&lt;li>순서도(flowchart) 작성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 알고리즘은 명확하고 모호하지 않아야 하며, 각 단계가 실행 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 검증 및 분석&lt;br>
알고리즘의 정확성과 효율성을 평가하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘이 모든 가능한 입력에 대해 올바른 결과를 도출하는지 확인하고, 성능을 분석한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>알고리즘의 정확성 검증&lt;/li>
&lt;li>시간 복잡도와 공간 복잡도 분석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계에서는 알고리즘의 효율성을 평가하여 개선이 필요한 부분을 식별한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구현&lt;br>
알고리즘을 실제 프로그래밍 언어로 구현하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 설계한 알고리즘을 컴퓨터가 실행할 수 있는 형태로 변환한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>프로그래밍 언어 선택&lt;/li>
&lt;li>코드 작성 및 디버깅&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 구현 단계에서는 선택한 프로그래밍 언어의 특성을 고려하여 알고리즘을 최적화할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 및 유지보수&lt;br>
구현된 알고리즘을 테스트하고 필요에 따라 개선하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘의 실제 성능을 확인하고 문제점을 해결한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>다양한 입력 데이터로 테스트 수행&lt;/li>
&lt;li>버그 수정 및 성능 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계는 지속적으로 이루어지며, 알고리즘의 품질을 향상시키는 데 중요한 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>알고리즘 설계는 반복적인 과정이며, 각 단계에서 발견된 문제점이나 개선사항을 바탕으로 이전 단계로 돌아가 수정하는 것이 일반적이다.&lt;br>
효과적인 알고리즘 설계를 위해서는 문제에 대한 깊은 이해와 다양한 알고리즘 기법에 대한 지식, 그리고 체계적인 접근 방식이 필요하다.&lt;/p>
&lt;h3>문제알고리즘 설계의 단계별 예시&lt;span class="hx-absolute -hx-mt-20" id="문제알고리즘-설계의-단계별-예시">&lt;/span>
&lt;a href="#%eb%ac%b8%ec%a0%9c%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84%ec%9d%98-%eb%8b%a8%ea%b3%84%eb%b3%84-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>스마트 주차장 관리 시스템의 알고리즘 설계 과정을 단계별로 상세히 살펴보자.&lt;/p>
&lt;h4>1. 문제 정의 및 분석&lt;span class="hx-absolute -hx-mt-20" id="1-문제-정의-및-분석">&lt;/span>
&lt;a href="#1-%eb%ac%b8%ec%a0%9c-%ec%a0%95%ec%9d%98-%eb%b0%8f-%eb%b6%84%ec%84%9d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>스마트 주차장 관리 시스템은 주차장의 효율적인 운영과 사용자 편의성을 향상시키기 위한 자동화된 시스템.&lt;/p>
&lt;h5>입력 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="입력-데이터-구조">&lt;/span>
&lt;a href="#%ec%9e%85%eb%a0%a5-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>차량 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차량 번호&lt;/td>
&lt;td>차량 식별을 위한 고유 번호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량 크기&lt;/td>
&lt;td>소형/중형/대형으로 구분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>입차 시간&lt;/td>
&lt;td>주차장 진입 시점 기록&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장애인 차량 여부&lt;/td>
&lt;td>장애인 전용 구역 사용 자격 확인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기 주차권 보유 여부&lt;/td>
&lt;td>정기권 사용자 우선 배정 확인&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>주차장 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>전체 주차 공간 수&lt;/td>
&lt;td>주차장의 총 수용 가능 차량 수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주차 공간 상태&lt;/td>
&lt;td>각 공간의 사용 가능 여부(빈 공간/사용 중)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장애인 전용 구역 위치&lt;/td>
&lt;td>장애인 차량 전용 주차 구역 정보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구역별 센서 데이터&lt;/td>
&lt;td>각 주차 공간의 실시간 상태 모니터링 정보&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>요금 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>기본 요금&lt;/td>
&lt;td>최초 주차 시 적용되는 기본 요금&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추가 시간당 요금&lt;/td>
&lt;td>기본 시간 초과 시 적용되는 시간당 요금&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 종류별 요금&lt;/td>
&lt;td>다양한 정기권의 종류와 각각의 요금 체계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>출력 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="출력-데이터-구조">&lt;/span>
&lt;a href="#%ec%b6%9c%eb%a0%a5-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>주차 관련 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>최적 주차 공간 위치&lt;/td>
&lt;td>차량 특성에 맞는 최적의 주차 공간 안내&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>현재 주차 가능 공간 수&lt;/td>
&lt;td>실시간 이용 가능한 주차 공간의 수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주차장 점유율&lt;/td>
&lt;td>전체 주차 공간 대비 사용 중인 공간의 비율&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>요금 관련 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>주차 요금 계산 결과&lt;/td>
&lt;td>주차 시간에 따른 최종 요금 계산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 잔여 기간&lt;/td>
&lt;td>정기권 사용자의 남은 사용 기간 정보&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>상태 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>실시간 주차장 상태&lt;/td>
&lt;td>전체 주차장의 현재 운영 상태&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량별 주차 위치&lt;/td>
&lt;td>각 차량의 현재 주차 위치 정보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>경보 및 알림&lt;/td>
&lt;td>비상 상황 또는 주요 이벤트 알림&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>제약조건&lt;span class="hx-absolute -hx-mt-20" id="제약조건">&lt;/span>
&lt;a href="#%ec%a0%9c%ec%95%bd%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>시스템 제약&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>제약 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>실시간 처리&lt;/td>
&lt;td>모든 데이터는 실시간으로 처리되어야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동시 다중 사용자 지원&lt;/td>
&lt;td>여러 사용자의 동시 접속 및 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>센서 데이터 처리 지연 최소화&lt;/td>
&lt;td>센서 데이터의 신속한 처리 및 반영&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>비즈니스 제약&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>제약 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>장애인 구역 제한&lt;/td>
&lt;td>장애인 전용 구역은 해당 차량만 사용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량 크기별 공간 배정&lt;/td>
&lt;td>차량 크기에 적합한 주차 공간만 배정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 사용자 우선 배정&lt;/td>
&lt;td>정기권 보유 차량에 대한 우선 주차 공간 배정&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>2. 알고리즘 설계&lt;span class="hx-absolute -hx-mt-20" id="2-알고리즘-설계">&lt;/span>
&lt;a href="#2-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>이 시스템에서는 여러 알고리즘이 필요하며, 각각의 목적과 선택 이유를 정리한다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>최적 주차 공간 배정 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 가중 그래프 최단 경로 (Dijkstra&amp;rsquo;s Algorithm)&lt;/li>
&lt;li>목적: 차량 특성과 현재 위치에 기반한 최적 주차 공간 선택&lt;/li>
&lt;li>선택 이유: 다양한 조건(거리, 크기, 접근성)을 가중치로 반영 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>실시간 모니터링 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 이벤트 기반 상태 관리&lt;/li>
&lt;li>목적: 센서 데이터 실시간 처리 및 상태 업데이트&lt;/li>
&lt;li>선택 이유: 비동기 처리로 시스템 반응성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>요금 계산 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 동적 프로그래밍&lt;/li>
&lt;li>목적: 다양한 요금제와 할인 적용&lt;/li>
&lt;li>선택 이유: 복잡한 요금 규칙을 효율적으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4>3. 알고리즘 표현&lt;span class="hx-absolute -hx-mt-20" id="3-알고리즘-표현">&lt;/span>
&lt;a href="#3-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ed%91%9c%ed%98%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>여기서는 최적 주차 공간 배정 알고리즘을 자세히 살펴보자.&lt;/p>
&lt;h5>의사코드&lt;span class="hx-absolute -hx-mt-20" id="의사코드">&lt;/span>
&lt;a href="#%ec%9d%98%ec%82%ac%ec%bd%94%eb%93%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>FUNCTION findOptimalParkingSpace(vehicleInfo, parkingLot):
// 초기화
availableSpaces = []
weightedGraph = createWeightedGraph(parkingLot)
// 적합한 주차 공간 필터링
FOR EACH space in parkingLot.spaces:
IF isSpaceSuitable(space, vehicleInfo):
availableSpaces.append(space)
// 각 공간에 대한 최적성 점수 계산
bestSpace = NULL
bestScore = INFINITY
FOR EACH space in availableSpaces:
score = calculateSpaceScore(space, vehicleInfo)
IF score &amp;lt; bestScore:
bestScore = score
bestSpace = space
RETURN bestSpace
FUNCTION calculateSpaceScore(space, vehicleInfo):
score = 0
// 거리 가중치
score &amp;#43;= getDistance(entrance, space) * DISTANCE_WEIGHT
// 크기 적합성 가중치
score &amp;#43;= getSizeFitScore(space, vehicleInfo) * SIZE_WEIGHT
// 특별 조건 가중치 (장애인 구역 등)
score &amp;#43;= getSpecialConditionScore(space, vehicleInfo) * SPECIAL_WEIGHT
RETURN score&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>순서도&lt;span class="hx-absolute -hx-mt-20" id="순서도">&lt;/span>
&lt;a href="#%ec%88%9c%ec%84%9c%eb%8f%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;pre class="mermaid hx-mt-6">flowchart TD
A([시작]) --> B[/차량정보 입력/]
B --> C[주차장 상태 조회]
C --> D[가용 공간 필터링]
D --> E{가용 공간 존재?}
E -->|No| F[/주차 불가 응답/]
E -->|Yes| G[공간별 점수 계산]
G --> H{특별 조건 차량?}
H -->|Yes| I[특별 구역 우선 점수 적용]
H -->|No| J[일반 점수 계산]
I --> K[최적 공간 선택]
J --> K
K --> L[/최적 주차 공간 안내/]
L --> M([종료])
F --> M&lt;/pre>&lt;h4>4. 구현&lt;span class="hx-absolute -hx-mt-20" id="4-구현">&lt;/span>
&lt;a href="#4-%ea%b5%ac%ed%98%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">dataclasses&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">typing&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Optional&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">datetime&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">datetime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">heapq&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Vehicle&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;차량 정보를 저장하는 클래스&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">plate_number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span> &lt;span class="c1"># &amp;#39;small&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;large&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_disabled&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">has_subscription&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">entry_time&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">datetime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ParkingSpace&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;주차 공간 정보를 저장하는 클래스&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">location&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_disabled_only&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_occupied&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sensor_status&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SmartParkingSystem&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total_spaces&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">]):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 스마트 주차 시스템 초기화
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> total_spaces: 전체 주차 공간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">total_spaces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">occupied_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="c1"># 차량별 주차 위치 추적&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">entrance_location&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 주차장 입구 위치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">find_optimal_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">Optional&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간을 찾는 메인 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 입차하는 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간 또는 None (가용 공간 없을 경우)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 가용 공간 필터링&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">space&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spaces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_is_space_suitable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 최적 공간 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_select_best_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">available_spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_is_space_suitable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">bool&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간이 해당 차량에 적합한지 확인
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> space: 검사할 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 적합 여부
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_occupied&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled_only&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 차량 크기 체크&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_order&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;small&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;medium&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;large&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">size_order&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">size_order&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_select_best_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 가용 공간 중 최적의 공간 선택
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> available_spaces: 가용 주차 공간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;inf&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">space&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_space_score&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">score&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">best_score&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">score&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">space&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">best_space&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_space_score&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간의 최적성 점수 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> space: 평가할 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적성 점수 (낮을수록 좋음)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DISTANCE_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SIZE_FIT_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">2.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SPECIAL_CONDITION_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 거리 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">distance&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_distance&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">entrance_location&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">location&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">distance&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">DISTANCE_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 크기 적합성 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_fit_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_size_fit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">size_fit_score&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">SIZE_FIT_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 특별 조건 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled_only&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">50&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">SPECIAL_CONDITION_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">score&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_distance&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">point1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 두 지점 간의 맨해튼 거리 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_size_fit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간과 차량 크기의 적합성 점수 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_values&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;small&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;medium&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;large&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size_values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">size_values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">])&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>5. 테스트&lt;span class="hx-absolute -hx-mt-20" id="5-테스트">&lt;/span>
&lt;a href="#5-%ed%85%8c%ec%8a%a4%ed%8a%b8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">test_smart_parking_system&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;스마트 주차 시스템 테스트&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트용 주차 공간 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;large&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;B1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;small&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;B2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 시스템 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">parking_system&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SmartParkingSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test_spaces&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 케이스 정의&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_cases&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 일반 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;123가4567&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 장애인 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;234가5678&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;small&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 대형 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;345가6789&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;large&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">vehicle&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">test_cases&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">테스트 차량: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plate_number&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parking_system&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">find_optimal_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;배정된 주차 공간: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;가용 주차 공간 없음&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_smart_parking_system&lt;/span>&lt;span class="p">()&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>6. 분석 및 개선사항&lt;span class="hx-absolute -hx-mt-20" id="6-분석-및-개선사항">&lt;/span>
&lt;a href="#6-%eb%b6%84%ec%84%9d-%eb%b0%8f-%ea%b0%9c%ec%84%a0%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>
&lt;p>성능 분석&lt;/p>
&lt;ul>
&lt;li>시간 복잡도: O(n) (n: 주차 공간 수)&lt;/li>
&lt;li>공간 복잡도: O(m) (m: 현재 주차된 차량 수)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>개선 필요 사항&lt;/p>
&lt;ul>
&lt;li>동시성 제어 메커니즘 추가&lt;/li>
&lt;li>센서 데이터 실시간 업데이트 처리&lt;/li>
&lt;li>예약 시스템 통합&lt;/li>
&lt;li>결제 시스템 연동&lt;/li>
&lt;li>비상 상황 처리 로직 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>확장 가능한 기능&lt;/p>
&lt;ul>
&lt;li>모바일 앱 연동&lt;/li>
&lt;li>차량 번호판 인식 시스템 통합&lt;/li>
&lt;li>통계 분석 기능 추가&lt;/li>
&lt;li>예측 모델 도입&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3></description></item><item><title>Memoization vs Tabulation</title><link>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation/</link><pubDate>Mon, 13 Jan 2025 11:25:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation/</guid><description>
&lt;h2>Memoization Vs Tabulation&lt;span class="hx-absolute -hx-mt-20" id="memoization-vs-tabulation">&lt;/span>
&lt;a href="#memoization-vs-tabulation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.&lt;/p>
&lt;p>Memoization(메모이제이션)은 &amp;ldquo;하향식(Top-down)&amp;rdquo; 접근 방식이다.&lt;br>
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.&lt;/p>
&lt;p>Tabulation(타뷸레이션)은 &amp;ldquo;상향식(Bottom-up)&amp;rdquo; 접근 방식이다.&lt;br>
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Tabulation&lt;/th>
&lt;th>Memoization&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>접근 방식&lt;/strong>&lt;/td>
&lt;td>Bottom-up (상향식)&lt;/td>
&lt;td>Top-down (하향식)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>구현 방법&lt;/strong>&lt;/td>
&lt;td>반복문 (Iterative)&lt;/td>
&lt;td>재귀 (Recursive)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>메모리 사용&lt;/strong>&lt;/td>
&lt;td>문제 크기만큼 고정&lt;/td>
&lt;td>필요한 만큼 동적 할당&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>실행 순서&lt;/strong>&lt;/td>
&lt;td>순차적으로 모든 하위 문제 해결&lt;/td>
&lt;td>필요한 하위 문제만 해결&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>공간 효율성&lt;/strong>&lt;/td>
&lt;td>예측 가능하고 일정함&lt;/td>
&lt;td>재귀 호출로 인한 스택 공간 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>시간 효율성&lt;/strong>&lt;/td>
&lt;td>모든 경우를 계산&lt;/td>
&lt;td>필요한 경우만 계산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>코드 복잡도&lt;/strong>&lt;/td>
&lt;td>일반적으로 더 단순&lt;/td>
&lt;td>일반적으로 더 복잡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>캐시 활용&lt;/strong>&lt;/td>
&lt;td>배열/테이블 형태&lt;/td>
&lt;td>해시 테이블/맵 형태&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>구현 예시 비교&lt;span class="hx-absolute -hx-mt-20" id="구현-예시-비교">&lt;/span>
&lt;a href="#%ea%b5%ac%ed%98%84-%ec%98%88%ec%8b%9c-%eb%b9%84%ea%b5%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>피보나치 수열 계산의 경우&lt;span class="hx-absolute -hx-mt-20" id="피보나치-수열-계산의-경우">&lt;/span>
&lt;a href="#%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98-%ec%88%98%ec%97%b4-%ea%b3%84%ec%82%b0%ec%9d%98-%ea%b2%bd%ec%9a%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Tabulation 방식&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fib_tabulation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테이블 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">table&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 순차적으로 값 채우기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">table&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Memoization 방식&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fib_memoization&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{}):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 이미 계산된 값이면 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기본 케이스&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 결과 저장 및 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fib_memoization&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">fib_memoization&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>세부 특성&lt;/th>
&lt;th>Tabulation&lt;/th>
&lt;th>Memoization&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>적합한 상황&lt;/strong>&lt;/td>
&lt;td>모든 하위 문제의 결과가 필요한 경우&lt;/td>
&lt;td>일부 하위 문제의 결과만 필요한 경우&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>디버깅 난이도&lt;/strong>&lt;/td>
&lt;td>상대적으로 쉬움&lt;/td>
&lt;td>재귀로 인해 더 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>최적화 가능성&lt;/strong>&lt;/td>
&lt;td>공간 최적화 쉬움&lt;/td>
&lt;td>재귀 깊이 제한으로 인한 제약&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>병렬화 가능성&lt;/strong>&lt;/td>
&lt;td>쉬움 (독립적인 계산)&lt;/td>
&lt;td>어려움 (의존성 있는 호출)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>초기화 오버헤드&lt;/strong>&lt;/td>
&lt;td>더 큼 (전체 테이블)&lt;/td>
&lt;td>더 작음 (필요시 할당)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>메모리 예측성&lt;/strong>&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>낮음 (실행 중 변동)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>성능 특성&lt;/th>
&lt;th>Tabulation&lt;/th>
&lt;th>Memoization&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>시간 복잡도&lt;/strong>&lt;/td>
&lt;td>O(n) - 모든 경우&lt;/td>
&lt;td>O(n) - 최악의 경우&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>공간 복잡도&lt;/strong>&lt;/td>
&lt;td>O(n) - 테이블 크기&lt;/td>
&lt;td>O(n) - 캐시 + 스택&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>캐시 적중률&lt;/strong>&lt;/td>
&lt;td>100% (모든 값 계산)&lt;/td>
&lt;td>상황에 따라 다름&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>초기 지연 시간&lt;/strong>&lt;/td>
&lt;td>더 김 (테이블 초기화)&lt;/td>
&lt;td>더 짧음 (즉시 시작)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>메모리 사용량&lt;/strong>&lt;/td>
&lt;td>예측 가능&lt;/td>
&lt;td>변동적&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.&lt;br>
일반적으로:&lt;/p>
&lt;ol>
&lt;li>모든 하위 문제를 풀어야 하는 경우: Tabulation&lt;/li>
&lt;li>일부 하위 문제만 필요한 경우: Memoization&lt;/li>
&lt;li>공간 효율성이 중요한 경우: Tabulation&lt;/li>
&lt;li>구현 단순성이 중요한 경우: Tabulation&lt;/li>
&lt;li>필요한 계산만 하고 싶은 경우: Memoization&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>브루트 포스 (Brute Force)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</link><pubDate>Sat, 11 Jan 2025 07:50:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</guid><description>
&lt;h2>브루트 포스 (Brute Force)&lt;span class="hx-absolute -hx-mt-20" id="브루트-포스-brute-force">&lt;/span>
&lt;a href="#%eb%b8%8c%eb%a3%a8%ed%8a%b8-%ed%8f%ac%ec%8a%a4-brute-force" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>브루트 포스는 &amp;ldquo;무식한 힘&amp;quot;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>모든 가능성을 고려한다.&lt;/li>
&lt;li>단순하고 직관적이다.&lt;/li>
&lt;li>항상 정확한 해답을 찾는다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 최적화 없이 문제를 해결하고자 할 때 사용한다.&lt;/li>
&lt;li>다른 효율적인 알고리즘이 없거나 구현이 어려울 때 필요하다.&lt;/li>
&lt;li>문제의 크기가 작을 때 빠르게 해결책을 찾을 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>구현이 간단하다.&lt;/li>
&lt;li>항상 최적의 해를 찾는다.&lt;/li>
&lt;li>문제의 제약 조건이 까다로울 때 유용하다.&lt;/li>
&lt;/ol>
&lt;h3>단점&lt;span class="hx-absolute -hx-mt-20" id="단점">&lt;/span>
&lt;a href="#%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>시간 복잡도가 높다 (대부분의 경우 O(2^n) 또는 O(n!)).&lt;/li>
&lt;li>큰 입력에 대해 비효율적이다.&lt;/li>
&lt;li>메모리 사용량이 많을 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>가능한 모든 경우의 수를 생성한다.&lt;/li>
&lt;li>각 경우에 대해 문제의 조건을 만족하는지 확인한다.&lt;/li>
&lt;li>조건을 만족하는 경우를 해답으로 채택한다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제의 크기가 작을 때 효과적이다.&lt;/li>
&lt;li>다른 알고리즘의 정확성을 검증하는 데 사용될 수 있다.&lt;/li>
&lt;li>구현이 간단하고 버그가 적다.&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>가능한 경우의 수를 줄이는 방법을 고려한다 (가지치기).&lt;/li>
&lt;li>병렬 처리를 활용하여 성능을 개선할 수 있다.&lt;/li>
&lt;li>메모이제이션을 사용하여 중복 계산을 줄인다.&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>후보 생성 함수 (generate_candidates)&lt;/li>
&lt;li>유효성 검사 함수 (is_valid_solution)&lt;/li>
&lt;li>반복문 또는 재귀를 통한 모든 경우의 수 탐색&lt;/li>
&lt;/ol>
&lt;h3>실제 예시 코드&lt;span class="hx-absolute -hx-mt-20" id="실제-예시-코드">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c-%ec%bd%94%eb%93%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>모든 가능한 비밀번호 조합을 생성하여 올바른 비밀번호를 찾는 함수&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">find_password&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">password_length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">character_set&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 모든 가능한 비밀번호 조합을 생성하여 올바른 비밀번호를 찾는 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> :param password_length: 비밀번호 길이
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> :param character_set: 사용 가능한 문자 집합
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> :return: 찾은 비밀번호 또는 None
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">generate_passwords&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_password&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_password&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">password_length&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield&lt;/span> &lt;span class="n">current_password&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">char&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">character_set&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">yield from&lt;/span> &lt;span class="n">generate_passwords&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_password&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">char&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">password&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">generate_passwords&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">is_correct_password&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">password&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 이 함수는 실제 비밀번호 확인 로직을 구현해야 함&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">password&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">character_set&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;abcdefghijklmnopqrstuvwxyz&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">password_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">find_password&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">password_length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">character_set&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;찾은 비밀번호: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>부분집합 생성 문제&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">generate_all_subsets&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주어진 원소들의 모든 가능한 부분집합을 생성하는 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> elements (list): 원소들의 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> list: 모든 가능한 부분집합들의 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 총 2^n개의 부분집합이 존재&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">all_subsets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 0부터 2^n-1까지의 모든 수에 대해&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_subset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 각 비트 위치 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># j번째 비트가 1이면 j번째 원소를 부분집합에 포함&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_subset&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">elements&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">all_subsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current_subset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">all_subsets&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 문자열 매칭 예제&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">string_matching_brute_force&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pattern&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 문자열에서 특정 패턴을 찾는 브루트 포스 알고리즘
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> text (str): 검색할 텍스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> pattern (str): 찾을 패턴
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> list: 패턴이 발견된 모든 시작 위치들의 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pattern&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">positions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모든 가능한 시작 위치에 대해 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">m&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">match&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 위치에서 패턴의 모든 문자 비교&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">pattern&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">match&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="k">match&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">positions&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">positions&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">text&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;AABAACAADAABAABA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pattern&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;AABA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">positions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">string_matching_brute_force&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pattern&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;패턴이 발견된 위치들: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">positions&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>랜덤화 알고리즘 (Randomized Algorithm)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</link><pubDate>Sat, 11 Jan 2025 05:55:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</guid><description>
&lt;h2>랜덤화 알고리즘 (Randomized Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="랜덤화-알고리즘-randomized-algorithm">&lt;/span>
&lt;a href="#%eb%9e%9c%eb%8d%a4%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-randomized-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다. 이 무작위성은 알고리즘의 동작이나 결정에 영향을 미치며, 같은 입력에 대해서도 매번 다른 결과를 낼 수 있다.&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>무작위성: 알고리즘의 핵심 특성으로, 난수를 사용하여 결정을 내린다.&lt;/li>
&lt;li>확률적 성능: 알고리즘의 성능이 확률적으로 분석된다.&lt;/li>
&lt;li>다양성: 같은 입력에 대해 다양한 출력이 가능하다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 문제의 간단한 해결책 제공&lt;/li>
&lt;li>최악의 경우 성능 개선&lt;/li>
&lt;li>결정론적 알고리즘의 한계 극복&lt;/li>
&lt;li>평균 실행 시간 단축&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>단순성: 복잡한 문제에 대해 간단한 해결책 제공&lt;/li>
&lt;li>효율성: 많은 경우에 결정론적 알고리즘보다 빠름&lt;/li>
&lt;li>유연성: 다양한 문제에 적용 가능&lt;/li>
&lt;/ol>
&lt;h3>단점&lt;span class="hx-absolute -hx-mt-20" id="단점">&lt;/span>
&lt;a href="#%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>결과의 일관성 부족: 같은 입력에 대해 다른 결과 가능&lt;/li>
&lt;li>디버깅의 어려움: 무작위성으로 인해 재현이 어려울 수 있음&lt;/li>
&lt;li>최악의 경우 보장 부족: 확률적 성능으로 인해 최악의 경우를 완전히 배제할 수 없음&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제 정의&lt;/li>
&lt;li>무작위 선택 요소 식별&lt;/li>
&lt;li>난수 생성기 사용&lt;/li>
&lt;li>무작위 선택에 기반한 결정&lt;/li>
&lt;li>결과 도출 및 분석&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효율성: 평균적으로 좋은 성능을 보여야 함&lt;/li>
&lt;li>정확성: 높은 확률로 정확한 결과를 제공해야 함&lt;/li>
&lt;li>단순성: 구현과 이해가 쉬워야 함&lt;/li>
&lt;li>확장성: 다양한 입력 크기에 대응할 수 있어야 함&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>고품질의 난수 생성기 사용&lt;/li>
&lt;li>무작위성의 적절한 활용&lt;/li>
&lt;li>확률 분석을 통한 성능 최적화&lt;/li>
&lt;li>병렬화 가능성 고려&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>난수 생성기&lt;/li>
&lt;li>무작위 선택 메커니즘&lt;/li>
&lt;li>결정 함수&lt;/li>
&lt;li>종료 조건&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>랜덤화된 퀵 정렬 알고리즘&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">random&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">randomized_quicksort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 무작위로 피벗을 선택하는 퀵 정렬 알고리즘
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> arr (list): 정렬할 배열
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> list: 정렬된 배열
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기저 사례: 배열의 길이가 1 이하면 이미 정렬된 상태&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 무작위로 피벗 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pivot&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 피벗을 기준으로 배열을 분할&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">middle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pivot&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 재귀적으로 각 부분을 정렬하고 결합&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">randomized_quicksort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">middle&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">randomized_quicksort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Monte Carlo 방식의 소수 판별 알고리즘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_prime_monte_carlo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 몬테 카를로 방식으로 소수를 판별하는 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> n (int): 판별할 숫자
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> k (int): 시도 횟수 (높을수록 정확도 증가)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> bool: 소수일 가능성이 높으면 True
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 여러 번의 시도를 통해 소수 여부 판별&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2부터 n-1 사이의 무작위 수 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 페르마의 소정리를 이용한 판별&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">pow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span> &lt;span class="c1"># 합성수임이 확실&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span> &lt;span class="c1"># 소수일 가능성이 높음&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">34&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">25&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">22&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">90&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sorted_arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">randomized_quicksort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;정렬된 배열: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">sorted_arr&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 소수 판별 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">numbers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">97&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">numbers&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">is_prime_monte_carlo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">은(는) &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="s1">&amp;#39;소수일 가능성이 높습니다&amp;#39;&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="s1">&amp;#39;합성수입니다&amp;#39;&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Algorithm Design techniques</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</link><pubDate>Fri, 01 Nov 2024 07:30:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</guid><description>
&lt;h2>Algorithm Design Techniques&lt;span class="hx-absolute -hx-mt-20" id="algorithm-design-techniques">&lt;/span>
&lt;a href="#algorithm-design-techniques" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.&lt;br>
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.&lt;/p>
&lt;p>분할 정복 (Divide and Conquer), 동적 계획법 (Dynamic Programming), 탐욕 알고리즘 (Greedy Algorithm), 백트래킹 (Backtracking), 분기 한정법 (Branch and Bound), 근사 알고리즘 (Approximation), Randomized Algorithm, 브루트 포스 (Brute Force)는 모두 복잡한 문제를 해결하기 위한 알고리즘 기법들이다.&lt;/p>
&lt;p>다음과 같은 공통점을 가지고 있다.&lt;/p>
&lt;ol>
&lt;li>문제 해결 접근법: 대부분의 기법들은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 접근 방식을 사용한다. 특히 분할 정복, 동적 계획법이 이런 특징을 잘 보여준다.&lt;/li>
&lt;li>최적화 목표: 대부분의 기법들은 주어진 문제에 대한 최적의 해결책을 찾는 것을 목표로 한다. 다만 접근 방식과 보장되는 최적성의 정도가 드랃.&lt;/li>
&lt;li>효율성 고려: 모든 기법들이 시간과 공간 복잡도를 고려하여 효율적인 해결책을 찾고자 한다.&lt;/li>
&lt;/ol>
&lt;p>각각의 알고리즘을 비교 분석하였다.&lt;/p>
&lt;ol>
&lt;li>문제 해결 방식:
&lt;ul>
&lt;li>분할 정복은 하위 문제들이 독립적이다.&lt;/li>
&lt;li>동적 계획법은 하위 문제들이 중복될 수 있으며, 이를 재활용한다.&lt;/li>
&lt;li>탐욕 알고리즘은 각 단계별로 독립적인 결정을 내리며, 지역적 최적해가 전역적 최적해로 이어지는 경우 적합하다.&lt;/li>
&lt;li>백트래킹과 분기 한정법은 체계적인 탐색을 수행하며, 제약 조건이 많은 최적화 문제에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>효율성:
&lt;ul>
&lt;li>동적 계획법과 분할 정복은 중복 계산을 줄여 효율성을 높인다.&lt;/li>
&lt;li>브루트 포스는 모든 경우를 탐색하여 비효율적일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적해 보장:
&lt;ul>
&lt;li>분할 정복, 동적 계획법 브루트 포스는 최적해를 보장한다.&lt;/li>
&lt;li>탐욕 알고리즘은 일반적으로 최적해를 보장하지 않는다.&lt;/li>
&lt;li>근사 알고리즘은 최적해의 근사값을 제공한다.&lt;/li>
&lt;li>무작위 알고리즘은 확률적으로 좋은 해답을 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적용 범위:
&lt;ul>
&lt;li>근사 알고리즘과 무작위 알고리즘은 NP-난해 문제 등 복잡한 문제에 적용될 수 있다.&lt;/li>
&lt;li>다른 기법들은 특정 유형의 문제에 더 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구현 복잡성:
&lt;ul>
&lt;li>브루트 포스는 구현이 간단하다.&lt;/li>
&lt;li>동적 계획법이나 분기 한정법은 상대적으로 구현이 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메모리 사용:
&lt;ul>
&lt;li>동적 계획법은 중간 결과를 저장하기 위해 추가 메모리를 사용한다.&lt;/li>
&lt;li>다른 기법들은 상대적으로 적은 메모리를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 알고리즘 기법들은 각각의 특성에 따라 적합한 문제 유형이 다르며, 때로는 여러 기법을 조합하여 사용하기도 한다. 문제의 성격과 요구사항에 따라 적절한 알고리즘을 선택하는 것이 중요하다.&lt;/p>
&lt;h3>Algorithm Design Techniques&lt;span class="hx-absolute -hx-mt-20" id="algorithm-design-techniques-1">&lt;/span>
&lt;a href="#algorithm-design-techniques-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 설계 기법&lt;/th>
&lt;th>핵심 개념&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>예시&lt;/th>
&lt;th>사용되는 접근 방법&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>분할 정복 (Divide and Conquer)&lt;/td>
&lt;td>문제를 더 작은 하위 문제로 나누고 재귀적으로 해결&lt;/td>
&lt;td>재귀적 구조, 하위 문제 독립성&lt;/td>
&lt;td>효율성, 병렬화 가능&lt;/td>
&lt;td>오버헤드, 메모리 사용량 증가&lt;/td>
&lt;td>병합 정렬, 퀵 정렬&lt;/td>
&lt;td>재귀적 접근, 분할 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동적 계획법 (Dynamic Programming)&lt;/td>
&lt;td>중복되는 하위 문제의 해결책을 저장하여 재사용&lt;/td>
&lt;td>최적 부분 구조, 중복 부분 문제&lt;/td>
&lt;td>시간 복잡도 감소, 최적해 보장&lt;/td>
&lt;td>메모리 사용량 증가, 구현 복잡성&lt;/td>
&lt;td>피보나치 수열, 배낭 문제&lt;/td>
&lt;td>메모이제이션, 타뷸레이션&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>탐욕 알고리즘 (Greedy Algorithm)&lt;/td>
&lt;td>각 단계에서 최선의 선택을 수행&lt;/td>
&lt;td>지역적 최적해 선택, 단순성&lt;/td>
&lt;td>구현 용이, 빠른 실행 시간&lt;/td>
&lt;td>전역 최적해 보장 못함&lt;/td>
&lt;td>크러스컬 알고리즘, 허프만 코딩&lt;/td>
&lt;td>선택적 접근, 순차적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>백트래킹 (Backtracking)&lt;/td>
&lt;td>가능한 모든 해결책을 탐색하며 조건 불만족 시 되돌아감&lt;/td>
&lt;td>깊이 우선 탐색, 가지치기&lt;/td>
&lt;td>모든 해결책 탐색 가능, 메모리 효율적&lt;/td>
&lt;td>최악의 경우 지수 시간 복잡도&lt;/td>
&lt;td>N-퀸 문제, 스도쿠&lt;/td>
&lt;td>재귀적 접근, 깊이 우선 탐색&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분기 한정법 (Branch and Bound)&lt;/td>
&lt;td>최적해를 찾기 위해 해 공간을 체계적으로 탐색&lt;/td>
&lt;td>너비 우선 탐색, 한계 함수 사용&lt;/td>
&lt;td>최적해 보장, 불필요한 탐색 제거&lt;/td>
&lt;td>메모리 사용량 증가, 구현 복잡성&lt;/td>
&lt;td>외판원 문제, 배낭 문제&lt;/td>
&lt;td>너비 우선 탐색, 한계 설정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>근사 알고리즘 (Approximation)&lt;/td>
&lt;td>최적해에 근접한 해결책을 다항 시간 내에 찾음&lt;/td>
&lt;td>근사비 보장, 다항 시간 복잡도&lt;/td>
&lt;td>NP-난해 문제 해결 가능, 빠른 실행 시간&lt;/td>
&lt;td>최적해 보장 못함&lt;/td>
&lt;td>집합 커버 문제, 최대 컷 문제&lt;/td>
&lt;td>휴리스틱 접근, 반복적 개선&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Randomized Algorithm&lt;/td>
&lt;td>무작위성을 활용하여 문제 해결&lt;/td>
&lt;td>확률적 접근, 반복 실행&lt;/td>
&lt;td>평균 성능 우수, 구현 간단&lt;/td>
&lt;td>결과의 일관성 부족&lt;/td>
&lt;td>빠른 정렬, 소수 판별&lt;/td>
&lt;td>확률적 접근, 몬테카를로 방법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>브루트 포스 (Brute Force)&lt;/td>
&lt;td>가능한 모든 경우를 탐색하여 해결책 찾음&lt;/td>
&lt;td>완전 탐색, 단순 구현&lt;/td>
&lt;td>정확한 해 보장, 구현 용이&lt;/td>
&lt;td>시간 복잡도 높음, 비효율적&lt;/td>
&lt;td>문자열 매칭, 부분집합 생성&lt;/td>
&lt;td>전수 조사, 순차적 접근&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이 표는 각 알고리즘 설계 기법의 주요 특성을 비교하고 있다.&lt;/p>
&lt;ul>
&lt;li>분할 정복과 동적 계획법은 문제를 작은 부분으로 나누어 해결한다는 점에서 유사하지만, 동적 계획법은 중복되는 하위 문제의 해결책을 저장하여 재사용한다는 점에서 차이가 있다.&lt;/li>
&lt;li>탐욕 알고리즘은 빠르고 구현이 쉽지만 항상 최적해를 보장하지는 않는다.&lt;/li>
&lt;li>백트래킹과 분기 한정법은 모두 탐색 공간을 체계적으로 탐색하지만, 백트래킹은 깊이 우선 탐색을, 분기 한정법은 너비 우선 탐색을 주로 사용한다.&lt;/li>
&lt;li>근사 알고리즘과 무작위 알고리즘은 정확한 해를 보장하지 않지만 빠른 실행 시간을 제공한다.&lt;/li>
&lt;li>브루트 포스는 가장 단순하지만 가장 비효율적인 방법으로, 다른 기법들의 기준점으로 사용될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>각 기법은 특정 문제 유형에 더 적합할 수 있으며, 실제 적용 시에는 문제의 특성, 요구사항, 제약 조건 등을 고려하여 적절한 기법을 선택하거나 여러 기법을 조합하여 사용해야 한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Approaches to algorithm design</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</link><pubDate>Fri, 01 Nov 2024 07:30:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</guid><description>
&lt;h2>Approaches to Algorithm Design&lt;span class="hx-absolute -hx-mt-20" id="approaches-to-algorithm-design">&lt;/span>
&lt;a href="#approaches-to-algorithm-design" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.&lt;br>
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.&lt;/p>
&lt;h3>Approaches to Algorithm Design&lt;span class="hx-absolute -hx-mt-20" id="approaches-to-algorithm-design-1">&lt;/span>
&lt;a href="#approaches-to-algorithm-design-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>알고리즘 설계를 위한 접근 방법은 문제 해결을 위한 전략적인 사고 과정을 의미한다.&lt;br>
이는 알고리즘 설계 기법과는 구별되는 개념으로, 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞춘다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>접근 방법&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 예시&lt;/th>
&lt;th>주요 관련 접근법&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>예증 (Exemplification)&lt;/td>
&lt;td>구체적인 예제를 통해 일반적 규칙을 유도하여 문제를 해결하는 방법으로, 실제 사례 분석을 통한 패턴 발견에 중점을 둠&lt;/td>
&lt;td>구체적인 예를 통해 패턴을 발견하기 쉬움&lt;br>직관적인 이해가 가능&lt;br>실제 사례 기반 학습으로 실용성 높음&lt;/td>
&lt;td>모든 경우를 고려하지 못할 수 있음&lt;br>예외 케이스 누락 위험&lt;br>과도한 일반화 위험&lt;/td>
&lt;td>수열의 일반항 찾기&lt;br>패턴 인식 문제&lt;br>규칙성 발견&lt;br>데이터 마이닝의 패턴 추출&lt;br>기계 학습의 특징 추출&lt;/td>
&lt;td>패턴 매칭&lt;br>귀납적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>패턴 매칭 (Pattern Matching)&lt;/td>
&lt;td>기존 문제와 유사한 패턴을 식별하고 해결 방법을 응용하며, 문제의 구조적 유사성에 기반한 접근&lt;/td>
&lt;td>기존 해결책을 응용하여 효율적&lt;br>검증된 방법론 활용 가능&lt;br>개발 시간 단축과 신뢰성 확보&lt;/td>
&lt;td>새로운 유형의 문제에 적용하기 어려움&lt;br>패턴 인식의 주관성&lt;br>잘못된 패턴 적용 시 비효율적&lt;/td>
&lt;td>문자열 매칭 알고리즘&lt;br>이미지 처리 문제&lt;br>자연어 처리&lt;br>유사도 기반 추천 시스템&lt;br>패턴 기반 보안 탐지&lt;/td>
&lt;td>예증&lt;br>유추적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>단순화와 일반화 (Simplification and Generalization)&lt;/td>
&lt;td>복잡한 문제를 단순한 형태로 변환한 후 점진적으로 일반화하며, 핵심 요소 추출에 중점&lt;/td>
&lt;td>복잡한 문제를 다루기 쉬워짐&lt;br>핵심 개념 파악 용이&lt;br>단계적 접근으로 검증 가능&lt;/td>
&lt;td>단순화 과정에서 중요한 요소를 놓칠 수 있음&lt;br>일반화 과정의 정확성 검증 필요&lt;br>실제 문제와의 괴리 가능성&lt;/td>
&lt;td>그래프 알고리즘&lt;br>기하학적 문제 해결&lt;br>시스템 모델링&lt;br>추상화 계층 설계&lt;br>복잡한 시스템 단순화&lt;/td>
&lt;td>수학적 모델링&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>귀납적 접근법 (Inductive Approach)&lt;/td>
&lt;td>기본 사례부터 시작하여 수학적 귀납법을 통해 일반적인 해결책으로 확장하며, 논리적 정당성 확보&lt;/td>
&lt;td>논리적 진행과 정확성 보장&lt;br>증명 가능한 해결책 도출&lt;br>체계적인 확장성 제공&lt;/td>
&lt;td>복잡한 귀납 과정 필요&lt;br>기본 사례 선정의 중요성&lt;br>일반화 과정의 복잡성&lt;/td>
&lt;td>재귀 함수 설계&lt;br>알고리즘 정확성 증명&lt;br>수학적 증명&lt;br>형식 검증&lt;br>기계 학습의 귀납적 추론&lt;/td>
&lt;td>예증&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자료구조 선택 (Data Structure Selection)&lt;/td>
&lt;td>문제의 특성과 요구사항을 분석하여 최적의 자료구조를 선택하고, 이를 기반으로 알고리즘 설계&lt;/td>
&lt;td>효율적인 성능 최적화&lt;br>메모리 사용 최적화&lt;br>알고리즘 복잡도 개선&lt;/td>
&lt;td>적절한 자료구조 선택에 시간 소요&lt;br>trade-off 분석 복잡성&lt;br>구현 난이도 증가&lt;/td>
&lt;td>해시 테이블 기반 검색&lt;br>트리 기반 알고리즘&lt;br>분산 데이터 구조&lt;br>빅데이터 처리 구조&lt;br>실시간 데이터 처리&lt;/td>
&lt;td>실험적-분석적 접근&lt;br>수학적 모델링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>상향식/하향식 접근법 (Bottom-up/Top-down)&lt;/td>
&lt;td>상향식: 기본 요소부터 점진적 구축&lt;br>하향식: 전체에서 세부로 분해하며, 두 방식의 상호보완적 활용 강조&lt;/td>
&lt;td>체계적인 문제 분석&lt;br>모듈화된 설계 가능&lt;br>복잡도 관리와 재사용성 향상&lt;/td>
&lt;td>전체 구조 파악의 어려움&lt;br>통합 과정의 복잡성&lt;br>두 접근법 간 균형 필요&lt;/td>
&lt;td>동적 프로그래밍&lt;br>분할 정복&lt;br>마이크로서비스 설계&lt;br>대규모 시스템 구조화&lt;br>복잡한 소프트웨어 아키텍처&lt;/td>
&lt;td>분석적 접근&lt;br>제약 기반 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>휴리스틱/메타휴리스틱 접근 (Heuristic/Metaheuristic)&lt;/td>
&lt;td>경험적 규칙과 직관을 활용한 실용적 해결책 도출(휴리스틱)과 이러한 전략들을 체계적으로 조합하고 제어(메타휴리스틱)&lt;/td>
&lt;td>복잡한 문제의 빠른 해결&lt;br>지역 최적해 탈출 가능&lt;br>유연한 전략 적용&lt;br>계산 비용 조절 가능&lt;/td>
&lt;td>최적해 보장 없음&lt;br>파라미터 튜닝 복잡성&lt;br>성능 예측 어려움&lt;br>휴리스틱 선택의 주관성&lt;/td>
&lt;td>외판원 문제(TSP)&lt;br>유전 알고리즘&lt;br>입자 군집 최적화&lt;br>강화학습&lt;br>진화 알고리즘&lt;/td>
&lt;td>확률적 접근법&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실험적-분석적 접근 (Experimental-Analytical)&lt;/td>
&lt;td>이론적 분석과 실험적 검증을 결합한 종합적 접근 방식으로, 이론과 실제의 균형을 추구&lt;/td>
&lt;td>이론과 실제의 통합적 이해&lt;br>체계적 검증 가능&lt;br>실용적 개선점 발견&lt;br>성능 예측과 검증&lt;/td>
&lt;td>시간과 자원 소모가 큼&lt;br>분석과 실험 설계의 복잡성&lt;br>이론-실제 간 격차 해결 필요&lt;/td>
&lt;td>알고리즘 성능 분석&lt;br>복잡도 검증&lt;br>데이터 기반 최적화&lt;br>벤치마킹&lt;br>성능 프로파일링&lt;/td>
&lt;td>수학적 모델링&lt;br>확률적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수학적 모델링 (Mathematical Modeling)&lt;/td>
&lt;td>문제를 수학적 모델로 형식화하여 체계적으로 접근하며, 이론적 기반 확보&lt;/td>
&lt;td>정확한 분석과 최적화&lt;br>이론적 기반 제공&lt;br>성능 예측 가능&lt;br>형식적 검증 가능&lt;/td>
&lt;td>복잡한 수학적 지식 필요&lt;br>현실 문제 단순화 필요&lt;br>모델 검증의 어려움&lt;/td>
&lt;td>최적화 문제&lt;br>시뮬레이션&lt;br>예측 모델링&lt;br>시스템 성능 분석&lt;br>금융 공학 알고리즘&lt;/td>
&lt;td>분석적 접근&lt;br>제약 기반 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>제약 기반 접근법 (Constraint-Based)&lt;/td>
&lt;td>문제의 제약조건을 중심으로 해결 공간을 체계적으로 정의하고 탐색&lt;/td>
&lt;td>명확한 문제 정의&lt;br>효율적 해공간 축소&lt;br>최적해 보장 가능성&lt;br>문제 범위 명확화&lt;/td>
&lt;td>제약조건 모델링 복잡성&lt;br>제약 충돌 해결&lt;br>확장성 제한&lt;br>과도한 제약 위험&lt;/td>
&lt;td>스케줄링 문제&lt;br>자원 할당&lt;br>제약 만족 문제&lt;br>구성 최적화&lt;br>실시간 제약 처리&lt;/td>
&lt;td>수학적 모델링&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유추적 접근법 (Analogical)&lt;/td>
&lt;td>다른 분야나 유사 문제의 해결 방식을 창의적으로 적용하여 해결책 도출&lt;/td>
&lt;td>창의적 해결책 도출&lt;br>검증된 패턴 활용&lt;br>분야 간 지식 전이&lt;br>혁신적 접근 가능&lt;/td>
&lt;td>부적절한 유추 위험&lt;br>도메인 지식 필요&lt;br>적용 가능성 검증 필요&lt;/td>
&lt;td>생물학적 알고리즘&lt;br>자연 현상 모방&lt;br>학제 간 문제 해결&lt;br>혁신적 알고리즘&lt;br>창의적 문제 해결&lt;/td>
&lt;td>패턴 매칭&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>변환적 접근 (Transformational)&lt;/td>
&lt;td>주어진 문제를 해결된 다른 형태로 변환하여 해결하며, 문제 간 관계성 활용&lt;/td>
&lt;td>검증된 해결책 활용&lt;br>문제 해결의 효율성&lt;br>기존 알고리즘 재사용&lt;br>문제 단순화 가능&lt;/td>
&lt;td>변환 과정의 오버헤드&lt;br>최적성 보장 어려움&lt;br>역변환 과정의 정확성&lt;/td>
&lt;td>NP 문제 변환&lt;br>그래프 변환&lt;br>컴파일러 최적화&lt;br>도메인 변환&lt;br>문제 재구성&lt;/td>
&lt;td>단순화와 일반화&lt;br>유추적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확률적 접근법 (Probabilistic)&lt;/td>
&lt;td>확률 이론과 통계적 방법을 활용하여 불확실성을 고려한 해결책 도출&lt;/td>
&lt;td>불확실성 체계적 처리&lt;br>리스크 분석 가능&lt;br>실제 환경 적합성&lt;br>확장성 높음&lt;/td>
&lt;td>확률 모델 설계 복잡성&lt;br>데이터 의존성&lt;br>정확성 보장의 어려움&lt;/td>
&lt;td>몬테카를로 방법&lt;br>확률적 알고리즘&lt;br>베이지안 최적화&lt;br>불확실성 모델링&lt;br>기계 학습 알고리즘&lt;/td>
&lt;td>휴리스틱 접근&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>접근법들 간의 관계&lt;span class="hx-absolute -hx-mt-20" id="접근법들-간의-관계">&lt;/span>
&lt;a href="#%ec%a0%91%ea%b7%bc%eb%b2%95%eb%93%a4-%ea%b0%84%ec%9d%98-%ea%b4%80%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;pre class="mermaid hx-mt-6">flowchart TD
subgraph Problem_Analysis["문제 분석 단계"]
EX[예증 Exemplification]
PM[패턴 매칭 Pattern Matching]
SG[단순화와 일반화 Simplification &amp; Generalization]
end
subgraph Solution_Design["해결책 설계 단계"]
DS[자료구조 선택 Data Structure Selection]
BT[상향식/하향식 Bottom-up/Top-down]
BR[역방향 추론 Backward Reasoning]
IA[귀납적 접근 Inductive Approach]
end
subgraph Solution_Methods["해결 방법론"]
HM[휴리스틱/메타휴리스틱 Heuristic/Metaheuristic]
MM[수학적 모델링 Mathematical Modeling]
EA[실험적-분석적 Experimental-Analytical]
PA[확률적 접근 Probabilistic]
end
subgraph Advanced_Approaches["고급 접근법"]
TA[변환적 접근 Transformational]
CA[제약 기반 Constraint-Based]
AA[유추적 접근 Analogical]
end
EX &lt;--> PM
PM &lt;--> SG
SG &lt;--> DS
DS &lt;--> BT
BT &lt;--> BR
BR &lt;--> HM
HM &lt;--> MM
MM &lt;--> EA
EA &lt;--> PA
PA &lt;--> TA
TA &lt;--> CA
CA &lt;--> AA
Problem_Analysis &lt;--> Solution_Design
Solution_Design &lt;--> Solution_Methods
Solution_Methods &lt;--> Advanced_Approaches
style Problem_Analysis fill:#e6f3ff,stroke:#333,stroke-width:2px
style Solution_Design fill:#f0fff0,stroke:#333,stroke-width:2px
style Solution_Methods fill:#fff0f5,stroke:#333,stroke-width:2px
style Advanced_Approaches fill:#fff5e6,stroke:#333,stroke-width:2px&lt;/pre>&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>근사 알고리즘 (Approximation algorithm)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</link><pubDate>Thu, 31 Oct 2024 05:23:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</guid><description>
&lt;h2>근사 알고리즘 (Approximation algorithm)&lt;span class="hx-absolute -hx-mt-20" id="근사-알고리즘-approximation-algorithm">&lt;/span>
&lt;a href="#%ea%b7%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-approximation-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>컴퓨터 과학에서 우리가 마주치는 많은 문제들 중에는 정확한 해답을 찾는 것이 현실적으로 매우 어려운 문제들이 있다.&lt;br>
예를 들어, 외판원 문제(Traveling Salesman Problem)는 도시들을 모두 한 번씩만 방문하면서 가장 짧은 경로를 찾는 문제인데, 도시의 수가 증가하면 가능한 모든 경로를 확인하는 데 너무 많은 시간이 걸린다.&lt;/p>
&lt;p>이런 상황에서 우리는 다음과 같은 선택을 할 수 있다:&lt;/p>
&lt;ol>
&lt;li>정확한 해답을 찾되 매우 오랜 시간이 걸리는 것을 감수한다&lt;/li>
&lt;li>정확하지는 않지만 &amp;lsquo;충분히 좋은&amp;rsquo; 해답을 빠르게 찾는다&lt;br>
근사 알고리즘은 두 번째 접근 방식을 택한다.&lt;/li>
&lt;/ol>
&lt;p>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &amp;lsquo;충분히 가까운&amp;rsquo; 해답을 찾는 알고리즘이다.&lt;br>
여기서 중요한 점은 근사 알고리즘이 얼마나 좋은 해답을 찾을 수 있는지 수학적으로 보장한다는 것이다.&lt;br>
예를 들어, &amp;ldquo;이 알고리즘은 항상 최적해의 1.5배 이내의 해답을 찾는다&amp;quot;와 같이 성능을 보장할 수 있다.&lt;/p>
&lt;p>이 기법은 특히 NP-난해(NP-hard) 문제와 같이 정확한 해를 다항 시간 내에 찾기 어려운 문제들을 다룰 때 유용하다.&lt;/p>
&lt;p>근사 알고리즘은 다음과 같은 특징을 가진다:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>최적해의 근사값 제공&lt;/strong>: 정확한 최적해 대신 그에 근접한 해답을 찾는다.&lt;/li>
&lt;li>&lt;strong>다항 시간 내 실행&lt;/strong>: 효율적으로 실행되어 빠른 시간 내에 결과를 제공한다.&lt;/li>
&lt;li>&lt;strong>성능 보장&lt;/strong>: 찾은 해답이 최적해와 얼마나 차이 나는지에 대한 이론적 보장을 제공한다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>근사 알고리즘의 주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>정확한 최적해를 찾는 대신 합리적인 시간 내에 &amp;lsquo;충분히 좋은&amp;rsquo; 해답을 제공한다.&lt;/li>
&lt;li>NP-난해 문제와 같이 다항 시간 내에 최적해를 찾기 어려운 문제에 대한 실용적인 해결책을 제시한다.&lt;/li>
&lt;/ol>
&lt;p>근사 알고리즘이 필요한 이유는 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>많은 실제 문제들이 NP-난해하여 정확한 해답을 효율적으로 찾기 어렵다.&lt;/li>
&lt;li>대규모 데이터를 다루는 현대 응용에서는 빠른 해답이 필요한 경우가 많다.&lt;/li>
&lt;li>일부 상황에서는 최적해가 아니더라도 &amp;lsquo;충분히 좋은&amp;rsquo; 해답으로 만족할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>근사 알고리즘의 필요성&lt;span class="hx-absolute -hx-mt-20" id="근사-알고리즘의-필요성">&lt;/span>
&lt;a href="#%ea%b7%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>근사 알고리즘이 필요한 이유는 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>NP-난해 문제 해결&lt;/strong>: 많은 최적화 문제들이 NP-난해(NP-hard)하여 다항 시간 내에 정확한 해답을 찾기 어렵다.&lt;/li>
&lt;li>&lt;strong>실용적인 해결책 제공&lt;/strong>: 빠른 시간 내에 &amp;lsquo;충분히 좋은&amp;rsquo; 해답을 찾아 실제 문제에 적용할 수 있다.&lt;/li>
&lt;li>&lt;strong>계산 자원의 효율적 사용&lt;/strong>: 제한된 시간과 메모리로 복잡한 문제를 해결할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>근사 알고리즘의 장단점&lt;span class="hx-absolute -hx-mt-20" id="근사-알고리즘의-장단점">&lt;/span>
&lt;a href="#%ea%b7%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%9e%a5%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>실행 시간이 빠르다.&lt;/li>
&lt;li>해답의 품질을 수학적으로 보장한다.&lt;/li>
&lt;li>대규모 문제에 적용 가능하다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>정확한 최적해를 찾지는 못한다.&lt;/li>
&lt;li>모든 문제에 대해 좋은 근사 알고리즘이 존재하는 것은 아니다.&lt;/li>
&lt;/ol>
&lt;h3>특성과 핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="특성과-핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1%ea%b3%bc-%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>근사 알고리즘의 주요 특성은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>근사 비율(Approximation Ratio): 알고리즘이 찾은 해답의 값을 A라 하고, 최적해의 값을 OPT라 할 때, 근사 비율 α는 다음과 같이 정의다:
&lt;ul>
&lt;li>최소화 문제의 경우: A ≤ α × OPT&lt;/li>
&lt;li>최대화 문제의 경우: A ≥ (1/α) × OPT&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>성능 보장(Performance Guarantee): 근사 알고리즘은 찾은 해답이 최적해와 얼마나 차이가 날 수 있는지에 대한 이론적 상한을 제공한다. 이는 알고리즘의 품질을 평가하는 중요한 지표가 된다.&lt;/li>
&lt;li>다항 시간 복잡도: 근사 알고리즘은 문제의 크기에 대해 다항 시간 내에 실행되어야 한다.&lt;/li>
&lt;/ol>
&lt;h3>근사 알고리즘의 작동 원리&lt;span class="hx-absolute -hx-mt-20" id="근사-알고리즘의-작동-원리">&lt;/span>
&lt;a href="#%ea%b7%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>근사 알고리즘의 핵심 원리는 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>근사비(Approximation ratio)&lt;/strong>: 알고리즘이 찾은 해의 품질을 측정하는 지표이다. 최적해와 근사해의 비율로 표현된다..&lt;/li>
&lt;li>&lt;strong>탐욕적 선택(Greedy choice)&lt;/strong>: 각 단계에서 지역적으로 최선의 선택을 한다. 이는 항상 전체적인 최적해를 보장하지는 않지만, 많은 경우 좋은 근사해를 제공한다.&lt;/li>
&lt;li>&lt;strong>반복적 개선&lt;/strong>: 초기 해답을 점진적으로 개선하여 더 나은 근사해를 찾는다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 근사 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-근사-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ea%b7%bc%ec%82%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>좋은 근사 알고리즘은 다음과 같은 특성을 가져야 한다:&lt;/p>
&lt;ol>
&lt;li>효율성: 빠른 실행 시간을 가져야 한다&lt;/li>
&lt;li>정확성: 근사 비율이 작아야 한다 (최적해에 가까운 해답을 찾아야 함)&lt;/li>
&lt;li>안정성: 입력이 조금 변경되어도 결과가 크게 달라지지 않아야 한다&lt;/li>
&lt;li>단순성: 이해하고 구현하기 쉬워야 한다다&lt;/li>
&lt;/ol>
&lt;h3>예시 코드&lt;span class="hx-absolute -hx-mt-20" id="예시-코드">&lt;/span>
&lt;a href="#%ec%98%88%ec%8b%9c-%ec%bd%94%eb%93%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>집합 커버 문제(Set Cover Problem)&lt;span class="hx-absolute -hx-mt-20" id="집합-커버-문제set-cover-problem">&lt;/span>
&lt;a href="#%ec%a7%91%ed%95%a9-%ec%bb%a4%eb%b2%84-%eb%ac%b8%ec%a0%9cset-cover-problem" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;blockquote>
&lt;p>집합 커버 문제(Set Cover Problem)&amp;gt;&lt;/p>
&lt;ul>
&lt;li>직관적인 이해&lt;br>
도서관에서 독서 모임을 운영하는 상황을 생각해보자.&lt;br>
100명의 회원들이 각자 다른 시간대에 참석 가능하다고 할 때, 모든 회원이 최소 하나의 모임에 참석할 수 있도록 하는 최소 개수의 모임 시간을 정하는 것이 집합 커버 문제의 한 예시이다.&lt;/li>
&lt;li>수학적 정의&lt;br>
집합 커버 문제는 다음과 같이 정의된다:
&lt;ul>
&lt;li>전체 집합 U (universe)가 주어진다.&lt;/li>
&lt;li>U의 부분집합들의 모음 F = {S1, S2, …, Sm}가 주어진다.&lt;/li>
&lt;li>목표는 F의 부분집합들 중 가능한 한 적은 수의 집합을 선택하여 U의 모든 원소를 커버하는 것.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>신도시 학교 배치 문제: 10개의 마을로 구성된 신도시에 학교를 배치하는 문제.&lt;/p>
&lt;ul>
&lt;li>전체 집합 U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} (마을 번호)&lt;/li>
&lt;li>부분집합 F = {S1, S2, S3, S4, S5, S6, S7, S8, S9, S10}
&lt;ul>
&lt;li>여기서 각 Si는 해당 마을에 학교를 지었을 때 15분 이내에 등교 가능한 마을들의 집합이다.&lt;/li>
&lt;li>예를 들어:
&lt;ul>
&lt;li>S1 = {1, 2, 3, 8}&lt;/li>
&lt;li>S2 = {1, 2, 3, 4, 8}&lt;/li>
&lt;li>S3 = {1, 2, 3, 4}&lt;/li>
&lt;li>S4 = {2, 3, 4, 5, 7, 8}&lt;/li>
&lt;li>S5 = {4, 5, 6, 7}&lt;/li>
&lt;li>S6 = {5, 6, 7, 9, 10}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>목표는 모든 마을을 커버하는 최소 개수의 부분집합(즉, 학교 위치)을 찾는 것이다.&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 탐욕적 방법으로 집합 커버 문제를 해결하는 함수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># universe: 전체 집합 (모든 마을들)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># subsets: 각 학교 위치별로 15분 내 통학 가능한 마을들의 집합을 담은 리스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">greedy_set_cover&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">universe&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">subsets&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 아직 학교가 배정되지 않은 마을들을 추적하기 위한 집합&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 처음에는 모든 마을이 미배정 상태&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uncovered&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">universe&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 선택된 학교 위치들(부분집합들)을 저장할 리스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cover&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모든 마을이 학교에 배정될 때까지 반복&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">uncovered&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 미배정된 마을들 중에서 가장 많은 마을을 커버할 수 있는 학교 위치 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># key 함수는 각 부분집합과 미배정 마을들의 교집합 크기를 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 즉, 해당 위치에 학교를 지었을 때 새롭게 커버되는 마을의 수를 계산&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_subset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">subsets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uncovered&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 선택된 학교 위치를 결과 리스트에 추가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cover&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">best_subset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 선택된 학교가 커버하는 마을들을 미배정 집합에서 제거&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># -= 연산자는 차집합 연산을 수행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uncovered&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">best_subset&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 이미 선택된 학교 위치는 다시 선택되지 않도록 후보 리스트에서 제거&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">best_subset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 선택된 모든 학교 위치들의 리스트 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cover&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트를 위한 입력 데이터 설정&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># universe: 1부터 10까지의 모든 마을 번호&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">universe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># subsets: 각 위치에 학교를 지었을 때 15분 내 통학 가능한 마을들의 집합&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 예: 첫 번째 집합 {1, 2, 3, 8}은 1번 위치에 학교를 지으면&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1, 2, 3, 8번 마을의 학생들이 15분 내 통학 가능함을 의미&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">subsets&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 1번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 2번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 3번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">},&lt;/span>&lt;span class="c1"># 4번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 5번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 6번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 7번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 8번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="c1"># 9번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="c1"># 10번 위치의 학교가 커버하는 마을들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 알고리즘 실행 및 결과 출력&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cover&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">greedy_set_cover&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">universe&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">subsets&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Approximate Set Cover:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cover&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 알고리즘은 다음과 같이 작동한다:&lt;/p>
&lt;ol>
&lt;li>아직 커버되지 않은 원소를 가장 많이 포함하는 부분집합을 선택한다.&lt;/li>
&lt;li>선택된 부분집합의 원소들을 커버된 것으로 표시한다.&lt;/li>
&lt;li>모든 원소가 커버될 때까지 1-2를 반복한다.&lt;/li>
&lt;/ol>
&lt;h4>Bin Packing Problem(빈 포장 문제)&lt;span class="hx-absolute -hx-mt-20" id="bin-packing-problem빈-포장-문제">&lt;/span>
&lt;a href="#bin-packing-problem%eb%b9%88-%ed%8f%ac%ec%9e%a5-%eb%ac%b8%ec%a0%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>빈 포장 문제는 주어진 크기의 여러 물건들을 동일한 크기의 빈(컨테이너)에 모두 넣으려고 할 때, 필요한 최소한의 빈 개수를 찾는 문제.&lt;br>
이는 NP-hard 문제이므로, 근사 알고리즘을 사용하여 해결하는 것이 효율적이다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Bin&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 빈(컨테이너) 객체를 초기화합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> capacity (float): 빈의 최대 용량
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="c1"># 빈의 최대 용량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span> &lt;span class="c1"># 빈에 담긴 아이템들을 저장하는 리스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">used_capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1"># 현재 사용된 용량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">can_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주어진 아이템을 현재 빈에 추가할 수 있는지 확인합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> item (float): 추가하려는 아이템의 크기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> bool: 아이템 추가 가능 여부
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">used_capacity&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 빈에 아이템을 추가합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> item (float): 추가할 아이템의 크기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> bool: 아이템 추가 성공 여부
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">can_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">used_capacity&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">item&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">first_fit_decreasing&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bin_capacity&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> First-Fit Decreasing 알고리즘을 사용하여 빈 포장 문제를 해결합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 이 알고리즘은 항상 최적해의 1.7배 이내의 해답을 보장합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> items (list): 포장할 아이템들의 크기 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> bin_capacity (float): 각 빈의 용량
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> list: 사용된 빈들의 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 아이템들을 내림차순으로 정렬&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sorted_items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">sorted&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">reverse&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 첫 번째 빈을 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bins&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">Bin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bin_capacity&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 각 아이템에 대해&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">sorted_items&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 아이템이 빈의 용량보다 큰 경우 처리 불가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">bin_capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="ne">ValueError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;Item size &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> exceeds bin capacity &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">bin_capacity&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기존 빈에 아이템을 넣을 수 있는지 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">item_packed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nb">bin&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">bins&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">bin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">item_packed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기존 빈에 넣을 수 없다면 새로운 빈 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">item_packed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_bin&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Bin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bin_capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_bin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bins&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_bin&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">bins&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 알고리즘 사용 예시&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">print_packing_solution&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bins&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 빈 포장 결과를 출력합니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> bins (list): 사용된 빈들의 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;총 사용된 빈의 개수: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bins&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">bin&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bins&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">빈 &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;사용된 용량: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">bin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">used_capacity&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">/&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">bin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;담긴 아이템들: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">bin&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 데이터 준비&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bin_capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 알고리즘 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result_bins&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first_fit_decreasing&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bin_capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 결과 출력&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">=== 빈 포장 문제 해결 결과 ===&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;전체 아이템: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;빈 용량: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">bin_capacity&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print_packing_solution&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result_bins&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">except&lt;/span> &lt;span class="ne">ValueError&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;오류 발생: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">****&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 코드는 다음과 같은 특징과 장점이 있다:&lt;/p>
&lt;ol>
&lt;li>근사 알고리즘 특성:
&lt;ul>
&lt;li>First-Fit Decreasing 방식은 이론적으로 최적해의 1.7배 이내의 해답을 보장한다.&lt;/li>
&lt;li>실제로는 대부분의 경우 이보다 더 좋은 결과를 얻을 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구현 방식:
&lt;ul>
&lt;li>아이템들을 내림차순으로 정렬하여 큰 아이템부터 처리한다.&lt;/li>
&lt;li>각 아이템에 대해 첫 번째로 들어갈 수 있는 빈을 찾아 배치한다.&lt;/li>
&lt;li>기존 빈에 넣을 수 없는 경우 새로운 빈을 생성한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>코드 구조:
&lt;ul>
&lt;li>&lt;code>Bin&lt;/code> 클래스로 각 컨테이너의 상태를 관리한다.&lt;/li>
&lt;li>메인 알고리즘은 &lt;code>first_fit_decreasing&lt;/code> 함수에 구현되어 있다.&lt;/li>
&lt;li>결과 출력을 위한 보조 함수도 포함되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>동적 계획법 (Dynamic Programming)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/</link><pubDate>Thu, 31 Oct 2024 05:23:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/</guid><description>
&lt;h2>동적 계획법 (Dynamic Programming, DP)&lt;span class="hx-absolute -hx-mt-20" id="동적-계획법-dynamic-programming-dp">&lt;/span>
&lt;a href="#%eb%8f%99%ec%a0%81-%ea%b3%84%ed%9a%8d%eb%b2%95-dynamic-programming-dp" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다. 이 기법은 중복되는 계산을 줄이고 효율성을 높이는 데 중점을 둔다.&lt;/p>
&lt;p>&lt;img src="1_11q5g7hUiSwhQquyfXDXUg.png" alt="Dynamic Programming" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.enjoyalgorithms.com/blog/introduction-to-dynamic-programming" target="_blank" rel="noopener">https://www.enjoyalgorithms.com/blog/introduction-to-dynamic-programming&lt;/a> _&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>최적 부분 구조(Optimal Substructure): 큰 문제의 최적해가 작은 문제의 최적해로 구성된다.&lt;/li>
&lt;li>중복되는 부분 문제(Overlapping Subproblems): 동일한 작은 문제들이 반복해서 나타난다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>동적 계획법의 주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>복잡한 문제를 효율적으로 해결하기&lt;/li>
&lt;li>중복 계산을 줄여 실행 시간 단축하기&lt;/li>
&lt;li>최적화 문제에서 전역 최적해 찾기&lt;br>
이 기법은 재귀적 해결 방식으로는 시간이 너무 오래 걸리는 문제들을 해결하는 데 필요하다.&lt;/li>
&lt;/ol>
&lt;h3>장단점&lt;span class="hx-absolute -hx-mt-20" id="장단점">&lt;/span>
&lt;a href="#%ec%9e%a5%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>실행 시간 단축&lt;/li>
&lt;li>복잡한 문제를 체계적으로 해결&lt;/li>
&lt;li>최적해 보장&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>메모리 사용량 증가&lt;/li>
&lt;li>모든 문제에 적용할 수 없음&lt;/li>
&lt;li>구현이 복잡할 수 있음&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제를 더 작은 하위 문제로 나눈다.&lt;/li>
&lt;li>가장 작은 하위 문제부터 해결하기 시작한다.&lt;/li>
&lt;li>해결한 하위 문제의 결과를 저장한다(메모이제이션).&lt;/li>
&lt;li>저장된 결과를 이용해 더 큰 문제를 해결한다.&lt;/li>
&lt;li>최종적으로 원래 문제의 해답을 얻는다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제를 적절히 하위 문제로 나눌 수 있어야 한다.&lt;/li>
&lt;li>중복 계산을 효과적으로 제거해야 한다.&lt;/li>
&lt;li>메모리 사용과 실행 시간 사이의 균형을 잘 맞춰야 한다.&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>메모이제이션을 적극 활용하자.&lt;/li>
&lt;li>반복문을 사용한 상향식(Bottom-up) 방식을 고려하자.&lt;/li>
&lt;li>필요한 결과만 저장하여 메모리를 절약하자.&lt;/li>
&lt;li>문제의 특성에 따라 1차원 또는 다차원 배열을 적절히 선택하자.&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>상태(State): 각 하위 문제를 표현하는 변수들&lt;/li>
&lt;li>점화식(Recurrence Relation): 하위 문제 간의 관계를 나타내는 식&lt;/li>
&lt;li>기저 사례(Base Case): 가장 작은 하위 문제의 해답&lt;/li>
&lt;li>메모이제이션(Memoization): 계산된 결과를 저장하는 기법&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>최장 증가 부분 수열(Longest Increasing Subsequence, LIS)&lt;/p>
&lt;ul>
&lt;li>최장 증가 부분 수열은 주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 의미한다.&lt;/li>
&lt;li>여기서 &amp;lsquo;부분 수열&amp;rsquo;은 원래 수열에서 몇 개의 숫자를 선택하여 순서를 유지한 채 만든 수열을 말한다.&lt;br>
예를 들어, 수열 &lt;code>[10, 22, 9, 33, 21, 50, 41, 60, 80]&lt;/code>을 살펴보자.&lt;br>
이 수열의 최장 증가 부분 수열은 &lt;code>[10, 22, 33, 50, 60, 80]&lt;/code>이다.&lt;br>
이 부분 수열은 원래 수열에서 숫자들의 상대적 순서를 유지하면서, 각 숫자가 이전 숫자보다 큰(증가하는) 가장 긴 수열이다.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>최장 증가 부분 수열(Longest Increasing Subsequence, LIS):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">longest_increasing_subsequence&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주어진 배열에서 최장 증가 부분 수열의 길이를 찾는 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 예시:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 입력: [10, 22, 9, 33, 21, 50, 41, 60, 80]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 출력: 6 (증가 수열: 10 -&amp;gt; 22 -&amp;gt; 33 -&amp;gt; 50 -&amp;gt; 60 -&amp;gt; 80)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> arr (list): 정수 배열
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> tuple: (최장 증가 부분 수열의 길이, 해당 수열)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># dp[i]는 arr[i]로 끝나는 최장 증가 부분 수열의 길이&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 각 위치에서 이전 요소 중 어떤 것을 선택했는지 추적&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 각 위치에 대해&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 위치 이전의 모든 요소들을 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 숫자가 이전 숫자보다 크고&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 이전 숫자로 끝나는 수열에 현재 숫자를 추가했을 때 더 긴 수열이 된다면&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># 길이 갱신&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prev&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="c1"># 이전 위치 저장&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 최장 길이와 그 위치 찾기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">max_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max_length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 실제 수열 재구성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sequence&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">last_pos&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sequence&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">last_pos&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">prev&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">last_pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">max_length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence&lt;/span>&lt;span class="p">[::&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 수열을 역순으로 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">test_lis&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 케이스&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_cases&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">22&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">33&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">50&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">41&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">60&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">test_cases&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">longest_increasing_subsequence&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;배열: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;최장 증가 부분 수열의 길이: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;해당 수열: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">sequence&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;-&amp;#34;&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">50&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_lis&lt;/span>&lt;span class="p">()&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 코드는 동적 계획법의 주요 특성을 잘 보여준다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>최적 부분 구조:&lt;br>
길이 i인 최장 증가 부분 수열은 길이 i-1인 최장 증가 부분 수열에 새로운 원소를 추가하여 만들어진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>중복되는 부분 문제:&lt;br>
각 위치에서 끝나는 최장 증가 부분 수열은 여러 번 계산될 수 있다.&lt;br>
DP 배열에 저장함으로써 중복 계산을 피한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>상태 정의:&lt;/p>
&lt;ul>
&lt;li>dp[i]: arr[i]로 끝나는 최장 증가 부분 수열의 길이&lt;/li>
&lt;li>prev[i]: 최장 수열에서 arr[i] 이전에 오는 원소의 인덱스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>점화식:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;p>이 구현은 O(n²) 시간 복잡도를 가지며, 실제 수열까지 추적할 수 있도록 구현되어 있다.&lt;br>
실행하면 다양한 테스트 케이스에 대해 최장 증가 부분 수열의 길이와 해당 수열을 확인할 수 있다.&lt;/p>
&lt;p>이 예제는 동적 계획법의 다음과 같은 중요한 특징들을 보여준다:&lt;/p>
&lt;ol>
&lt;li>부분 문제의 결과를 저장하고 재사용&lt;/li>
&lt;li>작은 문제부터 큰 문제로의 점진적 해결&lt;/li>
&lt;li>이전 상태를 바탕으로 현재 상태를 계산&lt;/li>
&lt;li>최적해의 실제 구성 요소 추적 가능&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>백트래킹 (Backtracking)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</link><pubDate>Thu, 31 Oct 2024 05:23:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</guid><description>
&lt;h2>백트래킹 (Backtracking)&lt;span class="hx-absolute -hx-mt-20" id="백트래킹-backtracking">&lt;/span>
&lt;a href="#%eb%b0%b1%ed%8a%b8%eb%9e%98%ed%82%b9-backtracking" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>백트래킹은 &amp;lsquo;되돌아가기&amp;rsquo;라는 의미를 가지고 있다.&lt;br>
백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.&lt;br>
이 알고리즘은 문제의 해결책을 찾기 위해 가능한 모든 경우의 수를 체계적으로 탐색하는 방법이다.&lt;/p>
&lt;p>백트래킹의 핵심 아이디어는 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>해결책을 찾아가는 과정에서 여러 선택지를 순차적으로 시도한다.&lt;/li>
&lt;li>현재의 선택이 해결책으로 이어질 가능성이 없다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다.&lt;/li>
&lt;li>이 과정을 반복하여 최종적으로 해결책을 찾거나, 모든 가능성을 탐색한다.&lt;/li>
&lt;/ol>
&lt;p>백트래킹은 단순한 완전 탐색(Exhaustive Search)과는 다르다.&lt;br>
백트래킹은 현재의 선택이 유망한지(promising) 판단하여, 유망하지 않다면 더 이상 그 방향으로 탐색하지 않고 이전 단계로 돌아간다. 이를 &amp;lsquo;가지치기(pruning)&amp;lsquo;라고 한다.&lt;/p>
&lt;p>
&lt;img src="../backtracking.png" alt="Backtracking" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/introduction-to-backtracking-2/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/introduction-to-backtracking-2/&lt;/a> _&lt;/p>
&lt;ul>
&lt;li>그림에서 보여지는 것처럼,
&lt;ul>
&lt;li>&lt;strong>IS&lt;/strong>: 재귀 호출이 유효한 솔루션을 찾기 시작하는 &lt;strong>초기 상태&lt;/strong>를 나타낸다.&lt;/li>
&lt;li>&lt;strong>C&lt;/strong>: 재귀 호출에 대한 다른 &lt;strong>&lt;strong>체크포인트를&lt;/strong>&lt;/strong> 나타낸다.&lt;/li>
&lt;li>&lt;strong>TN&lt;/strong>: 더 이상 재귀 호출을 할 수 없는 &lt;strong>&lt;strong>터미널 노드를&lt;/strong>&lt;/strong> 나타낸다. 이러한 노드는 재귀의 기본 사례로 작용하며 이 상태에서 현재 솔루션이 유효한지 여부를 판별한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각 체크포인트에서 프로그램은 몇 가지 결정을 내리고 다른 체크포인트로 이동하여 최종 노드에 도달한 후, 솔루션이 유효한지 여부를 확인한 후 프로그램은 체크포인트로 돌아가 다른 경로를 탐색하기 시작한다.&lt;br>
예를 들어 위의 이미지에서 &lt;strong>&lt;strong>TN1…TN5&lt;/strong>&lt;/strong> 는 솔루션이 허용되지 않는 최종 노드이고, &lt;strong>&lt;strong>TN6&lt;/strong>&lt;/strong> 은 유효한 솔루션을 찾은 상태이다.&lt;/li>
&lt;li>이미지 속 뒤로 가는 화살표는 동작의 후퇴를 보여주며, 어떤 체크포인트에서 변경한 내용을 되돌리는 것을 의미한다.&lt;/li>
&lt;/ul>
&lt;h3>백트래킹의 작동 원리&lt;span class="hx-absolute -hx-mt-20" id="백트래킹의-작동-원리">&lt;/span>
&lt;a href="#%eb%b0%b1%ed%8a%b8%eb%9e%98%ed%82%b9%ec%9d%98-%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>백트래킹 알고리즘은 주로 깊이 우선 탐색(DFS) 방식을 사용하여 구현된다.&lt;br>
작동 원리는 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>시작 상태에서 출발한다.&lt;/li>
&lt;li>현재 상태에서 가능한 모든 선택지를 확인한다.&lt;/li>
&lt;li>선택지 중 하나를 선택하여 다음 단계로 진행한다.&lt;/li>
&lt;li>선택한 경로가 해결책으로 이어질 가능성이 있는지 검사한다(이를 &amp;lsquo;유망성 검사&amp;rsquo;라고 한다).&lt;/li>
&lt;li>유망하지 않다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다(이를 &lt;strong>&amp;lsquo;백트래킹&amp;rsquo;&lt;/strong> 이라고 한다).&lt;/li>
&lt;li>해결책을 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다.&lt;/li>
&lt;/ol>
&lt;h3>백트래킹의 장단점&lt;span class="hx-absolute -hx-mt-20" id="백트래킹의-장단점">&lt;/span>
&lt;a href="#%eb%b0%b1%ed%8a%b8%eb%9e%98%ed%82%b9%ec%9d%98-%ec%9e%a5%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>모든 가능한 해결책을 체계적으로 탐색할 수 있다.&lt;/li>
&lt;li>불필요한 탐색을 줄여 효율성을 높일 수 있다.&lt;/li>
&lt;li>복잡한 문제에 대해 해결책이 존재하는지 여부를 확실히 알 수 있다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>최악의 경우 모든 경우의 수를 탐색해야 하므로 시간이 오래 걸릴 수 있다.&lt;/li>
&lt;li>문제의 크기가 커질수록 탐색해야 할 경우의 수가 기하급수적으로 증가할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>백트래킹 구현의 기본 구조&lt;span class="hx-absolute -hx-mt-20" id="백트래킹-구현의-기본-구조">&lt;/span>
&lt;a href="#%eb%b0%b1%ed%8a%b8%eb%9e%98%ed%82%b9-%ea%b5%ac%ed%98%84%ec%9d%98-%ea%b8%b0%eb%b3%b8-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>백트래킹은 주로 재귀 함수를 사용하여 구현한다.&lt;br>
기본적인 구조는 다음과 같다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>function backtrack(현재 상태):
if 해결책을 찾았다면:
해결책 반환
for 가능한 각 선택지에 대해:
if 선택이 유망하다면:
선택을 적용
backtrack(새로운 상태)
선택을 취소 (백트래킹)&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이러한 구조를 통해 모든 가능한 경우를 체계적으로 탐색하면서, 불필요한 탐색을 줄일 수 있다.&lt;/p>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효과적인 가지치기 조건&lt;/li>
&lt;li>명확한 상태 표현&lt;/li>
&lt;li>효율적인 유망성 검사&lt;/li>
&lt;li>적절한 재귀 구조&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>가지치기 조건을 최대한 일찍 적용&lt;/li>
&lt;li>상태를 효율적으로 표현하고 관리&lt;/li>
&lt;li>메모이제이션 기법 활용 고려&lt;/li>
&lt;li>반복문 대신 비트마스크 사용 검토&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>N-Queen 문제를 통해 백트래킹을 이해해보자.&lt;br>
이 문제는 N×N 크기의 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제이다.&lt;/p>
&lt;p>다음은 4-Queen 문제를 해결하는 파이썬 코드:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_safe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 같은 열에 퀸이 있는지 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 왼쪽 위 대각선 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">zip&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 오른쪽 위 대각선 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">zip&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">solve_n_queens&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">backtrack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모든 퀸을 배치했다면 성공&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 행의 각 열에 퀸을 놓아보기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">col&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">is_safe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 퀸을 배치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 다음 행으로 진행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">backtrack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 실패하면 퀸을 제거(백트래킹)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 체스판 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">board&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)]&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">backtrack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예시&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">solution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">solve_n_queens&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">solution&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 코드에서 백트래킹의 핵심 요소들을 볼 수 있다:&lt;/p>
&lt;ul>
&lt;li>선택: 각 행에서 퀸을 놓을 열을 선택한다.&lt;/li>
&lt;li>제약 조건 검사: is_safe 함수로 퀸이 서로 공격할 수 없는 위치인지 확인한다.&lt;/li>
&lt;li>백트래킹: 현재 선택이 해결책으로 이어지지 않으면 퀸을 제거하고 다른 위치를 시도한다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>분기 한정법 (Branch and Bound)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</link><pubDate>Thu, 31 Oct 2024 05:23:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</guid><description>
&lt;h2>분기 한정법 (Branch and Bound)&lt;span class="hx-absolute -hx-mt-20" id="분기-한정법-branch-and-bound">&lt;/span>
&lt;a href="#%eb%b6%84%ea%b8%b0-%ed%95%9c%ec%a0%95%eb%b2%95-branch-and-bound" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.&lt;br>
이 방법은 가능한 모든 해를 체계적으로 탐색하면서도 불필요한 탐색을 줄이는 것이 특징이다.&lt;/p>
&lt;p>분기 한정법은 두 가지 주요 개념을 기반으로 한다:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>분기(Branch)&lt;/strong>: 문제를 더 작은 하위 문제로 나누는 과정.&lt;/li>
&lt;li>&lt;strong>한정(Bound)&lt;/strong>: 각 하위 문제의 잠재적인 해결책의 품질을 평가하는 과정.&lt;br>
이 방법은 상태 공간 트리를 사용하여 모든 가능한 해결책을 체계적으로 탐색한다.&lt;/li>
&lt;/ol>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분기(Branching): 문제를 더 작은 하위 문제로 나눈다.
&lt;ul>
&lt;li>각 분기는 겹치지 않는 부분 문제들을 만든다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>한정(Bounding): 각 하위 문제의 해의 범위를 추정한다.
&lt;ul>
&lt;li>상한(upper bound)과 하한(lower bound)을 계산한다.&lt;/li>
&lt;li>유망하지 않은 분기는 더 이상 탐색하지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가지치기(Pruning): 최적해가 될 수 없는 하위 문제를 제거한다.&lt;/li>
&lt;li>상태 공간 트리(State Space Tree) 사용: 가능한 해들을 트리 구조로 표현한다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>분기 한정법의 주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>복잡한 최적화 문제의 최적해를 찾기&lt;/li>
&lt;li>불필요한 탐색을 줄여 효율적으로 해를 찾기&lt;/li>
&lt;li>NP-난해 문제에 대한 실용적인 해결책 제공&lt;br>
이 방법은 완전 탐색으로는 시간이 너무 오래 걸리는 문제들을 효율적으로 해결할 수 있어 필요하다.&lt;/li>
&lt;/ol>
&lt;h3>장단점&lt;span class="hx-absolute -hx-mt-20" id="장단점">&lt;/span>
&lt;a href="#%ec%9e%a5%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>최적해를 보장한다.&lt;/li>
&lt;li>불필요한 탐색을 줄여 효율성을 높인다.&lt;/li>
&lt;li>다양한 최적화 문제에 적용 가능하다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>최악의 경우 여전히 지수 시간 복잡도를 가진다.&lt;/li>
&lt;li>효과적인 한계 함수(bounding function)를 설계하는 것이 어려울 수 있다.&lt;/li>
&lt;li>메모리 사용량이 많을 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>초기 문제를 루트 노드로 하는 상태 공간 트리를 생성한다.&lt;/li>
&lt;li>현재 노드에서 가능한 선택지들로 분기(branch)한다.&lt;/li>
&lt;li>각 하위 노드의 한계값(bound)을 계산한다.&lt;/li>
&lt;li>한계값이 현재까지의 최선의 해보다 나쁜 노드는 가지치기(prune)한다.&lt;/li>
&lt;li>가장 유망한 노드를 선택하여 탐색을 계속한다.&lt;/li>
&lt;li>최적해를 찾거나 모든 가능성을 탐색할 때까지 2-5 단계를 반복한다.&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분기 함수(branch): 현재 노드에서 가능한 선택지들을 생성&lt;/li>
&lt;li>한계 함수(bound): 하위 트리의 최적값 추정&lt;/li>
&lt;li>선택 함수(selection): 다음에 탐색할 노드 선택&lt;/li>
&lt;li>가지치기 조건(pruning): 유망하지 않은 노드 제거 기준&lt;/li>
&lt;/ol>
&lt;h3>분기 한정법 Vs 백트래킹&lt;span class="hx-absolute -hx-mt-20" id="분기-한정법-vs-백트래킹">&lt;/span>
&lt;a href="#%eb%b6%84%ea%b8%b0-%ed%95%9c%ec%a0%95%eb%b2%95-vs-%eb%b0%b1%ed%8a%b8%eb%9e%98%ed%82%b9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>분기 한정법은 백트래킹과 유사하지만 몇 가지 중요한 차이점이 있다:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>목적&lt;/strong>: 분기 한정법은 최적화 문제에 특화되어 있습니다.&lt;/li>
&lt;li>&lt;strong>탐색 순서&lt;/strong>: 분기 한정법은 가장 유망한 노드를 우선적으로 탐색한다.&lt;/li>
&lt;li>&lt;strong>가지치기&lt;/strong>: 분기 한정법은 더 적극적으로 가지치기를 수행한다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효과적인 분기 전략: 문제를 균형 있게 나누는 분기 방법&lt;/li>
&lt;li>강력한 한계 함수: 정확하면서도 계산이 빠른 한계값 추정 방법&lt;/li>
&lt;li>효율적인 탐색 전략: 유망한 노드를 빠르게 찾는 방법&lt;/li>
&lt;li>메모리 효율성: 필요한 정보만을 저장하여 메모리 사용 최소화&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제에 특화된 한계 함수를 개발한다.&lt;/li>
&lt;li>깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)의 장단점을 고려하여 적절한 탐색 전략을 선택한다.&lt;/li>
&lt;li>병렬 처리를 활용하여 여러 하위 문제를 동시에 탐색하는 것을 고려한다.&lt;/li>
&lt;li>메모이제이션 기법을 사용하여 중복 계산을 줄인다.&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>
&lt;img src="../0-1-Knapsack-using-Branch-and-Bound3.jpg" alt="0/1 Knapsack using Branch and Bound" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/&lt;/a> _&lt;/p>
&lt;blockquote>
&lt;p>0/1 배낭 문제(0/1 Knapsack Problem)&lt;br>
주어진 조건:&lt;/p>
&lt;ul>
&lt;li>n개의 물건이 있음&lt;/li>
&lt;li>각 물건 i는 무게 &lt;code>w[i]&lt;/code>와 가치 &lt;code>v[i]&lt;/code>를 가짐&lt;/li>
&lt;li>배낭의 최대 수용 가능 무게는 W&lt;/li>
&lt;li>각 물건은 통째로 선택하거나 선택하지 않아야 함 (0 또는 1)&lt;br>
목표:&lt;/li>
&lt;li>배낭의 무게 제한을 초과하지 않으면서&lt;/li>
&lt;li>선택된 물건들의 총 가치를 최대화하는 물건들의 조합을 찾는 것&lt;br>
수학적 표현:&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>최대화: `Σ(v[i] * x[i]) (i = 1 to n)`
제약 조건: `Σ(w[i] * x[i]) ≤ W`
여기서` x[i]는 0 또는 1 (물건을 선택하거나 선택하지 않음)`&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/blockquote>
&lt;p>0/1 배낭 문제(0/1 Knapsack Problem)를 해결하는 분기 한정법&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Item&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="c1"># 물건의 무게&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="c1"># 물건의 가치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="c1"># 물건의 인덱스&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ratio&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="c1"># 단위 무게당 가치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">knapsack_branch_and_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 단위 무게당 가치 기준으로 정렬 (한정 함수의 효율을 위해)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">items&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ratio&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">reverse&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 최적해를 저장할 변수들&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">max_value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1"># 지금까지 찾은 최적해의 가치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_solution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="c1"># 최적해의 선택 여부 저장&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_weight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 현재 노드에서 가능한 최대 가치를 계산하는 한정 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 이 값이 현재까지의 최적해보다 작다면 더 탐색할 필요가 없음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">current_weight&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 노드의 한계값 계산&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bound_value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current_value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total_weight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current_weight&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node_level&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 남은 물건들을 가치/무게 비율이 높은 순서대로 분할하여 추가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">total_weight&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weight&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total_weight&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weight&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bound_value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 마지막 물건은 분할하여 추가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bound_value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">total_weight&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ratio&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">bound_value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">branch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_weight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">solution&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 분기 함수: 각 물건을 선택하거나 선택하지 않는 두 가지 경우로 분기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">nonlocal&lt;/span> &lt;span class="n">max_value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">best_solution&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모든 물건을 고려했다면 현재 해답 평가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">node_level&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">current_value&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">max_value&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">max_value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current_value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_solution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">solution&lt;/span>&lt;span class="p">[:]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 한계값 계산하여 가지치기 여부 결정&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_weight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">max_value&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="c1"># 유망하지 않은 노드는 가지치기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 물건을 선택하는 경우 탐색&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">current_weight&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weight&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">solution&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">branch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_weight&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weight&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current_value&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">solution&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 물건을 선택하지 않는 경우 탐색&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">solution&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node_level&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">branch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_weight&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">solution&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 초기 호출&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">branch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">max_value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">best_solution&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예시&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 데이터&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">weights&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">3.14&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">1.98&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 물건들의 무게&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">values&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">40&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">50&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">95&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 물건들의 가치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="c1"># 배낭의 용량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Item 객체들 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">items&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">Item&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">zip&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 알고리즘 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">max_value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">solution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">knapsack_branch_and_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;최대 가치: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">max_value&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;선택된 물건들: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">solution&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>탐욕 알고리즘 (Greedy Algorithm)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</link><pubDate>Thu, 31 Oct 2024 05:23:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</guid><description>
&lt;h2>탐욕 알고리즘 (Greedy Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="탐욕-알고리즘-greedy-algorithm">&lt;/span>
&lt;a href="#%ed%83%90%ec%9a%95-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-greedy-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>탐욕 알고리즘(Greedy Algorithm)은 최적화 문제를 해결하기 위한 간단하면서도 강력한 알고리즘 설계 기법이다.&lt;br>
문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다.&lt;br>
즉, &amp;lsquo;탐욕적&amp;rsquo;으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>근시안적 선택: 현재 상황에서 가장 좋은 선택을 한다.&lt;/li>
&lt;li>부분 최적해: 각 단계의 최적해가 전체 문제의 최적해로 이어질 것이라고 가정한다.&lt;/li>
&lt;li>되돌아가지 않음: 한 번 선택한 것을 번복하지 않는다.&lt;/li>
&lt;/ol>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>탐욕 알고리즘의 주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>복잡한 문제를 단순화하여 빠르게 해결하기&lt;/li>
&lt;li>근사해를 효율적으로 찾기&lt;/li>
&lt;li>최적화 문제에 대한 간단한 해법 제공&lt;br>
복잡한 최적화 문제를 해결할 때, 모든 경우를 고려하는 것이 불가능하거나 비효율적인 경우에 탐욕 알고리즘이 필요하다.&lt;/li>
&lt;/ol>
&lt;h3>장점과 단점&lt;span class="hx-absolute -hx-mt-20" id="장점과-단점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90%ea%b3%bc-%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>구현이 간단하고 직관적이다.&lt;/li>
&lt;li>계산 속도가 빠르다.&lt;/li>
&lt;li>메모리 사용량이 적다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>항상 최적해를 보장하지는 않는다.&lt;/li>
&lt;li>일부 문제에는 적용할 수 없다.&lt;/li>
&lt;li>전체적인 최적해를 놓칠 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>선택 절차: 현재 상태에서 최적의 해를 선택한다.&lt;/li>
&lt;li>적절성 검사: 선택한 해가 문제의 조건을 만족하는지 검사한다.&lt;/li>
&lt;li>해답 검사: 전체 문제가 해결되었는지 확인한다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>탐욕적 선택 속성: 지역적인 최적 선택이 전체 문제의 최적해로 이어져야 한다.&lt;/li>
&lt;li>최적 부분 구조: 문제의 최적해가 부분 문제의 최적해를 포함해야 한다.&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제를 잘 분석하여 탐욕적 선택이 가능한지 확인한다.&lt;/li>
&lt;li>정렬을 활용하여 선택 과정을 최적화한다.&lt;/li>
&lt;li>우선순위 큐나 힙을 사용하여 최적의 선택을 효율적으로 찾는다.&lt;/li>
&lt;li>불필요한 계산을 줄이기 위해 메모이제이션을 고려한다.&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>선택 함수: 각 단계에서 최적의 선택을 하는 함수&lt;/li>
&lt;li>적절성 검사 함수: 선택의 유효성을 검사하는 함수&lt;/li>
&lt;li>해답 검사 함수: 문제가 해결되었는지 확인하는 함수&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>거스름돈 문제를 해결하는 탐욕 알고리즘의 예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">coin_change&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">coins&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 큰 단위의 동전부터 사용하기 위해 내림차순 정렬&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">coins&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">reverse&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">change&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">coin&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">coins&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 동전으로 거슬러 줄 수 있는 만큼 거슬러 줌&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">amount&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">coin&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">change&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">coin&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">amount&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">coin&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">change&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">amount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">63&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">coins&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">25&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 사용 가능한 동전 단위&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">coin_change&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">coins&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">원을 거슬러 주기 위한 동전: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;사용된 동전 개수: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 알고리즘은 가장 큰 단위의 동전부터 사용하여 거스름돈을 만든다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>여러 활동들의 시작 시간과 종료 시간이 주어졌을 때, 한 강의실에서 진행할 수 있는 최대 활동 수를 찾는 문제&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">activity_selection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start_times&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">finish_times&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 겹치지 않게 선택할 수 있는 최대 활동 수를 찾는 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> start_times (list): 각 활동의 시작 시간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> finish_times (list): 각 활동의 종료 시간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> tuple: (선택된 활동의 수, 선택된 활동들의 인덱스 리스트)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start_times&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 종료 시간을 기준으로 활동들을 정렬&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">activities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">sorted&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">finish_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 첫 번째 활동은 항상 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">selected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">activities&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_finish_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">finish_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">activities&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 나머지 활동들을 검사&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">activities&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 활동의 시작 시간이 마지막 선택된 활동의 종료 시간 이후라면&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">start_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">last_finish_time&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">selected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_finish_time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">finish_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">current&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">selected&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">selected&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 테스트&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start_times&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">finish_times&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">selected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">activity_selection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start_times&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">finish_times&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;선택된 활동 수: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;선택된 활동들: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">selected&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 선택된 활동들의 시간 출력&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">selected&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;활동 &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">start_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">시에 시작, &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">finish_times&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">시에 종료&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>분할 정복 (Divide and Conquer)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</link><pubDate>Thu, 31 Oct 2024 05:22:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</guid><description>
&lt;h2>분할 정복 (Divide and Conquer)&lt;span class="hx-absolute -hx-mt-20" id="분할-정복-divide-and-conquer">&lt;/span>
&lt;a href="#%eb%b6%84%ed%95%a0-%ec%a0%95%eb%b3%b5-divide-and-conquer" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.&lt;/p>
&lt;p>분할 정복은 주어진 문제를 다음과 같은 세 단계로 해결한다:&lt;/p>
&lt;ol>
&lt;li>분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다.&lt;/li>
&lt;li>정복(Conquer): 하위 문제들을 재귀적으로 해결한다.&lt;/li>
&lt;li>결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해답을 얻는다.&lt;/li>
&lt;/ol>
&lt;p>
&lt;img src="../Working-of-Divide-and-Conquer-Algorithm.webp" alt="Working of Divide and Conquer" loading="lazy" />
_Source: &lt;a href="https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm/&lt;/a> _&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>재귀적 접근: 문제를 더 작은 동일한 유형의 하위 문제로 나누어 해결한다.&lt;/li>
&lt;li>분할 가능성: 문제가 더 작은 하위 문제로 자연스럽게 나누어질 수 있어야 한다.&lt;/li>
&lt;li>하위 문제 독립성: 각 하위 문제는 독립적으로 해결될 수 있어야 한다.&lt;/li>
&lt;/ul>
&lt;h3>목적과 필요성&lt;span class="hx-absolute -hx-mt-20" id="목적과-필요성">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81%ea%b3%bc-%ed%95%84%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>분할 정복의 주요 목적은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>복잡한 문제를 더 간단하고 해결 가능한 형태로 변환&lt;/li>
&lt;li>문제 해결 과정의 효율성 향상&lt;/li>
&lt;li>병렬 처리를 통한 성능 개선 가능성 제공&lt;br>
복잡하고 큰 규모의 문제를 효율적으로 해결하기 위해 분할 정복이 필요한다.&lt;/li>
&lt;/ol>
&lt;h3>장단점&lt;span class="hx-absolute -hx-mt-20" id="장단점">&lt;/span>
&lt;a href="#%ec%9e%a5%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>복잡한 문제를 효율적으로 해결할 수 있다.&lt;/li>
&lt;li>병렬 처리에 적합하다.&lt;/li>
&lt;li>일부 문제에서 최적의 시간 복잡도를 제공한다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>재귀 호출로 인한 오버헤드가 발생할 수 있다.&lt;/li>
&lt;li>모든 문제에 적용할 수 있는 것은 아니다.&lt;/li>
&lt;li>메모리 사용량이 증가할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>작동 원리&lt;span class="hx-absolute -hx-mt-20" id="작동-원리">&lt;/span>
&lt;a href="#%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제를 더 작은 하위 문제로 나눈다.&lt;/li>
&lt;li>하위 문제가 충분히 작아질 때까지 재귀적으로 나누는 과정을 반복한다.&lt;/li>
&lt;li>가장 작은 하위 문제부터 해결하기 시작한다.&lt;/li>
&lt;li>하위 문제의 해결책을 결합하여 상위 문제의 해답을 얻는다.&lt;/li>
&lt;li>최종적으로 원래 문제의 해답을 얻는다.&lt;/li>
&lt;/ol>
&lt;h3>좋은 알고리즘의 조건&lt;span class="hx-absolute -hx-mt-20" id="좋은-알고리즘의-조건">&lt;/span>
&lt;a href="#%ec%a2%8b%ec%9d%80-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효율적인 분할: 문제를 균형 있게 나누는 방법을 사용해야 한다.&lt;/li>
&lt;li>기저 사례(Base case) 정의: 더 이상 나눌 수 없는 가장 작은 문제를 정의해야 한다.&lt;/li>
&lt;li>효율적인 결합: 하위 문제의 해결책을 빠르게 결합할 수 있어야 한다.&lt;/li>
&lt;li>중복 계산 방지: 동일한 하위 문제를 반복해서 해결하지 않도록 해야 한다.&lt;/li>
&lt;/ol>
&lt;h3>효율적인 구현을 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="효율적인-구현을-위한-팁">&lt;/span>
&lt;a href="#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ea%b5%ac%ed%98%84%ec%9d%84-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>재귀 함수를 최적화하여 사용한다.&lt;/li>
&lt;li>하위 문제의 크기를 균형있게 나눈다.&lt;/li>
&lt;li>메모이제이션(Memoization)을 활용하여 중복 계산을 피한다.&lt;/li>
&lt;li>병렬 처리를 고려한다.&lt;/li>
&lt;/ol>
&lt;h3>핵심 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="핵심-구성-요소">&lt;/span>
&lt;a href="#%ed%95%b5%ec%8b%ac-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분할 함수: 문제를 하위 문제로 나누는 함수&lt;/li>
&lt;li>정복 함수: 기저 사례를 해결하는 함수&lt;/li>
&lt;li>결합 함수: 하위 문제의 해결책을 결합하는 함수&lt;/li>
&lt;li>기저 사례 확인 함수: 더 이상 나눌 수 없는 가장 작은 문제인지 확인하는 함수&lt;/li>
&lt;/ol>
&lt;h3>실제 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>병합 정렬(Merge Sort)을 구현한 코드:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기저 사례: 배열의 길이가 1 이하면 이미 정렬된 상태&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 분할 단계: 배열을 두 개의 하위 배열로 나눔&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">:]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 정복 단계: 재귀적으로 하위 배열 정렬&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 결합 단계: 정렬된 하위 배열을 병합&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 두 배열의 원소를 비교하며 병합&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 남은 원소들을 결과 배열에 추가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">:])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">extend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">:])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">38&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">27&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">43&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">82&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sorted_arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;정렬된 배열:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sorted_arr&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>메모이제이션 (Memoization)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</link><pubDate>Sun, 20 Oct 2024 11:22:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</guid><description>
&lt;h2>메모이제이션 (Memoization)&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션-memoization">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98-memoization" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>메모이제이션은 &amp;ldquo;기억하다&amp;quot;라는 뜻의 라틴어 &amp;lsquo;memorandum&amp;rsquo;에서 유래했다.&lt;br>
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.&lt;/p>
&lt;p>실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때&lt;/p>
&lt;ol>
&lt;li>&lt;strong>메모이제이션 미사용&lt;/strong>: 같은 단어가 나올 때마다 매번 사전을 찾음&lt;/li>
&lt;li>&lt;strong>메모이제이션 사용&lt;/strong>: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고&lt;br>
로 이해 가능하다.&lt;/li>
&lt;/ol>
&lt;h3>메모이제이션의 작동 원리&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션의-작동-원리">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98%ec%9d%98-%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>함수가 호출될 때 입력값을 확인한다.&lt;/li>
&lt;li>해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다.&lt;/li>
&lt;li>저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다.&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">memoized_function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{}):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 1. 이미 계산된 값인지 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2. 새로운 값 계산&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="c1"># 계산 로직&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 3. 계산된 값을 저장&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 4. 결과 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>메모이제이션의 장점&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션의-장점">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다.&lt;/li>
&lt;li>자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>메모이제이션의 사용 예시&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션의-사용-예시">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98%ec%9d%98-%ec%82%ac%ec%9a%a9-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.&lt;br>
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.&lt;/p>
&lt;p>자바스크립트:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 메모이제이션을 적용한 피보나치 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">memo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">function&lt;/span> &lt;span class="nx">fibonacciMemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nx">memo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">length&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fibonacciMemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nx">fibonacciMemo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>파이썬:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 메모이제이션 없는 버전&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 메모이제이션 적용 버전&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fib_memo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{}):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 이미 계산된 값이면 바로 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기본 케이스&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 새로운 값 계산 및 저장&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fib_memo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">fib_memo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 성능 비교&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">35&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;일반 재귀 결과: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">fib&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;소요 시간: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="si">:&lt;/span>&lt;span class="s2">f&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">초&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;메모이제이션 결과: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">fib_memo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;소요 시간: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="si">:&lt;/span>&lt;span class="s2">f&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">초&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>메모이제이션의 구현 방법&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션의-구현-방법">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98%ec%9d%98-%ea%b5%ac%ed%98%84-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>객체나 배열을 사용하여 계산 결과를 저장한다.&lt;/li>
&lt;li>함수 호출 시 먼저 저장된 결과가 있는지 확인한다.&lt;/li>
&lt;li>저장된 결과가 없으면 계산을 수행하고 결과를 저장한다.&lt;/li>
&lt;/ol>
&lt;h3>메모이제이션의 주의점&lt;span class="hx-absolute -hx-mt-20" id="메모이제이션의-주의점">&lt;/span>
&lt;a href="#%eb%a9%94%eb%aa%a8%ec%9d%b4%ec%a0%9c%ec%9d%b4%ec%85%98%ec%9d%98-%ec%a3%bc%ec%9d%98%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>메모리 사용량 증가: 결과를 저장하기 위해 추가적인 메모리가 필요하다.&lt;/li>
&lt;li>적용 대상 선택: 순수 함수(같은 입력에 항상 같은 출력을 반환하는 함수)에 적용하는 것이 좋다.&lt;/li>
&lt;li>캐시 관리: 저장된 결과가 너무 많아지면 메모리 문제가 발생할 수 있으므로, 적절한 캐시 관리가 필요할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>실제 적용 사례&lt;span class="hx-absolute -hx-mt-20" id="실제-적용-사례">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%a0%81%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>웹 개발: API 호출 결과 캐싱&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">get_user_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{}):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">user_id&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># API 호출로 데이터 가져오기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get_user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cache&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">user_id&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">data&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>알고리즘: 동적 프로그래밍 문제 해결&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">knapsack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{}):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">weights&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">weights&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">knapsack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">knapsack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">weights&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">knapsack&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">weights&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:],&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">memo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>그래픽 처리: 복잡한 렌더링 결과 저장&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>테이블레이션(Tabulation)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</link><pubDate>Sun, 20 Oct 2024 11:21:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</guid><description>
&lt;h2>테이블레이션(Tabulation)&lt;span class="hx-absolute -hx-mt-20" id="테이블레이션tabulation">&lt;/span>
&lt;a href="#%ed%85%8c%ec%9d%b4%eb%b8%94%eb%a0%88%ec%9d%b4%ec%85%98tabulation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.&lt;/p>
&lt;p>Tabulation은 &amp;lsquo;표를 만든다&amp;rsquo;는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.&lt;/p>
&lt;h3>Tabulation의 작동 원리&lt;span class="hx-absolute -hx-mt-20" id="tabulation의-작동-원리">&lt;/span>
&lt;a href="#tabulation%ec%9d%98-%ec%9e%91%eb%8f%99-%ec%9b%90%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다.&lt;/li>
&lt;li>표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다.&lt;/li>
&lt;li>기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다.&lt;/li>
&lt;li>반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다.&lt;/li>
&lt;li>최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다.&lt;/li>
&lt;/ol>
&lt;h3>Tabulation의 예시: 피보나치 수열&lt;span class="hx-absolute -hx-mt-20" id="tabulation의-예시-피보나치-수열">&lt;/span>
&lt;a href="#tabulation%ec%9d%98-%ec%98%88%ec%8b%9c-%ed%94%bc%eb%b3%b4%eb%82%98%ec%b9%98-%ec%88%98%ec%97%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>피보나치 수열을 계산하는 예시&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">fibonacci_tabulation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 표 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fib&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기본 케이스 설정&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 반복적 계산&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 최종 결과 반환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">fib&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 사용 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fibonacci_tabulation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1"># 55 출력&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 예시에서 표(fib 리스트)는 각 인덱스에 해당하는 피보나치 수를 저장한다.&lt;br>
작은 문제(0번째, 1번째 피보나치 수)부터 시작하여 점진적으로 큰 문제(n번째 피보나치 수)를 해결한다.&lt;/p>
&lt;h3>Tabulation의 장점&lt;span class="hx-absolute -hx-mt-20" id="tabulation의-장점">&lt;/span>
&lt;a href="#tabulation%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효율성: 중복 계산을 피하여 시간 복잡도를 개선한다.&lt;/li>
&lt;li>메모리 사용: 필요한 결과만 저장하므로 메모리를 효율적으로 사용한다.&lt;/li>
&lt;li>예측 가능성: 반복문을 사용하여 실행 시간을 예측하기 쉽다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item></channel></rss>