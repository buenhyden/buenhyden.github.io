<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm-Design | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/algorithm-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/algorithm-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/algorithm-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/algorithm-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Algorithm-Design"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Algorithm-Design"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Algorithm-Design</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Memoization vs Tabulation</h2></header><div class=entry-content><p>Memoization Vs Tabulation Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.
Memoization(메모이제이션)은 “하향식(Top-down)” 접근 방식이다.
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.
Tabulation(타뷸레이션)은 “상향식(Bottom-up)” 접근 방식이다.
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.
특성 Tabulation Memoization 접근 방식 Bottom-up (상향식) Top-down (하향식) 구현 방법 반복문 (Iterative) 재귀 (Recursive) 메모리 사용 문제 크기만큼 고정 필요한 만큼 동적 할당 실행 순서 순차적으로 모든 하위 문제 해결 필요한 하위 문제만 해결 공간 효율성 예측 가능하고 일정함 재귀 호출로 인한 스택 공간 필요 시간 효율성 모든 경우를 계산 필요한 경우만 계산 코드 복잡도 일반적으로 더 단순 일반적으로 더 복잡 캐시 활용 배열/테이블 형태 해시 테이블/맵 형태 구현 예시 비교 피보나치 수열 계산의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Tabulation 방식 def fib_tabulation(n): # 테이블 초기화 table = [0] * (n + 1) table[1] = 1 # 순차적으로 값 채우기 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n] # Memoization 방식 def fib_memoization(n, memo={}): # 이미 계산된 값이면 반환 if n in memo: return memo[n] # 기본 케이스 if n &lt;= 1: return n # 결과 저장 및 반환 memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo) return memo[n] 세부 특성 Tabulation Memoization 적합한 상황 모든 하위 문제의 결과가 필요한 경우 일부 하위 문제의 결과만 필요한 경우 디버깅 난이도 상대적으로 쉬움 재귀로 인해 더 어려움 최적화 가능성 공간 최적화 쉬움 재귀 깊이 제한으로 인한 제약 병렬화 가능성 쉬움 (독립적인 계산) 어려움 (의존성 있는 호출) 초기화 오버헤드 더 큼 (전체 테이블) 더 작음 (필요시 할당) 메모리 예측성 높음 낮음 (실행 중 변동) 성능 특성 Tabulation Memoization 시간 복잡도 O(n) - 모든 경우 O(n) - 최악의 경우 공간 복잡도 O(n) - 테이블 크기 O(n) - 캐시 + 스택 캐시 적중률 100% (모든 값 계산) 상황에 따라 다름 초기 지연 시간 더 김 (테이블 초기화) 더 짧음 (즉시 시작) 메모리 사용량 예측 가능 변동적 이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.
일반적으로:
...</p></div><footer class=entry-footer><span title='2024-10-11 11:25:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memoization vs Tabulation" href=https://buenhyden.github.io/til/2024/10/11/memoization-vs-tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모이제이션 (Memoization)</h2></header><div class=entry-content><p>메모이제이션 (Memoization) 메모이제이션은 “기억하다"라는 뜻의 라틴어 ‘memorandum’에서 유래했다.
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.
실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때
메모이제이션 미사용: 같은 단어가 나올 때마다 매번 사전을 찾음 메모이제이션 사용: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고
로 이해 가능하다. 메모이제이션의 작동 원리 함수가 호출될 때 입력값을 확인한다. 해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다. 저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 def memoized_function(n, memo={}): # 1. 이미 계산된 값인지 확인 if n in memo: return memo[n] # 2. 새로운 값 계산 result = ... # 계산 로직 # 3. 계산된 값을 저장 memo[n] = result # 4. 결과 반환 return result 메모이제이션의 장점 실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다. 자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다. 메모이제이션의 사용 예시 가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;547 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모이제이션 (Memoization)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;221 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 “무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.
특성 모든 가능성을 고려한다. 단순하고 직관적이다. 항상 정확한 해답을 찾는다. 목적과 필요성 복잡한 최적화 없이 문제를 해결하고자 할 때 사용한다. 다른 효율적인 알고리즘이 없거나 구현이 어려울 때 필요하다. 문제의 크기가 작을 때 빠르게 해결책을 찾을 수 있다. 장점 구현이 간단하다. 항상 최적의 해를 찾는다. 문제의 제약 조건이 까다로울 때 유용하다. 단점 시간 복잡도가 높다 (대부분의 경우 O(2^n) 또는 O(n!)). 큰 입력에 대해 비효율적이다. 메모리 사용량이 많을 수 있다. 작동 원리 가능한 모든 경우의 수를 생성한다. 각 경우에 대해 문제의 조건을 만족하는지 확인한다. 조건을 만족하는 경우를 해답으로 채택한다. 좋은 알고리즘의 조건 문제의 크기가 작을 때 효과적이다. 다른 알고리즘의 정확성을 검증하는 데 사용될 수 있다. 구현이 간단하고 버그가 적다. 효율적인 구현을 위한 팁 가능한 경우의 수를 줄이는 방법을 고려한다 (가지치기). 병렬 처리를 활용하여 성능을 개선할 수 있다. 메모이제이션을 사용하여 중복 계산을 줄인다. 핵심 구성 요소 후보 생성 함수 (generate_candidates) 유효성 검사 함수 (is_valid_solution) 반복문 또는 재귀를 통한 모든 경우의 수 탐색 실제 예시 코드 모든 가능한 비밀번호 조합을 생성하여 올바른 비밀번호를 찾는 함수
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Approaches to algorithm design</h2></header><div class=entry-content><p>Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.
Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법은 문제 해결을 위한 전략적인 사고 과정을 의미한다.
이는 알고리즘 설계 기법과는 구별되는 개념으로, 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞춘다.
...</p></div><footer class=entry-footer><span title='2024-10-13 07:30:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;951 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approaches to algorithm design" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/algorithm-design/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>