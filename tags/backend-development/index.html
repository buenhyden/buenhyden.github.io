<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend-development/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Design and Implementation</h2></header><div class=entry-content><p>API(Application Programming Interface) Design and Implementation API(응용 프로그램 프로그래밍 인터페이스, Application Programming Interface)는 소프트웨어 컴포넌트 간의 데이터 교환과 통신을 위한 표준화된 규약 및 인터페이스이다.
API는 현대 소프트웨어 개발의 핵심 요소로, 개발자가 기존 코드와 서비스를 활용하여 새로운 애플리케이션을 빠르게 구축할 수 있게 해준다. 또한, 백엔드 시스템, 서드파티 서비스, 내부 시스템 간의 연결을 가능하게 하며, 데이터와 기능을 안전하게 공유할 수 있는 표준화된 방법을 제공한다. 효과적인 API는 명확한 계약, 일관된 구조, 적절한 보안 메커니즘, 확장성 있는 설계를 갖추어야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to API Design and Implementation" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-design-and-implementation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Performance</h2></header><div class=entry-content><p>API Performance API 성능은 백엔드 시스템 설계에서 핵심적인 요소로, 최종 사용자 경험과 시스템 효율성에 직접적인 영향을 미친다.
API 성능의 정의와 중요성 API 성능이란 API가 요청을 처리하고 응답을 전달하는 속도와 효율성을 의미한다. 이는 단순히 빠른 응답 시간만을 의미하는 것이 아니라, 시스템 리소스의 효율적 사용, 확장성, 그리고 안정성까지 포함하는 개념이다.
API 성능이 중요한 이유는 다음과 같다:
사용자 경험 향상: 빠른 API 응답은 최종 사용자에게 더 나은 경험을 제공한다. 시스템 처리량 증가: 효율적인 API는 동일한 리소스로 더 많은 요청을 처리할 수 있다. 비용 효율성: 최적화된 API는 인프라 비용을 절감할 수 있다. 확장성 지원: 성능이 좋은 API는 트래픽 증가에 더 잘 대응할 수 있다. 데이터 통합 개선: 시스템 간 효율적인 데이터 교환을 가능하게 한다. API 성능 측정 지표 API 성능을 올바르게 최적화하기 위해서는 먼저 측정해야 한다.
...</p></div><footer class=entry-footer><span title='2025-02-26 06:08:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to API Performance" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/performance-optimization/api-performance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</h2></header><div class=entry-content><p>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet 데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.
세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:
JSON은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다. XML은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다. Protobuf는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다. 선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.
기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-systems/event-streaming-platforms/apache-kafka/kafka-vs-rabbitmq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/data--database-systems/database-technologies/nosql-databases/key-value-stores/redis%EC%99%80-valkey/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) vs. Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) vs. Web Server Web Server와 Application Server는 모두 클라이언트 요청을 처리하고 응답을 반환하는 서버이지만, 역할과 기능에서 중요한 차이가 있다. 이 두 서버는 종종 함께 사용되며, 서로 보완적인 관계를 형성한다.
정의 및 주요 역할 Web Server 주로 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 제공하는 서버이다. HTTP 프로토콜을 기반으로 클라이언트 요청에 응답한다. 정적 리소스를 빠르게 처리하며, 동적 요청은 Application Server로 전달하는 역할도 수행한다. Application Server 동적 콘텐츠를 생성하고 비즈니스 로직을 처리하는 서버이다. 데이터베이스와 상호작용하거나 애플리케이션 로직을 실행하여 클라이언트 요청에 따라 맞춤형 데이터를 반환한다. 동적 콘텐츠를 처리하기 때문에 복잡한 트랜잭션 관리 및 비즈니스 로직 수행이 가능하다. 기능 Web Server 정적 콘텐츠 제공: HTML, CSS, 이미지 파일 등. 요청 전달: 동적 콘텐츠 요청은 Application Server로 전달. 캐싱 및 로드 밸런싱: 웹사이트 성능 최적화를 위한 기능 제공. Application Server 동적 콘텐츠 생성: 클라이언트 요청에 따라 실시간으로 데이터를 생성. 비즈니스 로직 처리: 데이터베이스와 통신하거나 복잡한 연산 수행. 트랜잭션 관리: 다중 사용자 환경에서 데이터 일관성을 유지. 사용 사례 Web Server
...</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Web Application Server (WAS) vs. Web Server" href=https://buenhyden.github.io/posts/system-architecture--design/system-components/application--execution-core/web-application-servers/web-application-server-vs-web-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/oauth-2.x/oauth-20-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/jwt-vs-oauth-20/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-saml/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/backend-development/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>