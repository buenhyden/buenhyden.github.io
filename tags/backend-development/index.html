<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend-Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend-Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend-Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend-Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event Brokers</h2></header><div class=entry-content><p>Event Brokers 이벤트 브로커는 현대 분산 시스템과 마이크로서비스 아키텍처의 핵심 구성 요소로, 비동기 통신과 시스템 간 느슨한 결합을 가능하게 한다. Event Broker 는 이벤트 생성자 (Producer) 와 이벤트 소비자 (Consumer) 사이에서 중개자 역할을 수행한다.
Source: https://developer.confluent.io/patterns/event-stream/event-broker/
이벤트 브로커 기초 개념 이벤트 브로커란? 이벤트 브로커는 이벤트 생산자 (Producer) 와 소비자 (Consumer) 사이에서 메시지를 중개하는 미들웨어이다. 생산자는 이벤트를 발행 (publish) 하고, 소비자는 관심 있는 이벤트를 구독 (subscribe) 하는 발행 - 구독 (Pub/Sub) 패턴을 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:28:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;62 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Brokers" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/fundamentals/event-brokers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</h2></header><div class=entry-content><p>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet 데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.
세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:
JSON은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다. XML은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다. Protobuf는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다. 선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet" href=https://buenhyden.github.io/posts/software-engineering/service-and-application-engineering/application-development-fundamentals/data-exchange/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Synchronous vs Asynchronous APIs</h2></header><div class=entry-content><p>Synchronous vs. Asynchronous APIs API 설계에서 동기식(Synchronous)과 비동기식(Asynchronous) 패턴 중 어떤 것을 선택할지는 시스템 아키텍처와 사용자 경험에 중대한 영향을 미치는 결정이다. 각 패턴은 고유한 장단점을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
동기식 API(Synchronous API) 동기식 API는 클라이언트가 요청을 보내고 서버의 응답을 받을 때까지 대기하는 방식으로 작동한다. 이는 요청-응답 주기가 완료될 때까지 클라이언트가 다른 작업을 수행하지 않는 “차단(blocking)” 방식을 의미한다.
동기식 API의 작동 원리 동기식 API의 기본 흐름은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous vs Asynchronous APIs" href=https://buenhyden.github.io/posts/software-engineering/service-and-application-engineering/api-design-and-implementation/api-integration-patterns/synchronous-vs-asynchronous-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.
기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/messaging-systems/implementations/event-streaming-platforms/kafka/kafka-vs-rabbitmq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/nosql/key-value/redis%EC%99%80-valkey/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/software-engineering/service-and-application-engineering/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) vs. Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) vs. Web Server Web Server와 Application Server는 모두 클라이언트 요청을 처리하고 응답을 반환하는 서버이지만, 역할과 기능에서 중요한 차이가 있다. 이 두 서버는 종종 함께 사용되며, 서로 보완적인 관계를 형성한다.
정의 및 주요 역할 Web Server 주로 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 제공하는 서버이다. HTTP 프로토콜을 기반으로 클라이언트 요청에 응답한다. 정적 리소스를 빠르게 처리하며, 동적 요청은 Application Server로 전달하는 역할도 수행한다. Application Server 동적 콘텐츠를 생성하고 비즈니스 로직을 처리하는 서버이다. 데이터베이스와 상호작용하거나 애플리케이션 로직을 실행하여 클라이언트 요청에 따라 맞춤형 데이터를 반환한다. 동적 콘텐츠를 처리하기 때문에 복잡한 트랜잭션 관리 및 비즈니스 로직 수행이 가능하다. 기능 Web Server 정적 콘텐츠 제공: HTML, CSS, 이미지 파일 등. 요청 전달: 동적 콘텐츠 요청은 Application Server로 전달. 캐싱 및 로드 밸런싱: 웹사이트 성능 최적화를 위한 기능 제공. Application Server 동적 콘텐츠 생성: 클라이언트 요청에 따라 실시간으로 데이터를 생성. 비즈니스 로직 처리: 데이터베이스와 통신하거나 복잡한 연산 수행. 트랜잭션 관리: 다중 사용자 환경에서 데이터 일관성을 유지. 사용 사례 Web Server
...</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) vs. Web Server" href=https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure/infrastructure-components/web-and-edge-infrastructure/web-application-servers/web-application-server-vs-web-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/integration-patterns/api-integration/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/oauth/oauth-20-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-oauth-20/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/backend-development/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>