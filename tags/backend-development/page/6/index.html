<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend-Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend-Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend-Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend-Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 6749</h2></header><div class=entry-content><p>RFC 6749 RFC 6749는 OAuth 2.0 권한 부여 프레임워크(The OAuth 2.0 Authorization Framework)를 정의하는 인터넷 표준 문서이다. 이 문서는 2012년 10월에 인터넷 표준화 기구인 IETF(Internet Engineering Task Force)에 의해 발행되었다. 주 저자는 Dick Hardt이며, 여러 기술 전문가들의 협업으로 만들어졌다.
OAuth 2.0은 이전 버전인 OAuth 1.0(RFC 5849)의 후속 버전으로, 다양한 웹 애플리케이션, 데스크톱 애플리케이션, 모바일 애플리케이션 및 IoT 장치에서 안전한 권한 위임을 가능하게 하는 프로토콜이다. 간단히 말해, OAuth 2.0은 사용자가 자신의 비밀번호를 공유하지 않고도 제3자 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 해주는 프레임워크이다.
...</p></div><footer class=entry-footer><span title='2025-02-28 11:28:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 6749" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/oauth/rfc-6749/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming APIs</h2></header><div class=entry-content><p>Streaming APIs 스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다. 전통적인 RESTful API가 요청-응답 패턴을 기반으로 하는 반면, 스트리밍 API는 지속적인 연결을 통해 실시간 데이터를 제공한다. 이러한 접근 방식은 데이터가 생성되는 즉시 클라이언트에게 전달할 수 있어 실시간성이 중요한 애플리케이션에 적합하다.
스트리밍 API의 기본 원리는 클라이언트와 서버 간에 한 번 연결을 수립한 후, 서버가 필요에 따라 데이터를 푸시하는 방식으로 동작하다. 이는 폴링(polling) 방식의 단점인 불필요한 요청과 네트워크 오버헤드를 극복할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:41:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming APIs" href=https://buenhyden.github.io/posts/software-engineering/application-development/backend-development-fundamentals/request-response-cycle/streaming/streaming-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/integration/api-integration/event-driven-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pub/Sub APIs</h2></header><div class=entry-content><p>Pub/Sub APIs Pub/Sub 패턴의 기본 개념 Pub/Sub(Publish-Subscribe) 패턴은 메시지 기반 아키텍처의 핵심 패러다임으로, 데이터를 생성하는 발행자(Publisher)와 데이터를 소비하는 구독자(Subscriber) 사이의 느슨한 결합(loose coupling)을 제공한다. 이 패턴에서 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 자동으로 그 메시지를 수신한다.
Pub/Sub 패턴의 가장 중요한 특징은 발행자와 구독자가 서로에 대해 직접적인 지식이 필요 없다는 점이다. 발행자는 단순히 주제에 메시지를 보내고, 시스템이 해당 주제의 모든 구독자에게 메시지를 전달한다. 이러한 분리는 시스템 구성 요소 간의 의존성을 줄이고 확장성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pub/Sub APIs" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-styles/event-based-style/pub-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Websocket API vs. Websocket</h2></header><div class=entry-content><p>Websocket API vs. Websocket WebSocket이란? WebSocket은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 통신 프로토콜이다. HTTP와 달리, 연결이 한 번 수립되면 계속 유지되며, 클라이언트와 서버가 서로 독립적으로 메시지를 주고받을 수 있다.
WebSocket 프로토콜은 RFC 6455에 정의되어 있으며, ‘ws://’ 또는 암호화된 연결을 위한 ‘wss://’ URI 스키마를 사용한다. WebSocket은 HTTP 핸드셰이크를 사용하여 연결을 시작한 다음, 프로토콜을 WebSocket으로 업그레이드한다.
WebSocket API란? WebSocket API는 웹 애플리케이션에서 WebSocket 프로토콜을 사용할 수 있게 해주는 인터페이스이다. 이것은 W3C에서 표준화한 웹 API로, 자바스크립트를 통해 WebSocket 프로토콜을 구현할 수 있도록 한다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:38:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Websocket API vs. Websocket" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-styles/event-based-style/websocket/websocket-api-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC API vs. gRPC</h2></header><div class=entry-content><p>gRPC API vs. gRPC gRPC와 gRPC API는 현대 마이크로서비스 아키텍처에서 중요한 역할을 하는 기술이다.
gRPC 기본 개념 gRPC는 Google에서 개발한 고성능, 오픈소스 RPC(Remote Procedure Call) 프레임워크이다. 2015년에 처음 공개되었으며, HTTP/2 프로토콜 위에 구축되어 있다. ‘g’는 원래 Google을 의미했지만, 현재는 독립적인 오픈소스 프로젝트로 발전했다.
gRPC는 다음과 같은 주요 특징을 가지고 있다:
Protocol Buffers(protobuf)를 IDL(Interface Definition Language)로 사용 HTTP/2 기반 통신으로 높은 성능 제공 양방향 스트리밍 지원 다양한 프로그래밍 언어 지원 (C++, Java, Python, Go, Ruby, C# 등) 코드 생성 도구를 통한 클라이언트 및 서버 코드 자동 생성 gRPC API의 정의와 특징 gRPC API는 gRPC 프레임워크를 사용하여 구현된 API를 의미한다. 즉, gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:37:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API vs. gRPC" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GraphQL API vs. GraphQL</h2></header><div class=entry-content><p>GraphQL API vs. GraphQL GraphQL과 GraphQL API는 현대 웹 개발에서 자주 언급되는 개념이지만, 이 둘 사이에는 명확한 차이점이 있다.
GraphQL과 GraphQL API의 개념적 차이 GraphQL은 페이스북이 2012년에 개발하고 2015년에 오픈소스로 공개한 쿼리 언어와 서버 측 런타임 사양(specification)이다. 반면 GraphQL API는 이 GraphQL 사양을 구현한 실제 API 인터페이스를 의미한다.
쉽게 설명하자면, GraphQL은 프로그래밍 언어인 SQL과 같은 개념이고, GraphQL API는 이 언어를 사용하여 구축된 실제 데이터베이스 인터페이스와 같다.
핵심 특징 비교 GraphQL은 클라이언트가 정확히 필요한 데이터만 요청할 수 있는 유연한 쿼리 언어를 제공한다.
이는 REST API에서 흔히 발생하는 오버페칭(over-fetching)과 언더페칭(under-fetching) 문제를 해결한다.
...</p></div><footer class=entry-footer><span title='2025-02-27 11:11:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL API vs. GraphQL" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-styles/query-style/graphql/graphql-apis/graphql-api-vs-graphql/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pagination</h2></header><div class=entry-content><p>Pagination API 설계에서 페이지네이션은 대량의 데이터를 효율적으로 전송하고 관리하기 위한 핵심 요소이다. 페이지네이션을 통해 서버는 데이터를 작은 “페이지” 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.
페이지네이션의 필요성과 중요성 페이지네이션이 필요한 주요 이유는 다음과 같다:
성능 최적화
대규모 데이터셋을 한 번에 전송하면 여러 문제가 발생한다:
서버 부하 증가: 대량의 레코드를 검색하고 직렬화하는 과정은 서버 리소스를 많이 소모한다. 네트워크 부하: 대용량 응답은 네트워크 대역폭을 많이 사용하며, 특히 모바일 환경에서 문제가 된다. 응답 지연: 큰 데이터셋을 처리하는 데 시간이 오래 걸려 사용자 경험이 저하된다. 메모리 사용량: 클라이언트와 서버 모두 대량의 데이터를 메모리에 로드해야 한다. 사용자 경험 향상
페이지네이션은 사용자 인터페이스와 경험을 개선한다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pagination" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-performance/pagination/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>URI Design</h2></header><div class=entry-content><p>URI Design URI(Uniform Resource Identifier) 디자인은 API 설계의 근본적인 요소로, 개발자 경험과 API의 사용성, 유지보수성에 직접적인 영향을 미친다. 잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.
URI의 기본 개념과 구조 URI는 인터넷에서 특정 리소스를 고유하게 식별하는 문자열이다. API 설계에서 URI는 클라이언트가 서버의 리소스와 상호 작용하는 진입점 역할을 한다.
URI의 구성 요소 URI의 주요 구성 요소를 이해하는 것은 효과적인 디자인의 시작점이다:
1 2 3 4 https://api.example.com:8080/v1/customers/42/orders?status=pending#summary \___/ \______________/\__/\_________________/ \____________/ \______/ | | | | | | scheme authority port path query fragment 스킴(Scheme): URI가 사용하는 프로토콜(https, http 등) 권한(Authority): 서비스의 도메인 이름 또는 IP 주소 포트(Port): 서비스가 수신 대기하는 네트워크 포트(종종 생략됨) 경로(Path): 리소스의 위치를 계층적으로 나타내는 문자열 쿼리(Query): 리소스에 대한 추가 매개변수(필터링, 정렬 등) 프래그먼트(Fragment): 리소스 내의 특정 부분을 가리키는 식별자(일반적으로 API에서 덜 사용됨) URI vs. URL vs. URN URI 개념을 정확히 이해하기 위해서는 관련 용어의 차이점을 아는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to URI Design" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-fundamentals/api-endpoint-design/uri-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Get-and-Patch</h2></header><div class=entry-content><p>Get-and-Patch “Get-and-Patch"는 리소스의 부분적 업데이트를 효율적으로 처리하기 위한 REST API 디자인 패턴으로, 기존 CRUD(Create, Read, Update, Delete) 방식의 한계를 보완한다.
이 패턴은 GET과 PATCH 메서드 조합을 통해 리소스의 전체 상태를 검색하지 않고도 특정 필드만 업데이트할 수 있도록 설계되었다.
핵심 개념 두 단계 프로세스 Get: 리소스의 현재 상태 조회 (필요한 필드 확인) Patch: 변경된 필드만 서버에 전송하여 부분 업데이트 HTTP 메서드 활용 단계 HTTP 메서드 설명 Get GET 리소스의 전체/일부 상태 조회 Patch PATCH 식별된 필드만 부분적으로 업데이트 CRUD vs. Get-and-Patch 구분 CRUD (PUT) Get-and-Patch (PATCH) 업데이트 범위 전체 리소스 교체 특정 필드만 수정 네트워크 효율성 모든 필드 전송 필요 변경된 필드만 전송 멱등성 보장됨 조건부 보장 (구현 방식에 따라 다름) 동시성 제어 전체 리소스 버전 관리 필드 단위 낙관적 잠금 가능 사용 사례 단순 리소스 교체 대규모 객체의 일부 수정 작동 원리 Get 단계 클라이언트가 리소스의 현재 상태를 조회한다.
...</p></div><footer class=entry-footer><span title='2025-02-26 11:58:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Get-and-Patch" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/get-and-patch/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend-development/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend-development/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>