<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend-Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend-Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend-Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend-Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Jwt vs. Cookie-Based Auth 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간 정보를 안전하게 JSON 객체로 전송하기 위한 컴팩트하고 독립적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA와 같은 공개/개인 키 쌍을 사용하여 서명할 수 있다.
쿠키 기반 인증
쿠키 기반 인증은 사용자가 로그인할 때 서버가 세션 ID를 생성하고, 이 세션 ID를 쿠키에 저장하여 클라이언트에게 전송하는 방식이다. 모든 후속 요청에서 클라이언트는 이 쿠키를 서버에 보내고, 서버는 세션 ID를 확인하여 사용자를 인증한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:47:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/jwt-vs-cookie-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Session-based Auth</h2></header><div class=entry-content><p>Jwt vs. Session-based Auth 기본 개념 JWT(JSON Web Token)
JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있으며, 토큰 자체에 필요한 모든 정보를 포함하고 있다. JWT는 주로 상태 비저장(Stateless) 인증 메커니즘으로 사용된다.
세션 기반 인증
세션 기반 인증은 서버가 사용자의 인증 상태를 유지하는 전통적인 인증 방식이다. 사용자가 로그인하면 서버는 세션 ID를 생성하고 이를 서버 메모리나 데이터베이스에 저장한다. 이 세션 ID는 쿠키를 통해 클라이언트에게 전달되며, 후속 요청에서 클라이언트는 이 쿠키를 전송하여 인증 상태를 유지한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:46:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Session-based Auth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/jwt-vs-session-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Session-based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Session-based Auth 세션 기반 인증(Session-based Authentication) 세션 기반 인증은 전통적인 인증 방식으로, 서버가 사용자의 로그인 상태를 세션으로 유지하는 방식이다.
작동 원리 인증 과정: 사용자가 자격 증명(사용자 이름/비밀번호)을 제출한다. 서버는 자격 증명을 검증하고, 유효한 경우 고유한 세션 ID를 생성한다. 서버는 세션 ID와 관련 사용자 정보를 서버 측 저장소(메모리, 데이터베이스, 캐시 등)에 저장한다. 서버는 세션 ID를 클라이언트에게 쿠키로 전송한다. 클라이언트는 이후 요청 시 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키의 세션 ID를 확인하여 사용자를 식별한다. 세션 수명 주기: 세션은 사용자가 로그인할 때 생성된다. 세션은 일정 시간이 지나면 만료된다(서버 설정에 따라 다름). 사용자가 로그아웃하면 세션이 명시적으로 파기된다. 서버는 세션의 유효성과 만료를 관리한다. 주요 특징 상태 유지(Stateful): 서버가 세션 정보를 저장하고 관리한다. 쿠키 기반: 주로 HTTP 쿠키를 통해 세션 ID를 전달한다. 서버 측 저장소: 세션 데이터가 서버에 저장된다. 간단한 구현: 대부분의 웹 프레임워크에서 기본적으로 지원한다. 명시적인 세션 관리: 서버가 세션 생성, 검증, 만료, 파기를 제어한다. 토큰 인증(Token Authentication) 토큰 인증은 클라이언트에게 서명된 토큰을 발급하여 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:45:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Session-based Auth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-session-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OpenID Connect</h2></header><div class=entry-content><p>JWT vs. OpenID Connect JWT(JSON Web Token)와 OpenID Connect(OIDC)는 모두 현대적인 인증 및 권한 부여 시스템에서 중요한 역할을 하는 기술이다. 이 두 기술은 서로 밀접한 관계가 있지만, 목적과 기능 면에서 중요한 차이점을 가지고 있다.
JWT(JSON Web Token) JWT는 당사자 간에 안전하게 정보를 전송하기 위한 개방형 표준(RFC 7519)으로, 컴팩트하고 자체 포함적인 방식으로 정보를 안전하게 전달한다.
기본 구조 JWT는 점(.)으로 구분된 세 부분으로 구성된다:
헤더(Header): 토큰 유형과 사용된 암호화 알고리즘 정보 페이로드(Payload): 클레임(사용자 ID, 만료 시간 등) 정보 서명(Signature): 토큰의 무결성을 보장하는 디지털 서명 예시:
...</p></div><footer class=entry-footer><span title='2025-04-01 14:53:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OpenID Connect" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/jwt-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SOAP API vs. SOAP</h2></header><div class=entry-content><p>SOAP API vs. SOAP SOAP(Simple Object Access Protocol)는 웹 서비스 통신을 위한 중요한 프로토콜이지만, ‘SOAP API’와 ‘SOAP’라는 용어는 종종 혼용되어 사용된다.
SOAP와 SOAP API는 관련되어 있지만 다른 개념이다. SOAP는 메시지 교환 프로토콜이고, SOAP API는 이 프로토콜을 사용하여 구현된 웹 서비스이다. 이 둘의 관계를 이해하는 것은 웹 서비스 아키텍처를 설계하고 구현하는 데 중요한 기초가 된다.
현대 API 설계에서는 REST, GraphQL 등의 가벼운 대안이 더 많이 사용되고 있지만, 특정 엔터프라이즈 환경에서는 SOAP의 강력한 기능과 표준화된 접근 방식이 여전히 가치를 지니고 있다.
...</p></div><footer class=entry-footer><span title='2025-04-01 03:18:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API vs. SOAP" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/synchronous-communication/remote-procedure-calls/soap/soap-api-vs-soap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ReDoc</h2></header><div class=entry-content><p>ReDoc ReDoc은 OpenAPI(이전의 Swagger) 명세를 기반으로 한 오픈 소스 API 문서 생성 도구이다. 2016년에 Rebilly에 의해 개발된 이 도구는 단일 HTML 파일로 깔끔하고 반응형 있는 API 문서를 생성하는 데 특화되어 있다.
ReDoc의 핵심 가치는 세 가지이다:
개발자 친화적 인터페이스: 사용하기 쉽고 탐색하기 쉬운 문서 제공 시각적 매력: 미학적으로 세련된 문서 생성 유연성과 맞춤화: 다양한 요구에 맞게 조정 가능 ReDoc의 주요 기능 단일 페이지 디자인 ReDoc은 단일 페이지 애플리케이션(SPA) 접근 방식을 취한다. 이는 사용자가 페이지를 전환하지 않고도 모든 API 문서에 접근할 수 있음을 의미한다.
...</p></div><footer class=entry-footer><span title='2025-03-31 09:04:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ReDoc" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-docs--spec/openapi-specification/swagger/documentation-generation/redoc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adaptive Polling</h2></header><div class=entry-content><p>Adaptive Polling 어댑티브 폴링은 데이터 수집이나 시스템 모니터링 과정에서 폴링(polling) 주기를 상황과 필요에 따라 동적으로 조절하는 기술이다. 전통적인 고정 주기 폴링과 달리, 시스템의 상태와 환경 변화에 따라 폴링 빈도를 지능적으로 조절함으로써 리소스 사용 효율성을 극대화한다.
작동 원리 어댑티브 폴링은 다음과 같은 핵심 메커니즘을 기반으로 작동한다:
상태 감지(State Detection): 시스템은 현재 상태, 데이터 변화율, 이벤트 발생 빈도 등을 지속적으로 모니터링한다. 알고리즘 기반 의사결정(Algorithm-based Decision Making): 수집된 정보를 바탕으로 최적의 폴링 주기를 결정하는 알고리즘을 실행한다. 동적 조정(Dynamic Adjustment): 폴링 주기는 실시간으로 조정되며, 시스템 활동이 활발할 때는 주기가 짧아지고 비활성 상태에서는 주기가 길어진다. 예를 들어, 네트워크 트래픽이 갑자기 증가하면 시스템은 폴링 빈도를 높여 상황을 더 세밀하게 모니터링하고, 트래픽이 안정되면 폴링 빈도를 낮추어 리소스를 절약한다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adaptive Polling" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/polling/types/adaptive-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Smart Polling</h2></header><div class=entry-content><p>Smart Polling 스마트 폴링은 시스템이 데이터를 효율적으로 수집하고 모니터링하는 첨단 기술로, 전통적인 폴링 방식의 한계를 극복하기 위해 발전되었다. 이 기술은 폴링 과정에 지능적 의사결정 요소를 통합하여 리소스 사용 최적화와 시스템 성능 향상을 동시에 추구한다.
스마트 폴링의 기본 개념 스마트 폴링은 단순히 일정 주기로 데이터를 확인하는 전통적인 폴링과 달리, 다양한 컨텍스트 정보와 알고리즘을 활용하여 ‘언제’, ‘무엇을’, ‘어떻게’ 폴링할지 지능적으로 결정한다.
이는 다음과 같은 핵심 원칙에 기반한다:
컨텍스트 인식(Context Awareness): 시스템 상태, 네트워크 조건, 사용자 행동 패턴 등의 컨텍스트 정보를 고려한다. 적응형 의사결정(Adaptive Decision Making): 수집된 데이터와 상황에 따라 폴링 전략을 실시간으로 조정한다. 우선순위 기반 처리(Priority-based Processing): 중요도에 따라 데이터 수집 우선순위를 설정한다. 리소스 최적화(Resource Optimization): 필요한 정보만 필요한 시점에 수집하여 시스템 리소스를 효율적으로 사용한다. 스마트 폴링의 주요 기술 요소 이벤트 기반 폴링(Event-driven Polling) 특정 조건이나 트리거가 발생할 때만 폴링을 수행하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Smart Polling" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/polling/types/smart-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SAML vs. OAuth 2.0</h2></header><div class=entry-content><p>SAML vs. OAuth 2.0 인증(Authentication)과 권한 부여(Authorization)는 현대 웹 애플리케이션과 시스템에서 핵심적인 보안 구성 요소이다. SAML(Security Assertion Markup Language)과 OAuth 2.0은 이러한 기능을 제공하는 두 가지 주요 프로토콜이지만, 설계 철학, 사용 사례 및 기술적 구현에서 상당한 차이가 있다.
기본 개념 및 역사 SAML (Security Assertion Markup Language) SAML은 2002년 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 개방형 표준으로, 당시 기업들이 직면한 단일 인증 문제를 해결하기 위해 설계되었다. 현재 가장 널리 사용되는 버전은 2005년에 발표된 SAML 2.0이다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:31:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML vs. OAuth 2.0" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/saml-2.0/saml-vs-oauth-20/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session-Based Auth vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Session-Based Auth vs. Cookie-Based Auth 웹 애플리케이션에서 사용자 인증은 보안의 핵심 요소이다. 인증 시스템은 사용자의 신원을 확인하고, 인증된 사용자에게 적절한 권한을 부여하는 중요한 역할을 한다. 세션 기반 인증과 쿠키 기반 인증은 가장 널리 사용되는 두 가지 인증 메커니즘으로, 많은 사람들이 이 두 용어를 혼동하는 경우가 있다. 이 두 방식은 밀접하게 연관되어 있지만, 구현 방식과 보안 특성에서 중요한 차이점이 있다.
기본 개념 이해 쿠키(Cookie)란? 쿠키는 웹 서버가 사용자의 브라우저에 저장하는 작은 텍스트 파일이다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:29:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session-Based Auth vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/authentication-implementation/session-based-authentication/session-based-auth-vs-cookie-based-auth/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend-development/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend-development/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>