<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend-Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend-Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend-Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend-Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OIDC vs. OpenID</h2></header><div class=entry-content><p>OIDC vs. OpenID 인증과 권한 부여는 현대 웹 애플리케이션의 핵심 보안 요소로, 다양한 표준과 프로토콜이 개발되어 왔다. 그중에서도 OpenID와 OpenID Connect는 사용자 인증을 위한 중요한 표준이다. 이 두 기술은 이름이 유사하여 혼동되기 쉽지만, 근본적인 목적과 구현 방식에는 중요한 차이점이 있다.
역사적 배경 및 발전 과정 OpenID OpenID는 2005년 Brad Fitzpatrick가 처음 개발한 분산형 인증 프로토콜이다. 당시 인터넷은 사용자가 각 웹사이트마다 새로운 계정을 생성해야 하는 불편함이 있었고, 이를 해결하기 위해 등장했다.
...</p></div><footer class=entry-footer><span title='2025-03-11 12:09:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OIDC vs. OpenID" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/openid-connect/openid-connect-vs-openid/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Postman</h2></header><div class=entry-content><p>Postman Postman은 API(Application Programming Interface) 개발, 테스트, 문서화 및 협업을 위한 종합적인 플랫폼이다.
2012년 Abhinav Asthana가 개인 프로젝트로 시작한 이 도구는 현재 전 세계 2,000만 명 이상의 개발자와 50만 개 이상의 조직에서 사용하는 API 생태계의 핵심 요소로 성장했다.
Postman은 원래 Chrome 브라우저의 확장 프로그램으로 시작되어 API 요청을 쉽게 테스트할 수 있는 간단한 도구였다. 그러나 시간이 지남에 따라 독립 실행형 애플리케이션으로 발전했으며, 현재는 API 개발 수명주기 전체를 지원하는 클라우드 기반 플랫폼으로 확장되었다.
...</p></div><footer class=entry-footer><span title='2025-03-10 13:53:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Postman" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-testing/api-testing-tools/postman/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Contract Testing</h2></header><div class=entry-content><p>Contract Testing 계약 테스트(Contract Testing)는 서비스 간 상호작용이 명시된 계약을 준수하는지 확인하는 테스트 방법론이다. 현대적인 소프트웨어 아키텍처, 특히 마이크로서비스 환경에서 매우 중요한 역할을 한다.
계약의 정의 API 계약은 서비스 제공자(Provider)와 소비자(Consumer) 간의 “약속"으로 볼 수 있다.
이 계약은 다음과 같은 요소를 포함한다:
API 엔드포인트 및 경로 요청 및 응답 형식(JSON, XML 등) 데이터 구조 및 필드 정의 상태 코드 및 오류 처리 방식 인증 및 권한 부여 요구사항 계약 테스트의 필요성 마이크로서비스 아키텍처에서는 수십, 수백 개의 서비스가 서로 상호작용한다.
...</p></div><footer class=entry-footer><span title='2025-03-10 02:52:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Contract Testing" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-testing/contract-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Socket vs. Long Polling</h2></header><div class=entry-content><p>Web Socket vs. Long Polling 실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.
기본 개념 WebSocket WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-09 02:31:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Socket vs. Long Polling" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/web/websocket/websocket-vs-long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>WebSocket</h2></header><div class=entry-content><p>WebSocket 웹 소켓은 클라이언트와 서버 간에 지속적인 양방향 통신 채널을 제공하는 프로토콜이다. 전통적인 HTTP 통신과 달리, 웹 소켓은 한 번 연결이 수립되면 지속적으로 유지되어 실시간으로 데이터를 주고받을 수 있다.
웹 소켓 연결은 다음과 같은 특징적인 프로세스를 따른다:
핸드셰이크: 일반적인 HTTP 요청으로 시작하여 웹 소켓 연결로 ‘업그레이드’된다. 양방향 통신: 연결이 수립된 후, 클라이언트와 서버는 독립적으로 메시지를 주고받을 수 있다. 전이중(Full-duplex) 통신: 동시에 데이터를 송수신할 수 있다. HTTP vs. 웹 소켓 전통적인 HTTP와 웹 소켓의 주요 차이점을 이해하는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:32:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;40 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/web/websocket/websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-sent Events vs. Websocket</h2></header><div class=entry-content><p>Server-sent Events vs. Websocket 웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.
서버 전송 이벤트(SSE) 개념과 작동 원리 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, EventSource API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-03 05:41:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-sent Events vs. Websocket" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/asynchronous-communication/hybrid/sse/server-sent-events-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 6749</h2></header><div class=entry-content><p>RFC 6749 RFC 6749는 OAuth 2.0 권한 부여 프레임워크(The OAuth 2.0 Authorization Framework)를 정의하는 인터넷 표준 문서이다. 이 문서는 2012년 10월에 인터넷 표준화 기구인 IETF(Internet Engineering Task Force)에 의해 발행되었다. 주 저자는 Dick Hardt이며, 여러 기술 전문가들의 협업으로 만들어졌다.
OAuth 2.0은 이전 버전인 OAuth 1.0(RFC 5849)의 후속 버전으로, 다양한 웹 애플리케이션, 데스크톱 애플리케이션, 모바일 애플리케이션 및 IoT 장치에서 안전한 권한 위임을 가능하게 하는 프로토콜이다. 간단히 말해, OAuth 2.0은 사용자가 자신의 비밀번호를 공유하지 않고도 제3자 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 해주는 프레임워크이다.
...</p></div><footer class=entry-footer><span title='2025-02-28 11:28:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 6749" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/oauth-2.x/rfc-6749/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Websocket API vs. Websocket</h2></header><div class=entry-content><p>Websocket API vs. Websocket WebSocket이란? WebSocket은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 통신 프로토콜이다. HTTP와 달리, 연결이 한 번 수립되면 계속 유지되며, 클라이언트와 서버가 서로 독립적으로 메시지를 주고받을 수 있다.
WebSocket 프로토콜은 RFC 6455에 정의되어 있으며, ‘ws://’ 또는 암호화된 연결을 위한 ‘wss://’ URI 스키마를 사용한다. WebSocket은 HTTP 핸드셰이크를 사용하여 연결을 시작한 다음, 프로토콜을 WebSocket으로 업그레이드한다.
WebSocket API란? WebSocket API는 웹 애플리케이션에서 WebSocket 프로토콜을 사용할 수 있게 해주는 인터페이스이다. 이것은 W3C에서 표준화한 웹 API로, 자바스크립트를 통해 WebSocket 프로토콜을 구현할 수 있도록 한다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:38:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Websocket API vs. Websocket" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/web/websocket/websocket-api-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC API vs. gRPC</h2></header><div class=entry-content><p>gRPC API vs. gRPC gRPC와 gRPC API는 현대 마이크로서비스 아키텍처에서 중요한 역할을 하는 기술이다.
gRPC 기본 개념 gRPC는 Google에서 개발한 고성능, 오픈소스 RPC(Remote Procedure Call) 프레임워크이다. 2015년에 처음 공개되었으며, HTTP/2 프로토콜 위에 구축되어 있다. ‘g’는 원래 Google을 의미했지만, 현재는 독립적인 오픈소스 프로젝트로 발전했다.
gRPC는 다음과 같은 주요 특징을 가지고 있다:
Protocol Buffers(protobuf)를 IDL(Interface Definition Language)로 사용 HTTP/2 기반 통신으로 높은 성능 제공 양방향 스트리밍 지원 다양한 프로그래밍 언어 지원 (C++, Java, Python, Go, Ruby, C# 등) 코드 생성 도구를 통한 클라이언트 및 서버 코드 자동 생성 gRPC API의 정의와 특징 gRPC API는 gRPC 프레임워크를 사용하여 구현된 API를 의미한다. 즉, gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:37:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API vs. gRPC" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/synchronous-communication/remote-procedure-calls/grpc/grpc-api-vs-grpc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GraphQL API vs. GraphQL</h2></header><div class=entry-content><p>GraphQL API vs. GraphQL GraphQL과 GraphQL API는 현대 웹 개발에서 자주 언급되는 개념이지만, 이 둘 사이에는 명확한 차이점이 있다.
GraphQL과 GraphQL API의 개념적 차이 GraphQL은 페이스북이 2012년에 개발하고 2015년에 오픈소스로 공개한 쿼리 언어와 서버 측 런타임 사양(specification)이다. 반면 GraphQL API는 이 GraphQL 사양을 구현한 실제 API 인터페이스를 의미한다.
쉽게 설명하자면, GraphQL은 프로그래밍 언어인 SQL과 같은 개념이고, GraphQL API는 이 언어를 사용하여 구축된 실제 데이터베이스 인터페이스와 같다.
핵심 특징 비교 GraphQL은 클라이언트가 정확히 필요한 데이터만 요청할 수 있는 유연한 쿼리 언어를 제공한다.
이는 REST API에서 흔히 발생하는 오버페칭(over-fetching)과 언더페칭(under-fetching) 문제를 해결한다.
...</p></div><footer class=entry-footer><span title='2025-02-27 11:11:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL API vs. GraphQL" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-styles/graphql/graphql-api-vs-graphql/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend-development/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend-development/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>