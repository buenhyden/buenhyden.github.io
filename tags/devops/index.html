<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevOps | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/devops/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/devops/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/devops/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="DevOps"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="DevOps"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>DevOps</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cloud vs. On-Premise</h2></header><div class=entry-content><p>Cloud vs. On-Premise Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.
이 두 방식은 데이터 저장, 애플리케이션 호스팅, 그리고 전반적인 IT 리소스 관리에 있어 근본적인 차이를 보인다.
비교 항목 On-Premise 클라우드 초기 구축 비용 - 서버, 네트워크 장비 등 높은 초기 투자 필요
- 데이터센터 구축 비용 발생
- 소프트웨어 라이선스 구매 필요 - 초기 투자 비용 최소화
- 필요한 만큼만 시작 가능
- 하드웨어 구매 불필요 운영 비용 - 예측 가능한 고정 비용
- 전담 IT 인력 필요
- 전기, 냉각 등 관리 비용 발생 - 사용량 기반 과금
- 탄력적인 비용 구조
- 운영 인력 최소화 가능 확장성 - 물리적 인프라 확장 필요
- 확장 시 많은 시간과 비용 소요
- 사전 용량 계획 중요 - 필요에 따라 즉시 확장 가능
- 자동 확장/축소 지원
- 글로벌 확장 용이 보안 - 물리적 보안 직접 통제
- 데이터 위치 완벽 통제
- 자체 보안 정책 수립 가능 - 서비스 제공자의 보안 정책 따름
- 공유 인프라 사용
- 데이터 위치 선택 제한적 유지보수 - 모든 유지보수 직접 담당
- 정기적인 하드웨어 교체 필요
- 패치/업그레이드 직접 관리 - 서비스 제공자가 유지보수 담당
- 자동 업데이트/패치 적용
- 최신 기술 자동 적용 커스터마이징 - 완전한 커스터마이징 자유
- 하드웨어/소프트웨어 직접 선택
- 특수 요구사항 수용 용이 - 제한된 커스터마이징
- 제공되는 서비스 내에서 선택
- 표준화된 서비스 위주 가용성 - 자체 인프라로 안정성 확보
- 인터넷 연결 없이도 운영 가능
- 장애 대응 직접 수행 - 서비스 제공자의 SLA 따름
- 인터넷 연결 필수
- 여러 지역 동시 운영 가능 데이터 주권 - 완벽한 데이터 통제권 보유
- 물리적 데이터 위치 확실
- 규제 준수 용이 - 데이터 주권 일부 제한
- 국가간 데이터 이동 가능
- 규제 준수 확인 필요 접근성 - 내부 네트워크 중심
- 원격 접속 별도 구성 필요
- 물리적 접근 통제 가능 - 언제 어디서나 접근 가능
- 다양한 디바이스 지원
- 글로벌 접근성 우수 재해 복구 - 별도의 재해복구 센터 필요
- 높은 구축/운영 비용
- 복구 절차 직접 수행 - 자동화된 백업/복구
- 여러 지역 복제 용이
- 신속한 재해 복구 적합한 상황 - 높은 보안이 필요한 경우
- 특수한 규제 준수 필요
- 레거시 시스템 운영 - 빠른 시작이 필요한 경우
- 유연한 확장성 필요
- 글로벌 서비스 제공 실제로는 많은 기업들이 두 방식의 장점을 모두 활용하는 하이브리드 형태를 채택하고 있다.
기업의 특성, 요구사항, 예산 등을 종합적으로 고려하여 적절한 방식을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:33:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud vs. On-Premise" href=https://buenhyden.github.io/posts/devops-and-infrastructure/platform-infrastructure/cloud/cloud-vs-on-premise/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>IaaS and PaaS and SaaS</h2></header><div class=entry-content><p>IaaS and PaaS and SaaS https://macronetservices.com/iaas-vs-paas-vs-saas-the-ultimate-guide-for-2021/
IaaS, PaaS, SaaS는 클라우드 컴퓨팅의 주요 서비스 모델이다.
IaaS (Infrastructure as a Service):
IaaS는 가상화된 컴퓨팅 리소스를 인터넷을 통해 제공한다.
사용자는 서버, 스토리지, 네트워크 등의 IT 인프라를 필요에 따라 사용할 수 있다.
IaaS의 주요 특징은 유연성, 확장성, 비용 효율성이다.
사용자는 필요한 만큼의 리소스를 동적으로 할당받고, 사용한 만큼만 비용을 지불한다.
PaaS (Platform as a Service):
PaaS는 애플리케이션을 개발, 실행, 관리할 수 있는 플랫폼을 제공한다.
개발자는 기본 인프라를 관리할 필요 없이 애플리케이션 개발에 집중할 수 있다.
PaaS는 개발 도구, 데이터베이스 관리, 비즈니스 인텔리전스 서비스 등을 제공하여 개발 프로세스를 간소화한다.
...</p></div><footer class=entry-footer><span title='2024-11-10 06:45:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IaaS and PaaS and SaaS" href=https://buenhyden.github.io/posts/devops-and-infrastructure/platform-infrastructure/cloud/iaas-paas-saas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pull Request Flow</h2></header><div class=entry-content><p>Pull Request Flow **Version Control Systems (VCS)**에서 Pull Request Flow는 코드 변경 사항의 체계적 검토와 협업을 위한 핵심 프로세스입니다. 2025 년 현재 AI 기반 자동화, 실시간 협업 도구, 보안 강화가 주요 트렌드로 부상하며, GitHub 및 GitLab 을 중심으로 한 워크플로우 최적화가 중요시됩니다. 아래에서는 PR 흐름의 핵심 원칙부터 실무 적용 사례까지 종합적으로 정리합니다.
1. 주제 분류 적절성 검토 분류: Computer Science and Engineering > Backend Development > Version Control Systems > Collaboration 적절성: Pull Request(PR) 는 코드 리뷰, 병합 전략, 팀 협업을 관리하는 과정이므로 “Collaboration” 하위 분류는 타당합니다. Git 의 Fork-PR 모델과 GitHub/GitLab 의 협업 기능과 직접 연관됩니다 [1][3][7]. 2. 개요 구분 설명 핵심 개념 코드 변경 사항의 체계적 검토 및 병합 프로세스 목적 코드 품질 향상, 병렬 개발 효율화, 롤백 관리 주요 기능 PR 생성, 리뷰, 충돌 해결, 머지 전략 아키텍처 중앙집중형 (GitHub) vs 분산형 (GitLab) 최신 동향 AI 기반 자동 리뷰, 실시간 협업, SBOM 통합 3. 핵심 내용 정리 3.1 Pull Request 의 핵심 원칙 원칙 설명 출처 단일 책임 원칙 하나의 PR 은 하나의 기능/버그 수정만 포함 [6] 명확한 설명 제목과 본문에 변경 사항의 목적/영향 명시 [6][12] 소규모 변경 200-400 라인 이하로 분할하여 리뷰 효율성 ↑ [15] 3.2 분류에 따른 PR 유형 유형 특징 사용 사례 도구 Feature Branch 기능 단위 분기 → main 병합 신규 기능 개발 GitHub Gitflow develop/release 분기 활용 릴리스 관리 GitLab Forking 외부 기여자용 포크 기반 PR 오픈소스 기여 Bitbucket 3.3 장점과 단점 구분 항목 설명 ✅ 장점 코드 품질 다중 검토를 통한 버그 감소 [1][15] 협업 효율성 팀원 간 지식 공유 촉진 [3][19] ⚠ 단점 시간 소모 대규모 PR 검토 시 리소스 과부하 [15] 주관적 편향 리뷰어의 코딩 스타일 반영 가능 [18] 3.4 실무 적용 예시 시나리오 해결 방안 도구/기법 대규모 팀 리뷰 지연 CODEOWNERS 로 리뷰어 자동 지정 GitLab[8] 커밋 이력 단순화 Squash Merge 로 여러 커밋 압축 GitHub[9] 보안 취약성 검출 CodeQL + AI 리뷰봇 연동 Bugdar[12] 4. 추가 조사 내용 4.1 PR 템플릿 작성 목적: 표준화된 리뷰 프로세스 구축 [7]
...</p></div><footer class=entry-footer><span title='2024-10-01 02:11:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pull Request Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/pull-request-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serverless Architecture</h2></header><div class=entry-content><p>Serverless Architecture Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.
Serverless Architecture는 빠른 개발 속도와 비용 효율성으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless Architecture" href=https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/serverless/serverless-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shadow Deployment</h2></header><div class=entry-content><p>Shadow Deployment 실제 트래픽을 복제해 신규 환경에 적용, 영향 분석 미러링된 트래픽으로 실환경 테스트 로그 분석을 통한 기능 안정성 검증 트래픽 복제 시 개인정보 마스킹 이슈 처리 Shadow Deployment 는 소프트웨어 배포 전략 중 하나로, 새로운 버전의 애플리케이션을 기존 버전과 병행하여 실행하되 사용자에게는 영향을 주지 않는 방식이다.
Shadow Deployment 는 새로운 버전의 애플리케이션을 프로덕션 환경에 배포하고 실제 트래픽을 복제하여 새 버전으로 전송하지만, 그 결과는 사용자에게 반환하지 않는 방식이다. 이는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2024-09-23 12:47:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shadow Deployment" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/shadow-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Feature Flags</h2></header><div class=entry-content><p>Feature Flags Feature flags(또는 feature toggles)는 소프트웨어 개발에서 중요한 배포 전략 중 하나이다.
이 기술을 통해 개발자는 코드 변경 없이 런타임에 특정 기능을 활성화하거나 비활성화할 수 있다.
Feature flags는 조건문을 사용하여 코드의 특정 부분을 동적으로 제어하는 소프트웨어 개발 기법이다.
이를 통해 배포와 릴리스를 분리하고, 위험을 최소화하며 유연한 기능 관리가 가능해진다.
Feature flags는 현대적인 소프트웨어 개발에서 중요한 도구이다. 이를 효과적으로 사용하면 더 안전하고 유연한 배포 프로세스를 구축할 수 있다. 하지만 적절한 관리와 주의가 필요하며, 팀의 요구사항과 프로젝트의 특성에 맞게 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 12:36:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Feature Flags" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/feature-flags/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A/B Testing</h2></header><div class=entry-content><p>A/B Testing 사용자 그룹별로 다른 버전 제공, 실험적 배포 피처 플래그 (Feature Flag) 시스템 도입 사용자 그룹 분리 기반 실험 결과 측정 지표 (Conversion, Retention 등) A/B Testing 은 소프트웨어 배포 전략 중 하나로, 두 가지 이상의 버전을 사용자에게 제공하여 어떤 버전이 더 효과적인지 비교하는 방법이다.
A/B Testing 은 두 가지 이상의 버전 (A 와 B) 을 사용자 그룹에게 무작위로 제공하여 각 버전의 성능을 비교하는 실험적 접근 방식이다. 이는 웹사이트, 모바일 앱, 마케팅 캠페인 등 다양한 분야에서 사용된다.
...</p></div><footer class=entry-footer><span title='2024-09-23 02:14:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to A/B Testing" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/a-b-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blue-Green Deployment</h2></header><div class=entry-content><p>Blue-Green Deployment 두 환경을 번갈아 사용, 무중단 배포, 빠른 롤백 [2] 활성 (Active) vs 대기 (Standby) 환경 구성 배포 전후 Smoke Test 수행 Load Balancer 또는 Ingress 트래픽 전환 Blue-Green Deployment 은 무중단 배포 전략 중 하나로, 애플리케이션의 새 버전을 안전하고 효율적으로 배포하는 방법이다.
Blue-Green 배포는 두 개의 동일한 프로덕션 환경을 유지하는 방식이다:
Blue 환경: 현재 운영 중인 버전 Green 환경: 새로 배포할 버전
이 두 환경은 완전히 동일한 인프라와 설정을 가지고 있다. Blue-Green Deployment 은 안전하고 효율적인 배포 전략이지만, 적절한 계획과 자동화가 필요하다. 조직의 요구사항과 인프라 환경에 맞게 적절히 조정하여 사용하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-23 02:13:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blue-Green Deployment" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/blue-green-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Canary Deployment</h2></header><div class=entry-content><p>Canary Deployment 점진적 트래픽 배포 비율 설정 (e.g., 5%, 10%, 50%, 100%) 사용자 행동/성능 모니터링 연동 Istio/Flagger 로 구현하는 실습 일부 트래픽에만 신규 버전 적용, 이상 시 빠른 복구 카나리 배포 (Canary Deployment) 패턴은 새로운 버전의 애플리케이션을 점진적으로 배포하는 전략이다.
이 방식은 위험을 최소화하면서 새로운 기능이나 업데이트를 테스트할 수 있게 해준다.
카나리 배포라는 이름은 광부들이 유독 가스를 감지하기 위해 카나리아 새를 사용했던 관행에서 유래되었다.
소프트웨어 배포에서 이 개념은 다음과 같이 적용된다:
...</p></div><footer class=entry-footer><span title='2024-09-23 02:13:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Canary Deployment" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/canary-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rolling Deployment</h2></header><div class=entry-content><p>Rolling Deployment 배포 중 다운타임 최소화 Pod 수 또는 인스턴스 수 조절 전략 Kubernetes RollingUpdate 정책 설정 점진적 배포, 트래픽 분산, 점검 및 롤백 용이 Rolling Deployment 는 애플리케이션의 새 버전을 점진적으로 배포하는 무중단 배포 전략이다.
Rolling Deployment 는 기존 버전의 인스턴스를 새 버전으로 점진적으로 교체하는 방식이다.
이 과정에서 서비스의 가용성을 유지하면서 새 버전을 배포할 수 있다.
주요 특징:
인스턴스를 하나씩 또는 작은 배치로 업데이트 전체 배포 과정 동안 서비스 유지 새 버전과 이전 버전이 일시적으로 공존 Rolling Deployment 는 서비스의 연속성을 유지하면서 새 버전을 안전하게 배포할 수 있는 효과적인 전략이다.
그러나 버전 간 호환성과 데이터베이스 변경 관리에 주의가 필요하다.
조직의 요구사항과 애플리케이션 특성을 고려하여 적절히 구현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 02:13:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rolling Deployment" href=https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/rolling-deployment/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>