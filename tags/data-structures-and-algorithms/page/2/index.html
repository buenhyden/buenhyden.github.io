<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structures-and-Algorithms | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structures-and-algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structures-and-algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structures-and-Algorithms"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structures-and-Algorithms"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structures-and-Algorithms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;540 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/float/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Traversal 방법 비교</h2></header><div class=entry-content><p>Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.
각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.
트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.
중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1988 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traversal 방법 비교" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬은 1960년 Tony Hoare가 개발한 효율적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 성능을 보이는 정렬 방식이다. 실제 많은 프로그래밍 언어의 표준 라이브러리에 구현되어 있을 정도로 실용적인 정렬 알고리즘이다.
퀵 정렬은 간단한 아이디어를 바탕으로 하면서도 매우 효율적인 정렬 알고리즘이다.
평균적인 성능이 우수하고 실제 구현에서 다양한 최적화 기법을 적용할 수 있어 많은 환경에서 선호된다.
최악의 경우를 대비한 피벗 선택 최적화와 하이브리드 접근 방식을 통해 단점을 보완하여 현대적인 정렬 알고리즘의 기반이 되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1374 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/quick-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>힙 정렬 (Heap Sort)</h2></header><div class=entry-content><p>힙 정렬 (Heap Sort) 힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.
시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.
힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.
최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.
불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1735 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 정렬 (Heap Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/heap-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Hash Map vs Hash Map vs Hash Table</h2></header><div class=entry-content><p>Concurrent Hash Map Vs Hash Map Vs Hash Table 특성 Concurrent HashMap HashMap HashTable 동기화 세그먼트/버킷 단위의 부분 동기화 지원 동기화 지원하지 않음 메서드 단위의 전체 동기화 지원 동시성 높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능) 동시성 지원하지 않음 (단일 스레드 환경용) 낮은 동시성 (한 번에 하나의 스레드만 접근 가능) 성능 동시 접근 시 높은 성능 단일 스레드에서 가장 높은 성능 동기화로 인한 성능 저하 null 허용 key와 value 모두 null 불가 key는 하나만 null 허용, value는 여러 개 null 허용 key와 value 모두 null 불가 초기 용량 기본 16, 세그먼트 수는 16 기본 16 기본 11 적재율 기본 0.75 기본 0.75 기본 0.75 이터레이션 fail-safe 이터레이터 제공 fail-fast 이터레이터 제공 fail-fast 이터레이터 제공 생성 시기 Java 5 Java 1.2 Java 1.0 메모리 사용 세그먼트로 인한 추가 메모리 필요 가장 적은 메모리 사용 동기화로 인한 추가 메모리 필요 용도 멀티스레드 환경의 동시성이 필요한 경우 단일 스레드 환경의 일반적인 경우 레거시 코드 호환성이 필요한 경우 확장성 동적 확장 가능 동적 확장 가능 동적 확장 가능 순서 보장 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 동기화 비용 부분적 동기화로 중간 수준의 비용 동기화 비용 없음 전체 동기화로 높은 비용 스레드 안전성 스레드 안전 스레드 안전하지 않음 스레드 안전 키 충돌 처리 체이닝 방식 체이닝 방식 체이닝 방식 참고로 몇 가지 중요한 추가 설명을 하자면:
...</p></div><footer class=entry-footer><span title='2024-10-12 14:35:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Hash Map vs Hash Map vs Hash Table" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-data-structures/concurrent-hash-map-vs-hash-map-vs-hash-table/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linear Data Structure vs Non-Linear Data Structure</h2></header><div class=entry-content><p>Non-Primitive Linear Data Structure Vs Non-Linear Data Structure 데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.
측면 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적 또는 선형적으로 배열된 구조 데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조 구조 단일 레벨 구조 다중 레벨 구조 데이터 관계 요소 간 1:1 관계 요소 간 1:N 또는 N:N 관계 순회 단일 실행으로 모든 요소 순회 가능 단일 실행으로 모든 요소 순회 불가능 구현 복잡성 구현이 상대적으로 간단 구현이 상대적으로 복잡 메모리 사용 메모리 사용이 덜 효율적 메모리 사용이 더 효율적 시간 복잡도 입력 크기에 따라 증가 특정 작업에서 더 효율적 데이터 접근 순차적 접근 계층적 또는 네트워크 기반 접근 삽입/삭제 상대적으로 간단 더 복잡하지만 유연함 응용 분야 간단한 데이터 저장 및 처리 복잡한 관계 표현, AI, 이미지 처리 등 예시 배열, 연결 리스트, 스택, 큐 트리, 그래프, 해시 테이블, 힙 공통점:
...</p></div><footer class=entry-footer><span title='2024-10-12 11:00:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linear Data Structure vs Non-Linear Data Structure" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Primitive data structure vs Non-Primitive data structure</h2></header><div class=entry-content><p>Primitive Data Structure Vs Non-Primitive Data Structure Primitive Data Structure Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.
주요 특징 단순성: 가장 기본적이고 이해하기 쉬운 데이터 타입이다. 고정 크기: 일반적으로 고정된 메모리 크기를 가진다. 효율성: 메모리 사용과 접근 시간 측면에서 매우 효율적이다. 직접 표현: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다. 값 의미론: 변수에 실제 값이 직접 저장된다. 스택 할당: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다. 주요 primitive data structure들을 비교 분석하여 정리한 표:
...</p></div><footer class=entry-footer><span title='2024-10-12 08:39:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1085 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Primitive data structure vs Non-Primitive data structure" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>힙 (Heap)</h2></header><div class=entry-content><p>힙 (Heap) 힙(Heap)은 완전 이진 트리(Complete Binary Tree) 기반의 특수한 트리 자료구조로, 특정한 순서 속성을 만족한다.
특히 우선순위 큐를 구현하는 데 효율적으로 사용되며, 다양한 알고리즘에서 핵심적인 역할을 한다.
힙은 최댓값이나 최솟값에 빠르게 접근해야 하는 상황에서 매우 유용한 자료구조이다.
힙은 효율적인 우선순위 접근과 관리를 제공하는 강력한 자료구조이다.
최댓값이나 최솟값에 빠르게 접근해야 하지만 다른 요소들의 전체 정렬은 필요하지 않을 때 특히 유용하다.
효율적인 삽입, 삭제, 최댓값/최솟값 접근 연산을 통해 다양한 알고리즘과 시스템에서 중요한 역할을 수행한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:54:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1655 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 (Heap)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/heap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Segment Tree</h2></header><div class=entry-content><p>Segment Tree 세그먼트 트리는 구간 또는 범위에 대한 정보를 저장하고 관리하는 트리 형태의 자료구조이다. 데이터베이스, 파일 시스템, 네트워크 라우팅 등 다양한 응용 프로그램에서 사용되며, 효율적인 구간 쿼리와 업데이트 연산을 제공하는 특수한 데이터 구조이다.
https://www.geeksforgeeks.org/segment-tree-data-structure/
특징 완전 이진 트리 구조를 가진다. 각 노드는 배열의 특정 구간에 대한 정보를 저장한다. 리프 노드는 배열의 개별 원소를 나타낸다. 부모 노드는 자식 노드들의 정보를 결합한 값을 저장한다. 장점 구간 쿼리의 시간 복잡도가 O(log n)으로 매우 효율적이다. 데이터 업데이트 시 O(log n) 시간에 트리를 갱신할 수 있다. 동적인 상황에서도 효율적으로 작동한다. 단점 일반 배열에 비해 더 많은 메모리를 사용한다 (약 4n의 공간 복잡도). 구현이 상대적으로 복잡할 수 있다. 응용 데이터베이스 시스템의 범위 쿼리 최적화 컴퓨터 그래픽스의 렌더링 최적화 네트워크 라우팅 테이블 관리 금융 데이터 분석의 구간 통계 계산 동작 원리 트리 구축 (Build):
...</p></div><footer class=entry-footer><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;861 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Segment Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/advanced/segment-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Memoization vs Tabulation</h2></header><div class=entry-content><p>Memoization Vs Tabulation Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.
Memoization(메모이제이션)은 “하향식(Top-down)” 접근 방식이다.
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.
Tabulation(타뷸레이션)은 “상향식(Bottom-up)” 접근 방식이다.
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.
특성 Tabulation Memoization 접근 방식 Bottom-up (상향식) Top-down (하향식) 구현 방법 반복문 (Iterative) 재귀 (Recursive) 메모리 사용 문제 크기만큼 고정 필요한 만큼 동적 할당 실행 순서 순차적으로 모든 하위 문제 해결 필요한 하위 문제만 해결 공간 효율성 예측 가능하고 일정함 재귀 호출로 인한 스택 공간 필요 시간 효율성 모든 경우를 계산 필요한 경우만 계산 코드 복잡도 일반적으로 더 단순 일반적으로 더 복잡 캐시 활용 배열/테이블 형태 해시 테이블/맵 형태 구현 예시 비교 피보나치 수열 계산의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Tabulation 방식 def fib_tabulation(n): # 테이블 초기화 table = [0] * (n + 1) table[1] = 1 # 순차적으로 값 채우기 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n] # Memoization 방식 def fib_memoization(n, memo={}): # 이미 계산된 값이면 반환 if n in memo: return memo[n] # 기본 케이스 if n &lt;= 1: return n # 결과 저장 및 반환 memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo) return memo[n] 세부 특성 Tabulation Memoization 적합한 상황 모든 하위 문제의 결과가 필요한 경우 일부 하위 문제의 결과만 필요한 경우 디버깅 난이도 상대적으로 쉬움 재귀로 인해 더 어려움 최적화 가능성 공간 최적화 쉬움 재귀 깊이 제한으로 인한 제약 병렬화 가능성 쉬움 (독립적인 계산) 어려움 (의존성 있는 호출) 초기화 오버헤드 더 큼 (전체 테이블) 더 작음 (필요시 할당) 메모리 예측성 높음 낮음 (실행 중 변동) 성능 특성 Tabulation Memoization 시간 복잡도 O(n) - 모든 경우 O(n) - 최악의 경우 공간 복잡도 O(n) - 테이블 크기 O(n) - 캐시 + 스택 캐시 적중률 100% (모든 값 계산) 상황에 따라 다름 초기 지연 시간 더 김 (테이블 초기화) 더 짧음 (즉시 시작) 메모리 사용량 예측 가능 변동적 이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.
일반적으로:
...</p></div><footer class=entry-footer><span title='2024-10-13 11:25:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memoization vs Tabulation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/memoization-vs-tabulation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>