<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structures-and-Algorithms | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structures-and-algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structures-and-algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structures-and-Algorithms"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structures-and-Algorithms"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structures-and-Algorithms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>검색 알고리즘 (Search Algorithms)</h2></header><div class=entry-content><p>검색 알고리즘 (Searching Algorithms) 검색 알고리즘은 데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 알고리즘이다
이러한 알고리즘은 컴퓨터 과학의 핵심 요소로, 우리가 디지털 세계에서 정보를 찾고 처리하는 방식의 기반이 된다.
검색 알고리즘의 효율성은 데이터베이스, 웹 검색 엔진, 인공지능 등 현대 기술의 성능에 직접적인 영향을 미친다.
검색 알고리즘은 컴퓨터 과학의 핵심 요소로, 데이터를 효율적으로 찾고 처리하는 기초가 된다.
순차 검색부터 이진 검색, 해시 기반 검색, 트리 기반 검색, 그래프 검색 등 다양한 검색 알고리즘이 있으며, 각각은 특정 상황과 데이터 유형에 적합한 장단점을 가지고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-14 01:27:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 검색 알고리즘 (Search Algorithms)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting-and-searching/search-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Brute Force</h2></header><div class=entry-content><p>Back Tracking vs. Brute Force 브루트 포스와 백트래킹은 모두 조합 최적화 문제를 해결하는 데 사용되는 중요한 알고리즘 패러다임이다.
브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.
브루트 포스(Brute Force) 브루트 포스는 가능한 모든 경우의 수를 전부 확인하는 완전 탐색 알고리즘이다.
이 방법은 문제 해결을 위해 가능한 모든 후보해를 체계적으로 나열하고 각각을 검사한다.
브루트 포스의 작동 방식:
...</p></div><footer class=entry-footer><span title='2024-12-29 14:02:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>tail Recursion vs. Non-tail Recursion</h2></header><div class=entry-content><p>Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.
특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.
꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to tail Recursion vs. Non-tail Recursion" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adjacency Matrix vs Adjacency List</h2></header><div class=entry-content><p>그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교 그래프는 컴퓨터 과학에서 매우 중요한 자료구조로, 데이터 간의 관계를 효과적으로 표현할 수 있다.
그래프를 표현하는 방법을 선택할 때는 해결하려는 문제의 특성과 그래프의 구조를 고려해야 한다.
간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.
실제로는 두 방법을 혼합하거나 응용한 자료구조를 사용하기도 한다. 많은 실제 응용 사례(소셜 네트워크, 웹 페이지 연결 등)에서는 정점 수에 비해 간선 수가 적은 희소 그래프의 특성을 가지므로 인접 리스트가 더 많이 사용되는 경향이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 15:31:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adjacency Matrix vs Adjacency List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/graphs/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Postorder Traversal</h2></header><div class=entry-content><p>후위 순회(Postorder Traversal) 후위 순회(Postorder Traversal)는 트리 자료구조를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나로, 특별한 방문 순서와 특성을 가지고 있다.
후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.
트리 삭제, 표현식 평가, 디렉토리 크기 계산과 같은 작업에서 후위 순회의 특성이 자연스럽게 활용된다.
재귀적 구현이 가장 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 고급 기법을 통해 성능과 공간 효율성을 개선할 수 있다. 각 구현 방법은 상황에 따라 장단점이 있으므로, 문제의 성격과 제약 조건을 고려하여 적절한 방법을 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Postorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/binary-trees/basic-binary-trees/traversals/postorder-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬은 간단하면서도 직관적인 정렬 알고리즘으로, 실생활에서 카드 게임을 할 때 손에 든 카드를 정렬하는 방식과 매우 유사하다.
삽입 정렬은 간단하고 직관적인 정렬 알고리즘으로, 작은 데이터셋이나 거의 정렬된 데이터에서 효율적으로 작동한다.
비록 큰 데이터셋에서는 O(n²)의 시간 복잡도로 인해 퀵 정렬, 합병 정렬, 힙 정렬 등에 비해 느리지만, 그 단순함과 특정 상황에서의 효율성으로 인해 여전히 중요한 알고리즘이다.
실제 응용에서는 종종 다른 정렬 알고리즘과 함께 하이브리드 접근 방식으로 사용되며, 이를 통해 더 나은 성능을 얻을 수 있다. 또한 이진 탐색을 활용한 최적화나 셸 정렬과 같은 변형을 통해 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting-and-searching/comparison-based-sorting/simple-sorts/insertion-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Traversal</h2></header><div class=entry-content><p>Back Tracking vs. Traversal 백트래킹과 트래버설은 컴퓨터 과학에서 문제 해결과 데이터 구조 탐색에 사용되는 중요한 알고리즘 패러다임이다.
두 기법은 겉보기에 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.
백트래킹과 트래버설은 서로 다른 목적과 접근 방식을 가지고 있지만, 많은 복잡한 문제 해결에서 상호 보완적으로 사용된다.
트래버설은 데이터 구조의 모든 요소를 효율적으로 방문하는 체계적인 방법을 제공하고, 백트래킹은 방대한 해결책 공간에서 효율적으로 유망한 해결책을 찾는 전략을 제공한다.
실제 문제 해결에서는 두 개념의 장점을 결합하여 사용하는 것이 효과적이다.
예를 들어, 그래프에서 특정 조건을 만족하는 경로를 찾기 위해 DFS나 BFS와 같은 트래버설 알고리즘으로 그래프를 탐색하면서, 백트래킹 기법을 활용하여 유망하지 않은 경로는 조기에 포기하는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-12-09 14:55:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Level Order Traversal</h2></header><div class=entry-content><p>레벨 순서 순회 (Level Order Traversal) 트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.
이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.
레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.
큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.
특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Level Order Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/binary-trees/basic-binary-trees/traversals/level-order-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.
여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.
병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.
알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.
병합 정렬의 기본 원리 병합 정렬은 다음 세 단계로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Depth-First Search</h2></header><div class=entry-content><p>Back Tracking vs. Depth-First Search 백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.
DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.
백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.
깊이 우선 탐색(Depth-First Search, DFS) 깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:55:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Depth-First Search" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-depth-first-search/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>