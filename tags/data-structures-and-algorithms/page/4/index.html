<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structures-and-Algorithms | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structures-and-algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structures-and-algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structures-and-Algorithms"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structures-and-Algorithms"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structures-and-Algorithms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Traversal 방법 비교</h2></header><div class=entry-content><p>Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.
각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.
트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.
중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traversal 방법 비교" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬은 1960년 Tony Hoare가 개발한 효율적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 성능을 보이는 정렬 방식이다. 실제 많은 프로그래밍 언어의 표준 라이브러리에 구현되어 있을 정도로 실용적인 정렬 알고리즘이다.
퀵 정렬은 간단한 아이디어를 바탕으로 하면서도 매우 효율적인 정렬 알고리즘이다.
평균적인 성능이 우수하고 실제 구현에서 다양한 최적화 기법을 적용할 수 있어 많은 환경에서 선호된다.
최악의 경우를 대비한 피벗 선택 최적화와 하이브리드 접근 방식을 통해 단점을 보완하여 현대적인 정렬 알고리즘의 기반이 되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/types/quick-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>힙 정렬 (Heap Sort)</h2></header><div class=entry-content><p>힙 정렬 (Heap Sort) 힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.
시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.
힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.
최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.
불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 정렬 (Heap Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/types/heap-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linear Data Structure vs Non-Linear Data Structure</h2></header><div class=entry-content><p>Non-Primitive Linear Data Structure vs. Non-Linear Data Structure 데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.
측면 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적 또는 선형적으로 배열된 구조 데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조 구조 단일 레벨 구조 다중 레벨 구조 데이터 관계 요소 간 1:1 관계 요소 간 1:N 또는 N:N 관계 순회 단일 실행으로 모든 요소 순회 가능 단일 실행으로 모든 요소 순회 불가능 구현 복잡성 구현이 상대적으로 간단 구현이 상대적으로 복잡 메모리 사용 메모리 사용이 덜 효율적 메모리 사용이 더 효율적 시간 복잡도 입력 크기에 따라 증가 특정 작업에서 더 효율적 데이터 접근 순차적 접근 계층적 또는 네트워크 기반 접근 삽입/삭제 상대적으로 간단 더 복잡하지만 유연함 응용 분야 간단한 데이터 저장 및 처리 복잡한 관계 표현, AI, 이미지 처리 등 예시 배열, 연결 리스트, 스택, 큐 트리, 그래프, 해시 테이블, 힙 공통점:
...</p></div><footer class=entry-footer><span title='2024-10-12 11:00:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linear Data Structure vs Non-Linear Data Structure" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Primitive data structure vs Non-Primitive data structure</h2></header><div class=entry-content><p>Primitive Data Structure vs. Non-Primitive Data Structure Primitive Data Structure Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.
주요 특징 단순성: 가장 기본적이고 이해하기 쉬운 데이터 타입이다. 고정 크기: 일반적으로 고정된 메모리 크기를 가진다. 효율성: 메모리 사용과 접근 시간 측면에서 매우 효율적이다. 직접 표현: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다. 값 의미론: 변수에 실제 값이 직접 저장된다. 스택 할당: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다. 주요 primitive data structure들을 비교 분석하여 정리한 표:
...</p></div><footer class=entry-footer><span title='2024-10-12 08:39:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Primitive data structure vs Non-Primitive data structure" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Segment Tree</h2></header><div class=entry-content><p>Segment Tree 세그먼트 트리는 구간 또는 범위에 대한 정보를 저장하고 관리하는 트리 형태의 자료구조이다. 데이터베이스, 파일 시스템, 네트워크 라우팅 등 다양한 응용 프로그램에서 사용되며, 효율적인 구간 쿼리와 업데이트 연산을 제공하는 특수한 데이터 구조이다.
https://www.geeksforgeeks.org/segment-tree-data-structure/
특징 완전 이진 트리 구조를 가진다. 각 노드는 배열의 특정 구간에 대한 정보를 저장한다. 리프 노드는 배열의 개별 원소를 나타낸다. 부모 노드는 자식 노드들의 정보를 결합한 값을 저장한다. 장점 구간 쿼리의 시간 복잡도가 O(log n)으로 매우 효율적이다. 데이터 업데이트 시 O(log n) 시간에 트리를 갱신할 수 있다. 동적인 상황에서도 효율적으로 작동한다. 단점 일반 배열에 비해 더 많은 메모리를 사용한다 (약 4n의 공간 복잡도). 구현이 상대적으로 복잡할 수 있다. 응용 데이터베이스 시스템의 범위 쿼리 최적화 컴퓨터 그래픽스의 렌더링 최적화 네트워크 라우팅 테이블 관리 금융 데이터 분석의 구간 통계 계산 동작 원리 트리 구축 (Build):
...</p></div><footer class=entry-footer><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Segment Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/advanced/segment-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>슬라이딩 윈도우 기법 (Sliding Window Technique)</h2></header><div class=entry-content><p>슬라이딩 윈도우 기법 (Sliding Window Technique) 슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.
이 기법은 “창문(window)“처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.
슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-24 00:21:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 슬라이딩 윈도우 기법 (Sliding Window Technique)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/sliding-window-technique/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Brute Force</h2></header><div class=entry-content><p>Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.
두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.
먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.
Divide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 세 가지 주요 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Branch and Bound</h2></header><div class=entry-content><p>Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.
“Divide and Conquer"와 “Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.
분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.
두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Branch and Bound" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>최적 부분 구조(Optimal Substructure)</h2></header><div class=entry-content><p>최적 부분 구조(Optimal Substructure) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.
동적 계획법이 적용되기 위해서는 두 가지 핵심 특성이 필요하다:
중복되는 하위 문제(Overlapping Subproblems) 최적 부분 구조(Optimal Substructure)
이다. 최적 부분 구조는 효율적인 알고리즘 설계의 핵심 개념이다.
문제의 특성을 이해하고 최적 부분 구조를 식별할 수 있다면, 복잡한 문제도 동적 계획법이나 그리디 알고리즘을 통해 효율적으로 해결할 수 있다.
최적 부분 구조가 없는 문제는 다른 접근 방식(예: 분할 정복, 백트래킹)을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2025-01-22 14:02:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 최적 부분 구조(Optimal Substructure)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>