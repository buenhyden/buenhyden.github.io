<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data-Structures-and-Algorithms | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/data-structures-and-algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/data-structures-and-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/data-structures-and-algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data-Structures-and-Algorithms"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data-Structures-and-Algorithms"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Data-Structures-and-Algorithms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>무방향 그래프(Undirected Graph)</h2></header><div class=entry-content><p>무방향 그래프(Undirected Graph) 무방향 그래프(Undirected Graph) 는 각 간선(Edge)에 방향성이 없는 그래프이다.
즉, 정점 A와 정점 B가 간선으로 연결되어 있으면, A에서 B로 가는 것과 B에서 A로 가는 것이 동일하다.
무방향 그래프 특징 간선이 양방향(↔)으로 연결됨 정점 간 이동에 방향성이 없음 정점의 차수(Degree)는 해당 정점과 연결된 간선의 개수 DFS(깊이 우선 탐색), BFS(너비 우선 탐색) 등의 알고리즘이 적용 가능 연결 그래프(Connected Graph)와 비연결 그래프(Disconnected Graph) 개념 적용 가능 무방향 그래프의 표현 방법 1 2 3 A — B | | C — D A - B (A와 B는 서로 연결됨) A - C (A와 C는 서로 연결됨) B - D (B와 D는 서로 연결됨) C - D (C와 D는 서로 연결됨) 무방향 그래프의 인접 행렬(Adjacency Matrix) 표현 A B C D A 0 1 1 0 B 1 0 0 1 C 1 0 0 1 D 0 1 1 0 설명
...</p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 무방향 그래프(Undirected Graph)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/undirected-graph/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>방향 그래프(Directed Graph)</h2></header><div class=entry-content><p>방향 그래프(Directed Graph) 방향 그래프(Directed Graph, Digraph) 는 각 간선(Edge)에 방향성이 부여된 그래프이다.
즉, 간선이 단방향이므로 A → B 는 이동할 수 있지만 B → A 로는 이동할 수 없다.
방향 그래프는 일방향 관계가 있는 다양한 시스템을 모델링할 수 있다.
웹, 사회 연결망, 컴퓨터 시스템, 생물학적 네트워크 등 다양한 분야에서 방향 그래프를 활용한 알고리즘과 모델이 개발되고 있다.
방향 그래프 특징 간선이 한 방향(→)으로만 연결됨 단방향 관계를 표현할 때 사용 (예: 팔로우 관계, 웹 페이지 링크) 진입 차수(In-degree)와 진출 차수(Out-degree) 개념이 존재 진입 차수(In-degree): 해당 정점으로 들어오는 간선의 개수 진출 차수(Out-degree): 해당 정점에서 나가는 간선의 개수 방향 그래프의 표현 방법 방향 그래프 예시
...</p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 방향 그래프(Directed Graph)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/directed-graph/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NP-Hard vs. NP-Complete</h2></header><div class=entry-content><p>NP-Hard vs. NP-Complete 계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.
이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.
NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.
핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:02:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NP-Hard vs. NP-Complete" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asymptotic Notation</h2></header><div class=entry-content><p>점근적 표기법(Asymptotic Notation) 점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.
알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.
점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.
빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.
그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.
따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 10:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asymptotic Notation" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Types of Sorting Algorithm</h2></header><div class=entry-content><p>Sorting Algorithms 비교 정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.
정렬 알고리즘은 시간 복잡도, 공간 복잡도, 안정성, 실행 속도 등의 성능 차이로 인해 다양한 방식이 존재한다.
각 정렬 알고리즘은 고유한 특성과 작동 방식을 가지고 있습니다. 여기서는 6가지 주요 정렬 알고리즘을 공통된 예시 배열 [8, 5, 2, 6, 9, 3, 1, 4, 7]을 사용하여 비교 분석하겠습니다.
정렬 알고리즘 비교 각 정렬 알고리즘은 고유한 특성과 장단점을 가지고 있으며, 적용 상황에 따라 최적의 선택이 달라진다:
...</p></div><footer class=entry-footer><span title='2024-10-15 04:16:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Sorting Algorithm" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/sorting-algorithm-comparison/comparison--of-sorting-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모이제이션 (Memoization)</h2></header><div class=entry-content><p>메모이제이션 (Memoization) 메모이제이션은 “기억하다"라는 뜻의 라틴어 ‘memorandum’에서 유래했다.
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.
실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때
메모이제이션 미사용: 같은 단어가 나올 때마다 매번 사전을 찾음 메모이제이션 사용: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고
로 이해 가능하다. 메모이제이션의 작동 원리 함수가 호출될 때 입력값을 확인한다. 해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다. 저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 def memoized_function(n, memo={}): # 1. 이미 계산된 값인지 확인 if n in memo: return memo[n] # 2. 새로운 값 계산 result = ... # 계산 로직 # 3. 계산된 값을 저장 memo[n] = result # 4. 결과 반환 return result 메모이제이션의 장점 실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다. 자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다. 메모이제이션의 사용 예시 가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모이제이션 (Memoization)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/memoization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cuckoo Hash Table</h2></header><div class=entry-content><p>Cuckoo Hash Table Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.
특징 다중 해시 함수: 일반적으로 두 개 이상의 해시 함수를 사용한다. 결정적 성능: 최악의 경우에도 일정한 시간 복잡도를 보장한다. 동적 재배치: 충돌 발생 시 기존 항목을 다른 위치로 이동시킨다. 장점 빠른 검색 속도: O(1) 시간 복잡도로 검색 연산을 수행한다. 공간 효율성: 높은 로드 팩터를 유지할 수 있다. 삭제 연산 지원: Bloom Filter와 달리 효율적인 삭제가 가능하다. 단점 삽입 연산의 복잡성: 최악의 경우 무한 루프에 빠질 수 있어 재해싱이 필요할 수 있다. 구현의 복잡성: 일반 해시 테이블에 비해 구현이 더 복잡하다. 응용 데이터베이스 인덱싱 네트워크 라우팅 테이블 캐시 시스템 스팸 필터링 동작 원리 삽입:
...</p></div><footer class=entry-footer><span title='2024-10-09 12:57:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cuckoo Hash Table" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/cuckoo-hashing/cuckoo-hash-table/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/data-structures-and-algorithms/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>