<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data-Structures-and-Algorithms on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/data-structures-and-algorithms/</link>
    <description>Recent content in Data-Structures-and-Algorithms on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.150.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 24 Jan 2025 07:17:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/data-structures-and-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>State Representation</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/state-representation/</link>
      <pubDate>Tue, 21 Jan 2025 14:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/state-representation/</guid>
      <description>상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.</description>
    </item>
    <item>
      <title>가지치기(Pruning)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/backtracking-implementation/pruning/</link>
      <pubDate>Sun, 29 Dec 2024 14:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/backtracking-implementation/pruning/</guid>
      <description>가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.</description>
    </item>
    <item>
      <title>Algorithmic Thinking</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/</link>
      <pubDate>Fri, 27 Dec 2024 07:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/</guid>
      <description>알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.</description>
    </item>
    <item>
      <title>꼬리 재귀(Tail Recursion)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 09:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/</guid>
      <description>Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.</description>
    </item>
    <item>
      <title>인접 행렬(Adjacency Matrix)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/</link>
      <pubDate>Sat, 07 Dec 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/</guid>
      <description>수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.</description>
    </item>
    <item>
      <title>Algorithmic Complexity</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/algorithmic-complexity/</link>
      <pubDate>Fri, 06 Dec 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/algorithmic-complexity/</guid>
      <description>알고리즘 복잡도는 프로그램이나 알고리즘이 문제를 해결할 때 소요하는 시간과 공간, 즉 컴퓨팅 자원의 사용량을 입력 크기에 따라 수학적으로 분석하는 방법이다.</description>
    </item>
    <item>
      <title>Preorder Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/preorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/preorder-traversal/</guid>
      <description>전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태로, 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 &amp;#34;전위(Pre)&amp;#34;는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.</description>
    </item>
    <item>
      <title>Tree Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/</link>
      <pubDate>Fri, 06 Dec 2024 03:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/</guid>
      <description>트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다.</description>
    </item>
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/bubble-sort/</guid>
      <description>버블 정렬(Bubble Sort)은 인접한 요소를 반복적으로 비교하고 교환하여 정렬하는 간단한 알고리즘이다.</description>
    </item>
    <item>
      <title>정렬 알고리즘 (Sorting Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/</guid>
      <description>정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>튜링 기계 (Turing Machine)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/computational-models/machine-models/turing-machine/</link>
      <pubDate>Sun, 13 Oct 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/computational-models/machine-models/turing-machine/</guid>
      <description>튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.</description>
    </item>
    <item>
      <title>AVL 트리 (AVL tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/avl-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/avl-tree/</guid>
      <description>AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리이다.  각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.</description>
    </item>
    <item>
      <title>논리값 (Boolean)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/boolean-logic/</link>
      <pubDate>Mon, 07 Oct 2024 07:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/boolean-logic/</guid>
      <description>Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.</description>
    </item>
    <item>
      <title>Branching Strategies</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branching-strategies/</link>
      <pubDate>Tue, 21 Jan 2025 14:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branching-strategies/</guid>
      <description>분기 전략은 현재 부분 문제를 더 작은 하위 문제로 분할하는 방식을 정의한다. 이 과정에서 해결책 공간은 상호 배타적인 부분 공간으로 나뉘며, 이들을 모두 합치면 원래의 해결책 공간을 완전히 포함한다.</description>
    </item>
    <item>
      <title>Branch and Bound vs. Backtracking</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/</link>
      <pubDate>Fri, 10 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/</guid>
      <description>백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.</description>
    </item>
    <item>
      <title>상태 공간 트리(State Space Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/backtracking-implementation/state-space/</link>
      <pubDate>Sun, 29 Dec 2024 13:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/backtracking-implementation/state-space/</guid>
      <description>상태 공간 트리는 문제 해결 과정에서 가능한 모든 상태(state)와 그 상태들 간의 전이(transition)를 트리 형태로 표현한 자료구조이다.</description>
    </item>
    <item>
      <title>비꼬리 재귀(Non-tail Recursion)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/non-tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 09:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/non-tail-recursion/</guid>
      <description>Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다</description>
    </item>
    <item>
      <title>인접 리스트 (Adjacency List)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-list/</guid>
      <description>인접 리스트는 그래프 표현 방법 중 하나로, 각 정점(vertex)에 연결된 인접 정점들을 리스트 형태로 저장하는 방식이다.</description>
    </item>
    <item>
      <title>Inorder Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/inorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/inorder-traversal/</guid>
      <description>왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/selection-sort/</guid>
      <description>선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.</description>
    </item>
    <item>
      <title>이진 검색 (Binary Search)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/binary-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/binary-search/</guid>
      <description>리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다</description>
    </item>
    <item>
      <title>검색 알고리즘 (Search Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/searching-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/searching-algorithms/</guid>
      <description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</description>
    </item>
    <item>
      <title>복잡도 클래스(Complexity Classes)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/complexity-classes/</link>
      <pubDate>Sun, 13 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/complexity-classes/</guid>
      <description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</description>
    </item>
    <item>
      <title>이진 검색 트리 (Binary Search Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-search-trees/</link>
      <pubDate>Mon, 07 Oct 2024 12:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-search-trees/</guid>
      <description>BST는 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용되는 특수한 이진 트리 구조이다.</description>
    </item>
    <item>
      <title>문자 (Character)과 문자열 (String)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/characters-and-strings/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/characters-and-strings/</guid>
      <description>문자 (Character)는 단일 문자를 표현하는 데이터 타입이고,문자열 (String)은 문자들의 배열 또는 시퀀스</description>
    </item>
    <item>
      <title>배열 (Array)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array/</link>
      <pubDate>Mon, 07 Oct 2024 05:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array/</guid>
      <description>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.</description>
    </item>
    <item>
      <title>Recursion vs. Iteration</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/</link>
      <pubDate>Sun, 06 Oct 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/</guid>
      <description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</description>
    </item>
    <item>
      <title>Data Structures and Algorithms</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/</link>
      <pubDate>Thu, 19 Sep 2024 15:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/</guid>
      <description>데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문</description>
    </item>
    <item>
      <title>한계 함수(Bounding Functions)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/bounding-functions/</link>
      <pubDate>Fri, 03 Jan 2025 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/bounding-functions/</guid>
      <description>한계 함수는 분기한정법의 효율성을 결정짓는 중요한 요소로, 불필요한 탐색을 줄이고 최적해를 빠르게 찾는 데 결정적인 역할을 한다.</description>
    </item>
    <item>
      <title>Back Tracking vs. Brute Force</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-brute-force/</link>
      <pubDate>Sun, 29 Dec 2024 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-brute-force/</guid>
      <description>브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.</description>
    </item>
    <item>
      <title>tail Recursion vs. Non-tail Recursion</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion-vs-non-tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 00:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion-vs-non-tail-recursion/</guid>
      <description>재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다.</description>
    </item>
    <item>
      <title>Adjacency Matrix vs Adjacency List</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 15:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</guid>
      <description>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.</description>
    </item>
    <item>
      <title>Postorder Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/postorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/postorder-traversal/</guid>
      <description>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/insertion-sort/</guid>
      <description>삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>Recursion</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/</link>
      <pubDate>Mon, 14 Oct 2024 13:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/</guid>
      <description>재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.</description>
    </item>
    <item>
      <title>정수(Integer)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/integer-types/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/integer-types/</guid>
      <description>정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.</description>
    </item>
    <item>
      <title>Data Structures</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/</link>
      <pubDate>Mon, 07 Oct 2024 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/</guid>
      <description>데이터를 효율적으로 저장, 관리, 접근하기 위한 방법</description>
    </item>
    <item>
      <title>연결 리스트 (Linked List)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/</guid>
      <description>각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조</description>
    </item>
    <item>
      <title>Back Tracking vs. Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-traversal/</link>
      <pubDate>Mon, 09 Dec 2024 14:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-traversal/</guid>
      <description>백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.</description>
    </item>
    <item>
      <title>Level Order Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/level-order-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/level-order-traversal/</guid>
      <description>레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/merge-sort/</guid>
      <description>병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>Algorithms</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 08:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/algorithms/</guid>
      <description>문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차</description>
    </item>
    <item>
      <title>브루트 포스 (Brute Force)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/brute-force/</link>
      <pubDate>Sun, 13 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/brute-force/</guid>
      <description>브루트 포스는 &amp;#34;무식한 힘&amp;#34;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>레드-블랙 트리 (red-black tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/red-black-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/red-black-tree/</guid>
      <description>Red-black tree는 각 노드에 추가적인 색상 속성(빨간색 또는 검은색)을 가진 자체 균형 이진 검색 트리로, 트리의 균형을 유지하여 효율적인 검색, 삽입, 삭제 연산을 보장한다.</description>
    </item>
    <item>
      <title>해시 테이블(Hash Table)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table/</guid>
      <description>키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 키를 인덱스로 변환</description>
    </item>
    <item>
      <title>부동 소수점 (Float)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/floating-point/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/floating-point/</guid>
      <description>부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.</description>
    </item>
    <item>
      <title>Back Tracking vs. Depth-First Search</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-depth-first-search/</link>
      <pubDate>Sun, 29 Dec 2024 13:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/back-tracking-vs-depth-first-search/</guid>
      <description>DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.</description>
    </item>
    <item>
      <title>Traversal 방법 비교</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/comparison-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-trees/tree-traversals/comparison-traversal/</guid>
      <description>트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/quick-sort/</guid>
      <description>퀵 정렬(Quick Sort)은 분할 정복(divide and conquer) 전략을 사용하는 고성능 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>백트래킹 (Backtracking)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/</guid>
      <description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</description>
    </item>
    <item>
      <title>Problem Solving Techniques</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/problem-solving-techniques/</link>
      <pubDate>Sun, 13 Oct 2024 05:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/problem-solving-techniques/</guid>
      <description>주어진 문제를 효과적으로 분석하고 해결하기 위한 알고리즘 및 자료 구조를 적용하는 방법론</description>
    </item>
    <item>
      <title>Splay Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/splay-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/splay-tree/</guid>
      <description>Splay Tree는 자체 균형 이진 검색 트리의 일종으로, 최근에 접근한 노드를 루트로 이동시키는 &amp;#34;splay&amp;#34; 연산을 통해 자가 조정되는 특징을 가진다.</description>
    </item>
    <item>
      <title>스택 (Stack)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/stack/</link>
      <pubDate>Wed, 09 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/stack/</guid>
      <description>LIFO(Last In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/priority-queue-applications/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/priority-queue-applications/heap-sort/</guid>
      <description>힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>분기 한정법 (Branch and Bound)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/</guid>
      <description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</description>
    </item>
    <item>
      <title>Linear Data Structure vs Non-Linear Data Structure</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/linear-vs-non-linear-structure/</link>
      <pubDate>Sat, 12 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/linear-vs-non-linear-structure/</guid>
      <description>Linear Data Structure vs. Non-Linear Data Structure</description>
    </item>
    <item>
      <title>Primitive vs Non-Primitive structure</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/</link>
      <pubDate>Sat, 12 Oct 2024 08:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/</guid>
      <description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description>
    </item>
    <item>
      <title>힙 (Heap)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/heaps/</link>
      <pubDate>Mon, 07 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/heaps/</guid>
      <description>부모 노드와 자식 노드 간의 대소 관계가 일정한 규칙을 따르는 자료구조</description>
    </item>
    <item>
      <title>큐 (Queue)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue/</guid>
      <description>FIFO(First In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>분할 정복 (Divide and Conquer)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/</link>
      <pubDate>Sun, 13 Oct 2024 05:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/</guid>
      <description>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.</description>
    </item>
    <item>
      <title>트리 (Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/trees/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/trees/</guid>
      <description>계층적 구조를 가진 비선형 데이터 구조로, 노드들이 부모-자식 관계로 연결되어 있다</description>
    </item>
    <item>
      <title>동적 계획법 (Dynamic Programming)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/</guid>
      <description>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>그래프 (Graph)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graphs/</link>
      <pubDate>Mon, 07 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graphs/</guid>
      <description>노드(정점)와 엣지(간선)로 구성된 비선형 데이터 구조</description>
    </item>
    <item>
      <title>탐욕 알고리즘 (Greedy Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/greedy-algorithms/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/greedy-algorithms/</guid>
      <description>문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다. 즉, &amp;#39;탐욕적&amp;#39;으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.</description>
    </item>
    <item>
      <title>랜덤화 알고리즘 (Randomized Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/randomized-algorithms/</link>
      <pubDate>Sun, 13 Oct 2024 05:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/randomized-algorithms/</guid>
      <description>랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다.</description>
    </item>
    <item>
      <title>슬라이딩 윈도우 기법 (Sliding Window Technique)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sliding-window/</link>
      <pubDate>Fri, 24 Jan 2025 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sliding-window/</guid>
      <description>슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 &amp;#34;슬라이딩&amp;#34;하면서 문제를 해결한다.</description>
    </item>
    <item>
      <title>Divide and Conquer vs. Brute Force</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-brute-force/</link>
      <pubDate>Fri, 24 Jan 2025 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-brute-force/</guid>
      <description>Divide and Conquer vs. Brute Force 비교 분석</description>
    </item>
    <item>
      <title>Divide and Conquer vs. Branch and Bound</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/</link>
      <pubDate>Fri, 24 Jan 2025 02:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/</guid>
      <description>분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.</description>
    </item>
    <item>
      <title>최적 부분 구조(Optimal Substructure)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/optimal-substructure/</link>
      <pubDate>Wed, 22 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/optimal-substructure/</guid>
      <description>최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.</description>
    </item>
    <item>
      <title>중복되는 하위 문제(Overlapping Subproblems)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/</link>
      <pubDate>Tue, 21 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/</guid>
      <description>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.</description>
    </item>
    <item>
      <title>무방향 그래프(Undirected Graph)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/undirected-graph/</link>
      <pubDate>Sat, 18 Jan 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/undirected-graph/</guid>
      <description>무방향 그래프(Undirected Graph) 는 각 간선(Edge)에 방향성이 없는 그래프이다.</description>
    </item>
    <item>
      <title>방향 그래프(Directed Graph)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/directed-graph/</link>
      <pubDate>Sat, 18 Jan 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/directed-undirected/directed-graph/</guid>
      <description>방향 그래프(Directed Graph, Digraph) 는 각 간선(Edge)에 방향성이 부여된 그래프이다.</description>
    </item>
    <item>
      <title>Bottom-up Approach</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-implementation/bottom-up-approach/</link>
      <pubDate>Thu, 09 Jan 2025 04:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-implementation/bottom-up-approach/</guid>
      <description>가장 작은 하위 문제부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 방식이다.  모든 하위 문제의 결과를 테이블(일반적으로 배열)에 저장하고, 이미 계산된 결과를 활용하여 상위 문제를 해결한다.</description>
    </item>
    <item>
      <title>Greedy Algorithm vs. Divide and Conquer</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/greedy-vs-divide-and-conquer/</link>
      <pubDate>Sat, 28 Dec 2024 10:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/greedy-vs-divide-and-conquer/</guid>
      <description>분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.</description>
    </item>
    <item>
      <title>Deterministic vs. Nondeterministic computation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/</guid>
      <description>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</description>
    </item>
    <item>
      <title>P vs NP problem</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/</guid>
      <description>P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다</description>
    </item>
    <item>
      <title>NP-Hard vs. NP-Complete</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/</link>
      <pubDate>Fri, 27 Dec 2024 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/</guid>
      <description>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</description>
    </item>
    <item>
      <title>NP-난해(NP-Hard)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/</guid>
      <description>문제 H가 NP-Hard라는 것은, 모든 NP 문제가 다항 시간 내에 H로 환원(reduce)될 수 있다는 것을 의미한다.</description>
    </item>
    <item>
      <title>다항 공간(Polynomial Space) 클래스</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/space-complexity-classes/pspace/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/space-complexity-classes/pspace/</guid>
      <description>PSPACE는 결정론적 튜링 기계에서 다항 크기의 메모리를 사용하여 해결할 수 있는 모든 결정 문제의 집합이다.</description>
    </item>
    <item>
      <title>지수 시간(Exponential Time) 복잡도</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/exptime/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/exptime/</guid>
      <description>지수 시간(Exponential Time) 복잡도는 알고리즘의 실행 시간이 입력 크기에 대해 지수적으로 증가하는 경우를 나타낸다.</description>
    </item>
    <item>
      <title>NP-완전(NP-Complete)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-complete/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-complete/</guid>
      <description>NP-완전 문제는 NP 클래스 내에서 가장 &amp;#34;어려운&amp;#34; 문제들이다.</description>
    </item>
    <item>
      <title>다항 시간(Polynomial Time, P)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p/</guid>
      <description>다항 시간(Polynomial Time)이란 알고리즘의 실행 시간이 입력 크기 n에 대한 다항식 함수로 표현될 수 있음을 의미한다.  즉, 알고리즘의 시간 복잡도가 O(n^k) 형태로 표현되는 경우를 말한다.</description>
    </item>
    <item>
      <title>비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/np/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/np/</guid>
      <description>비결정론적 다항 시간(NP)은 비결정론적 튜링 기계(Non-deterministic Turing Machine)에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합을 의미한다. 좀 더 직관적인 정의로는 &amp;#34;해답이 주어졌을 때 그 해답이 올바른지 다항 시간 내에 검증할 수 있는 문제들의 집합&amp;#34;이라고 할 수 있다.</description>
    </item>
    <item>
      <title>Dynamic Programming vs. Divide and Conquer</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/divide-and-conquer-vs-dp/</link>
      <pubDate>Mon, 09 Dec 2024 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/divide-and-conquer-vs-dp/</guid>
      <description>Divide and Conquer&amp;#34;와 &amp;#34;Dynamic Programming&amp;#34;은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.</description>
    </item>
    <item>
      <title>Collision resolutions</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table-fundamentals/collision-resolution/</link>
      <pubDate>Sun, 08 Dec 2024 13:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table-fundamentals/collision-resolution/</guid>
      <description>해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.</description>
    </item>
    <item>
      <title>Stack vs Queue</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/data-structure-comparisons/linear-structure-comparison/stack-vs-queue/</link>
      <pubDate>Sun, 08 Dec 2024 08:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/data-structure-comparisons/linear-structure-comparison/stack-vs-queue/</guid>
      <description>스택(Stack)과 큐(Queue)는 컴퓨터 과학에서 널리 사용되는 선형 자료구조로, 데이터의 저장 및 처리 방식에서 차이가 있다.</description>
    </item>
    <item>
      <title>Asymptotic Notation</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/</link>
      <pubDate>Fri, 06 Dec 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/</guid>
      <description>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.</description>
    </item>
    <item>
      <title>해시 함수 (Hash Function)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table-fundamentals/hash-functions/</link>
      <pubDate>Sat, 09 Nov 2024 21:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table-fundamentals/hash-functions/</guid>
      <description>임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수</description>
    </item>
    <item>
      <title>Types of Sorting Algorithm</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/sorting-algorithm-comparison/comparison--of-sorting-algorithm/</link>
      <pubDate>Tue, 15 Oct 2024 04:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/sorting-algorithm-comparison/comparison--of-sorting-algorithm/</guid>
      <description>정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/reducibility/</guid>
      <description>환원 가능성은 하나의 문제를 다른 문제로 &amp;#34;변환&amp;#34;할 수 있는 능력을 의미한다.</description>
    </item>
    <item>
      <title>메모이제이션 (Memoization)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/memoization/</link>
      <pubDate>Sun, 13 Oct 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/memoization/</guid>
      <description>메모이제이션(Memoization)은 컴퓨터 프로그래밍에서 사용되는 최적화 기법으로, 함수의 호출 결과를 저장해두고 재사용함으로써 프로그램의 실행 속도를 향상시키는 방법이다.</description>
    </item>
    <item>
      <title>테이블레이션(Tabulation)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/tabulation/</guid>
      <description>Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.</description>
    </item>
    <item>
      <title>Octree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/octree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/octree/</guid>
      <description>Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.</description>
    </item>
    <item>
      <title>BK-tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/bk-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/bk-tree/</guid>
      <description>BK-Tree(Burkhard-Keller Tree)는 메트릭 공간(metric space)에서 효율적인 근사 검색을 위해 설계된 트리 기반 데이터 구조이다.  주로 레벤슈타인 거리(Levenshtein Distance)를 활용한 문자열 유사성 검색, 맞춤법 검사, DNA 시퀀스 분석에 활용된다.</description>
    </item>
    <item>
      <title>BSP Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/bsp-trees/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/bsp-trees/</guid>
      <description>BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것</description>
    </item>
    <item>
      <title>K-d Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/k-d-trees/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/k-d-trees/</guid>
      <description>K-d Tree는 k차원 공간에서 점들을 효율적으로 저장하고 검색하기 위한 이진 트리 기반의 공간 분할 데이터 구조로, K-d Tree는 k차원 공간을 재귀적으로 분할하여 표현하는 이진 트리이다.</description>
    </item>
    <item>
      <title>Merkle Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/practical-applications/algorithm-applications/cryptography/merkle-trees/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/practical-applications/algorithm-applications/cryptography/merkle-trees/</guid>
      <description>머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.  블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.</description>
    </item>
    <item>
      <title>Quad Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/quad-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/spatial-data-structures/quad-tree/</guid>
      <description>Quad Tree는 2차원 공간을 재귀적으로 4개의 영역으로 분할하여 표현하는 트리 기반의 데이터 구조로, 각 노드가 정확히 4개의 자식 노드를 갖는 트리 구조이다.</description>
    </item>
    <item>
      <title>Rope</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/specialized-trees/rope/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/specialized-trees/rope/</guid>
      <description>Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조</description>
    </item>
    <item>
      <title>Suffix Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/specialized-trees/suffix-trees/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/specialized-trees/suffix-trees/</guid>
      <description>Suffix Tree는 문자열의 모든 접미사를 효율적으로 저장하고 검색하는 특수한 트리 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>B 트리 (B-Trees)</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/</link>
      <pubDate>Fri, 11 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/</guid>
      <description>균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조</description>
    </item>
    <item>
      <title>Lock-free Stack</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/concurrent--parallel-structures/lock-free-structures/lock-free-stacks/</link>
      <pubDate>Wed, 09 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/concurrent--parallel-structures/lock-free-structures/lock-free-stacks/</guid>
      <description>Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.</description>
    </item>
    <item>
      <title>Cuckoo Hash Table</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/cuckoo-hashing/cuckoo-hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/cuckoo-hashing/cuckoo-hash-table/</guid>
      <description>Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.</description>
    </item>
    <item>
      <title>Bloom filter</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/bloom-filters/</link>
      <pubDate>Wed, 09 Oct 2024 12:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/bloom-filters/</guid>
      <description>블룸 필터(Bloom Filter)는 **공간 효율적인 확률적 데이터 구조**로, 원소가 집합에 속하는지 여부를 빠르게 확인하는 데 사용된다.</description>
    </item>
    <item>
      <title>Lock-free Queue</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/concurrent--parallel-structures/lock-free-structures/lock-free-queues/</link>
      <pubDate>Tue, 08 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/concurrent--parallel-structures/lock-free-structures/lock-free-queues/</guid>
      <description>Lock-free Queue는 락(lock)을 사용하지 않고 동시성을 제공하는 FIFO(First-In-First-Out) 자료구조이다.</description>
    </item>
    <item>
      <title>Circular Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/circular-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/circular-linked-list/</guid>
      <description>Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.</description>
    </item>
    <item>
      <title>Circular Queue</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue-implementation/circular-queue/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue-implementation/circular-queue/</guid>
      <description>Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.</description>
    </item>
    <item>
      <title>Doubly Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/doubly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/doubly-linked-list/</guid>
      <description>Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.</description>
    </item>
    <item>
      <title>Skip List</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/skip-list/</guid>
      <description>Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다</description>
    </item>
    <item>
      <title>Linked List vs. Array</title>
      <link>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/data-structure-comparisons/linear-structure-comparison/array-vs-linked-list/</link>
      <pubDate>Mon, 07 Oct 2024 16:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/data-structure-comparisons/linear-structure-comparison/array-vs-linked-list/</guid>
      <description>배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.</description>
    </item>
  </channel>
</rss>
