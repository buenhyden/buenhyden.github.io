<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>테스트 | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="테스트"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="테스트"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>테스트</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>5. 테스트 (Testing)</h2></header><div class=entry-content><p>테스트 (Testing) 개발된 소프트웨어의 품질을 검증하고 결함을 식별하는 단계
테스트 계획 수립 주요 목적 테스트의 범위, 접근 방식, 자원, 일정을 정의한다. 테스트 목표와 전략을 명확히 한다. 테스트 프로세스의 체계적인 구조를 제공한다. 필요한 테스트 환경과 도구를 식별한다. 테스트 활동의 효율성과 효과성을 높인다. 리스크를 식별하고 관리 전략을 수립한다. 이해관계자들에게 테스트 접근 방식에 대한 이해를 제공한다. 테스트 성공 기준을 정의한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 테스트 범위 정의 테스트 대상 기능 및 비기능 요구사항 식별 테스트 범위 문서 테스트 목표 설정 테스트를 통해 달성하고자 하는 목표 정의 테스트 목표 명세서 테스트 전략 수립 테스트 수행 방법 및 접근 방식 결정 테스트 전략 문서 테스트 유형 선정 수행할 테스트 유형(단위, 통합, 시스템 등) 결정 테스트 유형 목록 테스트 환경 계획 필요한 하드웨어, 소프트웨어, 네트워크 환경 정의 테스트 환경 명세서 테스트 일정 수립 테스트 활동의 일정과 마일스톤 설정 테스트 일정표 테스트 자원 할당 필요한 인력, 도구, 장비 등의 자원 계획 자원 할당 계획 테스트 데이터 준비 테스트에 필요한 데이터 식별 및 준비 계획 테스트 데이터 계획 리스크 분석 테스트 관련 리스크 식별 및 대응 전략 수립 리스크 관리 계획 테스트 메트릭스 정의 테스트 진행 상황 및 품질 측정 지표 선정 테스트 메트릭스 정의서 주의해야할 요소 주의 요소 설명 요구사항 이해 시스템 요구사항에 대한 정확한 이해와 반영 현실적인 계획 가용 자원과 시간을 고려한 실현 가능한 계획 수립 우선순위 설정 중요도와 리스크를 고려한 테스트 우선순위 결정 이해관계자 참여 모든 관련 이해관계자의 의견 수렴 및 동의 확보 유연성 변경사항에 대응할 수 있는 유연한 계획 구성 테스트 커버리지 충분한 테스트 커버리지 확보 방안 고려 자동화 고려 적절한 테스트 자동화 범위 및 방법 계획 보안 고려 테스트 과정에서의 데이터 보안 및 접근 제어 계획 규제 준수 관련 법규 및 산업 표준 준수 확인 지속적 개선 이전 프로젝트의 교훈을 반영한 계획 수립 테스트 케이스 설계 주요 목적 소프트웨어의 기능과 비기능적 요구사항을 검증한다. 다양한 입력 조건과 시나리오를 고려하여 포괄적인 테스트를 수행한다. 예상 결과를 명확히 정의하여 테스트 결과의 정확성을 판단한다. 효율적이고 효과적인 테스트 실행을 위한 기반을 마련한다. 버그와 결함을 조기에 발견하여 품질을 향상시킨다. 테스트의 재현성과 일관성을 보장한다. 테스트 커버리지를 최대화하여 소프트웨어의 신뢰성을 높인다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 분석 테스트 대상 요구사항 검토 및 이해 요구사항 분석 문서 테스트 기법 선택 적절한 테스트 설계 기법 결정 (예: 경계값 분석, 동등 분할 등) 테스트 기법 선정 문서 테스트 시나리오 작성 주요 테스트 시나리오 도출 테스트 시나리오 목록 테스트 케이스 작성 상세 테스트 케이스 개발 테스트 케이스 문서 테스트 데이터 준비 테스트에 필요한 입력 데이터 정의 테스트 데이터 세트 예상 결과 정의 각 테스트 케이스의 예상 결과 명시 예상 결과 문서 테스트 케이스 리뷰 작성된 테스트 케이스의 품질 검토 테스트 케이스 리뷰 보고서 테스트 매트릭스 작성 요구사항과 테스트 케이스 간 매핑 요구사항-테스트 매트릭스 우선순위 지정 테스트 케이스의 중요도 및 실행 순서 결정 우선순위가 지정된 테스트 케이스 목록 테스트 케이스 관리 테스트 케이스의 버전 관리 및 유지보수 테스트 케이스 저장소 주의해야할 요소 주의 요소 설명 요구사항 추적성 모든 요구사항이 테스트 케이스로 커버되는지 확인 테스트 커버리지 충분한 테스트 커버리지 확보 명확성과 구체성 테스트 단계와 예상 결과를 명확하고 구체적으로 기술 재사용성 테스트 케이스의 재사용 가능성 고려 유지보수성 쉽게 업데이트하고 관리할 수 있는 형태로 설계 다양성 다양한 시나리오와 경계 조건 고려 부정적 테스트 오류 상황과 예외 처리에 대한 테스트 포함 테스트 데이터 관리 적절하고 현실적인 테스트 데이터 준비 자동화 가능성 자동화 테스트로 전환 가능성 고려 일관성 테스트 케이스 작성 형식과 스타일의 일관성 유지 단위 테스트 주요 목적 개별 코드 단위(함수, 메소드, 클래스 등)의 정확성을 검증한다. 코드의 결함을 조기에 발견하고 수정한다. 코드 변경 시 기존 기능의 정상 작동을 보장한다. 개발자에게 즉각적인 피드백을 제공한다. 코드의 품질과 신뢰성을 향상시킨다. 문서화의 한 형태로 코드의 의도를 명확히 한다. 리팩토링과 코드 개선을 용이하게 한다. 전체 시스템 테스트의 비용과 시간을 절감한다 세부 활동과 산출물 세부 활동 설명 주요 산출물 테스트 대상 식별 테스트할 코드 단위 선정 테스트 대상 목록 테스트 케이스 설계 각 단위에 대한 테스트 시나리오 작성 단위 테스트 케이스 문서 테스트 코드 작성 실제 테스트를 수행할 코드 구현 단위 테스트 코드 테스트 데이터 준비 테스트에 필요한 입력 데이터 및 예상 결과 정의 테스트 데이터 세트 테스트 실행 작성된 테스트 코드 실행 테스트 실행 결과 로그 결과 분석 테스트 결과 검토 및 문제점 식별 테스트 결과 분석 보고서 코드 수정 발견된 문제점에 대한 코드 수정 수정된 소스 코드 회귀 테스트 수정 후 기존 기능 정상 작동 확인 회귀 테스트 결과 보고서 코드 커버리지 분석 테스트가 커버하는 코드 범위 확인 코드 커버리지 보고서 테스트 문서화 테스트 과정 및 결과 정리 단위 테스트 문서 주의해야할 요소 주의 요소 설명 독립성 각 테스트가 독립적으로 실행 가능하도록 설계 자동화 자동화된 테스트 실행 환경 구축 빠른 실행 신속한 피드백을 위한 효율적인 테스트 설계 가독성 명확하고 이해하기 쉬운 테스트 코드 작성 유지보수성 테스트 코드의 유지보수 용이성 고려 경계값 테스트 경계 조건과 예외 상황에 대한 테스트 포함 모의 객체 활용 외부 의존성을 가진 코드의 효과적인 테스트 테스트 우선 개발 TDD(Test-Driven Development) 방식 고려 리팩토링 테스트 코드의 품질 유지를 위한 주기적 리팩토링 테스트 데이터 관리 테스트에 사용되는 데이터의 일관성 및 현실성 유지 통합 테스트 주요 목적 개별 모듈이나 컴포넌트 간의 상호작용을 검증한다. 인터페이스 간 데이터 흐름의 정확성을 확인한다. 통합된 시스템의 기능적 요구사항 충족 여부를 검증한다. 모듈 간 의존성으로 인한 문제를 식별한다. 시스템 레벨에서 발생할 수 있는 오류를 조기에 발견한다. 전체 시스템의 안정성과 일관성을 확보한다. 개별 단위 테스트에서 발견하기 어려운 문제를 식별한다. 시스템 통합 과정에서의 리스크를 줄인다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 통합 전략 수립 통합 방식 및 순서 결정 (예: 상향식, 하향식, 샌드위치 등) 통합 전략 문서 통합 계획 작성 통합 단계, 일정, 자원 계획 수립 통합 테스트 계획서 테스트 케이스 설계 모듈 간 상호작용을 검증할 테스트 케이스 작성 통합 테스트 케이스 문서 테스트 환경 구축 통합 테스트를 위한 환경 설정 테스트 환경 구성 문서 스텁/드라이버 개발 필요한 스텁과 드라이버 프로그램 작성 스텁/드라이버 코드 테스트 실행 설계된 테스트 케이스 실행 테스트 실행 로그 결과 분석 테스트 결과 검토 및 문제점 식별 테스트 결과 분석 보고서 결함 수정 및 재테스트 발견된 문제 수정 및 재검증 수정 이력 및 재테스트 결과 회귀 테스트 수정 후 기존 기능 영향 확인 회귀 테스트 보고서 통합 진행 상황 보고 통합 과정 및 결과 문서화 통합 테스트 진행 보고서 주의해야할 요소 주의 요소 설명 통합 순서 효율적이고 논리적인 통합 순서 결정 인터페이스 정의 명확한 인터페이스 정의 및 문서화 데이터 무결성 모듈 간 데이터 전달의 정확성 확인 오류 처리 모듈 간 예외 상황 및 오류 처리 검증 환경 일관성 테스트 환경과 실제 운영 환경의 일치성 확보 의존성 관리 모듈 간 복잡한 의존관계 고려 성능 고려 통합 후 성능 저하 여부 확인 보안 모듈 간 상호작용에서의 보안 취약점 검토 버전 관리 통합되는 각 모듈의 버전 일치성 확인 문서화 통합 과정 및 결과의 상세한 문서화 시스템 테스트 주요 목적 전체 시스템이 명세된 요구사항을 충족하는지 검증한다. 시스템의 기능적, 비기능적 요구사항을 모두 테스트한다. 실제 운영 환경과 유사한 조건에서 시스템의 동작을 확인한다. 시스템의 성능, 보안, 신뢰성, 확장성 등을 평가한다. 사용자 관점에서 시스템의 사용성과 효율성을 검증한다. 예상치 못한 시스템 동작이나 오류를 식별한다. 시스템의 전반적인 품질과 안정성을 확보한다. 시스템이 실제 비즈니스 프로세스를 지원하는지 확인한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 테스트 계획 수립 시스템 테스트 범위, 접근 방식, 일정 정의 시스템 테스트 계획서 테스트 케이스 설계 기능 및 비기능 요구사항 기반 테스트 케이스 작성 시스템 테스트 케이스 문서 테스트 환경 구축 실제 운영 환경과 유사한 테스트 환경 설정 테스트 환경 구성 문서 테스트 데이터 준비 다양한 시나리오를 위한 테스트 데이터 생성 테스트 데이터 세트 기능 테스트 수행 시스템의 모든 기능에 대한 테스트 실행 기능 테스트 결과 보고서 성능 테스트 수행 부하, 스트레스, 확장성 등 성능 관련 테스트 성능 테스트 결과 보고서 보안 테스트 수행 시스템의 보안 취약점 및 위협 평가 보안 테스트 결과 보고서 사용성 테스트 수행 사용자 인터페이스 및 경험 평가 사용성 테스트 결과 보고서 결함 추적 및 관리 발견된 결함 기록, 분류, 추적 결함 추적 로그 회귀 테스트 수정 후 기존 기능 영향 확인 회귀 테스트 보고서 최종 테스트 보고서 작성 전체 시스템 테스트 결과 종합 시스템 테스트 최종 보고서 주의해야할 요소 주의 요소 설명 테스트 범위 모든 주요 기능과 비기능적 요구사항 포함 환경 유사성 실제 운영 환경과 최대한 유사한 테스트 환경 구성 데이터 다양성 다양한 시나리오와 경계 조건을 고려한 테스트 데이터 성능 기준 명확한 성능 기준 설정 및 측정 보안 고려사항 포괄적인 보안 테스트 및 취약점 평가 사용자 관점 실제 사용자 경험을 고려한 테스트 설계 통합 영향 시스템 구성 요소 간 상호작용 고려 예외 처리 예상치 못한 상황 및 오류 조건 테스트 확장성 향후 시스템 확장을 고려한 테스트 문서화 테스트 과정 및 결과의 상세한 문서화 사용자 수용 테스트 (UAT) 주요 목적 실제 사용자 관점에서 시스템의 적합성을 검증한다. 비즈니스 요구사항과 실제 구현된 기능의 일치 여부를 확인한다. 사용자의 실제 업무 프로세스를 시스템이 제대로 지원하는지 검증한다. 시스템의 사용성과 효율성을 최종 사용자 관점에서 평가한다. 사용자의 기대사항과 시스템 간의 격차를 식별한다. 최종 사용자의 시스템 수용 여부를 결정한다. 실제 운영 환경에서의 시스템 성능과 안정성을 확인한다. 사용자 교육 및 문서화의 적절성을 평가한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 UAT 계획 수립 UAT 범위, 참여자, 일정 등 정의 UAT 계획서 테스트 시나리오 개발 실제 업무 프로세스 기반 시나리오 작성 UAT 시나리오 문서 테스트 데이터 준비 실제 업무와 유사한 테스트 데이터 구성 UAT 테스트 데이터 세트 사용자 교육 UAT 참여자 대상 시스템 사용법 교육 사용자 교육 자료 UAT 환경 구축 실제 운영 환경과 유사한 UAT 환경 설정 UAT 환경 구성 문서 테스트 실행 사용자가 직접 테스트 시나리오 수행 UAT 실행 로그 피드백 수집 사용자로부터 시스템에 대한 의견 수집 사용자 피드백 문서 결함 보고 및 추적 발견된 문제점 기록 및 관리 결함 추적 로그 수정 및 재테스트 식별된 문제 해결 및 재검증 수정 이력 및 재테스트 결과 UAT 결과 보고 전체 UAT 과정 및 결과 종합 UAT 최종 보고서 주의해야할 요소 주의 요소 설명 사용자 선정 다양한 역할과 경험을 가진 대표 사용자 참여 실제 환경 유사성 실제 운영 환경과 최대한 유사한 UAT 환경 구성 명확한 수용 기준 구체적이고 측정 가능한 수용 기준 정의 충분한 시간 할당 사용자가 충분히 테스트할 수 있는 시간 제공 사용자 지원 UAT 과정 중 적절한 기술 지원 제공 객관성 유지 사용자의 객관적인 평가 유도 문서화 모든 피드백과 결과의 상세한 기록 변경 관리 UAT 중 발견된 문제에 대한 효과적인 변경 관리 의사소통 개발팀과 사용자 간의 원활한 의사소통 촉진 기대치 관리 현실적인 사용자 기대치 설정 및 관리 회귀 테스트 주요 목적 소프트웨어 변경 후 기존 기능이 여전히 정상적으로 작동하는지 확인한다. 새로운 변경사항이 기존 시스템에 부정적인 영향을 미치지 않았는지 검증한다. 버그 수정이 다른 부분에 새로운 문제를 일으키지 않았는지 확인한다. 시스템의 안정성과 일관성을 유지한다. 예상치 못한 부작용을 조기에 발견하고 해결한다. 지속적인 품질 보증을 제공한다. 변경 사항 적용 후 시스템의 전반적인 건전성을 검증한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 회귀 테스트 계획 수립 테스트 범위, 우선순위, 일정 정의 회귀 테스트 계획서 테스트 케이스 선정 영향 받을 수 있는 영역의 테스트 케이스 식별 회귀 테스트 케이스 목록 테스트 환경 준비 회귀 테스트를 위한 환경 설정 테스트 환경 구성 문서 자동화 스크립트 개발/업데이트 자동화된 회귀 테스트 스크립트 작성 또는 수정 테스트 자동화 스크립트 테스트 실행 선정된 테스트 케이스 실행 테스트 실행 로그 결과 분석 테스트 결과 검토 및 문제점 식별 회귀 테스트 결과 보고서 결함 보고 및 추적 발견된 회귀 결함 기록 및 관리 결함 추적 로그 영향 분석 변경사항이 시스템에 미친 영향 평가 영향 분석 보고서 재테스트 수정된 결함에 대한 재검증 재테스트 결과 보고서 최종 보고 전체 회귀 테스트 과정 및 결과 종합 회귀 테스트 최종 보고서 주의해야할 요소 주의 요소 설명 테스트 범위 선정 변경의 영향을 받을 수 있는 모든 영역 포함 우선순위 설정 중요도와 리스크에 따른 테스트 케이스 우선순위화 자동화 활용 반복적인 회귀 테스트의 효율성을 위한 자동화 테스트 데이터 관리 일관된 결과를 위한 테스트 데이터 버전 관리 시간 제약 고려 제한된 시간 내 효과적인 테스트 수행 전략 변경 이력 추적 각 변경사항과 관련된 회귀 테스트 결과 연계 환경 일관성 테스트 환경과 실제 운영 환경의 일치성 확보 전체 시스템 영향 고려 개별 변경이 전체 시스템에 미치는 영향 평가 지속적인 개선 회귀 테스트 프로세스의 효율성 지속 개선 커뮤니케이션 개발팀과 테스트팀 간의 효과적인 정보 공유 성능 테스트 주요 목적 시스템의 응답 시간, 처리량, 자원 사용률 등을 측정한다. 시스템이 정의된 성능 요구사항을 충족하는지 검증한다. 다양한 부하 조건에서 시스템의 안정성과 확장성을 평가한다. 성능 병목 지점을 식별하고 최적화 기회를 발견한다. 시스템의 최대 용량과 한계를 파악한다. 사용자 경험에 영향을 미칠 수 있는 성능 이슈를 조기에 발견한다. 시스템 장애 지점과 복구 능력을 테스트한다. 성능 튜닝 및 최적화를 위한 기초 데이터를 제공한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 성능 요구사항 분석 성능 목표 및 기준 정의 성능 요구사항 문서 테스트 계획 수립 성능 테스트 범위, 시나리오, 메트릭 정의 성능 테스트 계획서 테스트 환경 구성 실제 환경과 유사한 테스트 환경 설정 테스트 환경 구성 문서 테스트 데이터 준비 현실적인 테스트 데이터 세트 구성 테스트 데이터 세트 테스트 스크립트 개발 성능 테스트 시나리오 구현 테스트 스크립트 부하 테스트 수행 다양한 부하 수준에서 시스템 성능 측정 부하 테스트 결과 보고서 스트레스 테스트 수행 시스템의 한계 및 장애 복구 능력 테스트 스트레스 테스트 결과 보고서 확장성 테스트 수행 시스템 확장에 따른 성능 변화 측정 확장성 테스트 결과 보고서 결과 분석 성능 데이터 분석 및 문제점 식별 성능 분석 보고서 성능 튜닝 식별된 병목 지점 최적화 성능 최적화 권장사항 최종 보고서 작성 전체 성능 테스트 결과 종합 성능 테스트 최종 보고서 주의해야할 요소 주의 요소 설명 현실적인 시나리오 실제 사용 패턴을 반영한 테스트 시나리오 설계 테스트 환경의 적절성 실제 운영 환경과 최대한 유사한 테스트 환경 구성 다양한 부하 조건 일반, 피크, 스트레스 상황 등 다양한 조건 테스트 데이터 볼륨 실제 데이터 볼륨을 고려한 테스트 수행 모니터링 시스템 자원 사용률 등 상세한 모니터링 외부 요인 고려 네트워크 지연, 외부 서비스 등의 영향 고려 장기 실행 테스트 시간에 따른 성능 변화 관찰을 위한 장기 테스트 결과의 일관성 여러 번의 테스트 실행을 통한 결과 검증 성능 허용 오차 허용 가능한 성능 변동 범위 정의 보안 영향 보안 설정이 성능에 미치는 영향 고려 보안 테스트 주요 목적 시스템의 보안 취약점을 식별하고 평가한다. 데이터의 기밀성, 무결성, 가용성을 보장한다. 인증 및 권한 부여 메커니즘의 효과성을 검증한다. 외부 공격에 대한 시스템의 저항력을 평가한다. 보안 정책 및 규정 준수 여부를 확인한다. 잠재적인 보안 위협에 대한 대응 능력을 테스트한다. 시스템의 전반적인 보안 수준을 향상시킨다. 사용자 데이터와 시스템 자원의 보호 능력을 검증한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 보안 요구사항 분석 보안 목표 및 기준 정의 보안 요구사항 문서 위협 모델링 잠재적 보안 위협 식별 및 분석 위협 모델 문서 취약점 스캐닝 자동화된 도구를 사용한 취약점 검사 취약점 스캔 보고서 침투 테스트 실제 해킹 시도를 통한 보안 강도 평가 침투 테스트 결과 보고서 소스 코드 보안 검토 코드 레벨에서의 보안 취약점 분석 코드 보안 분석 보고서 인증 및 권한 테스트 접근 제어 메커니즘 검증 인증/권한 테스트 결과 암호화 테스트 데이터 암호화 방식의 적절성 검증 암호화 테스트 보고서 세션 관리 테스트 세션 처리의 보안성 평가 세션 관리 테스트 결과 보안 구성 검토 시스템 및 네트워크 구성의 보안성 평가 구성 검토 보고서 보안 사고 대응 테스트 보안 사고 발생 시 대응 능력 평가 사고 대응 테스트 보고서 최종 보안 평가 보고서 작성 전체 보안 테스트 결과 종합 보안 테스트 최종 보고서 주의해야할 요소 주의 요소 설명 법적 및 윤리적 고려사항 테스트 수행 시 법적 제한 및 윤리적 문제 고려 데이터 보호 테스트 중 민감한 데이터 보호 실제 환경과의 유사성 실제 운영 환경과 유사한 테스트 환경 구성 최신 보안 위협 반영 최신 보안 동향 및 새로운 공격 기법 고려 전체 시스템 범위 모든 시스템 구성 요소에 대한 포괄적 테스트 내부자 위협 고려 외부 공격뿐만 아니라 내부자 위협도 고려 지속적인 테스트 일회성이 아닌 지속적인 보안 테스트 수행 보안 패치 관리 발견된 취약점에 대한 신속한 패치 적용 보안 의식 제고 개발 및 운영 팀의 보안 의식 향상 제3자 구성 요소 검토 외부 라이브러리 및 서비스의 보안성 평가 테스트 자동화 주요 목적 반복적인 테스트 작업을 효율적으로 수행한다. 테스트 실행 시간을 단축하고 비용을 절감한다. 인적 오류를 최소화하여 테스트의 정확성과 일관성을 향상시킨다. 회귀 테스트의 효율성을 높여 빠른 피드백을 제공한다. 더 많은 테스트 케이스를 더 자주 실행할 수 있게 한다. 지속적 통합 및 배포(CI/CD) 프로세스를 지원한다. 테스트 커버리지를 확대하여 소프트웨어 품질을 향상시킨다. 반복 가능하고 신뢰할 수 있는 테스트 결과를 제공한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 자동화 전략 수립 자동화 범위, 도구, 접근 방식 결정 테스트 자동화 전략 문서 자동화 도구 선정 프로젝트에 적합한 자동화 도구 선택 도구 평가 및 선정 보고서 테스트 케이스 선별 자동화에 적합한 테스트 케이스 식별 자동화 대상 테스트 케이스 목록 프레임워크 설계 자동화 테스트 프레임워크 구축 테스트 자동화 프레임워크 스크립트 개발 자동화 테스트 스크립트 작성 테스트 자동화 스크립트 테스트 데이터 관리 자동화 테스트용 데이터 준비 및 관리 테스트 데이터 세트 실행 및 모니터링 자동화 테스트 실행 및 결과 모니터링 테스트 실행 로그 및 결과 보고서 결과 분석 및 보고 자동화 테스트 결과 분석 테스트 결과 분석 보고서 유지보수 및 업데이트 스크립트 및 프레임워크 유지보수 업데이트된 테스트 스크립트 성능 측정 자동화 테스트의 효율성 및 ROI 평가 자동화 성능 측정 보고서 주의해야할 요소 주의 요소 설명 적절한 자동화 범위 모든 테스트를 자동화하는 것이 아닌 적절한 범위 선정 유지보수 용이성 쉽게 유지보수할 수 있는 스크립트 및 프레임워크 설계 안정성 안정적이고 일관된 결과를 제공하는 자동화 테스트 구현 확장성 새로운 테스트 케이스 추가가 용이한 구조 설계 데이터 관리 테스트 데이터의 효과적인 관리 및 갱신 환경 독립성 다양한 테스트 환경에서 실행 가능한 자동화 구현 보안 고려 자동화 과정에서의 보안 취약점 방지 스킬셋 확보 자동화 도구 및 기술에 대한 팀의 역량 확보 비용-효과 분석 자동화 구현 및 유지보수 비용 대비 효과 고려 수동 테스트와의 균형 자동화와 수동 테스트의 적절한 조화 결함 관리 주요 목적 발견된 모든 결함을 체계적으로 기록하고 추적한다. 결함의 우선순위와 심각도를 평가하여 효율적인 해결을 지원한다. 결함 해결 과정을 투명하게 관리하여 프로젝트 진행 상황을 모니터링한다. 결함의 근본 원인을 분석하여 유사한 문제의 재발을 방지한다. 품질 메트릭스를 제공하여 소프트웨어의 전반적인 품질을 평가한다. 개발 팀과 테스트 팀 간의 효과적인 커뮤니케이션을 촉진한다. 릴리스 결정을 위한 객관적인 데이터를 제공한다. 프로젝트의 품질 목표 달성을 지원한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 결함 보고 발견된 결함을 상세히 기록 결함 보고서 결함 분류 결함의 유형, 심각도, 우선순위 분류 분류된 결함 목록 결함 할당 적절한 담당자에게 결함 해결 할당 결함 할당 문서 결함 분석 결함의 근본 원인 및 영향 분석 결함 분석 보고서 결함 해결 개발 팀의 결함 수정 작업 수정된 코드 또는 문서 재테스트 수정된 결함에 대한 검증 테스트 재테스트 결과 보고서 결함 상태 추적 결함의 생명주기 전반에 걸친 상태 관리 결함 상태 추적 로그 결함 보고서 생성 주기적인 결함 현황 및 트렌드 보고 결함 요약 보고서 결함 종료 해결된 결함의 최종 검토 및 종료 처리 결함 종료 문서 결함 데이터 분석 결함 데이터를 활용한 품질 개선 분석 품질 개선 제안서 주의해야할 요소 주의 요소 설명 정확한 결함 기술 결함을 명확하고 재현 가능하게 기술 우선순위 설정 비즈니스 영향과 기술적 중요도를 고려한 우선순위 설정 중복 결함 관리 유사하거나 중복된 결함의 효율적 관리 결함 생명주기 관리 결함의 상태 변화를 정확히 추적하고 관리 커뮤니케이션 개발 팀과 테스트 팀 간의 원활한 소통 결함 추적 도구 활용 효율적인 결함 관리를 위한 적절한 도구 사용 결함 재발 방지 유사한 결함의 재발을 막기 위한 근본 원인 분석 결함 데이터 보안 민감한 결함 정보에 대한 접근 제어 결함 보고의 객관성 감정적이거나 비난하는 톤을 피한 객관적 보고 지속적인 모니터링 결함 트렌드와 패턴의 지속적인 분석 및 대응 테스트 결과 분석 및 보고 주요 목적 테스트 활동의 결과를 종합적으로 평가한다. 소프트웨어의 품질 상태를 객관적으로 파악한다. 발견된 결함과 그 영향을 명확히 이해한다. 프로젝트 이해관계자들에게 테스트 진행 상황과 결과를 전달한다. 릴리스 결정을 위한 객관적인 데이터를 제공한다. 향후 개선이 필요한 영역을 식별한다. 테스트 프로세스의 효율성을 평가한다. 프로젝트 리스크를 식별하고 관리하는 데 도움을 준다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 테스트 데이터 수집 모든 테스트 활동의 결과 데이터 수집 테스트 데이터 세트 결과 분류 및 정리 수집된 데이터를 카테고리별로 분류 분류된 테스트 결과 통계 분석 테스트 결과의 통계적 분석 수행 테스트 통계 보고서 결함 트렌드 분석 결함 패턴 및 추세 분석 결함 트렌드 보고서 커버리지 분석 테스트 커버리지 평가 커버리지 분석 보고서 성능 메트릭스 분석 성능 관련 지표 분석 성능 분석 보고서 리스크 평가 발견된 이슈의 리스크 수준 평가 리스크 평가 문서 요약 보고서 작성 주요 발견사항 및 결론 요약 테스트 요약 보고서 상세 보고서 작성 테스트 결과의 상세 내용 기술 상세 테스트 결과 보고서 개선 제안 테스트 결과를 바탕으로 한 개선 사항 제안 개선 제안서 주의해야할 요소 주의 요소 설명 객관성 유지 편견 없이 객관적인 데이터 분석 및 보고 정확성 데이터의 정확성 확보 및 검증 명확성 복잡한 정보를 이해하기 쉽게 전달 관련성 이해관계자에게 관련 있고 중요한 정보 중심 보고 시기적절성 적시에 정보를 제공하여 의사결정 지원 보안 고려 민감한 정보의 적절한 처리 및 보호 추적 가능성 보고된 결과와 원본 데이터 간의 추적 가능성 확보 일관성 보고서 형식과 내용의 일관성 유지 맥락 제공 결과의 의미와 영향을 이해할 수 있는 맥락 제공 시각화 복잡한 데이터를 효과적으로 시각화하여 전달 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-20 00:55:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;3294 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 5. 테스트 (Testing)" href=https://buenhyden.github.io/posts/qa/sdlc/5-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Stubs</h2></header><div class=entry-content><p>Stubs Stubbing은 테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘
목적 의존성 격리: 실제 구현체로부터 테스트 대상을 분리하여 독립적인 테스트를 가능하게 합니다. 특정 시나리오 테스트: 다양한 상황에 대한 테스트를 용이하게 합니다. 미구현 코드 대체: 아직 개발되지 않은 부분을 임시로 대체할 수 있습니다. 테스트 속도 향상: 실제 리소스 접근 없이 빠른 테스트가 가능합니다. 특징 미리 정의된 응답(canned answer)을 제공합니다. 실제 코드의 동작을 단순화하여 모사합니다. 주로 상태 테스팅에 중점을 둡니다. 메서드 호출의 결과만 정의하며, 호출 여부는 검증하지 않습니다. 사용 사례 구현되지 않은 함수나 외부 라이브러리 함수를 사용할 때 복잡한 로직을 단순화하여 테스트하고자 할 때 특정 조건에서의 예외 상황을 테스트할 때 외부 의존성(예: 데이터베이스, 네트워크 요청)을 가진 코드를 테스트할 때 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from unittest.mock import Mock, patch import pytest from datetime import datetime # 테스트할 실제 클래스 class PaymentService: def __init__(self, payment_gateway): self.payment_gateway = payment_gateway def process_payment(self, amount): if amount &lt;= 0: raise ValueError("Amount must be positive") response = self.payment_gateway.charge(amount) if response['status'] == 'success': return True return False # 외부 결제 게이트웨이 클래스 (실제로는 외부 서비스) class PaymentGateway: def charge(self, amount): # 실제로는 외부 API를 호출하는 복잡한 로직 pass # Stub 예시 class PaymentGatewayStub: def charge(self, amount): # 항상 성공 응답을 반환하는 단순한 구현 return {'status': 'success', 'timestamp': datetime.now()} # 테스트 코드 def test_payment_service_with_stub(): # Stub 사용 gateway_stub = PaymentGatewayStub() payment_service = PaymentService(gateway_stub) assert payment_service.process_payment(100) == True Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // Jest를 사용한 테스트 예시 const { jest } = require('@jest/globals'); // 테스트할 실제 클래스 class UserService { constructor(database) { this.database = database; } async getUserById(id) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } return user; } async updateUserEmail(id, newEmail) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } user.email = newEmail; await this.database.updateUser(id, user); return user; } } // Stub 예시 class DatabaseStub { constructor() { this.users = new Map([ [1, { id: 1, name: 'John Doe', email: 'john@example.com' }], [2, { id: 2, name: 'Jane Doe', email: 'jane@example.com' }] ]); } async findUser(id) { return this.users.get(id); } async updateUser(id, userData) { this.users.set(id, userData); return userData; } } // 테스트 코드 describe('UserService', () => { // Stub을 사용한 테스트 describe('with stub', () => { const dbStub = new DatabaseStub(); const userService = new UserService(dbStub); test('should return user when exists', async () => { const user = await userService.getUserById(1); expect(user.name).toBe('John Doe'); }); test('should throw error when user not found', async () => { await expect(userService.getUserById(999)) .rejects .toThrow('User not found'); }); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-01 09:29:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stubs" href=https://buenhyden.github.io/posts/qa/fundamentals/test-double/stubs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mocks</h2></header><div class=entry-content><p>Mocks 소프트웨어 테스트에서 사용되는 중요한 기법으로, 실제 객체를 모방하는 가짜 객체를 만들어 테스트하는 방법
Mocking은 테스트하고자 하는 코드가 의존하는 부분을 가짜(mock)로 대체하는 기법으로, 단위 테스트를 작성할 때 특히 유용하다.
목적 외부 의존성 제어: 실제 외부 리소스에 의존하지 않고 테스트를 수행할 수 있게 합니다. 특정 시나리오 테스트: 예외 상황이나 복잡한 시나리오를 쉽게 재현할 수 있습니다. 테스트 속도 향상: 실제 리소스 접근 시간을 절약하여 테스트 실행 속도를 높입니다. 독립적인 테스트: 다른 컴포넌트의 구현 여부와 관계없이 테스트를 진행할 수 있습니다. 장점 빠른 테스트 속도: 외부 리소스 접근 시간을 절약합니다. 예외 시나리오 테스트 용이성: 특정 상황에서의 예외 처리를 쉽게 테스트할 수 있습니다. 외부 리소스 접근 회피: 실제 환경에 의존하지 않고 테스트할 수 있습니다. 복잡한 시나리오 테스트: 다양한 상태를 쉽게 재현할 수 있습니다. 단점 잠재적 부작용: 모킹된 동작과 실제 코드의 동작이 다를 수 있습니다. 모킹 오버헤드: 모킹 코드 작성과 설정에 추가 작업이 필요합니다. 모킹의 복잡성: 잘못된 모킹 설정은 테스트의 신뢰성을 떨어뜨릴 수 있습니다. 테스트의 일관성 문제: 모킹을 남용하면 테스트 코드와 실제 코드 간의 일관성이 떨어질 수 있습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from unittest.mock import Mock, patch import pytest from datetime import datetime # 테스트할 실제 클래스 class PaymentService: def __init__(self, payment_gateway): self.payment_gateway = payment_gateway def process_payment(self, amount): if amount &lt;= 0: raise ValueError("Amount must be positive") response = self.payment_gateway.charge(amount) if response['status'] == 'success': return True return False # 외부 결제 게이트웨이 클래스 (실제로는 외부 서비스) class PaymentGateway: def charge(self, amount): # 실제로는 외부 API를 호출하는 복잡한 로직 pass def test_payment_service_with_mock(): # Mock 객체 생성 mock_gateway = Mock() # Mock 동작 정의 mock_gateway.charge.return_value = {'status': 'success'} payment_service = PaymentService(mock_gateway) result = payment_service.process_payment(100) # 검증 assert result == True mock_gateway.charge.assert_called_once_with(100) # Mock을 사용한 다양한 시나리오 테스트 def test_payment_service_failed_payment(): mock_gateway = Mock() mock_gateway.charge.return_value = {'status': 'failed'} payment_service = PaymentService(mock_gateway) result = payment_service.process_payment(50) assert result == False mock_gateway.charge.assert_called_once() # Patch 데코레이터를 사용한 테스트 @patch('__main__.PaymentGateway') def test_payment_service_with_patch(mock_gateway_class): mock_gateway_instance = Mock() mock_gateway_class.return_value = mock_gateway_instance mock_gateway_instance.charge.return_value = {'status': 'success'} payment_service = PaymentService(PaymentGateway()) result = payment_service.process_payment(200) assert result == True mock_gateway_instance.charge.assert_called_once_with(200) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // Jest를 사용한 테스트 예시 const { jest } = require('@jest/globals'); // 테스트할 실제 클래스 class UserService { constructor(database) { this.database = database; } async getUserById(id) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } return user; } async updateUserEmail(id, newEmail) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } user.email = newEmail; await this.database.updateUser(id, user); return user; } } // 테스트 코드 describe('UserService', () => { // Mock을 사용한 테스트 describe('with mock', () => { // Jest mock 생성 const mockDatabase = { findUser: jest.fn(), updateUser: jest.fn() }; const userService = new UserService(mockDatabase); beforeEach(() => { // 각 테스트 전에 mock 초기화 jest.clearAllMocks(); }); test('should call database with correct id', async () => { const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' }; mockDatabase.findUser.mockResolvedValue(mockUser); const user = await userService.getUserById(1); expect(mockDatabase.findUser).toHaveBeenCalledWith(1); expect(user).toEqual(mockUser); }); test('should update user email', async () => { const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' }; const updatedUser = { ...mockUser, email: 'new@example.com' }; mockDatabase.findUser.mockResolvedValue(mockUser); mockDatabase.updateUser.mockResolvedValue(updatedUser); const result = await userService.updateUserEmail(1, 'new@example.com'); expect(mockDatabase.findUser).toHaveBeenCalledWith(1); expect(mockDatabase.updateUser).toHaveBeenCalledWith(1, updatedUser); expect(result.email).toBe('new@example.com'); }); test('should handle database errors', async () => { mockDatabase.findUser.mockRejectedValue(new Error('Database error')); await expect(userService.getUserById(1)) .rejects .toThrow('Database error'); }); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-01 06:14:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mocks" href=https://buenhyden.github.io/posts/qa/fundamentals/test-double/mocks/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>