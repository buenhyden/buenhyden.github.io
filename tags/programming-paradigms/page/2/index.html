<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Paradigms | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-paradigms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-paradigms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-paradigms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-paradigms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Paradigms"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Paradigms"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Paradigms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동시성 프로그래밍 (Concurrency Programming)</h2></header><div class=entry-content><p>동시성 프로그래밍 (Concurrency Programming) 동시성 프로그래밍은 여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법.
이는 시스템의 효율성을 높이고 처리 시간을 줄이는 데 중점을 둔다.
특징 여러 작업의 실행 흐름을 겹치게 하거나 병렬로 처리 멀티스레딩, 멀티프로세싱, 비동기 프로그래밍 등의 기법 사용 사용 사례 웹 서버: 여러 사용자의 요청을 동시에 처리 데이터베이스 시스템: 다수의 쿼리를 병렬로 처리 UI 애플리케이션: 백그라운드 작업 수행 중 사용자 인터페이스 응답성 유지 장점 시스템 자원의 효율적 사용 응답성 향상 처리량 증가 성능 최적화 단점 코드 복잡성 증가 디버깅 어려움 동기화 문제 (Race Condition, Deadlock 등) 성능 오버헤드 가능성 고려사항 동기화 메커니즘: 적절한 락(Lock) 사용 데드락 방지 공유 자원 보호 성능 최적화: 스레드 풀 크기 조정 작업 크기 최적화 메모리 사용량 관리 오류 처리: 예외 처리 전략 실패 복구 메커니즘 타임아웃 설정 구현시 주의사항 상태 관리:
...</p></div><footer class=entry-footer><span title='2024-11-25 23:42:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;800 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 프로그래밍 (Concurrency Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding)과 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩(Overriding)과 오버로딩(Overloading) 기본 개념 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 정의 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것 같은 클래스 내에서 동일한 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것 목적 상속 관계에서 메서드의 구현을 변경하기 위해 사용 비슷한 기능을 하는 메서드를 하나의 이름으로 여러 가지 방식으로 사용하기 위해 사용 다형성 유형 런타임 다형성 (동적 바인딩) 컴파일 타임 다형성 (정적 바인딩) 핵심 특징 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 이름 반드시 동일해야 함 반드시 동일해야 함 매개변수 부모 메서드와 동일해야 함 타입이나 개수가 달라야 함 반환 타입 부모 메서드와 동일하거나 공변 반환 타입이어야 함 다를 수 있음 접근 제어자 부모 메서드보다 더 제한적일 수 없음 자유롭게 지정 가능 예외 처리 부모 메서드보다 더 큰 범위의 예외를 던질 수 없음 자유롭게 지정 가능 코드 예시 비교 오버라이딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 부모 클래스 class Animal { public void makeSound() { System.out.println("동물이 소리를 냅니다"); } } // 자식 클래스 class Dog extends Animal { @Override // 오버라이딩 명시 public void makeSound() { System.out.println("멍멍!"); } } class Cat extends Animal { @Override public void makeSound() { System.out.println("야옹!"); } } 오버로딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculator { // 정수 덧셈 public int add(int a, int b) { return a + b; } // 실수 덧셈 public double add(double a, double b) { return a + b; } // 세 정수의 덧셈 public int add(int a, int b, int c) { return a + b + c; } // 배열의 덧셈 public int add(int[] numbers) { int sum = 0; for (int num : numbers) { sum += num; } return sum; } } 실행 시점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 결정 시점 런타임에 결정 컴파일 타임에 결정 바인딩 동적 바인딩 정적 바인딩 성능 영향 약간의 오버헤드 발생 가능 오버헤드 없음 사용 목적 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 주요 용도 • 부모 클래스 메서드의 동작 변경
• 다형성 구현
• 특화된 기능 구현 • 메서드 이름의 재사용
• 다양한 매개변수 처리
• 코드의 간결성 향상 활용 상황 • 추상 메서드 구현
• 인터페이스 구현
• 상속받은 메서드 수정 • 생성자 다중 정의
• 유틸리티 메서드 구현
• API 설계 제약사항 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 제약 • final 메서드는 오버라이드 불가
• private 메서드는 오버라이드 불가
• static 메서드는 오버라이드 불가 • 매개변수만 다르면 됨
• 반환 타입만 다른 것은 불가
• 접근 제어자 제약 없음 상속 관계 반드시 상속 관계가 있어야 함 상속 관계 불필요 기타 제약 • 부모의 메서드보다 접근성을 좁힐 수 없음
• 부모보다 더 큰 예외 선언 불가 • 매개변수 순서만 다른 경우 주의 필요
• 모호한 호출 가능성 주의 장단점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 장점 • 다형성 구현 가능
• 코드 재사용성 향상
• 유연한 설계 가능 • 직관적인 메서드명 사용
• 코드 가독성 향상
• API 사용 편의성 증가 단점 • 런타임 오버헤드
• 복잡한 상속 관계시 추적 어려움
• 잘못 사용시 부모 클래스 동작 훼손 • 과도한 사용시 복잡도 증가
• 타입 변환 오류 가능성
• 모호한 메서드 호출 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 04:56:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;535 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding)과 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-10-11 12:38:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>구조적 프로그래밍 (Structured Programming)</h2></header><div class=entry-content><p>구조적 프로그래밍 (Structured Programming) 구조적 프로그래밍은 1960년대에 등장한 프로그래밍 패러다임으로, 프로그램을 순차, 선택, 반복의 세 가지 기본 제어 구조로 구성하여 코드의 흐름을 체계적으로 관리하는 방식.
이 접근 방식은 코드를 모듈화하고 위에서 아래로 실행되는 절차적인 흐름을 강조한다.
특징 순차적 실행: 코드가 위에서 아래로 순서대로 실행됩니다. 모듈화: 프로그램을 작은 기능 단위로 나누어 구성합니다. 제어 구조: 순차, 선택(if-else, switch), 반복(for, while) 구조를 사용합니다. 단일 진입점과 단일 종료점: 각 모듈은 하나의 시작점과 끝점을 가집니다. GOTO문 사용 제한: 무분별한 흐름 제어를 방지합니다 장점 코드 가독성 향상: 체계적인 구조로 인해 코드 이해가 쉬워집니다. 유지보수 용이성: 모듈화된 구조로 인해 수정과 디버깅이 쉬워집니다. 개발 시간 단축: 모듈 재사용으로 개발 효율성이 증가합니다. 문제 중심 접근: 기계 중심이 아닌 문제 해결에 초점을 맞춥니다. 단점 실행 효율성 감소: 모듈 호출로 인한 오버헤드가 발생할 수 있습니다. 메모리 사용량 증가: 모듈 인터페이스로 인해 메모리 사용이 증가할 수 있습니다. 기계어 변환 시간: 고급 언어에서 기계어로의 변환에 시간이 소요됩니다. 개발 시간 증가: 언어 의존적인 특성으로 인해 개발에 더 많은 시간이 필요할 수 있습니다. 주의사항 및 고려사항 적절한 모듈화: 과도한 모듈화는 성능 저하를 초래할 수 있으므로 균형을 유지해야 합니다. 데이터 구조 설계: 프로그램의 데이터 구조를 신중히 설계해야 합니다. 재사용성 고려: 모듈을 설계할 때 재사용 가능성을 고려해야 합니다. 문서화: 각 모듈의 기능과 인터페이스를 명확히 문서화해야 합니다. 예시 Python 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # Python으로 구현한 학생 성적 관리 시스템 def get_student_info(): """사용자로부터 학생 정보를 입력받는 함수""" name = input("학생 이름을 입력하세요: ") scores = [] for subject in ["수학", "영어", "과학"]: while True: try: score = int(input(f"{subject} 점수를 입력하세요 (0-100): ")) if 0 &lt;= score &lt;= 100: scores.append(score) break print("점수는 0에서 100 사이여야 합니다.") except ValueError: print("숫자를 입력해주세요.") return name, scores def calculate_average(scores): """점수 리스트의 평균을 계산하는 함수""" return sum(scores) / len(scores) def determine_grade(average): """평균 점수를 기반으로 등급을 결정하는 함수""" if average >= 90: return 'A' elif average >= 80: return 'B' elif average >= 70: return 'C' elif average >= 60: return 'D' else: return 'F' def generate_report(name, scores, average, grade): """성적 보고서를 생성하는 함수""" report = f"\n성적 보고서\n" report += f"학생 이름: {name}\n" subjects = ["수학", "영어", "과학"] for subject, score in zip(subjects, scores): report += f"{subject}: {score}점\n" report += f"평균: {average:f}점\n" report += f"등급: {grade}" return report def main(): """메인 프로그램 함수""" try: # 학생 정보 입력 받기 name, scores = get_student_info() # 평균 계산 average = calculate_average(scores) # 등급 결정 grade = determine_grade(average) # 보고서 생성 report = generate_report(name, scores, average, grade) # 결과 출력 print(report) except Exception as e: print(f"오류가 발생했습니다: {str(e)}") if __name__ == "__main__": main() Javascript 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Node.js로 구현한 학생 성적 관리 시스템 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); function promptQuestion(question) { return new Promise((resolve) => { rl.question(question, (answer) => { resolve(answer); }); }); } async function getStudentInfo() { const name = await promptQuestion("학생 이름을 입력하세요: "); const scores = []; const subjects = ["수학", "영어", "과학"]; for (const subject of subjects) { while (true) { const scoreStr = await promptQuestion(`${subject} 점수를 입력하세요 (0-100): `); const score = parseInt(scoreStr); if (!isNaN(score) && score >= 0 && score &lt;= 100) { scores.push(score); break; } console.log("올바른 점수를 입력해주세요 (0-100)"); } } return { name, scores }; } function calculateAverage(scores) { return scores.reduce((sum, score) => sum + score, 0) / scores.length; } function determineGrade(average) { if (average >= 90) return 'A'; if (average >= 80) return 'B'; if (average >= 70) return 'C'; if (average >= 60) return 'D'; return 'F'; } function generateReport(name, scores, average, grade) { const subjects = ["수학", "영어", "과학"]; let report = "\n성적 보고서\n"; report += `학생 이름: ${name}\n`; subjects.forEach((subject, index) => { report += `${subject}: ${scores[index]}점\n`; }); report += `평균: ${average.toFixed(2)}점\n`; report += `등급: ${grade}`; return report; } async function main() { try { // 학생 정보 입력 받기 const { name, scores } = await getStudentInfo(); // 평균 계산 const average = calculateAverage(scores); // 등급 결정 const grade = determineGrade(average); // 보고서 생성 const report = generateReport(name, scores, average, grade); // 결과 출력 console.log(report); } catch (error) { console.error("오류가 발생했습니다:", error.message); } finally { rl.close(); } } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-09 09:06:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;922 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 구조적 프로그래밍 (Structured Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>절차적 프로그래밍 (Procedural Programming)</h2></header><div class=entry-content><p>절차적 프로그래밍 (Procedural Programming) 프로그램의 실행 흐름을 일련의 절차나 함수로 구성하는 프로그래밍 패러다임
문제를 해결하기 위해 작은 단계들로 나누고, 각 단계를 절차(함수)로 구현하여 이를 순차적으로 호출하는 방식으로 프로그램을 구성
특징 모듈성: 프로그램을 작은 기능 단위인 절차나 함수로 나눕니다. 순차적 실행: 코드가 위에서 아래로 순서대로 실행됩니다. 제어 구조: 순차, 선택(if-else, switch), 반복(for, while) 구조를 사용합니다. 데이터 구조: 배열, 리스트, 레코드 등의 표준 데이터 구조를 사용합니다. 상태 변경: 변수의 값을 직접 변경하여 프로그램의 상태를 관리합니다7. 장점 단순성: 초보자가 이해하고 사용하기 쉽습니다. 효율성: 직접적인 데이터 조작으로 인해 성능이 좋을 수 있습니다. 모듈화: 코드 재사용성과 유지보수성이 향상됩니다. 명확한 실행 흐름: 프로그램의 실행 순서가 명확하여 로직을 따라가기 쉽습니다. 단점 확장성 문제: 코드베이스가 커질수록 관리가 어려워집니다. 코드 중복: 반복적인 코드 작성이 발생할 수 있어 유지보수가 어려울 수 있습니다. 데이터와 기능의 분리: 객체 지향 프로그래밍에 비해 데이터와 기능이 분리되어 있어 복잡한 관계 모델링이 어려울 수 있습니다. 병행성 관리의 어려움: 가변 상태로 인해 병행 프로그래밍이 어려울 수 있습니다. 주의사항 및 고려사항 적절한 모듈화: 함수와 절차를 효과적으로 구조화하여 코드의 가독성과 재사용성을 높입니다. 전역 변수 사용 제한: 전역 변수의 과도한 사용은 프로그램의 복잡성을 증가시킬 수 있으므로 주의해야 합니다. 일관된 명명 규칙: 함수와 변수의 이름을 일관되게 지정하여 코드의 가독성을 높입니다. 주석 활용: 복잡한 로직이나 중요한 부분에 주석을 달아 코드의 이해도를 높입니다. 예시 Python Python 예제에서는 학생 성적 처리라는 특정 작업을 여러 함수로 분리하여 모듈화했습니다. 각 함수는 명확한 하나의 역할을 수행하며, 순차적으로 실행됩니다.
절차적 프로그래밍의 원칙을 따릅니다:
...</p></div><footer class=entry-footer><span title='2024-10-09 09:06:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 절차적 프로그래밍 (Procedural Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/procedural-programming/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-paradigms/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-paradigms/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>