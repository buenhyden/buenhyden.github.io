<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Software-Engineering on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/software-engineering/</link>
    <description>Recent content in Software-Engineering on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.9</generator>
    <language>en</language>
    <lastBuildDate>Tue, 24 Jun 2025 13:23:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/principles/</link>
      <pubDate>Tue, 27 May 2025 07:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/principles/</guid>
      <description>시스템 아키텍처와 소프트웨어 아키텍처 원칙들은 견고하고 유지보수 가능하며 확장 가능한 소프트웨어 시스템을 설계하기 위한 핵심 지침들로, SOLID 원칙, 관심사의 분리, 의존성 역전 등의 기본 원칙을 바탕으로 계층화 아키텍처, 클린 아키텍처, 마이크로서비스 아키텍처 등 다양한 패턴을 통해 복잡한 시스템의 설계와 구현을 체계적으로 지원한다.</description>
    </item>
    <item>
      <title>Creational</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/</guid>
      <description>Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다.</description>
    </item>
    <item>
      <title>Structural</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/</guid>
      <description>GoF의 Structural Patterns 는 **객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법**으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다.</description>
    </item>
    <item>
      <title>1. 계획 (Planning)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/1-planning/</link>
      <pubDate>Fri, 20 Sep 2024 00:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/1-planning/</guid>
      <description>프로젝트의 방향성과 범위를 설정하고, 자원과 일정을 계획하며, 위험 요소를 식별하고 관리 전략을 수립한다.</description>
    </item>
    <item>
      <title>Software Engineering</title>
      <link>https://buenhyden.github.io/posts/software-engineering/</link>
      <pubDate>Thu, 19 Sep 2024 10:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/</guid>
      <description>소프트웨어 공학은 **요구분석, 설계, 구현, 테스트, 유지보수**까지 전체 개발주기를 아우르며, **품질**, **생산성**, **유지보수성**을 높이기 위한 구조화된 접근이다. SDLC 방법론과 설계 원칙을 바탕으로 확장 가능하고 신뢰성 있는 소프트웨어 시스템을 구축한다.</description>
    </item>
    <item>
      <title>Behavioral</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/</guid>
      <description>Behavioral Design Patterns 는 객체 및 클래스 간의 상호작용과 책임 분산에 집중한 디자인 패턴군으로, 복잡한 시스템에서 객체들의 행위를 유연하게 조정하고 기능 확장 및 유지보수를 용이하게 만든다. 실무에서 프로그램의 확장성과 코드 품질 향상을 위해 필수적으로 활용된다.</description>
    </item>
    <item>
      <title>Programming Paradigms</title>
      <link>https://buenhyden.github.io/posts/software-engineering/programming-paradigms/</link>
      <pubDate>Sun, 22 Sep 2024 04:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/programming-paradigms/</guid>
      <description>코드를 효율적이고 유지보수가 용이하게 작성하기 위한 다양한 접근 방식</description>
    </item>
    <item>
      <title>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/2-requirements-gathering-and-analysis/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/2-requirements-gathering-and-analysis/</guid>
      <description>이해관계자의 요구사항을 수집하고 분석하여 시스템 요구사항을 정의하는 단계</description>
    </item>
    <item>
      <title>3. 설계 (Design)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/3-design/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/3-design/</guid>
      <description>요구사항을 바탕으로 시스템의 구조와 세부 사항을 설계하는 단계</description>
    </item>
    <item>
      <title>4. 구현 (Implementation)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/4-implementation/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/4-implementation/</guid>
      <description>설계를 바탕으로 실제 코드를 작성하는 단계</description>
    </item>
    <item>
      <title>5. 테스트 (Testing)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/5-testing/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/5-testing/</guid>
      <description>개발된 소프트웨어의 품질을 검증하고 결함을 식별하는 단계</description>
    </item>
    <item>
      <title>6. 배포 (Deployment)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/6-deployment/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/6-deployment/</guid>
      <description>완성된 소프트웨어를 실제 운영 환경에 설치하고 사용자에게 제공하는 단계</description>
    </item>
    <item>
      <title>7. 유지보수 (Maintenance)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/7-maintenance/</link>
      <pubDate>Fri, 20 Sep 2024 00:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/sdlc-phases/7-maintenance/</guid>
      <description>배포된 소프트웨어를 지속적으로 관리하고 개선하는 단계</description>
    </item>
    <item>
      <title>Mediator Pattern vs Observer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern-vs-observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern-vs-observer-pattern/</guid>
      <description>Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.</description>
    </item>
    <item>
      <title>Performance Optimization</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/</link>
      <pubDate>Tue, 24 Jun 2025 13:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/</guid>
      <description>&lt;h2 id=&#34;performance-optimization&#34;&gt;Performance Optimization&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;용어-정리&#34;&gt;용어 정리&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;hr&gt;</description>
    </item>
    <item>
      <title>Object Pooling</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/object-pooling/</link>
      <pubDate>Tue, 24 Jun 2025 10:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/object-pooling/</guid>
      <description>Object Pooling 은 객체의 생성과 소멸 비용을 줄이기 위해 미리 생성된 객체들을 풀 (Pool) 에 보관하고 재사용하는 성능 최적화 디자인 패턴이다.  메모리 할당/해제 오버헤드를 줄이고 가비지 컬렉션 압력을 감소시켜 시스템 성능을 향상시킨다.</description>
    </item>
    <item>
      <title>Architecture Styles and Patterns</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/</link>
      <pubDate>Sat, 14 Jun 2025 07:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/</guid>
      <description>Architecture Styles and Patterns은 시스템의 고수준 구조를 정의하고 컴포넌트 간 상호작용을 조직화하는 재사용 가능한 설계 솔루션이다. Architecture Style 은 시스템 전체 구조와 상호작용 원칙을 정의하며, Architecture Pattern 은 특정 구조적 문제에 대한 재사용 가능한 해결책을 제공한다. 다양한 패턴이 존재하며, 각각 특정 문제를 해결하고 확장성, 유지보수성, 테스트 용이성을 향상시킨다.</description>
    </item>
    <item>
      <title>Design Methodology</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/</link>
      <pubDate>Fri, 06 Jun 2025 16:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/</guid>
      <description>설계 방법론은 소프트웨어 시스템의 구조, 아키텍처, 개발 프로세스를 체계화하여 효율적이고 유지보수 가능한 소프트웨어를 개발하기 위한 원칙, 패턴, 실무 기법의 집합이다.</description>
    </item>
    <item>
      <title>Strategic Design</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/strategic-design/</link>
      <pubDate>Wed, 04 Jun 2025 13:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/strategic-design/</guid>
      <description>Strategic Design 은 DDD 내부에서 &amp;#39;무엇을&amp;#39; &amp;#39;왜&amp;#39; 만들지 결정하는 고수준 접근 방식이다. 복잡한 비즈니스 도메인의 핵심 (Subdomain/Core Domain) 을 정의하고 Bounded Context(경계 컨텍스트) 를 설정하며 Ubiquitous Language(공통 언어) 를 개발해 조직과 도메인 간 협업 기반을 마련하며 Context Map (컨텍스트 맵) 으로 시스템 전체 아키텍처를 관리한다.</description>
    </item>
    <item>
      <title>Tactical Design</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/tactical-design/</link>
      <pubDate>Wed, 04 Jun 2025 13:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/tactical-design/</guid>
      <description>전술적 설계 (Tactical Design) 는 **어떻게 구현할 것인가** 에 집중한다. 도메인 주도 설계 (DDD) 에서 전략적 설계로 정의된 도메인 모델을 실제 코드와 아키텍처로 구현하는 단계로, 단일 Bounded Context 내에서 Entity, Value Object, Aggregate, Repository, Factory, Domain Service 등 패턴을 적용해 **도메인 모델의 일관성, 트랜잭션 경계, 불변성, 도메인 규칙**을 구현한다.</description>
    </item>
    <item>
      <title>Messaging Systems</title>
      <link>https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure-components/messaging-systems/</link>
      <pubDate>Tue, 22 Apr 2025 13:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/systems-and-infrastructure/infrastructure-components/messaging-systems/</guid>
      <description>메시징 시스템은 분산 애플리케이션의 구성 요소 간 비동기 통신을 지원하여 결합도를 낮추고, 신뢰성·확장성·유연성을 제공합니다. 메시지 큐, 이벤트 스트리밍, 태스크 큐 등 다양한 형태가 존재하며, 실시간 데이터 처리, 작업 분산, 장애 복원력 등 다양한 요구에 대응한다.</description>
    </item>
    <item>
      <title>POSA(Pattern-Oriented Software Architecture)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/posa/</link>
      <pubDate>Sat, 05 Apr 2025 01:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/posa/</guid>
      <description>POSA(패턴 지향 소프트웨어 아키텍처) 는 복잡한 소프트웨어 시스템 설계 문제에 대한 검증된 해결책을 패턴 형태로 제공하는 아키텍처 접근 방식이다. 다양한 수준의 추상화에서 재사용 가능한 디자인 패턴을 체계적으로 적용하여 소프트웨어의 품질, 유지보수성 및 확장성을 향상시키는 방법론을 제시한다.</description>
    </item>
    <item>
      <title>지연 초기화(Lazy Initialization)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/lazy-initialization/</link>
      <pubDate>Wed, 18 Dec 2024 10:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/lazy-initialization/</guid>
      <description>지연 초기화는 객체나 값의 생성을 실제로 필요할 때까지 미루는 설계 패턴이다. 메모리 절약, 빠른 시작, 불필요한 연산 방지 등 자원 효율성을 극대화할 수 있지만, 최초 접근 시 지연, 예외 발생의 지연, 동시성 관리 등 주의가 필요하다.</description>
    </item>
    <item>
      <title>Domain-Driven Design</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-methodology/domain-driven-design/</guid>
      <description>Domain-Driven Design (DDD, 도메인 주도 설계) 는 복잡한 비즈니스 도메인을 중심으로 소프트웨어를 설계하는 방법론으로, 도메인 전문가와 개발자가 유비쿼터스 언어 (Ubiquitous Language) 를 통해 협력하여 도메인 모델을 구축하고, 바운디드 컨텍스트 (Bounded Context) 로 복잡성을 관리하며, 전략적 설계와 전술적 설계를 통해 유지보수 가능한 소프트웨어를 개발하는 접근법이다.</description>
    </item>
    <item>
      <title>Factory Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/factory-method-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/factory-method-pattern/</guid>
      <description>Factory Method Pattern 은 객체 생성을 위한 인터페이스를 정의하되, 어떤 클래스를 인스턴스화할지는 서브클래스가 결정하도록 하는 생성 패턴이다. 클라이언트 코드와 구체적인 제품 클래스 간의 결합도를 낮추고, 상속을 통해 객체 생성의 책임을 서브클래스에 위임하여 확장성과 유지보수성을 향상시킨다.</description>
    </item>
    <item>
      <title>Singleton Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/singleton-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/singleton-pattern/</guid>
      <description>Singleton 패턴은 클래스의 인스턴스를 하나만 생성하고, 어디서든 이 인스턴스를 공유하도록 보장하는 패턴이다. 전역 상태 관리, 설정 객체, 로깅, 캐시 등에서 활용되며, thread-safe 구현이 핵심이다.</description>
    </item>
    <item>
      <title>Flyweight Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/flyweight-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/flyweight-pattern/</guid>
      <description>플라이웨이트 패턴은 대량의 유사한 객체들 간에 공통 상태를 공유하여 메모리 사용량을 최소화하는 구조적 디자인 패턴이다.  고유 상태 (Intrinsic State) 와 외부 상태 (Extrinsic State) 를 분리하여, 공유 가능한 고유 상태는 하나의 플라이웨이트 객체에 저장하고 외부 상태는 컨텍스트에서 관리함으로써 메모리 효율성과 성능을 향상시킨다.</description>
    </item>
    <item>
      <title>Composite Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/composite-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/composite-pattern/</guid>
      <description>Composite Pattern은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴이다.</description>
    </item>
    <item>
      <title>Decorator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/decorator-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/decorator-pattern/</guid>
      <description>객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Adapter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/adapter-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/adapter-pattern/</guid>
      <description>Adapter Pattern 은 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 하는 구조적 설계 패턴이다. 기존 코드 수정 없이 레거시 시스템과 신규 시스템을 연결하는 브리지 역할을 하며, 인터페이스 변환을 통해 시스템 간 상호 운용성을 제공한다.</description>
    </item>
    <item>
      <title>Abstract Factory Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/abstract-factory-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/abstract-factory-pattern/</guid>
      <description>Abstract Factory Pattern 은 관련된 객체들의 패밀리를 구체적인 클래스를 명시하지 않고 생성할 수 있게 하는 생성형 디자인 패턴이다. 제품군의 일관성을 보장하며, 시스템의 독립성과 확장성을 제공하여 다양한 플랫폼이나 환경에서 동일한 인터페이스로 서로 다른 구현체를 생성할 수 있게 한다.</description>
    </item>
    <item>
      <title>Builder Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/builder-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/builder-pattern/</guid>
      <description>빌더 패턴은 복잡한 객체를 단계별로 생성하며, 생성 과정과 표현 방법을 분리해 다양한 조합의 객체 생성을 유연하게 지원하는 생성 패턴이다. 매개변수가 많거나 생성 절차가 복잡한 객체에 효과적이며, 코드 가독성, 유지보수성, 불변성 보장에 유리하다.</description>
    </item>
    <item>
      <title>Prototype Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/prototype-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/prototype-pattern/</guid>
      <description>Prototype 패턴은 객체 생성 비용이 높거나 런타임에 객체 유형이 동적으로 결정될 때 기존 인스턴스를 복제 (clone) 해 새 객체를 만드는 Creational 패턴이다. 클라이언트는 구체 클래스에 의존하지 않고 인터페이스 기반 clone 메서드를 통해 객체를 생성해 유연성과 성능을 개선한다.</description>
    </item>
    <item>
      <title>GoF</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/</link>
      <pubDate>Wed, 25 Sep 2024 01:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/</guid>
      <description>GoF 디자인 패턴은 객체 생성, 구조 조합, 행동 관리를 체계화한 23 가지 솔루션이다. 재사용 가능한 코드 작성을 통해 **유지보수성**과 **확장성**을 높이며, Singleton, Adapter, Observer 등이 대표적이다. 이 패턴들은 복잡한 시스템에서 발생하는 공통 문제를 해결하기 위해 필수적으로 활용된다.</description>
    </item>
    <item>
      <title>Interpreter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/</guid>
      <description>Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.</description>
    </item>
    <item>
      <title>Visitor Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/visitor-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/visitor-pattern/</guid>
      <description>Visitor Pattern은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Chain of Responsibility</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/chain-of-responsibility/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/chain-of-responsibility/</guid>
      <description>Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Mediator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern/</guid>
      <description>Mediator Pattern(중재자 패턴)은 소프트웨어 디자인 패턴 중 하나로, 객체 간의 상호작용을 캡슐화하여 서로 직접 통신하지 않고 중재자 객체를 통해서만 소통하도록 설계된 행동 패턴이다.</description>
    </item>
    <item>
      <title>Memento Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/memento-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/memento-pattern/</guid>
      <description>Mediator 패턴은 객체 지향 소프트웨어 디자인 패턴 중 하나로, 객체들 간의 복잡한 상호작용을 캡슐화하여 객체 간 결합도를 낮추는 행위 패턴이다.</description>
    </item>
    <item>
      <title>Command Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/command-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/command-pattern/</guid>
      <description>요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>State Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/state-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/state-pattern/</guid>
      <description>객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Template Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/template-method-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/template-method-pattern/</guid>
      <description>알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Incremental Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/incremental-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/incremental-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식.</description>
    </item>
    <item>
      <title>Prototyping Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/prototyping-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/prototyping-model/</guid>
      <description>최종 제품의 초기 버전 또는 모형을 만들어 사용자의 피드백을 받고 요구사항을 명확히 하는 방법.</description>
    </item>
    <item>
      <title>Rapid Application Development</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/hybrid-and-scaled/rapid-application-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/hybrid-and-scaled/rapid-application-development/</guid>
      <description>빠른 프로토타이핑과 반복적인 개발을 통해 신속하게 애플리케이션을 구축하는 접근 방식</description>
    </item>
    <item>
      <title>Iterative Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/iterative-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/iterative-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분으로 나누어 반복적으로 개발하고 개선하는 방법</description>
    </item>
    <item>
      <title>Spiral Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/spiral-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/spiral-model/</guid>
      <description>위험 분석을 중심으로 반복적인 개발을 수행하며, 각 반복 주기마다 위험 요소를 평가하고 대응한다.</description>
    </item>
    <item>
      <title>V Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/v-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/v-model/</guid>
      <description>개발 단계와 테스트 단계를 병행하여 진행하는 검증(Verification)과 확인(Validation) 중심의 접근 방식이다.</description>
    </item>
    <item>
      <title>Waterfall Model</title>
      <link>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/waterfall-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/software-development-lifecycle/software-development-methodology/traditional/waterfall-model/</guid>
      <description>각 단계를 순차적으로 진행하며, 이전 단계가 완료되어야 다음 단계로 넘어가는 전통적인 모델.</description>
    </item>
  </channel>
</rss>
