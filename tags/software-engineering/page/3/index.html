<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Engineering | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-engineering/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-engineering/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-engineering/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-engineering/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Engineering"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Engineering"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Engineering</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting</h2></header><div class=entry-content><p>Rate Limiting Rate Limiting은 MSA(Microservices Architecture) 환경에서 시스템 보안과 안정성을 유지하기 위한 핵심 기술로, 과도한 트래픽으로 인한 서비스 장애 방지와 악성 공격 차단을 목표로 한다.
클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.
Rate Limiting은 단순 트래픽 제어를 넘어 마이크로서비스 생태계의 안전벨트 역할을 수행한다.
2025년 현재, 주요 클라우드 제공업체들은 AI 기반 예측 차단 기능을 표준으로 제공하며, 이는 시스템 보안 설계 시 필수 요소로 자리잡았다. 효과적 구현을 위해서는 서비스 특성에 맞는 알고리즘 선택과 지속적 모니터링 체계 수립이 관건이다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/rate-limiting/rate-limiting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Consumer-side contract test</h2></header><div class=entry-content><p>Consumer-side Contract Test Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.
Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.
Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다. 격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다. 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다. 구현 단계 모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다. 테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다. 테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다. 계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다. 계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해). 장점 빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다. 명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다. 주의사항 과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다. 유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다. 완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 10:59:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-side contract test" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-side-contract-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Consumer-Driven Contract Testing</h2></header><div class=entry-content><p>Consumer-Driven Contract Testing Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.
CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.
CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자가 테스트의 주도권을 가진다. 실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다. 격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다. 구현 단계 소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다. 계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다. 계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다. 제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다. 장점 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다. 주의사항 계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음. 계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의. 도구 Pact: CDC 테스팅을 위한 대표적인 도구. Testsigma: CDC 테스팅을 지원하는 또 다른 도구. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-Driven Contract Testing" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-driven-contract-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Component Test</h2></header><div class=entry-content><p>Service Component Test Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.
주요 특징 격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다. 경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다. 집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다. 반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다. 구현 방법 테스트 환경 설정:
...</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Component Test" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/service-component-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Anti-Corruption Layer</h2></header><div class=entry-content><p>Anti-Corruption Layer Pattern 아래는 “Anti-Corruption Layer Pattern(부패 방지 레이어 패턴)” 에 대한 체계적이고 심층적인 조사, 분석, 정리입니다.
1. 태그 (Tag) Anti-Corruption-Layer Integration-Pattern Domain-Driven-Design Legacy-System 2. 분류 구조 적합성 분석 현재 분류 구조
1 2 3 4 5 Computer Science and Engineering └─ Software Engineering └─ Design and Architecture └─ Architecture Patterns └─ Specialized Patterns 분석 및 근거
Anti-Corruption Layer Pattern 은 기존 시스템 (레거시) 과 신규 시스템 (또는 다른 도메인) 간 통합 시, 서로 다른 도메인 모델의 오염 (부패) 을 방지하기 위해 중간에 변환 계층을 두는 패턴입니다.
이 패턴은 “Architecture Patterns > Specialized Patterns” 에 포함되어야 하며, “Software Engineering > Design and Architecture” 계층 아래에 위치하는 것이 적절합니다.
따라서, 현재 분류 구조는 주제의 특성과 실무적 중요성 모두를 반영하고 있습니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 10:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Anti-Corruption Layer" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/specialized-patterns/anti-corruption-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Composition</h2></header><div class=entry-content><p>API Composition API Composition 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.
API Composition은 여러 마이크로서비스의 API 응답을 집계하여 단일 API 엔드포인트로 제공하는 패턴이다.
이를 통해 클라이언트는 복잡한 데이터 요구사항을 단일 요청으로 처리할 수 있다.
API Composition 패턴은 마이크로서비스 아키텍처에서 데이터 접근을 간소화하고 클라이언트 경험을 개선하는 강력한 도구이나 구현 시 성능과 복잡성을 고려해야 하며, 시스템의 요구사항에 따라 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-16 10:52:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Composition" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/api-composition-strategies/api-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Database per Service Pattern</h2></header><div class=entry-content><p>Database per Service Pattern “Database per Service Pattern"은 마이크로서비스 아키텍처에서 중요한 디자인 패턴 중 하나이다.
Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.
이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.
주요 특징:
각 서비스는 자신만의 전용 데이터베이스를 가짐 서비스 간 데이터 접근은 API를 통해서만 가능 각 서비스는 자신의 요구사항에 가장 적합한 데이터베이스 기술을 선택할 수 있음 Database per Service Pattern은 마이크로서비스 아키텍처에서 서비스 간 독립성과 확장성을 높인다.
하지만 이를 효과적으로 구현하기 위해서는 신중한 설계와 다양한 기술적 도전을 해결해야 한다.
각 서비스의 특성과 전체 시스템의 요구사항을 고려하여 이 패턴의 적용 여부를 결정해야 하며, 필요에 따라 다른 패턴들과 조합하여 사용하는 것이 좋다.
...</p></div><footer class=entry-footer><span title='2024-11-12 10:05:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Database per Service Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/database-per-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Database</h2></header><div class=entry-content><p>Shared Database 마이크로서비스 아키텍처(MSA)에서 “Shared Database” 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.
Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.
Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 07:39:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/shared-database/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/replication/replication-model/master-slave/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Incremental Model</h2></header><div class=entry-content><p>증분 모델 (Incremental Model) 전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식. 각 증분은 완전한 기능을 갖춘 소프트웨어의 일부분으로, 사용자에게 점진적으로 제공
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 800, 'height': 600, 'diagramPadding': 15}}}%% graph TD %% 시작점 Start([프로젝트 시작]) --> Initial[초기 요구사항 분석] %% 증분 1: 핵심 기능 subgraph Inc1 [증분 1: 핵심 기능] R1[요구분석] --> D1[설계] D1 --> I1[구현] I1 --> T1[테스트] T1 --> V1[검증] end %% 증분 2: 확장 기능 subgraph Inc2 [증분 2: 확장 기능] R2[요구분석] --> D2[설계] D2 --> I2[구현] I2 --> T2[테스트] T2 --> V2[검증] end %% 증분 3: 최종 기능 subgraph Inc3 [증분 3: 최종 기능] R3[요구분석] --> D3[설계] D3 --> I3[구현] I3 --> T3[테스트] T3 --> V3[검증] end %% 증분 간 연결 Initial --> Inc1 V1 --> Inc2 V2 --> Inc3 V3 --> End([프로젝트 완료]) %% 산출물 연결 V1 -.제품 릴리즈 1.-> Rel1[동작하는 핵심 시스템] V2 -.제품 릴리즈 2.-> Rel2[확장된 시스템] V3 -.최종 릴리즈.-> Rel3[완성된 시스템] %% 피드백 루프 Rel1 -.피드백.-> R2 Rel2 -.피드백.-> R3 %% 스타일 정의 classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px classDef phase fill:#e1f5fe,stroke:#01579b,stroke-width:1px classDef milestone fill:#e8f5e9,stroke:#2e7d32,stroke-width:1px classDef release fill:#fff3e0,stroke:#e65100,stroke-width:1px class Start,End,Initial milestone class R1,D1,I1,T1,V1,R2,D2,I2,T2,V2,R3,D3,I3,T3,V3 phase class Rel1,Rel2,Rel3 release style Inc1 fill:#f0f4f8,stroke:#666,stroke-width:1px style Inc2 fill:#e1f5fe,stroke:#666,stroke-width:1px style Inc3 fill:#e8f5e9,stroke:#666,stroke-width:1px 주요 단계 요구사항 분석: 현재 증분에 포함될 기능을 정의. 설계: 시스템 아키텍처와 상세 설계를 수행. 구현: 실제 코드를 작성. 테스트: 구현된 기능을 테스트하고 버그를 수정. 통합 및 배포: 새로운 증분을 기존 시스템과 통합하고 사용자에게 제공. 특징 단계적 개발: 전체 시스템을 여러 개의 증분으로 나누어 개발. 순차적 제공: 각 증분을 완성할 때마다 사용자에게 제공. 기능 우선순위: 중요도나 우선순위에 따라 증분을 계획. 반복적 프로세스: 각 증분마다 요구사항 분석부터 테스트까지의 과정을 반복. 점진적 기능 확장: 각 증분마다 새로운 기능이 추가되거나 기존 기능이 개선. 장점 조기 제품 출시: 첫 번째 증분부터 사용 가능한 제품을 제공할 수 있다. 유연한 변경 관리: 각 증분 사이에 요구사항 변경을 반영할 수 있다. 위험 감소: 중요한 기능을 먼저 개발하여 주요 위험을 조기에 해결할 수 있다. 사용자 피드백 활용: 각 증분 후 사용자 피드백을 받아 다음 증분에 반영할 수 있다. 병렬 개발 가능: 여러 팀이 동시에 다른 증분을 개발할 수 있다. 단점 전체 아키텍처 설계 필요: 초기에 전체 시스템의 아키텍처를 설계해야 한다. 인터페이스 관리 복잡성: 증분 간 인터페이스 관리가 복잡할 수 있다. 문서화 부담: 각 증분마다 문서화가 필요하여 작업량이 증가할 수 있다. 전체 비용 증가: 여러 번의 통합과 테스트로 인해 전체 비용이 증가할 수 있다. 적합한 프로젝트 유형 주요 요구사항은 명확하지만 세부사항은 변경될 수 있는 프로젝트 빠른 시장 출시가 필요한 프로젝트 새로운 기술이나 기능을 점진적으로 도입하고자 할 때 자금이나 인력 등의 자원이 제한적인 경우 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Incremental Model" href=https://buenhyden.github.io/posts/software-engineering/software-development/software-development-methodology/traditional/incremental-model/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-engineering/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-engineering/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>