<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>라이브러리 (Library)와 프레임워크 (Framework)</h2></header><div class=entry-content><p>라이브러리 (Library)와 프레임워크 (Framework) 프로그래밍에서 라이브러리와 프레임워크는 소프트웨어 개발의 핵심 도구
비교 기준 라이브러리 (Library) 프레임워크 (Framework) 정의 특정 기능을 수행하는 코드의 재사용 가능한 모음 애플리케이션 개발을 위한 기본 구조와 규칙의 집합 제어 흐름 개발자가 직접 제어 (Caller가 Callee를 호출) 프레임워크가 제어 (IoC: Inversion of Control) 유연성 높음 (필요한 부분만 선택적으로 사용 가능) 상대적으로 낮음 (정해진 규칙과 구조를 따라야 함) 학습 곡선 상대적으로 낮음 (특정 기능만 학습) 높음 (전체 구조와 규칙을 이해해야 함) 코드 구조화 개발자가 직접 설계 프레임워크가 기본 구조 제공 대표적 예시 • React.js (UI 라이브러리)
• NumPy (수치 계산)
• jQuery (DOM 조작)
• Requests (HTTP 통신) • Django (Python 웹)
• Spring (Java 엔터프라이즈)
• Angular (웹 프론트엔드)
• Laravel (PHP 웹) 주요 장점 • 필요한 기능만 선택적 사용
• 가볍고 유연한 구조
• 빠른 학습과 적용 가능
• 다른 도구와 쉽게 통합 • 일관된 코드 구조
• 표준화된 개발 방식
• 보안, 성능 최적화 제공
• 큰 규모의 프로젝트에 적합 주요 단점 • 구조화된 가이드 부족
• 일관성 있는 코드 작성 어려움
• 큰 프로젝트에서 관리 어려움 • 학습에 많은 시간 필요
• 유연성 제한
• 불필요한 기능도 포함될 수 있음 사용 시기 • 특정 기능만 필요할 때
• 작은 규모의 프로젝트
• 최대한의 자유도가 필요할 때 • 큰 규모의 프로젝트
• 표준화된 개발이 필요할 때
• 팀 단위 개발 시 라이브러리(Library) 라이브러리는 특정 기능을 수행하는 함수, 클래스, 모듈 등의 모음이다.
개발자가 필요할 때 호출하여 사용할 수 있는 도구 모음이라고 볼 수 있다
...</p></div><footer class=entry-footer><span title='2024-11-08 06:47:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;268 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 라이브러리 (Library)와 프레임워크 (Framework)" href=https://buenhyden.github.io/til/2024/11/08/library-and-framework/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blocking vs Non-Blocking</h2></header><div class=entry-content><p>Blocking and Non-Blocking Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.
이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.
Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.
Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.
Blocking Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.
해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.
동작 방식 프로세스가 특정 작업을 요청한다. 해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다. 작업이 완료되면 프로세스는 다시 실행 상태로 전환된다. 그동안 다른 작업은 수행될 수 없다. 특징 프로그램의 실행 흐름이 순차적이고 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 응답을 즉시 받을 수 있다. 프로그램 구조가 단순하고 직관적이다. 실제 예시 1 2 3 4 5 6 // Blocking I/O의 예시 File file = new File("example.txt"); FileInputStream input = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = input.read(buffer); // 이 지점에서 Blocking 발생 // 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음 성능 측면 단일 작업의 처리 시간이 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 대기 시간이 발생한다. 구현 복잡도 구현이 단순하다. 디버깅이 쉽다. 코드 흐름이 직관적이다. 적합한 사례 간단한 스크립트 작성 순차적 데이터 처리 즉각적인 응답이 필요한 경우 작은 규모의 애플리케이션 Non-Blocking Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.
작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-18 12:36:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;801 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blocking vs Non-Blocking" href=https://buenhyden.github.io/til/2024/10/18/blocking-vs-non-blocking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)와 비동기(Asynchronous)</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 카테고리 동기(Synchronous) 비동기(Asynchronous) 기본 개념 - 작업이 순차적으로 실행됨 - 작업이 독립적으로 실행됨 - 이전 작업이 완료될 때까지 다음 작업 대기 - 작업의 완료를 기다리지 않고 다음 작업 진행 - 실행 순서가 보장됨 - 실행 순서가 보장되지 않음 처리 방식 - 단일 스레드에서 순차적 처리 - 멀티 스레드 또는 이벤트 루프 기반 처리 - 작업 완료까지 대기 - 작업 완료 시 콜백/Promise/async-await 등으로 처리 - 직관적인 코드 흐름 - 비선형적 코드 흐름 장점 - 코드의 가독성이 좋음 - 시스템 자원의 효율적 사용 - 디버깅이 용이함 - 더 나은 사용자 경험 제공 - 에러 처리가 간단함 - 높은 처리량(Throughput) 단점 - 시스템 자원 비효율적 사용 - 코드의 복잡성 증가 - 응답 시간이 길어질 수 있음 - 디버깅이 어려움 - 사용자 경험 저하 가능성 - 에러 처리가 복잡함 적합한 사용 사례 - 간단한 계산 작업 - 네트워크 요청 - 메모리 내 데이터 처리 - 파일 입출력 - 작은 크기의 데이터 처리 - 대용량 데이터 처리 - 순차적 처리가 필요한 작업 - 독립적으로 실행 가능한 작업 에러 처리 - try-catch 블록으로 직접 처리 - Promise의 catch 또는 try-catch와 async-await 사용 - 즉시 에러 감지 및 처리 - 에러 처리가 비동기적으로 발생 - 스택 트레이스 추적이 용이 - 에러 발생 지점 추적이 복잡할 수 있음 성능 특성 - CPU 집약적 작업에 유리 - I/O 집약적 작업에 유리 - 메모리 사용량이 예측 가능 - 동시 처리로 인한 메모리 사용량 변동 - 단일 작업 처리 시간이 빠름 - 전체 처리량 최적화에 유리 코드 관리 - 코드 구조가 단순함 - 상태 관리가 필요함 - 유지보수가 상대적으로 쉬움 - 비동기 패턴에 대한 이해 필요 - 테스트 작성이 용이함 - 테스트 시나리오가 복잡할 수 있음 리소스 활용 - 단일 리소스 점유 - 리소스의 효율적 분배 - 대기 시간 동안 블로킹 - 대기 시간 동안 다른 작업 수행 - 시스템 부하가 예측 가능 - 동시성으로 인한 부하 변동 가능 최신 트렌드 및 발전 방향 동기 프로그래밍의 발전 코루틴(Coroutine) 도입 제너레이터(Generator) 함수 활용 구조적 동시성(Structured Concurrency) 개념 도입 비동기 프로그래밍의 발전 Promise와 async/await의 보편화 반응형 프로그래밍(Reactive Programming)의 확산 이벤트 기반 아키텍처의 발전 비동기 스트림 처리 기술의 발전 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 00:57:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;341 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)와 비동기(Asynchronous)" href=https://buenhyden.github.io/til/2024/10/18/synchronous-and-asynchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Programming Language Control Structures</h2></header><div class=entry-content><p>Programming Language Control Structures 프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.
1. Iteration Structures 특정 코드 블록을 반복적으로 실행하기 위한 구조
Language For Loop While Loop Do-While For-Each/Range Python for x in sequence while condition N/A for x in iterable Java for(init;condition;increment) while(condition) do {…} while(condition) for(Type x: collection) JavaScript for(let i=0;i&lt;n;i++) while(condition) do {…} while(condition) for(let x of iterable) TypeScript Same as JavaScript + type safety Same as JavaScript Same as JavaScript Same as JavaScript Golang for i:=0; i&lt;n; i++ for condition N/A for _, v:= range slice Kotlin for (i in range) while(condition) do {…} while(condition) for (item in collection) Rust for x in iter while condition loop {…} for x in collection 2. Conditional Statements 특정 조건에 따라 다른 코드 블록을 실행하도록 하는 구조
...</p></div><footer class=entry-footer><span title='2024-10-11 11:12:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;716 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Language Control Structures" href=https://buenhyden.github.io/til/2024/10/11/programming-language-control-structures/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Iteration vs Recursion</h2></header><div class=entry-content><p>Iteration Vs Recursion Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration Vs Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-09-28 11:03:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;327 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Iteration vs Recursion" href=https://buenhyden.github.io/til/2024/09/28/iteration-vs-recursion/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>