<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Django</h2></header><div class=entry-content><p>Python Django Python으로 작성된 오픈 소스 웹 프레임워크로, 2005년에 처음 출시되어 현재까지 활발하게 개발되고 있다.
“The web framework for perfectionists with deadlines"라는 슬로건을 가지고 있으며, 빠른 개발과 깔끔한 설계를 동시에 추구한다.
“batteries included” 철학을 따른다. 이는 웹 개발에 필요한 대부분의 기능이 프레임워크에 이미 포함되어 있다는 의미이다.
주요 개념 모델 (Model): 데이터베이스 구조와 동작을 정의한다. 뷰 (View): 클라이언트 요청을 처리하고 응답을 생성한다. 템플릿 (Template): HTML 파일의 구조와 레이아웃을 정의한다. URL 설정: URL 패턴과 뷰를 연결한다. 폼 (Forms): 사용자 입력을 처리하고 검증한다. 미들웨어 (Middleware): 요청/응답 처리 과정에 개입하여 추가 기능을 제공한다. 특징 풀 스택 프레임워크: Django는 웹 개발에 필요한 모든 요소를 포함하는 풀 스택 프레임워크. DRY (Don’t Repeat Yourself) 원칙: 코드의 재사용성을 강조하여 개발 속도를 높인다. MVT (Model-View-Template) 아키텍처: MVC 패턴을 기반으로 하지만, Controller 대신 Template을 사용한다. Model: 데이터베이스 구조와 데이터를 정의 View: 비즈니스 로직을 처리 (다른 프레임워크의 Controller 역할) Template: 사용자에게 보여지는 인터페이스를 정의 (다른 프레임워크의 View 역할) ORM (Object-Relational Mapping): 데이터베이스 조작을 위한 강력한 ORM을 제공한다. 관리자 인터페이스: 자동 생성되는 관리자 페이지를 통해 빠른 데이터 관리가 가능하다. 장점 빠른 개발: 관리자 인터페이스와 ORM을 통해 빠른 개발이 가능하다. 보안: 다양한 보안 기능이 내장되어 있어 안전한 웹 애플리케이션 개발이 가능하다. 확장성: 다양한 서드파티 패키지를 통해 기능을 확장할 수 있다. 문서화: 풍부한 문서와 커뮤니티 지원을 받을 수 있다. 단점 모놀리식 구조: 작은 프로젝트에는 과도할 수 있다. 성능 이슈: ORM 사용 시 복잡한 쿼리에서 성능 문제가 발생할 수 있다. 학습 곡선: 초보자에게는 학습 곡선이 있을 수 있다. 실시간 처리: WebSocket 등의 실시간 기능은 추가 패키지 필요 개발 특성 모듈화: 앱 단위로 프로젝트를 구성하여 모듈화된 개발이 가능하다. 테스트 주도 개발: Django는 단위 테스트를 위한 도구를 제공한다. 마이그레이션: 데이터베이스 스키마 변경을 쉽게 관리할 수 있다. 성능과 기능 Django는 다양한 기능을 제공하면서도 성능 최적화를 위한 도구들을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-11-04 02:57:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;489 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Django" href=https://buenhyden.github.io/posts/programming-languages/python/web-framework/django/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Flask</h2></header><div class=entry-content><p>Python Flask 2010년 Armin Ronacher가 만든 Python 웹 프레임워크이다.
“마이크로 프레임워크"라고 불리는 Flask는 핵심 기능만을 가볍게 유지하면서도 필요에 따라 확장할 수 있는 유연한 구조를 제공한다.
주요 개념 라우팅: URL과 함수를 연결하여 요청을 처리한다. 템플릿 엔진: Jinja2를 사용하여 동적 HTML 생성을 지원한다. WSGI: Web Server Gateway Interface를 통해 웹 서버와 애플리케이션 간 통신을 처리한다. 확장성: 다양한 확장 모듈을 통해 기능을 추가할 수 있다. 특징 간결성: 최소한의 코드로 웹 애플리케이션을 구현할 수 있다. 유연성: 프로젝트 구조나 데이터베이스 선택 등에 있어 개발자에게 많은 자유를 제공한다. 마이크로 프레임워크: 핵심 기능만 제공하여 가볍고 빠른 개발이 가능하다. 컨텍스트 기반 설계: request, session 등의 글로벌 객체를 컨텍스트를 통해 안전하게 관리한다. Python 기반: 파이썬의 강력한 생태계를 활용할 수 있다. 장점 학습 용이성: 간단한 구조로 초보자도 쉽게 배울 수 있다. 빠른 프로토타이핑: 간단한 프로젝트를 빠르게 구현할 수 있다. 높은 자유도: 개발자가 원하는 대로 구조를 설계할 수 있다. 확장성: 필요에 따라 다양한 확장 모듈을 추가할 수 있다. 단점 기능의 제한: Django에 비해 기본 제공 기능이 적다. 대규모 프로젝트 관리: 큰 프로젝트에서는 구조화에 추가 노력이 필요할 수 있다. 성능 최적화: 대규모 트래픽 처리 시 추가적인 최적화가 필요할 수 있다. 개발 특성 모듈화: 앱 단위로 프로젝트를 구성하여 모듈화된 개발이 가능하다. RESTful API 개발: API 서버 구축에 적합하다. 마이크로서비스: 독립적인 서비스 컴포넌트 개발에 유용하다. 성능과 기능 경량화: 최소한의 오버헤드로 빠른 응답 시간을 제공한다. 확장 가능한 성능: 적절한 최적화를 통해 높은 성능을 달성할 수 있다. 내장 개발 서버: 테스트와 개발을 위한 서버를 제공한다. 디버깅 지원: 개발 모드에서 상세한 오류 정보를 제공한다. 서버 구현 예제 1 2 3 4 5 6 7 8 9 10 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' if __name__ == '__main__': app.run(debug=True) 이 예제는 간단한 Flask 애플리케이션을 생성하고 루트 URL에 접속 시 “Hello, World!“를 반환한다.
...</p></div><footer class=entry-footer><span title='2024-11-04 02:57:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flask" href=https://buenhyden.github.io/posts/programming-languages/python/web-framework/flask/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FastAPI</h2></header><div class=entry-content><p>Python FastAPI FastAPI는 2018년에 Sebastián Ramírez가 개발한 현대적인 Python 웹 프레임워크.
Python 3.6+ 의 타입 힌트를 기반으로 하며, 비동기 프로그래밍을 지원하는 고성능 웹 프레임워크.****
주요 개념 타입 힌트: FastAPI는 파이썬의 타입 힌트를 적극적으로 활용하여 코드의 안정성과 가독성을 높인다. 비동기 프로그래밍: Starlette을 기반으로 하여 비동기 프로그래밍을 지원한다. 의존성 주입: 코드의 재사용성을 높이고 결합도를 낮추는 의존성 주입 시스템을 제공한다. Pydantic: 데이터 검증과 설정 관리를 위한 Pydantic 라이브러리를 사용한다. 특징 빠른 성능: Starlette과 Pydantic을 기반으로 하여 NodeJS 및 Go와 대등한 수준의 높은 성능을 제공한다. 자동 문서화: Swagger UI와 ReDoc을 통해 API 문서를 자동으로 생성한다. 표준 기반: OpenAPI와 JSON Schema를 기반으로 한다. 쉬운 사용성: 직관적인 API로 빠른 개발이 가능하다. 장점 빠른 개발 속도: 간결한 문법과 자동 문서화 기능으로 개발 속도가 빠르다. 높은 성능: 비동기 지원과 최적화된 코드로 높은 성능을 제공한다. 타입 안정성: 파이썬의 타입 힌트를 활용하여 코드의 안정성을 높인다. 현대적인 기능: 비동기 처리, 의존성 주입, 자동 검증 등 현대적인 기능을 지원한다. 단점 상대적으로 작은 커뮤니티: 새로운 프레임워크이기 때문에 Django나 Flask에 비해 커뮤니티가 작다. 학습 곡선: 비동기 프로그래밍, 타입 힌트 등 현대적인 파이썬 개념에 익숙하지 않은 개발자에게는 학습 곡선이 있을 수 있다. 성숙도: 아직 1.0 버전이 출시되지 않아 안정성 면에서 우려가 있을 수 있다. 개발 특성 모듈화: 앱 단위로 프로젝트를 구성하여 모듈화된 개발이 가능하다. RESTful API 개발: API 서버 구축에 최적화되어 있다. 마이크로서비스: 독립적인 서비스 컴포넌트 개발에 유용하다. 성능과 기능 고성능: 비동기 처리와 최적화된 코드로 높은 성능을 제공한다. 데이터 검증: Pydantic을 통한 강력한 데이터 검증 기능을 제공한다. 보안: 내장된 보안 기능으로 SQL 인젝션, CSRF, XSS 등 다양한 보안 위협에 대응한다. 확장성: 다양한 미들웨어와 확장 기능을 지원한다. 서버 구현 예제 1 2 3 4 5 6 7 8 9 10 11 from fastapi import FastAPI app = FastAPI() @app.get("/") async def root(): return {"message": "Hello World"} @app.get("/items/{item_id}") async def read_item(item_id: int, q: str = None): return {"item_id": item_id, "q": q} 이 예제는 루트 경로와 아이템 ID를 받는 두 개의 엔드포인트를 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-04 02:56:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;360 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to FastAPI" href=https://buenhyden.github.io/posts/programming-languages/python/web-framework/fastapi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg</h2></header><div class=entry-content><p>setup.cfg setup.cfg는 파이썬 프로젝트의 설정을 관리하는 구성 파일이다.
이 파일은 INI 형식으로 작성되며, setuptools가 프로젝트를 빌드하고 배포할 때 참조하는 중요한 설정들을 포함한다.
주요 특징 선언적 구성: setup.py에서 프로그래밍 방식으로 정의하던 설정을 보다 간단하고 명확한 형식으로 선언할 수 있습니다. 정적 메타데이터: 프로젝트의 이름, 버전, 설명 등 변경이 잦지 않은 정보를 저장하는 데 적합합니다. 도구별 설정: 다양한 개발 도구들의 설정을 한 곳에서 관리할 수 있습니다. 주요 섹션 [metadata]:
프로젝트의 기본 정보를 정의한다.
여기에는 프로젝트 이름, 버전, 작성자 정보, 라이선스 등이 포함된다.
이 정보는 PyPI에 패키지를 등록할 때 사용되며, pip로 패키지를 설치할 때 표시되는 정보의 기반이 된다.
...</p></div><footer class=entry-footer><span title='2024-11-03 14:24:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;272 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg" href=https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/configuration/setup.cfg/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 20–The Zen of Python</h2></header><div class=entry-content><p>PEP 20–The Zen of Python 파이썬의 철학과 디자인 원칙을 담고 있다.
파이썬 인터프리터에서 import this를 실행하면 볼 수 있다.
1. Beautiful is Better than Ugly. (아름다움이 추한 것보다 낫다) 코드는 보기 좋고 이해하기 쉽게 작성해야 한다.
1 2 3 4 5 6 7 8 # 아름다운 코드 names = ['Alice', 'Bob', 'Charlie'] for name in names: print(f"Hello, {name}!") # 추한 코드 x=['Alice','Bob','Charlie'] for i in range(len(x)):print("Hello, "+x[i]+"!") 2. Explicit is Better than Implicit. (명시적이 암시적인 것보다 낫다) 코드의 의도를 명확히 표현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1202 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 20–The Zen of Python" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 257–Docstring Conventions</h2></header><div class=entry-content><p>PEP 257–Docstring Conventions Python 코드의 docstring 작성에 대한 규칙과 관례를 정의한 문서
정의
모듈, 함수, 클래스, 메서드 정의의 첫 번째 문장으로 오는 문자열 리터럴로, 해당 객체의 doc 특별 속성이 된다. 작성 대상
모든 모듈, 모듈이 내보내는 모든 함수와 클래스, 공개 메서드(생성자 포함)에 docstring을 작성해야 한다. 형식
항상 """삼중 큰따옴표"""를 사용한다.
한 줄 docstring과 여러 줄 docstring 두 가지 형식이 있다. 한 줄 Docstring 명확한 경우에 사용합니다. 마침표로 끝나는 구문으로 작성합니다. 함수/메서드의 효과를 명령형으로 설명합니다. 여러 줄 Docstring 요약 줄, 빈 줄, 자세한 설명 순으로 구성됩니다. 클래스 docstring 다음에는 빈 줄을 삽입합니다. 기본 규칙 1 2 3 4 5 6 7 def function(arg1, arg2): """한 줄 설명. 여러 줄에 걸친 자세한 설명. 매개변수와 반환값 설명. """ pass 모듈, 함수, 클래스별 Docstring 내용 모듈 내보내는 클래스, 예외, 함수 등을 나열
...</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 257–Docstring Conventions" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 3000–Python 3000</h2></header><div class=entry-content><p>PEP 3000–Python 3000 Python 3000 개발 과정과 특징을 설명한다.
Python 3000, Python 3.0, Py3k는 모두 같은 프로젝트를 지칭한다.
PEP 번호 체계 : 3000-3099는 메타 PEP, 3100-3999는 기능 PEP 타임라인 : Python 2.6과 3.0의 동시 출시 계획을 포함. 호환성과 전환: Python 3.0은 2.x와 하위 호환성이 없다. Python 2.6은 “Py3k 경고 모드"와 일부 3.0 기능을 지원. 2to3 도구를 통해 2.x 코드를 3.0으로 변환할 수 있다. 개발 모델: 2.6과 3.0을 동시 지원하는 프로젝트를 위한 권장 개발 방법을 제시. 구현 언어: Python 3000은 C로 구현되며, Python 2 코드베이스에서 진화합니다. Python2와 Python3의 비교 문법 차이 기능 Python 2 Python 3 print문 print "Hello" print("Hello") 정수 나눗셈 5/2 → 2 5/2 → 2.5 예외 처리 except Error, e except Error as e range 리스트 반환 이터레이터 반환 문자열 포맷팅 % 연산자 중심 f-strings, format() 메서드 유니코드 표현 방식 항목 Python 2 Python 3 기본 문자열 ASCII Unicode (UTF-8) 유니코드 선언 u"문자열" 기본 지원 바이트 문자열 str bytes 인코딩 처리 명시적 처리 필요 자동 처리 국제화 지원 제한적 완전 지원 성능 차이 항목 Python 2 Python 3 실행 속도 기준 10-15% 향상 메모리 관리 GC 기본 향상된 GC 멀티스레딩 GIL 제한 GIL 개선 비동기 처리 제한적 async/await 지원 최적화 기본 향상된 최적화 메모리 사용량 차이 항목 Python 2 Python 3 기본 객체 크기 기준 20-30% 감소 문자열 처리 더 많은 메모리 최적화된 메모리 컬렉션 리스트 중심 메모리 효율적인 뷰 캐시 처리 기본 향상된 캐시 메모리 해제 덜 효율적 더 효율적 5. 파일 입출력 성능 차이 항목 Python 2 Python 3 기본 I/O 상대적 느림 15-20% 향상 텍스트 처리 ASCII 중심 유니코드 최적화 버퍼링 기본 향상된 버퍼링 비동기 I/O 제한적 완전 지원 대용량 파일 처리 제한적 효율적 처리 라이브러리 지원 차이 특징 Python 2 Python 3 표준 라이브러리 기본적인 모듈 제공 개선된 모듈 및 새로운 모듈 추가 (예: asyncio, statistics) 서드파티 라이브러리 지원 일부 레거시 라이브러리만 지원 대부분의 주요 라이브러리가 지원 (예: TensorFlow, PyTorch) 새로운 라이브러리 개발 거의 없음 활발히 진행 중 유니코드 관련 라이브러리 제한적 지원 향상된 지원 레거시 라이브러리 호환성 높음 일부 호환되지 않을 수 있음 라이브러리 업데이트 빈도 낮음 (지원 종료) 높음 (지속적인 개선) AI/ML 라이브러리 지원 제한적 광범위 웹 개발 프레임워크 일부 구버전만 지원 최신 버전 지원 (예: Django, Flask) 데이터 과학 라이브러리 제한적 지원 폭넓은 지원 (예: pandas, numpy 최신 버전) 보안 관련 라이브러리 업데이트 중단 지속적인 보안 업데이트 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;379 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3000–Python 3000" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 3333–Python Web Server Gateway Interface V1.0.1</h2></header><div class=entry-content><p>PEP 3333–Python Web Server Gateway Interface V1.0.1 Python Web Server Gateway Interface (WSGI) 버전 1.0.1을 정의한 문서.
PEP 333의 개정판으로, Python 3 지원을 개선하고 몇 가지 오랜 de facto 수정사항을 반영
PEP 3333은 PEP 333을 Python 3 시대에 맞게 업데이트한 버전이다.
주요 변경사항과 특징 Python 3 지원: 문자열 처리가 유니코드로 변경됨 environ 딕셔너리의 문자열은 str 타입이어야 함 응답 본문은 bytes 타입이어야 함 새로운 보안 고려사항: 헤더 인젝션 방지 안전한 문자열 처리 미들웨어 체이닝: 여러 미들웨어를 연결하여 요청/응답 처리 파이프라인 구성 가능 파일 핸들링: wsgi.input과 wsgi.errors를 통한 표준화된 입출력 처리 WSGI (Web Server Gateway Interface) 웹 서버와 Python 웹 어플리케이션 또는 프레임워크 간의 표준 인터페이스를 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1026 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3333–Python Web Server Gateway Interface V1.0.1" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 484–Type Hints</h2></header><div class=entry-content><p>PEP 484–Type Hints Python에 타입 힌트(Type Hints)를 도입하여 함수의 인자와 반환값에 대한 타입을 명시할 수 있도록 하는 표준을 정의
Python 3.5부터 도입됨.
코드의 가독성을 높이고 정적 타입 분석 도구가 코드를 검사할 수 있도록 돕는다.
PEP 484는 Python의 동적 타이핑 특성을 유지하면서, 타입 힌트를 통해 코드의 품질과 유지보수성을 향상시키는 것을 목표로 한다.
주요 내용 함수 주석을 통한 타입 힌트 함수 인자와 반환값에 대한 타입 정보를 제공하여 코드의 의도를 명확히 한다. 예를 들어, 문자열을 인자로 받고 문자열을 반환하는 함수는 다음과 같이 정의할 수 있다. 1 2 3 4 def greeting(name: str) -> str: return 'Hello ' + name` # `name: str`: `name` 인자는 문자열이어야 함을 나타냅니다. # `-> str`: 함수가 문자열을 반환함을 나타냅니다. 정적 타입 검사 타입 힌트는 런타임에 강제되지 않으며, 정적 분석 도구(예: mypy)를 사용하여 코드의 타입 일관성을 검사할 수 있다. 이는 코드 작성 시 오류를 미리 발견하고 수정할 수 있게 도와준다. 타입 힌트 모듈 typing 모듈을 통해 다양한 타입 힌트를 제공한다. 예를 들어, 리스트, 딕셔너리와 같은 컨테이너 타입 및 제네릭(Generic) 타입을 지원한다. 유연한 사용 타입 힌트는 선택 사항이며, Python은 여전히 동적 타이핑 언어로 남아 있다. 즉, 모든 함수에 타입 힌트를 추가할 필요는 없다. 예제 간단한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 1. 기본적인 타입 힌트 사용 def greeting(name: str) -> str: # name 파라미터는 문자열(str) 타입이어야 함을 나타냄 # -> str 은 함수가 문자열을 반환함을 나타냄 return f"Hello, {name}!" # 2. 여러 기본 타입들의 사용 def calculate_total(quantity: int, price: float) -> float: # quantity는 정수(int), price는 실수(float) 타입 # 반환값은 실수(float) 타입 return quantity * price # 3. 리스트 타입 힌트 사용 from typing import List def get_first_name(names: List[str]) -> str: # names는 문자열 리스트임을 나타냄 # List[str]은 모든 요소가 문자열인 리스트를 의미 return names[0] if names else "" # 4. 옵셔널 타입 사용 from typing import Optional def find_user(user_id: Optional[int]) -> Optional[str]: # user_id는 정수이거나 None일 수 있음을 나타냄 # 반환값도 문자열이거나 None일 수 있음 if user_id is None: return None return f"User_{user_id}" 복잡한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from typing import Dict, Tuple, Union, Callable # 5. 딕셔너리와 복합 타입 def process_user_data( user_info: Dict[str, Union[str, int]] ) -> Tuple[str, int]: # Dict[str, Union[str, int]]는 # - 키는 문자열이고 # - 값은 문자열 또는 정수인 딕셔너리를 의미 # Tuple[str, int]는 문자열과 정수로 구성된 튜플을 반환한다는 의미 name = user_info.get("name", "") age = user_info.get("age", 0) return name, age # 6. 함수 타입 힌트 def apply_operation( func: Callable[[int, int], int], x: int, y: int ) -> int: # Callable[[int, int], int]는 # - 두 개의 정수를 입력받고 # - 정수를 반환하는 함수를 의미 return func(x, y) # 7. 제네릭 타입 from typing import TypeVar, Sequence T = TypeVar('T') # 제네릭 타입 변수 정의 def first_element(sequence: Sequence[T]) -> Optional[T]: # Sequence[T]는 임의의 타입 T로 이루어진 시퀀스를 의미 # Optional[T]는 T 타입 또는 None을 반환할 수 있음을 의미 return sequence[0] if sequence else None 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;519 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 484–Type Hints" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 492–Coroutines with Async and Await Syntax</h2></header><div class=entry-content><p>PEP 492–Coroutines with Async and Await Syntax Python에 비동기 프로그래밍을 위한 async와 await 구문을 도입하여 코루틴(coroutine)을 명시적으로 정의하고 사용하는 방법을 제안한다.
Python 3.5부터 도입되었다.
기존의 제너레이터 기반 코루틴과 구분되는 네이티브 코루틴을 정의한다.
PEP 492는 비동기 프로그래밍을 더 명확하고 Pythonic하게 만들어 준다.
PEP 492의 주요 내용 네이티브 코루틴 정의 async def 키워드를 사용하여 네이티브 코루틴을 정의한다.
이는 함수가 코루틴임을 명확히 나타내며, 기존의 yield나 yield from 대신 await를 사용한다.
1 2 3 4 async def fetch_data(): """데이터를 비동기적으로 가져오는 네이티브 코루틴""" await asyncio.sleep(1) # 비동기 작업 대기 return "data" await 표현식 await 키워드는 코루틴에서 다른 코루틴이나 비동기 작업의 완료를 기다릴 때 사용된다.
...</p></div><footer class=entry-footer><span title='2024-11-03 13:46:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 492–Coroutines with Async and Await Syntax" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>