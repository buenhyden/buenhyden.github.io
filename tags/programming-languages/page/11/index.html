<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Sequelize</h2></header><div class=entry-content><p>Sequelize Sequelize는 Node.js를 위한 현대적이고 강력한 Promise 기반 ORM(Object-Relational Mapping) 라이브러리.
관계형 데이터베이스와 상호작용하는 복잡한 작업을 단순화하고 추상화해준다.
ORM은 객체지향 프로그래밍 언어와 관계형 데이터베이스 사이의 번역기 역할을 한다.
복잡한 SQL 쿼리를 직접 작성하지 않고도 데이터베이스를 쉽게 조작할 수 있게 해준다.
Sequelize의 장점 데이터베이스 추상화 강력한 관계 설정 데이터 검증 마이그레이션 지원 다양한 데이터베이스 호환성 주의사항 대규모 애플리케이션에서는 성능 최적화 필요 ORM의 복잡성을 이해해야 함 직접 SQL 쿼리도 학습 권장 Sequelize의 주요 특징 다양한 데이터베이스 지원: MySQL, PostgreSQL, SQLite, MariaDB, MSSQL 등 여러 관계형 데이터베이스를 지원한다. 객체 지향적 접근: JavaScript 객체를 통해 데이터베이스 테이블을 표현하고 조작할 수 있다. 스키마 정의: 모델을 통해 데이터베이스 스키마를 정의하고 관리할 수 있다. 관계 설정: 모델 간의 관계(1:1, 1:N, N:M)를 쉽게 정의하고 관리할 수 있다. 쿼리 빌딩: SQL 쿼리를 직접 작성하지 않고도 JavaScript 메서드를 통해 데이터베이스 작업을 수행할 수 있다. 기본 설정 및 연결 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const { Sequelize, DataTypes } = require('sequelize'); // 데이터베이스 연결 const sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: 'mysql', // 사용하는 데이터베이스 종류 logging: false // SQL 로그 비활성화 }); // 연결 테스트 try { await sequelize.authenticate(); console.log('데이터베이스 연결 성공!'); } catch (error) { console.error('연결 실패:', error); } 모델 정의와 관계 기본 모델 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const User = sequelize.define('User', { // 속성 정의 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING }, email: { type: DataTypes.STRING, unique: true, validate: { isEmail: true } }, age: { type: DataTypes.INTEGER, validate: { min: 18, max: 100 } } }, { // 모델 옵션 timestamps: true, // createdAt, updatedAt 자동 생성 }); 모델 간 관계 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 1:N 관계 (One-to-Many) const Post = sequelize.define('Post', { title: DataTypes.STRING, content: DataTypes.TEXT }); // 사용자와 포스트 관계 정의 User.hasMany(Post); Post.belongsTo(User); // N:M 관계 (Many-to-Many) const Project = sequelize.define('Project', { name: DataTypes.STRING }); User.belongsToMany(Project, { through: 'UserProjects' }); Project.belongsToMany(User, { through: 'UserProjects' }); CRUD 작업 데이터 생성 1 2 3 4 5 6 7 8 9 10 11 12 // 단일 레코드 생성 const newUser = await User.create({ firstName: 'John', lastName: 'Doe', email: 'john@example.com' }); // 대량 생성 await User.bulkCreate([ { firstName: 'Alice', lastName: 'Smith' }, { firstName: 'Bob', lastName: 'Johnson' } ]); 데이터 조회 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 모든 사용자 조회 const users = await User.findAll(); // 조건부 조회 const youngUsers = await User.findAll({ where: { age: { [Op.lt]: 30 // 30세 미만 } }, include: [Post] // 연관된 포스트 함께 조회 }); // 단일 사용자 조회 const user = await User.findByPk(1); 데이터 업데이트 1 2 3 4 5 // 단일 레코드 업데이트 await User.update( { lastName: 'NewLastName' }, { where: { id: 1 } } ); 데이터 삭제 1 2 3 4 // 단일 레코드 삭제 await User.destroy({ where: { id: 1 } }); 트랜잭션 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 const result = await sequelize.transaction(async (t) => { const user = await User.create({ firstName: 'Transactional', lastName: 'User' }, { transaction: t }); await user.createPost({ title: '첫 번째 포스트', content: '트랜잭션 내 생성' }, { transaction: t }); return user; }); 마이그레이션 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 마이그레이션 예시 module.exports = { up: async (queryInterface, Sequelize) => { await queryInterface.createTable('Users', { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER }, firstName: { type: Sequelize.STRING } }); }, down: async (queryInterface, Sequelize) => { await queryInterface.dropTable('Users'); } }; 학습 로드맵 JavaScript 기본 문법 숙달 Node.js 기초 학습 SQL 기본 개념 이해 Sequelize 기본 CRUD 작업 연습 관계 모델링 및 고급 쿼리 학습 참고 및 출처 Sequelize | Feature-rich ORM for modern TypeScript & JavaScript
...</p></div><footer class=entry-footer><span title='2024-11-21 15:47:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;668 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Sequelize" href=https://buenhyden.github.io/posts/programming-languages/javascript/runtime-environments/nodejs/library/working-with-dbs/sequelize/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Biome</h2></header><div class=entry-content><p>Biome Biome은 JavaScript, TypeScript, JSX, TSX, JSON, CSS, GraphQL 등 다양한 웹 개발 언어를 위한 빠른 포매터이자 린터이다.
Rust로 작성되어 높은 성능을 자랑하며, Prettier와 97% 호환성을 제공한다.
주요 기능 코드 포매팅(Formatting)
일관된 코드 스타일을 자동으로 적용한다. 들여쓰기, 줄 바꿈, 공백 처리 등을 자동으로 조정한다. Prettier와 유사한 결과물을 생성하지만 훨씬 빠른 속도를 보여준다. 린팅(Linting)
코드의 잠재적 문제를 미리 발견한다. 보안 취약점, 성능 이슈, 코드 스타일 위반 등을 검사한다. ESLint의 대부분의 규칙을 지원하면서도 더 빠른 처리 속도를 제공한다. 구문 분석(Parser)
...</p></div><footer class=entry-footer><span title='2024-11-21 15:19:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;364 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Biome" href=https://buenhyden.github.io/posts/programming-languages/javascript/build-tools/linter-and-formatter/biome/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>eslint</h2></header><div class=entry-content><p>Eslint 2013년 Nicholas C. Zakas가 만든 JavaScript 코드 분석 도구로, 코드의 품질을 향상시키고 잠재적인 문제를 미리 발견하는 것이 주요 목적이다.
정적 코드 분석을 통해 문법 오류부터 코딩 스타일까지 다양한 측면을 검사할 수 있다.
2023년 11월 3일 금요일에 릴리즈된 ESLint 8.53.0 버전에서 포맷팅 규칙이 공식적으로 폐기됨. 포맷팅 규칙은 띄어쓰기, 세미콜론, 문자열 형식 등을 아우르는 코드 컨벤션을 강화시켜 주는 규칙을 의미한다.
주요 특징 규칙 시스템
ESLint는 매우 유연한 규칙 시스템을 가지고 있다. 각 규칙은 세 가지 수준으로 설정할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-21 15:15:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;457 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to eslint" href=https://buenhyden.github.io/posts/programming-languages/javascript/build-tools/linter-and-formatter/eslint/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>prettier</h2></header><div class=entry-content><p>Prettier Prettier는 2017년에 출시된 “독선적인(Opinionated)” 코드 포매터.
“독선적"이라는 의미는 코드 스타일에 대한 대부분의 결정을 Prettier가 자체적으로 내린다는 뜻.
이는 개발자들 사이의 코드 스타일 논쟁을 줄이고, 일관된 코드베이스를 유지하는 데 큰 도움을 준다.
주요 특징과 장점 광범위한 언어 지원
Prettier는 다음과 같은 다양한 언어와 파일 형식을 지원한다:
JavaScript/TypeScript JSX/TSX CSS/SCSS/Less HTML JSON Markdown YAML GraphQL 최소한의 설정
Prettier는 설정 옵션을 의도적으로 제한적으로 제공한다. 이는 다음과 같은 이점이 있다:
팀 내 코드 스타일 논쟁 감소 설정 파일 관리의 단순화 프로젝트 간 일관성 유지 용이 자동 코드 재정렬
Prettier는 AST(추상 구문 트리)를 사용하여 코드를 완전히 재구성한다:
...</p></div><footer class=entry-footer><span title='2024-11-21 15:15:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;446 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to prettier" href=https://buenhyden.github.io/posts/programming-languages/javascript/build-tools/linter-and-formatter/prettier/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로미스(Promise)</h2></header><div class=entry-content><p>프로미스(Promise) 프로미스(Promise)는 자바스크립트에서 비동기 처리를 위해 사용되는 객체이다.
프로미스(Promise)는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체이다.
이는 비동기 처리를 동기적으로 처리할 수 있게 해주며, 콜백 함수의 단점을 보완한다.
프로미스(Promise)의 상태 프로미스(Promise)는 세 가지 상태를 가진다.
대기(Pending): 초기 상태, 비동기 처리 로직이 아직 완료되지 않은 상태 이행(Fulfilled): 비동기 처리가 성공적으로 완료되어 프로미스(Promise)가 결과 값을 반환한 상태 거부(Rejected): 비동기 처리가 실패하거나 오류가 발생한 상태 Promise 생성자와 Executor 함수의 기본 구조 프로미스(Promise)는 new Promise() 생성자를 통해 생성된다.
Promise를 생성할 때는 다음과 같은 구조를 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-21 14:54:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;979 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로미스(Promise)" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/promise/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event Loop</h2></header><div class=entry-content><p>Event Loop 이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.
끊임없이 실행되는 프로세스로, 콜 스택이 비어있는지 확인하고 태스크 큐에서 콜백 함수를 가져와 실행하며, 자바스크립트 엔진이 아닌 호스팅 환경(브라우저 또는 Node.js)에서 제공되는 메커니즘이다. 또한, 비동기 작업의 완료 및 해당 콜백의 실행을 조정한다.
https://blog.kakaocdn.net/dn/bEeJN4/btsabeBnUWX/exb9jS9LXWWW7oM1Yk832K/img.png
Event Loop의 구성 요소 콜 스택 (Call Stack): 현재 실행 중인 함수들이 쌓이는 곳. 후입선출(LIFO) 구조 웹 API (Web APIs): 브라우저에서 제공하는 비동기 작업을 처리하는 API. 콜백 큐 (Callback Queue): 비동기 작업이 완료된 후 실행될 콜백 함수들이 대기하는 곳. 선입선출(FIFO) 구조 이벤트 루프 (Event Loop): 콜 스택과 콜백 큐를 모니터링하며 작업을 조율. Event Loop의 동작 과정 JavaScript 코드가 실행되면 함수 호출은 콜 스택에 쌓인다. 비동기 함수(예: setTimeout, fetch)를 만나면 웹 API로 보내져 별도로 처리된다. 웹 API에서 작업이 완료되면 해당 콜백 함수를 콜백 큐로 보낸다. 이벤트 루프는 지속적으로 콜 스택이 비어있는지 확인한다. 콜 스택이 비어있다면, 이벤트 루프는 콜백 큐에서 가장 오래된 콜백을 콜 스택으로 이동시킨다. 이 과정을 반복한다. Event Loop의 기본 개념: 식당 시나리오 상황: 바쁜 식당에서 일하는 웨이터를 생각해보자.
...</p></div><footer class=entry-footer><span title='2024-11-21 12:44:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;774 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Loop" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/event-loop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>pm2</h2></header><div class=entry-content><p>Pm2 PM2는 Node.js 애플리케이션을 위한 고급 프로덕션 프로세스 관리자.
이는 내장된 로드 밸런서를 포함하고 있으며, 애플리케이션을 항상 실행 상태로 유지하고, 시스템 재부팅 시에도 자동으로 재시작할 수 있게 해주는 도구.
프로세스 관리의 중요성:
서버 애플리케이션을 운영할 때는 단순히 애플리케이션을 실행하는 것 이상의 관리가 필요하다.
예기치 않은 충돌이 발생할 수 있고, 서버가 재시작될 수 있으며, 성능 모니터링이 필요할 수 있다.
PM2는 이러한 운영 관련 문제들을 효과적으로 해결해주는 도구. 주요 기능 프로세스 관리:
...</p></div><footer class=entry-footer><span title='2024-11-21 12:31:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;643 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pm2" href=https://buenhyden.github.io/posts/programming-languages/javascript/runtime-environments/nodejs/library/keep-app-running/pm2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jsdoc</h2></header><div class=entry-content><p>Jsdoc JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.
정의와 개념 JavaScript 코드에 대한 설명을 위해 사용되는 주석 시스템. /** */ 형식의 주석 안에 @로 시작하는 특별한 태그를 사용하여 정보를 제공한다. 주요 특징 API 문서 자동 생성: 주석을 기반으로 HTML 형식의 문서를 생성한다. 타입 정보 제공: 함수의 매개변수, 반환값 등의 타입을 명시할 수 있다. 코드 에디터 지원: 많은 IDE에서 JSDoc을 인식하여 자동완성, 타입 체크 등을 제공한다. 주요 태그 @param: 함수 매개변수 설명 @returns: 함수 반환값 설명 @type: 변수의 타입 지정 @typedef: 사용자 정의 타입 생성 @example: 사용 예제 제공 사용 예시 1 2 3 4 5 6 7 8 9 /** * 두 수를 더하는 함수 * @param {number} a - 첫 번째 숫자 * @param {number} b - 두 번째 숫자 * @returns {number} 두 숫자의 합 */ function add(a, b) { return a + b; } 참고 및 출처 Use JSDoc: Index
...</p></div><footer class=entry-footer><span title='2024-11-21 11:41:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;147 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jsdoc" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/jsdoc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Keywords</h2></header><div class=entry-content><p>Keywords 키워드들은 JavaScript 프로그래밍의 기본 구성 요소이며, ECMAScript 표준의 일부이다.
각 키워드는 특정한 프로그래밍 목적을 위해 설계되었으며, 이들을 올바르게 이해하고 사용하는 것이 효과적인 JavaScript 프로그래밍의 기초가 된다.
선언 관련 키워드 키워드 설명 예시 var 변수 선언 (함수 스코프) var name = "John"; let 변수 선언 (블록 스코프) let age = 25; const 상수 선언 (재할당 불가) const PI = 3.14; function 함수 선언 function add(a, b) { return a + b; } class 클래스 선언 class Person { constructor() {} } 조건문 및 반복문 키워드 키워드 설명 예시 if 조건문 if (age > 18) { console.log("Adult"); } else if문의 대안 조건 else { console.log("Minor"); } switch 다중 분기 조건문 switch (value) { case 1: break; } case switch문의 각 경우 case "A": return "Excellent"; default switch문의 기본 경우 default: return "Invalid"; for 반복문 for (let i = 0; i &lt; 5; i++) {} while 조건기반 반복문 while (count &lt; 10) {} do 최소 한번 실행되는 반복문 do { count++; } while (count &lt; 5); 제어 흐름 키워드 키워드 설명 예시 break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 함수에서 값 반환 return result; throw 예외 발생 throw new Error("Invalid input"); try 예외처리 시도 블록 try { riskyOperation(); } catch 예외처리 블록 catch (error) { handleError(error); } finally 예외 발생 여부와 관계없이 실행 finally { cleanup(); } 객체 지향 프로그래밍 키워드 키워드 설명 예시 this 현재 객체 참조 this.name = name; super 부모 클래스 참조 super(name); new 객체 생성 new Date(); extends 클래스 상속 class Student extends Person {} static 클래스 레벨 멤버 정의 static count = 0; get getter 메서드 정의 get name() { return this._name; } set setter 메서드 정의 set name(value) { this._name = value; } 모듈 및 패키지 키워드 키워드 설명 예시 import 모듈 가져오기 import { useState } from 'react'; export 모듈 내보내기 export default class MyComponent {} from 모듈 출처 지정 import React from 'react'; as 모듈 별칭 지정 import * as utils from './utils'; 기타 키워드 키워드 설명 예시 typeof 데이터 타입 확인 typeof value === "string" instanceof 객체 타입 확인 obj instanceof Array void undefined 값 반환 void function() {} delete 객체 프로퍼티 삭제 delete object.property in 프로퍼티 존재 확인 "name" in object debugger 디버깅 중단점 debugger; 예약된 리터럴 키워드 설명 예시 true 논리 참 값 let isActive = true; false 논리 거짓 값 let isDisabled = false; null 값이 없음을 나타내는 객체 let value = null; undefined 정의되지 않은 값 let value = undefined; 엄격 모드 키워드 키워드 설명 예시 “use strict” 엄격 모드 선언 "use strict"; // 코드의 시작 부분 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-21 03:18:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Keywords" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/keywords/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java Keywords</h2></header><div class=entry-content><p>Keyword 키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.
각 키워드의 특징과 주의사항:
모든 키워드는 소문자로만 작성된다. 키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다. 일부 키워드는 특정 컨텍스트에서만 의미를 가진다. 예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다. 데이터 타입 키워드 키워드 설명 예시 byte 8비트 정수형 (-128 ~ 127) byte b = 100; short 16비트 정수형 (-32,768 ~ 32,767) short s = 1000; int 32비트 정수형 int i = 10000; long 64비트 정수형 long l = 100000L; float 32비트 단정도 실수형 float f = 3.14f; double 64비트 배정도 실수형 double d = 3.14159; boolean 논리형 (true/false) boolean flag = true; char 16비트 유니코드 문자 char c = 'A'; void 반환값이 없음을 나타냄 void method() {} 제어문 키워드 키워드 설명 예시 if 조건문 시작 if (x > 0) {} else if문의 대안 경로 else {} switch 다중 분기문 시작 switch(value) {} case switch문의 각 경우 case 1: default switch문의 기본 경우 default: for 반복문 for (int i = 0; i &lt; n; i++) while 조건 기반 반복문 while (condition) do do-while 반복문 시작 do {} while(); break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 메소드에서 값 반환/종료 return value; 클래스 관련 키워드 키워드 설명 예시 class 클래스 정의 public class MyClass {} interface 인터페이스 정의 interface MyInterface {} extends 클래스/인터페이스 상속 class Child extends Parent {} implements 인터페이스 구현 class MyClass implements Interface {} enum 열거형 정의 enum Direction {NORTH, SOUTH} this 현재 인스턴스 참조 this.value = value; super 상위 클래스 참조 super.method(); new 객체 생성 new Object(); instanceof 객체 타입 검사 obj instanceof String 접근 제어 키워드 키워드 설명 예시 public 전체 접근 허용 public class Public {} private 클래스 내부만 접근 가능 private int value; protected 패키지와 자식 클래스 접근 가능 protected void method() {} default 패키지 내부만 접근 가능 int value; (키워드 생략) 제어자 키워드 키워드 설명 예시 static 클래스 레벨 멤버 정의 static int count; final 변경 불가 선언 final int MAX = 100; abstract 추상 클래스/메소드 선언 abstract class Abstract {} synchronized 스레드 동기화 synchronized void method() {} volatile 메모리 직접 접근 변수 volatile boolean flag; transient 직렬화 제외 필드 transient int temp; native 네이티브 메소드 선언 native void method(); strictfp 엄격한 부동소수점 연산 strictfp class Math {} 예외 처리 키워드 키워드 설명 예시 try 예외 발생 가능 블록 try {} catch 예외 처리 블록 catch (Exception e) {} finally 항상 실행되는 블록 finally {} throw 예외 발생 throw new Exception(); throws 예외 선언 void method() throws Exception {} assert 조건 검증 assert x > 0; 패키지 관련 키워드 키워드 설명 예시 package 패키지 선언 package com.example; import 클래스 임포트 import java.util.List; 리터럴 키워드 키워드 설명 예시 true 논리 참 값 boolean t = true; false 논리 거짓 값 boolean f = false; null 참조 없음 Object obj = null; 예약된 키워드 (미사용) 키워드 설명 const 상수 (사용되지 않음) goto 이동 (사용되지 않음) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-20 02:56:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Java Keywords" href=https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>