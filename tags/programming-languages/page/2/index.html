<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg Vs pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-08 14:29:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;602 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/til/2024/11/08/setup.cfg-vs-pyproject.toml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Programming Languages and Frameworks</h2></header><div class=entry-content><p>Programming Languages and Frameworks 프로그래밍 언어 비교 언어 언어 유형 주요 특징 장점 단점 주요 활용 분야 Python 고수준 인터프리터 언어 • 간결하고 읽기 쉬운 문법
• 동적 타이핑
• 광범위한 라이브러리 생태계 • 초보자가 배우기 쉬움
• 빠른 개발 속도
• 풍부한 데이터 과학 도구 • 실행 속도가 비교적 느림
• GIL로 인한 멀티스레딩 제한
• 메모리 사용량이 많음 • 데이터 과학
• 인공지능/머신러닝
• 웹 개발
• 스크립팅 JavaScript 스크립트 언어 • 이벤트 기반 프로그래밍
• 비동기 처리 지원
• 프론트엔드/백엔드 모두 가능 • 웹 개발의 표준
• 큰 개발자 커뮤니티
• 유연한 언어 특성 • 타입 시스템이 느슨함
• 브라우저별 호환성 이슈
• 코드 품질 관리가 어려움 • 웹 프론트엔드
• 서버사이드 개발(Node.js)
• 모바일 앱(React Native) Java 객체지향 컴파일 언어 • 플랫폼 독립성
• 강력한 타입 시스템
• 광범위한 기업용 라이브러리 • 안정성과 신뢰성
• 뛰어난 성능
• 풍부한 개발 도구 • 상대적으로 복잡한 문법
• 많은 보일러플레이트 코드
• 느린 개발 속도 • 엔터프라이즈 애플리케이션
• 안드로이드 앱
• 대규모 백엔드 시스템 Kotlin JVM 기반 현대적 언어 • Java 완벽 호환
• Null 안전성
• 간결한 문법 • Java보다 생산적
• 안전한 코드 작성
• 현대적 기능 지원 • 컴파일 시간이 길어질 수 있음
• 학습 자료가 상대적으로 적음
• 성숙도가 낮음 • 안드로이드 앱 개발
• 서버사이드 개발
• 크로스 플랫폼 개발 Go 컴파일 시스템 프로그래밍 언어 • 간단한 문법
• 내장 동시성 지원
• 빠른 컴파일과 실행 • 뛰어난 성능
• 쉬운 동시성 처리
• 빌트인 도구 지원 • 제네릭스 지원 제한적
• 예외 처리 기능 부족
• 생태계가 상대적으로 작음 • 클라우드 인프라
• 네트워크 서비스
• 시스템 도구 프로그래밍 언어별 기본 데이터 구조 분류 데이터 구조 Python JavaScript Java Kotlin Go Primitive Boolean bool boolean boolean Boolean bool Number (Integer) int number byte
short
int
long Byte
Short
Int
Long int8
int16
int32
int64 Number (Float) float number float
double Float
Double float32
float64 Character str[0] string[0] char Char rune String str string String String string Null/None None null
undefined null null nil Non-Primitive Array/List list Array Array
ArrayList Array
List array
slice Dictionary/Map dict Object
Map HashMap
TreeMap Map
HashMap map Set set Set HashSet
TreeSet Set
HashSet N/A Tuple tuple N/A N/A Pair
Triple N/A Queue/Stack collections.deque Array methods Queue
Stack Queue
Stack N/A Python: Python은 모든 것이 객체이지만, int, float, bool, str 등을 기본 데이터 타입으로 취급한다. JavaScript: JavaScript는 동적 타입 언어로, number와 같은 기본 타입과 object 같은 참조 타입을 가진다. Java: Java는 primitive 타입과 reference 타입을 명확히 구분한다. primitive 타입은 스택에 직접 저장되고, reference 타입은 힙 메모리를 참조한다. Kotlin: Kotlin은 Java와 달리 모든 타입을 객체로 취급하지만, 내부적으로는 JVM의 primitive 타입으로 최적화된다. Go: Go는 정적 타입 언어로, 다양한 크기의 정수형과 부동소수점 타입을 제공하며, struct를 통해 사용자 정의 타입을 만들 수 있다. 주요 개발 프레임워크 프레임워크 기본 정보 아키텍처 특성 기능성 성능과 확장성 개발 생산성 생태계 실제 활용 Django (Python) • 2005년 출시
• Python 기반
• BSD 라이선스 • MVT 아키텍처
• 모놀리식 구조
• ORM 내장 • 관리자 인터페이스 기본 제공
• 인증/보안 기능 완비
• Form 처리 시스템 • 중간 수준의 처리 성능
• 수평적 확장 가능
• 캐싱 시스템 내장 • 초기 설정 간편
• 빠른 개발 속도
• 중간 수준의 학습 곡선 • 매우 큰 커뮤니티
• 풍부한 서드파티 앱
• 광범위한 문서화 • Instagram
• Mozilla
• 대규모 CMS 시스템 Flask (Python) • 2010년 출시
• Python 기반
• BSD 라이선스 • 마이크로 프레임워크
• 유연한 구조
• 확장 가능한 설계 • 최소한의 핵심 기능
• RESTful 지원
• 유연한 라우팅 • 가벼운 리소스 사용
• 높은 처리 성능
• 유연한 확장 • 최소한의 초기 설정
• 빠른 프로토타이핑
• 낮은 학습 곡선 • 활발한 커뮤니티
• 다양한 확장 모듈
• 명확한 문서화 • Netflix
• LinkedIn
• 소규모 API 서비스 FastAPI (Python) • 2018년 출시
• Python 3.6+
• MIT 라이선스 • 비동기 처리
• OpenAPI 기반
• 타입 힌트 활용 • 자동 API 문서화
• 데이터 검증
• WebSocket 지원 • 매우 높은 성능
• 비동기 처리
• 효율적인 리소스 사용 • 간단한 초기 설정
• 빠른 API 개발
• 중간 수준의 학습 곡선 • 빠르게 성장 중
• 현대적 도구 통합
• 상세한 문서화 • Microsoft
• Uber
• 고성능 API 서비스 Spring (Java) • 2002년 출시
• Java 기반
• Apache 2.0 라이선스 • DI/IoC 컨테이너
• AOP 지원
• 모듈식 구조 • 광범위한 기능 제공
• 트랜잭션 관리
• 보안 프레임워크 • 높은 처리 성능
• 엔터프라이즈급 확장성
• 클러스터링 지원 • 복잡한 초기 설정
• 체계적인 개발 가능
• 높은 학습 곡선 • 거대한 커뮤니티
• 방대한 생태계
• 풍부한 레퍼런스 • 금융권 시스템
• 대형 포털
• 엔터프라이즈 시스템 Express.js (JavaScript) • 2010년 출시
• Node.js 기반
• MIT 라이선스 • 미들웨어 패턴
• 라우팅 중심
• MVC 지원 • 미들웨어 기반 기능 확장
• 라우팅
• 정적 파일 제공 • 경량화된 성능
• 이벤트 기반 확장성
• 비동기 처리 • 매우 간단한 설정
• 빠른 개발 가능
• 낮은 학습 곡선 • 매우 큰 커뮤니티
• NPM 생태계
• 풍부한 미들웨어 • IBM
• Uber
• RESTful API 서버 Nest.js (JavaScript) • 2017년 출시
• TypeScript 기반
• MIT 라이선스 • 모듈형 아키텍처
• DI 컨테이너
• 데코레이터 패턴 • TypeScript 지원
• OpenAPI 통합
• WebSocket 지원 • 높은 확장성
• 마이크로서비스 지원
• 캐싱 메커니즘 • 구조화된 초기 설정
• 체계적 개발
• 중간 수준의 학습 곡선 • 성장하는 커뮤니티
• 기업급 도구 지원
• 상세한 문서화 • Adidas
• Autodesk
• 엔터프라이즈 백엔드 Ktor (Kotlin) • 2018년 출시
• Kotlin 기반
• Apache 2.0 라이선스 • 비동기 처리
• 코루틴 기반
• 모듈식 구조 • WebSocket 지원
• 인증/보안 기능
• 유연한 라우팅 • 높은 성능
• 경량 리소스 사용
• 확장 가능한 구조 • 간단한 초기 설정
• Kotlin 친화적
• 중간 수준의 학습 곡선 • JetBrains 지원
• Kotlin 생태계
• 성장 중인 커뮤니티 • JetBrains
• 모바일 백엔드
• 마이크로서비스 Gin (Go) • 2014년 출시
• Go 기반
• MIT 라이선스 • 미들웨어 구조
• 라우터 중심
• MVC 지원 • 미들웨어 시스템
• JSON 검증
• 라우팅 그룹 • 매우 높은 성능
• 낮은 메모리 사용
• 고성능 라우터 • 빠른 초기 설정
• 직관적인 API
• 낮은 학습 곡선 • 큰 Go 커뮤니티
• 다양한 미들웨어
• 활발한 개발 • Dropbox
• Ethereum
• 고성능 API 서버 IoC(Inversion of Control)
프로그램의 제어 흐름을 역전시키는 소프트웨어 디자인 원칙
...</p></div><footer class=entry-footer><span title='2024-11-08 08:18:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1217 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Languages and Frameworks" href=https://buenhyden.github.io/til/2024/11/08/programming-languages-and-frameworks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript vs Node.js</h2></header><div class=entry-content><p>Javascript Vs Node.js JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.
주요 특징은 다음과 같다:
객체 기반의 스크립트 언어이다. 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 이벤트 중심의 프로그래밍이 가능하다. 웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다. 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 1 2 3 4 5 6 7 8 9 10 // JavaScript 예시 // DOM 조작 document.getElementById('myButton').addEventListener('click', function() { alert('버튼이 클릭되었습니다!'); }); // 비동기 처리 fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data));**** Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-08 09:33:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript vs Node.js" href=https://buenhyden.github.io/til/2024/11/08/javascript-vs-node.js/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import Vs Require require는 Node.js에서 사용되는 CommonJS 모듈 시스템의 키워드로, 동기적으로 모듈을 로드하며 프로그램의 어느 지점에서나 호출할 수 있다. 반면에 import는 ES6에서 도입된 모듈 시스템의 키워드로, 코드 실행 전에 모듈을 미리 로드하며 파일의 시작 부분에서만 사용할 수 있다. 따라서 프로젝트의 환경과 요구 사항에 따라 적절한 키워드를 선택하여 사용하는 것이 중요하다.
Import (ES Modules) ES6(ES2015)에서 도입된 모듈 시스템으로, JavaScript의 공식 표준 모듈 시스템. 정적 임포트 방식을 사용하며, 브라우저에서 기본적으로 지원된다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 기본 가져오기 import module from './module'; // 부분 가져오기 import { function1, function2 } from './module'; // 모든 것을 객체로 가져오기 import * as moduleObject from './module'; // 이름 변경하여 가져오기 import { originalName as newName } from './module'; // 가져오기와 실행만 하기 import './module'; Require (CommonJS) Node.js에서 기본적으로 사용되는 모듈 시스템으로, 동적 임포트를 지원한다. 런타임에 모듈을 로드할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-08 03:21:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;381 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/til/2024/11/08/import-vs-require/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Celery</h2></header><div class=entry-content><p>Celery Celery는 파이썬으로 작성된 분산 작업 큐 시스템이다.
주로 웹 애플리케이션에서 비동기 작업 처리와 작업 스케줄링을 위해 사용된다.
Celery는 파이썬으로 작성된 비동기 작업 큐/작업 스케줄러이다. 분산 메시지 전달을 기반으로 동작하며, 실시간 처리와 작업 스케줄링을 지원한다.
주요 역할:
비동기 작업 처리 실시간 작업 처리 예약된 작업 실행 분산 시스템에서의 작업 관리 Celery는 복잡한 비동기 작업 처리와 분산 시스템 구축에 매우 유용한 도구이다.
웹 애플리케이션의 성능을 향상시키고 확장성을 높이는 데 큰 도움이 된다.
...</p></div><footer class=entry-footer><span title='2025-01-29 07:04:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;747 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Celery" href=https://buenhyden.github.io/posts/programming-languages/python/library/queue/celery/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Keywords</h2></header><div class=entry-content><p>Keywords 키워드들은 JavaScript 프로그래밍의 기본 구성 요소이며, ECMAScript 표준의 일부이다.
각 키워드는 특정한 프로그래밍 목적을 위해 설계되었으며, 이들을 올바르게 이해하고 사용하는 것이 효과적인 JavaScript 프로그래밍의 기초가 된다.
선언 관련 키워드 키워드 설명 예시 var 변수 선언 (함수 스코프) var name = "John"; let 변수 선언 (블록 스코프) let age = 25; const 상수 선언 (재할당 불가) const PI = 3.14; function 함수 선언 function add(a, b) { return a + b; } class 클래스 선언 class Person { constructor() {} } 조건문 및 반복문 키워드 키워드 설명 예시 if 조건문 if (age > 18) { console.log("Adult"); } else if문의 대안 조건 else { console.log("Minor"); } switch 다중 분기 조건문 switch (value) { case 1: break; } case switch문의 각 경우 case "A": return "Excellent"; default switch문의 기본 경우 default: return "Invalid"; for 반복문 for (let i = 0; i &lt; 5; i++) {} while 조건기반 반복문 while (count &lt; 10) {} do 최소 한번 실행되는 반복문 do { count++; } while (count &lt; 5); 제어 흐름 키워드 키워드 설명 예시 break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 함수에서 값 반환 return result; throw 예외 발생 throw new Error("Invalid input"); try 예외처리 시도 블록 try { riskyOperation(); } catch 예외처리 블록 catch (error) { handleError(error); } finally 예외 발생 여부와 관계없이 실행 finally { cleanup(); } 객체 지향 프로그래밍 키워드 키워드 설명 예시 this 현재 객체 참조 this.name = name; super 부모 클래스 참조 super(name); new 객체 생성 new Date(); extends 클래스 상속 class Student extends Person {} static 클래스 레벨 멤버 정의 static count = 0; get getter 메서드 정의 get name() { return this._name; } set setter 메서드 정의 set name(value) { this._name = value; } 모듈 및 패키지 키워드 키워드 설명 예시 import 모듈 가져오기 import { useState } from 'react'; export 모듈 내보내기 export default class MyComponent {} from 모듈 출처 지정 import React from 'react'; as 모듈 별칭 지정 import * as utils from './utils'; 기타 키워드 키워드 설명 예시 typeof 데이터 타입 확인 typeof value === "string" instanceof 객체 타입 확인 obj instanceof Array void undefined 값 반환 void function() {} delete 객체 프로퍼티 삭제 delete object.property in 프로퍼티 존재 확인 "name" in object debugger 디버깅 중단점 debugger; 예약된 리터럴 키워드 설명 예시 true 논리 참 값 let isActive = true; false 논리 거짓 값 let isDisabled = false; null 값이 없음을 나타내는 객체 let value = null; undefined 정의되지 않은 값 let value = undefined; 엄격 모드 키워드 키워드 설명 예시 “use strict” 엄격 모드 선언 "use strict"; // 코드의 시작 부분 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-29 03:18:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Keywords" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java Keywords</h2></header><div class=entry-content><p>Keyword 키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.
각 키워드의 특징과 주의사항:
모든 키워드는 소문자로만 작성된다. 키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다. 일부 키워드는 특정 컨텍스트에서만 의미를 가진다. 예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다. 데이터 타입 키워드 키워드 설명 예시 byte 8비트 정수형 (-128 ~ 127) byte b = 100; short 16비트 정수형 (-32,768 ~ 32,767) short s = 1000; int 32비트 정수형 int i = 10000; long 64비트 정수형 long l = 100000L; float 32비트 단정도 실수형 float f = 3.14f; double 64비트 배정도 실수형 double d = 3.14159; boolean 논리형 (true/false) boolean flag = true; char 16비트 유니코드 문자 char c = 'A'; void 반환값이 없음을 나타냄 void method() {} 제어문 키워드 키워드 설명 예시 if 조건문 시작 if (x > 0) {} else if문의 대안 경로 else {} switch 다중 분기문 시작 switch(value) {} case switch문의 각 경우 case 1: default switch문의 기본 경우 default: for 반복문 for (int i = 0; i &lt; n; i++) while 조건 기반 반복문 while (condition) do do-while 반복문 시작 do {} while(); break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 메소드에서 값 반환/종료 return value; 클래스 관련 키워드 키워드 설명 예시 class 클래스 정의 public class MyClass {} interface 인터페이스 정의 interface MyInterface {} extends 클래스/인터페이스 상속 class Child extends Parent {} implements 인터페이스 구현 class MyClass implements Interface {} enum 열거형 정의 enum Direction {NORTH, SOUTH} this 현재 인스턴스 참조 this.value = value; super 상위 클래스 참조 super.method(); new 객체 생성 new Object(); instanceof 객체 타입 검사 obj instanceof String 접근 제어 키워드 키워드 설명 예시 public 전체 접근 허용 public class Public {} private 클래스 내부만 접근 가능 private int value; protected 패키지와 자식 클래스 접근 가능 protected void method() {} default 패키지 내부만 접근 가능 int value; (키워드 생략) 제어자 키워드 키워드 설명 예시 static 클래스 레벨 멤버 정의 static int count; final 변경 불가 선언 final int MAX = 100; abstract 추상 클래스/메소드 선언 abstract class Abstract {} synchronized 스레드 동기화 synchronized void method() {} volatile 메모리 직접 접근 변수 volatile boolean flag; transient 직렬화 제외 필드 transient int temp; native 네이티브 메소드 선언 native void method(); strictfp 엄격한 부동소수점 연산 strictfp class Math {} 예외 처리 키워드 키워드 설명 예시 try 예외 발생 가능 블록 try {} catch 예외 처리 블록 catch (Exception e) {} finally 항상 실행되는 블록 finally {} throw 예외 발생 throw new Exception(); throws 예외 선언 void method() throws Exception {} assert 조건 검증 assert x > 0; 패키지 관련 키워드 키워드 설명 예시 package 패키지 선언 package com.example; import 클래스 임포트 import java.util.List; 리터럴 키워드 키워드 설명 예시 true 논리 참 값 boolean t = true; false 논리 거짓 값 boolean f = false; null 참조 없음 Object obj = null; 예약된 키워드 (미사용) 키워드 설명 const 상수 (사용되지 않음) goto 이동 (사용되지 않음) 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-29 02:56:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Java Keywords" href=https://buenhyden.github.io/posts/programming-languages/java/concepts/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS</h2></header><div class=entry-content><p>NodeJS Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경
서버 사이드에서 JavaScript를 실행할 수 있게 해주는 플랫폼으로, 웹 서버 구축부터 네트워크 프로그래밍, 일반적인 서버 사이드 프로그래밍에 이르기까지 다양한 용도로 사용된다.
런타임 환경(Runtime Environment)
프로그램이 실행되는 동안 프로그램을 위한 ‘무대’를 제공하는 시스템.
이를 연극에 비유해보면, 런타임 환경은 배우(프로그램)가 공연할 수 있는 무대, 조명, 음향 시스템 등 모든 필요한 설비를 제공하는 극장과 같다.
주요 구성 요소
메모리 관리 런타임 환경은 프로그램이 사용할 메모리를 할당하고 관리. 기본 라이브러리 제공 런타임 환경은 프로그램이 필요로 하는 기본적인 기능들을 제공. 에러 처리 프로그램 실행 중 발생하는 오류를 감지하고 관리. 하드웨어 및 운영체제와의 상호작용 프로그램과 컴퓨터 시스템 사이의 중개자 역할. 중요성
...</p></div><footer class=entry-footer><span title='2024-11-08 04:45:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;859 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS" href=https://buenhyden.github.io/til/2024/11/08/nodejs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring</h2></header><div class=entry-content><p>Spring Spring은 Java 기반의 현대적인 엔터프라이즈 애플리케이션 개발을 위한 포괄적인 프레임워크.
Spring은 웹 프레임워크가 아닌 일반 프레임워크.
그 이유는:
범위의 차이
웹 프레임워크: 웹 애플리케이션 개발에 특화 (예: Django, Flask) Spring: 웹 외에도 다양한 종류의 애플리케이션 개발 가능 기능의 포괄성
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Spring으로 웹이 아닌 일반 애플리케이션도 개발 가능 @SpringBootApplication public class BatchProcessingApplication { @Scheduled(fixedRate = 1000) public void processData() { // 배치 처리 로직 } } // 데스크톱 애플리케이션도 가능 @SpringBootApplication public class DesktopApplication extends Application { @Override public void start(Stage stage) { // JavaFX UI 로직 } } 모듈성
Spring은 필요한 기능만 선택적으로 사용할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-07 09:52:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;947 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring" href=https://buenhyden.github.io/posts/programming-languages/java/framework/spring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring Boot</h2></header><div class=entry-content><p>Spring Boot Spring Boot는 Spring 프레임워크를 기반으로 한 Java 애플리케이션 개발을 더욱 쉽고 빠르게 만들어주는 도구
주요 특징과 장점 자동 구성 (Auto Configuration) Spring Boot는 @SpringBootApplication 어노테이션을 통해 자동 구성 기능을 제공한다.
이는 클래스패스에 있는 라이브러리를 기반으로 애플리케이션을 자동으로 설정하여 개발자가 수동으로 빈(Bean)을 구성할 필요성을 줄여준다.
독립 실행형 (Standalone) Spring Boot 애플리케이션은 외부 서버에 의존하지 않고 독립적으로 실행될 수 있다.
내장된 서버(예: Tomcat, Jetty, Undertow)를 포함하고 있어 별도의 웹 애플리케이션 서버 설치 없이 애플리케이션을 실행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-07 04:36:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring Boot" href=https://buenhyden.github.io/posts/programming-languages/java/web-framework/spring-boot/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>