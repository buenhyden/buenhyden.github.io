<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. FastAPI</h2></header><div class=entry-content><p>NodeJS vs. FastAPI 현대 웹 개발에서 백엔드 기술 선택은 프로젝트의 성공에 중요한 요소이다.
Node.js와 FastAPI는 각각 JavaScript와 Python 생태계에서 인기 있는 백엔드 기술로, 서로 다른 접근 방식과 강점을 가지고 있다.
Node.js는 오랜 기간 동안 검증된 기술로, 방대한 생태계와 JavaScript를 백엔드에서도 사용할 수 있는 일관성을 제공한다. 실시간 애플리케이션과 I/O 집약적 작업에 특히 뛰어나다.
FastAPI는 비교적 새로운 프레임워크이지만, 현대적인 Python 기능을 최대한 활용하여 빠른 개발 속도, 뛰어난 개발자 경험, 자동 문서화와 데이터 검증을 제공한다. Python의 데이터 과학 생태계와 통합이 필요한 프로젝트에 특히 적합하다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NodeJS vs. FastAPI" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/ecosystem--practice/runtime-environments/nodejs/nodejs-vs-fastapi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Flask</h2></header><div class=entry-content><p>NodeJS vs. Flask Node.js와 Flask는 현대 웹 애플리케이션 개발에 널리 사용되는 두 가지 인기 있는 백엔드 기술이다.
이 두 기술은 각각 다른 언어(JavaScript vs Python), 다른 철학, 그리고 서로 다른 접근 방식을 가지고 있다.
Node.js와 Flask는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
특히 I/O 집약적인 애플리케이션과 실시간 웹 애플리케이션에서 강점을 보인다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NodeJS vs. Flask" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/ecosystem--practice/runtime-environments/nodejs/nodejs-vs-flask/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ES Modules vs. CommonJS</h2></header><div class=entry-content><p>ES Modules vs. CommonJS 자바스크립트 애플리케이션이 복잡해지면서 코드를 모듈화하는 방법이 중요해졌다.
이에 두 가지 주요 모듈 시스템인 CommonJS와 ES Modules가 등장했다.
이 두 시스템은 각각 고유한 특성과 사용 사례를 가지고 있다.
JavaScript 모듈 시스템의 선택은 프로젝트의 요구 사항, 타겟 환경, 그리고 기존 코드베이스에 크게 의존한다.
최신 프로젝트에서는 ES Modules의 채택이 증가하는 추세이지만, CommonJS는 Node.js 생태계에서 여전히 중요한 역할을 하고 있다.
두 시스템의 장단점을 이해하고, 필요에 따라 적절한 시스템을 선택하거나 하이브리드 접근 방식을 채택하는 것이 좋다. 또한, 점진적으로 ES Modules로 마이그레이션하는 전략을 고려할 수 있으며, 이를 통해 모던 JavaScript의 이점을 활용하면서 기존 코드의 호환성도 유지할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:26:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to ES Modules vs. CommonJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/modules/es-modules-vs-commonjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Django</h2></header><div class=entry-content><p>NodeJS vs. Django 웹 개발에서 백엔드 프레임워크를 선택하는 것은 프로젝트의 성공에 중요한 요소이다. Node.js와 Django는 각각 다른 철학, 접근 방식, 그리고 강점을 가진 인기 있는 두 가지 백엔드 기술이다.
Node.js와 Django는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
빠른 프로토타이핑, 견고한 데이터 모델링, 내장된 관리 기능이 필요한 프로젝트에는 Django가 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:59:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NodeJS vs. Django" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/ecosystem--practice/runtime-environments/nodejs/nodejs-vs-django/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BunJS vs. NodeJS</h2></header><div class=entry-content><p>BunJS vs. NodeJS JavaScript는 원래 웹 브라우저에서만 실행되는 언어였지만, 서버 사이드 런타임의 등장으로 백엔드 개발에도 널리 사용되고 있다.
Node.js는 오랫동안 서버 사이드 JavaScript의 표준이었으나, Bun이라는 새로운 런타임이 등장하여 JavaScript 생태계에 변화를 가져오고 있다. 각기 다른 엔진과 설계 철학을 기반으로 개발되어 다양한 차이점을 보인다.
Node.js와 Bun은 각각 고유한 강점과 약점을 가진 JavaScript 런타임이다.
Node.js는 성숙한 생태계, 광범위한 호환성, 검증된 안정성을 제공하는 반면, Bun은 뛰어난 성능, 개선된 개발자 경험, 통합 도구를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:43:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to BunJS vs. NodeJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/ecosystem--practice/runtime-environments/bunjs/bunjs-vs-nodejs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>daphne</h2></header><div class=entry-content><p>Daphne Daphne는 Django Channels를 위해 개발된 HTTP, HTTP2 및 WebSocket 프로토콜 서버이다.
Django 프로젝트 팀에 의해 유지 관리되며 ASGI(Asynchronous Server Gateway Interface) 서버의 참조 구현으로 작동한다.
Django Channels와 함께 사용할 때, Redis나 다른 백엔드를 channel layer로 사용하여 실시간 통신을 구현할 수 있다.
이는 MongoDB의 Change Streams이나 MySQL의 CDC(Change Data Capture)와 같은 실시간 데이터 동기화 기능을 구현할 때 유용하다.
Daphne의 주요 특징 프로토콜 지원: Daphne는 HTTP, HTTP2, WebSocket 프로토콜을 모두 지원한다. 자동 프로토콜 협상: Daphne는 들어오는 요청을 자동으로 분석하여 적절한 프로토콜로 처리한다. ASGI 호환성: ASGI 애플리케이션과 호환되며, 특히 Django Channels를 위해 설계되었다. 개발 및 프로덕션 사용: Daphne는 개발 환경과 프로덕션 환경 모두에서 사용할 수 있다. Daphne 설치 pip를 사용하여 Daphne를 설치한다:
...</p></div><footer class=entry-footer><span title='2024-11-30 08:44:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to daphne" href=https://buenhyden.github.io/posts/programming-languages/python/ecosystem--practice/libraries/web-application-server/asgi-server/daphne/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>uvicorn</h2></header><div class=entry-content><p>Uvicorn Uvicorn은 Python용 ASGI(Asynchronous Server Gateway Interface) 웹 서버 구현체이다.
Uvicorn은 비동기 Python 웹 애플리케이션을 위한 고성능 서버이다.
ASGI 프로토콜을 지원하여 HTTP, HTTP2, WebSocket 등의 프로토콜을 처리할 수 있다.
주요 특징 비동기 처리: asyncio를 기반으로 하여 비동기 코드를 효율적으로 실행한다. 고성능: uvloop와 httptools를 사용하여 빠른 속도를 제공한다. 경량화: 최소한의 의존성으로 설치 가능하다. 개발 편의성: 자동 리로드 기능을 제공하여 개발 시 편리하다. ASGI 호환성: ASGI 표준을 준수하여 다양한 ASGI 프레임워크와 호환된다. FastAPI와의 통합 Uvicorn은 FastAPI의 기본 웹 서버로 사용된다.
FastAPI는 Uvicorn의 비동기 처리 능력을 활용하여 고성능 API를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-30 08:44:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to uvicorn" href=https://buenhyden.github.io/posts/programming-languages/python/ecosystem--practice/libraries/web-application-server/asgi-server/uvicorn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gunicorn</h2></header><div class=entry-content><p>Gunicorn Gunicorn(Green Unicorn)은 Python WSGI(Web Server Gateway Interface) HTTP 서버로, 파이썬 웹 애플리케이션을 위한 강력하고 효율적인 서버 솔루션이다.
Gunicorn은 웹 서버(예: Nginx)와 파이썬 웹 애플리케이션(예: Django, Flask) 사이에서 중개자 역할을 한다.
주요 기능은 다음과 같다:
웹 서버로부터 받은 HTTP 요청을 파이썬 애플리케이션이 이해할 수 있는 형태로 변환 파이썬 애플리케이션의 응답을 웹 서버에 전달 다중 프로세스를 통한 요청 처리로 성능 향상 Gunicorn의 특징 멀티 프로세싱: Gunicorn은 여러 워커 프로세스를 생성하여 동시에 많은 요청을 처리할 수 있다. 다양한 웹 프레임워크 지원: Django, Flask 등 대부분의 파이썬 웹 프레임워크와 호환된다. 자동 프로세스 관리: 서버 부하에 따라 워커 프로세스를 자동으로 관리한다. 유연한 설정: 다양한 설정 옵션을 통해 성능을 최적화할 수 있다. Gunicorn의 작동 방식 Gunicorn은 pre-fork 모델을 기반으로 작동한다:
...</p></div><footer class=entry-footer><span title='2024-11-30 03:37:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to gunicorn" href=https://buenhyden.github.io/posts/programming-languages/python/ecosystem--practice/libraries/web-application-server/wsgi-server/gunicorn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UWSGI</h2></header><div class=entry-content><p>UWSGI uWSGI는 파이썬 웹 애플리케이션을 위한 강력하고 유연한 애플리케이션 서버이다.
WSGI(Web Server Gateway Interface) 프로토콜을 구현하여 웹 서버와 파이썬 웹 애플리케이션 간의 표준화된 인터페이스를 제공한다.
적절한 설정과 튜닝을 통해 고성능, 안정성, 확장성을 제공하여 프로덕션 환경에서 파이썬 웹 애플리케이션을 효과적으로 운영할 수 있게 해준다.
uWSGI의 주요 특징 다양한 프로토콜 지원: HTTP, FastCGI, SCGI 등 여러 프로토콜을 지원한다. 고성능: 멀티 프로세싱과 멀티스레딩을 지원하여 높은 동시성과 성능을 제공한다. 유연성: 다양한 설정 옵션을 통해 세밀한 성능 튜닝이 가능한다. 플러그인 아키텍처: C, C++, Python 등 다양한 언어로 플러그인을 개발할 수 있어 확장성이 뛰어나다. 프로세스 관리: 마스터 프로세스가 워커 프로세스를 효율적으로 관리한다. uWSGI의 장점 높은 성능: 효율적인 리소스 관리로 높은 처리량을 제공한다. 안정성: 마스터 프로세스가 워커 프로세스를 관리하여 안정적인 운영이 가능하다. 유연성: 다양한 설정 옵션으로 다양한 환경에 적응할 수 있다. 확장성: 플러그인 아키텍처를 통해 기능을 확장할 수 있다. uWSGI의 작동 방식 웹 서버(예: Nginx)가 클라이언트로부터 요청을 받는다. 웹 서버는 이 요청을 uWSGI 서버로 전달한다. uWSGI는 요청을 파이썬 애플리케이션(예: Django, Flask)에 전달한다. 파이썬 애플리케이션이 요청을 처리하고 응답을 생성한다. uWSGI는 이 응답을 웹 서버로 반환하고, 웹 서버는 최종적으로 클라이언트에게 응답을 전송한다. uWSGI의 로드밸런싱 uWSGI는 내장된 로드 밸런싱 기능을 제공하여 여러 워커 프로세스 간에 요청을 효율적으로 분산시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-30 03:36:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to UWSGI" href=https://buenhyden.github.io/posts/programming-languages/python/ecosystem--practice/libraries/web-application-server/wsgi-server/uwsgi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>pydantic</h2></header><div class=entry-content><p>Pydantic Pydantic은 Python에서 데이터 검증과 설정 관리를 위한 강력한 라이브러리이다.
이 라이브러리는 타입 힌트를 사용하여 데이터 모델을 정의하고 자동으로 데이터를 검증한다.
주요 특징:
타입 힌트 기반 데이터 검증: Pydantic은 Python의 타입 힌트를 활용하여 데이터의 구조와 타입을 명확하게 정의한다. 자동 데이터 변환: 입력된 데이터를 적절한 타입으로 자동 변환한다. 예를 들어, 문자열로 입력된 숫자를 정수형으로 변환할 수 있다. 유효성 검사: 데이터가 정의된 규칙에 맞지 않을 경우 명확한 오류 메시지를 제공한다. JSON 직렬화 및 역직렬화: 모델 객체를 JSON으로 쉽게 변환하거나 JSON 데이터를 모델 객체로 변환할 수 있다. 사용 방법:
Pydantic을 사용하기 위한 기본적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-30 03:01:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to pydantic" href=https://buenhyden.github.io/posts/programming-languages/python/ecosystem--practice/libraries/validation/pydantic/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>