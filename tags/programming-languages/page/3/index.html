<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Polars</h2></header><div class=entry-content><p>Polars Polars는 고성능 데이터 처리를 위해 설계된 파이썬 DataFrame 라이브러리.
Rust로 작성된 핵심 엔진을 기반으로 하여 빠른 속도와 효율성을 제공한다.
주요 특징 높은 성능: Rust로 작성되어 메모리 최적화와 병렬 처리를 통해 대규모 데이터셋을 빠르게 처리한다. 직관적인 API: 사용자 친화적인 문법으로 데이터 조작 작업을 쉽게 수행할 수 있다. 지연 평가(Lazy Evaluation): 쿼리 최적화를 통해 효율적인 실행 계획을 수립한다. Apache Arrow 기반: 컬럼 기반 데이터 형식을 사용하여 벡터화된 쿼리 처리가 가능하다. GPU 지원: NVIDIA GPU를 활용한 고성능 in-memory 작업을 지원한다. 장점 속도: pandas보다 10-100배 빠른 성능을 보여준다. 메모리 효율성: pandas에 비해 2-4배 적은 RAM을 사용한다. 확장성: 대규모 데이터셋 처리에 적합하다. 병렬 처리: 여러 CPU 코어를 자동으로 활용한다. 유연한 실행 모드: 즉시 실행(eager execution)과 지연 실행(lazy execution)을 모두 지원한다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 import polars as pl # DataFrame 생성 df = pl.DataFrame({ "A": [1, 2, 3, 4, 5], "B": ["a", "b", "c", "d", "e"] }) # 데이터 필터링 filtered_df = df.filter(pl.col("A") > 2) # 그룹화 및 집계 result = df.groupby("B").agg(pl.col("A").sum()) Polars는 대규모 데이터 처리, 고성능 분석 작업, 그리고 실시간 데이터 처리가 필요한 프로젝트에 특히 적합하다.
pandas와 유사한 문법을 제공하면서도 더 나은 성능을 제공하여, 데이터 과학자들과 분석가들 사이에서 인기를 얻고 있다.
...</p></div><footer class=entry-footer><span title='2024-11-30 07:12:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;209 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polars" href=https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Numpy</h2></header><div class=entry-content><p>Numpy NumPy(Numerical Python)는 파이썬에서 과학 계산을 위한 핵심 라이브러리.
대규모 다차원 배열과 행렬 연산에 필요한 다양한 함수를 제공하며, 데이터 분석, 머신러닝, 이미지 처리 등 다양한 분야에서 널리 사용된다.
주요 특징 다차원 배열 객체(ndarray): 동일한 데이터 타입을 가진 원소들로 구성된 다차원 배열을 제공한다. 효율적인 메모리 사용: 동일한 데이터 타입을 사용하여 메모리를 효율적으로 활용한다. 빠른 연산 속도: C언어로 구현되어 있어 연산 속도가 매우 빠르다. 다양한 수학 함수: 기본적인 산술 연산부터 복잡한 선형대수 연산까지 다양한 수학 함수를 제공한다. 주요 기능 배열 생성: np.array(), np.zeros(), np.ones(), np.arange() 등의 함수로 다양한 배열을 생성할 수 있다. 배열 연산: 원소별 연산, 행렬 곱셈, 전치 등 다양한 배열 연산을 지원한다. 인덱싱과 슬라이싱: 복잡한 인덱싱과 슬라이싱 연산을 통해 배열의 특정 부분에 접근할 수 있다. 통계 함수: sum(), mean(), std(), var(), min(), max() 등 다양한 통계 함수를 제공한다. 선형 대수 연산: np.dot(), np.linalg 모듈을 통해 행렬 곱셈, 역행렬, 고유값 계산 등을 수행할 수 있다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import numpy as np # 배열 생성 arr = np.array([1, 2, 3, 4, 5]) # 기본 연산 print(arr + 1) # [2 3 4 5 6] print(arr * 2) # [2 4 6 8 10] # 통계 함수 print(np.mean(arr)) # 3.0 print(np.sum(arr)) # 15 # 다차원 배열 matrix = np.array([[1, 2, 3], [4, 5, 6]]) print(matrix.shape) # (2, 3) 응용 분야 NumPy는 데이터 분석, 머신러닝, 이미지 처리, 금융 모델링, 신호 처리, 천문학, 물리학, 기후 과학, 로보틱스 등 다양한 분야에서 활용된다.
...</p></div><footer class=entry-footer><span title='2024-11-30 07:08:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;271 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Numpy" href=https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/numpy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Celery</h2></header><div class=entry-content><p>Celery Celery는 파이썬으로 작성된 분산 작업 큐 시스템이다.
주로 웹 애플리케이션에서 비동기 작업 처리와 작업 스케줄링을 위해 사용된다.
Celery는 파이썬으로 작성된 비동기 작업 큐/작업 스케줄러이다. 분산 메시지 전달을 기반으로 동작하며, 실시간 처리와 작업 스케줄링을 지원한다.
주요 역할:
비동기 작업 처리 실시간 작업 처리 예약된 작업 실행 분산 시스템에서의 작업 관리 Celery는 복잡한 비동기 작업 처리와 분산 시스템 구축에 매우 유용한 도구이다.
웹 애플리케이션의 성능을 향상시키고 확장성을 높이는 데 큰 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-11-30 07:04:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;747 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Celery" href=https://buenhyden.github.io/posts/programming-languages/python/library/queue/celery/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>pandas</h2></header><div class=entry-content><p>Pandas 데이터를 다루기 위한 강력한 도구로, 엑셀의 스프레드시트와 비슷한 형태로 데이터를 처리할 수 있게 해준다.
가장 핵심이 되는 두 가지 데이터 구조는 Series(1차원)와 DataFrame(2차원)이다.
데이터 구조 상세 설명:
Series
Series는 1차원 배열과 같은 구조. 인덱스를 가지고 있어서 데이터에 쉽게 접근할 수 있다. 1 2 3 4 5 6 7 8 import pandas as pd s = pd.Series([1, 2, 3, 4, 5]) # 결과: # 0 1 # 1 2 # 2 3 # 3 4 # 4 5 DataFrame
DataFrame은 2차원 테이블 형태의 데이터 구조이다. 엑셀 시트처럼 행과 열로 구성되어 있다. 1 2 3 4 5 6 data = { '이름': ['김철수', '박영희', '이민수'], '나이': [25, 28, 30], '직업': ['학생', '회사원', '교사'] } df = pd.DataFrame(data) 주요 기능과 활용:
...</p></div><footer class=entry-footer><span title='2024-11-30 05:56:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pandas" href=https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/pandas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gunicorn</h2></header><div class=entry-content><p>Gunicorn Gunicorn(Green Unicorn)은 Python WSGI(Web Server Gateway Interface) HTTP 서버로, 파이썬 웹 애플리케이션을 위한 강력하고 효율적인 서버 솔루션이다.
Gunicorn은 웹 서버(예: Nginx)와 파이썬 웹 애플리케이션(예: Django, Flask) 사이에서 중개자 역할을 한다.
주요 기능은 다음과 같다:
웹 서버로부터 받은 HTTP 요청을 파이썬 애플리케이션이 이해할 수 있는 형태로 변환 파이썬 애플리케이션의 응답을 웹 서버에 전달 다중 프로세스를 통한 요청 처리로 성능 향상 Gunicorn의 특징 멀티 프로세싱: Gunicorn은 여러 워커 프로세스를 생성하여 동시에 많은 요청을 처리할 수 있다. 다양한 웹 프레임워크 지원: Django, Flask 등 대부분의 파이썬 웹 프레임워크와 호환된다. 자동 프로세스 관리: 서버 부하에 따라 워커 프로세스를 자동으로 관리한다. 유연한 설정: 다양한 설정 옵션을 통해 성능을 최적화할 수 있다. Gunicorn의 작동 방식 Gunicorn은 pre-fork 모델을 기반으로 작동한다:
...</p></div><footer class=entry-footer><span title='2024-11-30 03:37:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1449 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gunicorn" href=https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/gunicorn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UWSGI</h2></header><div class=entry-content><p>UWSGI uWSGI는 파이썬 웹 애플리케이션을 위한 강력하고 유연한 애플리케이션 서버이다.
WSGI(Web Server Gateway Interface) 프로토콜을 구현하여 웹 서버와 파이썬 웹 애플리케이션 간의 표준화된 인터페이스를 제공한다.
적절한 설정과 튜닝을 통해 고성능, 안정성, 확장성을 제공하여 프로덕션 환경에서 파이썬 웹 애플리케이션을 효과적으로 운영할 수 있게 해준다.
uWSGI의 주요 특징 다양한 프로토콜 지원: HTTP, FastCGI, SCGI 등 여러 프로토콜을 지원한다. 고성능: 멀티 프로세싱과 멀티스레딩을 지원하여 높은 동시성과 성능을 제공한다. 유연성: 다양한 설정 옵션을 통해 세밀한 성능 튜닝이 가능한다. 플러그인 아키텍처: C, C++, Python 등 다양한 언어로 플러그인을 개발할 수 있어 확장성이 뛰어나다. 프로세스 관리: 마스터 프로세스가 워커 프로세스를 효율적으로 관리한다. uWSGI의 장점 높은 성능: 효율적인 리소스 관리로 높은 처리량을 제공한다. 안정성: 마스터 프로세스가 워커 프로세스를 관리하여 안정적인 운영이 가능하다. 유연성: 다양한 설정 옵션으로 다양한 환경에 적응할 수 있다. 확장성: 플러그인 아키텍처를 통해 기능을 확장할 수 있다. uWSGI의 작동 방식 웹 서버(예: Nginx)가 클라이언트로부터 요청을 받는다. 웹 서버는 이 요청을 uWSGI 서버로 전달한다. uWSGI는 요청을 파이썬 애플리케이션(예: Django, Flask)에 전달한다. 파이썬 애플리케이션이 요청을 처리하고 응답을 생성한다. uWSGI는 이 응답을 웹 서버로 반환하고, 웹 서버는 최종적으로 클라이언트에게 응답을 전송한다. uWSGI의 로드밸런싱 uWSGI는 내장된 로드 밸런싱 기능을 제공하여 여러 워커 프로세스 간에 요청을 효율적으로 분산시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-30 03:36:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1631 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UWSGI" href=https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>pydantic</h2></header><div class=entry-content><p>Pydantic Pydantic은 Python에서 데이터 검증과 설정 관리를 위한 강력한 라이브러리이다.
이 라이브러리는 타입 힌트를 사용하여 데이터 모델을 정의하고 자동으로 데이터를 검증한다.
주요 특징:
타입 힌트 기반 데이터 검증: Pydantic은 Python의 타입 힌트를 활용하여 데이터의 구조와 타입을 명확하게 정의한다. 자동 데이터 변환: 입력된 데이터를 적절한 타입으로 자동 변환한다. 예를 들어, 문자열로 입력된 숫자를 정수형으로 변환할 수 있다. 유효성 검사: 데이터가 정의된 규칙에 맞지 않을 경우 명확한 오류 메시지를 제공한다. JSON 직렬화 및 역직렬화: 모델 객체를 JSON으로 쉽게 변환하거나 JSON 데이터를 모델 객체로 변환할 수 있다. 사용 방법:
Pydantic을 사용하기 위한 기본적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-30 03:01:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;632 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pydantic" href=https://buenhyden.github.io/posts/programming-languages/python/library/data-validation/pydantic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pytest</h2></header><div class=entry-content><p>Pytest pytest는 파이썬을 위한 강력하고 유연한 테스트 프레임워크.
단위 테스트부터 기능 테스트까지 다양한 수준의 테스트를 지원하며, 개발자들 사이에서 높은 인기를 얻고 있다.
주요 특징 간결한 문법: pytest는 파이썬의 기본 assert 문을 사용하여 테스트를 수행한다. 이로 인해 테스트 코드가 매우 간결해진다. 자동 테스트 발견: ’test_‘로 시작하는 함수나 ‘Test’로 시작하는 클래스를 자동으로 테스트 대상으로 인식한다. 풍부한 플러그인 생태계: 다양한 플러그인을 통해 기능을 확장할 수 있다.
주요 플러그인:
- pytest-cov: 코드 커버리지 측정
- pytest-mock: 목킹 기능 제공
- pytest-xdist: 병렬 테스트 실행
- pytest-django: Django 테스트 지원 상세한 실패 보고서: 테스트 실패 시 상세한 정보를 제공하여 디버깅을 용이하게 한다. 실패한 테스트의 정확한 위치 기대값과 실제값의 상세한 비교 실행 시간 및 커버리지 정보 성공/실패/스킵된 테스트 통계 매개변수화된 테스트: 여러 입력값에 대해 동일한 테스트를 반복 실행할 수 있다. 장점 간결성: unittest에 비해 더 간결한 문법을 제공한다. 유연성: 다양한 테스트 시나리오를 쉽게 구현할 수 있다. 확장성: 풍부한 플러그인 생태계를 통해 기능을 확장할 수 있다. 상세한 오류 보고: 테스트 실패 시 더 자세한 정보를 제공한다. 단점 학습 곡선: pytest만의 고유한 방식을 익혀야 한다. 기존 코드와의 호환성: 일부 기존 unittest 코드와 호환되지 않을 수 있다. 예외 테스트 pytest.raises 컨텍스트 매니저를 사용하여 예외 발생을 테스트할 수 있다.
예외의 종류뿐만 아니라 예외 메시지까지 검증할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-29 23:55:00 +0000 UTC'>November 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;760 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pytest" href=https://buenhyden.github.io/posts/programming-languages/python/testing/pytest/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Unittest</h2></header><div class=entry-content><p>Unittest unittest는 파이썬의 표준 라이브러리에 포함된 단위 테스트 프레임워크.
이 프레임워크는 소프트웨어 개발에서 개별 코드 단위의 정확성을 검증하는 데 사용된다.
주요 특징 테스트 자동화: unittest는 테스트 케이스를 자동으로 실행하고 결과를 보고한다. 테스트 독립성: 각 테스트는 독립적으로 실행되며, 다른 테스트의 결과에 영향을 받지 않는다. 테스트 픽스처: setUp()과 tearDown() 메서드를 통해 테스트 전후 환경을 설정하고 정리할 수 있다. 단언(Assertions): 다양한 assert 메서드를 제공하여 예상 결과와 실제 결과를 비교할 수 있다. 테스트 케이스 작성 unittest는 unittest.TestCase를 상속하는 클래스를 통해 테스트를 구성한다.
이러한 클래스 기반 접근방식은 다음과 같은 장점을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-11-29 23:55:00 +0000 UTC'>November 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;799 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Unittest" href=https://buenhyden.github.io/posts/programming-languages/python/testing/unittest/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Greenlet and Gevent</h2></header><div class=entry-content><p>Greenlet and Gevent Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.
Greenlet Greenlet은 Python에서 경량 코루틴을 구현한 라이브러리이다.
추가적으로 이야기 하면, Greenlet은 Python의 경량 협력적 멀티태스킹(cooperative multitasking)을 위한 기본 단위이다. 이는 마치 매우 가벼운 스레드처럼 작동하지만, 운영체제 수준의 스레드가 아닌 사용자 공간에서 실행되는 마이크로스레드이다.
주요 특징:
경량성: 일반 스레드보다 생성 비용이 매우 적다. 협력적 멀티태스킹: 명시적으로 제어권을 양보할 때만 컨텍스트 스위칭이 일어난다. 단일 OS 스레드 내 실행: 모든 greenlet은 동일한 물리적 스레드에서 실행된다. 사용 예:
...</p></div><footer class=entry-footer><span title='2024-11-29 05:33:00 +0000 UTC'>November 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;658 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greenlet and Gevent" href=https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>