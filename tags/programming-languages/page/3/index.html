<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg vs. pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/python/package-management-and-configuration/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Javascript</h2></header><div class=entry-content><p>NodeJS vs. Javascript JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.
주요 특징은 다음과 같다:
객체 기반의 스크립트 언어이다. 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 이벤트 중심의 프로그래밍이 가능하다. 웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다. 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 1 2 3 4 5 6 7 8 9 10 // JavaScript 예시 // DOM 조작 document.getElementById('myButton').addEventListener('click', function() { alert('버튼이 클릭되었습니다!'); }); // 비동기 처리 fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data));**** Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:33:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Javascript" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/runtime-environments/nodejs/nodejs-javascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import vs. Require 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/javascript-core/core-concepts/modules-and-environment/modules/import-vs-require/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript Engines</h2></header><div class=entry-content><p>Javascript Engines JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램이다.
웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.
JavaScript는 원래 인터프리터 언어로 설계되었지만, 현대의 JavaScript 엔진들은 성능 향상을 위해 다양한 최적화 기술을 사용한다.
JavaScript 엔진의 주요 역할:
JavaScript 코드를 읽고 구문 분석(파싱) 코드를 기계어 또는 중간 표현으로 변환 코드 실행 메모리 관리 (가비지 컬렉션 포함) 최적화 수행 JavaScript 엔진은 현대 웹의 핵심 구성 요소로, 웹 브라우저와 서버 측 애플리케이션 모두에서 JavaScript 코드를 실행하는 데 필수적이다. Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore와 같은 주요 엔진들은 계속해서 발전하며, 성능을 향상시키고 새로운 언어 기능을 지원하고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-24 09:46:00 +0000 UTC'>February 24, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript Engines" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/javascript-core/language-fundamentals/javascript-engines/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>select_related</h2></header><div class=entry-content><p>select_related select_related는 SQL의 JOIN 연산을 활용하여 외래 키(Foreign Key) 관계가 있는 객체를 단일 쿼리로 함께 가져오는 메서드이다.
이는 “many-to-one” 관계(ForeignKey)나 “one-to-one” 관계(OneToOneField)에서 특히 유용하다.
1 2 3 4 5 # 기본 사용법 book = Book.objects.select_related('publisher').get(id=1) # 이제 book.publisher에 접근할 때 추가 쿼리 없이 바로 접근 가능 publisher_name = book.publisher.name # 추가 데이터베이스 호출 없음 Django의 select_related는 관계형 데이터를 효율적으로 가져오기 위한 필수적인 도구이다.
올바르게 사용하면 애플리케이션의 성능을 크게 향상시킬 수 있다. 특히 ForeignKey와 OneToOneField 관계에서 N+1 쿼리 문제를 해결하는 데 탁월하다.
...</p></div><footer class=entry-footer><span title='2025-02-08 02:39:00 +0000 UTC'>February 8, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to select_related" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/python/web-framework/django/orm/queryset/optimization/select_related/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Typescript vs. Javascript</h2></header><div class=entry-content><p>Typescript vs. Javascript JavaScript와 TypeScript는 둘 다 웹 및 기타 환경에서 널리 사용되는 프로그래밍 언어이지만, 설계와 사용 목적에 있어 몇 가지 중요한 차이가 있다.
JavaScript는 인터프리터(또는 JIT 컴파일러)에 의해 실행되는 동적 타입의 스크립트 언어로, 유연성과 간편함을 제공하며 브라우저와 Node.js 등에서 기본 언어로 사용된다. TypeScript는 Microsoft에서 개발한 JavaScript의 상위 집합(superset)으로, 정적 타입 시스템과 클래스, 인터페이스, 제네릭 등 강력한 객체지향 프로그래밍(OOP) 기능을 추가하여 대규모 애플리케이션이나 엔터프라이즈 환경에서 코드의 안정성과 유지보수성을 높이는 데 목적이 있다. JavaScript JavaScript는 1995년 Brendan Eich에 의해 만들어진 웹 브라우저용 스크립트 언어이다. 원래는 웹 페이지에 상호작용을 추가하기 위해 설계되었지만, 현재는 브라우저 환경 외에도 서버 사이드(Node.js), 모바일 앱 개발(React Native), 데스크톱 애플리케이션(Electron) 등 다양한 환경에서 사용된다.
...</p></div><footer class=entry-footer><span title='2025-01-19 00:43:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Typescript vs. Javascript" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/typescript-vs-javascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying vs. Partial Application</h2></header><div class=entry-content><p>Currying vs. Partial Application 자바스크립트의 함수형 프로그래밍에서 가장 중요한 개념 중 두 가지는 커링(Currying)과 부분 적용(Partial Application)이다. 이 두 기법은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.
커링과 부분 적용은 자바스크립트의 콜백 함수를 더 효과적으로 다루기 위한 강력한 기법이다.
두 패턴 모두 함수의 재사용성을 높이고 코드를 더 모듈화하는 데 도움이 된다.
두 기법의 핵심 차이는 인자 처리 방식과 최종 함수의 구조에 있다.
커링은 항상 단일 인자 함수의 체인을 만들고, 부분 적용은 일부 인자를 고정한 새로운 함수를 만든다.
...</p></div><footer class=entry-footer><span title='2024-12-26 10:17:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying vs. Partial Application" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/javascript-core/asynchronous-programming/callback/currying-vs-partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Partial Application</h2></header><div class=entry-content><p>Partial Application 함수형 프로그래밍에서 콜백 함수를 더 효과적으로 활용하는 핵심 기법 중 하나가 부분 적용(Partial Application)이다.
부분 적용은 함수형 프로그래밍의 강력한 도구로, 함수의 재사용성과 조합성을 크게 향상시킨다.
커링과는 다른 접근 방식을 취하지만, 둘 다 함수를 더 작고 재사용 가능한 단위로 분해하는 데 도움이 된다.
부분 적용의 주요 이점:
코드 중복 감소: 공통 인자를 가진 함수 호출을 단순화한다. 의도 명확화: 특화된 함수 이름을 통해 코드의 의도를 명확히 한다. 조합성 향상: 함수를 더 작고 조합 가능한 단위로 분해한다. 유연성: 필요에 따라 어떤 인자든 부분 적용할 수 있다. 자바스크립트의 콜백 패턴과 함께 부분 적용을 사용하면, 보다 선언적이고 재사용 가능한 코드를 작성할 수 있다. 특히 이벤트 처리, API 호출, 데이터 변환 같은 영역에서 부분 적용은 코드 품질을 향상시키는 실용적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 09:54:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Partial Application" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/javascript-core/asynchronous-programming/callback/partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying</h2></header><div class=entry-content><p>Currying 커링(Currying)은 함수형 프로그래밍에서 유래한 중요한 개념으로, 여러 개의 인자를 받는 함수를 단일 인자를 받는 일련의 함수들로 변환하는 기법이다.
이 기법은 수학자이자 논리학자인 하스켈 커리(Haskell Curry)의 이름을 따서 명명되었다.
커링은 자바스크립트의 함수형 프로그래밍 패러다임에서 특히 유용하며, 함수 합성과 부분 적용을 가능하게 하는 강력한 도구이다.
커링은 자바스크립트에서 함수형 프로그래밍을 구현하는 데 중요한 기법 중 하나이다.
이 기법은 코드의 재사용성과 모듈성을 높이고, 함수 조합을 용이하게 하며, 복잡한 로직을 더 작고 관리하기 쉬운 단위로 분해하는 데 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 07:51:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/javascript-core/asynchronous-programming/callback/currying/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Tree Shaking</h2></header><div class=entry-content><p>Tree Shaking 트리 쉐이킹은 현대 자바스크립트 애플리케이션의 번들 크기를 최적화하는 중요한 기술이다.
트리 쉐이킹은 현대 웹 애플리케이션 최적화의 필수 요소가 되었다.
최적의 결과를 얻기 위한 권장 사항은 다음과 같다:
ES 모듈 사용: 모든 코드를 ESM 형식으로 작성하고 사용. 번들러 선택: Rollup 또는 Webpack과 같은 트리 쉐이킹을 지원하는 번들러를 사용. 명시적 가져오기: import * as보다 import { specificFunction }을 선호. 사이드 이펙트 관리: sideEffects 속성을 설정하고 사이드 이펙트를 최소화. 최신 라이브러리 선택: 트리 쉐이킹을 지원하는 라이브러리를 선택. 번들 분석: Bundle Analyzer를 사용하여 결과를 모니터링하고 개선. 순수 함수형 접근 방식: 가능한 한 순수 함수를 작성하고 사용. 자바스크립트 애플리케이션 최적화의 다른 측면과 마찬가지로, 트리 쉐이킹은 세심한 설계와 지속적인 개선이 필요한 분야이다. 적절하게 구현된다면 사용자 경험과 애플리케이션 성능에 상당한 개선을 가져올 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-26 07:13:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Tree Shaking" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages-and-theory/core-languages/javascript-family/tooling-and-ecosystem/module-bundlers/tree-shaking/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>