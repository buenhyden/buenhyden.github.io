<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming-Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming-Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming-Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Programming-Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 20–The Zen of Python</h2></header><div class=entry-content><p>PEP 20–The Zen of Python 파이썬의 철학과 디자인 원칙을 담고 있다.
파이썬 인터프리터에서 import this를 실행하면 볼 수 있다.
1. Beautiful is Better than Ugly. (아름다움이 추한 것보다 낫다) 코드는 보기 좋고 이해하기 쉽게 작성해야 한다.
1 2 3 4 5 6 7 8 # 아름다운 코드 names = ['Alice', 'Bob', 'Charlie'] for name in names: print(f"Hello, {name}!") # 추한 코드 x=['Alice','Bob','Charlie'] for i in range(len(x)):print("Hello, "+x[i]+"!") 2. Explicit is Better than Implicit. (명시적이 암시적인 것보다 낫다) 코드의 의도를 명확히 표현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1202 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 20–The Zen of Python" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 257–Docstring Conventions</h2></header><div class=entry-content><p>PEP 257–Docstring Conventions Python 코드의 docstring 작성에 대한 규칙과 관례를 정의한 문서
정의
모듈, 함수, 클래스, 메서드 정의의 첫 번째 문장으로 오는 문자열 리터럴로, 해당 객체의 doc 특별 속성이 된다. 작성 대상
모든 모듈, 모듈이 내보내는 모든 함수와 클래스, 공개 메서드(생성자 포함)에 docstring을 작성해야 한다. 형식
항상 """삼중 큰따옴표"""를 사용한다.
한 줄 docstring과 여러 줄 docstring 두 가지 형식이 있다. 한 줄 Docstring 명확한 경우에 사용합니다. 마침표로 끝나는 구문으로 작성합니다. 함수/메서드의 효과를 명령형으로 설명합니다. 여러 줄 Docstring 요약 줄, 빈 줄, 자세한 설명 순으로 구성됩니다. 클래스 docstring 다음에는 빈 줄을 삽입합니다. 기본 규칙 1 2 3 4 5 6 7 def function(arg1, arg2): """한 줄 설명. 여러 줄에 걸친 자세한 설명. 매개변수와 반환값 설명. """ pass 모듈, 함수, 클래스별 Docstring 내용 모듈 내보내는 클래스, 예외, 함수 등을 나열
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 257–Docstring Conventions" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 3000–Python 3000</h2></header><div class=entry-content><p>PEP 3000–Python 3000 Python 3000 개발 과정과 특징을 설명한다.
Python 3000, Python 3.0, Py3k는 모두 같은 프로젝트를 지칭한다.
PEP 번호 체계 : 3000-3099는 메타 PEP, 3100-3999는 기능 PEP 타임라인 : Python 2.6과 3.0의 동시 출시 계획을 포함. 호환성과 전환: Python 3.0은 2.x와 하위 호환성이 없다. Python 2.6은 “Py3k 경고 모드"와 일부 3.0 기능을 지원. 2to3 도구를 통해 2.x 코드를 3.0으로 변환할 수 있다. 개발 모델: 2.6과 3.0을 동시 지원하는 프로젝트를 위한 권장 개발 방법을 제시. 구현 언어: Python 3000은 C로 구현되며, Python 2 코드베이스에서 진화합니다. Python2와 Python3의 비교 문법 차이 기능 Python 2 Python 3 print문 print "Hello" print("Hello") 정수 나눗셈 5/2 → 2 5/2 → 2.5 예외 처리 except Error, e except Error as e range 리스트 반환 이터레이터 반환 문자열 포맷팅 % 연산자 중심 f-strings, format() 메서드 유니코드 표현 방식 항목 Python 2 Python 3 기본 문자열 ASCII Unicode (UTF-8) 유니코드 선언 u"문자열" 기본 지원 바이트 문자열 str bytes 인코딩 처리 명시적 처리 필요 자동 처리 국제화 지원 제한적 완전 지원 성능 차이 항목 Python 2 Python 3 실행 속도 기준 10-15% 향상 메모리 관리 GC 기본 향상된 GC 멀티스레딩 GIL 제한 GIL 개선 비동기 처리 제한적 async/await 지원 최적화 기본 향상된 최적화 메모리 사용량 차이 항목 Python 2 Python 3 기본 객체 크기 기준 20-30% 감소 문자열 처리 더 많은 메모리 최적화된 메모리 컬렉션 리스트 중심 메모리 효율적인 뷰 캐시 처리 기본 향상된 캐시 메모리 해제 덜 효율적 더 효율적 5. 파일 입출력 성능 차이 항목 Python 2 Python 3 기본 I/O 상대적 느림 15-20% 향상 텍스트 처리 ASCII 중심 유니코드 최적화 버퍼링 기본 향상된 버퍼링 비동기 I/O 제한적 완전 지원 대용량 파일 처리 제한적 효율적 처리 라이브러리 지원 차이 특징 Python 2 Python 3 표준 라이브러리 기본적인 모듈 제공 개선된 모듈 및 새로운 모듈 추가 (예: asyncio, statistics) 서드파티 라이브러리 지원 일부 레거시 라이브러리만 지원 대부분의 주요 라이브러리가 지원 (예: TensorFlow, PyTorch) 새로운 라이브러리 개발 거의 없음 활발히 진행 중 유니코드 관련 라이브러리 제한적 지원 향상된 지원 레거시 라이브러리 호환성 높음 일부 호환되지 않을 수 있음 라이브러리 업데이트 빈도 낮음 (지원 종료) 높음 (지속적인 개선) AI/ML 라이브러리 지원 제한적 광범위 웹 개발 프레임워크 일부 구버전만 지원 최신 버전 지원 (예: Django, Flask) 데이터 과학 라이브러리 제한적 지원 폭넓은 지원 (예: pandas, numpy 최신 버전) 보안 관련 라이브러리 업데이트 중단 지속적인 보안 업데이트 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;379 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3000–Python 3000" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 3333–Python Web Server Gateway Interface V1.0.1</h2></header><div class=entry-content><p>PEP 3333–Python Web Server Gateway Interface V1.0.1 Python Web Server Gateway Interface (WSGI) 버전 1.0.1을 정의한 문서.
PEP 333의 개정판으로, Python 3 지원을 개선하고 몇 가지 오랜 de facto 수정사항을 반영
PEP 3333은 PEP 333을 Python 3 시대에 맞게 업데이트한 버전이다.
주요 변경사항과 특징 Python 3 지원: 문자열 처리가 유니코드로 변경됨 environ 딕셔너리의 문자열은 str 타입이어야 함 응답 본문은 bytes 타입이어야 함 새로운 보안 고려사항: 헤더 인젝션 방지 안전한 문자열 처리 미들웨어 체이닝: 여러 미들웨어를 연결하여 요청/응답 처리 파이프라인 구성 가능 파일 핸들링: wsgi.input과 wsgi.errors를 통한 표준화된 입출력 처리 WSGI (Web Server Gateway Interface) 웹 서버와 Python 웹 어플리케이션 또는 프레임워크 간의 표준 인터페이스를 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1026 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3333–Python Web Server Gateway Interface V1.0.1" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 484–Type Hints</h2></header><div class=entry-content><p>PEP 484–Type Hints Python에 타입 힌트(Type Hints)를 도입하여 함수의 인자와 반환값에 대한 타입을 명시할 수 있도록 하는 표준을 정의
Python 3.5부터 도입됨.
코드의 가독성을 높이고 정적 타입 분석 도구가 코드를 검사할 수 있도록 돕는다.
PEP 484는 Python의 동적 타이핑 특성을 유지하면서, 타입 힌트를 통해 코드의 품질과 유지보수성을 향상시키는 것을 목표로 한다.
주요 내용 함수 주석을 통한 타입 힌트 함수 인자와 반환값에 대한 타입 정보를 제공하여 코드의 의도를 명확히 한다. 예를 들어, 문자열을 인자로 받고 문자열을 반환하는 함수는 다음과 같이 정의할 수 있다. 1 2 3 4 def greeting(name: str) -> str: return 'Hello ' + name` # `name: str`: `name` 인자는 문자열이어야 함을 나타냅니다. # `-> str`: 함수가 문자열을 반환함을 나타냅니다. 정적 타입 검사 타입 힌트는 런타임에 강제되지 않으며, 정적 분석 도구(예: mypy)를 사용하여 코드의 타입 일관성을 검사할 수 있다. 이는 코드 작성 시 오류를 미리 발견하고 수정할 수 있게 도와준다. 타입 힌트 모듈 typing 모듈을 통해 다양한 타입 힌트를 제공한다. 예를 들어, 리스트, 딕셔너리와 같은 컨테이너 타입 및 제네릭(Generic) 타입을 지원한다. 유연한 사용 타입 힌트는 선택 사항이며, Python은 여전히 동적 타이핑 언어로 남아 있다. 즉, 모든 함수에 타입 힌트를 추가할 필요는 없다. 예제 간단한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 1. 기본적인 타입 힌트 사용 def greeting(name: str) -> str: # name 파라미터는 문자열(str) 타입이어야 함을 나타냄 # -> str 은 함수가 문자열을 반환함을 나타냄 return f"Hello, {name}!" # 2. 여러 기본 타입들의 사용 def calculate_total(quantity: int, price: float) -> float: # quantity는 정수(int), price는 실수(float) 타입 # 반환값은 실수(float) 타입 return quantity * price # 3. 리스트 타입 힌트 사용 from typing import List def get_first_name(names: List[str]) -> str: # names는 문자열 리스트임을 나타냄 # List[str]은 모든 요소가 문자열인 리스트를 의미 return names[0] if names else "" # 4. 옵셔널 타입 사용 from typing import Optional def find_user(user_id: Optional[int]) -> Optional[str]: # user_id는 정수이거나 None일 수 있음을 나타냄 # 반환값도 문자열이거나 None일 수 있음 if user_id is None: return None return f"User_{user_id}" 복잡한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from typing import Dict, Tuple, Union, Callable # 5. 딕셔너리와 복합 타입 def process_user_data( user_info: Dict[str, Union[str, int]] ) -> Tuple[str, int]: # Dict[str, Union[str, int]]는 # - 키는 문자열이고 # - 값은 문자열 또는 정수인 딕셔너리를 의미 # Tuple[str, int]는 문자열과 정수로 구성된 튜플을 반환한다는 의미 name = user_info.get("name", "") age = user_info.get("age", 0) return name, age # 6. 함수 타입 힌트 def apply_operation( func: Callable[[int, int], int], x: int, y: int ) -> int: # Callable[[int, int], int]는 # - 두 개의 정수를 입력받고 # - 정수를 반환하는 함수를 의미 return func(x, y) # 7. 제네릭 타입 from typing import TypeVar, Sequence T = TypeVar('T') # 제네릭 타입 변수 정의 def first_element(sequence: Sequence[T]) -> Optional[T]: # Sequence[T]는 임의의 타입 T로 이루어진 시퀀스를 의미 # Optional[T]는 T 타입 또는 None을 반환할 수 있음을 의미 return sequence[0] if sequence else None 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;519 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 484–Type Hints" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 492–Coroutines with Async and Await Syntax</h2></header><div class=entry-content><p>PEP 492–Coroutines with Async and Await Syntax Python에 비동기 프로그래밍을 위한 async와 await 구문을 도입하여 코루틴(coroutine)을 명시적으로 정의하고 사용하는 방법을 제안한다.
Python 3.5부터 도입되었다.
기존의 제너레이터 기반 코루틴과 구분되는 네이티브 코루틴을 정의한다.
PEP 492는 비동기 프로그래밍을 더 명확하고 Pythonic하게 만들어 준다.
PEP 492의 주요 내용 네이티브 코루틴 정의 async def 키워드를 사용하여 네이티브 코루틴을 정의한다.
이는 함수가 코루틴임을 명확히 나타내며, 기존의 yield나 yield from 대신 await를 사용한다.
1 2 3 4 async def fetch_data(): """데이터를 비동기적으로 가져오는 네이티브 코루틴""" await asyncio.sleep(1) # 비동기 작업 대기 return "data" await 표현식 await 키워드는 코루틴에서 다른 코루틴이나 비동기 작업의 완료를 기다릴 때 사용된다.
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 492–Coroutines with Async and Await Syntax" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PEP 8-Style Guide for Python Code</h2></header><div class=entry-content><p>PEP8 - Style Guide for Python Code Python 코드의 스타일 가이드로, 가독성과 일관성을 높이기 위한 다양한 규칙과 권장사항을 제시한다.
중요한 점은
이 가이드라인들은 제안사항이며, 프로젝트의 일관성이 더 중요하다. 기존 코드의 스타일을 존중해야 한다. 일부 규칙은 특수한 상황에서 무시될 수 있다. 가독성이 최우선.
프로젝트별로 자체적인 스타일 가이드가 있을 경우 해당 가이드를 우선시 코드 레이아웃 (Code Layout) 들여쓰기 (Indentation) 4개의 스페이스를 사용. 연속된 줄은 괄호 안에서 수직으로 정렬하거나 hanging indent를 사용한다. 탭은 사용하지 않음. 탭과 공백은 혼용하지 않는다. 라인 길이 최대 79자 문서화 문자열(docstring)과 주석은 72자 긴 줄은 여러 줄로 나누어 작성. 줄 연결은 괄호나 백슬래시를 사용한다. 줄바꿈 연산자 앞에서 줄을 바꾸는 것이 더 가독성이 좋다. 올바른 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 괄호 안에서 수직 정렬 foo = long_function_name(var_one, var_two, var_three, var_four) # Hanging indent def long_function_name( var_one, var_two, var_three, var_four): # 함수 내용은 4칸 들여쓰기 print(parameter_1) # if문도 4칸 들여쓰기 if True: # if문 내부는 추가로 4칸 들여쓰기 print("Nested content") # 여러 줄의 리스트 my_list = [ 1, 2, 3, 4, 5, 6 ] with open('/path/to/some/file/you/want/to/read') as file_1, \ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) # 1. 괄호를 사용한 줄 나누기 long_string = ( "이것은 매우 긴 문자열이라서 " "여러 줄로 나누어 작성했습니다." ) # 2. 연산자 앞에서 줄 바꾸기 total = ( first_variable + second_variable - third_variable ) income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) # 3. 함수 인자 나누기 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 인자가 첫 줄에 있으면 안 됨 foo = long_function_name(var_one, var_two, var_three, var_four) def long_function_name( parameter_1, # 2칸만 들여씀 parameter_2, parameter_3 # 불필요하게 많이 들여씀 ): print(parameter_1) # 탭 사용 if True: print("Wrong indent") # 3칸만 들여씀 with open('/path/to/some/file/you/want/to/read') as file_1, open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) # 1. 한 줄이 너무 김 long_string = "이것은 매우 긴 문자열이라서 한 줄에 전부 작성하면 79자를 훨씬 넘어가게 되어 가독성이 떨어지게 됩니다." # 2. 잘못된 줄 나누기 total = first_variable + \ second_variable + \ third_variable income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) # 3. 잘못된 함수 인자 나누기 def long_function_name(var_one, var_two , var_three, var_four): # 쉼표가 잘못된 위치에 있음 print(var_one) 임포트 (Import) 임포트는 항상 파일의 맨 위에 작성한다. 각 임포트는 별도의 줄에 작성한다. 임포트는 다음 순서로 그룹화한다. 표준 라이브러리 관련된 서드파티 라이브러리 로컬 애플리케이션 / 라이브러리 올바른 예 1 2 3 4 5 6 7 8 9 10 11 12 13 # 1. 표준 라이브러리 import os import sys from datetime import datetime, timedelta # 2. 서드파티 라이브러리 import numpy as np import pandas as pd # 3. 로컬 애플리케이션 from myproject.models import User from myproject.utils import helper from . import localmodule 잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 # 1. 한 줄에 여러 임포트 import sys, os, datetime # 2. 잘못된 순서 from myproject.models import User import os import pandas as pd # 3. 와일드카드 임포트 from mymodule import * # 이것은 피해야 함 # 4. 불필요한 임포트 from mymodule import MyClass, MyClass # 중복 표현식과 문장의 공백 적절한 공백 사용은 코드의 가독성을 크게 향상시킨다. 일관된 공백 사용이 중요하다. 괄호, 대괄호, 중괄호 안쪽에 불필요한 공백을 넣지 않는다. 쉼표, 세미콜론, 콜론 앞에는 공백을 넣지 않는다. 올바른 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 1. 할당 연산자 x = 1 y = 2 # 2. 연산자 result = x + y * (z - 1) # 3. 쉼표 후 공백 items = [1, 2, 3, 4, 5] def func(x, y, z): pass if x == 4: print(x, y); x, y = y, x # 1. 괄호 spam(ham[1], {eggs: 2}) # 2. 딕셔너리 dict = {'key': 'value'} # 3. 리스트/튜플 list = [1, 2, 3] tuple = (1, 2, 3) 잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 1. 불일치하는 공백 x=1 y= 2 z =3 # 2. 연산자 주변 공백 누락 result=x+y*(z-1) # 3. 쉼표 후 공백 누락 items = [1,2,3,4,5] def func(x,y,z): pass if x == 4 : print(x , y) ; x , y = y , x # 1. 불필요한 공백 spam( ham[ 1 ], { eggs: 2 } ) # 2. 불일치하는 공백 dict = { 'key':'value' } dict = {'key' :'value'} # 3. 리스트/튜플의 불필요한 공백 list = [ 1,2,3 ] tuple = ( 1,2,3 ) 명명 규칙(Naming Conventions) 일관된 이름 규칙은 코드의 가독성을 높인다. 의미 있고 설명적인 이름을 사용해야 한다. 타입 규칙 예시 설명 패키지/모듈 짧은 소문자
필요시 언더스코어 utils
email_validator
data_parser 모듈은 import 시 파일명이 되므로 짧고 간단하게 작성 클래스 CapWords(Pascal Case) UserProfile
EmailValidator
DatabaseConnection 각 단어의 첫 글자를 대문자로 작성 함수/메서드 소문자 + 언더스코어
(snake_case) calculate_total()
get_user_info()
validate_email() 기능을 명확히 설명하는 동사로 시작 변수 소문자 + 언더스코어
(snake_case) user_name
total_count
items_list 데이터의 내용을 명확히 설명 상수 대문자 + 언더스코어 MAX_VALUE
DEFAULT_TIMEOUT
PI 변경되지 않는 값임을 명확히 표시 보호 속성 앞에 언더스코어 1개 _internal_name
_protected_method() 직접 접근을 권장하지 않는 내부 사용 속성 비공개 속성 앞에 언더스코어 2개 __private_name
__private_method() 클래스 외부에서 접근을 제한하는 속성 특별 메서드 앞뒤 더블 언더스코어 __init__
__str__
__len__ Python에서 특별한 의미를 가진 메서드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 1. 패키지/모듈 예시 import email_validator from data_processing import utils # 2. 클래스 예시 class UserProfile: def __init__(self, name): self.name = name class EmailValidator: def validate(self, email): pass # 3. 함수/메서드 예시 def calculate_total(items): return sum(items) def get_user_info(user_id): pass # 4. 변수 예시 first_name = "John" total_count = 0 items_list = [] # 5. 상수 예시 MAX_CONNECTIONS = 100 DEFAULT_TIMEOUT = 30 PI = 3.14159 # 6. 클래스에서의 보호/비공개 속성 예시 class Customer: def __init__(self): self._internal_id = 123 # 보호 속성 self.__private_data = "secret" # 비공개 속성 def _protected_method(self): # 보호 메서드 pass def __private_method(self): # 비공개 메서드 pass def __str__(self): # 특별 메서드 return f"Customer {self._internal_id}" 추가적인 명명 규칙 지침:
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;4642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 8-Style Guide for Python Code" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-8-style-guide-for-python-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python-Special Methods</h2></header><div class=entry-content><p>Python-Special Methods 클래스에 특별한 기능을 부여하는 특수한 메소드.
언더스코어 두 개로 둘러싸인 이름을 가지며, 파이썬 인터프리터에 의해 특정 상황에서 자동으로 호출된다.
객체 생성 및 초기화 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Example: def __new__(cls, *args, **kwargs): # 객체 생성 전에 호출되는 메서드 print("1. __new__ 호출: 객체 생성") # 실제 객체 생성 instance = super().__new__(cls) return instance def __init__(self, value): # 객체 초기화 메서드 print("2. __init__ 호출: 객체 초기화") self.value = value def __del__(self): # 객체가 소멸될 때 호출되는 메서드 print("3. __del__ 호출: 객체 소멸") # 사용 예시 obj = Example(10) # __new__와 __init__ 호출 del obj # __del__ 호출 객체 표현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): # 사용자 친화적인 문자열 표현 return f"{self.name} ({self.age}세)" def __repr__(self): # 개발자를 위한 상세한 문자열 표현 return f"Person(name='{self.name}', age={self.age})" def __format__(self, format_spec): # 형식화된 문자열 표현 if format_spec == 'brief': return f"{self.name}" return str(self) # 사용 예시 person = Person("홍길동", 30) print(str(person)) # __str__ 호출 print(repr(person)) # __repr__ 호출 print(format(person, 'brief')) # __format__ 호출 __str__와 __repr__의 차이 특징 str repr 목적 사용자 친화적 출력 개발자 친화적 출력 사용 print() 함수 디버깅, 개발 상세도 간단한 설명 상세한 정보 형식 읽기 쉬운 형식 정확한 정보 포함 연산자 오버로딩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): # + 연산자 return Vector(self.x + other.x, self.y + other.y) def __sub__(self, other): # - 연산자 return Vector(self.x - other.x, self.y - other.y) def __mul__(self, scalar): # * 연산자 return Vector(self.x * scalar, self.y * scalar) def __truediv__(self, scalar): # / 연산자 return Vector(self.x / scalar, self.y / scalar) def __floordiv__(self, scalar): # // 연산자 return Vector(self.x // scalar, self.y // scalar) def __mod__(self, scalar): # % 연산자 return Vector(self.x % scalar, self.y % scalar) def __pow__(self, power): # ** 연산자 return Vector(self.x ** power, self.y ** power) def __lshift__(self, other): # &lt;&lt; 연산자 return self.x &lt;&lt; other.x, self.y &lt;&lt; other.y def __rshift__(self, other): # >> 연산자 return self.x >> other.x, self.y >> other.y def __and__(self, other): # & 연산자 return self.x & other.x, self.y & other.y def __or__(self, other): # | 연산자 return self.x | other.x, self.y | other.y def __xor__(self, other): # ^ 연산자 return self.x ^ other.x, self.y ^ other.y v1 = Vector(1, 2) v2 = Vector(3, 4) print(v1 + v2) # 벡터 덧셈 print(v1 * 2) # 벡터 스칼라 곱 단항 연산자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Number: def __init__(self, value): self.value = value def __pos__(self): # 단항 + 연산자 return Number(+self.value) def __neg__(self): # 단항 - 연산자 return Number(-self.value) def __abs__(self): # abs() 함수 return Number(abs(self.value)) def __invert__(self): # ~ 연산자 return Number(~self.value) n = Number(5) print(abs(n).value) # 절대값 print((~n).value) # 비트 반전 비교 연산자 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Temperature: def __init__(self, celsius): self.celsius = celsius def __eq__(self, other): # == 연산자 return self.celsius == other.celsius def __ne__(self, other): # != 연산자 return self.celsius != other.celsius def __lt__(self, other): # &lt; 연산자 return self.celsius &lt; other.celsius def __le__(self, other): # &lt;= 연산자 return self.celsius &lt;= other.celsius def __gt__(self, other): # > 연산자 return self.celsius > other.celsius def __ge__(self, other): # >= 연산자 return self.celsius >= other.celsius t1 = Temperature(20) t2 = Temperature(25) print(t1 &lt; t2) # 온도 비교 컨테이너 메소드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class CustomList: def __init__(self, items): self.items = items def __len__(self): # len() 함수 return len(self.items) def __getitem__(self, index): # 인덱싱 return self.items[index] def __setitem__(self, index, value): # 인덱스로 값 설정 self.items[index] = value def __delitem__(self, index): # 인덱스로 항목 삭제 del self.items[index] def __iter__(self): # 이터레이션 return iter(self.items) def __next__(self): # 다음 항목 반환 if not self.items: raise StopIteration return self.items.pop(0) def __contains__(self, item): # in 연산자 return item in self.items cl = CustomList([1, 2, 3, 4, 5]) print(len(cl)) # 길이 print(cl[2]) # 인덱싱 print(3 in cl) # 포함 여부 속성 접근 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class DynamicAttributes: def __init__(self): self._attributes = {} def __getattr__(self, name): # 존재하지 않는 속성 접근 return self._attributes.get(name, None) def __setattr__(self, name, value): # 속성 설정 if name == '_attributes': super().__setattr__(name, value) else: self._attributes[name] = value def __delattr__(self, name): # 속성 삭제 del self._attributes[name] def __getattribute__(self, name): # 모든 속성 접근 시 호출 print(f"Accessing attribute: {name}") return super().__getattribute__(name) da = DynamicAttributes() da.new_attr = 42 print(da.new_attr) del da.new_attr 호출 가능 객체 1 2 3 4 5 6 7 class Adder: def __call__(self, x, y): # 객체를 함수처럼 호출 return x + y add = Adder() print(add(3, 4)) # 객체를 함수처럼 사용 컨텍스트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class FileManager: def __init__(self, filename): self.filename = filename def __enter__(self): # with 문 진입 시 호출 self.file = open(self.filename, 'w') return self.file def __exit__(self, exc_type, exc_value, traceback): # with 문 종료 시 호출 self.file.close() with FileManager('test.txt') as f: f.write('Hello, World!') 피클링 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pickle class Picklable: def __init__(self, value): self.value = value def __reduce__(self): # 객체의 직렬화 방법 정의 return (self.__class__, (self.value,)) obj = Picklable(42) pickled = pickle.dumps(obj) unpickled = pickle.loads(pickled) print(unpickled.value) 기타 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class CustomNumber: def __init__(self, value): self.value = value def __hash__(self): # hash() 함수 return hash(self.value) def __bool__(self): # bool() 함수 return bool(self.value) def __index__(self): # 정수형 변환 return int(self.value) cn = CustomNumber(42) print(hash(cn)) print(bool(cn)) print(list(range(cn))[0]) # __index__ 사용 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-25 23:41:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1095 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python-Special Methods" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/special-methods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python - Iterators</h2></header><div class=entry-content><p>Python - Iterators 데이터 컬렉션의 요소들을 순차적으로 접근할 수 있게 해주는 객체
이터레이터의 기능과 역할 데이터 스트림에서 한 번에 하나의 항목을 반환 현재 항목과 방문한 항목을 추적 컨테이너의 요소에 순차적으로 접근 메모리를 효율적으로 사용 이터레이터의 특징 __iter__() 및 __next__() 메서드를 구현하여 이터레이터 프로토콜을 따름 next() 함수를 사용하여 다음 요소에 접근 모든 요소를 순회한 후 StopIteration 예외 발생 지연 평가(lazy evaluation)를 지원하여 필요한 요소만 생성 활용 대용량 파일 처리 데이터베이스 쿼리 결과 처리 스트리밍 데이터 처리 메모리 효율적인 데이터 처리 실시간 데이터 생성 이터레이터의 종류 기본 이터레이터
가장 일반적인 형태의 이터레이터.
__iter__와 __next__ 메서드를 구현하여 만든다.
...</p></div><footer class=entry-footer><span title='2024-11-25 17:52:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;732 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python - Iterators" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/iterators/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Structural Pattern Matching</h2></header><div class=entry-content><p>Structural Pattern Matching Python 3.10부터 도입된 구조적 패턴 매칭(Structural Pattern Matching) 은 데이터의 구조와 값을 기반으로 코드의 흐름을 제어하는 강력한 기능이다.
이는 기존의 if-elif-else 문을 대체하거나 보완하여 코드의 가독성과 유지보수성을 향상시키는 데 유용하다.
기본 개념 및 문법 구조적 패턴 매칭은 match 문과 case 절을 사용하여 구현된다.
match 문은 주어진 표현식을 평가하고, 각 case 절은 해당 표현식의 결과와 비교할 패턴을 정의한다.
가장 먼저 일치하는 패턴의 코드 블록이 실행된다.
1 2 3 4 5 6 7 match 표현식: case 패턴1: # 패턴1과 일치할 때 실행할 코드 case 패턴2: # 패턴2와 일치할 때 실행할 코드 case _: # 어떤 패턴과도 일치하지 않을 때 실행할 코드 여기서 case _:는 와일드카드 패턴으로, 앞의 어떤 패턴과도 일치하지 않을 때 실행된다.
...</p></div><footer class=entry-footer><span title='2024-11-25 14:32:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;946 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Structural Pattern Matching" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/conditionals/structural-pattern-matching/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/programming-languages/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/programming-languages/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>