<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JSON vs. XML vs. Protobuf</h2></header><div class=entry-content><p>JSON vs. XML vs. Protobuf 데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.
세 가지 직렬화 형식은 각각 고유한 장단점이 있어 특정 사용 사례에 더 적합하다:
JSON은 웹 애플리케이션과 사람이 읽을 수 있는 인터페이스에 이상적이다. 단순성과 광범위한 지원이 특징이다. XML은 복잡한 문서와 엔터프라이즈 시스템에 적합하다. 강력한 스키마 지원과 메타데이터 처리 능력이 있다. Protobuf는 고성능 시스템과 마이크로서비스 아키텍처에 최적화되어 있다. 속도와 효율성이 중요한 경우에 탁월하다. 선택은 프로젝트 요구사항, 팀 전문성, 상호운용성 요구사항, 성능 고려사항에 따라 달라질 수 있다. 단일 프로젝트 내에서도 다양한 부분에 서로 다른 형식을 사용하는 것이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JSON vs. XML vs. Protobuf" href=https://buenhyden.github.io/posts/backend/api-design/fundamentals/json-vs-xml-vs-protobuf/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.
기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/databases/nosql/types/key-value/redis%EC%99%80-valkey/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/server-sent-events/server-sent-events-vs-webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) vs. Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) vs. Web Server Web Server와 Application Server는 모두 클라이언트 요청을 처리하고 응답을 반환하는 서버이지만, 역할과 기능에서 중요한 차이가 있다. 이 두 서버는 종종 함께 사용되며, 서로 보완적인 관계를 형성한다.
정의 및 주요 역할 Web Server 주로 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 제공하는 서버이다. HTTP 프로토콜을 기반으로 클라이언트 요청에 응답한다. 정적 리소스를 빠르게 처리하며, 동적 요청은 Application Server로 전달하는 역할도 수행한다. Application Server 동적 콘텐츠를 생성하고 비즈니스 로직을 처리하는 서버이다. 데이터베이스와 상호작용하거나 애플리케이션 로직을 실행하여 클라이언트 요청에 따라 맞춤형 데이터를 반환한다. 동적 콘텐츠를 처리하기 때문에 복잡한 트랜잭션 관리 및 비즈니스 로직 수행이 가능하다. 기능 Web Server 정적 콘텐츠 제공: HTML, CSS, 이미지 파일 등. 요청 전달: 동적 콘텐츠 요청은 Application Server로 전달. 캐싱 및 로드 밸런싱: 웹사이트 성능 최적화를 위한 기능 제공. Application Server 동적 콘텐츠 생성: 클라이언트 요청에 따라 실시간으로 데이터를 생성. 비즈니스 로직 처리: 데이터베이스와 통신하거나 복잡한 연산 수행. 트랜잭션 관리: 다중 사용자 환경에서 데이터 일관성을 유지. 사용 사례 Web Server
...</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) vs. Web Server" href=https://buenhyden.github.io/posts/backend/web-infrastructure/web-application-server/web-application-server-vs-web-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/types/event-driven-apis/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Load Shifting vs. Load Balancing</h2></header><div class=entry-content><p>Load Shifting vs. Load Balancing 네트워크와 시스템 관리에서 부하 관리는 시스템의 안정성과 효율성을 유지하는 핵심 요소이다. 특히 로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.
로드 밸런싱(Load Balancing) 로드 밸런싱은 네트워크 트래픽이나 작업 부하를 여러 서버나 리소스에 고르게 분산시키는 기술이다. 이는 주로 실시간으로 이루어지며, 시스템의 전체적인 성능과 가용성을 향상시키는 것이 목적이다.
주요 특징 목적: 시스템 성능 최적화, 가용성 향상, 응답 시간 개선 타이밍: 실시간 또는 거의 실시간으로 작동 분배 방식: 여러 리소스에 작업을 균등하게 분산 적용 사례: 웹 서버 클러스터, 데이터베이스 클러스터, 컴퓨팅 그리드 로드 밸런싱 알고리즘 라운드 로빈(Round Robin): 순차적으로 각 서버에 요청을 할당한다.
...</p></div><footer class=entry-footer><span title='2025-04-04 02:45:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Shifting vs. Load Balancing" href=https://buenhyden.github.io/posts/system-design/migration-strategies/load-shifting/load-shifting-vs-load-balancing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Telemetry vs. OpenTelemetry</h2></header><div class=entry-content><p>Telemetry vs. OpenTelemetry Telemetry와 OpenTelemetry는 모두 시스템의 상태, 성능, 동작을 관찰하고 데이터를 수집하는 데 사용되지만, 그 목적과 구현 방식에서 중요한 차이점이 있다.
Telemetry Telemetry는 일반적인 데이터 수집 및 전송 방법을 의미하며, 다양한 시스템에서 자동으로 데이터를 수집하고 분석하는 데 사용된다.
특징 목적: 원격 시스템의 데이터(메트릭, 로그, 트레이스 등)를 수집하여 성능과 상태를 분석. 범위: 모든 종류의 데이터 수집에 적용 가능 (하드웨어, 소프트웨어, IoT 등). 구현 방식: 특정 표준 없이 다양한 방식으로 데이터를 수집하고 처리. 활용 사례: 네트워크 모니터링, 애플리케이션 성능 분석, IoT 디바이스 관리 등. 장점 다양한 환경에서 데이터 수집 가능. 실시간 모니터링과 문제 탐지 지원. 단점 데이터 표준화 부족으로 도구 간 호환성 문제 발생 가능. 특정 벤더나 도구에 종속될 가능성 있음. OpenTelemetry OpenTelemetry는 Telemetry 데이터를 표준화된 방식으로 수집하고 관리하기 위한 오픈소스 프레임워크로, 특히 클라우드 네이티브 및 분산 시스템에서 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-04 01:16:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Telemetry vs. OpenTelemetry" href=https://buenhyden.github.io/posts/system-design/telemetry/telemetry-vs-opentelemetry/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/oauth/oauth-20-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/jwt-vs-oauth-20/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/backend/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>