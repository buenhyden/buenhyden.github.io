<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 캐싱 (Database Caching)</h2></header><div class=entry-content><p>데이터베이스 캐싱 (Database Caching) 데이터베이스 캐싱은 자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술.
정의와 목적 자주 액세스하는 데이터를 고속 메모리에 저장하여 빠른 검색 가능 데이터베이스 서버의 부하 감소 및 응답 시간 단축 주요 장점 성능 향상: 데이터 검색 속도 개선 서버 부하 감소: 반복적인 쿼리 처리 최소화 비용 절감: 데이터베이스 리소스 사용 효율화 사용자 경험 개선: 빠른 응답 시간 제공 작동 원리 캐시 히트: 요청 데이터가 캐시에 있어 즉시 반환 캐시 미스: 데이터가 캐시에 없어 원본 데이터베이스에서 조회 캐싱 전략 인-메모리 캐싱: RAM에 데이터 저장 (예: Redis, Memcached) 쿼리 결과 캐싱: 자주 실행되는 쿼리 결과 저장 객체 캐싱: 애플리케이션 레벨에서 객체 단위로 캐싱 주의사항 데이터 일관성 유지: 캐시와 원본 데이터 간 불일치 방지 적절한 캐시 갱신 정책 수립 필요 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 06:25:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 캐싱 (Database Caching)" href=https://buenhyden.github.io/posts/backend/performance-optimization/caching/server-side/database-caching/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프록시(Proxy)</h2></header><div class=entry-content><p>프록시(Proxy) 프록시(Proxy)는 “대리” 또는 “대신"이라는 의미를 가진 개념으로, 네트워크 환경에서 중요한 역할을 수행한다.
프록시 서버는 클라이언트의 요청을 받아 대신 서버에 접속하여 데이터를 주고받는 중개자 역할을 한다.
이 과정에서 프록시 서버는 클라이언트의 IP 주소를 숨기고, 자신의 IP 주소를 사용하여 서버와 통신한다.
프록시의 주요 기능 익명성 제공: 클라이언트의 실제 IP 주소를 숨겨 개인정보를 보호한다. 캐싱: 자주 요청되는 데이터를 저장하여 네트워크 성능을 향상시킨다. 접근 제어: 특정 웹사이트나 콘텐츠에 대한 접근을 제한할 수 있다. 로깅 및 모니터링: 네트워크 트래픽을 기록하고 분석할 수 있다. 프록시 사용의 장점 보안 강화: 클라이언트와 서버 사이의 직접적인 연결을 차단하여 보안을 향상시킨다. 성능 최적화: 캐싱을 통해 반복적인 요청에 대한 응답 속도를 높인다. 접근 제어: 조직 내 네트워크 사용을 관리하고 제한할 수 있다. 익명성: 사용자의 실제 IP 주소와 위치를 숨길 수 있다. 프록시 사용의 주의점 속도 저하: 추가적인 네트워크 홉으로 인해 약간의 지연이 발생할 수 있다. 보안 위험: 잘못 구성된 프록시는 오히려 보안 취약점이 될 수 있다. 호환성 문제: 일부 애플리케이션이나 서비스와 호환되지 않을 수 있다. 프록시의 작동 방식 사용자(클라이언트)가 웹사이트에 접속하려고 할 때, 직접 웹사이트 서버에 연결하지 않고 프록시 서버에 연결한다. 프록시 서버는 사용자의 요청을 받아 웹사이트 서버에 전달한다. 웹사이트 서버는 프록시 서버에 응답을 보낸다. 프록시 서버는 받은 응답을 다시 사용자에게 전달한다. Reverse Proxy vs. Forward-Proxy 프록시 서버는 클라이언트와 서버 간의 중개자 역할을 하는 서버로, 네트워크 아키텍처에서 중요한 구성 요소이다.
프록시 서버는 크게 포워드 프록시(Forward Proxy)와 리버스 프록시(Reverse Proxy)로 구분된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 08:47:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프록시(Proxy)" href=https://buenhyden.github.io/posts/backend/web-infrastructure/reverse-proxy/proxy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-19 07:35:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/hypermedia-style/hateoas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/platform-engineering/observability/observability-vs-monitoring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Metric</h2></header><div class=entry-content><p>Metric Metric는 시스템의 상태와 성능을 수치화하여 측정하는 중요한 관측 도구이다.
Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값이다.
예를 들어, 웹 서버의 응답 시간, CPU 사용률, 메모리 사용량 등이 Metric가 될 수 있다.
장점 효율적인 저장: 숫자 데이터는 저장 공간을 적게 차지한다. 빠른 쿼리: 시계열 데이터베이스를 사용하여 빠른 검색과 분석이 가능하다. 장기 추세 분석: 오랜 기간 동안의 데이터를 저장하고 분석할 수 있다. 시각화 용이성: 그래프나 대시보드로 쉽게 표현할 수 있다. 단점 초기 설정에 시간과 노력이 필요하다 너무 많은 Metric는 오히려 혼란을 줄 수 있다 저장 공간과 처리 리소스가 필요하다 Metric의 중요성 성능 모니터링: 시스템의 전반적인 성능을 지속적으로 모니터링할 수 있다. 문제 감지: 비정상적인 패턴이나 임계값 초과를 빠르게 감지할 수 있다. 용량 계획: 리소스 사용량 추세를 분석하여 미래의 용량을 계획할 수 있다. 최적화: 성능 병목 현상을 식별하고 최적화할 수 있는 기회를 제공한다. Metric의 구성 요소 일반적인 Metric는 다음 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metric" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/metrics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Trace</h2></header><div class=entry-content><p>Trace Trace는 분산 시스템에서 요청의 흐름을 추적하고 시각화하는 데 사용된다.
Trace는 분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것이다.
각 Trace는 하나 이상의 span으로 구성되며, 첫 번째 span은 root span이라고 한다.
Trace의 목적 분산 시스템에서의 요청 흐름 이해 성능 병목 지점 식별 서비스 간 의존성 파악 오류 및 지연의 근본 원인 분석 Trace의 구성 요소 트레이스는 다음과 같은 구성 요소들로 이루어진다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 트레이스 시작 Span rootSpan = tracer.spanBuilder("checkout-process") .setSpanKind(SpanKind.SERVER) .startSpan(); try (Scope scope = rootSpan.makeCurrent()) { // 자식 스팬 생성 Span paymentSpan = tracer.spanBuilder("process-payment") .setParent(Context.current().with(rootSpan)) .startSpan(); try { processPayment(); paymentSpan.setStatus(StatusCode.OK); } catch (Exception e) { paymentSpan.setStatus(StatusCode.ERROR, e.getMessage()); throw e; } finally { paymentSpan.end(); } } finally { rootSpan.end(); } 트레이스 구성의 핵심 요소들:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trace" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/tracing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log</h2></header><div class=entry-content><p>Log Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.
문제가 발생했을 때 무슨 일이 있었는지 추적할 수 있게 해주며, 시스템의 동작을 이해하는 데 필수적인 정보를 제공한다.
로그 구조를 설계할 때는 다음과 같은 원칙들을 고려해야 한다:
일관성(Consistency): 모든 로그 항목은 동일한 구조와 형식을 따라야 한다. 이는 로그 파싱과 분석을 용이하게 만든다. 검색 가능성(Searchability): 주요 필드들은 쉽게 검색하고 필터링할 수 있는 형태여야 한다. 확장성(Extensibility): 새로운 정보를 추가할 필요가 생겼을 때 기존 구조를 해치지 않고 확장할 수 있어야 한다. 상세도 조절(Verbosity Control): 로그 레벨을 통해 필요한 상세도를 조절할 수 있어야 한다. 로그 구조를 효과적으로 설계하면 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/logging/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend/page/9/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>