<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ACID</h2></header><div class=entry-content><p>ACID 데이터베이스 관리 시스템(DBMS)에서 ACID는 트랜잭션의 신뢰성과 일관성을 정의하는 네 가지 주요 특성.
ACID는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)의 약자
ACID의 중요성:
데이터 무결성 유지 트랜잭션의 신뢰성 보장 동시성 제어 시스템 장애 복구 비즈니스 규칙 및 관계형 무결성 강화 장점:
데이터 일관성 유지 트랜잭션 무결성 보장 내결함성 및 복구 기능 제공 동시성 제어 가능 단점:
처리 오버헤드로 인한 성능 저하 대용량 OLTP 시스템에서의 성능 문제 제한적인 잠금으로 인한 확장성 제한 Atomicity (원자성) 원자성은 트랜잭션이 단일의 불가분한 작업 단위로 취급되어야 함을 의미합니다.
...</p></div><footer class=entry-footer><span title='2024-10-24 13:10:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;741 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ACID" href=https://buenhyden.github.io/posts/databases/rdbms/sql/tracsaction/acid/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>N plus one problem</h2></header><div class=entry-content><p>N plus one problem N+1 문제는 하나의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 연관된 데이터를 조회하기 위해 N번의 추가 쿼리가 발생하는 현상을 말한다.
주로 ORM(Object-Relational Mapping) 기술을 사용할 때 발생하는 성능 관련 이슈로 데이터베이스에 불필요하게 많은 쿼리를 실행하게 되는 상황을 말한다.
발생 원인 연관 관계 매핑: 주로 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생한다. 지연 로딩(Lazy Loading): 연관된 엔티티를 실제로 사용할 때 추가적인 쿼리가 발생한다. 즉시 로딩(Eager Loading): 연관된 엔티티를 함께 조회하려 할 때 추가 쿼리가 발생할 수 있다. 문제점 성능 저하: 불필요한 데이터베이스 쿼리로 인해 애플리케이션의 성능이 크게 저하된다. 네트워크 부하: 데이터베이스와의 통신이 증가하여 네트워크 부하가 증가한다. 데이터베이스 부하: 과도한 쿼리 실행으로 데이터베이스 서버에 부담을 준다. 이러한 N+1 문제는 데이터베이스 성능에 큰 영향을 미칠 수 있으므로, 개발 초기 단계부터 인지하고 적절한 해결 방법을 적용하는 것이 중요하다.
특히 대규모 애플리케이션에서는 이 문제를 해결하지 않으면 심각한 성능 저하를 경험할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 11:21:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;475 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to N plus one problem" href=https://buenhyden.github.io/posts/databases/more-about-databases/n-plus-one-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로시저 (Procedure)</h2></header><div class=entry-content><p>프로시저 (Procedure) 데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합으로,
자주 사용하는 SQL 명령어들을 하나의 작은 프로그램으로 미리 작성해두고 필요할 때 호출하여 사용하는 것이다.
SQL Server에서의 프로시저 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 주문 처리를 위한 저장 프로시저 생성 CREATE PROCEDURE ProcessOrder @OrderID int, @CustomerID int, @TotalAmount decimal(10,2) AS BEGIN -- 트랜잭션 시작 BEGIN TRANSACTION TRY -- 주문 정보 입력 INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES (@OrderID, @CustomerID, GETDATE(), @TotalAmount) -- 재고 수량 업데이트 UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductID IN ( SELECT ProductID FROM OrderDetails WHERE OrderID = @OrderID ) -- 고객 포인트 업데이트 UPDATE Customers SET Points = Points + (@TotalAmount * 0.01) WHERE CustomerID = @CustomerID -- 트랜잭션 완료 COMMIT TRANSACTION CATCH -- 오류 발생 시 롤백 ROLLBACK TRANSACTION -- 오류 정보 반환 SELECT ERROR_MESSAGE() AS ErrorMessage END END -- 프로시저 사용 예시 EXEC ProcessOrder @OrderID = 1001, @CustomerID = 500, @TotalAmount = 150000 프로시저의 주요 특징과 장점 성능 최적화
프로시저는 최초 실행 시 컴파일되어 캐시에 저장되므로, 반복 실행 시 더 빠른 성능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:05:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;715 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로시저 (Procedure)" href=https://buenhyden.github.io/posts/databases/rdbms/procedure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>keyword</h2></header><div class=entry-content><p>Keyword SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 키워드를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.
데이터 조회 (Query) 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- SELECT: 데이터를 조회하는 기본 키워드 -- 지정된 컬럼의 데이터를 결과셋으로 반환 SELECT employee_id, first_name, salary FROM employees; -- FROM: 데이터를 가져올 테이블을 지정 -- 여러 테이블을 콤마로 구분하거나 JOIN을 사용할 수 있음 SELECT * FROM employees, departments; -- DISTINCT: 결과에서 중복된 행을 제거하는 데 사용 -- 기본 DISTINCT 사용 -- 부서별 unique한 직무 목록 조회 SELECT DISTINCT job_id FROM employees; -- 여러 컬럼에 DISTINCT 적용 -- 부서와 직무의 unique한 조합 조회 SELECT DISTINCT department_id, job_id FROM employees; -- COUNT와 함께 사용 -- 회사에 존재하는 직무 개수 조회 SELECT COUNT(DISTINCT job_id) as unique_jobs FROM employees; -- GROUP BY와 함께 사용 SELECT department_id, COUNT(DISTINCT job_id) as job_types FROM employees GROUP BY department_id; 결과 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- LIMIT - 반환되는 결과의 최대 행 수를 제한합니다. SELECT * FROM employees LIMIT 10 -- 상위 10개 행만 반환 -- OFFSET - 결과의 시작 위치를 지정합니다. LIMIT와 함께 자주 사용됩니다. SELECT * FROM employees LIMIT 10 OFFSET 20 -- 21번째부터 30번째 행을 반환 -- FETCH - SQL 표준의 LIMIT와 유사한 기능을 합니다. SELECT * FROM employees FETCH FIRST 10 ROWS ONLY -- 페이지당 10개 항목, 3번째 페이지 조회 SELECT * FROM products ORDER BY name LIMIT 10 OFFSET 20; -- (페이지 번호 - 1) * 페이지 크기 = OFFSET 조건 연산자 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- WHERE: 조건절을 지정하여 특정 조건을 만족하는 데이터만 조회 -- AND, OR을 사용하여 여러 조건 조합 가능 SELECT * FROM employees WHERE salary > 50000 AND department_id = 10; -- IN: 값 목록 중 포함 여부 -- BETWEEN: 범위 조건 -- LIKE: 패턴 매칭 -- IS NULL: NULL 값 확인 SELECT * FROM employees WHERE department_id IN (10, 20, 30) AND salary BETWEEN 40000 AND 60000 AND first_name LIKE '김%' AND manager_id IS NOT NULL; -- CASE - 조건에 따라 다른 값을 반환합니다. -- WHEN - CASE 문에서 조건을 지정합니다. -- THEN - 조건이 참일 때 반환할 값을 지정합니다. -- ELSE - 모든 조건이 거짓일 때 반환할 값을 지정합니다. SELECT name, CASE WHEN age &lt; 20 THEN 'Young' WHEN age &lt; 60 THEN 'Adult' ELSE 'Senior' END as age_group FROM users; 정렬과 그룹화 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- GROUP BY: 지정된 컬럼을 기준으로 데이터를 그룹화 -- 주로 집계 함수와 함께 사용 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; -- ORDER BY: 결과를 정렬 -- ASC(오름차순), DESC(내림차순) 지정 가능 SELECT * FROM employees ORDER BY salary DESC, first_name ASC; -- HAVING: GROUP BY로 그룹화된 데이터에 대한 조건 지정 -- WHERE는 개별 행에 대한 조건, HAVING은 그룹에 대한 조건 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000; 조인(Join) 관련 키워드 JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. JOIN을 사용하면 여러 테이블의 데이터를 하나의 결과 집합으로 결합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 07:56:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3111 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to keyword" href=https://buenhyden.github.io/posts/databases/rdbms/sql/syntax/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ORM(Object-Relational Mapping)</h2></header><div class=entry-content><p>ORM(Object-Relational Mapping) 객체 지향 프로그래밍 언어와 관계형 데이터베이스 사이의 불일치를 해결하기 위한 기술
특징:
객체와 데이터베이스 테이블 간의 매핑 SQL 쿼리 대신 객체 지향적 방식으로 데이터베이스 조작 데이터베이스 독립성 제공 장점:
직관적이고 가독성 좋은 코드 작성 가능 생산성 향상: 개발자가 비즈니스 로직에 집중 가능 재사용성과 유지보수성 증가 데이터베이스 종속성 감소 단점:
성능 저하 가능성: 복잡한 쿼리의 경우 최적화가 어려울 수 있음 학습 곡선: ORM 사용법을 익히는 데 시간이 필요 복잡한 쿼리 처리의 한계: 매우 복잡한 쿼리는 직접 SQL 작성이 필요할 수 있음 ORM과 raw query 사이에는 성능 차이가 존재한다.
일반적으로 raw SQL이 ORM보다 더 나은 성능을 보인다.
주요 차이점은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-10-24 03:42:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;206 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ORM(Object-Relational Mapping)" href=https://buenhyden.github.io/til/2024/10/24/orm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cardinality</h2></header><div class=entry-content><p>Cardinality Cardinality는 데이터베이스 분야에서 주로 두 가지 의미로 사용된다.
테이블 간의 관계에서의 Cardinality
이는 두 엔티티 간의 최대 연관성을 나타낸다.
주요 유형은 다음과 같습니다:
1:1 (일대일) 관계: 예를 들어, 사원과 사원증의 관계 1:N (일대다) 관계: 예를 들어, 교수와 학생의 관계 N:M (다대다) 관계: 예를 들어, 학생과 강좌의 관계 컬럼에 있는 고유한 값의 Cardinality
이는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.
Cardinality의 정도에 따라 다음과 같이 분류할 수 있다:
높은 Cardinality: 주민등록번호, 이메일 주소와 같이 대부분의 값이 고유한 경우 중간 Cardinality: 우편번호, 도시 이름과 같이 일부 값이 고유하지만 많은 값이 반복되는 경우 낮은 Cardinality: 성별, 상태 코드와 같이 적은 수의 고유 값을 포함하는 경우 데이터베이스 성능에 여러 가지 중요한 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2024-10-22 15:08:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;409 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cardinality" href=https://buenhyden.github.io/posts/databases/rdbms/sql/cardinality/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>분산 쿼리 (distributed query)</h2></header><div class=entry-content><p>분산 쿼리 (distributed query) 여러 노드에 분산된 데이터를 대상으로 쿼리를 실행하고 결과를 얻는 과정.
분산 쿼리 처리의 핵심 단계:
쿼리 분석 및 최적화
사용자가 쿼리를 요청하면, 시스템은 먼저 전체 데이터베이스 시스템에서 가장 효율적인 실행 계획을 수립한다.
이 과정에서 다음과 같은 요소들을 고려한다:
데이터의 물리적 위치 네트워크 대역폭과 지연 시간 각 노드의 처리 능력 데이터 전송 비용
예를 들어, 다음과 같은 쿼리가 있다고 가정해보면, 1 2 3 4 SELECT customers.name, orders.order_date FROM customers JOIN orders ON customers.id = orders.customer_id WHERE orders.amount > 1000; 이 쿼리가 서울과 부산에 분산된 데이터베이스에서 실행된다면, 시스템은 다음과 같은 실행 계획을 수립할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-22 09:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;397 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 쿼리 (distributed query)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/distributed-database/distributed-query/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>분산 트랜잭션 (Distributed transaction)</h2></header><div class=entry-content><p>분산 트랜잭션 (Distributed transaction) 분산 트랜잭션은 두 개 이상의 데이터 저장소(특히 데이터베이스)에 걸쳐 수행되는 일련의 데이터 작업이다.
이는 일반적으로 네트워크로 연결된 별도의 노드에서 조정되며, 단일 서버의 여러 데이터베이스에 걸쳐 있을 수도 있다.
특징:
ACID 속성 준수: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장한다. 일관성 유지: 모든 분산 데이터베이스가 최신 정보로 동일하게 업데이트되어야 한다. 종료 보장: 분산 트랜잭션은 완전히 실행되거나 전혀 실행되지 않아야 한다. 장점:
데이터 일관성 보장 복잡한 비즈니스 프로세스 지원 시스템 신뢰성 향상 단점:
...</p></div><footer class=entry-footer><span title='2024-10-22 09:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;637 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 트랜잭션 (Distributed transaction)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/distributed-database/distributed-transaction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링(Database Clustering)</h2></header><div class=entry-content><p>데이터베이스 클러스터링(Database Clustering) 하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술.
이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다..
데이터베이스 클러스터링(Database Clustering)은 하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술이다. 이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다.
클러스터링의 목적 고가용성(High Availability) 확보: 하나의 서버가 실패하더라도 다른 서버가 작업을 계속할 수 있어 서비스 중단을 최소화한다. 부하 분산(Load Balancing): 여러 서버로 작업을 분산시켜 전체적인 성능을 향상시킵니다[3]. 확장성(Scalability) 개선: 필요에 따라 서버를 추가하여 시스템의 처리 능력을 증가시킬 수 있습니다[2]. 구성 방식:
데이터베이스 클러스터링은 주로 두 가지 방식으로 구성된다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링(Database Clustering)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/distributed-database/database-clustering/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>샤딩 (sharding)</h2></header><div class=entry-content><p>샤딩 (sharding) 대규모 데이터베이스 시스템에서 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 기술.
각각의 분할된 데이터 조각을 ‘샤드(shard)‘라고 부른다.
이 기술은 데이터베이스의 성능, 확장성, 가용성을 향상시키는 데 중요한 역할을 한다.
예를 들어 전자상거래 사이트의 사용자 데이터를 지역별로 나누어 관리한다고 가정해보자.
서울 지역 사용자의 데이터는 샤드 A에, 부산 지역 사용자의 데이터는 샤드 B에 저장하는 식. 이렇게 하면 각 지역의 서버가 해당 지역 사용자의 데이터만 처리하면 되므로 시스템 부하를 분산할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;655 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 샤딩 (sharding)" href=https://buenhyden.github.io/posts/databases/rdbms/sharding/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>