<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Timestamp-Checked</h2></header><div class=entry-content><p>Timestamp-Checked Timestamp-Checked 방식은 동시성 제어를 위한 중요한 기법 중 하나로, 주로 낙관적 동시성 제어(Optimistic Concurrency Control)의 맥락에서 사용된다.
기본 원리 타임스탬프 할당: 각 트랜잭션에 고유한 타임스탬프를 부여한다. 이는 주로 트랜잭션이 시작될 때 시스템 시간이나 논리적 카운터를 사용하여 생성된다. 읽기-검증-쓰기 단계: 트랜잭션은 다음 세 단계로 실행된다. 읽기 단계: 데이터를 읽고 로컬에서 작업을 수행한다. 검증 단계: 다른 트랜잭션과의 충돌을 검사한다. 쓰기 단계: 충돌이 없다면 변경사항을 데이터베이스에 반영한다. 충돌 감지: 트랜잭션이 커밋하려 할 때, 자신이 읽은 데이터가 다른 트랜잭션에 의해 변경되었는지 확인한다. 작동 방식 각 데이터 항목에는 두 가지 타임스탬프가 유지된다: 읽기 타임스탬프(R-timestamp): 해당 데이터를 성공적으로 읽은 트랜잭션 중 가장 큰 타임스탬프 쓰기 타임스탬프(W-timestamp): 해당 데이터를 성공적으로 수정한 트랜잭션 중 가장 큰 타임스탬프 트랜잭션이 데이터를 읽거나 쓰려고 할 때, 다음과 같은 규칙이 적용된다: 읽기 연산: 트랜잭션의 타임스탬프가 데이터의 쓰기 타임스탬프보다 작으면 연산이 거부되고 트랜잭션은 롤백된다. 쓰기 연산: 트랜잭션의 타임스탬프가 데이터의 읽기 또는 쓰기 타임스탬프보다 작으면 연산이 거부되고 트랜잭션은 롤백된다. 장점 교착 상태(Deadlock) 방지: 락을 사용하지 않기 때문에 교착 상태가 발생하지 않는다. 대기 시간 감소: 트랜잭션이 다른 트랜잭션을 기다리지 않고 바로 실행된다. 높은 동시성: 여러 트랜잭션이 동시에 실행될 수 있어 시스템의 처리량이 향상된다. 단점 롤백 가능성 증가: 충돌이 감지되면 트랜잭션이 롤백되어야 하므로, 시스템 부하가 높을 때 롤백 빈도가 증가할 수 있다. 연쇄 롤백: 하나의 트랜잭션 롤백이 다른 트랜잭션의 롤백을 유발할 수 있다. 오버헤드: 각 데이터 항목에 대해 타임스탬프를 유지하고 관리해야 하므로 추가적인 저장 공간과 처리 시간이 필요하다. Timestamp-Checked 방식은 특히 읽기 작업이 많고 쓰기 충돌이 적은 환경에서 효과적이다. 그러나 높은 동시성 환경에서는 롤백으로 인한 성능 저하를 주의해야 한다. 따라서 시스템의 특성과 요구사항을 고려하여 적절한 동시성 제어 방식을 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2025-02-26 11:58:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Timestamp-Checked" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/handling-crud-operations/timestamp-checked/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Caching Strategies</h2></header><div class=entry-content><p>Caching Strategies 캐싱은 API 설계에서 성능을 최적화하는 핵심 전략이다. 자주 요청되는 데이터를 임시 저장소에 저장함으로써 반복적인 계산, 데이터베이스 쿼리, 네트워크 요청을 줄이고 응답 시간을 대폭 향상시킬 수 있다.
API 캐싱은 현대 웹 애플리케이션과 분산 시스템의 성능, 확장성, 사용자 경험을 개선하는 필수적인 전략이다.
적절히 구현된 캐싱 전략은 다음과 같은 여러 이점을 제공한다:
응답 시간 단축: 사용자에게 더 빠른 API 응답 제공 백엔드 부하 감소: 서버와 데이터베이스의 리소스 사용 최적화 비용 효율성: 인프라 요구 사항 및 대역폭 비용 절감 확장성 향상: 기존 리소스로 더 많은 사용자와 요청 처리 안정성 개선: 일시적인 장애 상황에서도 서비스 가용성 유지 그러나 API 캐싱은 단순히 기술적 구현 이상의 것이다. 효과적인 캐싱 전략은 데이터의 특성, 사용자 요구사항, 비즈니스 우선순위를 철저히 이해하고 이를 기반으로 설계되어야 한다. 데이터의 신선도, 캐시 적중률, 리소스 사용, 구현 복잡성 간의 균형을 맞추는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-02-13 01:30:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Strategies" href=https://buenhyden.github.io/posts/backend/api-design/api-performance/caching-strategies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 7519</h2></header><div class=entry-content><p>RFC 7519 RFC 7519는 JSON Web Token(JWT)에 대한 공식 인터넷 표준 문서이다.
2015년 5월에 Internet Engineering Task Force(IETF)에 의해 발행된 이 문서는 JWT의 구조, 형식, 서명 방법, 암호화 방법 등을 상세히 정의하고 있다. JWT는 당사자 간에 안전하게 정보를 전송하기 위한 간결하고 자체 포함적인 방법을 제공하는 개방형 표준이다.
JWT는 현대 웹 애플리케이션과 마이크로서비스 아키텍처에서 인증 및 정보 교환을 위한 핵심 기술로 자리 잡았다. 특히 Single Sign-On(SSO), API 인증, 정보의 안전한 전송 등 다양한 사용 사례에서 널리 활용되고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-06 03:33:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 7519" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/rfc-7519/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Personal Identifiable Information (PII)</h2></header><div class=entry-content><p>Personal Identifiable Information (PII) 개인 식별 정보(Personal Identifiable Information, PII)는 개인의 신원을 식별하거나 추적하는 데 사용될 수 있는 정보를 의미한다. 디지털 시대의 도래와 함께 PII의 중요성과 그에 대한 보호 필요성이 크게 증가했다.
PII의 개념 및 정의 정의 개인 식별 정보(PII)는 단독으로 또는 다른 정보와 결합하여 특정 개인을 식별, 연락, 위치 파악할 수 있게 하는 정보이다. 다양한 기관과 법률에 따라 PII의 정확한 정의는 다소 차이가 있을 수 있으나, 기본적인 개념은 동일하다.
...</p></div><footer class=entry-footer><span title='2025-02-02 03:32:00 +0000 UTC'>February 2, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Personal Identifiable Information (PII)" href=https://buenhyden.github.io/posts/backend/api-design/standards-and-compliance/pii/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Short Polling</h2></header><div class=entry-content><p>Short Polling Short polling은 클라이언트와 서버 간의 실시간에 가까운 통신을 구현하기 위한 기본적인 기술이다.
Short polling은 실시간 업데이트가 필요하지만 진정한 실시간성이 중요하지 않은 애플리케이션에서 구현이 간단하고 호환성이 좋은 솔루션이다. 그러나 사용자가 많아지거나 지연 시간이 중요한 애플리케이션에서는 Long Polling, SSE, WebSockets 같은 더 효율적인 기술의 사용을 고려해야 한다.
Short Polling의 개념 Short polling은 클라이언트가 주기적으로 서버에 HTTP 요청을 보내 새로운 데이터가 있는지 확인하는 방식이다. 클라이언트는 정해진 시간 간격으로 서버에 요청을 보내고, 서버는 그 순간 가지고 있는, 클라이언트가 아직 받지 않은 데이터를 응답한다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:45:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Short Polling" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/polling/types/short-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Long Polling</h2></header><div class=entry-content><p>Long Polling Long polling은 전통적인 short polling의 한계를 극복하기 위해 발전된 웹 통신 기법으로, 실시간에 가까운 데이터 전송을 가능하게 한다. 이 기술은 특히 웹소켓(WebSocket)이 등장하기 전에 실시간 웹 애플리케이션 구현에 널리 사용되었다.
Long polling은 WebSockets의 대중화 이전에 실시간 웹 애플리케이션의 핵심 기술이었으며, 오늘날에도 특정 상황에서 유용한 접근 방식이다. 특히 WebSockets 지원이 제한된 환경이나, 단순한 실시간 요구사항을 가진 애플리케이션에서 여전히 가치 있는 솔루션이다.
최신 웹 애플리케이션에서는 WebSockets가 선호되는 경향이 있지만, Long polling은 폴백(fallback) 메커니즘으로 구현되어 WebSockets를 지원하지 않는 환경에서도 실시간에 가까운 경험을 제공할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:44:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Long Polling" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/polling/types/long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 9457</h2></header><div class=entry-content><p>RFC 9457 RFC 9457은 그 후속 버전으로, HTTP API의 오류 응답을 구조화된 형식으로 전달하기 위한 표준이다.
이 문서는 RFC 7807을 대체하며, 이전 버전에서의 경험과 피드백을 반영하여 몇 가지 중요한 개선사항을 도입했다.
RFC 9457의 주요 개선사항 RFC 9457은 RFC 7807을 기반으로 다음과 같은 주요 개선점을 포함하고 있다.
문제 유형(type) 필드의 명확화
기존: type 필드는 문제의 유형을 식별하는 URI로 사용되었지만, 그 사용 방식이 모호할 수 있다. 개선: type 필드의 사용을 명확히 정의하고, 공용 레지스트리를 통해 표준화된 문제 유형을 관리하도록 권장하고 있다. 여러 문제의 표현 지원
...</p></div><footer class=entry-footer><span title='2024-12-15 14:25:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 9457" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/error-handling/rfc-9457/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 7807</h2></header><div class=entry-content><p>RFC 7807: Problem Details for HTTP APIs RFC 7807은 HTTP API에서 오류 상황을 일관되고 기계가 처리하기 쉬운 방식으로 전달하기 위한 표준이다. 이 규격은 “Problem Details for HTTP APIs"라는 제목으로 2016년 3월에 공식 발표되었으며, HTTP API에서 발생한 오류 상황을 구조화된 JSON 또는 XML 형식으로 표현하는 방식을 정의한다.
발표: 2016년 3월
저자: Mark Nottingham 외
상태: Proposed Standard (표준화 단계의 공식 규격)
RFC 7807의 배경과 목적 HTTP API는 다양한 클라이언트와 통신하며, 여러 오류 상황에 직면한다. 전통적으로 각 API는 자체적인 오류 응답 형식을 정의했는데, 이로 인해 클라이언트 개발자는 API마다 다른 오류 처리 로직을 구현해야 했다.
...</p></div><footer class=entry-footer><span title='2024-12-15 14:24:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 7807" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/error-handling/rfc-7807/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Portainer</h2></header><div class=entry-content><p>Portainer란? 컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구
개요 Docker, Kubernetes 등 다양한 컨테이너 플랫폼을 지원하는 범용 컨테이너 관리 솔루션 직관적인 웹 인터페이스를 통해 컨테이너 환경의 복잡성을 단순화 100만 명 이상의 사용자와 30,000개 이상의 GitHub 스타를 보유한 인기 있는 도구 주요 특징과 기능 컨테이너 관리: 컨테이너의 배포, 시작, 중지, 로그 확인 등을 GUI로 수행 스택 배포: Docker Compose를 사용한 멀티 컨테이너 애플리케이션 배포 지원 볼륨 및 네트워크 관리: 데이터 저장소와 네트워크 구성 관리 이미지 관리: Docker 레지스트리 연동 및 이미지 관리 리소스 모니터링: CPU, 메모리 사용량 등 컨테이너 성능 모니터링 템플릿: 미리 정의된 애플리케이션 템플릿을 통한 간편한 배포 장점 사용 편의성: 명령줄 지식 없이도 컨테이너 관리 가능 중앙 집중식 관리: 여러 Docker 환경을 단일 인터페이스에서 관리 보안 강화: 사용자 및 팀 단위의 접근 제어 기능 제공 확장성: 소규모 프로젝트부터 대규모 엔터프라이즈 환경까지 지원 버전 Community Edition (CE): 무료 오픈소스 버전 Business Edition (BE): 기업용 고급 기능(보안, 감사 등) 제공 버전 Portainer 설치 Host간 볼륨 매칭을 위한 디렉토리 생성 1 mkdir -p /kubernetes/portainer_data Portainerdmf docker run 명령어를 통해 docker에 설치
위에서 생성한 폴더와 마운트 1 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /kubernetes/portainer_data:/data portainer/portainer-ce:latest Portainer 로그인
웹브라우저 Portainer 서버(예: http://서버IP:9000)에 접근
[처음 접속시]
username과 password 입력
Source: hyunyoun
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Portainer" href=https://buenhyden.github.io/posts/devops/virtualization/containerization/tools/portainer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VMware</h2></header><div class=entry-content><p>VMware 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구
회사 및 라이선스:
VMware, Inc.에서 개발 대부분 유료 소프트웨어이며, 일부 제품(VMware Workstation Player)만 개인용으로 무료 제공 성능 및 기능:
일반적으로 성능이 우수하며, 최적화된 자원 관리 제공 고급 기능(스냅샷, 클론, 3D 가속, 암호화된 VM 등) 지원 vSphere를 통한 고급 네트워크 기능 제공 호환성:
Windows, macOS (Fusion), Linux 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
직관적이고 사용하기 쉬운 인터페이스 제공 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 12:55:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VMware" href=https://buenhyden.github.io/posts/devops/virtualization/tools/vmware/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>