<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ABAC</h2></header><div class=entry-content><p>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC) ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.
이를 통해 매우 세분화되고 유연한 접근 제어가 가능하다.
의료, 금융, 정부 등 복잡한 보안 요구사항을 가진 분야에서 유용하게 활용될 수 있다.
주요 특징 유연성: 다양한 속성 조합을 통해 복잡한 접근 제어 정책을 수용할 수 있다. 세분화: 사용자 역할뿐만 아니라 다양한 속성을 고려하여 더 정교한 접근 제어가 가능하다. 동적 정책: 실시간 속성 변화에 따라 접근 제어 결정을 동적으로 수행할 수 있다. 확장성: 새로운 속성을 쉽게 추가하여 정책을 확장할 수 있다. ABAC의 주요 구성 요소 속성: 주체, 객체, 환경 조건에 대한 특성을 정의한다. 주체(Subject) 속성 사용자 ID, 이름, 직급, 부서, 보안 등급 근속 연수, 자격증, 교육 이수 여부 소속 조직, 프로젝트 참여 이력 객체(Object/Resource) 속성 데이터 분류, 보안 레벨 소유자, 작성일, 만료일 프로젝트 코드, 부서 코드 데이터 타입, 크기, 형식 행동(Action) 속성 읽기, 쓰기, 삭제, 수정 승인, 거부, 이관 다운로드, 공유, 인쇄 환경(Environment) 속성 접근 시간, 위치 네트워크 종류(내부/외부) 디바이스 종류, 보안 상태 현재 위험 수준 정책 모델: 속성들의 조합으로 접근 제어 규칙을 정의한다. 아키텍처 모델: ABAC 시스템의 구현 방식을 정의한다. ABAC의 장점 높은 유연성과 세분화된 접근 제어 가능 동적이고 컨텍스트 인식적인 정책 적용 가능 새로운 사용자나 리소스에 대해 개별 권한 설정 없이 속성만으로 접근 제어 가능 ABAC의 단점 구현 및 관리의 복잡성 성능 영향: 많은 속성을 평가해야 하므로 처리 시간이 길어질 수 있음 정책 설계의 어려움: 복잡한 속성 조합으로 인한 예기치 않은 결과 발생 가능성 모범 사례 정책 설계
...</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ABAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/abac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RBAC</h2></header><div class=entry-content><p>규칙 기반 접근 제어(Rule-Based Access Control, RBAC) RBAC는 “만약 ~라면 ~할 수 있다"와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다.
각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.
클라우드 환경, 마이크로서비스 아키텍처, IoT 시스템 등 동적이고 복잡한 환경에서 특히 유용하며, 보안 요구사항이 높고 빠르게 변화하는 조직에 적합하다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Rule { constructor(condition, consequence) { // 규칙의 조건부(if)와 결과부(then)를 정의합니다 this.condition = condition; this.consequence = consequence; } evaluate(context) { // 주어진 컨텍스트에 대해 규칙을 평가합니다 if (this.condition(context)) { return this.consequence; } return null; } } class RuleEngine { constructor() { this.rules = []; } addRule(rule) { // 새로운 규칙을 규칙 엔진에 추가합니다 this.rules.push(rule); } evaluateAccess(context) { // 모든 규칙을 순차적으로 평가합니다 for (const rule of this.rules) { const result = rule.evaluate(context); if (result !== null) { return result; } } // 기본적으로는 접근을 거부합니다 return false; } } 주요 특징 규칙 기반 결정: 사용자의 속성, 리소스의 특성, 환경 조건 등을 고려한 규칙을 설정하여 접근 권한을 결정한다. 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 동적 평가: 접근 요청 시 실시간으로 규칙을 평가하여 결정을 내린다. 중앙 집중식 관리: 규칙을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 규칙 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 투명성: 규칙이 명시적으로 정의되어 있어 접근 제어 결정의 이유를 쉽게 이해할 수 있다. 단점 복잡성: 규칙이 많아지면 관리가 복잡해질 수 있다. 성능 영향: 많은 규칙을 평가해야 할 경우 처리 시간이 길어질 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RBAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/rbac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Payment Card Industry Data Security Standard (PCI DSS)</h2></header><div class=entry-content><p>Payment Card Industry Data Security Standard (PCI DSS) PCI DSS(Payment Card Industry Data Security Standard)는 신용카드 결제 과정에서 카드 소유자의 데이터를 안전하게 보호하기 위해 주요 글로벌 카드 브랜드(Visa, MasterCard, American Express, Discover, JCB)가 공동으로 제정한 국제 보안 표준이다.
이 표준은 카드 정보의 저장, 처리, 전송을 수행하는 모든 조직이 준수해야 하며, 이를 통해 카드 결제 산업의 데이터 보안을 강화하고 사기 및 데이터 유출을 방지하는 것을 목표로 한다.
2025년 3월 기준 PCI DSS v4.0은 기존 버전 대비 64개 신규 요구사항을 추가했으며, 특히 이메일 기반 공격 방지를 위한 DMARC 정책과 API 보안 강화 조치가 주목받고 있다.
조직들은 연간 1회 이상의 전체 시스템 진단과 분기별 외부 취약점 스캔을 통해 규정 준수를 유지해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-27 13:03:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Payment Card Industry Data Security Standard (PCI DSS)" href=https://buenhyden.github.io/posts/backend/api-design/standards-and-compliance/pci-dss/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h2></header><div class=entry-content><p>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.
기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성
• 우수한 확장성
• 효율적인 로드밸런싱
• 실시간 데이터 동기화 • 구현이 상대적으로 간단
• 비용 효율적
• 지리적 분산 용이
• 읽기 성능 향상 단점 • 구현 비용이 높음
• 복잡한 구성
• 네트워크 대역폭 필요
• 관리 어려움 • 데이터 일관성 보장 어려움
• 쓰기 성능 향상 제한적
• 마스터 노드 병목 현상
• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리
• 실시간 데이터 처리
• 무중단 서비스 필요
• 대규모 동시 접속 처리 • 데이터 백업
• 읽기 작업이 많은 서비스
• 지역별 서비스 제공
• 재해 복구 대비 산업 분야 • 금융 거래 시스템
• 통신 서비스
• 대형 전자상거래
• 실시간 예약 시스템 • 콘텐츠 제공 서비스
• 분석 리포팅 시스템
• 글로벌 서비스
• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요
• 낮은 지연시간 필수
• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능
• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요
• 동일한 사양의 노드 권장
• 충분한 메모리 • 마스터 노드 성능 중요
• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요
• 모니터링 시스템 필수
• 정기적인 유지보수 • 상대적으로 간단한 관리
• 백업 정책 중요
• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-25 15:42:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)" href=https://buenhyden.github.io/posts/databases/rdbms/database-clustering-and-replication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로시저 (Procedure)</h2></header><div class=entry-content><p>프로시저 (Procedure) 데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합으로,
자주 사용하는 SQL 명령어들을 하나의 작은 프로그램으로 미리 작성해두고 필요할 때 호출하여 사용하는 것이다.
SQL Server에서의 프로시저 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 주문 처리를 위한 저장 프로시저 생성 CREATE PROCEDURE ProcessOrder @OrderID int, @CustomerID int, @TotalAmount decimal(10,2) AS BEGIN -- 트랜잭션 시작 BEGIN TRANSACTION TRY -- 주문 정보 입력 INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES (@OrderID, @CustomerID, GETDATE(), @TotalAmount) -- 재고 수량 업데이트 UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductID IN ( SELECT ProductID FROM OrderDetails WHERE OrderID = @OrderID ) -- 고객 포인트 업데이트 UPDATE Customers SET Points = Points + (@TotalAmount * 0.01) WHERE CustomerID = @CustomerID -- 트랜잭션 완료 COMMIT TRANSACTION CATCH -- 오류 발생 시 롤백 ROLLBACK TRANSACTION -- 오류 정보 반환 SELECT ERROR_MESSAGE() AS ErrorMessage END END -- 프로시저 사용 예시 EXEC ProcessOrder @OrderID = 1001, @CustomerID = 500, @TotalAmount = 150000 프로시저의 주요 특징과 장점 성능 최적화
프로시저는 최초 실행 시 컴파일되어 캐시에 저장되므로, 반복 실행 시 더 빠른 성능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:05:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로시저 (Procedure)" href=https://buenhyden.github.io/posts/databases/rdbms/sql/stored-procedures-and-functions/procedure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>keyword</h2></header><div class=entry-content><p>Keyword SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 키워드를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.
데이터 조회 (Query) 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- SELECT: 데이터를 조회하는 기본 키워드 -- 지정된 컬럼의 데이터를 결과셋으로 반환 SELECT employee_id, first_name, salary FROM employees; -- FROM: 데이터를 가져올 테이블을 지정 -- 여러 테이블을 콤마로 구분하거나 JOIN을 사용할 수 있음 SELECT * FROM employees, departments; -- DISTINCT: 결과에서 중복된 행을 제거하는 데 사용 -- 기본 DISTINCT 사용 -- 부서별 unique한 직무 목록 조회 SELECT DISTINCT job_id FROM employees; -- 여러 컬럼에 DISTINCT 적용 -- 부서와 직무의 unique한 조합 조회 SELECT DISTINCT department_id, job_id FROM employees; -- COUNT와 함께 사용 -- 회사에 존재하는 직무 개수 조회 SELECT COUNT(DISTINCT job_id) as unique_jobs FROM employees; -- GROUP BY와 함께 사용 SELECT department_id, COUNT(DISTINCT job_id) as job_types FROM employees GROUP BY department_id; 결과 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- LIMIT - 반환되는 결과의 최대 행 수를 제한합니다. SELECT * FROM employees LIMIT 10 -- 상위 10개 행만 반환 -- OFFSET - 결과의 시작 위치를 지정합니다. LIMIT와 함께 자주 사용됩니다. SELECT * FROM employees LIMIT 10 OFFSET 20 -- 21번째부터 30번째 행을 반환 -- FETCH - SQL 표준의 LIMIT와 유사한 기능을 합니다. SELECT * FROM employees FETCH FIRST 10 ROWS ONLY -- 페이지당 10개 항목, 3번째 페이지 조회 SELECT * FROM products ORDER BY name LIMIT 10 OFFSET 20; -- (페이지 번호 - 1) * 페이지 크기 = OFFSET 조건 연산자 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- WHERE: 조건절을 지정하여 특정 조건을 만족하는 데이터만 조회 -- AND, OR을 사용하여 여러 조건 조합 가능 SELECT * FROM employees WHERE salary > 50000 AND department_id = 10; -- IN: 값 목록 중 포함 여부 -- BETWEEN: 범위 조건 -- LIKE: 패턴 매칭 -- IS NULL: NULL 값 확인 SELECT * FROM employees WHERE department_id IN (10, 20, 30) AND salary BETWEEN 40000 AND 60000 AND first_name LIKE '김%' AND manager_id IS NOT NULL; -- CASE - 조건에 따라 다른 값을 반환합니다. -- WHEN - CASE 문에서 조건을 지정합니다. -- THEN - 조건이 참일 때 반환할 값을 지정합니다. -- ELSE - 모든 조건이 거짓일 때 반환할 값을 지정합니다. SELECT name, CASE WHEN age &lt; 20 THEN 'Young' WHEN age &lt; 60 THEN 'Adult' ELSE 'Senior' END as age_group FROM users; 정렬과 그룹화 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- GROUP BY: 지정된 컬럼을 기준으로 데이터를 그룹화 -- 주로 집계 함수와 함께 사용 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; -- ORDER BY: 결과를 정렬 -- ASC(오름차순), DESC(내림차순) 지정 가능 SELECT * FROM employees ORDER BY salary DESC, first_name ASC; -- HAVING: GROUP BY로 그룹화된 데이터에 대한 조건 지정 -- WHERE는 개별 행에 대한 조건, HAVING은 그룹에 대한 조건 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000; 조인(Join) 관련 키워드 JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. JOIN을 사용하면 여러 테이블의 데이터를 하나의 결과 집합으로 결합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 07:56:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to keyword" href=https://buenhyden.github.io/posts/databases/rdbms/sql/syntax/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cardinality</h2></header><div class=entry-content><p>Cardinality Cardinality는 데이터베이스 분야에서 주로 두 가지 의미로 사용된다.
테이블 간의 관계에서의 Cardinality
이는 두 엔티티 간의 최대 연관성을 나타낸다.
주요 유형은 다음과 같습니다:
1:1 (일대일) 관계: 예를 들어, 사원과 사원증의 관계 1:N (일대다) 관계: 예를 들어, 교수와 학생의 관계 N:M (다대다) 관계: 예를 들어, 학생과 강좌의 관계 컬럼에 있는 고유한 값의 Cardinality
이는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.
Cardinality의 정도에 따라 다음과 같이 분류할 수 있다:
높은 Cardinality: 주민등록번호, 이메일 주소와 같이 대부분의 값이 고유한 경우 중간 Cardinality: 우편번호, 도시 이름과 같이 일부 값이 고유하지만 많은 값이 반복되는 경우 낮은 Cardinality: 성별, 상태 코드와 같이 적은 수의 고유 값을 포함하는 경우 데이터베이스 성능에 여러 가지 중요한 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2024-10-22 15:08:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cardinality" href=https://buenhyden.github.io/posts/databases/rdbms/sql/cardinality/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 캐싱 (Database Caching)</h2></header><div class=entry-content><p>데이터베이스 캐싱 (Database Caching) 데이터베이스 캐싱은 자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술.
정의와 목적 자주 액세스하는 데이터를 고속 메모리에 저장하여 빠른 검색 가능 데이터베이스 서버의 부하 감소 및 응답 시간 단축 주요 장점 성능 향상: 데이터 검색 속도 개선 서버 부하 감소: 반복적인 쿼리 처리 최소화 비용 절감: 데이터베이스 리소스 사용 효율화 사용자 경험 개선: 빠른 응답 시간 제공 작동 원리 캐시 히트: 요청 데이터가 캐시에 있어 즉시 반환 캐시 미스: 데이터가 캐시에 없어 원본 데이터베이스에서 조회 캐싱 전략 인-메모리 캐싱: RAM에 데이터 저장 (예: Redis, Memcached) 쿼리 결과 캐싱: 자주 실행되는 쿼리 결과 저장 객체 캐싱: 애플리케이션 레벨에서 객체 단위로 캐싱 주의사항 데이터 일관성 유지: 캐시와 원본 데이터 간 불일치 방지 적절한 캐시 갱신 정책 수립 필요 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 06:25:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 캐싱 (Database Caching)" href=https://buenhyden.github.io/posts/system-design/caching/types/database/database-caching/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-19 07:35:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/hateoas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/devops/monitoring-and-observability/observability/observability-vs-monitoring/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/backend/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/backend/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>