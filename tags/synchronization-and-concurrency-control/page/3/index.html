<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Synchronization-and-Concurrency-Control | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/synchronization-and-concurrency-control/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Synchronization-and-Concurrency-Control"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Synchronization-and-Concurrency-Control"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Synchronization-and-Concurrency-Control</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Starvation</h2></header><div class=entry-content><p>기아 상태 (Starvation) 운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황.
자원 관리 문제로, 낮은 우선순위 프로세스가 높은 우선순위 프로세스에 의해 자원이 계속 점유되어 무기한 대기하는 상황으로 주로 우선순위 기반 스케줄링에서 발생하며, 시스템 성능과 공정성에 부정적인 영향을 미친다.
Source: https://www.javatpoint.com/what-is-starvation-in-operating-system
발생 조건 기아 상태가 발생하기 위한 주요 조건은 다음과 같다:
우선순위 기반 스케줄링: 높은 우선순위 프로세스가 계속 실행되면서 낮은 우선순위 프로세스가 실행되지 못함. 자원 부족: 시스템 자원이 제한적일 때 특정 프로세스가 지속적으로 자원을 얻지 못함. 비공정한 스케줄링 알고리즘: 공정성을 고려하지 않는 알고리즘이 낮은 우선순위 프로세스를 무시함. 임계 구역 점유: 특정 프로세스가 임계 구역을 오래 점유하여 다른 프로세스의 접근을 차단. 해결책 및 방지책 기아 상태를 해결하거나 방지하기 위한 방법은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-25 07:52:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Starvation" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/starvation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>교착상태 (Deadlock)</h2></header><div class=entry-content><p>교착상태 (Deadlock) 둘 이상의 프로세스가 서로가 가진 자원을 기다리며 무한정 대기하는 상황
Source: https://www.geeksforgeeks.org/deadlock-system-model/
교착상태를 시뮬레이션하는 예제:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 import threading import time class Resource: def __init__(self, name): self.name = name self.lock = threading.Lock() def acquire(self, process_name): print(f"{process_name}가 {self.name} 획득 시도") self.lock.acquire() print(f"{process_name}가 {self.name} 획득 성공") def release(self, process_name): print(f"{process_name}가 {self.name} 반환") self.lock.release() def process_task(process_name, first_resource, second_resource): """ 교착상태를 발생시키는 프로세스 작업을 시뮬레이션합니다. 각 프로세스는 두 개의 자원을 순차적으로 획득하려 시도합니다. """ try: # 첫 번째 자원 획득 first_resource.acquire(process_name) print(f"{process_name}가 작업 중…") time.sleep(1) # 다른 프로세스가 두 번째 자원을 획득할 시간을 줌 # 두 번째 자원 획득 시도 second_resource.acquire(process_name) print(f"{process_name}가 모든 자원 획득 성공") # 작업 수행 time.sleep(1) # 자원 반환 second_resource.release(process_name) first_resource.release(process_name) except Exception as e: print(f"{process_name} 오류 발생: {e}") def main(): # 두 개의 자원 생성 resource_A = Resource("Resource A") resource_B = Resource("Resource B") # 두 개의 프로세스 생성 # Process 1은 A -> B 순서로 자원 획득 시도 # Process 2는 B -> A 순서로 자원 획득 시도 process1 = threading.Thread( target=process_task, args=("Process 1", resource_A, resource_B) ) process2 = threading.Thread( target=process_task, args=("Process 2", resource_B, resource_A) ) # 프로세스 시작 process1.start() process2.start() # 프로세스 종료 대기 process1.join() process2.join() if __name__ == "__main__": print("교착상태 시뮬레이션 시작") main() print("시뮬레이션 종료") Deadlock이 발생하기 위한 필요 조건 Deadlock이 발생하기 위해서는 다음 네 가지 조건이 모두 충족되어야 한다:
...</p></div><footer class=entry-footer><span title='2024-11-23 23:24:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;632 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 교착상태 (Deadlock)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/deadlock/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Race Condition</h2></header><div class=entry-content><p>경쟁 상태 (Race Condition) 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 접근의 타이밍이나 순서에 따라 결과가 달라질 수 있는 상황.
이는 프로그램의 실행 결과가 프로세스/스레드의 실행 순서에 따라 예측할 수 없게 달라지는 현상을 초래한다.
Source: https://www.rapitasystems.com/blog/race-condition-testing
발생 조건 경쟁 상태가 발생하기 위한 조건은 다음과 같다:
두 개 이상의 포인터가 동시에 같은 데이터에 접근. 최소한 하나의 포인터가 데이터를 쓰기 위해 사용됨. 데이터 접근을 동기화하는 메커니즘이 없음. 해결책 및 방지책 동기화 메커니즘 사용: 뮤텍스(mutex), 세마포어, 락(lock) 등을 사용하여 공유 자원에 대한 접근을 제어한다. 원자적 연산 사용: 분할할 수 없는 단일 연산으로 처리하여 중간 상태를 방지한다. 스레드 안전 프로그래밍: 모든 함수를 스레드 안전하게 설계한다. 락프리 알고리즘: 고급 기법으로, 특정 동시성 작업을 최적화하는 데 사용된다. 트랜잭션 격리 수준 조정: 데이터베이스에서는 직렬화 가능한 트랜잭션 격리 수준을 사용하여 경쟁 상태를 방지할 수 있다. 실제 시스템에서의 예방책 정적 분석 도구 사용: 소스 코드나 컴파일된 바이너리를 분석하여 잠재적인 경쟁 상태를 탐지한다. 로그 분석 및 모니터링: 시스템 로그를 분석하여 경쟁 상태의 징후를 감지한다. 분산 추적 시스템: 분산 시스템에서 요청과 메시지의 흐름을 추적하여 타이밍 의존성을 식별한다. 일관성 검사 도구: 분산 노드 간의 데이터 일관성을 확인하여 경쟁 상태로 인한 이상을 탐지한다. 고려사항 및 주의사항 비결정적 특성: 경쟁 상태로 인한 버그는 재현하기 어려우므로 철저한 테스트가 필요하다. 성능 영향: 동기화 메커니즘의 과도한 사용은 성능 저하를 초래할 수 있으므로 균형이 필요하다. 데드락 주의: 락을 사용할 때는 데드락 발생 가능성에 주의해야 한다. 확장성 고려: 분산 시스템에서는 경쟁 상태 관리가 시스템의 확장성에 영향을 미칠 수 있다. 모범 사례 최소한의 임계 영역: 락으로 보호되는 코드 영역을 최소화하여 성능 저하를 방지한다. 세분화된 락: 전역 락 대신 세분화된 락을 사용하여 병렬성을 높인다. 불변성 활용: 가능한 경우 불변 객체를 사용하여 동시성 문제를 원천적으로 방지한다. 스레드 안전한 라이브러리 사용: 검증된 스레드 안전 라이브러리를 활용한다. 실제 시스템에서의 해결 전략 데이터베이스 트랜잭션: 데이터베이스 시스템에서는 ACID 속성을 갖는 트랜잭션을 사용하여 경쟁 상태를 관리한다. 분산 락: 분산 시스템에서는 Zookeeper나 etcd와 같은 도구를 사용하여 분산 락을 구현한다. 버전 관리: 낙관적 동시성 제어를 위해 데이터 버전을 관리하여 충돌을 감지하고 해결한다. 이벤트 소싱: 상태 변경을 이벤트로 기록하여 일관성을 유지하고 경쟁 상태를 해결한다. 경쟁 상태를 시연하고 해결하는 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import threading import time # 경쟁 상태가 발생하는 예제 class BankAccount: def __init__(self): self.balance = 0 # 공유 자원 def deposit(self, amount): # 현재 잔액 읽기 current = self.balance # 시간 지연을 통한 경쟁 상태 시뮬레이션 time.sleep(0.1) # 잔액 업데이트 self.balance = current + amount def get_balance(self): return self.balance # 경쟁 상태가 해결된 버전 class SafeBankAccount: def __init__(self): self.balance = 0 self.lock = threading.Lock() # 상호 배제를 위한 락 def deposit(self, amount): with self.lock: # 임계 영역 보호 current = self.balance time.sleep(0.1) self.balance = current + amount def get_balance(self): with self.lock: return self.balance # 테스트 함수 def test_race_condition(): # 경쟁 상태가 있는 계좌 account = BankAccount() # 여러 스레드가 동시에 입금 threads = [] for _ in range(10): t = threading.Thread(target=account.deposit, args=(100,)) threads.append(t) t.start() # 모든 스레드 완료 대기 for t in threads: t.join() print(f"예상 잔액: 1000, 실제 잔액: {account.get_balance()}") # 안전한 계좌로 테스트 safe_account = SafeBankAccount() # 동일한 테스트 수행 threads = [] for _ in range(10): t = threading.Thread(target=safe_account.deposit, args=(100,)) threads.append(t) t.start() for t in threads: t.join() print(f"안전한 계좌 잔액: {safe_account.get_balance()}") if __name__ == "__main__": test_race_condition() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 23:11:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;581 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Race Condition" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/race-condition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동시성 제어 (Concurrency Control)</h2></header><div class=entry-content><p>동시성 제어 (Concurrency Control) 동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.
다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.
동시성 제어의 중요성 동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:
갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실 모순성: 일관성 없는 데이터 읽기 연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀 목적 트랜잭션의 직렬성 보장 데이터의 무결성 및 일관성 유지 시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화) 주요 동시성 제어 기법 락킹(Locking) 기법 락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.
...</p></div><footer class=entry-footer><span title='2024-11-23 02:47:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;370 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 제어 (Concurrency Control)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>잠금 (Lock)</h2></header><div class=entry-content><p>잠금 (Lock) 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 기본 요소이다.
임계 영역을 보호하고 한 번에 하나의 스레드만 접근할 수 있도록 한다.
스레드가 임계 영역에 진입하기 전에 lock을 획득(acquire)하고, 임계 영역을 빠져나올 때 lock을 해제(release)한다. 다른 스레드가 이미 lock을 보유하고 있다면, lock을 획득하려는 스레드는 lock이 해제될 때까지 대기한다.
Lock은 두 가지 상태를 가진다:
잠금 해제 상태 (Unlocked): 다른 프로세스나 스레드가 Lock을 획득할 수 있는 상태 잠금 상태 (Locked): 이미 한 프로세스나 스레드가 Lock을 보유하고 있는 상태 작동 방식 Lock 획득 (acquire): 스레드가 임계 영역에 진입하기 전에 lock을 획득합니다. 임계 영역 실행: lock을 획득한 스레드만 임계 영역의 코드를 실행할 수 있습니다. Lock 해제 (release): 임계 영역을 빠져나올 때 lock을 해제합니다. Lock을 사용할 때 고려해야할 사항 Lock의 범위는 가능한 한 작게 유지하여 성능 저하를 최소화한다. Lock을 획득하는 시간을 최소화하여 다른 스레드의 대기 시간을 줄인다. 데드락을 방지하기 위해 Lock 획득 순서를 일관되게 유지한다. 예외 상황에서도 Lock이 올바르게 해제되도록 보장한다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import threading class BankAccount: def __init__(self): self.balance = 1000 self.lock = threading.Lock() # Lock 객체 생성 def withdraw(self, amount): # Lock을 획득 시도. 이미 잠겨있다면 획득할 때까지 대기 self.lock.acquire() try: if self.balance >= amount: # 잔액 확인과 차감이 하나의 원자적 작업으로 수행됨 current_balance = self.balance current_balance -= amount self.balance = current_balance print(f"출금 성공: {amount}, 잔액: {self.balance}") else: print("잔액 부족") finally: # 예외가 발생하더라도 반드시 Lock을 해제 self.lock.release() Lock의 유형 공유 락(Shared Lock)과 배타 락(Exclusive Lock) 공유 락(Shared Lock):
여러 스레드가 동시에 리소스를 읽을 수 있지만, 쓰기는 불가능한 락. 읽기 작업에 사용되는 락(Lock) 여러 스레드가 동시에 획득 가능 쓰기 작업을 차단함 배타 락(Exclusive Lock):
한 번에 하나의 스레드만 리소스에 접근할 수 있는 락. 쓰기 작업에 사용되는 락(Lock). 다른 세션의 읽기와 쓰기를 모두 막는다. 데이터 일관성 보장에 유용. 동시성이 낮음. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import threading from typing import Set, Optional class SharedExclusiveLock: def __init__(self): self._lock = threading.Lock() self._shared_holders: Set[int] = set() # 공유 락을 보유한 스레드들 self._exclusive_holder: Optional[int] = None # 배타 락을 보유한 스레드 self._shared_count = 0 self._condition = threading.Condition(self._lock) def acquire_shared(self) -> bool: """공유 락 획득""" with self._lock: while self._exclusive_holder is not None: self._condition.wait() thread_id = threading.get_ident() self._shared_holders.add(thread_id) self._shared_count += 1 return True def release_shared(self): """공유 락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._shared_holders: raise RuntimeError("공유 락을 보유하고 있지 않습니다") self._shared_holders.remove(thread_id) self._shared_count -= 1 if self._shared_count == 0: self._condition.notify_all() def acquire_exclusive(self) -> bool: """배타 락 획득""" with self._lock: while self._exclusive_holder is not None or self._shared_count > 0: self._condition.wait() self._exclusive_holder = threading.get_ident() return True def release_exclusive(self): """배타 락 해제""" with self._lock: if self._exclusive_holder != threading.get_ident(): raise RuntimeError("배타 락을 보유하고 있지 않습니다") self._exclusive_holder = None self._condition.notify_all() # 사용 예시 def reader(lock: SharedExclusiveLock, reader_id: int): """읽기 작업을 수행하는 스레드""" print(f"Reader {reader_id} 시작") lock.acquire_shared() try: print(f"Reader {reader_id} 읽기 작업 수행 중…") time.sleep(1) finally: lock.release_shared() print(f"Reader {reader_id} 종료") def writer(lock: SharedExclusiveLock, writer_id: int): """쓰기 작업을 수행하는 스레드""" print(f"Writer {writer_id} 시작") lock.acquire_exclusive() try: print(f"Writer {writer_id} 쓰기 작업 수행 중…") time.sleep(2) finally: lock.release_exclusive() print(f"Writer {writer_id} 종료") 업데이트 락(Update Lock)과 의도 락(Intent Lock) 업데이트 락(Update Lock):
읽기는 허용하지만, 다른 업데이트 락이나 배타 락의 획득을 방지하는 락(Lock). 읽기 작업은 허용하지만 다른 업데이트나 쓰기 작업은 차단. 읽기-쓰기 전환 시 데드락 방지에 유용하다. Conversion Deadlock을 방지하기 위해 사용된다. 수정을 위해 베타 락(Exclusive Lock)을 걸기 전에 사용하는 락(Lock). 의도 락(Intent Lock):
상위 레벨 리소스에 대한 락을 설정하기 전에 사용되는 락. 계층적 락킹 구조에서 사용. 다른 트랜잭션에게 락 의도를 알림. 데이터베이스 시스템에서 주로 사용됨. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import threading from enum import Enum, auto from typing import Dict, Set class LockType(Enum): INTENT_SHARED = auto() INTENT_EXCLUSIVE = auto() UPDATE = auto() SHARED = auto() EXCLUSIVE = auto() class HierarchicalLock: def __init__(self): self._lock = threading.Lock() self._holders: Dict[LockType, Set[int]] = { lock_type: set() for lock_type in LockType } self._condition = threading.Condition(self._lock) def _can_acquire(self, lock_type: LockType, thread_id: int) -> bool: """주어진 락 타입을 획득할 수 있는지 확인""" if lock_type == LockType.UPDATE: # 업데이트 락은 공유 락과 호환되지만 다른 업데이트 락과는 호환되지 않음 return not (self._holders[LockType.EXCLUSIVE] or self._holders[LockType.UPDATE]) elif lock_type == LockType.INTENT_SHARED: # 의도 공유 락은 배타 락과만 충돌 return not self._holders[LockType.EXCLUSIVE] # … 다른 락 타입에 대한 호환성 검사 로직 추가 def acquire(self, lock_type: LockType) -> bool: """락 획득""" with self._lock: thread_id = threading.get_ident() while not self._can_acquire(lock_type, thread_id): self._condition.wait() self._holders[lock_type].add(thread_id) return True def release(self, lock_type: LockType): """락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._holders[lock_type]: raise RuntimeError(f"{lock_type} 락을 보유하고 있지 않습니다") self._holders[lock_type].remove(thread_id) self._condition.notify_all() 스핀 락 (Spin Lock) 락을 획득할 때까지 계속해서 확인하는 바쁜 대기(busy-waiting) 방식의 락.
...</p></div><footer class=entry-footer><span title='2024-11-18 10:54:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1400 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 잠금 (Lock)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/lock/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>