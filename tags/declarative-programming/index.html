<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Declarative-Programming | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/declarative-programming/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/declarative-programming/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/declarative-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/declarative-programming/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Declarative-Programming"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Declarative-Programming"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Declarative-Programming</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>제약 프로그래밍 (Constraint programming)</h2></header><div class=entry-content><p>제약 프로그래밍 (Constraint programming) 복잡한 조합 문제를 표현하고 해결하기 위한 강력한 패러다임
문제를 변수와 이들 변수에 대한 제약 조건의 형태로 표현하는 프로그래밍 방식
특징 선언적 모델링: 문제를 제약 조건의 집합으로 표현합니다. 제약 만족: 모든 제약 조건을 만족하는 변수 할당을 찾습니다. 탐색 공간 축소: 제약 조건을 통해 가능한 해결책의 범위를 줄입니다. 다양한 문제 해결: 이산적이고 조합적인 문제를 효과적으로 다룹니다. 효율적인 탐색 알고리즘: 제약 전파, 지능적 변수 할당, 효율적인 가지치기 전략을 사용합니다. 장점 표현력: 복잡한 문제를 간결하게 표현할 수 있습니다. 유연성: 다양한 종류의 제약 조건을 표현할 수 있습니다. 효율성: 대규모 탐색 공간을 효과적으로 탐색할 수 있습니다. 최적화 가능: 만족 가능한 해결책 중 최적의 해결책을 찾을 수 있습니다. 단점 학습 곡선: 초보자에게는 이해하기 어려울 수 있습니다. 성능 변동: 문제 표현 방식에 따라 성능이 크게 달라질 수 있습니다. 특정 문제에 제한: 모든 종류의 문제에 적합하지 않을 수 있습니다. 주의사항 및 고려사항 적절한 문제 선택: 제약 프로그래밍에 적합한 문제인지 고려해야 합니다. 효율적인 제약 조건 설계: 문제를 효과적으로 표현하는 제약 조건을 설계해야 합니다. 솔버 선택: 문제의 특성에 맞는 적절한 솔버를 선택해야 합니다. 성능 최적화: 대규모 문제의 경우 성능 최적화를 고려해야 합니다. 예시 Python Python 예제는 스도쿠 퍼즐 해결기를 구현했습니다.
이는 제약 프로그래밍의 전형적인 예시로, 다음과 같은 제약 조건들을 다룹니다:
...</p></div><footer class=entry-footer><span title='2024-10-09 09:06:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;834 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 제약 프로그래밍 (Constraint programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/constraint-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>논리 프로그래밍 (Logic Programming)</h2></header><div class=entry-content><p>논리 프로그래밍 (Logic Programming) 수학적 논리에 기반한 프로그래밍 패러다임
전통적인 프로그래밍이 “어떻게(how)” 문제를 해결할지에 중점을 둔다면, 논리 프로그래밍은 “무엇을(what)” 해결해야 하는지에 초점을 맞춘다.
프로그램은 사실(facts)과 규칙(rules)의 집합으로 구성되며, 시스템은 이러한 논리적 관계를 사용하여 쿼리(queries)에 대한 답을 찾아낸다.
특징 선언적 스타일: 프로그램의 목표를 명시하고, 실행 방법은 시스템이 결정합니다. 논리 규칙: 프로그램은 술어(predicates)와 사실로 표현된 논리 규칙으로 구성됩니다. 패턴 매칭: 입력을 논리 규칙과 대조하여 적용 가능성을 판단합니다. 지식 표현: 복잡한 관계와 개념을 명확하고 간결하게 표현할 수 있습니다. 추론 메커니즘: 기존 사실과 규칙으로부터 새로운 사실과 규칙을 도출합니다. 장점 표현력: 복잡하고 추상적인 개념을 간결하게 표현할 수 있습니다. 모듈성: 독립적인 모듈로 프로그램을 분리할 수 있어 재사용성과 유지보수성이 향상됩니다. 유연성: 다양한 실행 모드(전방 연쇄, 후방 연쇄, 대화형 쿼리)를 지원합니다. 효율적인 메모리 관리: 데이터 저장과 메모리 관리가 효율적입니다. 지식 표현에 적합: 논리적 관계를 쉽게 사실과 규칙으로 변환할 수 있습니다. 단점 계산 효율성: 복잡한 문제나 대규모 지식 기반에서는 계산 비용이 높을 수 있습니다. 비결정성: 여러 해결책이 존재하거나 예측 불가능한 동작을 할 수 있습니다. 디버깅의 어려움: 오류나 예상치 못한 결과의 원인을 추적하기 어려울 수 있습니다. 제한된 문제 범위: 모든 유형의 문제에 적합하지 않을 수 있습니다. 주의사항 및 고려사항 적절한 문제 선택: 논리 프로그래밍이 적합한 문제 영역을 선택해야 합니다. 성능 최적화: 복잡한 쿼리나 대규모 데이터셋에서의 성능을 고려해야 합니다. 지식 표현의 정확성: 사실과 규칙이 정확하게 도메인 지식을 반영해야 합니다. 비결정성 관리: 여러 해결책이 존재할 때의 처리 방법을 고려해야 합니다. 다른 패러다임과의 통합: 필요에 따라 명령형 또는 함수형 프로그래밍과 결합할 수 있습니다. 예시 Python 사실(Facts) 표현: 사실들은 단순한 관계 튜플로 표현됩니다 예: (“부모”, “철수”, “영희”)는 “철수는 영희의 부모이다"를 의미합니다 규칙(Rules) 정의: 규칙은 head(결론)와 body(조건)로 구성됩니다 조부모 관계는 두 개의 부모 관계를 통해 추론됩니다 추론 엔진: 재귀적으로 사실과 규칙을 탐색합니다 백트래킹을 사용하여 모든 가능한 해답을 찾습니다 순환 참조를 방지하기 위한 방문 집합을 사용합니다 패턴 매칭: 간단한 패턴 매칭을 통해 관계를 확인합니다 실제 논리 프로그래밍 언어에서는 더 복잡한 단일화(unification) 알고리즘을 사용합니다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class LogicEngine: def __init__(self): self.facts = [] self.rules = [] def add_fact(self, fact): """사실을 데이터베이스에 추가합니다""" self.facts.append(fact) def add_rule(self, rule): """규칙을 데이터베이스에 추가합니다""" self.rules.append(rule) def query(self, goal): """목표에 대한 해답을 찾습니다""" return self._solve(goal, set()) def _solve(self, goal, visited): """재귀적으로 해답을 찾습니다""" # 순환 참조 방지 if str(goal) in visited: return set() results = set() visited.add(str(goal)) # 사실에서 직접 매칭 확인 for fact in self.facts: if self._match(goal, fact): results.add(fact) # 규칙을 통한 추론 for rule in self.rules: if self._match(goal, rule.head): for body_fact in self._solve(rule.body, visited.copy()): results.add(rule.head) return results def _match(self, pattern1, pattern2): """두 패턴이 매칭되는지 확인합니다""" return pattern1 == pattern2 class Rule: def __init__(self, head, body): self.head = head self.body = body # 가족 관계 예제 def main(): engine = LogicEngine() # 사실 추가 (부모-자식 관계) engine.add_fact(("부모", "철수", "영희")) engine.add_fact(("부모", "영희", "민수")) engine.add_fact(("부모", "영희", "수진")) # 규칙 추가 (조부모 관계) engine.add_rule(Rule( ("조부모", "X", "Z"), ("부모", "X", "Y", "부모", "Y", "Z") )) # 쿼리 실행 print("=== 직접적인 부모 관계 ===") results = engine.query(("부모", "영희", "민수")) print(f"영희는 민수의 부모인가? {len(results) > 0}") print("\n=== 조부모 관계 추론 ===") results = engine.query(("조부모", "철수", "민수")) print(f"철수는 민수의 조부모인가? {len(results) > 0}") if __name__ == "__main__": main() Javascript 사실(Facts) 표현: 사실들은 단순한 관계 튜플로 표현됩니다 예: (“부모”, “철수”, “영희”)는 “철수는 영희의 부모이다"를 의미합니다 규칙(Rules) 정의: 규칙은 head(결론)와 body(조건)로 구성됩니다 조부모 관계는 두 개의 부모 관계를 통해 추론됩니다 추론 엔진: 재귀적으로 사실과 규칙을 탐색합니다 백트래킹을 사용하여 모든 가능한 해답을 찾습니다 순환 참조를 방지하기 위한 방문 집합을 사용합니다 패턴 매칭: 간단한 패턴 매칭을 통해 관계를 확인합니다 실제 논리 프로그래밍 언어에서는 더 복잡한 단일화(unification) 알고리즘을 사용합니다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class LogicEngine { constructor() { this.facts = new Set(); this.rules = []; } addFact(fact) { this.facts.add(JSON.stringify(fact)); } addRule(rule) { this.rules.push(rule); } query(goal) { return this._solve(goal, new Set()); } _solve(goal, visited) { const goalStr = JSON.stringify(goal); if (visited.has(goalStr)) { return new Set(); } const results = new Set(); visited.add(goalStr); // 사실에서 직접 매칭 확인 for (const factStr of this.facts) { const fact = JSON.parse(factStr); if (this._match(goal, fact)) { results.add(factStr); } } // 규칙을 통한 추론 for (const rule of this.rules) { if (this._match(goal, rule.head)) { const bodyResults = this._solve(rule.body, new Set(visited)); if (bodyResults.size > 0) { results.add(JSON.stringify(rule.head)); } } } return results; } _match(pattern1, pattern2) { return JSON.stringify(pattern1) === JSON.stringify(pattern2); } } class Rule { constructor(head, body) { this.head = head; this.body = body; } } // 가족 관계 예제 async function main() { const engine = new LogicEngine(); // 사실 추가 (부모-자식 관계) engine.addFact(["부모", "철수", "영희"]); engine.addFact(["부모", "영희", "민수"]); engine.addFact(["부모", "영희", "수진"]); // 규칙 추가 (조부모 관계) engine.addRule(new Rule( ["조부모", "X", "Z"], ["부모", "X", "Y", "부모", "Y", "Z"] )); // 쿼리 실행 console.log("=== 직접적인 부모 관계 ==="); const parentResults = engine.query(["부모", "영희", "민수"]); console.log(`영희는 민수의 부모인가? ${parentResults.size > 0}`); console.log("\n=== 조부모 관계 추론 ==="); const grandparentResults = engine.query(["조부모", "철수", "민수"]); console.log(`철수는 민수의 조부모인가? ${grandparentResults.size > 0}`); } main().catch(console.error); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-09 09:05:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;924 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리 프로그래밍 (Logic Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>함수형 프로그래밍 (Functional Programming)</h2></header><div class=entry-content><p>함수형 프로그래밍 (Functional Programming) 수학적 함수의 개념을 바탕으로 한 프로그래밍 패러다임.
이 방식은 상태 변경과 데이터 변경을 최소화하고 함수의 응용을 강조.
특징 순수 함수: 동일한 입력에 대해 항상 같은 출력을 반환하며, 부수 효과가 없습니다. 불변성: 데이터는 생성된 후 변경되지 않습니다. 고차 함수: 함수를 인자로 받거나 함수를 반환할 수 있습니다. 재귀: 반복문 대신 재귀를 사용하여 문제를 해결합니다. 지연 평가: 필요한 시점까지 계산을 미룹니다. 장점 코드의 간결성과 가독성: 함수 중심의 코드로 더 읽기 쉽고 이해하기 쉽습니다. 테스트와 디버깅 용이성: 순수 함수는 예측 가능하므로 테스트하기 쉽습니다. 병렬 처리 용이성: 불변성과 부수 효과 없음으로 인해 동시성 처리가 쉽습니다. 모듈성과 재사용성: 작은 순수 함수들의 조합으로 큰 프로그램을 만들 수 있습니다. 단점 학습 곡선: 전통적인 명령형 프로그래밍과 다른 사고방식이 필요합니다. 성능 이슈: 불변성으로 인해 메모리 사용량이 증가할 수 있습니다. 복잡성: 일부 문제에서는 함수형 접근이 더 복잡할 수 있습니다. 주의사항 및 고려사항 적절한 사용: 모든 문제에 함수형 접근이 최선은 아닙니다. 문제의 특성을 고려해야 합니다. 성능 최적화: 불변성과 순수 함수로 인한 성능 저하를 주의해야 합니다. 팀의 이해도: 팀 전체가 함수형 프로그래밍 개념을 이해하고 있어야 합니다. 예시 Python Python 예제는 금융 거래 분석 시스템을 구현.
다음과 같은 함수형 프로그래밍 개념들을 보여준다:
...</p></div><footer class=entry-footer><span title='2024-10-09 09:05:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;974 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 함수형 프로그래밍 (Functional Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>