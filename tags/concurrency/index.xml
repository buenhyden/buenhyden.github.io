<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Concurrency</title><link>https://buenhyden.github.io/tags/concurrency/</link><description>Recent content in Concurrency on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 15 Jan 2025 05:33:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Greenlet and Gevent</title><link>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/</link><pubDate>Wed, 15 Jan 2025 05:33:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/</guid><description>
&lt;h2>Greenlet and Gevent&lt;/h2>&lt;p>Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.&lt;/p>
&lt;h3>Greenlet&lt;/h3>&lt;p>Greenlet은 Python에서 경량 코루틴을 구현한 라이브러리이다.&lt;br>
추가적으로 이야기 하면, Greenlet은 Python의 경량 협력적 멀티태스킹(cooperative multitasking)을 위한 기본 단위이다. 이는 마치 매우 가벼운 스레드처럼 작동하지만, 운영체제 수준의 스레드가 아닌 사용자 공간에서 실행되는 마이크로스레드이다.&lt;/p>
&lt;p>주요 특징:&lt;/p>
&lt;ul>
&lt;li>경량성: 일반 스레드보다 생성 비용이 매우 적다.&lt;/li>
&lt;li>협력적 멀티태스킹: 명시적으로 제어권을 양보할 때만 컨텍스트 스위칭이 일어난다.&lt;/li>
&lt;li>단일 OS 스레드 내 실행: 모든 greenlet은 동일한 물리적 스레드에서 실행된다.&lt;/li>
&lt;/ul>
&lt;p>사용 예:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">greenlet&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">greenlet&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">test1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gr2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">test2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">42&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">greenlet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">greenlet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>작동 원리&lt;/h4>&lt;p>Greenlet은 협력적 멀티태스킹을 사용한다.&lt;br>
이는 각 greenlet이 자발적으로 제어권을 다른 greenlet에게 넘겨주는 방식이다.&lt;br>
이를 코드로 살펴보면:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">greenlet&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">greenlet&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">task1&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Task 1: Start&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gr2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># task2로 제어권 전환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Task 1: End&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">task2&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Task 2: Start&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># task1으로 제어권 전환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Task 2: End&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">greenlet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">greenlet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gr1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">switch&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># 실행 시작&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 코드에서 &lt;code>switch()&lt;/code>를 호출할 때마다 실행 컨텍스트가 한 greenlet에서 다른 greenlet으로 전환된다.&lt;br>
이는 매우 효율적인데, 운영체제의 컨텍스트 스위칭이 필요 없기 때문이다.&lt;/p>
&lt;h4>Greenlet Vs 시스템 스레드&lt;/h4>&lt;p>전통적인 스레드와 greenlet의 차이점을 이해하는 것이 중요하다:&lt;br>
주요 차이점:&lt;/p>
&lt;ol>
&lt;li>스레드는 선점형(preemptive) 멀티태스킹을 사용하며, 운영체제가 스케줄링을 관리한다.&lt;/li>
&lt;li>Greenlet은 협력적 멀티태스킹을 사용하며, 애플리케이션이 스케줄링을 제어한다.&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 전통적인 스레드 사용&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">threading&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">io_task&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 운영체제 수준의 블로킹&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;IO Task&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">io_task&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Greenlet을 사용한 비슷한 작업&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">greenlet&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">greenlet&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">gevent&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">io_task_greenlet&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 다른 greenlet에게 제어권 양보&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;IO Task&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spawn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">io_task_greenlet&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>메모리와 성능 특성&lt;/h4>&lt;p>Greenlet의 주요 장점은 그 효율성에 있다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>메모리 사용:&lt;/p>
&lt;ul>
&lt;li>일반 스레드: 약 8MB/스레드&lt;/li>
&lt;li>Greenlet: 약 3KB/greenlet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>컨텍스트 스위칭 비용:&lt;/p>
&lt;ul>
&lt;li>스레드: 운영체제 수준의 컨텍스트 스위치 필요&lt;/li>
&lt;li>Greenlet: 사용자 공간에서의 간단한 점프 명령만 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4>제한사항과 고려사항&lt;/h4>&lt;p>Greenlet을 사용할 때 주의해야 할 점들이 있다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>CPU 바운드 작업:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">cpu_intensive&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># CPU를 많이 사용하는 작업&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 다른 greenlet이 실행될 기회가 없음&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">))&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이런 경우 다른 greenlet이 실행될 기회를 주기 위해 명시적으로 제어권을 양보해야 한다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">cpu_intensive_with_yield&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1000000&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 다른 greenlet에게 기회 제공&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>블로킹 작업:&lt;br>
일반적인 블로킹 I/O 작업은 다른 greenlet의 실행을 막을 수 있다.&lt;br>
이를 해결하기 위해 gevent는 표준 라이브러리의 블로킹 함수들을 비동기 버전으로 패치하는 monkey patching을 제공한다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">gevent&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">monkey&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">monkey&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">patch_all&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 이제 표준 라이브러리의 블로킹 함수들이 greenlet-friendly하게 변경됨&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;p>Greenlet은 Python에서 효율적인 비동기 프로그래밍을 가능하게 하는 강력한 도구이다.&lt;br>
특히 I/O 바운드 작업이 많은 웹 애플리케이션에서 뛰어난 성능을 발휘할 수 있다. 하지만 그 특성과 제한사항을 잘 이해하고 적절한 상황에서 사용하는 것이 중요하다.&lt;/p>
&lt;h3>Gevent&lt;/h3>&lt;p>Gevent는 Greenlet을 기반으로 구축된 동시성 라이브러리이다.&lt;/p>
&lt;p>주요 특징:&lt;/p>
&lt;ul>
&lt;li>비동기 I/O: libev 또는 libuv 이벤트 루프를 사용하여 효율적인 비동기 I/O를 제공한다.&lt;/li>
&lt;li>동기 API: 비동기 코드를 동기 스타일로 작성할 수 있게 해준다.&lt;/li>
&lt;li>Monkey patching: 표준 라이브러리의 블로킹 함수들을 비동기 버전으로 자동 대체한다.&lt;/li>
&lt;/ul>
&lt;p>사용 예:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">gevent&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Running in foo&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Explicit context switch to foo again&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Explicit context to bar&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Implicit context switch back to bar&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">joinall&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spawn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gevent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spawn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">])&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>Gevent와 Greenlet의 관계&lt;/h4>&lt;p>Gevent는 Greenlet을 기반으로 구축되었으며, Greenlet의 기능을 확장하여 더 편리한 비동기 프로그래밍 환경을 제공한다.&lt;br>
Gevent는 Greenlet의 컨텍스트 스위칭을 자동화하고, 네트워크 작업을 비동기적으로 처리할 수 있게 해준다.&lt;/p>
&lt;h3>사용 사례&lt;/h3>&lt;ul>
&lt;li>웹 서버 및 네트워크 애플리케이션 개발&lt;/li>
&lt;li>동시에 많은 I/O 작업을 처리해야 하는 경우&lt;/li>
&lt;li>기존의 동기식 코드를 최소한의 변경으로 비동기로 전환할 때&lt;/li>
&lt;/ul>
&lt;h3>주의사항&lt;/h3>&lt;ul>
&lt;li>Gevent 사용 시 모든 I/O 작업이 비동기로 처리되므로, CPU 바운드 작업에는 적합하지 않을 수 있다.&lt;/li>
&lt;li>Monkey patching은 강력하지만, 일부 라이브러리와 호환성 문제를 일으킬 수 있으므로 주의가 필요하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>동시성 (Concurrency)</title><link>https://buenhyden.github.io/posts/computer-system/system-execution-models/concurrency/</link><pubDate>Fri, 01 Nov 2024 06:51:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/computer-system/system-execution-models/concurrency/</guid><description>
&lt;h2>동시성 (Concurrency)&lt;/h2>&lt;p>동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다. 예를 들어, 하나의 CPU 코어에서 여러 작업을 빠르게 번갈아가며 실행하여 마치 동시에 여러 작업이 처리되는 것처럼 보이게 만든다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Computer%20System/System%20Execution%20Models/Concurrency/Concurrency.gif"
alt="Concurrency"
loading="lazy" />
&lt;/figure>
_Source: &lt;a href="https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation" target="_blank" rel="noopener">https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation&lt;/a> _&lt;/p>
&lt;h3>동시성의 특징&lt;/h3>&lt;ol>
&lt;li>&lt;strong>논리적 개념&lt;/strong>: 동시성은 물리적으로 동시에 실행되는 것이 아닌, 논리적으로 동시에 실행되는 것처럼 보이게 하는 개념이다.&lt;/li>
&lt;li>&lt;strong>자원 효율성&lt;/strong>: CPU가 유휴 상태로 있지 않고 계속해서 작업을 처리하므로 시스템 자원을 효율적으로 사용할 수 있다.&lt;/li>
&lt;li>&lt;strong>응답성 향상&lt;/strong>: 여러 작업을 번갈아가며 처리하므로 전체적인 시스템의 응답성이 향상된다.&lt;/li>
&lt;/ol>
&lt;h3>동시성의 구현 방법&lt;/h3>&lt;ol>
&lt;li>&lt;strong>멀티스레딩&lt;/strong>: 하나의 프로세스 내에서 여러 스레드를 사용하여 작업을 동시에 처리한다.&lt;/li>
&lt;li>&lt;strong>비동기 프로그래밍&lt;/strong>: 작업을 비동기적으로 처리하여 한 작업이 완료되기를 기다리지 않고 다른 작업을 수행할 수 있게 한다.&lt;/li>
&lt;/ol>
&lt;h3>동시성의 장점&lt;/h3>&lt;ol>
&lt;li>&lt;strong>성능 향상&lt;/strong>: 여러 작업을 동시에 처리함으로써 전체적인 처리 속도를 높일 수 있다.&lt;/li>
&lt;li>&lt;strong>자원 활용 최적화&lt;/strong>: CPU와 같은 시스템 자원을 최대한 활용할 수 있다.&lt;/li>
&lt;li>&lt;strong>사용자 경험 개선&lt;/strong>: 특히 UI 애플리케이션에서 동시성을 활용하면 사용자 반응성을 크게 향상시킬 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>동시성의 주의점&lt;/h3>&lt;ol>
&lt;li>&lt;strong>복잡성 증가&lt;/strong>: 동시성 프로그래밍은 일반적인 순차적 프로그래밍보다 복잡할 수 있다.&lt;/li>
&lt;li>&lt;strong>동기화 문제&lt;/strong>: 여러 작업이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 주의해야 한다.&lt;/li>
&lt;li>&lt;strong>디버깅의 어려움&lt;/strong>: 동시에 실행되는 작업들 간의 상호작용으로 인해 버그를 찾고 수정하기가 어려울 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>동시성의 실제 예시&lt;/h3>&lt;ol>
&lt;li>&lt;strong>웹 브라우저&lt;/strong>: 여러 탭을 동시에 열어 각각 다른 웹페이지를 로드하면서 사용자 입력을 받는 것은 동시성의 좋은 예이다.&lt;/li>
&lt;li>&lt;strong>데이터베이스 시스템&lt;/strong>: 여러 사용자의 쿼리를 동시에 처리하는 데이터베이스 시스템도 동시성을 활용한다.&lt;/li>
&lt;/ol>
&lt;p>동시성은 현대 프로그래밍에서 매우 중요한 개념으로, 시스템의 성능을 향상시키고 사용자 경험을 개선하는 데 크게 기여한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Concurrency vs Parallelism</title><link>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</link><pubDate>Fri, 01 Nov 2024 02:38:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</guid><description>
&lt;h2>동시성 (Concurrency) Vs 병렬성 (Parallelism)&lt;/h2>&lt;p>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.&lt;br>
동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.&lt;br>
실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/TIL/2024/11/8e925d68-4f47-4ef9-8d51-6a39f19c75d2.jpg"
alt="Concurrent vs Parallel"
loading="lazy" />
&lt;/figure>{: width=&amp;ldquo;700&amp;rdquo; height=&amp;ldquo;400&amp;rdquo; }&lt;br>
&lt;em>Source: &lt;a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism&lt;/a>&lt;/em>&lt;/p>
&lt;p>동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.&lt;br>
이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 &amp;ldquo;컨텍스트 스위칭(Context Switching)&amp;ldquo;이라고 한다.&lt;/p>
&lt;p>병렬성(Parallelism)은 여러 작업을 실제로 동시에 처리하는 개념으로, 여러 코어나 프로세서가 필요하며, 실제로 동시에 실행된다. 이로 인해 전체적인 처리 속도를 향상시킬 수 있다.&lt;br>
이러한 작업들은 여러 코어나 프로세서가 각각 독립적인 작업을 동시에 처리하며 각 작업은 서로 다른 하드웨어 자원을 사용한다.&lt;/p>
&lt;h3>동시성(Concurrency)과 병렬성(Parallelism) 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>동시성 (Concurrency)&lt;/th>
&lt;th>병렬성 (Parallelism)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>여러 작업을 번갈아가며 실행하여 동시에 처리되는 것처럼 보이게 함&lt;/td>
&lt;td>여러 작업을 실제로 동시에 처리함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실행 방식&lt;/td>
&lt;td>작업 간 빠른 전환 (Context Switching)&lt;/td>
&lt;td>실제 동시 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>하드웨어 요구사항&lt;/td>
&lt;td>단일 코어로도 가능&lt;/td>
&lt;td>다중 코어 또는 프로세서 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>목적&lt;/td>
&lt;td>응답성 향상, 자원 효율성 증대&lt;/td>
&lt;td>전체 처리 속도 향상&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 특성&lt;/td>
&lt;td>I/O 대기 시간 최소화&lt;/td>
&lt;td>CPU 처리량 최대화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡성&lt;/td>
&lt;td>작업 간 전환과 자원 공유로 인해 복잡할 수 있음&lt;/td>
&lt;td>작업 분할과 결과 통합 과정이 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적용 사례&lt;/td>
&lt;td>웹 서버, 사용자 인터페이스, 멀티태스킹 OS&lt;/td>
&lt;td>대규모 데이터 처리, 과학 계산, 그래픽 렌더링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 방법&lt;/td>
&lt;td>멀티스레딩, 비동기 프로그래밍&lt;/td>
&lt;td>멀티프로세싱, GPU 병렬 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 관리&lt;/td>
&lt;td>자원 공유와 동기화 필요&lt;/td>
&lt;td>각 작업이 독립적인 자원 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 공유&lt;/td>
&lt;td>쉬움 (공유 메모리)&lt;/td>
&lt;td>어려움 (프로세스 간 통신 필요)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리소스 효율성&lt;/td>
&lt;td>대기 시간 활용으로 효율적&lt;/td>
&lt;td>CPU 자원 최대 활용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>공유 메모리 사용&lt;/td>
&lt;td>독립적인 메모리 공간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적합한 작업&lt;/td>
&lt;td>I/O 바운드 작업&lt;br>(파일, 네트워크, DB 작업)&lt;/td>
&lt;td>CPU 바운드 작업&lt;br>(복잡한 계산, 데이터 처리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확장성&lt;/td>
&lt;td>단일 시스템 내에서 제한적&lt;br>I/O 작업에 대해 좋은 확장성&lt;/td>
&lt;td>여러 시스템으로 확장 가능&lt;br>CPU 코어 수에 비례하여 확장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 향상&lt;/td>
&lt;td>응답 시간 개선에 중점&lt;/td>
&lt;td>처리량 증가에 중점&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>에러 처리&lt;/td>
&lt;td>상대적으로 단순&lt;/td>
&lt;td>복잡한 동기화 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디버깅 난이도&lt;/td>
&lt;td>상대적으로 어려움 (타이밍 이슈)&lt;/td>
&lt;td>매우 어려움 (동시성 문제 + 분산 시스템 이슈)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프로그래밍 모델&lt;/td>
&lt;td>이벤트 기반, 콜백, Promises 등&lt;/td>
&lt;td>MapReduce, 데이터 병렬화 등&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>선택 기준표&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상황&lt;/th>
&lt;th>권장 방식&lt;/th>
&lt;th>이유&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>웹 서버 개발&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>대부분 I/O 작업 위주&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이미지 처리&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>CPU 집약적 작업&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자 인터페이스&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>반응성 향상 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>대규모 데이터 분석&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>독립적인 데이터 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실시간 스트리밍&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>지속적인 I/O 처리 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>과학적 계산&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>복잡한 계산 작업 분할 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>성능 비교표&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>작업 유형&lt;/th>
&lt;th>동시성 성능&lt;/th>
&lt;th>병렬성 성능&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>I/O 작업&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;td>보통&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CPU 작업&lt;/td>
&lt;td>보통&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>효율적&lt;/td>
&lt;td>많은 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>응답 시간&lt;/td>
&lt;td>일관적&lt;/td>
&lt;td>변동 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>처리량&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 활용&lt;/td>
&lt;td>효율적&lt;/td>
&lt;td>최대화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3>참고 및 출처&lt;/h3></description></item><item><title>코루틴(Coroutine)</title><link>https://buenhyden.github.io/posts/programming-languages/concepts/coroutine/</link><pubDate>Mon, 14 Oct 2024 06:52:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/programming-languages/concepts/coroutine/</guid><description>
&lt;h2>코루틴(Coroutine)&lt;/h2>&lt;p>코루틴(Coroutine)은 복잡한 비동기 작업을 간단하고 효율적으로 처리할 수 있게 해주는 프로그래밍 개념이다.&lt;br>
프로그램의 실행 흐름을 제어할 수 있는 프로그래밍 구성 요소이다.&lt;br>
일반적인 함수와 달리, 코루틴은 실행을 일시 중단하고 재개할 수 있으며, 여러 진입점과 종료점을 가질 수 있다.&lt;br>
이는 마치 대화하는 것처럼, 실행을 주고받을 수 있다는 특징이 있다.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Python에서의 간단한 코루틴 예제&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">simple_coroutine&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;코루틴 시작&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 중단점&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1초 후 재개&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 다른 중단점&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;또 1초 후 재개&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 코루틴 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">simple_coroutine&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">())&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Programming%20Languages/Concepts/0_H5DpdbiOZhkWlYBq.webp"
alt="Coroutine"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://medium.com/@turxan.dunya97/simple-explanation-what-is-coroutines-in-programming-d01e0ddf6f06" target="_blank" rel="noopener">https://medium.com/@turxan.dunya97/simple-explanation-what-is-coroutines-in-programming-d01e0ddf6f06&lt;/a> _&lt;/p>
&lt;h3>코루틴의 주요 특징&lt;/h3>&lt;ol>
&lt;li>&lt;strong>경량성&lt;/strong>: 코루틴은 스레드보다 훨씬 가볍다. 수천 개의 코루틴을 생성해도 시스템 리소스를 많이 사용하지 않는다.&lt;/li>
&lt;li>&lt;strong>비동기 처리&lt;/strong>: 코루틴을 사용하면 비동기 작업을 동기 코드처럼 쉽게 작성할 수 있다.&lt;/li>
&lt;li>&lt;strong>중단 및 재개&lt;/strong>: 코루틴은 실행 중 특정 지점에서 일시 중단되고 나중에 재개될 수 있다.&lt;/li>
&lt;li>&lt;strong>구조화된 동시성&lt;/strong>: 코루틴은 부모-자식 관계로 구성되어 예외 처리와 취소가 용이하다.&lt;/li>
&lt;/ol>
&lt;h3>코루틴의 작동 원리&lt;/h3>&lt;p>코루틴은 다음과 같은 방식으로 작동한다:&lt;/p>
&lt;ol>
&lt;li>코루틴이 시작되면 특정 작업을 수행한다.&lt;/li>
&lt;li>작업 중 중단 지점(suspension point)에 도달하면 실행을 일시 중단한다.&lt;/li>
&lt;li>중단된 동안 다른 코루틴이나 작업이 실행될 수 있다.&lt;/li>
&lt;li>중단 조건이 해제되면 중단된 지점부터 다시 실행을 재개한다.&lt;/li>
&lt;/ol>
&lt;h3>코루틴의 장점&lt;/h3>&lt;ol>
&lt;li>&lt;strong>효율적인 자원 사용&lt;/strong>: 하나의 스레드에서 여러 코루틴을 실행할 수 있어 시스템 자원을 효율적으로 사용한다.&lt;/li>
&lt;li>&lt;strong>간결한 비동기 코드&lt;/strong>: 복잡한 비동기 로직을 간단하고 읽기 쉬운 코드로 작성할 수 있다.&lt;/li>
&lt;li>&lt;strong>에러 처리 용이&lt;/strong>: 구조화된 동시성 덕분에 예외 처리가 쉽다.&lt;/li>
&lt;li>&lt;strong>테스트 용이성&lt;/strong>: 동기 코드처럼 테스트할 수 있어 테스트가 쉽다.&lt;/li>
&lt;/ol>
&lt;h3>코루틴 사용 예시&lt;/h3>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">asyncio&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">data_processor&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;데이터를 비동기적으로 처리하는 코루틴입니다.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 각 처리 단계에서 다른 코루틴에게 실행을 양보할 수 있습니다.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;데이터 처리 시작&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 첫 번째 처리 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># I/O 작업을 시뮬레이션&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;첫 번째 단계 완료&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 두 번째 처리 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;두 번째 단계 완료&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;처리 완료&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">progress_monitor&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;다른 작업의 진행 상황을 모니터링하는 코루틴입니다.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;모니터링 중…&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 0.5초마다 상태 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;여러 코루틴을 동시에 실행하는 메인 함수입니다.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 처리 작업과 모니터링을 동시에 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">processor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">create_task&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data_processor&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">monitor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">create_task&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">progress_monitor&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># data_processor가 완료될 때까지 기다림&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">await&lt;/span> &lt;span class="n">processor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모니터링 작업 중단&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">monitor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cancel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;최종 결과: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 이벤트 루프 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">())&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item></channel></rss>