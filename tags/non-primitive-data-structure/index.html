<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Primitive-Data-Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/non-primitive-data-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/non-primitive-data-structure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/non-primitive-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/non-primitive-data-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-Primitive-Data-Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-Primitive-Data-Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Non-Primitive-Data-Structure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Hash Map vs Hash Map vs Hash Table</h2></header><div class=entry-content><p>Concurrent Hash Map Vs Hash Map Vs Hash Table 특성 Concurrent HashMap HashMap HashTable 동기화 세그먼트/버킷 단위의 부분 동기화 지원 동기화 지원하지 않음 메서드 단위의 전체 동기화 지원 동시성 높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능) 동시성 지원하지 않음 (단일 스레드 환경용) 낮은 동시성 (한 번에 하나의 스레드만 접근 가능) 성능 동시 접근 시 높은 성능 단일 스레드에서 가장 높은 성능 동기화로 인한 성능 저하 null 허용 key와 value 모두 null 불가 key는 하나만 null 허용, value는 여러 개 null 허용 key와 value 모두 null 불가 초기 용량 기본 16, 세그먼트 수는 16 기본 16 기본 11 적재율 기본 0.75 기본 0.75 기본 0.75 이터레이션 fail-safe 이터레이터 제공 fail-fast 이터레이터 제공 fail-fast 이터레이터 제공 생성 시기 Java 5 Java 1.2 Java 1.0 메모리 사용 세그먼트로 인한 추가 메모리 필요 가장 적은 메모리 사용 동기화로 인한 추가 메모리 필요 용도 멀티스레드 환경의 동시성이 필요한 경우 단일 스레드 환경의 일반적인 경우 레거시 코드 호환성이 필요한 경우 확장성 동적 확장 가능 동적 확장 가능 동적 확장 가능 순서 보장 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 동기화 비용 부분적 동기화로 중간 수준의 비용 동기화 비용 없음 전체 동기화로 높은 비용 스레드 안전성 스레드 안전 스레드 안전하지 않음 스레드 안전 키 충돌 처리 체이닝 방식 체이닝 방식 체이닝 방식 참고로 몇 가지 중요한 추가 설명을 하자면:
...</p></div><footer class=entry-footer><span title='2025-01-06 14:35:00 +0000 UTC'>January 6, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Hash Map vs Hash Map vs Hash Table" href=https://buenhyden.github.io/til/2025/01/concurrent-hash-map-vs-hash-map-vs-hash-table/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Data Structure</h2></header><div class=entry-content><p>Concurrent Data Structure Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조이다.
전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.
Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계된 데이터 구조입니다.
Concurrent Data Structure는 일반적으로 다음과 같은 방식으로 구현된다:
세밀한 락(fine-grained locking) 사용 락 없는(lock-free) 알고리즘 대기 없는(wait-free) 알고리즘 지연된 삭제와 메모리 재사용 기법 이러한 구조는 고성능 멀티스레드 시스템, 데이터베이스, 운영체제, 네트워크 스택 등 다양한 분야에서 활용된다.
...</p></div><footer class=entry-footer><span title='2025-01-06 12:55:00 +0000 UTC'>January 6, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;383 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Data Structure" href=https://buenhyden.github.io/til/2025/01/concurrent-data-structure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Suffix Array vs Suffix Tree vs Trie</h2></header><div class=entry-content><p>Suffix Array Vs Suffix Tree Vs Trie Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.
특성 Suffix Array Suffix Tree Trie 기본 구조 모든 접미사를 정렬하여 저장하는 1차원 배열 모든 접미사를 트리 형태로 저장하는 압축된 트리 구조 문자열을 문자 단위로 저장하는 트리 구조 메모리 효율성 O(n), 매우 효율적 O(n), 하지만 실제로는 4n 정도로 큼 O(ALPHABET_SIZE key_length n), 매우 큼 구축 시간 O(n log n) O(n) (Ukkonen’s Algorithm 사용 시) O(n * key_length) 검색 시간 O(m log n + occ), m은 패턴 길이 O(m + occ), m은 패턴 길이 O(m), m은 검색할 문자열 길이 구현 난이도 비교적 간단 매우 복잡 비교적 간단 LCP 계산 추가 배열 필요 트리 구조에서 직접 계산 가능 해당 없음 패턴 매칭 이진 검색 이용 트리 순회로 직접 검색 트리 순회로 직접 검색 공간 지역성 매우 좋음 (연속된 메모리) 보통 (포인터로 인한 흩어짐) 나쁨 (노드가 메모리에 흩어짐) 주요 응용 텍스트 검색, DNA 분석 문자열 처리, 바이오인포매틱스 사전 구현, 자동 완성 동적 업데이트 어려움 가능하나 복잡 쉬움 접두사 검색 어려움 가능하나 비효율적 매우 효율적 최장 공통 접두사 추가 작업 필요 직접 계산 가능 직접 계산 가능 최장 공통 부분 문자열 LCP 배열 필요 직접 계산 가능 부적합 압축 가능성 제한적 매우 좋음 있음 (압축 트라이) 캐시 성능 매우 좋음 보통 나쁨 실제 사용 사례 대용량 문자열 검색 시스템 생물정보학, 문자열 처리 자동 완성, 사전 검색 추가적인 중요 고려사항:
...</p></div><footer class=entry-footer><span title='2025-01-08 15:40:00 +0000 UTC'>January 8, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Array vs Suffix Tree vs Trie" href=https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Lock-free Stack</h2></header><div class=entry-content><p>Lock-free Stack Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.
이 자료구조는 여러 스레드가 동시에 스택에 접근할 수 있으며, 시스템 전체의 진행을 보장한다.
특징 동시성 지원: 여러 스레드가 동시에 스택에 접근하고 수정할 수 있다. 락 사용 없음: 전통적인 동기화 기법인 락을 사용하지 않는다. 진행 보장: 시스템 전체의 진행을 보장하며, 개별 스레드의 기아 현상이 발생할 수 있다. 원자적 연산 사용: Compare-And-Swap(CAS)과 같은 원자적 연산을 사용한다. 구현 방식 Lock-free Stack은 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2025-01-09 13:22:00 +0000 UTC'>January 9, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;333 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock-free Stack" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Circular Queue</h2></header><div class=entry-content><p>Circular Queue (Circular Buffer) 이는 선형 큐의 확장된 버전으로, 데이터를 효율적으로 저장하고 관리하는 특정한 방식을 제공한다.
Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.
이는 ‘Ring Buffer’라고도 불리며, 고정 크기의 배열을 사용하여 데이터를 연속적인 루프로 저장한다.
https://www.geeksforgeeks.org/what-is-circular-queue-circular-queue-meaning/
특징 원형 구조: 마지막 위치가 첫 번째 위치와 연결되어 있다. FIFO (First In First Out) 원칙을 따른다. 두 개의 포인터: 큐의 front와 rear를 추적하는 두 개의 포인터를 사용한다. 고정 크기: 초기화 시 크기가 설정되며, 이후 변경이 어렵다. 장점 메모리 효율성: 선형 큐의 주요 한계인 메모리 낭비 문제를 해결한다. 빠른 연산: 삽입과 삭제 연산의 시간 복잡도가 O(1)이다. 공간 재사용: 큐의 앞부분이 비어있을 때 재사용이 가능하다. 캐시 지역성: 연속된 메모리 사용으로 CPU 캐시 성능이 향상된다. 단점 크기 제한: 고정 크기로 인해 오버플로우와 데이터 손실 가능성이 있다. 구현 복잡성: 선형 큐보다 구현이 복잡하다. 디버깅 어려움: 원형 구조로 인해 디버깅이 어려울 수 있다. 동적 크기 조정의 어려움: 크기를 동적으로 조정하기 어렵다. 응용 CPU 스케줄링: 운영 체제에서 프로세스 관리에 사용된다. 트래픽 관리 시스템: 교차로에서의 효율적인 흐름 제어에 활용된다. 메모리 관리: 운영 체제의 메모리 관리에 사용된다. 스트리밍 서비스: 오디오 및 비디오 스트리밍에 활용된다. 네트워크 패킷 관리: 라우터와 스위치에서 패킷 데이터 처리에 사용된다. 동작 원리 초기화: front와 rear 포인터를 -1로 설정한다. 삽입(Enqueue): 큐가 가득 찼는지 확인한다. rear 포인터를 원형으로 증가시킨 ((rear + 1) % size). 새 요소를 rear 위치에 삽입한다[11]. 삭제(Dequeue): 큐가 비어있는지 확인한다. front 위치의 요소를 반환한다. front 포인터를 원형으로 증가시킨다 ((front + 1) % size). 구성 요소 배열: 데이터를 저장하는 고정 크기의 배열. front 포인터: 큐의 첫 번째 요소를 가리킨다. rear 포인터: 큐의 마지막 요소를 가리킨다. size: 큐의 최대 크기를 나타낸다. 구현 방식 JavaScript를 사용한 Circular Queue 구현 예시:
...</p></div><footer class=entry-footer><span title='2025-01-09 12:59:00 +0000 UTC'>January 9, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;527 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Queue" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/circular-queue/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/non-primitive-data-structure/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>