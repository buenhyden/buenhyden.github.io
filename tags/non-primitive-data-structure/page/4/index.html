<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Primitive-Data-Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/non-primitive-data-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/non-primitive-data-structure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/non-primitive-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/non-primitive-data-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-Primitive-Data-Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-Primitive-Data-Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Non-Primitive-Data-Structure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Ternary search tree</h2></header><div class=entry-content><p>Ternary search tree 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-12 08:04:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Ternary search tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/ternary-search-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>vantage-point tree</h2></header><div class=entry-content><p>vantage-point tree 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-12 08:04:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to vantage-point tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/vantage-point-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>X-tree</h2></header><div class=entry-content><p>X-tree 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-12 08:04:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to X-tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/x-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>트라이 (Trie)</h2></header><div class=entry-content><p>트라이 (Trie) 문자열을 효율적으로 저장하고 검색할 수 있는 트리 기반의 자료구조
prefix tree 또는 digital tree라고도 불린다.
https://www.geeksforgeeks.org/introduction-to-trie-data-structure-and-algorithm-tutorials/?ref=shm
특징 각 노드가 문자를 저장 루트 노드는 비어 있음 자식 노드들이 다음 문자를 나타냄 노드들이 연결되어 하나의 단어를 형성 공통 접두사를 공유하는 단어들을 효율적으로 저장 장점 빠른 검색 속도: 단어 검색 시간 복잡도가 O(m)으로, m은 검색하는 단어의 길이. 공통 접두사 활용: 공간 효율성이 높음. 자동 완성 기능: 특정 접두사를 포함하는 모든 단어를 쉽게 찾을 수 있음 정렬된 데이터 저장: 사전 순으로 데이터를 저장하고 검색 가능 해시 충돌 없음: 안정적인 성능 보장 단점 높은 메모리 사용: 각 노드가 여러 자식에 대한 링크를 가지고 있어 저장 공간을 많이 사용 복잡한 구현: 기본적인 이진 트리에 비해 구현이 다소 복잡 고정된 문자 집합: 보통 알파벳이나 특정 문자 집합을 기반으로 설계되어 다양한 문자 집합 지원을 위해 추가 구현 필요 예시: 각 노드는 문자를 키로 하는 자식 노드들의 맵을 가지고 있다. Python에서는 딕셔너리를, JavaScript에서는 Map을 사용함. 노드마다 그 노드가 단어의 끝인지를 나타내는 플래그(is_end_of_word/isEndOfWord)를 가지고 있다.
이를 통해 “app"과 “apple” 같이 하나가 다른 것의 접두사인 경우도 정확히 구분할 수 있다. count 변수를 통해 각 노드를 지나는 단어의 수를 추적할 수 있다. 이는 자동완성 시스템에서 추천 단어의 빈도수를 계산하는 데 유용하다. 접두사 검색 기능(starts_with/startsWith)을 통해 특정 문자열로 시작하는 단어가 존재하는지 빠르게 확인할 수 있다. get_words_with_prefix/getWordsWithPrefix 메서드를 통해 특정 접두사로 시작하는 모든 단어를 찾을 수 있다. 이는 자동완성 기능 구현에 직접적으로 활용될 수 있다. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class TrieNode: def __init__(self): self.children = {} # 자식 노드를 저장하는 딕셔너리 self.is_end_of_word = False # 단어의 끝을 표시하는 플래그 self.count = 0 # 이 노드를 지나는 단어의 수를 저장 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: """단어를 트라이에 삽입하는 메서드""" node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.count += 1 # 이 노드를 지나는 단어 수 증가 node.is_end_of_word = True def search(self, word: str) -> bool: """단어가 트라이에 존재하는지 검색하는 메서드""" node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: """주어진 접두사로 시작하는 단어가 있는지 확인하는 메서드""" node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def get_words_with_prefix(self, prefix: str) -> list: """주어진 접두사로 시작하는 모든 단어를 찾는 메서드""" result = [] node = self.root # 접두사에 해당하는 노드까지 이동 for char in prefix: if char not in node.children: return result node = node.children[char] # 현재 노드부터 DFS로 모든 단어 찾기 self._find_words(node, prefix, result) return result def _find_words(self, node: TrieNode, current_word: str, result: list) -> None: """DFS로 현재 노드부터 가능한 모든 단어를 찾는 보조 메서드""" if node.is_end_of_word: result.append(current_word) for char, child in node.children.items(): self._find_words(child, current_word + char, result) # 사용 예시 if __name__ == "__main__": trie = Trie() # 단어 삽입 words = ["apple", "app", "apricot", "banana", "bat"] for word in words: trie.insert(word) # 검색 예시 print(f"'apple' exists: {trie.search('apple')}") # True print(f"'app' exists: {trie.search('app')}") # True print(f"'appl' exists: {trie.search('appl')}") # False # 접두사 검색 예시 print(f"Words with prefix 'ap': {trie.get_words_with_prefix('ap')}") # ['apple', 'app', 'apricot'] Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class TrieNode { constructor() { this.children = new Map(); // 자식 노드를 저장하는 Map this.isEndOfWord = false; // 단어의 끝을 표시하는 플래그 this.count = 0; // 이 노드를 지나는 단어의 수를 저장 } } class Trie { constructor() { this.root = new TrieNode(); } insert(word) { let node = this.root; for (const char of word) { if (!node.children.has(char)) { node.children.set(char, new TrieNode()); } node = node.children.get(char); node.count++; } node.isEndOfWord = true; } search(word) { let node = this.root; for (const char of word) { if (!node.children.has(char)) { return false; } node = node.children.get(char); } return node.isEndOfWord; } startsWith(prefix) { let node = this.root; for (const char of prefix) { if (!node.children.has(char)) { return false; } node = node.children.get(char); } return true; } getWordsWithPrefix(prefix) { const result = []; let node = this.root; // 접두사에 해당하는 노드까지 이동 for (const char of prefix) { if (!node.children.has(char)) { return result; } node = node.children.get(char); } // 현재 노드부터 DFS로 모든 단어 찾기 this._findWords(node, prefix, result); return result; } _findWords(node, currentWord, result) { if (node.isEndOfWord) { result.push(currentWord); } for (const [char, child] of node.children) { this._findWords(child, currentWord + char, result); } } } // 사용 예시 const trie = new Trie(); // 단어 삽입 const words = ["apple", "app", "apricot", "banana", "bat"]; words.forEach(word => trie.insert(word)); // 검색 예시 console.log(`'apple' exists: ${trie.search('apple')}`); // true console.log(`'app' exists: ${trie.search('app')}`); // true console.log(`'appl' exists: ${trie.search('appl')}`); // false // 접두사 검색 예시 console.log(`Words with prefix 'ap': ${trie.getWordsWithPrefix('ap')}`); // ['apple', 'app', 'apricot'] 사용하기 적절한 곳 자동 완성 및 추천 시스템 사전 구현 DNA 서열 분석 IP 라우팅 검색어 자동완성 텍스트 편집기 검색 엔진 최적화 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-12 08:04:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;939 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 트라이 (Trie)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fenwick Tree</h2></header><div class=entry-content><p>Fenwick Tree (Binary Indexed Tree, BIT) Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.
1994년 Peter M. Fenwick에 의해 제안되었다.
데이터를 저장하고 조작하는 방식을 정의하며, 특정 연산을 효율적으로 수행할 수 있게 해줍니다.
https://en.wikipedia.org/wiki/Fenwick_tree#/media/File:16-node_Fenwick_tree.svg
일반적인 트리와 달리, 배열을 사용하여 이진 트리를 암시적으로 표현한다.
각 인덱스는 이진수 표현에서 마지막 1의 위치에 따라 관리하는 구간의 크기가 결정된다.
...</p></div><footer class=entry-footer><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fenwick Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/non-primitive-data-structure/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/non-primitive-data-structure/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>