<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Algorithm"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Algorithm"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>보간 검색 (Interpolation Search)</h2></header><div class=entry-content><p>보간 검색 (Interpolation Search) 보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.
이진 탐색(Binary Search)과 유사하지만, 데이터 분포를 고려해 탐색 위치를 예측함으로써 평균적으로 더 빠른 성능을 보인다. 특히 균등한 데이터 분포에서 효과적이다.
보간 검색은 데이터 특성에 민감하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.
핵심 개념 데이터 균등성 가정: 배열의 값이 선형적으로 분포되어 있다고 가정한다.
예측 위치 계산: 탐색 위치를 다음 공식으로 계산한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 12:33:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;592 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보간 검색 (Interpolation Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬(Bubble Sort)은 인접한 요소를 반복적으로 비교하고 교환하여 정렬하는 간단한 알고리즘이다.
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, 구현이 쉽지만 성능이 낮은 특징을 가진다.
https://www.wscubetech.com/resources/dsa/bubble-sort
알고리즘 작동 원리 비교: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(arr[i]와 arr[i+1])를 비교한다. 교환: 순서가 잘못된 경우(arr[i] > arr[i+1]) 두 요소의 위치를 교환한다. 반복: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다. 패스 완료: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다. 예시: [5, 3, 8, 4, 2]
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.
병합 정렬은 데이터 무결성과 안정성이 중요한 시스템(예: 금융 거래 로그)에서 선호된다.
현대 프로그래밍 언어의 표준 라이브러리(예: Python sorted(), Java Collections.sort())에서도 하이브리드 방식으로 병합 정렬을 활용한다.
https://www.programiz.com/dsa/merge-sort
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;528 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.
삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
https://www.geeksforgeeks.org/insertion-sort-algorithm/
삽입 정렬의 작동 원리 초기화: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다. 요소 선택: 정렬되지 않은 부분에서 요소를 선택한다. 비교 및 이동: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다. 삽입: 찾은 위치에 요소를 삽입한다. 반복: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다. 예시: 배열 [5, 2, 4, 6, 1, 3]의 정렬 과정
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;603 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>선택 정렬 (Selection Sort)</h2></header><div class=entry-content><p>선택 정렬 (Selection Sort) 선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.
선택 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.
https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw
알고리즘 작동 원리 초기화:
배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다. 초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다. 최솟값 탐색:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;411 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선택 정렬 (Selection Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬(Quick Sort)은 분할 정복(divide and conquer) 전략을 사용하는 고성능 정렬 알고리즘이다. 1960년 Tony Hoare가 개발했으며, 평균적으로 **O(n log n)**의 시간 복잡도를 가지며 대규모 데이터셋 처리에 효율적이다.
퀵 정렬은 실시간 시스템과 고성능 컴퓨팅에서 널리 사용되며, 알고리즘 최적화의 핵심 사례로 연구된다.
피벗 선택 전략과 하이브리드 기법을 적용하면 현대 애플리케이션에서도 뛰어난 성능을 발휘한다.
https://www.geeksforgeeks.org/quick-sort-algorithm/
기본 원리 핵심 개념 피벗(Pivot) 선택: 배열에서 하나의 요소를 선택한다. 피벗 선택 방법은 성능에 큰 영향을 미칩니다(예: 첫 번째/중간/랜덤 요소 또는 중앙값). 분할(Partitioning): 피벗을 기준으로 배열을 두 부분으로 나눈다. 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동한다. 재귀적 정렬: 분할된 서브 배열에 대해 동일한 과정을 재귀적으로 반복한다. 분할 과정 예시 배열 [5, 3, 8, 4, 2]에서 피벗을 중간 값인 4로 선택:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;600 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>힙 정렬 (Heap Sort)</h2></header><div class=entry-content><p>힙 정렬 (Heap Sort) 힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.
1964년 J. W. J. Williams가 개발한 이 알고리즘은 **최악, 평균, 최선의 경우 모두 O(n log n)**의 시간 복잡도를 보장하며, **메모리 효율성(O(1))**이 뛰어난 특징을 가진다.
주로 대규모 데이터셋 처리와 안정적인 성능이 요구되는 시스템에서 활용된다.
힙 정렬은 성능 예측이 중요한 시스템에서 특히 유용하다. 최근에는 하이브리드 알고리즘(예: Introsort)에서 퀵 정렬의 최악 경우를 방지하기 위해 힙 정렬을 부분적으로 활용하기도 한다.
데이터 특성과 시스템 요구사항에 따라 적절한 정렬 방식을 선택하는 것이 핵심이다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 정렬 (Heap Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>깊이 우선 탐색 (Depth-First Search)</h2></header><div class=entry-content><p>깊이 우선 탐색 (Depth-First Search, DFS) 그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.
미로에서 한 길을 끝까지 가보고, 막힌 길이면 되돌아와서 다른 길을 탐색하는 것과 비슷하다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
작동 방식 루트 노드(또는 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색한다.
각 분기에서 가장 깊은 곳까지 탐색한 후에 백트래킹(되돌아가기)하여 다음 분기로 넘어간다.
장점 메모리 사용이 너비 우선 탐색(BFS)보다 효율적. 현재 경로상의 노드들만 기억하면 되기 때문. 목표 노드가 깊은 단계에 있을 때 BFS보다 빠르게 발견할 수 있다. 모든 노드를 방문하고자 할 때 적합. 단점 해가 없는 경로에 빠질 경우 불필요한 탐색을 할 수 있다. 찾은 경로가 최단 경로라는 보장이 없다. 무한 깊이의 경우에는 탐색이 끝나지 않을 수 있다. 주의해야 할 점 깊이가 매우 깊은 그래프에서는 재귀 방식 사용시 스택 오버플로우가 발생할 수 있으므로, 반복적 방식을 고려해야 합니다. 양방향 그래프에서는 무한 루프를 방지하기 위해 반드시 방문 체크를 해야 합니다. 그래프에 사이클이 있는 경우를 항상 고려해야 합니다. 주로 사용하는 데이터 구조 DFS는 주로 스택(Stack)을 사용하여 구현한다.
재귀 호출을 사용할 경우 시스템 스택을 활용하고, 반복문을 사용할 경우 직접 스택을 구현하여 사용한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:41:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 깊이 우선 탐색 (Depth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>너비 우선 탐색 (Breadth-First Search)</h2></header><div class=entry-content><p>너비 우선 탐색 (Breadth-First Search, BFS) BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘.
시작 노드에서 인접한 모든 노드를 탐색한 후, 그 다음 레벨의 노드들을 차례로 탐색한다.
Source: https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/
장점 최단 경로 보장: 가중치가 없는 그래프에서 출발 노드에서 목표 노드까지의 최단 경로를 항상 찾는다. 무한 경로 방지: 모든 경로를 동시에 진행하기 때문에 무한히 깊은 경로에 빠질 위험이 없습니다. 넓은 탐색: 특정 깊이까지의 모든 노드를 탐색하는 데 적합합니다. 단점 높은 메모리 사용량: 큐에 저장해야 할 노드가 많아질 수 있어 메모리 사용량이 큽니다. 탐색 속도 저하: 경로가 매우 길거나 그래프가 클 경우, 탐색 속도가 느려질 수 있습니다. 해가 없는 경우 비효율적: 유한 그래프에서는 모든 노드를 탐색해야 하고, 무한 그래프에서는 종료하지 못할 수 있습니다. 주의해야 할 점 방문 여부를 반드시 확인해야 합니다. 그렇지 않으면 중복 방문으로 인해 무한 루프에 빠질 수 있습니다. 큐 자료구조를 활용해야 하며, 재귀적으로 구현하지 않습니다. 주로 사용하는 데이터 구조 큐(Queue): BFS는 선입선출(FIFO) 원칙을 따르므로 큐를 사용하여 다음에 탐색할 노드를 관리합니다. 큐를 사용하면 현재 레벨의 모든 노드를 방문한 후 다음 레벨로 자연스럽게 넘어갈 수 있습니다. 배열 또는 집합(Set): 방문 여부를 기록하기 위해 사용됩니다. 배열은 간단하게 구현할 수 있고, 집합은 중복 방지에 효과적입니다. 구현 예시 Java 인접 리스트를 사용하여 그래프를 표현했습니다. LinkedList를 사용하여 큐를 구현했습니다. 기본적인 BFS 탐색을 구현하여 방문 순서를 출력합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Java Implementation import java.util.*; class Graph { private int V; // 정점의 개수 private LinkedList&lt;Integer>[] adj; // 인접 리스트 @SuppressWarnings("unchecked") Graph(int v) { V = v; adj = new LinkedList[v]; for (int i = 0; i &lt; v; ++i) adj[i] = new LinkedList&lt;>(); } // 그래프에 간선 추가 void addEdge(int v, int w) { adj[v].add(w); } // BFS 구현 void BFS(int start) { // 방문 여부를 체크할 배열 boolean[] visited = new boolean[V]; // BFS를 위한 큐 생성 Queue&lt;Integer> queue = new LinkedList&lt;>(); // 시작 노드를 방문 처리하고 큐에 삽입 visited[start] = true; queue.add(start); while (!queue.isEmpty()) { // 큐에서 정점을 꺼내서 출력 start = queue.poll(); System.out.print(start + " "); // 현재 정점과 인접한 모든 정점에 대해 for (int n : adj[start]) { // 방문하지 않은 정점이면 방문 처리하고 큐에 삽입 if (!visited[n]) { visited[n] = true; queue.add(n); } } } } } Javascript 객체를 사용하여 인접 리스트를 구현했습니다. 배열의 shift()와 push()를 사용하여 큐 동작을 구현했습니다. 방문한 노드들의 순서를 배열로 반환합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // JavaScript Implementation class Graph { constructor() { this.adjacencyList = {}; } addVertex(vertex) { if (!this.adjacencyList[vertex]) { this.adjacencyList[vertex] = []; } } addEdge(vertex1, vertex2) { this.adjacencyList[vertex1].push(vertex2); this.adjacencyList[vertex2].push(vertex1); } bfs(start) { const queue = [start]; // 큐 생성 및 시작 노드 추가 const visited = {}; // 방문 체크를 위한 객체 const result = []; // 방문 순서를 저장할 배열 visited[start] = true; // 시작 노드 방문 처리 while (queue.length) { const vertex = queue.shift(); // 큐에서 정점 추출 result.push(vertex); // 결과 배열에 추가 // 인접한 정점들을 처리 this.adjacencyList[vertex].forEach(neighbor => { if (!visited[neighbor]) { visited[neighbor] = true; queue.push(neighbor); } }); } return result; } } Python collections.deque를 사용하여 효율적인 큐 구현을 했습니다. 거리 정보와 경로 추적 기능을 추가했습니다. 최단 경로를 찾는 기능도 구현되어 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # Python Implementation from collections import deque class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def bfs_with_distance(self, start): # 방문 여부와 거리를 저장할 딕셔너리 visited = {} distance = {} parent = {} # 경로 추적을 위한 부모 노드 저장 # 큐 생성 및 시작 노드 초기화 queue = deque([start]) visited[start] = True distance[start] = 0 parent[start] = None while queue: # 큐에서 정점을 꺼내서 처리 current = queue.popleft() print(f"방문: {current} (거리: {distance[current]})") # 인접한 모든 정점에 대해 for neighbor in self.graph.get(current, []): if neighbor not in visited: visited[neighbor] = True distance[neighbor] = distance[current] + 1 parent[neighbor] = current queue.append(neighbor) return distance, parent def find_shortest_path(self, start, end, parent): # 최단 경로 재구성 path = [] current = end while current is not None: path.append(current) current = parent[current] return path[::-1] # 경로를 역순으로 반환 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-15 05:41:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 너비 우선 탐색 (Breadth-First Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
Source: https://jojozhuang.github.io/algorithm/algorithm-binary-search/
장점 검색 속도가 매우 빠릅니다. 시간 복잡도는 O(log n)입니다. 대용량 데이터에서 특정 값의 위치를 찾는 데 효율적입니다. 단점 반드시 정렬된 데이터에서만 사용할 수 있습니다. 데이터의 삽입, 삭제가 빈번한 경우 비효율적일 수 있습니다. 주의해야 할 점들 정렬 상태 유지:
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1070 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/algorithm/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>