<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Network-Protocols | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/network-protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/network-protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/network-protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/network-protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Network-Protocols"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Network-Protocols"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Network-Protocols</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DKIM (DomainKeys Identified Mail)</h2></header><div class=entry-content><p>DKIM (DomainKeys Identified Mail) DKIM은 이메일 인증을 위한 중요한 기술로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 발신자가 주장하는 도메인에서 보낸 것임을 확인할 수 있게 해준다.
디지털 서명을 사용하여 이메일의 무결성과 출처를 검증하는 방식으로 작동한다.
DKIM은 현대 이메일 인증의 핵심 구성 요소로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 주장하는 도메인에서 왔음을 보장한다. SPF 및 DMARC와 함께 사용할 때, DKIM은 피싱, 스푸핑 및 스팸으로부터 이메일 시스템을 보호하는 강력한 도구이다.
DKIM을 효과적으로 구현하려면 강력한 암호화 키, 적절한 서명 범위, 안전한 키 관리 및 정기적인 모니터링이 필요하다. 이러한 모범 사례를 따르면 이메일 보안을 강화하고 전달률을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-14 09:45:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DKIM (DomainKeys Identified Mail)" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/email-protocols/email-security/dkim/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DMARC (Domain-based Message Authentication, Reporting, and Conformance)</h2></header><div class=entry-content><p>DMARC (Domain-based Message Authentication, Reporting, and Conformance) DMARC는 이메일 인증 프로토콜로, SPF(Sender Policy Framework)와 DKIM(DomainKeys Identified Mail)을 기반으로 작동하는 포괄적인 이메일 보안 솔루션이다. 2012년에 공식적으로 도입된 DMARC는 도메인 소유자가 자신의 도메인에서 보내는 이메일을 보호하고, 다른 사람이 해당 도메인을 사칭하여 이메일을 보내는 것을 방지하는 메커니즘을 제공한다.
DMARC는 세 가지 핵심 기능을 제공한다:
인증 정책 설정: 도메인 소유자가 SPF 및 DKIM 인증이 실패할 경우 수신 서버가 어떻게 대응해야 하는지 명확한 지침을 제공할 수 있다. 정렬(Alignment) 확인: 이메일의 ‘From’ 헤더가 SPF 및 DKIM에서 인증된 도메인과 일치하는지 확인한다. 보고 기능: 도메인 소유자에게 자신의 도메인을 사용하여 전송된 모든 이메일(인증 성공 및 실패 모두)에 대한 상세한 보고서를 제공한다. DMARC의 중요성 DMARC는 현대 이메일 보안 인프라에서 다음과 같은 이유로 중요한 역할을 한다:
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DMARC (Domain-based Message Authentication, Reporting, and Conformance)" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/email-protocols/email-security/dmarc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain Keys</h2></header><div class=entry-content><p>Domain Keys 도메인 키(DomainKeys)는 이메일 발신자의 도메인을 확인하고 메시지 무결성을 보장하기 위해 설계된 이메일 인증 방법이다. 2004년 야후(Yahoo)에서 개발했으며, 현재 널리 사용되는 DKIM(DomainKeys Identified Mail)의 전신이라고 할 수 있다.
도메인 키는 이메일 보안의 중요한 이정표였으며, 현대 이메일 인증 기술 발전에 중요한 역할을 했다. 비록 현재는 DKIM으로 대체되었지만, 도메인 키가 도입한 공개 키 암호화 방식은 오늘날 이메일 인증의 핵심 원칙으로 남아있다. 이메일 사용자는 이러한 기술 덕분에 더욱 안전한 통신 환경을 누릴 수 있게 되었다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Keys" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/email-protocols/email-security/domain-keys/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Sender Policy Framework (SPF)</h2></header><div class=entry-content><p>Sender Policy Framework (SPF) SPF(Sender Policy Framework)는 이메일 스푸핑과 스팸을 방지하기 위해 설계된 이메일 인증 방법이다. 이메일 도메인 소유자가 어떤 메일 서버가 해당 도메인에서 이메일을 보낼 수 있는 권한이 있는지 지정할 수 있게 해주는 중요한 보안 메커니즘이다.
SPF의 기본 개념 SPF는 DNS(Domain Name System) TXT 레코드를 통해 구현된다.
도메인 소유자는 DNS에 특별한 TXT 레코드를 추가하여 해당 도메인에서 이메일을 보낼 수 있는 권한이 있는 메일 서버의 IP 주소 목록을 지정한다.
이메일을 받는 서버는 발신자의 도메인에 대한 SPF 레코드를 확인하고, 이메일이 실제로 권한이 있는 서버에서 왔는지 검증한다. 이 과정을 통해 누군가가 여러분의 도메인을 사칭하여 이메일을 보내는 것을 방지할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Sender Policy Framework (SPF)" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/email-protocols/email-security/spf/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이메일 필터링 방식: White Listing vs. Grey Listing</h2></header><div class=entry-content><p>이메일 필터링 방식: White Listing vs. Grey Listing 이메일 시스템에서 스팸과 악성 메시지를 필터링하는 다양한 방법이 있다.
그중에서도 화이트리스팅(White Listing)과 그레이리스팅(Grey Listing)은 서로 다른 접근 방식을 취하는 필터링 기술이다. 이 두 방식은 각각 고유한 장단점을 가지고 있으며, 이메일 시스템의 보안과 사용성 사이의 균형을 맞추는 데 중요한 역할을 한다.
화이트리스팅(White Listing) 화이트리스팅은 명시적으로 신뢰할 수 있는 엔티티(IP 주소, 이메일 주소, 도메인 등)의 목록을 작성하고, 이 목록에 포함된 엔티티만 접근을 허용하는 보안 방식이다.
화이트리스트에 없는 모든 것은 기본적으로 차단된다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이메일 필터링 방식: White Listing vs. Grey Listing" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/email-protocols/email-security/white-listing-vs-grey-listing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교</h2></header><div class=entry-content><p>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교 멱등성과 안전한 메서드는 HTTP 메서드의 중요한 특성으로, 서버의 상태 변화와 관련이 있다.
멱등성(Idempotency)은 동일한 요청을 여러 번 수행해도 서버의 상태가 동일하게 유지되는 특성을 말한다.
즉, 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 유지된다.
안전한 메서드(Safe Methods)는 서버의 상태를 변경하지 않는 HTTP 메서드를 의미한다.
이는 주로 리소스를 조회하는 용도로 사용되며, 서버의 데이터나 상태를 수정하지 않는다.
...</p></div><footer class=entry-footer><span title='2024-10-19 00:49:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/web-protocols/http/methods/idempotency-and-safe-methods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>안전한 메서드 (Safe Methods)</h2></header><div class=entry-content><p>안전한 메서드 (Safe Methods) 서버의 상태를 변경하지 않는 HTTP 메서드.
특징 리소스 변경 없음: 요청을 여러 번 보내도 서버의 상태가 동일하게 유지됩니다. 읽기 전용 작업: 주로 데이터를 조회하는 용도로 사용됩니다. 부작용 없음: 서버의 상태를 변경하지 않으므로 안전하게 여러 번 호출할 수 있습니다. 중요성 신뢰성: 클라이언트가 서버의 상태를 변경하지 않고 안전하게 정보를 요청할 수 있습니다. 캐싱 최적화: 안전한 메서드는 캐시하기에 적합하여 성능 향상에 도움이 됩니다. 사용자 경험: 브라우저가 안전한 메서드를 자유롭게 호출할 수 있어 프리페칭 등의 기능을 구현할 수 있습니다. 구현 방법 읽기 전용 로직: 안전한 메서드 구현 시 서버의 상태를 변경하지 않는 로직만 포함해야 합니다. 멱등성 보장: 안전한 메서드는 멱등성도 가져야 하므로, 여러 번 호출해도 동일한 결과를 반환하도록 구현합니다. 예외 처리: 안전한 메서드가 서버 상태를 변경하지 않도록 주의깊게 예외를 처리해야 합니다. 이점 성능 최적화: 안전한 메서드는 캐싱이 가능하여 네트워크 트래픽을 줄이고 응답 시간을 개선할 수 있습니다. 보안 강화: 데이터를 변경하지 않으므로 무단 수정이나 삭제의 위험이 없습니다. 확장성: 안전한 메서드는 프록시나 중간 계층에서 자유롭게 처리할 수 있어 시스템 확장성이 향상됩니다. HTTP 메서드별 안전성 GET: 안전한 메서드. 리소스를 조회하는 용도로 사용됩니다. HEAD: 안전한 메서드. GET과 유사하지만 헤더 정보만 반환합니다. OPTIONS: 안전한 메서드. 서버가 지원하는 메서드 정보를 반환합니다. POST: 안전하지 않은 메서드. 새로운 리소스를 생성하거나 데이터를 제출합니다. PUT: 안전하지 않은 메서드. 리소스를 생성하거나 대체합니다. DELETE: 안전하지 않은 메서드. 지정된 리소스를 삭제합니다. PATCH: 안전하지 않은 메서드. 리소스의 부분적인 수정에 사용됩니다.— 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 16:31:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 안전한 메서드 (Safe Methods)" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/web-protocols/http/methods/safe-methods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cookies</h2></header><div class=entry-content><p>Cookies HTTP 쿠키는 웹 서버가 사용자의 브라우저에 저장하는 작은 텍스트 데이터로, 사용자 세션 관리와 개인화된 경험 제공을 위해 설계되었다.
HTTP의 무상태(Stateless) 특성을 보완하여 연속적인 요청 간 상태 유지가 가능하게 한다.
정의 및 목적 데이터 저장 형식: 키=값 쌍으로 구성된 텍스트 파일. 동작 원리: 서버 → Set-Cookie 헤더로 브라우저에 전송. 브라우저 → 이후 요청 시 Cookie 헤더에 포함. 1 2 3 4 5 6 7 // 서버 응답 예시 HTTP/2.0 200 OK Set-Cookie: session_id=abc123; Secure; HttpOnly // 클라이언트 요청 예시 GET /dashboard HTTP/2.0 Cookie: session_id=abc123 주요 용도 용도 설명 예시 세션 관리 로그인 상태, 장바구니 정보 유지 온라인 쇼핑몰 결제 과정 개인화 언어 설정, 테마 저장 다크 모드 자동 적용 트래킹 사용자 행동 분석 및 광고 타겟팅 구글 애널리틱스 세션 관리: 1 2 3 4 5 6 7 8 9 10 // 로그인 세션 관리 app.post('/login', (req, res) => { // 사용자 인증 후 const sessionId = generateSessionId(); res.cookie('sessionId', sessionId, { httpOnly: true, secure: true, maxAge: 24 * 60 * 60 * 1000 // 24시간 }); }); 개인화: 1 2 3 4 // 사용자 선호도 저장 function saveUserPreference(theme) { document.cookie = `theme=${theme}; max-age=31536000; path=/`; } 트래킹: 1 2 3 4 5 6 // 방문자 추적 function trackPageVisit() { let visits = getCookie('visitCount') || 0; visits++; document.cookie = `visitCount=${visits}; max-age=31536000`; } 쿠키의 구성 요소 이름=값: 쿠키는 기본적으로 이름과 값의 쌍으로 이루어진 문자열. 만료 날짜(Expires) 또는 최대 수명(Max-Age): 쿠키의 유효 기간을 지정하며, 이 기간이 지나면 브라우저는 해당 쿠키를 삭제한다. 도메인(Domain)과 경로(Path): 쿠키가 적용될 도메인과 경로를 지정하여 특정 범위에서만 쿠키를 전송하도록 제한할 수 있다. 보안 속성: Secure 속성을 설정하면 쿠키는 HTTPS 연결에서만 전송되며, HttpOnly 속성을 설정하면 JavaScript와 같은 클라이언트 측 스크립트에서 쿠키에 접근할 수 없다. 주요 속성 속성 설명 예시 Name 쿠키의 이름 sessionId Value 쿠키의 값 abc123xyz Domain 쿠키가 유효한 도메인 .example.com Path 쿠키가 유효한 경로 / Expires/Max-Age 쿠키 만료 시간 Wed, 21 Oct 2024 Secure HTTPS에서만 전송 Secure HttpOnly JS에서 접근 불가 HttpOnly SameSite CSRF 방지 설정 Strict, Lax, None Name과 Value: 1 2 // 쿠키의 기본 구성 document.cookie = "username=John Doe"; // 이름=값 형태 Expires/Max-Age: 1 2 3 4 // 만료 시간 설정 document.cookie = "username=John Doe; expires=Thu, 18 Dec 2025 12:00:00 UTC"; // 또는 Max-Age 사용 document.cookie = "username=John Doe; max-age=3600"; // 1시간 후 만료 Domain과 Path: 1 2 // 특정 도메인과 경로에서만 사용 가능한 쿠키 document.cookie = "user=John; domain=example.com; path=/blog"; Secure와 HttpOnly: 1 2 3 4 // 보안 관련 설정 // Secure: HTTPS에서만 전송 // HttpOnly: JavaScript에서 접근 불가 response.setHeader('Set-Cookie', 'sessionId=abc123; Secure; HttpOnly'); 주요 유형별 특징 기본 분류 유형 저장 위치 수명 사용 사례 세션 쿠키 브라우저 메모리 브라우저 종료 시 삭제 로그인 세션 지속형 쿠키 디스크 Expires/Max-Age 지정 자동 로그인 서드파티 쿠키 타 도메인 설정 장기적 크로스 사이트 광고 트래킹 특수 쿠키 (보안 리스크) 슈퍼쿠키: 일반 삭제로 제거 불가능 플래시 쿠키: Adobe Flash 기반, 브라우저 외부 저장 좀비 쿠키: 삭제 후 자동 재생성 쿠키 작동 방식 쿠키 설정 과정 클라이언트가 웹사이트 방문 서버가 Set-Cookie 헤더로 쿠키 전송 브라우저가 쿠키 저장 이후 요청시 자동으로 쿠키 전송 쿠키 전송 과정 브라우저가 HTTP 요청 준비 유효한 쿠키 확인 Cookie 헤더에 쿠키 포함 서버로 요청 전송 쿠키 관리 및 보안 HTTP 쿠키의 보안 속성은 XSS(교차 사이트 스크립팅), CSRF(교차 사이트 요청 위조) 등 웹 공격을 방어하고 사용자 데이터를 보호하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-18 07:12:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cookies" href=https://buenhyden.github.io/posts/networking-and-communication/application-protocols/web-protocols/http/cookies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>서브넷팅 (Subnetting)</h2></header><div class=entry-content><p>서브넷팅 (Subnetting) 서브넷팅(Subnetting)은 네트워크를 더 작은 단위의 네트워크로 분할하는 기술이다.
이 기술은 IP 주소의 효율적인 사용과 네트워크 관리를 개선하기 위해 사용된다.
서브넷팅은 하나의 IP 클래스를 효율적으로 이용하기 위해 Host ID 구간을 분할하여 원래 정의된 Network ID와 함께 Network ID로 사용하는 네트워크 관리 기법이다.
서브넷팅을 통해 분할된 네트워크를 서브넷(Subnet)라고 한다.
주요 목적 IP 주소 낭비 방지 브로드캐스트 도메인의 크기 축소 네트워크 성능 향상 보안성 강화 서브넷팅의 장점 네트워크 관리 용이성 향상 고급 네트워크 보안 구현 가능 네트워크 트래픽 감소 ISP로부터 추가 IP 주소 요청 필요성 감소 서브넷 (Subnet) 서브넷은 ‘Sub Network’의 줄임말로, 더 큰 네트워크의 논리적인 부분집합을 의미한다.
이는 마치 큰 건물을 여러 개의 사무실로 나누는 것과 비슷한데, 각 사무실(서브넷)은 자신만의 공간을 가지면서도 전체 건물(네트워크)의 일부로 기능한다.
...</p></div><footer class=entry-footer><span title='2024-10-17 13:09:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 서브넷팅 (Subnetting)" href=https://buenhyden.github.io/posts/networking-and-communication/core-protocols/network-layer/internet-protocol/subnetting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>네트워크 주소 변환 (NAT, Network Address Translation)</h2></header><div class=entry-content><p>네트워크 주소 변환 (NAT, Network Address Translation) 네트워크 주소 변환(NAT, Network Address Translation)은 IP 패킷의 TCP/UDP 포트 번호와 소스 및 목적지의 IP 주소를 재기록하면서 라우터를 통해 네트워크 트래픽을 주고받는 기술이다.
NAT 를 이용하는 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함으로, 등록되지 않은 IP 주소를 사용하는 사설 IP 네트워크가 인터넷에 연결될 수 있도록 한다.
일반적으로 두 네트워크를 함께 연결하는 라우터에서 작동하며, 패킷이 다른 네트워크로 전달되기 전에 내부 네트워크의 비공개 (전역적으로 고유하지 않음) 주소를 올바른 주소로 변환한다.
...</p></div><footer class=entry-footer><span title='2024-10-17 13:07:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 주소 변환 (NAT, Network Address Translation)" href=https://buenhyden.github.io/posts/networking-and-communication/core-protocols/network-layer/internet-protocol/nat/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/network-protocols/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>