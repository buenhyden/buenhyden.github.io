<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm-Design-Techniques | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/algorithm-design-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/algorithm-design-techniques/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/algorithm-design-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/algorithm-design-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Algorithm-Design-Techniques"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Algorithm-Design-Techniques"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Algorithm-Design-Techniques</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Memoization vs Tabulation</h2></header><div class=entry-content><p>Memoization Vs Tabulation Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.
Memoization(메모이제이션)은 “하향식(Top-down)” 접근 방식이다.
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.
Tabulation(타뷸레이션)은 “상향식(Bottom-up)” 접근 방식이다.
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.
특성 Tabulation Memoization 접근 방식 Bottom-up (상향식) Top-down (하향식) 구현 방법 반복문 (Iterative) 재귀 (Recursive) 메모리 사용 문제 크기만큼 고정 필요한 만큼 동적 할당 실행 순서 순차적으로 모든 하위 문제 해결 필요한 하위 문제만 해결 공간 효율성 예측 가능하고 일정함 재귀 호출로 인한 스택 공간 필요 시간 효율성 모든 경우를 계산 필요한 경우만 계산 코드 복잡도 일반적으로 더 단순 일반적으로 더 복잡 캐시 활용 배열/테이블 형태 해시 테이블/맵 형태 구현 예시 비교 피보나치 수열 계산의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Tabulation 방식 def fib_tabulation(n): # 테이블 초기화 table = [0] * (n + 1) table[1] = 1 # 순차적으로 값 채우기 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n] # Memoization 방식 def fib_memoization(n, memo={}): # 이미 계산된 값이면 반환 if n in memo: return memo[n] # 기본 케이스 if n &lt;= 1: return n # 결과 저장 및 반환 memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo) return memo[n] 세부 특성 Tabulation Memoization 적합한 상황 모든 하위 문제의 결과가 필요한 경우 일부 하위 문제의 결과만 필요한 경우 디버깅 난이도 상대적으로 쉬움 재귀로 인해 더 어려움 최적화 가능성 공간 최적화 쉬움 재귀 깊이 제한으로 인한 제약 병렬화 가능성 쉬움 (독립적인 계산) 어려움 (의존성 있는 호출) 초기화 오버헤드 더 큼 (전체 테이블) 더 작음 (필요시 할당) 메모리 예측성 높음 낮음 (실행 중 변동) 성능 특성 Tabulation Memoization 시간 복잡도 O(n) - 모든 경우 O(n) - 최악의 경우 공간 복잡도 O(n) - 테이블 크기 O(n) - 캐시 + 스택 캐시 적중률 100% (모든 값 계산) 상황에 따라 다름 초기 지연 시간 더 김 (테이블 초기화) 더 짧음 (즉시 시작) 메모리 사용량 예측 가능 변동적 이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.
일반적으로:
...</p></div><footer class=entry-footer><span title='2024-10-13 11:25:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memoization vs Tabulation" href=https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모이제이션 (Memoization)</h2></header><div class=entry-content><p>메모이제이션 (Memoization) 메모이제이션은 “기억하다"라는 뜻의 라틴어 ‘memorandum’에서 유래했다.
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.
실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때
메모이제이션 미사용: 같은 단어가 나올 때마다 매번 사전을 찾음 메모이제이션 사용: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고
로 이해 가능하다. 메모이제이션의 작동 원리 함수가 호출될 때 입력값을 확인한다. 해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다. 저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 def memoized_function(n, memo={}): # 1. 이미 계산된 값인지 확인 if n in memo: return memo[n] # 2. 새로운 값 계산 result = ... # 계산 로직 # 3. 계산된 값을 저장 memo[n] = result # 4. 결과 반환 return result 메모이제이션의 장점 실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다. 자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다. 메모이제이션의 사용 예시 가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;547 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모이제이션 (Memoization)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;221 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 “무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.
특성 모든 가능성을 고려한다. 단순하고 직관적이다. 항상 정확한 해답을 찾는다. 목적과 필요성 복잡한 최적화 없이 문제를 해결하고자 할 때 사용한다. 다른 효율적인 알고리즘이 없거나 구현이 어려울 때 필요하다. 문제의 크기가 작을 때 빠르게 해결책을 찾을 수 있다. 장점 구현이 간단하다. 항상 최적의 해를 찾는다. 문제의 제약 조건이 까다로울 때 유용하다. 단점 시간 복잡도가 높다 (대부분의 경우 O(2^n) 또는 O(n!)). 큰 입력에 대해 비효율적이다. 메모리 사용량이 많을 수 있다. 작동 원리 가능한 모든 경우의 수를 생성한다. 각 경우에 대해 문제의 조건을 만족하는지 확인한다. 조건을 만족하는 경우를 해답으로 채택한다. 좋은 알고리즘의 조건 문제의 크기가 작을 때 효과적이다. 다른 알고리즘의 정확성을 검증하는 데 사용될 수 있다. 구현이 간단하고 버그가 적다. 효율적인 구현을 위한 팁 가능한 경우의 수를 줄이는 방법을 고려한다 (가지치기). 병렬 처리를 활용하여 성능을 개선할 수 있다. 메모이제이션을 사용하여 중복 계산을 줄인다. 핵심 구성 요소 후보 생성 함수 (generate_candidates) 유효성 검사 함수 (is_valid_solution) 반복문 또는 재귀를 통한 모든 경우의 수 탐색 실제 예시 코드 모든 가능한 비밀번호 조합을 생성하여 올바른 비밀번호를 찾는 함수
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>랜덤화 알고리즘 (Randomized Algorithm)</h2></header><div class=entry-content><p>랜덤화 알고리즘 (Randomized Algorithm) 랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다. 이 무작위성은 알고리즘의 동작이나 결정에 영향을 미치며, 같은 입력에 대해서도 매번 다른 결과를 낼 수 있다.
특성 무작위성: 알고리즘의 핵심 특성으로, 난수를 사용하여 결정을 내린다. 확률적 성능: 알고리즘의 성능이 확률적으로 분석된다. 다양성: 같은 입력에 대해 다양한 출력이 가능하다. 목적과 필요성 복잡한 문제의 간단한 해결책 제공 최악의 경우 성능 개선 결정론적 알고리즘의 한계 극복 평균 실행 시간 단축 장점 단순성: 복잡한 문제에 대해 간단한 해결책 제공 효율성: 많은 경우에 결정론적 알고리즘보다 빠름 유연성: 다양한 문제에 적용 가능 단점 결과의 일관성 부족: 같은 입력에 대해 다른 결과 가능 디버깅의 어려움: 무작위성으로 인해 재현이 어려울 수 있음 최악의 경우 보장 부족: 확률적 성능으로 인해 최악의 경우를 완전히 배제할 수 없음 작동 원리 문제 정의 무작위 선택 요소 식별 난수 생성기 사용 무작위 선택에 기반한 결정 결과 도출 및 분석 좋은 알고리즘의 조건 효율성: 평균적으로 좋은 성능을 보여야 함 정확성: 높은 확률로 정확한 결과를 제공해야 함 단순성: 구현과 이해가 쉬워야 함 확장성: 다양한 입력 크기에 대응할 수 있어야 함 효율적인 구현을 위한 팁 고품질의 난수 생성기 사용 무작위성의 적절한 활용 확률 분석을 통한 성능 최적화 병렬화 가능성 고려 핵심 구성 요소 난수 생성기 무작위 선택 메커니즘 결정 함수 종료 조건 실제 예시 랜덤화된 퀵 정렬 알고리즘
...</p></div><footer class=entry-footer><span title='2024-10-13 05:55:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;516 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 랜덤화 알고리즘 (Randomized Algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>근사 알고리즘 (Approximation algorithm)</h2></header><div class=entry-content><p>근사 알고리즘 (Approximation algorithm) 컴퓨터 과학에서 우리가 마주치는 많은 문제들 중에는 정확한 해답을 찾는 것이 현실적으로 매우 어려운 문제들이 있다.
예를 들어, 외판원 문제(Traveling Salesman Problem)는 도시들을 모두 한 번씩만 방문하면서 가장 짧은 경로를 찾는 문제인데, 도시의 수가 증가하면 가능한 모든 경로를 확인하는 데 너무 많은 시간이 걸린다.
이런 상황에서 우리는 다음과 같은 선택을 할 수 있다:
정확한 해답을 찾되 매우 오랜 시간이 걸리는 것을 감수한다 정확하지는 않지만 ‘충분히 좋은’ 해답을 빠르게 찾는다
근사 알고리즘은 두 번째 접근 방식을 택한다. 근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 ‘충분히 가까운’ 해답을 찾는 알고리즘이다.
여기서 중요한 점은 근사 알고리즘이 얼마나 좋은 해답을 찾을 수 있는지 수학적으로 보장한다는 것이다.
예를 들어, “이 알고리즘은 항상 최적해의 1.5배 이내의 해답을 찾는다"와 같이 성능을 보장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 근사 알고리즘 (Approximation algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 ‘되돌아가기’라는 의미를 가지고 있다.
백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.
이 알고리즘은 문제의 해결책을 찾기 위해 가능한 모든 경우의 수를 체계적으로 탐색하는 방법이다.
백트래킹의 핵심 아이디어는 다음과 같다:
해결책을 찾아가는 과정에서 여러 선택지를 순차적으로 시도한다. 현재의 선택이 해결책으로 이어질 가능성이 없다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다. 이 과정을 반복하여 최종적으로 해결책을 찾거나, 모든 가능성을 탐색한다. 백트래킹은 단순한 완전 탐색(Exhaustive Search)과는 다르다.
백트래킹은 현재의 선택이 유망한지(promising) 판단하여, 유망하지 않다면 더 이상 그 방향으로 탐색하지 않고 이전 단계로 돌아간다. 이를 ‘가지치기(pruning)‘라고 한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;682 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.
이 방법은 가능한 모든 해를 체계적으로 탐색하면서도 불필요한 탐색을 줄이는 것이 특징이다.
분기 한정법은 두 가지 주요 개념을 기반으로 한다:
분기(Branch): 문제를 더 작은 하위 문제로 나누는 과정. 한정(Bound): 각 하위 문제의 잠재적인 해결책의 품질을 평가하는 과정.
이 방법은 상태 공간 트리를 사용하여 모든 가능한 해결책을 체계적으로 탐색한다. 특성 분기(Branching): 문제를 더 작은 하위 문제로 나눈다. 각 분기는 겹치지 않는 부분 문제들을 만든다. 한정(Bounding): 각 하위 문제의 해의 범위를 추정한다. 상한(upper bound)과 하한(lower bound)을 계산한다. 유망하지 않은 분기는 더 이상 탐색하지 않는다. 가지치기(Pruning): 최적해가 될 수 없는 하위 문제를 제거한다. 상태 공간 트리(State Space Tree) 사용: 가능한 해들을 트리 구조로 표현한다. 목적과 필요성 분기 한정법의 주요 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;910 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>탐욕 알고리즘 (Greedy Algorithm)</h2></header><div class=entry-content><p>탐욕 알고리즘 (Greedy Algorithm) 탐욕 알고리즘(Greedy Algorithm)은 최적화 문제를 해결하기 위한 간단하면서도 강력한 알고리즘 설계 기법이다.
문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다.
즉, ‘탐욕적’으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.
특성 근시안적 선택: 현재 상황에서 가장 좋은 선택을 한다. 부분 최적해: 각 단계의 최적해가 전체 문제의 최적해로 이어질 것이라고 가정한다. 되돌아가지 않음: 한 번 선택한 것을 번복하지 않는다. 목적과 필요성 탐욕 알고리즘의 주요 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;547 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 탐욕 알고리즘 (Greedy Algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>분할 정복 (Divide and Conquer)</h2></header><div class=entry-content><p>분할 정복 (Divide and Conquer) 분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.
분할 정복은 주어진 문제를 다음과 같은 세 단계로 해결한다:
분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다. 정복(Conquer): 하위 문제들을 재귀적으로 해결한다. 결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해답을 얻는다. Source: https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm/
특성 재귀적 접근: 문제를 더 작은 동일한 유형의 하위 문제로 나누어 해결한다. 분할 가능성: 문제가 더 작은 하위 문제로 자연스럽게 나누어질 수 있어야 한다. 하위 문제 독립성: 각 하위 문제는 독립적으로 해결될 수 있어야 한다. 목적과 필요성 분할 정복의 주요 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-13 05:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;483 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분할 정복 (Divide and Conquer)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>