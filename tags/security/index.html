<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Security | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/security/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/security/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/security/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/security/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Security"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Security"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Security</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CCE vs CVE vs CWE</h2></header><div class=entry-content><p>CCE Vs CVE Vs CWE CCE, CVE, CWE는 모두 컴퓨터 시스템과 소프트웨어의 보안 취약점을 식별하고 분류하기 위한 표준화된 체계이다.
이 세 가지 개념은 각각 다른 측면의 보안 취약점을 다루고 있다.
구분 CCE (Common Configuration Enumeration) CVE (Common Vulnerabilities and Exposures) CWE (Common Weakness Enumeration) 정의 시스템 보안 구성 문제를 식별하고 추적하기 위한 표준 명명 체계 공개된 사이버 보안 취약점에 대한 표준 식별자 시스템 소프트웨어/하드웨어 보안 취약점의 유형을 분류하는 표준 목록 주요 목적 보안 구성 설정의 표준화된 참조 제공 특정 보안 취약점의 고유한 식별과 추적 취약점의 유형과 원인에 대한 분류 체계 제공 식별자 형식 CCE-XXXX-X CVE-YYYY-NNNNN CWE-XXX 사용 범위 시스템 구성 및 설정 특정 제품의 구체적 취약점 취약점의 유형과 분류 주요 내용 - 구성 매개변수
- 권장 설정 값
- 구성 지침 - 취약점 설명
- 영향받는 시스템
- 해결 방안 - 취약점 유형
- 원인과 결과
- 완화 방법 구조 특징 - 플랫폼별 구성 항목
- 기술적 메커니즘
- 검증 기준 - 타임라인 기반
- 영향도 평가
- 참조 정보 - 계층적 구조
- 다중 뷰
- 관계 정의 주요 활용 - 보안 구성 관리
- 컴플라이언스 점검
- 시스템 강화 - 취약점 관리
- 패치 관리
- 위험 평가 - 보안 설계
- 코드 리뷰
- 취약점 분석 관리 주체 NIST MITRE MITRE 업데이트 주기 새로운 구성 항목 발견 시 새로운 취약점 발견 시 정기적 업데이트 연관 표준 - SCAP
XCCDF
OVAL - CVSS
NVD
SCAP - CVE
CAPEC
SANS Top 25 주요 이점 - 구성 표준화
- 자동화 지원
- 감사 효율성 - 취약점 추적
- 명확한 의사소통
- 위험 관리 - 체계적 분류
- 원인 분석
- 예방 가이드 한계점 - 플랫폼 의존성
- 구성 복잡성
- 업데이트 지연 - 공개된 취약점만 포함
- 시간 지연
- 상세도 차이 - 추상적 성격
- 복잡한 분류
- 실제 적용 어려움 이러한 세 가지 표준은 각각 다른 관점에서 보안 취약점을 다루며, 서로 보완적인 관계를 가지고 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 07:53:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;326 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE vs CVE vs CWE" href=https://buenhyden.github.io/til/2024/11/15/cce-vs-cve-vs-cwe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비대칭키 암호화 (Asymmetric Encryption)</h2></header><div class=entry-content><p>비대칭키 암호화 (Asymmetric Encryption) 비대칭키 암호화는 공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식.
장점:
키 분배가 용이하다 (공개키는 공개적으로 공유 가능) 높은 보안성을 제공한다. 디지털 서명 등 다양한 보안 기능 구현이 가능하다. 단점:
대칭키 암호화에 비해 처리 속도가 느리다. 더 많은 컴퓨팅 자원이 필요하다. 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes class AsymmetricEncryption: def __init__(self): # 키 쌍 생성 self.private_key = rsa.generate_private_key( public_exponent=65537, # 일반적으로 사용되는 공개 지수 key_size=2048 # 보안을 위한 충분한 키 크기 ) # 개인키로부터 공개키 추출 self.public_key = self.private_key.public_key() def encrypt_message(self, message): """공개키로 메시지 암호화""" encrypted = self.public_key.encrypt( message.encode(), padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return encrypted def decrypt_message(self, encrypted_message): """개인키로 메시지 복호화""" decrypted = self.private_key.decrypt( encrypted_message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return decrypted.decode() 주요 특징 키 분배 문제 해결: 안전하지 않은 채널에서도 키를 교환할 수 있다. 높은 보안성: 공개키가 노출되어도 개인키가 안전하면 전체 시스템이 안전하다. 디지털 서명 가능: 메시지의 무결성과 발신자 인증에 사용된다. 느린 처리 속도: 대칭키 암호화에 비해 연산 속도가 느리다. 작동 원리 공개키와 개인키라는 두 개의 키를 사용한다.
공개키로 암호화한 데이터는 개인키로만 복호화할 수 있다.
개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:22:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비대칭키 암호화 (Asymmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/asymmetric-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>해시 함수 (Hash Functions)</h2></header><div class=entry-content><p>해시 함수 (Hash Functions) 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
특징:
일방향성: 해시 값으로부터 원본 데이터를 복구하는 것이 계산상 불가능하다.
1 2 3 4 5 6 7 8 9 10 11 12 13 def demonstrate_one_way(): """해시 함수의 일방향성을 보여주는 함수""" class PasswordManager: def __init__(self): self.password_hash = None def set_password(self, password): # 비밀번호는 해시값으로만 저장 self.password_hash = create_hash(password) def verify_password(self, password): # 입력된 비밀번호의 해시값과 저장된 해시값 비교 return create_hash(password) == self.password_hash 결정성: 같은 입력에 대해 항상 같은 해시 값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:22:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1804 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 함수 (Hash Functions)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/hash-functions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>대칭키 암호화 (Symmetric Encryption)</h2></header><div class=entry-content><p>대칭키 암호화 (Symmetric Encryption) 대칭키 암호화는 동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식.
구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from cryptography.fernet import Fernet class SymmetricEncryption: def __init__(self): # 대칭키 생성 self.key = Fernet.generate_key() self.cipher_suite = Fernet(self.key) def encrypt(self, data): """데이터 암호화""" if isinstance(data, str): data = data.encode() return self.cipher_suite.encrypt(data) def decrypt(self, encrypted_data): """데이터 복호화""" decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode() # 사용 예시 encryptor = SymmetricEncryption() message = "Hello, World!" encrypted = encryptor.encrypt(message) decrypted = encryptor.decrypt(encrypted) 주요 특징 암호화와 복호화에 같은 키를 사용한다. 혼돈(confusion)과 확산(diffusion)의 원리를 이용하여 평문을 암호화한다. 주로 치환(substitution)과 순열(permutation) 연산을 포함한 라운드를 반복하는 구조로 설계된다. 데이터 변환 방식에 따라 블록 암호와 스트림 암호로 구분된다. 혼돈(confusion)과 확산(diffusion)의 원리 혼돈(confusion)
암호문과 키 사이의 관계를 숨기는 것.
키의 단일 비트 변화가 암호문의 많은 비트를 변화시킴.
주로 치환(substitution) 연산을 통해 달성. 확산(diffusion)
암호문과 평문 사이의 관계를 숨기는 것.
평문의 통계적 특성을 암호문 전체에 분산시킴.
주로 순열(permutation) 연산을 통해 달성. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def confusion_example(input_data, key): # 혼돈(Confusion) 예시: XOR 연산을 사용하여 입력 데이터와 키를 결합 # 각 문자를 키와 XOR 연산하여 암호화 return [chr(ord(char) ^ key) for char in input_data] def diffusion_example(input_data): # 확산(Diffusion) 예시: 간단한 순열 연산을 사용 # 입력 데이터를 뒤집어 확산 효과를 시뮬레이션 return input_data[::-1] # 예시 데이터와 키 input_data = "HELLO" key = 3 # 혼돈 적용 confused_data = confusion_example(input_data, key) # 확산 적용 diffused_data = diffusion_example(confused_data) # 결과 출력 print("원본 데이터:", input_data) print("혼돈 적용 후:", ''.join(confused_data)) print("확산 적용 후:", ''.join(diffused_data)) 라운드 반복 구조 치환과 순열 연산을 포함한 기본 구조(라운드)를 여러 번 반복하는 방식.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:21:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;806 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 대칭키 암호화 (Symmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/symmetric-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동형 암호화(Homomorphic Encryption)</h2></header><div class=entry-content><p>동형 암호화(Homomorphic Encryption) 동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술.
일반적인 암호화 방식에서는 데이터를 처리하기 위해서는 먼저 복호화를 해야 하지만, 동형 암호화에서는 암호화된 상태 그대로 데이터를 처리할 수 있다.
예를 들어, 두 개의 숫자 3과 4를 동형 암호화했다고 가정해보자.
이 암호화된 값들을 더하면, 그 결과를 복호화했을 때 7(즉, 3+4)이 나오게 된다.
동형 암호화의 종류 부분 동형 암호화(Partial Homomorphic Encryption, PHE):
하나의 연산만 지원(덧셈 또는 곱셈).
- 대표적인 예로 Paillier 암호화(덧셈 지원)와 RSA(곱셈 지원)가 있다.
- 구현이 비교적 간단하고 성능이 우수합니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:11:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;340 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동형 암호화(Homomorphic Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/homomorphic-encryption/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>양자 암호화(quantum cryptography)</h2></header><div class=entry-content><p>양자 암호화(quantum cryptography) 양자 암호화는 양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술.
전통적인 암호화가 수학적 복잡성에 기반한다면, 양자 암호화는 양자역학의 기본 법칙을 활용하여 이론적으로 해독이 불가능한 보안을 제공한다.
양자 암호화의 핵심 원리 양자 암호화의 가장 중요한 원리는 양자역학의 기본 특성들을 활용한다:
관측 효과: 양자 상태를 측정하면 그 상태가 변화한다. 이는 도청자가 통신을 엿들으려 할 때 필연적으로 흔적을 남기게 됨을 의미한다. 복제 불가능성: 양자 상태는 완벽하게 복제할 수 없다는 ‘양자 복제 불가 정리’를 기반으로 한다. 이는 도청자가 양자 정보를 완벽하게 복사할 수 없음을 보장한다. 중첩 상태: 양자는 동시에 여러 상태를 가질 수 있으며, 측정 전까지는 확률적인 상태로 존재한다. 이러한 특성은 암호키 생성에 활용된다. 양자 암호화의 구현 방식 양자키분배(Quantum Key Distribution, QKD)는 가장 대표적인 양자 암호화 구현 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:11:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 양자 암호화(quantum cryptography)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/quantum-cryptography/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:10:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session based Auth</h2></header><div class=entry-content><p>Session Based Auth Session based Authentication은 웹 애플리케이션에서 사용자의 인증 상태를 유지하는 전통적인 방법 서버 측에서 사용자의 인증 상태와 데이터를 관리하는 방식이다. 사용자가 로그인하면 서버는 고유한 세션 ID를 생성하고, 이와 관련된 사용자 정보를 서버의 메모리나 데이터베이스에 저장한다.
주요 장점 서버 제어
서버가 세션을 완전히 제어할 수 있어 필요할 때 즉시 세션을 무효화할 수 있습니다.
보안성
세션 데이터가 서버에 안전하게 보관되며, 클라이언트는 세션 ID만 가지고 있습니다.
사용 편의성
기존 웹 애플리케이션과의 호환성이 좋고, 구현이 상대적으로 단순합니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 11:30:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session based Auth" href=https://buenhyden.github.io/posts/security/authentication/session-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SAML</h2></header><div class=entry-content><p>SAML 웹 애플리케이션에서 사용자 인증과 권한 부여를 위한 개방형 표준 프로토콜.
SAML은 사용자가 하나의 로그인 자격 증명으로 여러 웹 애플리케이션에 접근할 수 있게 해주는 인증 메커니즘.
주로 기업 환경에서 단일 로그인(SSO) 구현에 사용된다.
장점 통합 인증(SSO) 지원으로 사용자 편의성 향상 표준화된 XML 기반 프로토콜로 상호운용성 보장 강력한 보안 기능 제공 다양한 인증 방식 지원 주요 구성 요소 아이덴티티 제공자(IdP) 사용자 인증을 수행하고 인증 정보를 서비스 제공자에게 전달합니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class IdentityProvider: def __init__(self): self.private_key = load_private_key() self.certificate = load_certificate() def create_assertion(self, user_data): """SAML Assertion 생성""" assertion = { "issuer": "https://idp.example.com", "subject": user_data["username"], "attributes": { "email": user_data["email"], "role": user_data["role"] }, "conditions": { "notBefore": datetime.utcnow(), "notOnOrAfter": datetime.utcnow() + timedelta(minutes=5) } } return self.sign_assertion(assertion) 서비스 제공자(SP) IdP로부터 받은 인증 정보를 신뢰하고 사용자에게 서비스를 제공합니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 11:25:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;570 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML" href=https://buenhyden.github.io/posts/security/authentication/saml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Basic Authentication</h2></header><div class=entry-content><p>Basic Authentication 이 인증 방식은 HTTP 프로토콜에 내장된 가장 기본적인 인증 메커니즘.
HTTP 헤더에 사용자의 인증 정보를 포함시켜 전송하는 방식
다음과 같은 경우에는 사용을 피해야 한다.
공개 웹사이트 사용자 계정 시스템 전자상거래 사이트 소셜 미디어 중요한 데이터 금융 정보 개인정보 의료 기록 높은 보안이 필요한 API 결제 시스템 인증 서비스 중요 비즈니스 로직 인증 과정 클라이언트가 보호된 리소스에 접근을 시도합니다.
서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 전송합니다.
1 2 HTTP/1.1 401 Unauthorized WWW-Authenticate: Basic realm="Access to the staging site" 클라이언트는 사용자명과 비밀번호를 base64로 인코딩하여 Authorization 헤더에 포함시켜 다시 요청을 보냅니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 11:24:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;432 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Basic Authentication" href=https://buenhyden.github.io/posts/security/authentication/basic-authentication/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/security/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>