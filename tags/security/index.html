<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Security | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/security/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/security/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/security/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/security/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Security"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Security"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Security</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CCE vs CVE vs CWE</h2></header><div class=entry-content><p>CCE vs. CVE vs. CWE CCE, CVE, CWE는 모두 컴퓨터 시스템과 소프트웨어의 보안 취약점을 식별하고 분류하기 위한 표준화된 체계이다.
이 세 가지 개념은 각각 다른 측면의 보안 취약점을 다루고 있다.
구분 CCE (Common Configuration Enumeration) CVE (Common Vulnerabilities and Exposures) CWE (Common Weakness Enumeration) 정의 시스템 보안 구성 문제를 식별하고 추적하기 위한 표준 명명 체계 공개된 사이버 보안 취약점에 대한 표준 식별자 시스템 소프트웨어/하드웨어 보안 취약점의 유형을 분류하는 표준 목록 주요 목적 보안 구성 설정의 표준화된 참조 제공 특정 보안 취약점의 고유한 식별과 추적 취약점의 유형과 원인에 대한 분류 체계 제공 식별자 형식 CCE-XXXX-X CVE-YYYY-NNNNN CWE-XXX 사용 범위 시스템 구성 및 설정 특정 제품의 구체적 취약점 취약점의 유형과 분류 주요 내용 - 구성 매개변수
- 권장 설정 값
- 구성 지침 - 취약점 설명
- 영향받는 시스템
- 해결 방안 - 취약점 유형
- 원인과 결과
- 완화 방법 구조 특징 - 플랫폼별 구성 항목
- 기술적 메커니즘
- 검증 기준 - 타임라인 기반
- 영향도 평가
- 참조 정보 - 계층적 구조
- 다중 뷰
- 관계 정의 주요 활용 - 보안 구성 관리
- 컴플라이언스 점검
- 시스템 강화 - 취약점 관리
- 패치 관리
- 위험 평가 - 보안 설계
- 코드 리뷰
- 취약점 분석 관리 주체 NIST MITRE MITRE 업데이트 주기 새로운 구성 항목 발견 시 새로운 취약점 발견 시 정기적 업데이트 연관 표준 - SCAP
XCCDF
OVAL - CVSS
NVD
SCAP - CVE
CAPEC
SANS Top 25 주요 이점 - 구성 표준화
- 자동화 지원
- 감사 효율성 - 취약점 추적
- 명확한 의사소통
- 위험 관리 - 체계적 분류
- 원인 분석
- 예방 가이드 한계점 - 플랫폼 의존성
- 구성 복잡성
- 업데이트 지연 - 공개된 취약점만 포함
- 시간 지연
- 상세도 차이 - 추상적 성격
- 복잡한 분류
- 실제 적용 어려움 이러한 세 가지 표준은 각각 다른 관점에서 보안 취약점을 다루며, 서로 보완적인 관계를 가지고 있다.
...</p></div><footer class=entry-footer><span title='2024-11-07 07:53:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE vs CVE vs CWE" href=https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce-vs-cve-vs-cwe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DKIM (DomainKeys Identified Mail)</h2></header><div class=entry-content><p>DKIM (DomainKeys Identified Mail) DKIM은 이메일 인증을 위한 중요한 기술로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 발신자가 주장하는 도메인에서 보낸 것임을 확인할 수 있게 해준다.
디지털 서명을 사용하여 이메일의 무결성과 출처를 검증하는 방식으로 작동한다.
DKIM은 현대 이메일 인증의 핵심 구성 요소로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 주장하는 도메인에서 왔음을 보장한다. SPF 및 DMARC와 함께 사용할 때, DKIM은 피싱, 스푸핑 및 스팸으로부터 이메일 시스템을 보호하는 강력한 도구이다.
DKIM을 효과적으로 구현하려면 강력한 암호화 키, 적절한 서명 범위, 안전한 키 관리 및 정기적인 모니터링이 필요하다. 이러한 모범 사례를 따르면 이메일 보안을 강화하고 전달률을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-14 09:45:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DKIM (DomainKeys Identified Mail)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dkim/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DMARC (Domain-based Message Authentication, Reporting, and Conformance)</h2></header><div class=entry-content><p>DMARC (Domain-based Message Authentication, Reporting, and Conformance) DMARC는 이메일 인증 프로토콜로, SPF(Sender Policy Framework)와 DKIM(DomainKeys Identified Mail)을 기반으로 작동하는 포괄적인 이메일 보안 솔루션이다. 2012년에 공식적으로 도입된 DMARC는 도메인 소유자가 자신의 도메인에서 보내는 이메일을 보호하고, 다른 사람이 해당 도메인을 사칭하여 이메일을 보내는 것을 방지하는 메커니즘을 제공한다.
DMARC는 세 가지 핵심 기능을 제공한다:
인증 정책 설정: 도메인 소유자가 SPF 및 DKIM 인증이 실패할 경우 수신 서버가 어떻게 대응해야 하는지 명확한 지침을 제공할 수 있다. 정렬(Alignment) 확인: 이메일의 ‘From’ 헤더가 SPF 및 DKIM에서 인증된 도메인과 일치하는지 확인한다. 보고 기능: 도메인 소유자에게 자신의 도메인을 사용하여 전송된 모든 이메일(인증 성공 및 실패 모두)에 대한 상세한 보고서를 제공한다. DMARC의 중요성 DMARC는 현대 이메일 보안 인프라에서 다음과 같은 이유로 중요한 역할을 한다:
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DMARC (Domain-based Message Authentication, Reporting, and Conformance)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dmarc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain Keys</h2></header><div class=entry-content><p>Domain Keys 도메인 키(DomainKeys)는 이메일 발신자의 도메인을 확인하고 메시지 무결성을 보장하기 위해 설계된 이메일 인증 방법이다. 2004년 야후(Yahoo)에서 개발했으며, 현재 널리 사용되는 DKIM(DomainKeys Identified Mail)의 전신이라고 할 수 있다.
도메인 키는 이메일 보안의 중요한 이정표였으며, 현대 이메일 인증 기술 발전에 중요한 역할을 했다. 비록 현재는 DKIM으로 대체되었지만, 도메인 키가 도입한 공개 키 암호화 방식은 오늘날 이메일 인증의 핵심 원칙으로 남아있다. 이메일 사용자는 이러한 기술 덕분에 더욱 안전한 통신 환경을 누릴 수 있게 되었다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Keys" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/domain-keys/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Sender Policy Framework (SPF)</h2></header><div class=entry-content><p>Sender Policy Framework (SPF) SPF(Sender Policy Framework)는 이메일 스푸핑과 스팸을 방지하기 위해 설계된 이메일 인증 방법이다. 이메일 도메인 소유자가 어떤 메일 서버가 해당 도메인에서 이메일을 보낼 수 있는 권한이 있는지 지정할 수 있게 해주는 중요한 보안 메커니즘이다.
SPF의 기본 개념 SPF는 DNS(Domain Name System) TXT 레코드를 통해 구현된다.
도메인 소유자는 DNS에 특별한 TXT 레코드를 추가하여 해당 도메인에서 이메일을 보낼 수 있는 권한이 있는 메일 서버의 IP 주소 목록을 지정한다.
이메일을 받는 서버는 발신자의 도메인에 대한 SPF 레코드를 확인하고, 이메일이 실제로 권한이 있는 서버에서 왔는지 검증한다. 이 과정을 통해 누군가가 여러분의 도메인을 사칭하여 이메일을 보내는 것을 방지할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Sender Policy Framework (SPF)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/spf/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이메일 필터링 방식: White Listing vs. Grey Listing</h2></header><div class=entry-content><p>이메일 필터링 방식: White Listing vs. Grey Listing 이메일 시스템에서 스팸과 악성 메시지를 필터링하는 다양한 방법이 있다.
그중에서도 화이트리스팅(White Listing)과 그레이리스팅(Grey Listing)은 서로 다른 접근 방식을 취하는 필터링 기술이다. 이 두 방식은 각각 고유한 장단점을 가지고 있으며, 이메일 시스템의 보안과 사용성 사이의 균형을 맞추는 데 중요한 역할을 한다.
화이트리스팅(White Listing) 화이트리스팅은 명시적으로 신뢰할 수 있는 엔티티(IP 주소, 이메일 주소, 도메인 등)의 목록을 작성하고, 이 목록에 포함된 엔티티만 접근을 허용하는 보안 방식이다.
화이트리스트에 없는 모든 것은 기본적으로 차단된다.
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이메일 필터링 방식: White Listing vs. Grey Listing" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/white-listing-vs-grey-listing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Key Authentication</h2></header><div class=entry-content><p>API Key Authentication API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.
API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.
API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Key Authentication" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/security/api-key-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.
CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.
CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.
CORS의 작동 원리 브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다. 서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다. 브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다. Origin의 정의
Origin은 다음 세 가지 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/security/cors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mutual TLS</h2></header><div class=entry-content><p>Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutual TLS" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/security/mutual-tls/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth2/OIDC (OpenID Connect)</h2></header><div class=entry-content><p>OAuth2/OIDC (OpenID Connect) MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.
OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.
OAuth 2.0 OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth2/OIDC (OpenID Connect)" href=https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/architecture-patterns/microservices/security/oauth2-oidc/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/security/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>