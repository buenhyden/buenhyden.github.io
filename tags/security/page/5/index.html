<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Security | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/security/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/security/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/security/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/security/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Security"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Security"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Security</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication</h2></header><div class=entry-content><p>Token Authentication 사용자 자격 증명 대신 고유한 토큰을 사용하여 인증을 수행하며, 반복적인 로그인 없이 지속적인 접근을 가능하게 한다.
주요 특징 상태 비저장(Stateless):
서버는 토큰의 유효성만 검증하면 되므로, 세션 정보를 저장할 필요가 없습니다.
확장성:
여러 서버에서도 동일한 토큰으로 인증이 가능합니다.
보안:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TokenSecurity: def __init__(self): self.blacklisted_tokens = set() def revoke_token(self, token: str): """토큰 무효화""" self.blacklisted_tokens.add(token) def is_token_blacklisted(self, token: str): """토큰 블랙리스트 확인""" return token in self.blacklisted_tokens def rotate_token(self, old_token: str): """토큰 교체""" # 이전 토큰 무효화 self.revoke_token(old_token) # 새 토큰 발급 payload = token_auth.verify_token(old_token) return token_auth.create_access_token(payload) 토큰 구조 일반적으로 JWT(JSON Web Token) 형식을 사용합니다. 헤더, 페이로드, 서명으로 구성됩니다. 장점 향상된 보안: 자격 증명 노출 위험 감소 확장성: 서버 부하 감소 및 분산 시스템 지원 유연성: 다양한 플랫폼과 디바이스 간 호환성 단점 토큰 관리의 복잡성 토큰 탈취 위험 중앙 집중식 시스템에 대한 의존성 주요 구성 요소 토큰 생성 및 발급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class AuthenticationService: def __init__(self): self.token_auth = TokenAuth() async def authenticate_user(self, username: str, password: str): """사용자 인증 및 토큰 발급""" # 사용자 검증 user = await validate_user_credentials(username, password) if not user: raise HTTPException(status_code=401, detail="Invalid credentials") # 토큰 생성 access_token = self.token_auth.create_access_token( data={"sub": user.username, "role": user.role} ) return { "access_token": access_token, "token_type": "bearer" } 토큰 검증 및 보호된 리소스 접근 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_current_user(token: str = Depends(oauth2_scheme)): """현재 인증된 사용자 정보 획득""" credentials_exception = HTTPException( status_code=401, detail="Could not validate credentials", headers={"WWW-Authenticate": "Bearer"}, ) try: # 토큰 검증 payload = token_auth.verify_token(token) username = payload.get("sub") if username is None: raise credentials_exception # 사용자 정보 반환 return {"username": username, "role": payload.get("role")} except jwt.JWTError: raise credentials_exception 작동 원리 사용자가 자격 증명을 제공하여 로그인합니다. 서버는 자격 증명을 확인하고 유효한 경우 액세스 토큰을 생성합니다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킵니다. 서버는 각 요청마다 토큰을 검증하여 사용자를 인증합니다. 토큰 기반 인증의 모범 사례 토큰 만료 시간 설정:
...</p></div><footer class=entry-footer><span title='2024-11-11 11:24:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;600 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication" href=https://buenhyden.github.io/posts/security/authentication/token-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session base Auth and Cookie base Auth</h2></header><div class=entry-content><p>Session Base Auth and Cookie Base Auth 세션 기반 인증(Session Based Authentication)과 쿠키 기반 인증(Cookie Based Authentication)은 웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식이다.
두 용어는 종종 혼용되어 사용되지만, 정확히 말하면 서로 다른 개념으로, 쿠키 기반 인증은 클라이언트 측의 저장 메커니즘을 가리키는 반면, 세션 기반 인증은 서버 측의 상태 관리 방식을 의미한다.
실제로 대부분의 세션 기반 인증은 쿠키를 전송 수단으로 사용한다. 이것이 바로 이 두 용어가 자주 혼용되는 이유이다.
...</p></div><footer class=entry-footer><span title='2024-11-11 02:10:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session base Auth and Cookie base Auth" href=https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>암호화 알고리즘 (Encryption Algorithm)</h2></header><div class=entry-content><p>암호화 알고리즘 (Encryption Algorithm) 암호화는 평문(원본 데이터)을 암호문(암호화된 데이터)으로 변환하는 과정이다.
이 과정에서 특정 키를 사용하며, 이 키 없이는 암호문을 해독할 수 없도록 설계된다.
현대의 암호화 알고리즘은 수학적 원리를 기반으로 하여 매우 높은 수준의 보안을 제공한다.
특징 기밀성: 허가되지 않은 사용자가 데이터를 읽을 수 없도록 한다. 무결성: 데이터가 변조되지 않았음을 보장한다. 인증: 데이터의 출처를 확인할 수 있게 한다. 부인 방지: 송신자가 메시지 전송을 부인할 수 없게 한다. 주요 암호화 알고리즘 분류 대칭키 암호화 (Symmetric Key Encryption) 특징 동일한 키로 암호화와 복호화를 수행 빠른 처리 속도 비교적 단순한 구조 주요 알고리즘 AES (Advanced Encryption Standard) 가장 널리 사용되는 표준 암호화 알고리즘 128비트, 192비트, 256비트 키 크기 지원 높은 보안성과 효율성 활용: 금융 거래, 데이터 저장, 통신 보안 DES (Data Encryption Standard) 과거의 표준 암호화 알고리즘 56비트 키 사용 현재는 보안 강도가 낮아 권장되지 않음 역사적 중요성을 가짐 3DES (Triple DES) DES를 세 번 적용하여 보안성 강화 112비트 또는 168비트 키 사용 DES보다 안전하지만 속도가 느림 레거시 시스템에서 여전히 사용 비대칭키 암호화 (Asymmetric Key Encryption) 특징 공개키와 개인키 쌍을 사용 높은 보안성 키 교환 문제 해결 처리 속도가 상대적으로 느림 주요 알고리즘 RSA (Rivest-Shamir-Adleman) 가장 널리 사용되는 공개키 암호화 방식 소인수분해의 어려움을 기반으로 함 디지털 서명에도 사용 활용: SSL/TLS, 전자서명, 키 교환 ECC (Elliptic Curve Cryptography) 타원곡선의 수학적 특성을 이용 RSA보다 짧은 키로 동등한 보안성 제공 모바일 기기에 적합 활용: 모바일 보안, IoT 기기 해시 함수 (Hash Functions) 특징 단방향 암호화 고정된 길이의 출력 생성 충돌 저항성 주요 알고리즘 SHA (Secure Hash Algorithm) SHA-256, SHA-384, SHA-512 등 다양한 변형 높은 보안성 블록체인에서 널리 사용 활용: 패스워드 저장, 무결성 검증 MD5 (Message Digest Algorithm 5) 128비트 해시값 생성 현재는 취약점이 발견되어 보안용도로 권장되지 않음 무결성 검사에 제한적으로 사용 최신 트렌드와 미래 방향 양자 암호화
...</p></div><footer class=entry-footer><span title='2024-11-05 15:29:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;385 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 암호화 알고리즘 (Encryption Algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/encryption-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-05 13:10:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Nonce</h2></header><div class=entry-content><p>Nonce 암호학에서 사용되는 중요한 개념으로, “Number used Once"의 약자로 단 한 번만 사용되는 임의의 숫자를 의미한다.
일상적인 예시로 이해해보면, 은행에서 일회용 인증번호(OTP)를 보내는 것과 비슷하다. 매번 새로운 번호가 생성되고, 한 번 사용하고 나면 그 번호는 더 이상 유효하지 않다.
목적 재전송 공격 방지 같은 메시지가 반복해서 전송되는 것을 막기 위해 사용됩니다. 예를 들어, 누군가가 암호화된 통신을 가로채서 그대로 재전송하는 공격을 시도할 때, Nonce가 다르기 때문에 이전 메시지는 무효화됩니다. 초기화 벡터(IV)로서의 역할 암호화 과정에서 같은 평문이라도 매번 다른 암호문이 생성되도록 합니다. 이는 패턴 분석을 통한 공격을 어렵게 만듭니다. 해시 함수에서의 활용 예를 들어, 비트코인 채굴에서는 특정 조건을 만족하는 해시값을 찾기 위해 Nonce를 계속 변경해가며 시도합니다. 이것이 작업 증명(Proof of Work)의 핵심 메커니즘입니다. 고려해야 할 사항 예측 불가능성: Nonce는 무작위성이 보장되어야 합니다. 순차적인 번호는 예측이 가능하므로 보안에 취약할 수 있습니다. 충분한 길이: Nonce의 길이가 너무 짧으면 중복될 가능성이 높아집니다. 보통 64비트 이상을 권장합니다. 저장과 검증: 사용된 Nonce를 일정 기간 저장하고 중복 사용을 검사해야 합니다. 사용 사례 인증 프로토콜 OAuth나 JWT와 같은 인증 시스템에서 요청의 유효성을 검증하는데 사용됩니다. 암호화 통신 TLS/SSL 프로토콜에서 ‘Client Nonce’와 ‘Server Nonce’를 교환하여 세션 키를 생성합니다. 블록체인 채굴 과정에서 블록의 해시값을 조정하는데 사용됩니다. 데이터베이스 보안 같은 데이터의 중복 저장을 방지하거나, 데이터의 무결성을 검증하는데 활용됩니다. 주의사항 Nonce는 재사용되어서는 안 됩니다. 한 번 사용된 Nonce는 반드시 폐기해야 합니다. 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용해야 합니다. Nonce의 유효 기간을 적절히 설정하고 관리해야 합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-04 15:31:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;223 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Nonce" href=https://buenhyden.github.io/posts/security/cryptography/nonce/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/security/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/security/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>