<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QA | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/qa/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/qa/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/qa/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/qa/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="QA"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="QA"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>QA</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>호환성 테스트 (Compatibility Test)</h2></header><div class=entry-content><p>호환성 테스트 (Compatibility Test) 호환성 테스트는 소프트웨어가 다양한 하드웨어, 운영체제, 네트워크 환경 등에서 올바르게 작동하는지 확인하기 위해 수행되는 테스트이다.
특징과 목적 호환성 테스트의 주요 특징과 목적은 다음과 같다:
철저함: 다양한 환경에서 발생할 수 있는 문제를 찾아낸다. 확장성: 발견된 문제를 쉽게 재현하고 해결할 수 있어야 한다. 사용자 경험 보장: 모든 사용자가 비슷한 경험을 할 수 있도록 한다. 테스트 범위 호환성 테스트는 다음과 같은 범위를 포함한다:
하드웨어 호환성 소프트웨어 호환성 (운영체제, 브라우저 등) 네트워크 호환성 데이터베이스 호환성 수행 시점 호환성 테스트는 일반적으로 소프트웨어 개발의 후반부, 특히 알파 테스트와 베타 테스트 단계에서 수행된다.
...</p></div><footer class=entry-footer><span title='2024-11-12 03:27:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;472 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 호환성 테스트 (Compatibility Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/compatibility-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>스모크 테스트 (Smoke Test)</h2></header><div class=entry-content><p>스모크 테스트 (Smoke Test) 스모크 테스트는 소프트웨어의 가장 중요한 기능이 제대로 작동하는지 빠르게 확인하는 예비 테스트이다.
간단한 웹 애플리케이션의 스모크 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import requests import logging class WebAppSmokeTest: def __init__(self, base_url): self.base_url = base_url self.logger = logging.getLogger(__name__) def run_smoke_test(self): """기본 기능 스모크 테스트 실행""" test_results = { "homepage_access": self.test_homepage(), "login_page": self.test_login_page(), "basic_search": self.test_search_functionality(), "server_health": self.test_server_status() } # 테스트 결과 분석 failed_tests = [test for test, result in test_results.items() if result == False] if failed_tests: self.logger.error(f"스모크 테스트 실패: {failed_tests}") return False self.logger.info("모든 스모크 테스트 통과") return True def test_homepage(self): """홈페이지 접속 테스트""" try: response = requests.get(f"{self.base_url}/") return response.status_code == 200 except Exception as e: self.logger.error(f"홈페이지 접속 실패: {str(e)}") return False def test_login_page(self): """로그인 페이지 접속 테스트""" try: response = requests.get(f"{self.base_url}/login") return "로그인" in response.text except Exception as e: self.logger.error(f"로그인 페이지 접속 실패: {str(e)}") return False 특징과 목적 스모크 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-12 02:15:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1697 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스모크 테스트 (Smoke Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/smoke-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>기능 테스트 (Functional Test)</h2></header><div class=entry-content><p>기능 테스트 (Functional Test) 기능 테스트는 소프트웨어가 사용자의 요구사항을 충족하는지 확인하는 테스트 방법이다.
이는 시스템이 “무엇을 하는지"에 초점을 맞추며, 사용자 관점에서 소프트웨어의 기능을 검증한다.
간단한 온라인 쇼핑몰의 장바구니 기능 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import unittest from shopping_cart import ShoppingCart from product import Product class TestShoppingCartFunctionality(unittest.TestCase): def setUp(self): """테스트 준비: 장바구니와 상품 객체 생성""" self.cart = ShoppingCart() self.product1 = Product("노트북", 1000000, "전자기기") self.product2 = Product("마우스", 50000, "전자기기") def test_add_item_to_cart(self): """상품 추가 기능 테스트""" # 상품을 장바구니에 추가 self.cart.add_item(self.product1, 1) # 장바구니에 상품이 정확히 들어갔는지 확인 self.assertEqual(self.cart.item_count, 1) self.assertEqual(self.cart.total_price, 1000000) def test_remove_item_from_cart(self): """상품 제거 기능 테스트""" # 상품을 장바구니에 먼저 추가 self.cart.add_item(self.product1, 1) # 상품 제거 self.cart.remove_item(self.product1) # 장바구니가 비어있는지 확인 self.assertEqual(self.cart.item_count, 0) self.assertEqual(self.cart.total_price, 0) def test_update_item_quantity(self): """상품 수량 변경 기능 테스트""" # 상품 추가 후 수량 변경 self.cart.add_item(self.product1, 1) self.cart.update_quantity(self.product1, 2) # 수량과 총 가격이 올바르게 변경되었는지 확인 self.assertEqual(self.cart.get_item_quantity(self.product1), 2) self.assertEqual(self.cart.total_price, 2000000) 특징과 목적 사용자 중심: 실제 사용자의 관점에서 소프트웨어를 테스트한다. 요구사항 검증: 소프트웨어가 명세된 요구사항을 충족하는지 확인한다. 결함 발견: 소프트웨어의 기능적 오류를 찾아낸다. 품질 보증: 소프트웨어의 전반적인 품질을 향상시킨다. 테스트 범위 기능 테스트는 끝(브라우저)에서 끝(데이터베이스)까지 모든 구성 요소를 논리적으로 완전한 하나의 기능으로 다룬다.
이는 사용자 인터페이스부터 백엔드 시스템까지 전체 애플리케이션 스택을 포함한다.
...</p></div><footer class=entry-footer><span title='2024-11-12 02:14:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;479 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 기능 테스트 (Functional Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/functional-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>엔드투엔드 테스트(End-to-End Test, E2E Test)</h2></header><div class=entry-content><p>엔드투엔드 테스트(End-to-End Test, E2E Test) 엔드투엔드 테스트는 소프트웨어 시스템을 처음부터 끝까지 검증하는 테스트 방법이다.
이는 사용자의 관점에서 전체 애플리케이션의 흐름을 테스트하여 모든 구성 요소가 올바르게 작동하는지 확인한다.
온라인 쇼핑몰의 엔드투엔드 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # Selenium을 사용한 E2E 테스트 예시 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC class ShoppingMallE2ETest: def setUp(self): # 브라우저 실행 및 초기 설정 self.driver = webdriver.Chrome() self.driver.get("https://example-shop.com") def test_complete_purchase_flow(self): # 1. 로그인 self.login("test@example.com", "password123") # 2. 상품 검색 search_box = self.driver.find_element(By.ID, "search") search_box.send_keys("노트북") search_box.submit() # 3. 상품 선택 product = WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.CLASS_NAME, "product-item")) ) product.click() # 4. 장바구니 담기 add_to_cart = self.driver.find_element(By.ID, "add-to-cart") add_to_cart.click() # 5. 결제 진행 checkout_button = self.driver.find_element(By.ID, "checkout") checkout_button.click() # 6. 배송 정보 입력 self.fill_shipping_info({ "name": "홍길동", "address": "서울시 강남구", "phone": "010-1234-5678" }) # 7. 결제 완료 확인 confirmation = WebDriverWait(self.driver, 20).until( EC.presence_of_element_located((By.CLASS_NAME, "order-confirmation")) ) assert confirmation.is_displayed() # 8. 주문 내역 확인 order_number = confirmation.find_element(By.CLASS_NAME, "order-number").text assert len(order_number) > 0 특징과 목적 사용자 중심: 실제 사용자의 경험을 시뮬레이션한다. 전체 시스템 검증: 모든 구성 요소와 외부 종속성을 포함하여 테스트한다. 실제 환경 유사성: 프로덕션 환경과 유사한 조건에서 테스트를 수행한다. 테스트 범위 엔드투엔드 테스트는 다음과 같은 요소를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 02:14:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;573 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 엔드투엔드 테스트(End-to-End Test, E2E Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/end-to-end-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fakes</h2></header><div class=entry-content><p>Fakes Fakes는 Test Double 기법 중 하나로, 실제 객체의 간단한 구현을 제공하는 테스트용 객체.
목적 실제 구현체를 단순화하여 테스트 환경에서 사용한다. 외부 의존성을 제거하고 테스트 속도를 향상시킨다. 실제 객체와 유사한 동작을 제공하여 현실적인 테스트 환경을 구성한다. 장점 테스트 실행 속도가 빠르다. 실제 구현체보다 구성이 간단하다. 테스트 간 재사용이 용이하다. 실제 객체와 유사한 동작으로 신뢰성 있는 테스트가 가능하다. 단점 실제 구현체와 동작이 완전히 일치하지 않을 수 있다. Fake 객체 구현에 추가적인 시간과 노력이 필요하다. Fake 객체 자체의 유지보수가 필요할 수 있다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class RealDatabase: def connect(self): # 실제 데이터베이스 연결 로직 pass def fetch_data(self): # 실제 데이터 조회 로직 return "Real data" class FakeDatabase: def connect(self): # 연결 시뮬레이션 pass def fetch_data(self): # 가짜 데이터 반환 return "Fake data" class DataService: def __init__(self, database): self.database = database def get_data(self): self.database.connect() return self.database.fetch_data() # 테스트 fake_db = FakeDatabase() data_service = DataService(fake_db) result = data_service.get_data() assert result == "Fake data" JavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class RealDatabase { connect() { // 실제 데이터베이스 연결 로직 } fetchData() { // 실제 데이터 조회 로직 return "Real data"; } } class FakeDatabase { connect() { // 연결 시뮬레이션 } fetchData() { // 가짜 데이터 반환 return "Fake data"; } } class DataService { constructor(database) { this.database = database; } getData() { this.database.connect(); return this.database.fetchData(); } } // 테스트 const fakeDb = new FakeDatabase(); const dataService = new DataService(fakeDb); const result = dataService.getData(); console.assert(result === "Fake data"); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-11 21:17:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;300 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fakes" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/fakes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dummy Objects</h2></header><div class=entry-content><p>Dummy Objects 테스트 과정에서 실제로는 사용되지 않지만 메서드의 파라미터를 채우기 위해 전달되는 객체
Dummy Objects는 Test Double 기법 중 하나로, 테스트에 필요하지만 실제로 사용되지 않는 객체를 의미합니다.
목적 테스트 대상 코드의 인터페이스 요구사항을 충족시키기 위해 사용된다. 테스트 실행을 위해 필요하지만 테스트 자체와는 관련이 없는 객체를 대체한다. 장점 테스트 코드를 단순화하고 가독성을 높인다. 불필요한 객체 생성을 피해 테스트 성능을 향상시킨다. 테스트 대상 코드를 외부 의존성으로부터 격리시킨다. 단점 실제 객체의 동작을 정확히 반영하지 않을 수 있다. 과도한 사용 시 테스트의 현실성이 떨어질 수 있다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # 실제 이메일 서비스 클래스 class EmailService: def __init__(self, smtp_server, port): self.smtp_server = smtp_server self.port = port def send_notification(self, user, message): # 실제로는 이메일을 보내는 복잡한 로직이 있을 것입니다 print(f"Sending email to {user.email}: {message}") # 사용자 클래스 class User: def __init__(self, name, email, notification_service): self.name = name self.email = email self.notification_service = notification_service def notify_login(self): self.notification_service.send_notification( self, f"New login detected for {self.name}" ) # Dummy 객체 class DummyEmailService: def __init__(self, smtp_server=None, port=None): pass # 아무것도 하지 않음 def send_notification(self, user, message): pass # 아무것도 하지 않음 # 테스트 코드 def test_user_creation(): # Dummy 이메일 서비스 사용 dummy_email_service = DummyEmailService() # 실제로 테스트하고 싶은 것은 사용자 생성 로직입니다 user = User("John Doe", "john@example.com", dummy_email_service) assert user.name == "John Doe" assert user.email == "john@example.com" JavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 실제 로깅 서비스 클래스 class LoggerService { constructor(logLevel) { this.logLevel = logLevel; } log(message) { // 실제로는 로그를 저장하는 복잡한 로직이 있을 것입니다 console.log(`[${this.logLevel}] ${message}`); } } // 사용자 관리 클래스 class UserManager { constructor(logger) { this.logger = logger; this.users = []; } addUser(user) { this.users.push(user); this.logger.log(`User ${user.name} added`); return this.users.length; } } // Dummy 로거 class DummyLogger { constructor(logLevel) { // 아무것도 저장하지 않음 } log(message) { // 아무것도 하지 않음 } } // 테스트 코드 describe('UserManager', () => { it('should add a new user correctly', () => { // Dummy 로거 사용 const dummyLogger = new DummyLogger(); const userManager = new UserManager(dummyLogger); // 실제로 테스트하고 싶은 것은 사용자 추가 로직입니다 const userCount = userManager.addUser({ name: 'John' }); expect(userCount).toBe(1); expect(userManager.users.length).toBe(1); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-11 21:15:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dummy Objects" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/dummy-objects/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spies</h2></header><div class=entry-content><p>Spies Spies는 Test Double 기법 중 하나로, 실제 객체의 메서드 호출을 추적하고 기록하는 데 사용된다.
목적 메서드 호출 여부, 횟수, 전달된 인자 등을 검증한다. 실제 구현을 변경하지 않고 메서드의 동작을 관찰한다. 코드의 상호작용을 분석하고 테스트한다. 장점 비침투적: 실제 객체의 동작을 변경하지 않고 관찰할 수 있다. 유연성: 다양한 정보를 수집하고 검증할 수 있다. 상세한 검증: 메서드 호출의 세부 사항을 정확히 확인할 수 있다. 단점 복잡성: 과도한 사용 시 테스트 코드가 복잡해질 수 있다. 오버스펙: 구현 세부사항에 너무 의존적인 테스트를 작성할 위험이 있다. 성능: 많은 spy를 사용할 경우 테스트 실행 속도가 느려질 수 있다. 예시 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 from typing import Dict, Optional from datetime import datetime # 실제 데이터베이스 리포지토리 class UserRepository: def __init__(self, database_connection): self.db = database_connection def save(self, user_id: str, user_data: Dict): # 실제로는 데이터베이스에 SQL 쿼리를 실행할 것입니다 self.db.execute( "INSERT INTO users (id, data, created_at) VALUES (?, ?, ?)", [user_id, user_data, datetime.now()] ) def find_by_id(self, user_id: str) -> Optional[Dict]: # 실제로는 데이터베이스에서 조회할 것입니다 result = self.db.execute( "SELECT * FROM users WHERE id = ?", [user_id] ) return result.fetchone() # Fake 리포지토리 class FakeUserRepository: def __init__(self): # 데이터베이스 대신 딕셔너리를 사용 self.users: Dict[str, Dict] = {} def save(self, user_id: str, user_data: Dict): # 메모리에 직접 저장 self.users[user_id] = { 'data': user_data, 'created_at': datetime.now() } def find_by_id(self, user_id: str) -> Optional[Dict]: # 메모리에서 직접 조회 return self.users.get(user_id) # 사용자 서비스 class UserService: def __init__(self, user_repository): self.repository = user_repository def create_user(self, user_id: str, name: str, email: str): user_data = {'name': name, 'email': email} self.repository.save(user_id, user_data) def get_user(self, user_id: str): return self.repository.find_by_id(user_id) # 테스트 코드 def test_user_service(): # Fake 리포지토리 사용 fake_repository = FakeUserRepository() user_service = UserService(fake_repository) # 사용자 생성 테스트 user_service.create_user('user1', 'John Doe', 'john@example.com') # 사용자 조회 테스트 user = user_service.get_user('user1') assert user['data']['name'] == 'John Doe' assert user['data']['email'] == 'john@example.com' JavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 실제 외부 API 서비스 class WeatherService { async getTemperature(city) { // 실제로는 외부 API를 호출할 것입니다 const response = await fetch( `https://api.weather.com/${city}/temperature` ); return response.json(); } } // Fake 날씨 서비스 class FakeWeatherService { constructor() { // 미리 정의된 도시별 온도 데이터 this.temperatureData = { 'Seoul': { temperature: 25 }, 'New York': { temperature: 20 }, 'London': { temperature: 15 } }; } async getTemperature(city) { // 실제 API 호출 대신 저장된 데이터 반환 return Promise.resolve(this.temperatureData[city] || { temperature: 0 }); } } // 날씨 알림 서비스 class WeatherAlertService { constructor(weatherService) { this.weatherService = weatherService; } async shouldSendAlert(city) { const data = await this.weatherService.getTemperature(city); return data.temperature > 30; } } // 테스트 코드 describe('WeatherAlertService', () => { it('should not send alert for normal temperature', async () => { // Fake 날씨 서비스 사용 const fakeWeatherService = new FakeWeatherService(); const alertService = new WeatherAlertService(fakeWeatherService); const shouldAlert = await alertService.shouldSendAlert('Seoul'); expect(shouldAlert).toBe(false); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-11 21:15:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;560 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spies" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/spies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>부하 테스트(Load Testing)</h2></header><div class=entry-content><p>부하 테스트(Load Testing) 부하 테스트는 소프트웨어 시스템이 예상되는 사용자 부하 하에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
이는 실제 사용 환경과 유사한 조건에서 시스템의 성능을 평가한다.
특징과 목적 시스템의 최대 운영 용량 파악 성능 병목 현상 식별 확장성 및 안정성 검증 사용자 경험 개선 테스트 범위 부하 테스트는 다음과 같은 범위를 포함한다:
웹 애플리케이션 데이터베이스 시스템 네트워크 인프라 서버 리소스 (CPU, 메모리, 디스크 I/O) 수행 시점 부하 테스트는 주로 다음 시점에 수행된다:
...</p></div><footer class=entry-footer><span title='2024-11-11 14:24:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;349 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부하 테스트(Load Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/load-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>스트레스 테스트 (Stress Testing)</h2></header><div class=entry-content><p>스트레스 테스트 (Stress Testing) 스트레스 테스트는 소프트웨어 시스템을 극한의 조건에서 테스트하여 그 한계를 파악하는 성능 테스트의 한 유형이다.
이는 시스템이 정상적인 운영 범위를 넘어선 상황에서 어떻게 동작하는지를 평가한다.
웹 애플리케이션의 스트레스 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import time from locust import HttpUser, task, between class StressTestUser(HttpUser): wait_time = between(0.1, 0.5) # 매우 짧은 대기 시간 @task def stress_test_scenario(self): """극한 상황 시뮬레이션""" # 대용량 데이터 요청 with self.client.get("/api/products", params={"page_size": 1000}, catch_response=True) as response: # 응답 검증 if response.elapsed.total_seconds() > 5.0: response.failure("응답 시간 초과") elif response.status_code != 200: response.failure(f"에러 발생: {response.status_code}") # 시스템 복구 능력 테스트 time.sleep(0.1) # 잠시 대기 # 후속 요청으로 시스템 회복 확인 recovery_response = self.client.get("/api/health") assert recovery_response.status_code == 200 특징과 목적 스트레스 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-11 14:24:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;609 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스트레스 테스트 (Stress Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/stress-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Stubs</h2></header><div class=entry-content><p>Stubs Stubbing은 테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘
목적 의존성 격리: 실제 구현체로부터 테스트 대상을 분리하여 독립적인 테스트를 가능하게 합니다. 특정 시나리오 테스트: 다양한 상황에 대한 테스트를 용이하게 합니다. 미구현 코드 대체: 아직 개발되지 않은 부분을 임시로 대체할 수 있습니다. 테스트 속도 향상: 실제 리소스 접근 없이 빠른 테스트가 가능합니다. 특징 미리 정의된 응답(canned answer)을 제공합니다. 실제 코드의 동작을 단순화하여 모사합니다. 주로 상태 테스팅에 중점을 둡니다. 메서드 호출의 결과만 정의하며, 호출 여부는 검증하지 않습니다. 사용 사례 구현되지 않은 함수나 외부 라이브러리 함수를 사용할 때 복잡한 로직을 단순화하여 테스트하고자 할 때 특정 조건에서의 예외 상황을 테스트할 때 외부 의존성(예: 데이터베이스, 네트워크 요청)을 가진 코드를 테스트할 때 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from unittest.mock import Mock, patch import pytest from datetime import datetime # 테스트할 실제 클래스 class PaymentService: def __init__(self, payment_gateway): self.payment_gateway = payment_gateway def process_payment(self, amount): if amount &lt;= 0: raise ValueError("Amount must be positive") response = self.payment_gateway.charge(amount) if response['status'] == 'success': return True return False # 외부 결제 게이트웨이 클래스 (실제로는 외부 서비스) class PaymentGateway: def charge(self, amount): # 실제로는 외부 API를 호출하는 복잡한 로직 pass # Stub 예시 class PaymentGatewayStub: def charge(self, amount): # 항상 성공 응답을 반환하는 단순한 구현 return {'status': 'success', 'timestamp': datetime.now()} # 테스트 코드 def test_payment_service_with_stub(): # Stub 사용 gateway_stub = PaymentGatewayStub() payment_service = PaymentService(gateway_stub) assert payment_service.process_payment(100) == True Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // Jest를 사용한 테스트 예시 const { jest } = require('@jest/globals'); // 테스트할 실제 클래스 class UserService { constructor(database) { this.database = database; } async getUserById(id) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } return user; } async updateUserEmail(id, newEmail) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } user.email = newEmail; await this.database.updateUser(id, user); return user; } } // Stub 예시 class DatabaseStub { constructor() { this.users = new Map([ [1, { id: 1, name: 'John Doe', email: 'john@example.com' }], [2, { id: 2, name: 'Jane Doe', email: 'jane@example.com' }] ]); } async findUser(id) { return this.users.get(id); } async updateUser(id, userData) { this.users.set(id, userData); return userData; } } // 테스트 코드 describe('UserService', () => { // Stub을 사용한 테스트 describe('with stub', () => { const dbStub = new DatabaseStub(); const userService = new UserService(dbStub); test('should return user when exists', async () => { const user = await userService.getUserById(1); expect(user.name).toBe('John Doe'); }); test('should throw error when user not found', async () => { await expect(userService.getUserById(999)) .rejects .toThrow('User not found'); }); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-11 09:29:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stubs" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/stubs/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/qa/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/qa/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>