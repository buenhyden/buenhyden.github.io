<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QA | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/qa/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/qa/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/qa/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/qa/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="QA"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="QA"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>QA</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>감사(Audit)</h2></header><div class=entry-content><p>감사(Audit) 독립적인 검토자들이 소프트웨어 산출물과 프로세스를 체계적으로 검사하고 평가하는 공식적인 검토 과정이다.
이는 마치 회계 감사와 유사하게, 객관적인 기준에 따라 철저하게 검증하는 과정이다.
외부 또는 독립적인 감사자에 의해 수행되며, 주로 규정 준수와 품질 표준 충족 여부를 확인하는 데 중점을 둔다.
Audit의 주요 특징 공식성과 체계성
Audit은 가장 공식적인 검토 형태.
모든 과정이 문서화되며, 정해진 절차와 체크리스트에 따라 진행된다.
예를 들어:
1 2 3 4 5 6 7 8 Audit 계획서 1. 검토 범위: 사용자 인증 모듈 전체 2. 검토 일정: 2024.01.15 - 2024.01.19 3. 참여자 역할: - 주검토자: 김철수 (보안팀) - 부검토자: 이영희 (품질관리팀) - 기술지원: 박지민 (개발팀) 4. 검토 기준: ISO/IEC 27001 보안 표준 독립성
Audit을 수행하는 검토자들은 해당 프로젝트나 코드 개발에 직접 참여하지 않은 독립적인 인원들로 구성된다.
이는 객관적인 평가를 보장하기 위함이다.
...</p></div><footer class=entry-footer><span title='2024-10-29 07:09:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 감사(Audit)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/peer-review/formal-review/audit/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>페어 프로그래밍(Pair Programming)</h2></header><div class=entry-content><p>페어 프로그래밍(Pair Programming) 페어 프로그래밍에서는 두 명의 개발자가 서로 다른 역할을 맡는다.
‘드라이버(Driver)‘는 실제로 코드를 작성하는 사람이고, ‘네비게이터(Navigator)‘는 코드를 검토하고 방향을 제시하는 사람이다.
이 두 역할은 주기적으로 교대한다.
실제 페어 프로그래밍 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 페어 프로그래밍 세션 예시 // Driver가 코드를 작성하고, Navigator가 실시간으로 리뷰와 제안을 합니다 // Navigator: "사용자 등록 기능을 구현해볼까요? 먼저 입력값 검증부터 시작하는게 좋겠어요." // Driver: "네, 동의합니다. 사용자 이름과 이메일 유효성을 체크하는 메서드부터 작성할게요." public class UserRegistration { public boolean registerUser(String username, String email) { // Navigator: "null 체크도 필요할 것 같네요." // Driver: "네, 좋은 지적입니다. 추가하겠습니다." if (username == null || email == null) { return false; } // Navigator: "이메일 형식 검증도 필요할 것 같아요." // Driver: "이메일 정규식을 사용해서 검증하면 좋겠네요." if (!validateEmailFormat(email)) { return false; } // Navigator: "사용자 이름 길이 제한도 있어야 할 것 같아요." // Driver: "네, 최소 3자, 최대 20자로 제한하겠습니다." if (username.length() &lt; 3 || username.length() > 20) { return false; } // 실제 등록 로직 구현… return saveUser(username, email); } } 페어 프로그래밍의 주요 이점 실시간 코드 리뷰
두 명이 함께 작업하면서 즉각적인 피드백이 가능하다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:09:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페어 프로그래밍(Pair Programming)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/peer-review/informal-review/pair-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Inspection</h2></header><div class=entry-content><p>인스펙션 (inspection) 인스펙션(Inspection)은 정적 테스팅의 한 형태로, 가장 공식적이고 체계적인 리뷰 방법이다.
인스펙션은 FTR(Formal Technical Review)라고도 불리며, 정형화된 절차와 체크리스트를 사용하여 소프트웨어 산출물의 결함을 찾아내는 방법이다.
이는 정적 테스트 방법 중 가장 많은 인원이 참여하고 가장 공식적인 프로세스를 따른다.
주요 목적 결함 발견: 코드나 문서의 오류를 조기에 식별한다. 품질 향상: 소프트웨어 산출물의 전반적인 품질을 개선한다. 프로세스 개선: 개발 프로세스의 문제점을 파악하고 개선한다. 인스펙션 대상 인스펙션은 다음과 같은 소프트웨어 산출물에 적용된다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:08:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inspection" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/inspection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>관리 검토(Management Review)</h2></header><div class=entry-content><p>관리 검토(Management Review) 관리 검토는 소프트웨어 개발 프로젝트의 진행 상황, 목표 달성도, 리스크 등을 경영진과 프로젝트 관리자가 검토하는 공식적인 프로세스이다.
이는 기술적 세부사항보다는 프로젝트의 전반적인 상태와 비즈니스 목표 달성 여부에 초점을 맞춘다.
관리 검토의 주요 목적 프로젝트 현황 평가
프로젝트의 진행 상황을 검토하고 계획대로 진행되고 있는지 확인한다.
예를 들어:
1 2 3 4 1. 계획된 진행률 2. 실제 진행률 3. 현재 식별된 리스크 4. 예산 현황 비즈니스 목표 정렬성 확인
개발되고 있는 소프트웨어가 조직의 비즈니스 목표와 부합하는지 검토한다:
...</p></div><footer class=entry-footer><span title='2024-10-29 07:08:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 관리 검토(Management Review)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/peer-review/formal-review/management-review/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>기술 검토(Technical Review)</h2></header><div class=entry-content><p>기술 검토(Technical Review) 기술 검토는 소프트웨어의 기술적 측면을 전문가들이 체계적으로 평가하는 공식적인 검토 프로세스이다.
이는 코드의 품질, 아키텍처의 적절성, 기술적 의사결정의 타당성 등을 검증하는 과정이다.
마치 건축가들이 건물의 설계도를 검토하는 것과 유사하게, 소프트웨어 엔지니어들이 시스템의 기술적 측면을 심도 있게 검토한다.
기술 검토의 주요 목적 기술적 완성도 평가
시스템의 기술적 설계와 구현이 요구사항을 충족하는지 확인한다.
기술적 리스크 식별
잠재적인 기술적 문제점과 리스크를 조기에 발견한다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 기술 리스크 체크리스트 1. 성능 관련 □ 응답 시간 요구사항 충족 □ 확장성 고려사항 □ 리소스 사용 효율성 2. 보안 관련 □ 인증/인가 메커니즘 □ 데이터 암호화 □ 취약점 대응 방안 3. 유지보수성 □ 코드 모듈화 □ 문서화 수준 □ 테스트 용이성 기술 검토의 주요 영역 아키텍처 검토
시스템 구조의 적절성을 평가한다.
...</p></div><footer class=entry-footer><span title='2024-10-29 07:07:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 기술 검토(Technical Review)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/verification-and-validation/reviews/peer-review/formal-review/technical-review/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>코드 크기 메트릭(Lines of Code, LOC)</h2></header><div class=entry-content><p>코드 크기 메트릭(Lines of Code, LOC) 이 메트릭은 프로그램의 크기를 코드 라인 수로 표현하며, 소프트웨어 개발 프로젝트의 규모 추정, 생산성 측정, 품질 관리 등에 활용된다.
코드 크기는 다양한 방식으로 측정될 수 있으며, 각각의 측정 방식은 서로 다른 목적과 의미를 가진다.
특징과 기능 프로젝트 규모 추정: LOC는 소프트웨어 프로젝트의 크기를 추정하는 데 사용된다. 생산성 측정: 개발자나 팀의 생산성을 LOC를 기준으로 평가할 수 있다. 비용 산정: LOC를 기반으로 프로젝트 비용과 개발 노력을 추정할 수 있다. 복잡성 지표: 코드의 양이 많을수록 일반적으로 복잡성이 높아진다. 유형 물리적 코드 라인(Physical Lines of Code, LOC):
이는 가장 단순한 형태의 측정 방식으로, 파일의 전체 라인 수를 세는 것이다.
다음은 물리적 코드 라인의 예시입니다:
...</p></div><footer class=entry-footer><span title='2024-10-28 10:01:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코드 크기 메트릭(Lines of Code, LOC)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/quality-metrics/code-quality-metrics/lines-of-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>유지보수성 지수 (Maintainability Index)</h2></header><div class=entry-content><p>유지보수성 지수 (Maintainability Index) 유지보수성 지수는 코드를 얼마나 쉽게 유지보수할 수 있는지를 나타내는 0에서 100 사이의 수치이다.
이 지수가 높을수록 코드의 유지보수가 더 쉽다는 것을 의미한다.
유지보수성 지수의 계산 유지보수성 지수는 다음과 같은 요소들을 고려하여 계산된다:
Halstead Volume (HV): 코드의 복잡도를 수학적으로 계산한 값 Cyclomatic Complexity (CC): 코드의 논리적 복잡도 Lines of Code (LOC): 코드의 총 라인 수 주석 비율 (선택적) 기본적인 계산 공식은 다음과 같다:
$$ MI = MAX(0, (171 - 5.2 * ln(HV) - 0.23 * CC - 16.2 * ln(LOC)) * 100 / 171) $$
...</p></div><footer class=entry-footer><span title='2024-10-28 09:59:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 유지보수성 지수 (Maintainability Index)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/quality-metrics/code-quality-metrics/maintainability-index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>응집도(Cohesion)</h2></header><div class=entry-content><p>응집도(Cohesion) 응집도는 하나의 모듈이 얼마나 단일한 목적에 집중되어 있는지를 나타낸다.
모듈 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 측정하는 척도이다.
높은 응집도는 모듈이 하나의 명확한 책임을 가지고 있음을 의미하며, 이는 좋은 설계의 특징이다.
특징 및 기능 모듈의 독립성을 나타냄 유지보수성과 재사용성 향상에 기여 모듈의 품질을 평가하는 지표로 사용 응집도의 종류 낮은 응집도부터 높은 응집도 순
우연적 응집도(Coincidental Cohesion):
서로 관련 없는 기능들이 한 모듈에 모여있는 경우.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 우연적 응집도의 예 class Utility { public void calculateTax() { } public void formatDate() { } public void validateEmail() { } public void connectToDatabase() { } } // 개선된 버전 - 각 책임을 분리 class TaxCalculator { public void calculateTax() { } } class DateFormatter { public void formatDate() { } } class EmailValidator { public void validateEmail() { } } 논리적 응집도(Logical Cohesion):
논리적으로 비슷한 기능을 수행하지만 실제로는 다른 작업들을 하나의 모듈에서 처리하는 경우.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:58:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 응집도(Cohesion)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/quality-metrics/code-quality-metrics/cohesion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>코드 중복도 (Code Duplication)</h2></header><div class=entry-content><p>코드 중복도 (Code Duplication) 코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다.
중복된 코드는 유지보수를 어렵게 만들고, 버그 수정 시 여러 곳을 동시에 수정해야 하는 문제를 야기한다.
이는 일반적으로 바람직하지 않은 프로그래밍 관행으로 간주되며, 소프트웨어의 유지보수성과 확장성을 저해할 수 있다.
특징과 특성 유지보수 어려움: 중복된 코드는 변경 시 여러 곳을 동시에 수정해야 하므로 유지보수가 어려워진다. 버그 발생 가능성 증가: 한 곳의 수정을 다른 곳에 반영하지 않을 경우, 일관성이 깨지고 버그가 발생할 수 있다. 코드량 증가: 중복 코드는 전체 코드의 양을 증가시켜 가독성을 떨어뜨리고 디버깅을 어렵게 만든다. OCP(Open-Closed Principle) 위배: 중복 코드는 수정에 닫혀 있어야 한다는 SOLID 원칙에 위배된다. 중복 코드 감지 방법 수동 코드 리뷰: 개발팀이 협력하여 코드를 검토하고 중복을 식별한다. 코드 분석 도구 사용: SonarQube, PMD, ESLint 등의 도구를 활용하여 자동으로 중복 코드를 탐지한다. 버전 관리 시스템 활용: Git 등의 버전 관리 시스템을 통해 코드 변경 사항을 비교하여 중복을 식별한다. IDE 기능 활용: 대부분의 현대적인 IDE는 코드 중복을 찾는 기능을 내장하고 있다. 코드 중복의 유형 완전 중복(Exact Duplication):
동일한 코드가 그대로 복사되어 사용되는 경우.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:58:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코드 중복도 (Code Duplication)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/quality-metrics/code-quality-metrics/code-duplication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>결합도 (Coupling)</h2></header><div class=entry-content><p>결합도 (Coupling) 결합도는 서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표이다.
낮은 결합도는 모듈이 독립적이며 변경 시 다른 모듈에 미치는 영향이 적음을 의미한다.
모듈이란 클래스, 컴포넌트, 패키지 등 코드의 논리적 단위를 의미한다.
특징 및 기능 모듈 간 상호작용 정도를 나타냄 소프트웨어 구조의 품질을 평가하는 지표로 사용 유지보수성, 재사용성, 테스트 용이성에 영향을 미침 결합도의 종류 낮은 결합도부터 높은 결합도 순
내용 결합도(Content Coupling):
가장 강한 형태의 결합도로, 한 모듈이 다른 모듈의 내부 동작에 직접 관여하는 경우이다.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:54:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 결합도 (Coupling)" href=https://buenhyden.github.io/posts/quality-assurance-and-testing/quality-metrics/code-quality-metrics/coupling/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/qa/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/qa/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>