<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Principles on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/principles/</link>
    <description>Recent content in Principles on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.157.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 03:02:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Clean Code</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/code-quality/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/code-quality/clean-code/</guid>
      <description>클린 코드는 읽기 쉽고, 이해와 유지보수가 용이한 코드를 작성하는 원칙과 기법을 의미한다. 명확한 네이밍, 단순화, 일관성, 중복 최소화, 테스트 가능성 등 다양한 원칙을 통해 소프트웨어 품질과 개발 생산성을 높이며, 협업과 장기적인 유지보수에 큰 이점을 제공한다.</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
  </channel>
</rss>
