<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Principles on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/principles/</link>
    <description>Recent content in Principles on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 05:43:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/</link>
      <pubDate>Tue, 27 May 2025 07:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/</guid>
      <description>시스템 아키텍처와 소프트웨어 아키텍처 원칙들은 견고하고 유지보수 가능하며 확장 가능한 소프트웨어 시스템을 설계하기 위한 핵심 지침들로, SOLID 원칙, 관심사의 분리, 의존성 역전 등의 기본 원칙을 바탕으로 계층화 아키텍처, 클린 아키텍처, 마이크로서비스 아키텍처 등 다양한 패턴을 통해 복잡한 시스템의 설계와 구현을 체계적으로 지원한다.</description>
    </item>
    <item>
      <title>Architecture Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/</link>
      <pubDate>Sat, 21 Dec 2024 05:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/</guid>
      <description>아키텍처 원칙은 소프트웨어 시스템의 품질, 지속 가능성, 적응성을 보장하기 위한 근본적인 지침과 규칙의 집합으로, SOLID, DRY, KISS와 같은 설계 원칙부터 클라우드 네이티브, 마이크로서비스 원칙까지 다양한 측면을 포괄한다. 이러한 원칙들은 비즈니스 목표와 기술적 제약 사이의 균형을 맞추며, 일관된 설계 결정과 효과적인 커뮤니케이션을 통해 복잡한 시스템의 성공적인 구현과 진화를 가능하게 한다.</description>
    </item>
    <item>
      <title>Clean Code</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/clean-code/</guid>
      <description>클린 코드는 읽기 쉽고, 이해와 유지보수가 용이한 코드를 작성하는 원칙과 기법을 의미한다. 명확한 네이밍, 단순화, 일관성, 중복 최소화, 테스트 가능성 등 다양한 원칙을 통해 소프트웨어 품질과 개발 생산성을 높이며, 협업과 장기적인 유지보수에 큰 이점을 제공한다.</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>Programming Paradigms</title>
      <link>https://buenhyden.github.io/posts/programming-languages/programming-paradigms/</link>
      <pubDate>Sun, 22 Sep 2024 04:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/programming-paradigms/</guid>
      <description>코드를 효율적이고 유지보수가 용이하게 작성하기 위한 다양한 접근 방식</description>
    </item>
    <item>
      <title>Design Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/</link>
      <pubDate>Thu, 29 May 2025 03:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/</guid>
      <description>Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다.</description>
    </item>
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/dependency-inversion-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/dependency-inversion-principle/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/interface-segregation-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/interface-segregation-principle/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/liskov-substitution-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/liskov-substitution-principle/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/open-closed-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/open-closed-principle/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/single-responsibility-principle/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/single-responsibility-principle/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>Inversion of Control</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/</link>
      <pubDate>Tue, 03 Jun 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/</guid>
      <description>Inversion of Control(제어의 역전) 은 소프트웨어 구성 요소 간 결합도를 낮추고, 제어 흐름을 외부 프레임워크나 컨테이너에 위임함으로써 유연성, 확장성, 테스트 용이성을 높이는 설계 원칙이다. 주로 의존성 주입 (Dependency Injection) 등으로 구현되며, 모듈화와 유지보수성 향상에 핵심적 역할을 한다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>Convention over Configuration</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/convention-over-configuration/</link>
      <pubDate>Sat, 31 May 2025 07:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/convention-over-configuration/</guid>
      <description>Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다.</description>
    </item>
    <item>
      <title>GRASP</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/grasp/</link>
      <pubDate>Fri, 30 May 2025 12:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/grasp/</guid>
      <description>GRASP 는 객체지향 설계에서 객체와 클래스에 책임을 효과적으로 할당하기 위한 9 가지 실용적 설계 원칙의 집합이다.  Information Expert, Creator, Controller, Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations 로 구성되어 있으며 각 원칙은 객체의 역할, 책임, 협력, 결합도, 응집도 등 시스템의 구조적 품질을 높이기 위해 사용된다.</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
    <item>
      <title>Program Against Abstractions</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/program-against-abstractions/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/program-against-abstractions/</guid>
      <description>Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다.</description>
    </item>
    <item>
      <title>Composition Over Inheritance</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/composition-over-inheritance/</link>
      <pubDate>Tue, 04 Feb 2025 14:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/composition-over-inheritance/</guid>
      <description>&amp;#34;Composition Over Inheritance&amp;#34; 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 &amp;#34;is-a&amp;#34; 관계보다 &amp;#34;has-a&amp;#34; 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.</description>
    </item>
    <item>
      <title>Law of Demeter</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/law-of-demeter/</link>
      <pubDate>Tue, 04 Feb 2025 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/law-of-demeter/</guid>
      <description>Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 &amp;#39; 최소 지식의 원칙 &amp;#39; 이다.</description>
    </item>
    <item>
      <title>최적 부분 구조(Optimal Substructure)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/</link>
      <pubDate>Wed, 22 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/</guid>
      <description>최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.</description>
    </item>
    <item>
      <title>중복되는 하위 문제(Overlapping Subproblems)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/</link>
      <pubDate>Tue, 21 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/</guid>
      <description>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.</description>
    </item>
    <item>
      <title>Boundaries</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/boundaries/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/boundaries/</guid>
      <description>경계 (Boundaries) 는 소프트웨어 아키텍처에서 서로 다른 구성 요소 간의 분리선과 계약을 정의하는 핵심 원칙으로, 단일 책임 원칙과 느슨한 결합을 통해 시스템의 모듈성, 유지보수성, 확장성을 향상시키며, 도메인 주도 설계와 마이크로서비스 아키텍처에서 특히 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Component Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/component-principles/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/component-principles/</guid>
      <description>컴포넌트 원칙 (Component Principles)은 소프트웨어를 재사용 가능하고 독립적으로 배포할 수 있는 단위로 분할하는 아키텍처 설계 지침이다. 주요 원칙은 재사용/릴리즈 동등성, 공통 폐쇄, 공통 재사용, 안정적 의존성, 안정적 추상화 등으로, 시스템의 유지보수성, 확장성, 품질을 크게 높인다.</description>
    </item>
    <item>
      <title>Coupling and Cohesion</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/coupling-and-cohesion/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/coupling-and-cohesion/</guid>
      <description>커플링과 응집도는 소프트웨어 모듈 간의 상호의존성 정도와 모듈 내부 요소들의 기능적 연관성을 측정하는 핵심 설계 원칙이다. 낮은 커플링과 높은 응집도를 통해 유지보수가 용이하고 확장 가능한 시스템을 구축할 수 있으며, 이는 모든 우수한 소프트웨어 아키텍처의 기반이 된다.</description>
    </item>
    <item>
      <title>Policy vs. Detail</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/policy-vs-detail/</link>
      <pubDate>Sat, 21 Dec 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/policy-vs-detail/</guid>
      <description>Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다.</description>
    </item>
    <item>
      <title>Cloud Native Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/cloud-native-principles/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/cloud-native-principles/</guid>
      <description>클라우드 네이티브 원칙(Cloud Native Principles)는 클라우드 환경에서 애플리케이션을 설계하고 운영하는 핵심 원칙을 정의한다. 마이크로서비스, 컨테이너화, 불변 인프라, 선언적 API, 서비스 메시, 자동화 등을 통해 느슨하게 결합된 복원력 있는 시스템을 구현하여 비즈니스 민첩성과 운영 효율성을 극대화하는 아키텍처 접근법이다.</description>
    </item>
    <item>
      <title>Twelve-Factor App methodology</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/12-factor-app/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/architecture-principles/12-factor-app/</guid>
      <description>Twelve-Factor App Methodology 는 클라우드 환경에서 확장 가능하고 유지보수하기 쉬운 애플리케이션을 개발하기 위한 12 가지 원칙을 제시한다. 이 원칙들은 코드베이스 관리, 구성 설정, 종속성 선언 등 다양한 측면을 포괄하며, 현대 소프트웨어 개발의 모범 사례로 널리 채택되고 있다.</description>
    </item>
    <item>
      <title>KISS Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/kiss/</link>
      <pubDate>Mon, 23 Sep 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/kiss/</guid>
      <description>KISS(Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 불필요한 복잡성을 피하고, 가능한 한 단순하게 설계·구현하라는 설계 원칙이다. 이를 통해 코드의 가독성, 유지보수성, 확장성을 높이고, 오류 발생 가능성을 줄일 수 있다.</description>
    </item>
    <item>
      <title>YAGNI Principle</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/yagni/</link>
      <pubDate>Mon, 23 Sep 2024 00:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/yagni/</guid>
      <description>YAGNI 는 &amp;#34;You Ain&amp;#39;t Gonna Need It&amp;#34; 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/principles/design-principles/solid/</guid>
      <description>SOLID 는 객체지향 설계의 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 으로, 소프트웨어의 유지보수성과 확장성을 높이고 코드의 품질을 개선한다. 각 원칙은 단일 책임, 확장성, 대체 가능성, 인터페이스 분리, 의존성 역전을 강조한다.</description>
    </item>
  </channel>
</rss>
