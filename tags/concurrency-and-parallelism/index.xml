<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Concurrency-and-Parallelism on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/concurrency-and-parallelism/</link>
    <description>Recent content in Concurrency-and-Parallelism on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.150.0</generator>
    <language>en</language>
    <lastBuildDate>Mon, 04 Aug 2025 03:58:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/concurrency-and-parallelism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pessimistic vs. Optimistic Locking</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-strategy/pessimistic-vs-optimistic-locking/</link>
      <pubDate>Mon, 04 Aug 2025 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-strategy/pessimistic-vs-optimistic-locking/</guid>
      <description>Pessimistic과 Optimistic Locking은 데이터 무결성 보장을 위한 두 가지 대표 동시성 제어 전략이다. 전자는 충돌을 사전에 차단하고, 후자는 충돌 발생 시 검증한다. 충돌 빈도, 시스템 환경, 성능 요구에 따라 적절히 선택해야 한다.</description>
    </item>
    <item>
      <title>Lock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/lock/</link>
      <pubDate>Mon, 04 Aug 2025 03:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/lock/</guid>
      <description>Lock은 멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하여 상호 배제(Mutual Exclusion)를 보장하는 동기화 수단이다. 임계 구역 보호를 통해 원자성을 제공하며, 경쟁 조건(Race Condition)을 방지한다. Spin Lock, Mutex, Reentrant Lock 등 다양한 유형이 존재하며, 선택에 따라 성능과 안정성에 영향을 미친다.</description>
    </item>
    <item>
      <title>Concurrency Problems</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/</link>
      <pubDate>Wed, 21 May 2025 05:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/</guid>
      <description>Deadlock, Livelock, Race Condition, Starvation은 동시성 환경에서 발생하는 대표적인 병목 현상이다. 데드락은 자원 상호 점유로 인한 정지, 라이브락은 지속된 상태 변화에도 진전 없음, 레이스 컨디션은 타이밍 의존으로 인한 예측 불가, 기아 상태는 낮은 우선순위로 인한 무한 대기를 초래한다.</description>
    </item>
    <item>
      <title>Livelock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/livelock/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/livelock/</guid>
      <description>라이브락(Livelock)은 둘 이상의 스레드나 프로세스가 서로 상태 변화에 반응해 계속 동작하지만, 실제 작업은 전혀 진전되지 않는 동시성 문제. 데드락과 달리 블로킹 없이 실행되나 결과는 없음. 재시도 제한, 랜덤 백오프 등이 해결책.</description>
    </item>
    <item>
      <title>Race Condition</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/race-condition/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/race-condition/</guid>
      <description>**Race Condition(경쟁 상태)**은 두 개 이상의 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 실행 순서나 타이밍에 따라 결과가 달라지는 동시성 문제. 이는 동기화 부족으로 인해 발생하며, 데이터 불일치, 보안 취약성, 시스템 오류를 유발할 수 있다. 락, 세마포어, 동기화 블록 등으로 예방할 수 있다.</description>
    </item>
    <item>
      <title>Starvation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/starvation/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/starvation/</guid>
      <description>Starvation은 동시성 시스템에서 특정 프로세스나 스레드가 자원을 지속적으로 할당받지 못해 실행되지 않는 상태이다. 주로 우선순위 스케줄링, 자원 경합 등에서 발생하며 시스템의 공정성을 해친다. 에이징, 공정 락, 라운드 로빈 등으로 방지할 수 있다.</description>
    </item>
    <item>
      <title>Deadlock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/deadlock/</link>
      <pubDate>Tue, 20 May 2025 14:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/deadlock/</guid>
      <description>Deadlock(교착상태) 은 둘 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 현상으로, 시스템 전체 성능과 안정성에 큰 영향을 미치는 주요 동시성 문제다. 상호 배제, 점유와 대기, 비선점, 순환 대기라는 네 가지 필요조건이 동시에 성립할 때 발생하며, 시스템 성능 저하와 응답 불가 상태를 초래한다.</description>
    </item>
    <item>
      <title>Critical Section</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/critical-section/</link>
      <pubDate>Tue, 20 May 2025 14:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/critical-section/</guid>
      <description>**Critical Section**은 여러 실행 흐름이 동시에 공유 자원에 접근하는 것을 방지하기 위해 **오직 하나만 진입**할 수 있도록 설계된 코드 영역입니다. **Mutual Exclusion**을 통해 **데이터 일관성**과 **Race Condition 방지**를 보장하며, **mutex, semaphore, monitor, atomic operation** 등의 동기화 기법으로 제어합니다.</description>
    </item>
    <item>
      <title>Mutual Exclusion</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/mutual-exclusion/</link>
      <pubDate>Tue, 20 May 2025 14:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/mutual-exclusion/</guid>
      <description>**상호 배제(Mutual Exclusion)**는 여러 스레드나 프로세스가 공유 자원에 동시에 접근하지 못하도록 제어하여 데이터 일관성과 시스템 안정성을 보장하는 동시성 제어 기법이다. **임계 구역(Critical Section)**에 한 번에 하나의 실행 단위만 진입하도록 제한하며, **경쟁 상태(Race Condition)**를 방지한다. 구현에는 락(Lock), 세마포어(Semaphore), 뮤텍스(Mutex), 모니터(Monitor) 등이 사용되며, 분산 환경과 실시간 시스템에서도 필수적으로 활용된다.</description>
    </item>
    <item>
      <title>Concurrency and Parallelism</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/concurrency-vs-parallelism/</link>
      <pubDate>Sat, 05 Oct 2024 02:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/concurrency-vs-parallelism/</guid>
      <description>**동시성(Concurrency)**은 여러 작업을 시간적으로 겹치게 처리해 시스템 응답성과 자원 활용을 높이는 설계 방식이며, **병렬성(Parallelism)**은 여러 작업을 물리적으로 동시에 실행해 처리 성능을 극대화하는 실행 모델이다. 두 개념은 목적과 구현 수준이 다르며, I/O 바운드 작업에는 동시성이, CPU 바운드 작업에는 병렬성이 효과적이다.</description>
    </item>
    <item>
      <title>Mutex</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/mutex/</link>
      <pubDate>Fri, 04 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/mutex/</guid>
      <description>Mutex는 상호 배제(Mutual Exclusion)를 구현하는 동기화 도구로, 여러 스레드 또는 프로세스가 공유 자원에 동시에 접근하지 못하도록 제어한다. 임계 구역 보호를 통해 레이스 컨디션과 데이터 불일치를 방지하며, 락(lock)과 언락(unlock)을 통해 자원 접근을 순차적으로 보장한다. 스핀락, 블로킹, 재귀적 락 등 다양한 구현 기법과 우선순위 제어 정책이 존재한다.</description>
    </item>
    <item>
      <title>조건 변수 (Condition Variables)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/condition-variables/</link>
      <pubDate>Fri, 04 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/condition-variables/</guid>
      <description>조건 변수(Condition Variable)는 멀티스레드 환경에서 특정 조건이 충족될 때까지 스레드를 효율적으로 대기시키고, 조건 변화 시 신호를 보내 실행을 재개하는 동기화 기법이다. 반드시 뮤텍스와 함께 사용하며, 스푸리어스 웨이크업에 대비해 while 루프 조건 재검사가 필수이다. 생산자-소비자 등 다양한 패턴에서 활용된다.</description>
    </item>
    <item>
      <title>원자적 연산 (Atomic Operation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/atomic-operations/</link>
      <pubDate>Fri, 04 Oct 2024 10:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/atomic-operations/</guid>
      <description>원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/monitor/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/monitor/</guid>
      <description>모니터는 공유 데이터와 해당 데이터를 조작하는 연산을 하나의 모듈로 캡슐화하여, 다중 스레드 환경에서의 경쟁 조건(Race Condition)을 방지한다.</description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/semaphores/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/semaphores/</guid>
      <description>세마포어(Semaphore)는 멀티스레드·멀티프로세스 환경에서 공유 자원 접근을 제어하는 동기화 원시로, 카운터와 원자적 P(wait)·V(signal) 연산을 기반으로 동작한다. 이진·카운팅 방식이 있으며, 데드락·경쟁 조건 방지와 IPC, 임계 구역 관리 등 OS와 병렬 프로그래밍에서 폭넓게 활용된다.</description>
    </item>
    <item>
      <title>데커 알고리즘 (Dekker&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/dekkers-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/dekkers-algorithm/</guid>
      <description>데커 알고리즘(Dekker&amp;#39;s Algorithm)은 두 프로세스 간 상호 배제(Mutual Exclusion)를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.</description>
    </item>
    <item>
      <title>램포트의 빵집 알고리즘 (Lamport&#39;s Bakery Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/lamports-bakery-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/lamports-bakery-algorithm/</guid>
      <description>N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다</description>
    </item>
    <item>
      <title>피터슨 알고리즘 (Peterson&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/petersons-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/petersons-algorithm/</guid>
      <description>피터슨 알고리즘(Peterson&amp;#39;s Algorithm)은 두 프로세스의 상호 배제(Mutual Exclusion)를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.</description>
    </item>
  </channel>
</rss>
