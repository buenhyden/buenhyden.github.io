<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency-and-Parallelism | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/concurrency-and-parallelism/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/concurrency-and-parallelism/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/concurrency-and-parallelism/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/concurrency-and-parallelism/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concurrency-and-Parallelism"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concurrency-and-Parallelism"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Concurrency-and-Parallelism</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pessimistic vs. Optimistic Locking</h2></header><div class=entry-content><p>Pessimistic vs. Optimistic Locking Pessimistic Locking은 충돌을 우려해 먼저 락을 거는 방식으로, 데이터 무결성이 중요한 환경에서 적합하다. Optimistic Locking은 충돌 가능성이 낮다고 보고 사후 검증을 통해 일관성을 보장한다. 시스템 요구사항과 성능 특성에 따라 선택된다.
등장 배경 및 발전 과정 Pessimistic Locking은 초기 RDBMS + ACID 보장 요구에서 발전했으며, 충돌 회피를 위한 보수적 접근 방식이 정립되었으며, Optimistic Locking은 낮은 충돌 환경을 가정한 성능 중심 전략으로, 분산 시스템, 웹/모바일 기반 환경에서 발전해왔다.
...</p></div><footer class=entry-footer><span title='2025-08-04 03:58:00 +0000 UTC'>August 4, 2025</span>&nbsp;·&nbsp;40 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pessimistic vs. Optimistic Locking" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/basic-concepts/lock/pessimistic-vs-optimistic-locking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mutex</h2></header><div class=entry-content><p>Mutex **뮤텍스 (Mutex)**는 멀티스레드 및 멀티프로세스 환경에서 공유 자원에 대한 동시 접근을 제어하기 위한 핵심 동기화 프리미티브다. 임계 구역 (Critical Section) 에 한 번에 하나의 실행 흐름만 접근하도록 보장하며, 레이스 조건, 데이터 무결성 문제, 교착 상태 등을 예방한다. 스핀 락, 재귀 락, 슬립 락 등 다양한 구현 방식이 존재하며, 우선순위 상속, 데드락 회피, 우선순위 역전 대응 등 고급 기능도 지원된다. 현대 운영체제 및 프로그래밍 언어에서 폭넓게 활용되며, RW-lock, RCU, Lock-Free 구조 등이 대체 기법으로 함께 고려된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 11:00:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;42 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutex" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/synchronization-primitives/software-level/mutex/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조건 변수 (Condition Variable)</h2></header><div class=entry-content><p>조건 변수 (Condition Variable) 조건 변수 (Condition Variable) 는 멀티스레드 환경에서 스레드가 특정 조건이 충족될 때까지 Busy-wait 없이 대기하도록 하는 동기화 메커니즘이다.
반드시 뮤텍스와 함께 사용하여 조건 검사·변경의 원자성을 보장하며, 주요 연산은 wait()(대기), signal()/notify_one()(하나 깨움), broadcast()/notify_all()(모두 깨움) 이다.
대부분 Mesa-style 구현을 따르므로 깨어난 뒤 조건을 while 루프로 재검사해야 하며, 유령 깨움과 신호 손실 방지를 위해 상태 변경 후 락을 잡은 채 신호를 보내야 한다.
생산자 - 소비자, 이벤트 처리, 흐름 제어 등에서 필수적으로 활용되며, POSIX, C++, Java, Go 등 다양한 플랫폼에서 지원된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:54:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;68 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건 변수 (Condition Variable)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/synchronization-primitives/condition-synchronization/implementation-mechanisms/condition-variable/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>원자적 연산 (Atomic Operation)</h2></header><div class=entry-content><p>원자적 연산 (Atomic Operation) Atomic Operation (원자적 연산) – 현대 시스템의 동시성 핵심 1단계: 기본 분석 1. 대표 태그 생성 Concurrency-Control (동시성제어) Synchronization-Primitive (동기화프리미티브) Hardware-Level (하드웨어단) Data-Integrity (데이터무결성) 2. 분류 체계 검증 현 분류(Computer Science Fundamentals > Concurrency and Parallelism > Synchronization Primitives > Hardware Level)는 적합합니다. Atomic Operation(원자적 연산)은 동시성(Concurrency)과 병렬성(Parallelism)의 근간이 되는 하드웨어 단의 동기화 기본 요소(Synchronization Primitive)로, 시스템 아키텍처와 운영체제의 핵심적 위치를 갖습니다.13
3. 핵심 요약 Atomic Operation(원자적 연산)이란 여러 스레드가 경쟁적으로 자료를 다루는 환경에서, “불가분·순간적"으로 처리되어 그 실행 중간(Intermediate State)을 다른 스레드가 인식하지 못하는 연산을 의미합니다. 하드웨어 수준의 지원 덕분에 높은 신뢰성과 성능을 제공합니다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:48:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;126 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 원자적 연산 (Atomic Operation)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/synchronization-primitives/hardware-level/atomic-operation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Monitor</h2></header><div class=entry-content><p>Monitor 대표 태그 생성 Synchronization-Primitive Concurrency-Control Mutual-Exclusion 동작-메커니즘 대표 태그 생성 Synchronization-Primitive Thread-Safety Concurrency-Control High-Level-Abstraction 분류 체계 검증 현재 분류: “Computer Science Fundamentals > Concurrency and Parallelism > Synchronization Primitives > Software Level”
검증 결과: 적절한 분류입니다.
근거: 모니터 (Monitor)는 동시성 제어를 위한 소프트웨어 수준의 동기화 기법으로, 뮤텍스 (Mutex)와 조건 변수 (Condition Variables)를 결합한 고수준 추상화 메커니즘입니다. 운영체제나 하드웨어 수준이 아닌 프로그래밍 언어 차원에서 제공되는 동기화 구조이므로 Software Level 분류가 정확합니다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;98 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monitor" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/synchronization-primitives/software-level/monitor/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Semaphore</h2></header><div class=entry-content><p>Semaphore 세마포어 (Semaphore) 는 1965 년 에츠허르 W. 다이크스트라가 제안한 동기화 메커니즘으로, 멀티스레드·멀티프로세스 환경에서 공유 자원 접근을 제어한다.
내부 정수 카운터와 대기 큐를 관리하며, 원자적 연산인 P(wait/acquire) 와 V(signal/release) 를 통해 자원 사용 순서를 조율한다.
이진 세마포어 (Binary) 는 뮤텍스처럼 단일 접근을 보장하고, 카운팅 세마포어 (Counting) 는 N 개의 자원을 관리한다. POSIX, System V, Java, Python, Go 등 다양한 환경에서 구현되어 임계 구역 보호, 리소스 풀 관리, 생산자 - 소비자 문제, 네트워크 요청 제한 등 폭넓게 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;62 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Semaphore" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/synchronization-primitives/software-level/semaphore/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데커 알고리즘 (Dekker's Algorithm)</h2></header><div class=entry-content><p>데커 알고리즘 (Dekker’s Algorithm) 데커 알고리즘(Dekker’s Algorithm)은 두 프로세스 간 **상호 배제(Mutual Exclusion)**를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.
이 알고리즘은 두 개의 프로세스가 공유 자원에 동시에 접근하는 것을 방지하여 경쟁 상태(race condition)를 해결하는 방법을 제시한다.
공유 자원에 대한 안전한 접근을 위해 **플래그(flag)**와 턴(turn) 변수를 활용하며, 하드웨어적 명령어 없이 소프트웨어만으로 구현 가능하다.
데커 알고리즘은 상호 배제 문제 해결의 역사적 중요성을 가지지만, 현대 시스템에서는 **세마포어(Semaphore)**나 **뮤텍스(Mutex)**와 같은 더 효율적인 동기화 기법이 주로 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데커 알고리즘 (Dekker's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/dekkers-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h2></header><div class=entry-content><p>램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.
램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.
핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/lamports-bakery-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>피터슨 알고리즘 (Peterson's Algorithm)</h2></header><div class=entry-content><p>피터슨 알고리즘 (Peterson’s Algorithm) 피터슨 알고리즘(Peterson’s Algorithm)은 두 프로세스의 **상호 배제(Mutual Exclusion)**를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.
1981년 개리 피터슨(Gary L. Peterson)이 제안한 이 알고리즘은 간결성과 이론적 엄밀성으로 운영체제 및 병행 프로그래밍 분야에서 널리 연구된다.
피터슨 알고리즘은 이론적 완결성을 인정받지만, 현대 시스템에서는 주로 하드웨어 기반 동기화 기법(예: TAS, CAS)이 사용됩니다. 그러나 병행 프로그래밍의 근본 원리를 이해하는 데 여전히 핵심적인 역할을 한다.
핵심 구성 요소 플래그 배열(flag) 각 프로세스의 임계 영역 진입 의사 표시 (flag, flag 초기값 False) 턴 변수(turn) 임계 영역 진입 순서 결정 (0 또는 1 값을 가짐) 동작 원리 진입 의사 표시:
프로세스 i가 임계 영역 진입 전 flag[i] = True 설정.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 피터슨 알고리즘 (Peterson's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/petersons-algorithm/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>