<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Process-Synchronization on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/process-synchronization/</link>
    <description>Recent content in Process-Synchronization on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.143.0</generator>
    <language>en</language>
    <lastBuildDate>Thu, 03 Oct 2024 11:00:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/process-synchronization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mutex</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/mutex/</link>
      <pubDate>Thu, 03 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/mutex/</guid>
      <description>Mutex(Mutual Exclusion)는 공유 자원에 대한 접근을 동기화하는 객체.</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/monitor/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/monitor/</guid>
      <description>&lt;h2 id=&#34;monitor&#34;&gt;Monitor&lt;/h2&gt;
&lt;p&gt;프로세스 동기화에서 **모니터(Monitor)**는 공유 자원에 대한 안전한 접근을 보장하기 위한 상위 수준의 동기화 도구이다.&lt;br&gt;
모니터는 공유 데이터와 해당 데이터를 조작하는 연산을 하나의 모듈로 캡슐화하여, 다중 스레드 환경에서의 경쟁 조건(Race Condition)을 방지한다.&lt;/p&gt;
&lt;p&gt;모니터는 &lt;strong&gt;고수준의 동기화 추상화&lt;/strong&gt;로, 복잡한 뮤텍스/세마포어 관리 없이 안전한 병행 프로그래밍을 가능하게 한다.&lt;br&gt;
현대 언어에서는 모니터 패턴이 내장되어 있어(&lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt;), 데드락과 경쟁 조건을 효과적으로 방지한다.&lt;br&gt;
다만 저수준 시스템 프로그래밍에서는 뮤텍스나 세마포어가 더 유연할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;정의&#34;&gt;정의&lt;/h3&gt;
&lt;p&gt;모니터는 **뮤텍스(Mutex)**와 **조건 변수(Condition Variable)**를 결합한 추상화된 동기화 메커니즘이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/semaphore/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/semaphore/</guid>
      <description>멀티스레딩 환경에서 공유 자원에 대한 접근을 제어하는 동기화 도구</description>
    </item>
    <item>
      <title>조건 변수 (Condition Variable)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/condition-variable/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/condition-variable/</guid>
      <description>조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.</description>
    </item>
    <item>
      <title>원자적 연산 (Atomic Operation)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/atomic-operation/</link>
      <pubDate>Thu, 03 Oct 2024 10:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/atomic-operation/</guid>
      <description>원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.</description>
    </item>
    <item>
      <title>데커 알고리즘 (Dekker&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/dekkers-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/dekkers-algorithm/</guid>
      <description>&lt;h2 id=&#34;데커-알고리즘-dekkers-algorithm&#34;&gt;데커 알고리즘 (Dekker&amp;rsquo;s Algorithm)&lt;/h2&gt;
&lt;p&gt;데커 알고리즘(Dekker&amp;rsquo;s Algorithm)은 두 프로세스 간 **상호 배제(Mutual Exclusion)**를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.&lt;br&gt;
이 알고리즘은 두 개의 프로세스가 공유 자원에 동시에 접근하는 것을 방지하여 경쟁 상태(race condition)를 해결하는 방법을 제시한다.&lt;br&gt;
공유 자원에 대한 안전한 접근을 위해 **플래그(flag)**와 &lt;strong&gt;턴(turn)&lt;/strong&gt; 변수를 활용하며, 하드웨어적 명령어 없이 소프트웨어만으로 구현 가능하다.&lt;/p&gt;
&lt;p&gt;데커 알고리즘은 &lt;strong&gt;상호 배제 문제 해결의 역사적 중요성&lt;/strong&gt;을 가지지만, 현대 시스템에서는 **세마포어(Semaphore)**나 **뮤텍스(Mutex)**와 같은 더 효율적인 동기화 기법이 주로 사용된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>램포트의 빵집 알고리즘 (Lamport&#39;s Bakery Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/lamports-bakery-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/lamports-bakery-algorithm/</guid>
      <description>&lt;h2 id=&#34;램포트의-빵집-알고리즘-lamports-bakery-algorithm&#34;&gt;램포트의 빵집 알고리즘 (Lamport&amp;rsquo;s Bakery Algorithm)&lt;/h2&gt;
&lt;p&gt;램포트의 빵집 알고리즘(Lamport&amp;rsquo;s Bakery Algorithm)은 &lt;strong&gt;N개 프로세스의 상호 배제(Mutual Exclusion)&lt;/strong&gt; 문제를 해결하기 위한 소프트웨어 기반 알고리즘다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.&lt;/p&gt;
&lt;p&gt;램포트의 빵집 알고리즘은 &lt;strong&gt;병행 프로그래밍의 이론적 토대&lt;/strong&gt;를 제공했지만, 현대 시스템에서는 주로 &lt;strong&gt;하드웨어 지원 동기화 기법&lt;/strong&gt;이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.&lt;/p&gt;
&lt;h3 id=&#34;핵심-원리&#34;&gt;&lt;strong&gt;핵심 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;번호표-시스템&#34;&gt;번호표 시스템&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스는 임계 영역 진입 전 &lt;strong&gt;고유한 번호표&lt;/strong&gt;를 받는다.&lt;/li&gt;
&lt;li&gt;번호표는 &lt;strong&gt;단조 증가(monotonically increasing)&lt;/strong&gt; 방식으로 발급되며, 동시 접근 시 &lt;strong&gt;프로세스 ID&lt;/strong&gt;로 우선순위 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;단조 증가(monotonically increasing)란 &lt;strong&gt;함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질&lt;/strong&gt;을 의미한다. 즉, &lt;strong&gt;감소하는 구간 없이 유지되거나 증가&lt;/strong&gt;하는 경우를 말한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>피터슨 알고리즘 (Peterson&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/petersons-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/petersons-algorithm/</guid>
      <description>&lt;h2 id=&#34;피터슨-알고리즘-petersons-algorithm&#34;&gt;피터슨 알고리즘 (Peterson&amp;rsquo;s Algorithm)&lt;/h2&gt;
&lt;p&gt;피터슨 알고리즘(Peterson&amp;rsquo;s Algorithm)은 두 프로세스의 **상호 배제(Mutual Exclusion)**를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.&lt;br&gt;
1981년 개리 피터슨(Gary L. Peterson)이 제안한 이 알고리즘은 간결성과 이론적 엄밀성으로 운영체제 및 병행 프로그래밍 분야에서 널리 연구된다.&lt;/p&gt;
&lt;p&gt;피터슨 알고리즘은 &lt;strong&gt;이론적 완결성&lt;/strong&gt;을 인정받지만, 현대 시스템에서는 주로 &lt;strong&gt;하드웨어 기반 동기화 기법&lt;/strong&gt;(예: TAS, CAS)이 사용됩니다. 그러나 병행 프로그래밍의 근본 원리를 이해하는 데 여전히 핵심적인 역할을 한다.&lt;/p&gt;
&lt;h3 id=&#34;핵심-구성-요소&#34;&gt;&lt;strong&gt;핵심 구성 요소&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;플래그 배열(flag)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스의 임계 영역 진입 의사 표시 (&lt;code&gt;flag&lt;/code&gt;, &lt;code&gt;flag&lt;/code&gt; 초기값 &lt;code&gt;False&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;턴 변수(turn)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;임계 영역 진입 순서 결정 (0 또는 1 값을 가짐)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;&lt;strong&gt;동작 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;진입 의사 표시&lt;/strong&gt;:&lt;br&gt;
프로세스 &lt;code&gt;i&lt;/code&gt;가 임계 영역 진입 전 &lt;code&gt;flag[i] = True&lt;/code&gt; 설정.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Process Synchronization</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/</link>
      <pubDate>Thu, 03 Oct 2024 06:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/</guid>
      <description>여러 프로세스가 공유하는 자원의 일관성을 유지하기 위한 메커니즘</description>
    </item>
  </channel>
</rss>
