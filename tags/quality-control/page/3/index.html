<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Quality-Control | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/quality-control/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/quality-control/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/quality-control/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/quality-control/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Quality-Control"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Quality-Control"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Quality-Control</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Scenario Testing</h2></header><div class=entry-content><p>시나리오 테스팅 (Scenario Testing) 시나리오 테스팅은 실제 상황을 시뮬레이션하여 소프트웨어를 검증하는 강력한 기술이다. 개별 기능에 초점을 맞춘 기존 테스트 케이스와 달리 시나리오 테스트에서는 일련의 이벤트나 상호 작용이 발생할 때 시스템이 어떻게 작동하는지 검사한다.
주요 특징 사용자 중심 접근: 실제 사용자의 관점에서 소프트웨어를 테스트한다. 전체 흐름 검증: 개별 기능이 아닌 전체 사용 흐름을 테스트한다. 현실적인 상황 재현: 실제 사용 환경과 유사한 상황을 시뮬레이션한다. 비기술적 언어 사용: 비기술적인 사용자도 이해할 수 있는 언어로 작성된다. 장점 사용자 경험 개선: 실제 사용자의 관점에서 테스트하므로 사용자 불편이나 흐름의 단절을 발견할 수 있다. 종합적인 결함 발견: 기능 간 상호작용에서 발생하는 결함을 발견할 수 있다. 예기치 못한 문제 파악: 다양한 상황을 미리 시뮬레이션하여 잠재적인 오류와 리스크를 발견할 수 있다. 팀 간 협업 강화: 비기술적 이해관계자도 시나리오를 이해하기 쉬워 협업이 용이하다. 적용 방법 시나리오 정의: 테스트할 주요 시나리오를 식별한다. 테스트 데이터 준비: 실제 환경에서 발생할 수 있는 모든 상황을 포괄하는 데이터를 준비한다. 시나리오 실행: 정의된 시나리오에 따라 테스트를 수행한다. 결과 분석: 시나리오 실행 결과를 분석하고 문제점을 식별한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-02 09:57:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Scenario Testing" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-testing/scenario-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</h2></header><div class=entry-content><p>조합 테스트 설계 기법 (Combinatorial Test Design Techniques) 조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.
이 기법은 모든 가능한 입력 조합을 테스트하는 대신 최적화된 조합을 선택하여 테스트 범위를 최대화하고 테스트 케이스 수를 최소화한다.
실제 테스트 설계 시에는 다음과 같은 단계를 따르는 것이 좋다:
테스트 대상 식별
먼저 어떤 요소들을 테스트할 것인지 명확히 한다.
각 요소가 가질 수 있는 값들도 정의한다. 제약조건 파악
일부 조합은 현실적으로 불가능하거나 의미가 없을 수 있다.
예를 들어, 특정 운영체제 버전에서는 5G를 지원하지 않을 수 있다. 테스트 방법 선택
시스템의 중요도와 가용 자원을 고려하여 적절한 테스트 방법을 선택한다. 테스트 케이스 생성
선택한 방법에 따라 테스트 케이스를 생성한다.
이때 자동화 도구를 활용하면 더욱 효율적이다. 주요 특징 수학적 기반: 직교 배열(Orthogonal Arrays)과 같은 수학적 개념을 활용한다. 효율성: 적은 수의 테스트 케이스로 넓은 범위의 입력 조합을 커버한다. 리스크 감소: 특정 입력 조합에서 발생할 수 있는 결함을 효과적으로 찾아낸다. 자동화 가능: 특수한 알고리즘이나 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다. 주요 기법 페어와이즈 테스팅(Pairwise Testing): 모든 가능한 입력 매개변수 쌍의 조합을 테스트한다. N-방향 테스팅(N-way Testing): 페어와이즈를 확장하여 3개 이상의 매개변수 조합을 고려한다. 직교 배열 테스팅(Orthogonal Array Testing): 수학적 직교 배열을 사용하여 효율적인 테스트 조합을 생성한다. 올페어 알고리즘(AllPairs Algorithm): 각 변수 쌍에 대한 모든 값 조합을 효율적으로 테스트한다. 장점 테스트 케이스 수 감소: 효율적인 조합으로 필요한 테스트 케이스 수를 줄인다. 높은 결함 검출률: 다양한 입력 조합을 테스트하여 더 많은 결함을 발견할 수 있다. 시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다. 조기 결함 발견: 개발 초기 단계에서 결함을 식별할 수 있다. 한계점 복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다. 모든 결함 검출 불가능: 특정 시퀀스나 의존성이 필요한 결함은 놓칠 수 있다. 정확한 입력 데이터 필요: 효과적인 테스트를 위해서는 정확하고 완전한 입력 데이터가 필요하다. 조합 테스트를 더욱 효과적으로 수행하기 위한 팁 우선순위 설정:
모든 조합을 테스트할 수 없다면, 중요도나 위험도를 기준으로 우선순위를 정한다.
예를 들어, 사용자가 가장 많이 사용하는 조합이나 문제가 발생했을 때 영향이 큰 조합을 먼저 테스트한다.
...</p></div><footer class=entry-footer><span title='2024-11-02 09:42:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 조합 테스트 설계 기법 (Combinatorial Test Design Techniques)" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-testing/combinatorial-test-design-techniques/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>랜덤 테스팅(Random Testing)</h2></header><div class=entry-content><p>랜덤 테스팅 (Random Testing) 랜덤 테스팅은 테스트 대상 시스템에 임의로 생성된 데이터를 입력하여 프로그램의 동작을 검증하는 기법이다.
이는 통계적 테스팅 또는 몬테카를로 테스팅으로도 알려져 있다.
실제 예시를 통해 더 자세히 살펴보자.
숫자 정렬 프로그램을 테스트한다고 가정해보자.
전통적인 테스트 방식에서는 미리 정해진 테스트 케이스(예: [1,2,3] 또는 [3,2,1])를 사용할 것.
하지만 랜덤 테스팅에서는 무작위로 생성된 숫자 배열을 사용한다.
이를 통해 개발자가 미처 생각하지 못한 경우의 수를 테스트할 수 있다.
랜덤 테스팅의 실제 적용 과정을 단계별로 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-11-02 07:24:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 랜덤 테스팅(Random Testing)" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-testing/random-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>페어와이즈 테스팅(Pairwise Testing)</h2></header><div class=entry-content><p>페어와이즈 테스팅(Pairwise Testing) 페어와이즈 테스팅은 모든 가능한 입력 값 조합을 테스트하는 대신, 입력 매개변수의 모든 쌍(pair)을 최소한 한 번씩 테스트하는 기법이다.
이는 대부분의 결함이 두 입력 값의 상호작용에 기인한다는 관찰에 기반한다.
실제 예시를 통해 더 자세히 살펴보자.
웹 브라우저 애플리케이션을 테스트한다고 가정하면:
운영체제: Windows, Mac, Linux
브라우저: Chrome, Firefox, Safari
화면 해상도: HD, FHD, 4K
언어 설정: 한국어, 영어, 일본어
만약 모든 가능한 조합을 테스트하려면 몇 개의 테스트 케이스가 필요할까?
3(운영체제) × 3(브라우저) × 3(해상도) × 3(언어) = 81개의 테스트 케이스가 필요하다.
...</p></div><footer class=entry-footer><span title='2024-11-02 07:06:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 페어와이즈 테스팅(Pairwise Testing)" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-testing/pairwise-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비교 검사(Comparison Testing)</h2></header><div class=entry-content><p>비교 검사(Comparison Testing) 비교 검사는 블랙박스 테스팅 기법 중 하나로, 동일한 기능을 수행하는 여러 버전의 소프트웨어나 시스템을 비교하여 테스트하는 방법.
비교 검사는 동일한 입력값을 여러 버전의 소프트웨어에 제공하고, 그 출력값을 비교하는 방식으로 진행된다.
예를 들어, 새로운 버전의 소프트웨어와 이전 버전의 소프트웨어에 같은 입력을 주고 결과를 비교하여 일관성을 검증한다.
비교 검사는 특히 다음과 같은 상황에서 효과적이다:
중요한 시스템 업그레이드 시:
새로운 버전이 기존 기능을 정확히 수행하는지 확인 예상치 못한 부작용 발견 호환성 검증 시:
...</p></div><footer class=entry-footer><span title='2024-11-02 00:13:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 비교 검사(Comparison Testing)" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-testing/comparison-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Path Coverage</h2></header><div class=entry-content><p>경로 커버리지(Path Coverage) 경로 커버리지는 프로그램의 제어 흐름 그래프(Control Flow Graph, CFG)에서 모든 가능한 실행 경로를 테스트하는 구조적 테스팅 기법이다.
이는 프로그램의 입력과 출력 값보다는 내부 제어 흐름에 초점을 맞춘다.
먼저 경로 커버리지의 기본 개념을 간단한 예제를 통해 이해해보자:
1 2 3 4 5 6 7 8 9 10 11 def calculate_discount(price, is_member, is_sale_period): if is_member: if is_sale_period: return price * 0.8 # 20% 할인 else: return price * 0.9 # 10% 할인 else: if is_sale_period: return price * 0.95 # 5% 할인 else: return price # 할인 없음 이 함수에는 다음과 같은 가능한 실행 경로들이 있다:
...</p></div><footer class=entry-footer><span title='2024-11-01 15:01:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Path Coverage" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/white-box-testing/path-coverage/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조건 커버리지 (Condition Coverage)</h2></header><div class=entry-content><p>조건 커버리지 (Condition Coverage) 조건 커버리지는 결정 포인트 내의 각 개별 조건식이 참(true)과 거짓(false)의 결과를 최소한 한 번씩 갖도록 테스트하는 기법이다.
이는 전체 조건식의 결과와는 독립적으로 각 개별 조건의 결과에 초점을 맞춘다.
주요 특징 개별 조건 중심: 전체 조건식이 아닌 각 개별 조건식의 결과를 검증한다. 최소 요구사항: 각 조건이 최소한 한 번씩 참과 거짓의 결과를 가져야 한다. 세분화된 테스트: 복잡한 조건문의 각 부분을 개별적으로 테스트할 수 있다. 장점 조건의 독립적 평가: 각 조건을 독립적으로 평가하여 더 세밀한 테스트가 가능하다. 제어 흐름에 대한 높은 민감도: 프로그램의 제어 흐름을 더 정확하게 테스트할 수 있다. 결정 커버리지보다 강력: 더 많은 테스트 케이스를 요구하므로 더 철저한 테스트가 가능하다. 단점 전체 조건식 결과 보장 부족: 개별 조건의 참/거짓만을 테스트하므로 전체 조건식의 모든 결과를 보장하지 않을 수 있다. 테스트 케이스 증가: 조건의 수가 많아질수록 필요한 테스트 케이스의 수가 증가한다.
따라서 조건 커버리지는 다른 테스트 커버리지 지표들(구문 커버리지, 분기 커버리지 등)과 함께 사용되어야 하며, 이를 통해 더 완성도 높은 테스트를 수행할 수 있다. 조건 커버리지를 계산하는 방법 1 2 3 4 5 6 public boolean isEligibleForDiscount(int age, boolean isMember, int purchaseAmount) { if (age >= 60 && isMember || purchaseAmount > 1000) { return true; } return false; } 이 코드에는 세 가지 개별 조건이 있다:
...</p></div><footer class=entry-footer><span title='2024-11-01 15:01:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 조건 커버리지 (Condition Coverage)" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/white-box-testing/condition-coverage/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Decision Coverage</h2></header><div class=entry-content><p>결정 커버리지 (Decision Coverage) 결정 커버리지는 프로그램의 모든 결정 포인트(조건문)에서 전체 조건식이 최소한 한 번씩 참(True)과 거짓(False)의 결과를 가지도록 테스트하는 방법이다.
이는 브랜치 커버리지(Branch Coverage)라고도 불린다.
간단한 예제:
1 2 3 4 5 6 7 8 9 10 11 public class LoanApproval { public boolean approveLoan(double income, double creditScore) { if (income >= 50000) { if (creditScore >= 700) { return true; } return false; } return false; } } 이 코드의 결정 커버리지를 100% 달성하기 위해서는 다음과 같은 테스트 케이스가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-01 15:00:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Decision Coverage" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/white-box-testing/decision-coverage/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Statement Coverage</h2></header><div class=entry-content><p>구문 커버리지 (Statement Coverage) 구문 커버리지는 프로그램을 구성하는 모든 문장들이 최소한 한 번은 실행될 수 있는 입력 데이터를 테스트 데이터로 선정하는 기준이다.
또한 라인 커버리지(Line Coverage)라고도 불린다.
먼저 간단한 예제를 통해 구문 커버리지의 이해:
1 2 3 4 5 6 7 8 9 10 11 12 13 def calculate_grade(score): # 구문 1 if score >= 90: # 구문 2 grade = 'A' elif score >= 80: # 구문 3 grade = 'B' else: # 구문 4 grade = 'C' # 구문 5 return grade 이 함수의 모든 구문을 실행하기 위해서는 다음과 같은 테스트 케이스가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-01 15:00:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Statement Coverage" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/white-box-testing/statement-coverage/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Function Coverage</h2></header><div class=entry-content><p>함수 커버리지 (Function Coverage) 함수 커버리지는 프로그램 내의 모든 함수가 테스트 중에 최소한 한 번 이상 호출되었는지를 측정하는 지표이다.
간단한 예제:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Calculator: def add(self, a, b): return a + b def subtract(self, a, b): return a - b def multiply(self, a, b): return a * b def divide(self, a, b): if b == 0: raise ValueError("Cannot divide by zero") return a / b 이 계산기 클래스의 모든 함수를 테스트하기 위해서는 다음과 같은 테스트 코드가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-01 10:30:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Function Coverage" href=https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/white-box-testing/function-coverage/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/quality-control/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/quality-control/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>