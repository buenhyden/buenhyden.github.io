<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Communication-Style | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/communication-style/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/communication-style/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/communication-style/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/communication-style/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Communication-Style"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Communication-Style"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Communication-Style</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain-specific</h2></header><div class=entry-content><p>Domain-specific Domain-specific 프로토콜은 특정 도메인이나 비즈니스 영역에 특화된 통신 프로토콜을 의미한다.
이 프로토콜은 일반적인 통신 프로토콜보다 해당 도메인의 특성과 요구사항에 더 적합하게 설계되어 있다.
주요 특징 도메인 주도 설계(DDD)와의 연계: 도메인 주도 설계는 복잡한 소프트웨어를 개발할 때 도메인 모델을 중심으로 설계하는 접근 방식이다. MSA에서 도메인별 통신 스타일을 적용하면, 각 도메인의 비즈니스 로직과 데이터가 해당 서비스 내에서 캡슐화되어 독립성을 유지할 수 있다.
통신 프로토콜의 선택: 각 도메인의 특성에 따라 적합한 통신 프로토콜을 선택한다. 예를 들어, 실시간성이 중요한 도메인에서는 gRPC나 GraphQL과 같은 프로토콜을, 비동기 처리가 적합한 도메인에서는 Kafka나 AMQP와 같은 메시징 프로토콜을 사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;333 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-specific" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Remote-Procedure</h2></header><div class=entry-content><p>Remote-Procedure Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.
RPC의 작동 원리 클라이언트가 로컬 프로시저를 호출한다. 클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다. 클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다. 서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다. 서버 스텁이 파라미터를 언마샬링(unmarshalling)한다. 서버 스텁이 서버 프로시저를 호출한다. RPC의 특징 투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다. 높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다. 위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다. RPI 패턴의 주요 구성 요소 통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다. 서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다. 오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다. 보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다. RPC의 장점 효율성: 도메인 특화 기능으로 통신 효율성이 높아진다. 구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다. 직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다. RPC의 단점 네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다. 복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다. 호환성 문제: 다른 시스템과의 통합이 어려울 수 있다. RPI 패턴 구현 시 고려해야 할 사항 성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다. 확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다. 모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다. MSA에서의 RPC 활용 마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Remote-Procedure" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Messaging</h2></header><div class=entry-content><p>Messaging 마이크로서비스 아키텍처(MSA)에서 Messaging은 중요한 Communication style 중 하나이다.
Messaging은 서비스 간 비동기 통신을 가능하게 하며, 시스템의 확장성과 유연성을 향상시킨다.
Messaging은 서비스들이 메시지를 통해 비동기적으로 통신하는 방식이다. 서비스들은 메시지 브로커를 통해 메시지를 주고받으며, 이를 통해 느슨한 결합(loose coupling)을 실현한다.
주요 특징 비동기 통신: 서비스는 메시지를 보내고 즉시 다른 작업을 수행할 수 있다. 느슨한 결합: 서비스들은 직접적인 연결 없이 메시지를 통해 통신한다. 메시지 구조: 메시지는 일반적으로 헤더(header)와 바디(message body)로 구성된다. 채널 기반 통신: 메시지는 채널을 통해 전달된다. point-to-point 채널과 publish-subscribe 채널이 있다. Messaging 패턴 Request/Response: 서비스가 요청 메시지를 보내고 응답을 기다린다. Notifications: 서비스가 메시지를 보내지만 응답을 기대하지 않는다. Publish/Subscribe: 서비스가 메시지를 발행하면 여러 수신자가 구독할 수 있다. Event-Driven: 서비스가 이벤트를 발행하고 다른 서비스들이 이에 반응한다. Messaging 패턴의 주요 구성 요소 메시지 구조:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:21:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Messaging" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>