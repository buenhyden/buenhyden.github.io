<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/javascript/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/javascript/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/javascript/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Javascript</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2025-01-17 09:07:00 +0000 UTC'>January 17, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/til/2025/01/17/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VueJS vs ReactJS vs NextJS</h2></header><div class=entry-content><p>VueJS Vs ReactJS Vs NextJS VueJS, ReactJS, NextJS는 모두 현대적인 웹 애플리케이션을 개발하기 위한 JavaScript 기반의 프레임워크 및 라이브러리로, 각각 고유한 특징과 장단점을 가지고 있으며, 다양한 웹 개발 시나리오에 사용된다.
구분 Vue.js React.js Next.js 기본 정의 점진적이고 직관적인 JavaScript 프레임워크 유연한 JavaScript UI 라이브러리 React 기반 풀스택 웹 프레임워크 개발사 및 출시 2014년, Evan You가 개발 2013년, Facebook(현 Meta) 개발 2016년, Vercel이 개발 핵심 철학 점진적 도입이 가능한 유연한 프레임워크 선언적 UI 개발과 컴포넌트 기반 구조 React의 장점을 서버 사이드와 결합 기술적 특징 - 반응형 데이터 바인딩
- 양방향 데이터 흐름
- 컴포넌트 기반 개발 - Virtual DOM
- 단방향 데이터 흐름
JSX 문법 - SSR/SSG 지원
- 파일 기반 라우팅
- 자동 코드 분할 상태 관리 Vuex, Pinia (공식 상태 관리 도구) Redux, Context API (커뮤니티 기반) React 상태 관리 + 서버 상태 성능 최적화 - 작은 번들 크기
- 효율적인 반응형 시스템 - Virtual DOM 기반 최적화
- 메모이제이션 - 자동 이미지 최적화
- 경로 기반 코드 분할 사용 시나리오 - 중소규모 애플리케이션
- 점진적 마이그레이션
- 빠른 개발 필요 시 - 대규모 SPA
- 복잡한 UI 개발
- 커스텀 솔루션 필요 시 - SEO 중심 프로젝트
- 풀스택 애플리케이션
- 엔터프라이즈급 개발 학습 용이성 매우 낮은 진입 장벽, HTML 친화적 중간 수준, JavaScript 숙련도 필요 높은 수준, React 지식 필수 생태계 특성 공식 도구 중심의 통합된 생태계 거대하고 다양한 커뮤니티 생태계 React 생태계 + 서버 사이드 도구 개발 도구 Vue CLI, Vue DevTools Create React App, React DevTools 내장 빌드 시스템, 분석 도구 배포 특성 단순한 정적 파일 배포 가능 정적 파일 기반 배포 서버 필요, Vercel 최적화 프로젝트 확장성 중간 수준의 모듈식 확장 높은 자유도의 확장성 풀스택 확장 용이 이 세 기술은 각각의 고유한 장점과 사용 시나리오를 가지고 있다.
Vue.js는 빠른 학습과 개발이 가능하고, React.js는 유연하고 강력한 UI 개발을 지원하며, Next.js는 현대적인 웹 애플리케이션의 완벽한 솔루션을 제공한다.
프로젝트의 요구사항과 팀의 기술적 배경에 따라 적절한 선택을 하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 04:51:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VueJS vs ReactJS vs NextJS" href=https://buenhyden.github.io/til/2024/11/17/vuejs-vs-reactjs-vs-nextjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ExpressJS vs NestJS</h2></header><div class=entry-content><p>ExpressJS Vs NestJS ExpressJS와 NestJS의 주요 특징들을 상세히 비교 분석하여 표로 정리해드리겠습니다.
비교 기준 ExpressJS NestJS 프레임워크 특성 미니멀리스트, 유연한 Node.js 웹 프레임워크 TypeScript 기반의 구조화된 풀스택 프레임워크 아키텍처 스타일 자유로운 구조 (개발자가 직접 설계) Angular 스타일의 모듈식 아키텍처 (강제됨) 언어 지원 JavaScript 중심 (TypeScript도 사용 가능) TypeScript 중심 (JavaScript도 사용 가능) 학습 곡선 낮음 (시작하기 쉬움) 높음 (많은 개념과 패턴 학습 필요) 기본 구조 최소한의 구조만 제공 모듈, 컨트롤러, 서비스 등 세분화된 구조 라우팅 예시 javascript app.get('/users', (req, res) => { res.send('Users list'); }); typescript @Controller('users') export class UsersController { @Get() findAll(): string { return 'Users list'; } } 의존성 주입 없음 (수동으로 구현 필요) 내장된 강력한 DI 시스템 제공 데코레이터 지원 지원하지 않음 광범위한 데코레이터 지원 미들웨어 처리 직관적이고 단순한 미들웨어 체인 복잡하지만 강력한 미들웨어 시스템 테스트 용이성 별도 테스트 도구 설정 필요 내장된 테스트 도구 제공 확장성 수동 구성 필요 모듈 시스템을 통한 쉬운 확장 성능 매우 가벼움 (적은 오버헤드) 약간의 오버헤드 존재 실시간 처리 WebSocket 수동 구현 필요 WebSocket 데코레이터 제공 유효성 검사 외부 라이브러리 필요 내장 파이프를 통한 유효성 검사 문서화 Swagger 등 수동 설정 필요 자동 API 문서 생성 지원 적합한 프로젝트 - 작은 규모의 프로젝트
- 빠른 프로토타이핑
- 마이크로서비스 - 대규모 엔터프라이즈 애플리케이션
- 복잡한 비즈니스 로직
- 팀 프로젝트 개발 생산성 초기에는 빠르나 규모가 커지면 관리 어려움 초기 설정에 시간이 걸리나 장기적으로 생산성 높음 커뮤니티/생태계 매우 큰 커뮤니티, 풍부한 미들웨어 성장하는 커뮤니티, 내장 기능 많음 에러 처리 수동 구현 필요 내장된 예외 필터 시스템 데이터베이스 통합 ORM 선택 자유 TypeORM/Sequelize 등과 쉬운 통합 보안 기능 외부 미들웨어 필요 내장된 보안 기능 제공 모니터링/로깅 외부 도구 통합 필요 내장된 로깅 시스템 제공 선택 가이드:
...</p></div><footer class=entry-footer><span title='2024-11-17 04:50:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ExpressJS vs NestJS" href=https://buenhyden.github.io/til/2024/11/17/expressjs-vs-nestjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Programming Languages and Frameworks</h2></header><div class=entry-content><p>Programming Languages and Frameworks 프로그래밍 언어 비교 언어 언어 유형 주요 특징 장점 단점 주요 활용 분야 Python 고수준 인터프리터 언어 • 간결하고 읽기 쉬운 문법
• 동적 타이핑
• 광범위한 라이브러리 생태계 • 초보자가 배우기 쉬움
• 빠른 개발 속도
• 풍부한 데이터 과학 도구 • 실행 속도가 비교적 느림
• GIL로 인한 멀티스레딩 제한
• 메모리 사용량이 많음 • 데이터 과학
• 인공지능/머신러닝
• 웹 개발
• 스크립팅 JavaScript 스크립트 언어 • 이벤트 기반 프로그래밍
• 비동기 처리 지원
• 프론트엔드/백엔드 모두 가능 • 웹 개발의 표준
• 큰 개발자 커뮤니티
• 유연한 언어 특성 • 타입 시스템이 느슨함
• 브라우저별 호환성 이슈
• 코드 품질 관리가 어려움 • 웹 프론트엔드
• 서버사이드 개발(Node.js)
• 모바일 앱(React Native) Java 객체지향 컴파일 언어 • 플랫폼 독립성
• 강력한 타입 시스템
• 광범위한 기업용 라이브러리 • 안정성과 신뢰성
• 뛰어난 성능
• 풍부한 개발 도구 • 상대적으로 복잡한 문법
• 많은 보일러플레이트 코드
• 느린 개발 속도 • 엔터프라이즈 애플리케이션
• 안드로이드 앱
• 대규모 백엔드 시스템 Kotlin JVM 기반 현대적 언어 • Java 완벽 호환
• Null 안전성
• 간결한 문법 • Java보다 생산적
• 안전한 코드 작성
• 현대적 기능 지원 • 컴파일 시간이 길어질 수 있음
• 학습 자료가 상대적으로 적음
• 성숙도가 낮음 • 안드로이드 앱 개발
• 서버사이드 개발
• 크로스 플랫폼 개발 Go 컴파일 시스템 프로그래밍 언어 • 간단한 문법
• 내장 동시성 지원
• 빠른 컴파일과 실행 • 뛰어난 성능
• 쉬운 동시성 처리
• 빌트인 도구 지원 • 제네릭스 지원 제한적
• 예외 처리 기능 부족
• 생태계가 상대적으로 작음 • 클라우드 인프라
• 네트워크 서비스
• 시스템 도구 프로그래밍 언어별 기본 데이터 구조 분류 데이터 구조 Python JavaScript Java Kotlin Go Primitive Boolean bool boolean boolean Boolean bool Number (Integer) int number byte
short
int
long Byte
Short
Int
Long int8
int16
int32
int64 Number (Float) float number float
double Float
Double float32
float64 Character str[0] string[0] char Char rune String str string String String string Null/None None null
undefined null null nil Non-Primitive Array/List list Array Array
ArrayList Array
List array
slice Dictionary/Map dict Object
Map HashMap
TreeMap Map
HashMap map Set set Set HashSet
TreeSet Set
HashSet N/A Tuple tuple N/A N/A Pair
Triple N/A Queue/Stack collections.deque Array methods Queue
Stack Queue
Stack N/A Python: Python은 모든 것이 객체이지만, int, float, bool, str 등을 기본 데이터 타입으로 취급한다. JavaScript: JavaScript는 동적 타입 언어로, number와 같은 기본 타입과 object 같은 참조 타입을 가진다. Java: Java는 primitive 타입과 reference 타입을 명확히 구분한다. primitive 타입은 스택에 직접 저장되고, reference 타입은 힙 메모리를 참조한다. Kotlin: Kotlin은 Java와 달리 모든 타입을 객체로 취급하지만, 내부적으로는 JVM의 primitive 타입으로 최적화된다. Go: Go는 정적 타입 언어로, 다양한 크기의 정수형과 부동소수점 타입을 제공하며, struct를 통해 사용자 정의 타입을 만들 수 있다. 주요 개발 프레임워크 프레임워크 기본 정보 아키텍처 특성 기능성 성능과 확장성 개발 생산성 생태계 실제 활용 Django (Python) • 2005년 출시
• Python 기반
• BSD 라이선스 • MVT 아키텍처
• 모놀리식 구조
• ORM 내장 • 관리자 인터페이스 기본 제공
• 인증/보안 기능 완비
• Form 처리 시스템 • 중간 수준의 처리 성능
• 수평적 확장 가능
• 캐싱 시스템 내장 • 초기 설정 간편
• 빠른 개발 속도
• 중간 수준의 학습 곡선 • 매우 큰 커뮤니티
• 풍부한 서드파티 앱
• 광범위한 문서화 • Instagram
• Mozilla
• 대규모 CMS 시스템 Flask (Python) • 2010년 출시
• Python 기반
• BSD 라이선스 • 마이크로 프레임워크
• 유연한 구조
• 확장 가능한 설계 • 최소한의 핵심 기능
• RESTful 지원
• 유연한 라우팅 • 가벼운 리소스 사용
• 높은 처리 성능
• 유연한 확장 • 최소한의 초기 설정
• 빠른 프로토타이핑
• 낮은 학습 곡선 • 활발한 커뮤니티
• 다양한 확장 모듈
• 명확한 문서화 • Netflix
• LinkedIn
• 소규모 API 서비스 FastAPI (Python) • 2018년 출시
• Python 3.6+
• MIT 라이선스 • 비동기 처리
• OpenAPI 기반
• 타입 힌트 활용 • 자동 API 문서화
• 데이터 검증
• WebSocket 지원 • 매우 높은 성능
• 비동기 처리
• 효율적인 리소스 사용 • 간단한 초기 설정
• 빠른 API 개발
• 중간 수준의 학습 곡선 • 빠르게 성장 중
• 현대적 도구 통합
• 상세한 문서화 • Microsoft
• Uber
• 고성능 API 서비스 Spring (Java) • 2002년 출시
• Java 기반
• Apache 2.0 라이선스 • DI/IoC 컨테이너
• AOP 지원
• 모듈식 구조 • 광범위한 기능 제공
• 트랜잭션 관리
• 보안 프레임워크 • 높은 처리 성능
• 엔터프라이즈급 확장성
• 클러스터링 지원 • 복잡한 초기 설정
• 체계적인 개발 가능
• 높은 학습 곡선 • 거대한 커뮤니티
• 방대한 생태계
• 풍부한 레퍼런스 • 금융권 시스템
• 대형 포털
• 엔터프라이즈 시스템 Express.js (JavaScript) • 2010년 출시
• Node.js 기반
• MIT 라이선스 • 미들웨어 패턴
• 라우팅 중심
• MVC 지원 • 미들웨어 기반 기능 확장
• 라우팅
• 정적 파일 제공 • 경량화된 성능
• 이벤트 기반 확장성
• 비동기 처리 • 매우 간단한 설정
• 빠른 개발 가능
• 낮은 학습 곡선 • 매우 큰 커뮤니티
• NPM 생태계
• 풍부한 미들웨어 • IBM
• Uber
• RESTful API 서버 Nest.js (JavaScript) • 2017년 출시
• TypeScript 기반
• MIT 라이선스 • 모듈형 아키텍처
• DI 컨테이너
• 데코레이터 패턴 • TypeScript 지원
• OpenAPI 통합
• WebSocket 지원 • 높은 확장성
• 마이크로서비스 지원
• 캐싱 메커니즘 • 구조화된 초기 설정
• 체계적 개발
• 중간 수준의 학습 곡선 • 성장하는 커뮤니티
• 기업급 도구 지원
• 상세한 문서화 • Adidas
• Autodesk
• 엔터프라이즈 백엔드 Ktor (Kotlin) • 2018년 출시
• Kotlin 기반
• Apache 2.0 라이선스 • 비동기 처리
• 코루틴 기반
• 모듈식 구조 • WebSocket 지원
• 인증/보안 기능
• 유연한 라우팅 • 높은 성능
• 경량 리소스 사용
• 확장 가능한 구조 • 간단한 초기 설정
• Kotlin 친화적
• 중간 수준의 학습 곡선 • JetBrains 지원
• Kotlin 생태계
• 성장 중인 커뮤니티 • JetBrains
• 모바일 백엔드
• 마이크로서비스 Gin (Go) • 2014년 출시
• Go 기반
• MIT 라이선스 • 미들웨어 구조
• 라우터 중심
• MVC 지원 • 미들웨어 시스템
• JSON 검증
• 라우팅 그룹 • 매우 높은 성능
• 낮은 메모리 사용
• 고성능 라우터 • 빠른 초기 설정
• 직관적인 API
• 낮은 학습 곡선 • 큰 Go 커뮤니티
• 다양한 미들웨어
• 활발한 개발 • Dropbox
• Ethereum
• 고성능 API 서버 IoC(Inversion of Control)
프로그램의 제어 흐름을 역전시키는 소프트웨어 디자인 원칙
...</p></div><footer class=entry-footer><span title='2024-10-21 08:18:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1217 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Languages and Frameworks" href=https://buenhyden.github.io/til/2024/10/21/programming-languages-and-frameworks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Karma</h2></header><div class=entry-content><p>Karma Karma는 모든 브라우저에서 JavaScript 코드를 테스트할 수 있게 해주는 테스트 러너이다.
Google의 AngularJS 팀이 개발했으며, 특히 브라우저 기반의 자동화된 테스트 실행에 특화되어 있다.
여러 브라우저에서 동시에 테스트를 실행하고, 실시간으로 결과를 확인할 수 있다는 점이 큰 특징이다.
정의와 목적 JavaScript 코드를 실제 브라우저에서 테스트할 수 있게 해주는 도구 개발자에게 생산적인 테스팅 환경을 제공하는 것이 주요 목적 설정과 기본 구조 Karma의 설정은 karma.conf.js 파일을 통해 이루어진다.
기본적인 설정 파일은 다음과 같은 구조를 가진다:
...</p></div><footer class=entry-footer><span title='2025-01-04 06:17:00 +0000 UTC'>January 4, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;541 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Karma" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/karma/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/javascript/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>