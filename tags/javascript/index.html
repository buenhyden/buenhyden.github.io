<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/javascript/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/javascript/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/javascript/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Javascript</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ECMAScript</h2></header><div class=entry-content><p>ECMAScript ECMAScript는 자바스크립트의 표준 규격으로, Ecma International이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.
1997년 처음 표준화되었으며, 자바스크립트의 핵심 문법과 기능을 규정한다.
ECMAScript는 ECMA 인터내셔널(ECMA International)에서 제정한 스크립트 프로그래밍 언어의 표준 사양이다.
이 표준은 다양한 스크립트 언어의 상호 운용성을 보장하기 위해 만들어졌으며, JavaScript, JScript, ActionScript 등이 ECMAScript 표준을 준수한다.
ECMAScript는 1997년에 첫 번째 버전이 발표된 이후 지속적으로 발전해 왔다.
주요 버전으로는 2015년에 발표된 ECMAScript 6(ES6), 2016년의 ECMAScript 2016(ES7), 2017년의 ECMAScript 2017(ES8) 등이 있으며, 각 버전마다 새로운 기능과 개선 사항이 추가되었다.
...</p></div><footer class=entry-footer><span title='2024-12-04 17:43:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ECMAScript" href=https://buenhyden.github.io/posts/programming-languages/javascript/ecmascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript vs. Python</h2></header><div class=entry-content><p>Javascript vs. Python JavaScript와 Python은 현대 프로그래밍 세계에서 가장 인기 있는 두 언어이다.
두 언어 모두 높은 수준의 프로그래밍 언어이지만, 설계 철학, 사용 사례, 문법 등에서 중요한 차이점이 있다.
JavaScript와 Python은 각각 고유한 강점과 약점을 가진 강력한 프로그래밍 언어이다.
JavaScript는 웹 개발에서 독보적인 위치를 차지하고 있으며, 비동기 프로그래밍 모델과 빠른 실행 속도가 특징이다. Python은 가독성이 뛰어나고 데이터 과학, 기계 학습, 자동화 분야에서 뛰어난 라이브러리 지원을 제공한다.
역사와 배경 JavaScript JavaScript는 1995년 Netscape의 Brendan Eich에 의해 웹 브라우저용 스크립팅 언어로 개발되었다.
처음에는 ‘Mocha’라고 불렸으며, 나중에 ‘LiveScript’로 이름이 바뀌었고, 마지막으로 마케팅 목적으로 ‘JavaScript’라는 이름이 되었다 (Java와의 관련성은 거의 없다).
JavaScript는 웹 페이지에 상호작용성을 추가하기 위해 만들어졌으며, 시간이 지남에 따라 Node.js와 같은 플랫폼 덕분에 서버 측 개발로 확장되었다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:24:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;732 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript vs. Python" href=https://buenhyden.github.io/posts/programming-languages/javascript/javascript-vs-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python vs Javascript vs Typescript vs Java</h2></header><div class=entry-content><p>Python Vs Javascript Vs Typescript Vs Java 프로그래밍 언어마다 각기 다른 설계 철학과 실행 방식, 개발 생태계 및 목적이 존재한다.
Python은 배우기 쉽고 다양한 분야(데이터 분석, 웹 개발, 자동화 등)에서 활용되는 동적 인터프리터 언어 JavaScript는 웹 브라우저 내에서 동작하는 클라이언트 사이드 스크립팅 언어로 빠른 반응형 인터페이스 구성에 적합하다. TypeScript는 JavaScript의 상위 집합으로 정적 타입 검사와 클래스, 인터페이스, 제네릭 등의 기능을 제공하여 대규모 애플리케이션 개발 시 안정성을 높인다. Java는 JVM 위에서 동작하는 컴파일러 기반의 정적 타입 언어로, 엔터프라이즈급 애플리케이션과 멀티스레드 환경에 강점을 가지고 있다. 각 언어는 고유한 강점과 약점을 가지고 있으며, 특정 프로젝트나 도메인에 더 적합할 수 있다.
최근 트렌드는 다중 언어 개발(polyglot programming)로, 하나의 프로젝트에서 여러 언어를 함께 사용하는 경우가 많다. 예를 들어, 데이터 처리는 Python, 웹 프론트엔드는 TypeScript/React, 백엔드는 Java로 개발하는 방식이 흔하다.
...</p></div><footer class=entry-footer><span title='2025-01-19 00:44:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1301 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python vs Javascript vs Typescript vs Java" href=https://buenhyden.github.io/posts/programming-languages/python-vs-javascript-vs-typescript-vs-java/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback Hell</h2></header><div class=entry-content><p>Callback Hell 콜백 지옥은 여러 비동기 작업을 순차적으로 처리해야 할 때 발생하는 중첩된 콜백 구조를 말한다. 코드가 깊게 중첩되어 가독성이 떨어지고 유지보수가 어려워지는 문제가 있다.
이는 주로 여러 비동기 작업(API 호출, 파일 읽기, 타이머 등)이 순차적으로 실행되어야 할 때 발생하며, 코드가 피라미드 형태로 깊이 중첩되는 특징을 보인다.
콜백 지옥의 원인 비동기 작업의 연속성:
A 작업의 결과가 B 작업의 입력으로 필요할 때, 콜백 안에 콜백을 중첩해야 한다. JavaScript의 단일 스레드 특성:
비동기 작업 완료 시점을 콜백 함수로 처리해야 하므로 중첩이 불가피한다. 주요 문제점 문제점 설명 가독성 저하 코드의 들여쓰기 수준이 과도하게 증가하여 논리 흐름 파악이 어렵다. 에러 처리 복잡 각 콜백마다 별도의 에러 핸들링이 필요해 중복 코드가 발생한다. 유지보수 난이도 기능 수정 시 중첩 구조에서 의도치 않은 버그 발생 가능성이 높다. 해결 방법 1 2 3 4 5 6 7 8 9 10 11 getData(function(a) { getMoreData(a, function(b) { getEvenMoreData(b, function(c) { getYetEvenMoreData(c, function(d) { getFinalData(d, function(finalData) { console.log("최종 데이터:", finalData); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); 함수 분리 (모듈화) 각 콜백을 별도의 명명된 함수로 분리하여 중첩을 줄인다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:39:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Hell" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/callback-hell/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Javascript</h2></header><div class=entry-content><p>NodeJS vs. Javascript JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.
주요 특징은 다음과 같다:
객체 기반의 스크립트 언어이다. 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 이벤트 중심의 프로그래밍이 가능하다. 웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다. 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 1 2 3 4 5 6 7 8 9 10 // JavaScript 예시 // DOM 조작 document.getElementById('myButton').addEventListener('click', function() { alert('버튼이 클릭되었습니다!'); }); // 비동기 처리 fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data));**** Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:33:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Javascript" href=https://buenhyden.github.io/posts/programming-languages/javascript/runtime-environments/nodejs/nodejs-javascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import Vs Require 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/posts/programming-languages/javascript/basic-syntax/modules/import-vs-require/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript Engines</h2></header><div class=entry-content><p>Javascript Engines JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램이다.
웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.
JavaScript는 원래 인터프리터 언어로 설계되었지만, 현대의 JavaScript 엔진들은 성능 향상을 위해 다양한 최적화 기술을 사용한다.
JavaScript 엔진의 주요 역할:
JavaScript 코드를 읽고 구문 분석(파싱) 코드를 기계어 또는 중간 표현으로 변환 코드 실행 메모리 관리 (가비지 컬렉션 포함) 최적화 수행 JavaScript 엔진은 현대 웹의 핵심 구성 요소로, 웹 브라우저와 서버 측 애플리케이션 모두에서 JavaScript 코드를 실행하는 데 필수적이다. Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore와 같은 주요 엔진들은 계속해서 발전하며, 성능을 향상시키고 새로운 언어 기능을 지원하고 있다.
...</p></div><footer class=entry-footer><span title='2025-03-05 09:46:00 +0000 UTC'>March 5, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1980 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript Engines" href=https://buenhyden.github.io/posts/programming-languages/javascript/javascript-engines/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Typescript vs. Javascript</h2></header><div class=entry-content><p>Typescript vs. Javascript JavaScript와 TypeScript는 둘 다 웹 및 기타 환경에서 널리 사용되는 프로그래밍 언어이지만, 설계와 사용 목적에 있어 몇 가지 중요한 차이가 있다.
JavaScript는 인터프리터(또는 JIT 컴파일러)에 의해 실행되는 동적 타입의 스크립트 언어로, 유연성과 간편함을 제공하며 브라우저와 Node.js 등에서 기본 언어로 사용된다. TypeScript는 Microsoft에서 개발한 JavaScript의 상위 집합(superset)으로, 정적 타입 시스템과 클래스, 인터페이스, 제네릭 등 강력한 객체지향 프로그래밍(OOP) 기능을 추가하여 대규모 애플리케이션이나 엔터프라이즈 환경에서 코드의 안정성과 유지보수성을 높이는 데 목적이 있다. JavaScript JavaScript는 1995년 Brendan Eich에 의해 만들어진 웹 브라우저용 스크립트 언어이다. 원래는 웹 페이지에 상호작용을 추가하기 위해 설계되었지만, 현재는 브라우저 환경 외에도 서버 사이드(Node.js), 모바일 앱 개발(React Native), 데스크톱 애플리케이션(Electron) 등 다양한 환경에서 사용된다.
...</p></div><footer class=entry-footer><span title='2025-01-19 00:43:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;796 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Typescript vs. Javascript" href=https://buenhyden.github.io/posts/programming-languages/typescript/typescript-vs-javascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Async and Await</h2></header><div class=entry-content><p>Async and Await 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-02 09:47:00 +0000 UTC'>January 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Async and Await" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/promises/async-and-await/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/javascript/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>