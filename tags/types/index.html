<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/types/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/types/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/types/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Types</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.
이름에서 알 수 있듯이, 마치 물속에서 공기 방울이 떠오르는 것처럼 큰 값들이 배열의 끝으로 ‘부글부글’ 올라가는 모습을 연상시킨다.
이 알고리즘은 단순함 때문에 컴퓨터 과학 입문 과정에서 가장 먼저 배우는 정렬 알고리즘이지만, 실제 응용에서는 비효율성 때문에 잘 사용되지 않는다. 그럼에도 불구하고, 버블 정렬의 작동 방식과 특성을 이해하는 것은 다른 정렬 알고리즘의 기초를 다지는 데 중요하다.
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 구현이 쉽고 이해하기 직관적이다. 그러나 O(n²)의 시간 복잡도로 인해 대규모 데이터셋에서는 비효율적이며, 실제 응용에서는 퀵 정렬, 병합 정렬, 힙 정렬과 같은 더 효율적인 알고리즘들이 선호된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/bubble-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Native Compiler</h2></header><div class=entry-content><p>Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.
네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/compilers-and-programming-language-theory/language-processor/compiler/types/native-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ANSI</h2></header><div class=entry-content><p>ANSI “ANSI 인코딩"이라는 용어는 실제로 약간의 혼란을 불러일으키는 명칭이다.
엄밀히 말하면, ANSI(American National Standards Institute)는 표준을 개발하고 승인하는 미국 비영리 조직의 이름이지, 특정 문자 인코딩이 아니다. 그러나 이 용어는 일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.
실제로 “ANSI 인코딩"이라고 불리는 것은 다음과 같다:
Windows 코드 페이지: Windows에서 기본 8비트 문자 세트로 사용되는 인코딩 ISO-8859 계열의 확장: ASCII의 7비트를 8비트로 확장한 다양한 문자 세트 로컬 시스템의 기본 인코딩: Windows의 지역 설정에 따라 달라지는 인코딩 이러한 혼란은 Windows가 등장한 초기에 마이크로소프트가 당시 발전 중이던 ANSI 표준을 기반으로 문자 세트를 개발했기 때문에 발생했다. 그러나 이 문자 세트들은 결국 정식 ANSI 표준으로 채택되지 않았으나, 이름은 그대로 남게 되었다.
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ANSI" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비꼬리 재귀(Non-tail Recursion)</h2></header><div class=entry-content><p>비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.
이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.
비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.
이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.
그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비꼬리 재귀(Non-tail Recursion)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>선택 정렬 (Selection Sort)</h2></header><div class=entry-content><p>선택 정렬 (Selection Sort) 선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.
선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.
선택 정렬의 핵심 특징은 다음과 같다:
구현이 매우 간단합니다. 교환 연산의 수가 적습니다(최대 n-1번). 메모리 사용이 최소화된다. 입력 데이터의 상태와 관계없이 일정한 성능을 보인다. 더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선택 정렬 (Selection Sort)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 탐색은 정렬된 배열에서 특정 값을 찾기 위한 효율적인 알고리즘이다.
일반적인 선형 탐색보다 훨씬 빠르며, 특히 대규모 데이터셋에서 그 효율성이 두드러진다.
이진 탐색은 간단하면서도 강력한 알고리즘으로, 정렬된 데이터에서 매우 효율적인 검색을 가능하게 한다.
O(log n)의 시간 복잡도는 대규모 데이터셋에서 특히 중요하다.
이 알고리즘을 마스터하면 다양한 문제 해결과 시스템 최적화에 적용할 수 있다.
이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/searching/types/binary-search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cross Compiler</h2></header><div class=entry-content><p>Cross Compiler 크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러이다. 이는 임베디드 시스템이나 운영체제 개발처럼 대상 시스템이 컴파일러를 직접 실행하기에 부적합한 경우에 자주 사용되며, 한 개발 환경에서 여러 플랫폼용 소프트웨어를 동시에 개발할 수 있게 해준다.
크로스 컴파일러는 소프트웨어 개발의 다양한 분야, 특히 임베디드 시스템, 모바일 애플리케이션, 게임 콘솔, IoT 기기 개발에서 필수적인 도구이다. 이 기술은 개발자가 한 시스템에서 개발하면서 다양한 타겟 플랫폼용 코드를 생성할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:29:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cross Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/compilers-and-programming-language-theory/language-processor/compiler/types/cross-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CP949</h2></header><div class=entry-content><p>CP949 CP949(Code Page 949)는 한국어 문자를 표현하기 위해 마이크로소프트가 개발한 문자 인코딩이다.
한국어 환경에서 오랫동안 사용되어 온 이 인코딩은 현대 소프트웨어 개발에서도 여전히 중요한 역할을 하고 있다.
CP949는 한국어 컴퓨팅 역사에서 중요한 역할을 했으며, 여전히 많은 레거시 시스템과 Windows 환경에서 사용되고 있다. 모든 한글 조합을 지원하기 위해 EUC-KR을 확장한 이 인코딩은 2바이트 멀티바이트 구조를 사용하여 한글을 효율적으로 표현한다.
현대 IT 개발 환경에서는 국제화, 표준화, 호환성 등의 이유로 UTF-8이 권장되지만, CP949에 대한 이해는 다음과 같은 상황에서 여전히 중요하다:
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CP949" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/cp949/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>tail Recursion vs. Non-tail Recursion</h2></header><div class=entry-content><p>Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.
특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.
꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to tail Recursion vs. Non-tail Recursion" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/types/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>