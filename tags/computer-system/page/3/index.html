<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-System | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-System"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-System"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>세그먼테이션 (Segmentation)</h2></header><div class=entry-content><p>세그먼테이션 (Segmentation) 세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.
세그먼테이션의 기본 개념을 이해하기 위해, 먼저 프로그램의 구조를 생각해보자.
일반적인 프로그램은 코드 영역, 데이터 영역, 스택 영역 등 서로 다른 목적을 가진 영역들로 구성된다.
세그먼테이션은 이러한 논리적 단위들을 각각의 세그먼트로 관리한다.
Source: https://www.geeksforgeeks.org/segmentation-in-operating-system/
세그먼테이션의 주요 구성 요소와 작동 방식 세그먼트 테이블(Segment Table):
1 2 3 4 5 6 7 8 9 10 struct SegmentTableEntry { uint32_t base; // 세그먼트의 시작 주소 uint32_t limit; // 세그먼트의 크기 bool present; // 메모리 존재 여부 struct { bool read; // 읽기 권한 bool write; // 쓰기 권한 bool execute; // 실행 권한 } protection; }; 주소 변환 과정:
논리적 주소는 다음과 같이 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;314 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 세그먼테이션 (Segmentation)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>페이징 (Paging)</h2></header><div class=entry-content><p>페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.
이는 두 가지 큰 문제를 발생시켰다:
큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.
이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.
Source: https://www.geeksforgeeks.org/paging-in-operating-system/
페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페이징 (Paging)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>메시지 큐(Message Queue) 프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.
메시지 큐는 커널 내에 저장된 메시지의 연결 리스트로, 고유한 식별자로 구분된다.
이는 프로세스들이 비동기적으로 통신할 수 있게 해주는 IPC 메커니즘이다.
메시지 크기 제한과 시스템 리소스 사용 등의 단점도 고려해야 한다.
적절한 사용 시나리오를 파악하고 효과적으로 활용하는 것이 중요하다.
Source: https://www.javatpoint.com/ipc-using-message-queues
메시지 큐의 특징 커널 관리: 메시지 큐는 커널에 의해 관리되어 안정성이 높고 동기화가 용이하다. FIFO 순서: 메시지는 일반적으로 선입선출(FIFO) 순서로 처리된다. 비동기 통신: 송신 프로세스와 수신 프로세스가 동시에 활성화될 필요가 없다. 메시지 구조: 각 메시지는 타입 필드, 길이, 실제 데이터로 구성된다. 프로세스 분리: 메시지 큐를 사용하면 프로세스들이 서로 직접 연결되지 않아도 된다. 메시지 큐의 주요 시스템 호출 ftok(): 고유한 키를 생성한다. msgget(): 메시지 큐를 생성하거나 기존 큐의 식별자를 반환한다. msgsnd(): 메시지를 큐에 추가한다. msgrcv(): 큐에서 메시지를 검색한다. msgctl(): 큐에 대한 다양한 작업을 수행한다. 메시지 큐 사용 방법 메시지 큐 생성:
...</p></div><footer class=entry-footer><span title='2024-10-20 12:03:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Memory</h2></header><div class=entry-content><p>공유 메모리(Shared Memory) 공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.
이는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있게 해주며, IPC 메커니즘 중에서 가장 빠른 통신 방법을 제공한다.
Source: https://www.geeksforgeeks.org/ipc-shared-memory/
작동 원리 프로세스가 커널에 공유 메모리 할당을 요청 커널이 해당 프로세스에 메모리 공간을 할당 이후 다른 프로세스들도 해당 메모리 영역에 접근 가능 공유 메모리의 생성과 관리 공유 메모리를 사용하는 일반적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-20 12:03:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Memory" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/shared-memory/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pipe</h2></header><div class=entry-content><p>파이프(Pipe) 파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.
종류 익명 파이프 (Anonymous Pipe): 부모-자식 프로세스 간 통신에 사용
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os def create_anonymous_pipe(): """익명 파이프 생성 예제""" read_fd, write_fd = os.pipe() pid = os.fork() # 프로세스 생성 if pid > 0: # 부모 프로세스 os.close(read_fd) # 읽기 끝 닫기 os.write(write_fd, "Hello from parent".encode()) os.close(write_fd) else: # 자식 프로세스 os.close(write_fd) # 쓰기 끝 닫기 message = os.read(read_fd, 1024).decode() print(f"Child received: {message}") os.close(read_fd) 이름 있는 파이프 (Named Pipe 또는 FIFO): 관련 없는 프로세스 간 통신에 사용
...</p></div><footer class=entry-footer><span title='2024-10-20 12:02:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/pipe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로세스 제어 블록(Process Control Block, PCB)</h2></header><div class=entry-content><p>프로세스 제어 블록(Process Control Block, PCB) 프로세스 제어 블록(Process Control Block, PCB)은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다.
PCB는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.
Sourece: https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/
PCB의 주요 구성 요소 프로세스 식별자(Process ID, PID): 각 프로세스에 할당되는 고유한 식별 번호이다. 프로세스 상태(Process State): 프로세스의 현재 상태를 나타낸다. 주요 상태로는 생성(new), 준비(ready), 실행(running), 대기(waiting), 종료(terminated) 등이 있다. 프로그램 카운터(Program Counter): 다음에 실행할 명령어의 주소를 가리킨다. CPU 레지스터: 프로세스가 CPU를 사용할 때의 레지스터 정보를 저장한다. CPU 스케줄링 정보: 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보를 포함한다. 메모리 관리 정보: 프로세스의 메모리 할당 정보, 페이지 테이블 등을 저장한다. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등을 관리한다. 계정 정보: CPU 사용 시간, 메모리 사용량 등 프로세스의 리소스 사용 정보를 추적한다. PCB의 역할과 중요성 프로세스 관리: PCB는 운영 체제가 프로세스의 생명주기를 관리하는 데 필수적이다. 컨텍스트 스위칭: PCB는 프로세스 간 전환 시 현재 상태를 저장하고 복원하는 데 사용된다. 스케줄링: 운영 체제는 PCB의 정보를 바탕으로 프로세스 스케줄링 결정을 내린다. 리소스 관리: PCB는 프로세스에 할당된 리소스를 추적하고 관리한다. 동기화 및 통신: 프로세스 간 동기화와 통신에 필요한 정보를 저장한다. PCB의 생명주기 프로세스 생성 시 PCB가 생성되고 초기화된다. 프로세스 실행 중 PCB 정보가 지속적으로 업데이트된다. 프로세스 종료 시 PCB가 제거된다. PCB의 구현 및 저장 PCB는 운영 체제 커널의 보호된 메모리 영역에 저장된다.
일부 운영 체제에서는 PCB를 커널 스택의 시작 부분에 위치시킨다.
...</p></div><footer class=entry-footer><span title='2024-10-20 06:59:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;261 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 제어 블록(Process Control Block, PCB)" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-control-block/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process Scheduling</h2></header><div class=entry-content><p>프로세스 스케쥴링 (Process Scheduling) 프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘.
프로세스 스케줄링도 다양한 요소를 고려하여 최적의 실행 순서를 결정한다.
주요 특징 CPU 활용도 극대화: I/O 대기 시간 동안 다른 프로세스에 CPU를 할당하여 유휴 시간을 최소화합니다. 처리량 증가: 단위 시간당 완료되는 프로세스의 수를 늘립니다. 응답 시간 최소화: 사용자 요청에 대한 시스템의 반응 속도를 향상시킵니다. 대기 시간 감소: 프로세스가 준비 큐에서 기다리는 시간을 줄입니다. 공정성 유지: 모든 프로세스에 적절한 CPU 시간을 할당합니다. 스케줄링의 목적 CPU 활용도 최대화
...</p></div><footer class=entry-footer><span title='2024-10-20 06:21:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Scheduling" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Context Switching</h2></header><div class=entry-content><p>Context Switching Context Switching은 운영 체제에서 매우 중요한 개념으로, 여러 프로세스나 스레드가 단일 CPU 자원을 공유하여 효율적으로 실행될 수 있게 하는 메커니즘이다.
Context Switching은 CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 불러와 실행을 재개하는 과정을 말한다.
이를 통해 여러 작업이 동시에 실행되는 것처럼 보이게 된다.
Source: https://www.geeksforgeeks.org/context-switch-in-operating-system/
Context Switching의 필요성 멀티태스킹: 여러 프로세스가 동시에 실행되는 것처럼 보이게 하여 시스템 효율성을 높인다. 인터럽트 처리: 하드웨어 인터럽트나 시스템 호출 등에 신속하게 대응할 수 있다. 자원 공유: 단일 CPU로 여러 프로세스를 실행할 수 있게 한다. Context Switching의 과정 현재 실행 중인 프로세스의 상태 저장: CPU 레지스터, 프로그램 카운터 등의 정보를 PCB(Process Control Block)에 저장한다. 새로운 프로세스 선택: 스케줄러가 다음에 실행할 프로세스를 선택한다. 새 프로세스의 상태 복원: 선택된 프로세스의 PCB에서 상태 정보를 불러와 CPU 레지스터에 복원한다. 실행 재개: 새 프로세스의 실행을 시작한다. Context Switching의 트리거 인터럽트: 하드웨어나 소프트웨어에서 발생하는 인터럽트. 시간 할당 종료: 프로세스에 할당된 CPU 시간이 끝났을 때. I/O 요청: 프로세스가 I/O 작업을 요청하여 대기 상태로 전환될 때. 우선순위: 더 높은 우선순위의 프로세스가 실행 준비될 때. Context Switching의 구현 방식 하드웨어 스위칭: 프로세서 코어에 내장된 태스크 상태 세그먼트(TSS)를 사용한다. 소프트웨어 스위칭: 운영 체제의 커널 루틴과 데이터 구조를 사용하여 구현한다. 더 빠르고 일관성 있는 방식이다. Context Switching의 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-20 01:00:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Context Switching" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/context-switching/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>잠금 (Lock)</h2></header><div class=entry-content><p>잠금 (Lock) 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 기본 요소이다.
임계 영역을 보호하고 한 번에 하나의 스레드만 접근할 수 있도록 한다.
스레드가 임계 영역에 진입하기 전에 lock을 획득(acquire)하고, 임계 영역을 빠져나올 때 lock을 해제(release)한다. 다른 스레드가 이미 lock을 보유하고 있다면, lock을 획득하려는 스레드는 lock이 해제될 때까지 대기한다.
Lock은 두 가지 상태를 가진다:
잠금 해제 상태 (Unlocked): 다른 프로세스나 스레드가 Lock을 획득할 수 있는 상태 잠금 상태 (Locked): 이미 한 프로세스나 스레드가 Lock을 보유하고 있는 상태 작동 방식 Lock 획득 (acquire): 스레드가 임계 영역에 진입하기 전에 lock을 획득합니다. 임계 영역 실행: lock을 획득한 스레드만 임계 영역의 코드를 실행할 수 있습니다. Lock 해제 (release): 임계 영역을 빠져나올 때 lock을 해제합니다. Lock을 사용할 때 고려해야할 사항 Lock의 범위는 가능한 한 작게 유지하여 성능 저하를 최소화한다. Lock을 획득하는 시간을 최소화하여 다른 스레드의 대기 시간을 줄인다. 데드락을 방지하기 위해 Lock 획득 순서를 일관되게 유지한다. 예외 상황에서도 Lock이 올바르게 해제되도록 보장한다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import threading class BankAccount: def __init__(self): self.balance = 1000 self.lock = threading.Lock() # Lock 객체 생성 def withdraw(self, amount): # Lock을 획득 시도. 이미 잠겨있다면 획득할 때까지 대기 self.lock.acquire() try: if self.balance >= amount: # 잔액 확인과 차감이 하나의 원자적 작업으로 수행됨 current_balance = self.balance current_balance -= amount self.balance = current_balance print(f"출금 성공: {amount}, 잔액: {self.balance}") else: print("잔액 부족") finally: # 예외가 발생하더라도 반드시 Lock을 해제 self.lock.release() Lock의 유형 공유 락(Shared Lock)과 배타 락(Exclusive Lock) 공유 락(Shared Lock):
여러 스레드가 동시에 리소스를 읽을 수 있지만, 쓰기는 불가능한 락. 읽기 작업에 사용되는 락(Lock) 여러 스레드가 동시에 획득 가능 쓰기 작업을 차단함 배타 락(Exclusive Lock):
한 번에 하나의 스레드만 리소스에 접근할 수 있는 락. 쓰기 작업에 사용되는 락(Lock). 다른 세션의 읽기와 쓰기를 모두 막는다. 데이터 일관성 보장에 유용. 동시성이 낮음. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import threading from typing import Set, Optional class SharedExclusiveLock: def __init__(self): self._lock = threading.Lock() self._shared_holders: Set[int] = set() # 공유 락을 보유한 스레드들 self._exclusive_holder: Optional[int] = None # 배타 락을 보유한 스레드 self._shared_count = 0 self._condition = threading.Condition(self._lock) def acquire_shared(self) -> bool: """공유 락 획득""" with self._lock: while self._exclusive_holder is not None: self._condition.wait() thread_id = threading.get_ident() self._shared_holders.add(thread_id) self._shared_count += 1 return True def release_shared(self): """공유 락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._shared_holders: raise RuntimeError("공유 락을 보유하고 있지 않습니다") self._shared_holders.remove(thread_id) self._shared_count -= 1 if self._shared_count == 0: self._condition.notify_all() def acquire_exclusive(self) -> bool: """배타 락 획득""" with self._lock: while self._exclusive_holder is not None or self._shared_count > 0: self._condition.wait() self._exclusive_holder = threading.get_ident() return True def release_exclusive(self): """배타 락 해제""" with self._lock: if self._exclusive_holder != threading.get_ident(): raise RuntimeError("배타 락을 보유하고 있지 않습니다") self._exclusive_holder = None self._condition.notify_all() # 사용 예시 def reader(lock: SharedExclusiveLock, reader_id: int): """읽기 작업을 수행하는 스레드""" print(f"Reader {reader_id} 시작") lock.acquire_shared() try: print(f"Reader {reader_id} 읽기 작업 수행 중…") time.sleep(1) finally: lock.release_shared() print(f"Reader {reader_id} 종료") def writer(lock: SharedExclusiveLock, writer_id: int): """쓰기 작업을 수행하는 스레드""" print(f"Writer {writer_id} 시작") lock.acquire_exclusive() try: print(f"Writer {writer_id} 쓰기 작업 수행 중…") time.sleep(2) finally: lock.release_exclusive() print(f"Writer {writer_id} 종료") 업데이트 락(Update Lock)과 의도 락(Intent Lock) 업데이트 락(Update Lock):
읽기는 허용하지만, 다른 업데이트 락이나 배타 락의 획득을 방지하는 락(Lock). 읽기 작업은 허용하지만 다른 업데이트나 쓰기 작업은 차단. 읽기-쓰기 전환 시 데드락 방지에 유용하다. Conversion Deadlock을 방지하기 위해 사용된다. 수정을 위해 베타 락(Exclusive Lock)을 걸기 전에 사용하는 락(Lock). 의도 락(Intent Lock):
상위 레벨 리소스에 대한 락을 설정하기 전에 사용되는 락. 계층적 락킹 구조에서 사용. 다른 트랜잭션에게 락 의도를 알림. 데이터베이스 시스템에서 주로 사용됨. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import threading from enum import Enum, auto from typing import Dict, Set class LockType(Enum): INTENT_SHARED = auto() INTENT_EXCLUSIVE = auto() UPDATE = auto() SHARED = auto() EXCLUSIVE = auto() class HierarchicalLock: def __init__(self): self._lock = threading.Lock() self._holders: Dict[LockType, Set[int]] = { lock_type: set() for lock_type in LockType } self._condition = threading.Condition(self._lock) def _can_acquire(self, lock_type: LockType, thread_id: int) -> bool: """주어진 락 타입을 획득할 수 있는지 확인""" if lock_type == LockType.UPDATE: # 업데이트 락은 공유 락과 호환되지만 다른 업데이트 락과는 호환되지 않음 return not (self._holders[LockType.EXCLUSIVE] or self._holders[LockType.UPDATE]) elif lock_type == LockType.INTENT_SHARED: # 의도 공유 락은 배타 락과만 충돌 return not self._holders[LockType.EXCLUSIVE] # … 다른 락 타입에 대한 호환성 검사 로직 추가 def acquire(self, lock_type: LockType) -> bool: """락 획득""" with self._lock: thread_id = threading.get_ident() while not self._can_acquire(lock_type, thread_id): self._condition.wait() self._holders[lock_type].add(thread_id) return True def release(self, lock_type: LockType): """락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._holders[lock_type]: raise RuntimeError(f"{lock_type} 락을 보유하고 있지 않습니다") self._holders[lock_type].remove(thread_id) self._condition.notify_all() 스핀 락 (Spin Lock) 락을 획득할 때까지 계속해서 확인하는 바쁜 대기(busy-waiting) 방식의 락.
...</p></div><footer class=entry-footer><span title='2024-10-19 10:54:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1400 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 잠금 (Lock)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/lock/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>상호 배제 (Mutual Exclusion)</h2></header><div class=entry-content><p>상호 배제 (Mutual Exclusion) 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘.
한 번에 하나의 프로세스나 스레드만 임계 영역(critical section)에 진입할 수 있도록 보장하는 기법이다.
필요한 이유:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 상호 배제가 없는 경우의 문제점 class BankAccount: def __init__(self): self.balance = 1000 def withdraw(self, amount): # 다음 세 줄의 작업이 원자적이지 않음 current_balance = self.balance # 잔액 읽기 current_balance = current_balance - amount # 계산 self.balance = current_balance # 결과 저장 # 두 스레드가 동시에 실행되면 문제가 발생할 수 있음 account = BankAccount() # 스레드 1: withdraw(500) # 스레드 2: withdraw(500) # 예상 잔액: 0, 실제 잔액: 500 (잘못된 결과) 목적 데이터 무결성 유지: 여러 프로세스가 동시에 공유 데이터를 수정하는 것을 방지한다. 경쟁 조건(Race Condition) 예방: 프로세스 실행 순서에 따른 결과 불일치를 막는다. 교착 상태(Deadlock)와 기아 상태(Starvation) 방지: 자원 할당의 효율성을 높인다. 구현 방법 잠금(Lock)
가장 기본적인 동기화 메커니즘으로, 한 번에 하나의 스레드만 임계 영역에 접근할 수 있게 한다.
...</p></div><footer class=entry-footer><span title='2024-10-19 07:50:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상호 배제 (Mutual Exclusion)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-system/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/computer-system/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>