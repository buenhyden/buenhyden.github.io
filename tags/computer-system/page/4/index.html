<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-System | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-System"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-System"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/computer-science/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Invalidation</h2></header><div class=entry-content><p>Cache Invalidation Cache Invalidation(캐시 무효화)는 캐시에 저장된 데이터가 더 이상 최신 상태가 아니거나 유효하지 않을 때, 이를 무효화하여 캐시가 최신 데이터를 제공하도록 보장하는 과정이다.
캐시 무효화는 캐싱 시스템에서 데이터 일관성을 유지하고, 잘못된 데이터를 반환하지 않도록 하기 위해 필수적인 메커니즘이다.
Cache Invalidation은 캐싱 시스템에서 필수적인 요소로, 데이터 일관성을 유지하고 잘못된 정보를 방지하기 위해 사용된다. Expiration(TTL), Active Invalidation, Validation-based Caching 등 다양한 전략을 상황에 맞게 선택해야 하며, 구현 시 성능과 복잡성을 균형 있게 고려해야 한다. 올바른 설계와 전략 선택은 시스템의 신뢰성과 효율성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Invalidation" href=https://buenhyden.github.io/posts/system-design/caching/cache-invalidation/cache-invalidation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy</h2></header><div class=entry-content><p>Cache Strategy Cache Strategy(캐시 전략) 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.
캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.
캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy" href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy/cache-strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Caching Techniques</h2></header><div class=entry-content><p>Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.
브라우저 캐싱 (Browser Caching)
브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.
사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.
이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 02:37:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Techniques" href=https://buenhyden.github.io/posts/system-design/caching/types/caching-techniques/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-29 16:44:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-science/computer-architecture/cpu/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>파이프라이닝 (Pipelining)</h2></header><div class=entry-content><p>파이프라이닝 (Pipelining) 프로세서 아키텍처에서의 파이프라이닝(Pipelining)은 CPU의 성능을 향상시키는 중요한 기술이다.
파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.
현대 프로세서 설계에서 필수적인 기술이며, 대부분의 현대 CPU는 최소 2단계에서 최대 30-40단계의 파이프라인을 사용한다.
이 기술을 통해 프로세서의 전체적인 성능을 크게 향상시킬 수 있지만, 효과적인 구현을 위해서는 복잡한 설계 고려사항들을 신중히 관리해야 한다.
Source: https://www.geeksforgeeks.org/pipelined-architecture-with-its-diagram/
파이프라이닝의 작동 원리 파이프라이닝은 명령어 실행 과정을 여러 단계로 나누어 처리한다.
일반적인 파이프라인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-29 02:20:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 파이프라이닝 (Pipelining)" href=https://buenhyden.github.io/posts/computer-science/computer-architecture/processor-architecture/microarchitecture/pipelining/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-science/computer-architecture/types/harvard-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Von Neumann architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.
Source: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/
특징 순차적 실행:
명령어를 메모리에서 한 번에 하나씩 순차적으로 가져와 실행 레지스터:
프로그램 카운터 (PC): 다음 실행할 명령어의 주소 저장 명령어 레지스터 (CIR): 현재 실행 중인 명령어 저장 메모리 주소 레지스터 (MAR): 접근할 메모리 주소 저장 메모리 데이터 레지스터 (MDR): 메모리와 주고받는 데이터 저장 누산기 (Accumulator): 연산 결과 임시 저장 버스 시스템:
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann architecture" href=https://buenhyden.github.io/posts/computer-science/computer-architecture/types/von-neumann-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-system/page/3/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>