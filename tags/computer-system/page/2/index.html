<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-System | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-System"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-System"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Prefetch Policy</h2></header><div class=entry-content><p>Prefetch Policy Cache Policy의 Prefetch Policy는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.
이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.
Prefetching은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.
이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.
Prefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.
Prefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.
하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prefetch Policy" href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/prefetch-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy Cache Replacement Policy(캐시 교체 정책) 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.
Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/replacement-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Placement Policy</h2></header><div class=entry-content><p>Placement Policy Cache Placement Policy는 캐시 메모리에서 특정 메모리 블록이 캐시에 저장될 위치를 결정하는 규칙을 의미한다.
이는 캐시의 구조와 데이터 접근 패턴에 따라 성능과 효율성에 큰 영향을 미친다. Placement Policy는 캐시 메모리의 설계와 운영에서 중요한 역할을 하며, 주로 다음 세 가지 주요 유형으로 나뉜다:
Direct-Mapped Cache Fully Associative Cache Set-Associative Cache. Cache Placement Policy란? 정의: Placement Policy는 특정 메모리 블록이 캐시에 저장될 때, 캐시 내에서 어느 위치(캐시 라인)에 저장될지를 결정하는 규칙이다. 목적: 캐시 메모리의 효율적인 사용. 데이터 접근 속도 최적화. 충돌(Collision) 관리: 동일한 캐시 라인에 여러 데이터가 매핑되는 상황을 최소화. Cache Placement Policy는 데이터가 캐시에 저장되는 위치를 결정하며, 시스템 성능과 효율성에 직접적인 영향을 미친다.
Direct-Mapped, Fully Associative, Set-Associative 각각 장단점이 있으므로, 애플리케이션 요구사항과 하드웨어 제약 조건을 고려하여 적절한 정책을 선택해야 한다.
Set-Associative는 대부분의 현대 시스템에서 자주 사용되는 절충안으로, 성능과 비용 간 균형을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:50:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Placement Policy" href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/placement-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-30 08:05:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/access-methods/memory-access-methods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-30 08:04:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/address-modes/memory-address-modes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Caching Techniques</h2></header><div class=entry-content><p>Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.
브라우저 캐싱 (Browser Caching)
브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.
사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.
이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 02:37:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Techniques" href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/types/caching-techniques/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-29 16:44:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/cpu/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>파이프라이닝 (Pipelining)</h2></header><div class=entry-content><p>파이프라이닝 (Pipelining) 프로세서 아키텍처에서의 파이프라이닝(Pipelining)은 CPU의 성능을 향상시키는 중요한 기술이다.
파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.
현대 프로세서 설계에서 필수적인 기술이며, 대부분의 현대 CPU는 최소 2단계에서 최대 30-40단계의 파이프라인을 사용한다.
이 기술을 통해 프로세서의 전체적인 성능을 크게 향상시킬 수 있지만, 효과적인 구현을 위해서는 복잡한 설계 고려사항들을 신중히 관리해야 한다.
Source: https://www.geeksforgeeks.org/pipelined-architecture-with-its-diagram/
파이프라이닝의 작동 원리 파이프라이닝은 명령어 실행 과정을 여러 단계로 나누어 처리한다.
일반적인 파이프라인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-29 02:20:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 파이프라이닝 (Pipelining)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/processor-architecture/microarchitecture/pipelining/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/harvard-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-system/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/computer-system/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>