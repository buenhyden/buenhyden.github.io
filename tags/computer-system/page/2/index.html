<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer-System | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/computer-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/computer-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/computer-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/computer-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer-System"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer-System"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Computer-System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Von Neumann Architecture vs Harvard Architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Vs Harvard Architecture 하버드 아키텍처(Harvard Architecture)와 폰 노이만 아키텍처(von Neumann Architecture)는 컴퓨터 시스템의 메모리 구조를 정의하는 두 가지 대표적인 설계 방식이다.
각 아키텍처는 메모리와 버스 구조에 대한 접근 방식에서 차이를 보이며, 이에 따라 성능, 설계 복잡성, 활용 분야 등에서 차별화된다.
특성 하버드 아키텍처 폰 노이만 아키텍처 메모리 구조 명령어와 데이터를 위한 별도의 메모리 명령어와 데이터가 동일한 메모리에 저장 버스 구조 명령어 버스와 데이터 버스가 분리 하나의 공유 버스 사용 병렬 처리 명령어 fetch와 데이터 접근을 동시에 수행 가능 명령어 fetch와 데이터 접근을 순차적으로 수행 성능 일반적으로 더 빠른 실행 속도 메모리 병목 현상으로 인해 상대적으로 느림 복잡성 하드웨어 구조가 더 복잡 상대적으로 단순한 구조 비용 일반적으로 더 높은 구현 비용 상대적으로 낮은 구현 비용 유연성 메모리 사용의 유연성이 낮음 메모리 사용의 유연성이 높음 보안성 프로그램과 데이터 분리로 인한 높은 보안성 상대적으로 낮은 보안성 주요 응용 분야 임베디드 시스템, DSP, 마이크로컨트롤러 범용 컴퓨터, 개인용 컴퓨터 메모리 접근 동시에 명령어와 데이터 접근 가능 순차적 메모리 접근 명령어 실행 1 사이클에 1 명령어 실행 가능 여러 사이클에 걸쳐 명령어 실행 메모리 확장 명령어와 데이터 메모리 독립적 확장 가능 단일 메모리 확장 전력 효율성 일반적으로 더 높은 전력 효율성 상대적으로 낮은 전력 효율성 캐시 구조 명령어 캐시와 데이터 캐시 분리 통합 캐시 또는 분리된 캐시 사용 가능 이 두 아키텍처는 각각의 장단점을 가지고 있으며, 현대의 많은 프로세서들은 두 아키텍처의 장점을 결합한 하이브리드 구조를 채택하고 있다. 예를 들어, 내부적으로는 하버드 구조를 사용하여 성능을 향상시키고, 외부적으로는 폰 노이만 구조를 유지하여 유연성을 확보하는 방식을 사용한다.
...</p></div><footer class=entry-footer><span title='2024-09-21 05:34:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;244 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann Architecture vs Harvard Architecture" href=https://buenhyden.github.io/til/2024/09/21/von-neumann-architecture-vs-harvard-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deadlock vs Livelock</h2></header><div class=entry-content><p>Deadlock Vs Livelock 데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다.
데드락(Deadlock)은 두 개 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 상태를 말하며, 상호 배제(Mutual Exclusion), 점유 대기(Hold and Wait), 비선점(No Preemption), 순환 대기(Circular Wait) 등의 조건이 충족되어야 한다. 예를 들어, 프로세스 A가 자원 X를 점유하고, 프로세스 B가 자원 Y를 점유한 상태에서, A는 Y를, B는 X를 요청하면 데드락이 발생한다
...</p></div><footer class=entry-footer><span title='2024-10-18 07:03:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deadlock vs Livelock" href=https://buenhyden.github.io/til/2024/10/18/deadlock-vs-livelock/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Allocation Policy</h2></header><div class=entry-content><p>Allocation Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Allocation Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/allocation-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Prefetch Policy</h2></header><div class=entry-content><p>Prefetch Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prefetch Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/prefetch-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/replacement-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Write Policy</h2></header><div class=entry-content><p>Write Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Write Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Placement Policy</h2></header><div class=entry-content><p>Placement Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-23 10:50:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Placement Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/placement-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process</h2></header><div class=entry-content><p>Process 프로세스는 실행 중인 프로그램의 인스턴스.
구체적으로는 운영체제가 관리하는 작업의 단위로, CPU 시간이나 메모리와 같은 시스템 자원을 할당받아 실행되는 프로그램의 동적인 실체를 의미한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
특징 독립성: 각 프로세스는 독립된 메모리 공간을 가진다. 동시성: 여러 프로세스가 동시에 실행될 수 있다. 상태 변화: 프로세스는 실행 중 여러 상태를 거친다. 기능과 역할 기능:
작업 단위: 운영체제가 관리하는 작업의 기본 단위입니다. 프로그램 코드 실행: 프로세스는 프로그램의 명령어들을 순차적으로 실행합니다. 자원 관리: 할당받은 시스템 자원을 효율적으로 사용하고 관리합니다. 프로세스 간 통신: 다른 프로세스와 정보를 교환하고 협력합니다. 역할:
...</p></div><footer class=entry-footer><span title='2024-10-20 23:32:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>소켓(Socket)</h2></header><div class=entry-content><p>소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.
소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.
운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.
소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:
프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-20 16:30:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;561 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소켓(Socket)" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>가상 메모리 (Virtual Memory)</h2></header><div class=entry-content><p>가상 메모리 (Virtual Memory) 가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.
실제 물리적 메모리(RAM)의 크기에 관계없이 프로그램이 사용할 수 있는 메모리 공간을 확장하며, 프로그램의 주소 공간을 실제 메모리에서 분리하여 가상 주소 공간을 제공한다.
가상 메모리가 필요한 이유:
메모리 제약 극복
프로그램의 크기가 실제 물리적 메모리보다 클 수 있다.
예를 들어 16GB RAM을 가진 컴퓨터에서 20GB가 필요한 프로그램을 실행할 수 있게 된다. 메모리 보호
각 프로세스는 자신만의 가상 주소 공간을 가지므로, 다른 프로세스의 메모리에 접근할 수 없다. 메모리 효율성
실제로 사용되는 부분만 물리적 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있다. Source: https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1121 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가상 메모리 (Virtual Memory)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/computer-system/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/computer-system/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>