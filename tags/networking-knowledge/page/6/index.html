<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking-Knowledge | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/networking-knowledge/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/networking-knowledge/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/networking-knowledge/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/networking-knowledge/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking-Knowledge"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking-Knowledge"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Networking-Knowledge</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>네트워크 주소 변환 (NAT, Network Address Translation)</h2></header><div class=entry-content><p>네트워크 주소 변환 (NAT, Network Address Translation) 네트워크 주소 변환(NAT, Network Address Translation)은 IP 패킷의 TCP/UDP 포트 번호와 소스 및 목적지의 IP 주소를 재기록하면서 라우터를 통해 네트워크 트래픽을 주고받는 기술이다.
NAT 를 이용하는 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함으로, 등록되지 않은 IP 주소를 사용하는 사설 IP 네트워크가 인터넷에 연결될 수 있도록 한다.
일반적으로 두 네트워크를 함께 연결하는 라우터에서 작동하며, 패킷이 다른 네트워크로 전달되기 전에 내부 네트워크의 비공개 (전역적으로 고유하지 않음) 주소를 올바른 주소로 변환한다.
...</p></div><footer class=entry-footer><span title='2024-10-17 13:07:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;757 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 주소 변환 (NAT, Network Address Translation)" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/internet-protocol/nat/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CIDR (Classless Inter-Domain Routing)</h2></header><div class=entry-content><p>CIDR (Classless Inter-Domain Routing) CIDR은 1993년에 도입된 IP 주소 할당 및 라우팅 방식으로, 기존의 클래스 기반 주소 체계(Classful Addressing)의 한계를 극복하기 위해 만들어졌다.
인터넷이 급속도로 성장하면서 기존의 고정된 클래스 체계로는 IP 주소를 효율적으로 할당하기 어려워졌고, 이를 해결하기 위해 더 유연한 주소 할당 방식이 필요해지면서 탄생되었다.
네트워크 정보를 여러 개로 나누어진 Sub-Network 들을 모두 나타낼 수 있는 하나의 Network 로 통합해서 보여주는 방법이다.
목적 IP 주소 자원의 낭비를 줄임 라우팅 테이블의 크기를 감소시킴 더 유연하고 효율적인 주소 할당을 제공 특징 주소 집약(Route Aggregation)
CIDR의 가장 중요한 특징 중 하나는 라우팅 테이블을 간소화할 수 있는 주소 집약이다.
예를 들어:
...</p></div><footer class=entry-footer><span title='2024-10-17 11:51:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;934 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CIDR (Classless Inter-Domain Routing)" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/internet-protocol/cidr/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>IP Delivery Modes</h2></header><div class=entry-content><p>IP Delivery Modes 네트워크에서 데이터를 전송하는 다양한 방식.
https://ipcisco.com/lesson/unicast-broadcast-multicast-anycast/#google_vignette
특성 Unicast Multicast Broadcast Anycast 전송 방식 1:1 통신으로, 하나의 송신자가 하나의 특정 수신자에게 데이터를 전송 1:N 통신으로, 하나의 송신자가 특정 그룹에 속한 다수의 수신자에게 동시에 데이터를 전송 1:모두 통신으로, 하나의 송신자가 네트워크 내의 모든 호스트에게 데이터를 전송 1:1/다수 통신으로, 하나의 송신자가 동일한 주소를 가진 여러 노드 중 가장 가까운 하나의 노드에게 데이터를 전송 주소 체계 각 호스트마다 고유한 IP 주소 사용 Class D IP 주소(224.0.0.0 ~ 239.255.255.255) 사용. IPv6에서는 ff00::/8 프리픽스 사용 IPv4에서 네트워크 주소의 호스트 부분이 모두 1인 주소 사용 동일한 유니캐스트 주소를 여러 노드가 공유 트래픽 효율성 수신자가 많을 경우 네트워크 부하가 증가하여 비효율적 그룹 멤버들에게 한 번의 전송으로 데이터 전달이 가능하여 효율적 모든 호스트에게 전송되어 불필요한 트래픽 발생 가능성이 높음 가까운 노드에게만 전송되어 효율적이며, 로드 밸런싱 효과 있음 주요 용도 일반적인 인터넷 통신, 이메일, 웹 브라우징 등 화상 회의, IPTV, 소프트웨어 배포, 실시간 주식 정보 전송 등 네트워크 설정 정보 전파, DHCP, ARP 등 DNS 서버, CDN 서비스, 로드 밸런싱이 필요한 서비스 신뢰성 TCP를 사용할 경우 높은 신뢰성 보장 UDP 기반으로 동작하여 상대적으로 신뢰성이 낮음. 필요시 응용 계층에서 신뢰성 보장 메커니즘 구현 필요 신뢰성이 낮으며, 일반적으로 UDP 사용 유니캐스트와 동일한 수준의 신뢰성 제공 IPv4 지원 지원 지원 지원 제한적 지원 IPv6 지원 지원 지원 (향상된 기능) 미지원 (대신 멀티캐스트 사용) 기본 지원 장점 - 높은 신뢰성
- 간단한 구현
- 모든 프로토콜 지원
- 보안성 우수 - 네트워크 대역폭 효율적 사용
- 다수의 수신자에게 효율적 전송
- 확장성이 좋음 - 간단한 구현
- 모든 호스트에 빠른 정보 전달
- 네트워크 설정에 유용 - 서버 이중화 용이
- 로드 밸런싱 효과
- 지연 시간 최소화 단점 - 다수 수신자 전송 시 비효율적
- 대역폭 소비가 큼 - 라우터의 멀티캐스트 지원 필요
- 구현 복잡
- 신뢰성 보장 메커니즘 별도 필요 - 불필요한 트래픽 발생
- 네트워크 성능 저하
IPv6에서 미지원 - 구현 복잡
- 라우팅 테이블 크기 증가
- 관리 어려움 각 전달 방식은 고유한 특성과 장단점을 가지고 있으며, 사용 목적과 네트워크 환경에 따라 적절한 방식을 선택해야 한다.
IPv6에서는 브로드캐스트가 제거되고 멀티캐스트와 애니캐스트가 강화되어 더욱 효율적인 네트워크 구성이 가능해졌다.
...</p></div><footer class=entry-footer><span title='2024-10-17 07:37:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IP Delivery Modes" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/internet-protocol/ip-delivery-modes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Media Access Control Address (MAC Address)</h2></header><div class=entry-content><p>Media Access Control Address(MAC Address) 네트워크 장비를 식별하기 위한 고유한 하드웨어 주소.
구조 48비트(6바이트) 길이의 주소로, 16진수 형식으로 표현된다.
주로 6개의 2자리 16진수 그룹으로 표시되며, 콜론(:), 하이픈(-), 또는 점(.)으로 구분된다.
1 2 3 4 5 class MACAddress: def __init__(self, address): # MAC 주소 예시: "00:1A:2B:3C:4D:5E" self.oui = address[:8] # 조직 고유 식별자 (앞 3바이트) self.nic = address[9:] # 네트워크 인터페이스 식별자 (뒤 3바이트) MAC 주소의 첫 24비트(3바이트)는 OUI(Organizationally Unique Identifier)로, IEEE에서 제조업체에 할당하는 고유 번호 나머지 24비트는 제조업체가 각 장치에 할당하는 고유 번호. 용도 로컬 네트워크 내에서 장치를 고유하게 식별한다. 데이터 링크 계층(OSI 모델의 2계층)에서 사용된다. 네트워크 통신에서 데이터 패킷의 송신자와 수신자를 식별한다. 특징 제조업체에 의해 할당되며, 전 세계적으로 고유하다. 하드웨어에 고정되어 있어 일반적으로 변경할 수 없다. LAN 환경에서 장치 간 통신에 사용된다. IP 주소와의 차이 MAC 주소는 물리적 주소로, 로컬 네트워크 내에서만 사용된다. IP 주소는 논리적 주소로, 인터넷 상에서 전역적으로 사용된다. 기능 네트워크 진단 및 문제 해결에 사용된다. 네트워크 보안(MAC 주소 필터링 등)에 활용될 수 있다. MAC 주소의 종류 유니캐스트 주소 특정 단일 장치를 위한 주소.
...</p></div><footer class=entry-footer><span title='2024-10-16 12:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;635 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Media Access Control Address (MAC Address)" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/hardwares/media-access-control-address/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/packet/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/routing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-16 09:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;225 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/network-hop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프래그먼테이션 (Fragmentation)</h2></header><div class=entry-content><p>프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.
이는 다음과 같은 목적을 가진다:
다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.
이를 MTU(Maximum Transmission Unit)라고 한다.
예를 들어:
이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트
만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.
각 프래그먼트는:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:40:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프래그먼테이션 (Fragmentation)" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/networking-knowledge/page/5/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>