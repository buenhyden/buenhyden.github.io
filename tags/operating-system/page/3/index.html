<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operating-System | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/operating-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/operating-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/operating-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/operating-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Operating-System"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Operating-System"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Operating-System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>상호 배제 (Mutual Exclusion)</h2></header><div class=entry-content><p>상호 배제 (Mutual Exclusion) 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘.
한 번에 하나의 프로세스나 스레드만 임계 영역(critical section)에 진입할 수 있도록 보장하는 기법이다.
필요한 이유:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 상호 배제가 없는 경우의 문제점 class BankAccount: def __init__(self): self.balance = 1000 def withdraw(self, amount): # 다음 세 줄의 작업이 원자적이지 않음 current_balance = self.balance # 잔액 읽기 current_balance = current_balance - amount # 계산 self.balance = current_balance # 결과 저장 # 두 스레드가 동시에 실행되면 문제가 발생할 수 있음 account = BankAccount() # 스레드 1: withdraw(500) # 스레드 2: withdraw(500) # 예상 잔액: 0, 실제 잔액: 500 (잘못된 결과) 목적 데이터 무결성 유지: 여러 프로세스가 동시에 공유 데이터를 수정하는 것을 방지한다. 경쟁 조건(Race Condition) 예방: 프로세스 실행 순서에 따른 결과 불일치를 막는다. 교착 상태(Deadlock)와 기아 상태(Starvation) 방지: 자원 할당의 효율성을 높인다. 구현 방법 잠금(Lock)
가장 기본적인 동기화 메커니즘으로, 한 번에 하나의 스레드만 임계 영역에 접근할 수 있게 한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 07:50:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상호 배제 (Mutual Exclusion)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process</h2></header><div class=entry-content><p>Process 프로세스는 실행 중인 프로그램의 인스턴스.
구체적으로는 운영체제가 관리하는 작업의 단위로, CPU 시간이나 메모리와 같은 시스템 자원을 할당받아 실행되는 프로그램의 동적인 실체를 의미한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
특징 독립성: 각 프로세스는 독립된 메모리 공간을 가진다. 동시성: 여러 프로세스가 동시에 실행될 수 있다. 상태 변화: 프로세스는 실행 중 여러 상태를 거친다. 기능과 역할 기능:
작업 단위: 운영체제가 관리하는 작업의 기본 단위입니다. 프로그램 코드 실행: 프로세스는 프로그램의 명령어들을 순차적으로 실행합니다. 자원 관리: 할당받은 시스템 자원을 효율적으로 사용하고 관리합니다. 프로세스 간 통신: 다른 프로세스와 정보를 교환하고 협력합니다. 역할:
...</p></div><footer class=entry-footer><span title='2024-10-02 23:32:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>소켓(Socket)</h2></header><div class=entry-content><p>소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.
소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.
운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.
소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:
프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-02 16:30:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;561 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소켓(Socket)" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>메시지 큐(Message Queue) 프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.
메시지 큐는 커널 내에 저장된 메시지의 연결 리스트로, 고유한 식별자로 구분된다.
이는 프로세스들이 비동기적으로 통신할 수 있게 해주는 IPC 메커니즘이다.
메시지 크기 제한과 시스템 리소스 사용 등의 단점도 고려해야 한다.
적절한 사용 시나리오를 파악하고 효과적으로 활용하는 것이 중요하다.
Source: https://www.javatpoint.com/ipc-using-message-queues
메시지 큐의 특징 커널 관리: 메시지 큐는 커널에 의해 관리되어 안정성이 높고 동기화가 용이하다. FIFO 순서: 메시지는 일반적으로 선입선출(FIFO) 순서로 처리된다. 비동기 통신: 송신 프로세스와 수신 프로세스가 동시에 활성화될 필요가 없다. 메시지 구조: 각 메시지는 타입 필드, 길이, 실제 데이터로 구성된다. 프로세스 분리: 메시지 큐를 사용하면 프로세스들이 서로 직접 연결되지 않아도 된다. 메시지 큐의 주요 시스템 호출 ftok(): 고유한 키를 생성한다. msgget(): 메시지 큐를 생성하거나 기존 큐의 식별자를 반환한다. msgsnd(): 메시지를 큐에 추가한다. msgrcv(): 큐에서 메시지를 검색한다. msgctl(): 큐에 대한 다양한 작업을 수행한다. 메시지 큐 사용 방법 메시지 큐 생성:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Memory</h2></header><div class=entry-content><p>공유 메모리(Shared Memory) 공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.
이는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있게 해주며, IPC 메커니즘 중에서 가장 빠른 통신 방법을 제공한다.
Source: https://www.geeksforgeeks.org/ipc-shared-memory/
작동 원리 프로세스가 커널에 공유 메모리 할당을 요청 커널이 해당 프로세스에 메모리 공간을 할당 이후 다른 프로세스들도 해당 메모리 영역에 접근 가능 공유 메모리의 생성과 관리 공유 메모리를 사용하는 일반적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Memory" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/shared-memory/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pipe</h2></header><div class=entry-content><p>파이프(Pipe) 파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.
종류 익명 파이프 (Anonymous Pipe): 부모-자식 프로세스 간 통신에 사용
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os def create_anonymous_pipe(): """익명 파이프 생성 예제""" read_fd, write_fd = os.pipe() pid = os.fork() # 프로세스 생성 if pid > 0: # 부모 프로세스 os.close(read_fd) # 읽기 끝 닫기 os.write(write_fd, "Hello from parent".encode()) os.close(write_fd) else: # 자식 프로세스 os.close(write_fd) # 쓰기 끝 닫기 message = os.read(read_fd, 1024).decode() print(f"Child received: {message}") os.close(read_fd) 이름 있는 파이프 (Named Pipe 또는 FIFO): 관련 없는 프로세스 간 통신에 사용
...</p></div><footer class=entry-footer><span title='2024-10-02 12:02:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/pipe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기화 (Synchronization)</h2></header><div class=entry-content><p>동기화 (Synchronization) 여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 메커니즘.
동기화란 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하도록 하는 것을 의미한다. 이는 여러 작업 간의 실행 순서와 타이밍을 제어하여 데이터의 일관성을 유지하고 경쟁 상태(Race Condition)를 방지하는 것을 목표로 한다.
동기화의 필요성 동기화가 필요한 주요 이유는 다음과 같다:
데이터 일관성 유지: 여러 프로세스나 스레드가 동시에 같은 데이터에 접근할 때 발생할 수 있는 불일치를 방지한다. 경쟁 상태 방지: 둘 이상의 프로세스가 공유 자원에 동시에 접근하려 할 때 발생할 수 있는 예측 불가능한 결과를 방지한다. 순서 보장: 특정 작업이 다른 작업보다 먼저 실행되어야 하는 경우, 동기화를 통해 실행 순서를 제어할 수 있다. 동기화 메커니즘 동기화를 구현하기 위한 주요 메커니즘은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 07:48:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;304 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기화 (Synchronization)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/synchronization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로세스 제어 블록(Process Control Block, PCB)</h2></header><div class=entry-content><p>프로세스 제어 블록(Process Control Block, PCB) 프로세스 제어 블록(Process Control Block, PCB)은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다.
PCB는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.
Sourece: https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/
PCB의 주요 구성 요소 프로세스 식별자(Process ID, PID): 각 프로세스에 할당되는 고유한 식별 번호이다. 프로세스 상태(Process State): 프로세스의 현재 상태를 나타낸다. 주요 상태로는 생성(new), 준비(ready), 실행(running), 대기(waiting), 종료(terminated) 등이 있다. 프로그램 카운터(Program Counter): 다음에 실행할 명령어의 주소를 가리킨다. CPU 레지스터: 프로세스가 CPU를 사용할 때의 레지스터 정보를 저장한다. CPU 스케줄링 정보: 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보를 포함한다. 메모리 관리 정보: 프로세스의 메모리 할당 정보, 페이지 테이블 등을 저장한다. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등을 관리한다. 계정 정보: CPU 사용 시간, 메모리 사용량 등 프로세스의 리소스 사용 정보를 추적한다. PCB의 역할과 중요성 프로세스 관리: PCB는 운영 체제가 프로세스의 생명주기를 관리하는 데 필수적이다. 컨텍스트 스위칭: PCB는 프로세스 간 전환 시 현재 상태를 저장하고 복원하는 데 사용된다. 스케줄링: 운영 체제는 PCB의 정보를 바탕으로 프로세스 스케줄링 결정을 내린다. 리소스 관리: PCB는 프로세스에 할당된 리소스를 추적하고 관리한다. 동기화 및 통신: 프로세스 간 동기화와 통신에 필요한 정보를 저장한다. PCB의 생명주기 프로세스 생성 시 PCB가 생성되고 초기화된다. 프로세스 실행 중 PCB 정보가 지속적으로 업데이트된다. 프로세스 종료 시 PCB가 제거된다. PCB의 구현 및 저장 PCB는 운영 체제 커널의 보호된 메모리 영역에 저장된다.
일부 운영 체제에서는 PCB를 커널 스택의 시작 부분에 위치시킨다.
...</p></div><footer class=entry-footer><span title='2024-10-02 06:59:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;261 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 제어 블록(Process Control Block, PCB)" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-control-block/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process Scheduling</h2></header><div class=entry-content><p>프로세스 스케쥴링 (Process Scheduling) 프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘.
프로세스 스케줄링도 다양한 요소를 고려하여 최적의 실행 순서를 결정한다.
주요 특징 CPU 활용도 극대화: I/O 대기 시간 동안 다른 프로세스에 CPU를 할당하여 유휴 시간을 최소화합니다. 처리량 증가: 단위 시간당 완료되는 프로세스의 수를 늘립니다. 응답 시간 최소화: 사용자 요청에 대한 시스템의 반응 속도를 향상시킵니다. 대기 시간 감소: 프로세스가 준비 큐에서 기다리는 시간을 줄입니다. 공정성 유지: 모든 프로세스에 적절한 CPU 시간을 할당합니다. 스케줄링의 목적 CPU 활용도 최대화
...</p></div><footer class=entry-footer><span title='2024-10-02 06:21:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Scheduling" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동시성 제어 (Concurrency Control)</h2></header><div class=entry-content><p>동시성 제어 (Concurrency Control) 동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.
다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.
동시성 제어의 중요성 동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:
갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실 모순성: 일관성 없는 데이터 읽기 연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀 목적 트랜잭션의 직렬성 보장 데이터의 무결성 및 일관성 유지 시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화) 주요 동시성 제어 기법 락킹(Locking) 기법 락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 02:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;370 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 제어 (Concurrency Control)" href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/operating-system/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/operating-system/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>