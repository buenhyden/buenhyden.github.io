<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Graph | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/graph/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/graph/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/graph/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/graph/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Graph"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Graph"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Graph</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>인접 행렬(Adjacency Matrix)</h2></header><div class=entry-content><p>인접 행렬(Adjacency Matrix) 인접 행렬은 그래프를 표현하는 가장 기본적인 방법 중 하나로, 수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.
행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.
인접 행렬은 그래프를 표현하는 직관적이고 효율적인 방법이다. 특히 간선의 존재 여부를 빠르게 확인해야 하거나, 간선이 많은 밀집 그래프를 다룰 때 유용하다. 또한, 행렬 연산을 통해 그래프의 다양한 속성을 분석할 수 있다는 장점이 있다.
하지만 정점이 많고 간선이 적은 희소 그래프에서는 메모리 사용량이 많아지는 단점이 있다. 이러한 경우에는 인접 리스트나 희소 행렬 표현과 같은 대안을 고려할 필요가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 03:04:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인접 행렬(Adjacency Matrix)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>인접 리스트 (Adjacency List)</h2></header><div class=entry-content><p>인접 리스트 (Adjacency List) 인접 리스트는 그래프 표현 방법 중 하나로, 각 정점(vertex)에 연결된 인접 정점들을 리스트 형태로 저장하는 방식이다.
특히 희소 그래프(sparse graph), 즉 간선의 수가 정점 수의 제곱에 비해 훨씬 적은 그래프를 표현할 때 메모리 효율성이 뛰어나다.
인접 리스트는 그래프 표현 방법 중에서 가장 널리 사용되는 방식 중 하나이다.
특히 희소 그래프를 효율적으로 표현할 수 있어 많은 실제 문제에 적합하다.
인접 리스트의 주요 장점을 요약하면 다음과 같다:
공간 효율성: 간선이 적은 그래프에서 메모리 사용량이 O(V + E)로 효율적이다. 정점 순회 효율성: 특정 정점의 인접 정점을 빠르게 순회할 수 있다. 동적 그래프 지원: 정점이나 간선의 추가/삭제가 효율적이다. 그래프 알고리즘 효율성: DFS, BFS, 다익스트라 등 많은 그래프 알고리즘이 인접 리스트에서 효율적으로 동작한다.
다만, 두 정점 간의 간선 존재 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 더 적합할 수 있다. 인접 리스트는 소셜 네트워크, 웹 그래프, 교통 네트워크, 생물학적 네트워크 등 다양한 분야에서 그래프 문제를 해결하는 데 중요한 역할을 한다. 최신 그래프 처리 시스템과 라이브러리들은 인접 리스트를 기반으로 하여 확장성과 성능을 최적화하고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 03:04:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;5058 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인접 리스트 (Adjacency List)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-list/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adjacency Matrix vs Adjacency List</h2></header><div class=entry-content><p>그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교 그래프는 컴퓨터 과학에서 매우 중요한 자료구조로, 데이터 간의 관계를 효과적으로 표현할 수 있다.
그래프를 표현하는 방법을 선택할 때는 해결하려는 문제의 특성과 그래프의 구조를 고려해야 한다.
간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.
실제로는 두 방법을 혼합하거나 응용한 자료구조를 사용하기도 한다. 많은 실제 응용 사례(소셜 네트워크, 웹 페이지 연결 등)에서는 정점 수에 비해 간선 수가 적은 희소 그래프의 특성을 가지므로 인접 리스트가 더 많이 사용되는 경향이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 15:31:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;891 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adjacency Matrix vs Adjacency List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Edge List</h2></header><div class=entry-content><p>Edge List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-07 14:01:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Edge List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/edge-list/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spanning Tree</h2></header><div class=entry-content><p>스패닝 트리(Spanning Tree) 스패닝 트리(Spanning Tree) 는 무방향 그래프(Undirected Graph)의 모든 정점을 포함하면서, 사이클 없이 연결된 부분 그래프이다. 다시 말해, 원래 그래프의 모든 정점을 최소한의 간선으로 연결한 트리 구조이다.
신장 트리는 그래프 이론의 핵심 개념으로, 다양한 실제 문제 해결에 활용된다.
최소 신장 트리 알고리즘인 크루스칼, 프림, 보로프카는 각각 다른 상황에서 최적의 성능을 보이며, 알고리즘 선택은 그래프의 특성과 문제 요구사항에 따라 달라진다.
신장 트리의 응용은 네트워크 설계, 클러스터링, 이미지 처리 등 다양한 분야에 걸쳐 있으며, 그 변형과 확장은 더 복잡한 문제를 해결하는 데 도움이 된다. 최적화 기법과 효율적인 자료구조를 활용하면 대규모 그래프에서도 신장 트리를 효과적으로 계산할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 03:05:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1457 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spanning Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/types/spanning-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>무방향 그래프(Undirected Graph)</h2></header><div class=entry-content><p>무방향 그래프(Undirected Graph) 무방향 그래프(Undirected Graph) 는 각 간선(Edge)에 방향성이 없는 그래프이다.
즉, 정점 A와 정점 B가 간선으로 연결되어 있으면, A에서 B로 가는 것과 B에서 A로 가는 것이 동일하다.
무방향 그래프 특징 간선이 양방향(↔)으로 연결됨 정점 간 이동에 방향성이 없음 정점의 차수(Degree)는 해당 정점과 연결된 간선의 개수 DFS(깊이 우선 탐색), BFS(너비 우선 탐색) 등의 알고리즘이 적용 가능 연결 그래프(Connected Graph)와 비연결 그래프(Disconnected Graph) 개념 적용 가능 무방향 그래프의 표현 방법 1 2 3 A — B | | C — D A - B (A와 B는 서로 연결됨) A - C (A와 C는 서로 연결됨) B - D (B와 D는 서로 연결됨) C - D (C와 D는 서로 연결됨) 무방향 그래프의 인접 행렬(Adjacency Matrix) 표현 A B C D A 0 1 1 0 B 1 0 0 1 C 1 0 0 1 D 0 1 1 0 설명
...</p></div><footer class=entry-footer><span title='2024-12-07 03:05:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;743 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 무방향 그래프(Undirected Graph)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/types/undirected-graph/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>방향 그래프(Directed Graph)</h2></header><div class=entry-content><p>방향 그래프(Directed Graph) 방향 그래프(Directed Graph, Digraph) 는 각 간선(Edge)에 방향성이 부여된 그래프이다.
즉, 간선이 단방향이므로 A → B 는 이동할 수 있지만 B → A 로는 이동할 수 없다.
방향 그래프는 일방향 관계가 있는 다양한 시스템을 모델링할 수 있다.
웹, 사회 연결망, 컴퓨터 시스템, 생물학적 네트워크 등 다양한 분야에서 방향 그래프를 활용한 알고리즘과 모델이 개발되고 있다.
방향 그래프 특징 간선이 한 방향(→)으로만 연결됨 단방향 관계를 표현할 때 사용 (예: 팔로우 관계, 웹 페이지 링크) 진입 차수(In-degree)와 진출 차수(Out-degree) 개념이 존재 진입 차수(In-degree): 해당 정점으로 들어오는 간선의 개수 진출 차수(Out-degree): 해당 정점에서 나가는 간선의 개수 방향 그래프의 표현 방법 방향 그래프 예시
...</p></div><footer class=entry-footer><span title='2024-12-07 03:05:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;712 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 방향 그래프(Directed Graph)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/types/directed-graph/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>