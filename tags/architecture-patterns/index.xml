<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture-Patterns on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/architecture-patterns/</link>
    <description>Recent content in Architecture-Patterns on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.151.2</generator>
    <language>en</language>
    <lastBuildDate>Fri, 04 Apr 2025 02:45:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/architecture-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Connection Pooling</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/data-access-optimization/connection-pooling/</link>
      <pubDate>Fri, 25 Oct 2024 06:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/data-access-optimization/connection-pooling/</guid>
      <description>Connection Pooling은 데이터베이스 연결을 재사용 가능한 형태로 캐시하는 메커니즘이다.  이는 애플리케이션이 데이터베이스에 연결할 때마다 새로운 연결을 생성하는 대신, 미리 생성된 연결을 사용할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Load Shifting vs. Load Balancing</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-load-balancing/</link>
      <pubDate>Fri, 04 Apr 2025 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-load-balancing/</guid>
      <description>로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.</description>
    </item>
    <item>
      <title>Load shifting vs. autoscaling</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-autoscaling/</link>
      <pubDate>Wed, 02 Apr 2025 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-autoscaling/</guid>
      <description>**Load Shifting**과 **Autoscaling**은 백엔드 시스템에서 리소스를 효율적으로 관리하기 위한 두 가지 전략이다</description>
    </item>
    <item>
      <title>Load Shifting</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/</link>
      <pubDate>Tue, 01 Apr 2025 15:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/</guid>
      <description>로드 시프팅은 시스템 부하를 효율적으로 관리하는 전략으로, 피크 시간대의 작업 부하를 비피크 시간대로 이동시켜 자원 활용을 최적화하는 방법이다.</description>
    </item>
    <item>
      <title>Throttling</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/throttling/</link>
      <pubDate>Sun, 09 Mar 2025 16:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/throttling/</guid>
      <description>Throttling은 트래픽이 과도하게 몰릴 때 시스템이 완전히 중단되거나 요청을 거부하는 대신, 요청 처리 속도를 늦추거나 대기열에 넣어 점진적으로 처리하는 방식이다.</description>
    </item>
    <item>
      <title>Rate Limiting vs. Throttling</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting-vs-throttling/</link>
      <pubDate>Tue, 25 Feb 2025 13:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting-vs-throttling/</guid>
      <description>Rate Limiting은 특정 시간 프레임 내에 클라이언트가 API에 보낼 수 있는 요청 수를 제한하는 기술이며 Throttling은 요청 속도를 조절하여 제한에 도달했을 때 요청을 지연시키거나 대기열에 넣는다.</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/</link>
      <pubDate>Fri, 14 Feb 2025 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/</guid>
      <description>Rate Limiting은 특정 시간 간격 동안 API에 대한 요청 수를 제한하는 기술이다. 쉽게 말해, 사용자나 클라이언트가 특정 시간 동안 보낼 수 있는 요청의 횟수에 상한선을 두는 것이다.</description>
    </item>
    <item>
      <title>Ambassador</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/ambassador/</link>
      <pubDate>Tue, 19 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/ambassador/</guid>
      <description>Ambassador Pattern은 클라이언트와 마이크로서비스 사이에 별도의 서비스(Ambassador)를 두어 통신을 관리하는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/rate-limiting/</guid>
      <description>클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/caching-strategies/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/performance-design/caching-strategies/cache-aside/</guid>
      <description>애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching-strategies/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching-strategies/cache-aside/</guid>
      <description>애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/anti-corruption-layer/</guid>
      <description>이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/event-driven/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/event-driven/cqrs/</guid>
      <description>CQRS는 쓰기(명령)와 읽기(조회)를 별도 모델로 분리해 각자 최적화·독립적 확장을 가능하게 하는 아키텍처 패턴이다. 읽기 전용 뷰·비대칭 스케일링에 유리하고 보안/검증 경계도 선명해진다. 다만 복잡성과 동기화 비용이 늘며, ES와의 결합은 선택 사항이다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/event-driven/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/event-driven/event-sourcing/</guid>
      <description>이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Backend for Frontend Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/backend-for-frontend/</link>
      <pubDate>Thu, 14 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/backend-for-frontend/</guid>
      <description>Backend for Frontend 아키텍처는 다양한 프론트엔드의 요구사항에 맞춤화된 백엔드 서비스를 제공하여 사용자 경험을 최적화하고, 보안성과 개발 효율성을 향상시키는 설계 패턴이다.</description>
    </item>
    <item>
      <title>API Gateway Pattern</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-operations/api-gateway-patterns/</link>
      <pubDate>Thu, 14 Nov 2024 01:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-operations/api-gateway-patterns/</guid>
      <description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/architecture-styles/distributed-architecture/integration-patterns/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Database per Service</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-architecture/database-design-patterns/microservices-patterns/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-architecture/database-design-patterns/microservices-patterns/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-architecture/database-design-patterns/microservices-patterns/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-architecture/database-design-patterns/microservices-patterns/shared-database/</guid>
      <description>여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다</description>
    </item>
    <item>
      <title>Idempotent Operations</title>
      <link>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-reliability/idempotency-patterns/idempotent-operations/</link>
      <pubDate>Wed, 09 Oct 2024 02:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/integration-patterns/eip/message-reliability/idempotency-patterns/idempotent-operations/</guid>
      <description>멱등 연산 (Idempotent Operation) 은 동일한 입력으로 여러 번 수행하더라도 결과가 첫 번째 수행한 것과 동일한 특성을 가진 연산이다. 분산 시스템, REST API, 데이터베이스 등에서 중요하게 활용되며, 시스템의 신뢰성과 일관성을 보장하는 핵심 원칙이다. 네트워크 오류나 중복 요청 상황에서도 안전하게 작업을 수행할 수 있게 해주는 설계 패턴으로 현대 시스템 아키텍처에서 필수적인 개념이다.</description>
    </item>
    <item>
      <title>Caching</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching/</link>
      <pubDate>Mon, 30 Sep 2024 14:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching/</guid>
      <description>캐싱 (Caching) 은 데이터/결과/요청을 임시로 저장함으로써 반복적인 연산, 입출력, 네트워크 요청에 필요한 시간과 비용을 대폭 줄여주는 핵심 시스템 설계 기법이다. 메모리, 디스크, 분산 환경 등 다양한 계층에서 적용되며, 성능 개선과 응답속도 향상, 시스템 부하 분산에 매우 효과적이다.</description>
    </item>
    <item>
      <title>Cache Strategies</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching-strategies/</link>
      <pubDate>Mon, 30 Sep 2024 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/caching-strategies/</guid>
      <description>Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.</description>
    </item>
    <item>
      <title>Master-Slave</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-architecture/scalability--distribution/replication/master-slave/master-slave/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-architecture/scalability--distribution/replication/master-slave/master-slave/</guid>
      <description>하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다</description>
    </item>
  </channel>
</rss>
