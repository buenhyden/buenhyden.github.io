<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Architecture-Patterns | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Architecture-Patterns"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Architecture-Patterns"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Architecture-Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Load Shifting vs. Load Balancing</h2></header><div class=entry-content><p>Load Shifting vs. Load Balancing 네트워크와 시스템 관리에서 부하 관리는 시스템의 안정성과 효율성을 유지하는 핵심 요소이다. 특히 로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.
로드 밸런싱(Load Balancing) 로드 밸런싱은 네트워크 트래픽이나 작업 부하를 여러 서버나 리소스에 고르게 분산시키는 기술이다. 이는 주로 실시간으로 이루어지며, 시스템의 전체적인 성능과 가용성을 향상시키는 것이 목적이다.
주요 특징 목적: 시스템 성능 최적화, 가용성 향상, 응답 시간 개선 타이밍: 실시간 또는 거의 실시간으로 작동 분배 방식: 여러 리소스에 작업을 균등하게 분산 적용 사례: 웹 서버 클러스터, 데이터베이스 클러스터, 컴퓨팅 그리드 로드 밸런싱 알고리즘 라운드 로빈(Round Robin): 순차적으로 각 서버에 요청을 할당한다.
...</p></div><footer class=entry-footer><span title='2025-04-04 02:45:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Shifting vs. Load Balancing" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-load-balancing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Load shifting vs. autoscaling</h2></header><div class=entry-content><p>Load Shifting vs. Autoscaling Load Shifting과 Autoscaling은 백엔드 시스템에서 리소스를 효율적으로 관리하기 위한 두 가지 중요한 전략이다. 이들은 서로 다른 목적과 작동 방식을 가지고 있으며, 특정 상황에 따라 적합하게 사용된다.
Load Shifting 개념: 워크로드를 피크 시간대에서 비피크 시간대로 이동하여 리소스를 더 균형 있게 활용하는 전략. 주요 목적: 리소스 사용 최적화. 비용 절감 (예: 전력 소비가 적은 시간대 활용). 시스템 안정성 유지. 작동 방식: 작업 스케줄링을 통해 특정 시간대에 작업을 재배치. 지리적 부하 이동을 통해 다른 데이터 센터나 지역으로 워크로드를 분산. 적용 사례: 배치 작업을 야간에 실행하여 낮 시간대 사용자 요청 처리에 집중. 전력 비용이 낮은 시간대에 대규모 작업 수행. Autoscaling 개념: 실시간 수요 변화에 따라 시스템의 리소스(예: 서버 인스턴스)를 자동으로 확장하거나 축소하는 기술. 주요 목적: 실시간 트래픽 변화 대응. 과도한 리소스 프로비저닝 방지로 비용 최적화. 성능 및 사용자 경험 개선. 작동 방식: CPU, 메모리, 네트워크 트래픽 등 실시간 메트릭을 기반으로 인스턴스 수를 조정. 수요 증가 시 서버를 추가하고, 수요 감소 시 서버를 비활성화. 적용 사례: 전자상거래 사이트에서 트래픽 급증 시 서버 자동 확장. 클라우드 환경에서 이벤트 기반 애플리케이션의 동적 확장. 차이점 비교 특성 Load Shifting Autoscaling 목적 워크로드를 시간 또는 지역적으로 이동하여 리소스 최적화 실시간 수요 변화에 따라 리소스를 자동 조정 작동 방식 작업 스케줄링 및 지리적 부하 이동 실시간 메트릭 기반 서버 확장 및 축소 주요 적용 사례 배치 작업 재조정, 전력 비용 최적화 웹 애플리케이션의 트래픽 급증 대응 자동화 수준 사전 계획된 스케줄 기반 실시간 동적 조정 비용 절감 방식 비피크 시간대 활용 필요 시 인스턴스 추가 및 제거로 비용 최적화 사용 환경 장기적인 워크로드 관리 단기적인 수요 변화 대응 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2025-04-02 15:29:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load shifting vs. autoscaling" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-autoscaling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting vs. Throttling</h2></header><div class=entry-content><p>Rate Limiting vs. Throttling Rate Limiting과 Throttling은 API 설계와 관리에서 핵심적인 요소로, 시스템의 안정성과 보안을 유지하는 데 중요한 역할을 한다.
Rate Limiting과 Throttling은 모두 시스템 보호와 최적화를 위한 중요한 기술이지만, 그 목적과 구현 방식에는 명확한 차이가 있다. Rate Limiting은 특정 시간 내 허용되는 요청 수를 제한하여 남용을 방지하는 데 중점을 두는 반면, Throttling은 요청 처리 속도를 조절하여 시스템 리소스를 효율적으로 사용하는 데 중점을 둔다.
실제 애플리케이션에서는 두 기술을 함께 사용하여 더욱 견고하고 효율적인 시스템을 구축하는 것이 일반적입니다. Rate Limiting을 통해 과도한 요청을 차단하고, Throttling을 통해 허용된 요청을 적절한 속도로 처리함으로써 시스템의 안정성과 성능을 모두 확보할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-25 13:08:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting vs. Throttling" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting-vs-throttling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting</h2></header><div class=entry-content><p>Rate Limiting Rate Limiting은 MSA(Microservices Architecture) 환경에서 시스템 보안과 안정성을 유지하기 위한 핵심 기술로, 과도한 트래픽으로 인한 서비스 장애 방지와 악성 공격 차단을 목표로 한다.
클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.
Rate Limiting은 단순 트래픽 제어를 넘어 마이크로서비스 생태계의 안전벨트 역할을 수행한다.
2025년 현재, 주요 클라우드 제공업체들은 AI 기반 예측 차단 기능을 표준으로 제공하며, 이는 시스템 보안 설계 시 필수 요소로 자리잡았다. 효과적 구현을 위해서는 서비스 특성에 맞는 알고리즘 선택과 지속적 모니터링 체계 수립이 관건이다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting" href=https://buenhyden.github.io/posts/system-architecture--design/performance--scalability/load-management/traffic-control/rate-limiting/rate-limiting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave" href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/scalability--distribution/replication/master-slave/master-slave/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>