<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process-Management | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/process-management/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/process-management/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/process-management/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/process-management/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process-Management"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process-Management"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Process-Management</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Starvation</h2></header><div class=entry-content><p>기아 상태 (Starvation) 운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황.
자원 관리 문제로, 낮은 우선순위 프로세스가 높은 우선순위 프로세스에 의해 자원이 계속 점유되어 무기한 대기하는 상황으로 주로 우선순위 기반 스케줄링에서 발생하며, 시스템 성능과 공정성에 부정적인 영향을 미친다.
Source: https://www.javatpoint.com/what-is-starvation-in-operating-system
발생 조건 기아 상태가 발생하기 위한 주요 조건은 다음과 같다:
우선순위 기반 스케줄링: 높은 우선순위 프로세스가 계속 실행되면서 낮은 우선순위 프로세스가 실행되지 못함. 자원 부족: 시스템 자원이 제한적일 때 특정 프로세스가 지속적으로 자원을 얻지 못함. 비공정한 스케줄링 알고리즘: 공정성을 고려하지 않는 알고리즘이 낮은 우선순위 프로세스를 무시함. 임계 구역 점유: 특정 프로세스가 임계 구역을 오래 점유하여 다른 프로세스의 접근을 차단. 해결책 및 방지책 기아 상태를 해결하거나 방지하기 위한 방법은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:52:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Starvation" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/starvation/__index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process Synchronization</h2></header><div class=entry-content><p>프로세스 동기화 (Process Synchronization) 여러 프로세스가 공유하는 자원의 일관성을 유지하기 위한 메커니즘.
컴퓨터 시스템에서 여러 프로세스가 공유 자원에 접근할 때 충돌을 방지하고 데이터의 일관성을 유지하기 위해 동기화가 필요하다.
다음 두 가지 목적을 가진다:
실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 필요성 데이터 일관성 유지: 여러 프로세스가 공유 데이터에 동시 접근할 때 발생할 수 있는 예상치 못한 결과를 방지한다. 실행 순서 보장: 특정 프로세스의 실행이 다른 프로세스의 결과에 의존하는 경우, 올바른 순서로 실행되도록 한다. 임계 영역 문제 임계 영역(Critical Section)은 여러 프로세스가 공유하는 데이터를 접근하는 코드 영역을 말한다.
예를 들어, 은행 계좌의 잔액을 수정하는 코드가 임계 영역이 될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 06:22:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Synchronization" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/process-synchronization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로세스 제어 블록(Process Control Block, PCB)</h2></header><div class=entry-content><p>프로세스 제어 블록 (Process Control Block, PCB) 프로세스 제어 블록 (Process Control Block, PCB) 은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다.
PCB 는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.
Sourece: https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/
PCB 의 주요 구성 요소 프로세스 식별자 (Process ID, PID): 각 프로세스에 할당되는 고유한 식별 번호이다. 프로세스 상태 (Process State): 프로세스의 현재 상태를 나타낸다. 주요 상태로는 생성 (new), 준비 (ready), 실행 (running), 대기 (waiting), 종료 (terminated) 등이 있다. 프로그램 카운터 (Program Counter): 다음에 실행할 명령어의 주소를 가리킨다. CPU 레지스터: 프로세스가 CPU 를 사용할 때의 레지스터 정보를 저장한다. CPU 스케줄링 정보: 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보를 포함한다. 메모리 관리 정보: 프로세스의 메모리 할당 정보, 페이지 테이블 등을 저장한다. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등을 관리한다. 계정 정보: CPU 사용 시간, 메모리 사용량 등 프로세스의 리소스 사용 정보를 추적한다. PCB 의 역할과 중요성 프로세스 관리: PCB 는 운영 체제가 프로세스의 생명주기를 관리하는 데 필수적이다. 컨텍스트 스위칭: PCB 는 프로세스 간 전환 시 현재 상태를 저장하고 복원하는 데 사용된다. 스케줄링: 운영 체제는 PCB 의 정보를 바탕으로 프로세스 스케줄링 결정을 내린다. 리소스 관리: PCB 는 프로세스에 할당된 리소스를 추적하고 관리한다. 동기화 및 통신: 프로세스 간 동기화와 통신에 필요한 정보를 저장한다. PCB 의 생명주기 프로세스 생성 시 PCB 가 생성되고 초기화된다. 프로세스 실행 중 PCB 정보가 지속적으로 업데이트된다. 프로세스 종료 시 PCB 가 제거된다. PCB 의 구현 및 저장 PCB 는 운영 체제 커널의 보호된 메모리 영역에 저장된다.
일부 운영 체제에서는 PCB 를 커널 스택의 시작 부분에 위치시킨다.
...</p></div><footer class=entry-footer><span title='2024-10-02 06:59:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 제어 블록(Process Control Block, PCB)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-control-block/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로세스 간 통신 (Inter-Process Communication, IPC)</h2></header><div class=entry-content><p>프로세스 간 통신 (Inter-Process Communication, IPC) 프로세스 간 통신은 서로 다른 프로세스들이 데이터를 주고받거나 서로의 동작을 조율하기 위해 사용하는 메커니즘.
한 프로세스의 출력이 다른 프로세스의 입력으로 사용될 수 있다.
이를 통해 프로세스들은 데이터를 교환하고, 작업을 동기화하며, 리소스를 효율적으로 활용할 수 있다.
프로세스 간 통신(IPC)에 대해 체계적으로 설명해드리겠습니다. 이 개념을 더 쉽게 이해하기 위해, 실제 생활의 예시와 함께 설명을 시작하겠습니다.
Source: https://www.geeksforgeeks.org/inter-process-communication-ipc/
장점 프로세스 간 데이터 공유 및 협력 가능 모듈화 및 유연한 시스템 설계 가능 단점 구현 복잡성 증가 동기화 및 데드락 문제 발생 가능성 IPC의 주요 방식 파이프(Pipe) 파이프는 가장 오래되고 간단한 IPC 방식으로, 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달된다.
...</p></div><footer class=entry-footer><span title='2024-10-02 06:20:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 간 통신 (Inter-Process Communication, IPC)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Context Switching</h2></header><div class=entry-content><p>Context Switching Context Switching 은 운영 체제에서 매우 중요한 개념으로, 여러 프로세스나 스레드가 단일 CPU 자원을 공유하여 효율적으로 실행될 수 있게 하는 메커니즘이다.
Context Switching 은 CPU 가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 불러와 실행을 재개하는 과정을 말한다.
이를 통해 여러 작업이 동시에 실행되는 것처럼 보이게 된다.
Source: https://www.geeksforgeeks.org/context-switch-in-operating-system/
Context Switching 의 필요성 멀티태스킹: 여러 프로세스가 동시에 실행되는 것처럼 보이게 하여 시스템 효율성을 높인다. 인터럽트 처리: 하드웨어 인터럽트나 시스템 호출 등에 신속하게 대응할 수 있다. 자원 공유: 단일 CPU 로 여러 프로세스를 실행할 수 있게 한다. Context Switching 의 과정 현재 실행 중인 프로세스의 상태 저장: CPU 레지스터, 프로그램 카운터 등의 정보를 PCB(Process Control Block) 에 저장한다. 새로운 프로세스 선택: 스케줄러가 다음에 실행할 프로세스를 선택한다. 새 프로세스의 상태 복원: 선택된 프로세스의 PCB 에서 상태 정보를 불러와 CPU 레지스터에 복원한다. 실행 재개: 새 프로세스의 실행을 시작한다. Context Switching 의 트리거 인터럽트: 하드웨어나 소프트웨어에서 발생하는 인터럽트. 시간 할당 종료: 프로세스에 할당된 CPU 시간이 끝났을 때. I/O 요청: 프로세스가 I/O 작업을 요청하여 대기 상태로 전환될 때. 우선순위: 더 높은 우선순위의 프로세스가 실행 준비될 때. Context Switching 의 구현 방식 하드웨어 스위칭: 프로세서 코어에 내장된 태스크 상태 세그먼트 (TSS) 를 사용한다. 소프트웨어 스위칭: 운영 체제의 커널 루틴과 데이터 구조를 사용하여 구현한다. 더 빠르고 일관성 있는 방식이다. Context Switching 의 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-02 01:00:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Context Switching" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/context-switching/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/process-management/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>