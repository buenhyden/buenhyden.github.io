<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Thread | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/thread/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/thread/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/thread/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/thread/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Thread"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Thread"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Thread</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread</h2></header><div class=entry-content><p>Process Vs Thread 프로세스:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. 스레드:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. ![Single Threaded vs Multi-threaded Process](Screenshot-from-2024-02-26-11-48-56-768.png “https://www.geeksforgeeks.org/thread-in-operating-system/_
Process Vs Thread 특성 Process Thread 정의 실행 중인 프로그램의 인스턴스 프로세스 내에서 실행되는 더 작은 실행 단위 메모리 공간 독립적인 메모리 공간 (코드, 데이터, 스택, 힙) 프로세스의 메모리 공간 공유 (코드, 데이터, 힙), 독립적인 스택 구성 요소 - 코드 영역
- 데이터 영역
- 스택 영역
- 힙 영역 - 스레드 ID
- 프로그램 카운터
- 레지스터 집합
- 스택 자원 공유 다른 프로세스와 자원 공유 안 함 같은 프로세스 내 스레드 간 자원 공유 생성 비용 높음 낮음 컨텍스트 스위칭 비용이 큼 비용이 적음 (같은 프로세스 내에서) 안정성 높음 (한 프로세스의 오류가 다른 프로세스에 영향 없음) 상대적으로 낮음 (한 스레드의 오류가 전체 프로세스에 영향) 통신 프로세스 간 통신(IPC) 필요 (복잡하고 오버헤드 큼) 쉽고 빠른 통신 (공유 메모리 사용) 병렬 처리 가능하지만 오버헤드 큼 효율적인 병렬 처리 가능 메모리 구조 비교 메모리 영역 Process Thread 코드 영역 독립적 공유 데이터 영역 독립적 공유 힙 영역 독립적 공유 스택 영역 독립적 각 스레드마다 독립적 특성 상세 비교 특성 Process Thread 독립성 완전히 독립적 부분적으로 독립적 자원 공유 제한적 (IPC 필요) 쉽게 공유 가능 오류 영향 다른 프로세스에 영향 없음 같은 프로세스의 모든 스레드에 영향 동기화 필요성 낮음
- IPC 메커니즘 필요 공유 자원에 대한 동기화 필요
- 뮤텍스, 세마포어 등 사용 생성 시간 더 오래 걸림 더 빠름 종료 시간 더 오래 걸림 더 빠름 장단점 비교 구분 Process Thread 장점 - 높은 안정성
- 다른 프로세스의 영향 받지 않음
- 보안성이 높음 - 생성/종료가 빠름
- 자원 공유가 쉬움
- 통신 비용이 적음 단점 - 많은 시스템 자원 필요
- 프로세스 간 통신이 복잡
- 컨텍스트 스위칭 비용이 큼 - 동기화 문제 발생 가능
- 디버깅이 어려움
- 하나의 스레드 문제가 전체에 영향 사용 사례 비교 용도 Process 선호 Thread 선호 웹 서버 안정성이 중요한 경우 높은 동시성이 필요한 경우 GUI 앱 독립적인 작업이 많은 경우 반응성이 중요한 경우 데이터 처리 대용량 병렬 처리 데이터 공유가 많은 경우 시스템 서비스 격리가 필요한 경우 빈번한 통신이 필요한 경우 활용 예 - 독립적인 애플리케이션 - 웹 브라우저의 각 탭 - 다중 사용자 서버 - 웹 서버 요청 처리 - 게임 엔진 (렌더링, 물리 연산) - 멀티미디어 애플리케이션 동기화 메커니즘 비교 메커니즘 Process Thread 공유 메모리 명시적으로 설정 필요 기본적으로 공유 뮤텍스 프로세스 간 뮤텍스 필요 프로세스 내 뮤텍스 사용 세마포어 시스템 세마포어 필요 프로세스 내 세마포어 사용 메시지 전달 IPC 메커니즘 사용 직접 메모리 접근 이러한 차이점들을 이해하고 적절히 활용하면, 상황에 맞는 최적의 실행 단위를 선택할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-14 08:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;454 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread" href=https://buenhyden.github.io/til/2024/10/process-vs-thread/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process Vs Thread Vs Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-14 08:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/til/2024/10/process-vs-thread-vs-coroutine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-26 23:32:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;654 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/thread/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>