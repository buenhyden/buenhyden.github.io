<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Object-Oriented-Programming | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/object-oriented-programming/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/object-oriented-programming/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/object-oriented-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/object-oriented-programming/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Object-Oriented-Programming"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Object-Oriented-Programming"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Object-Oriented-Programming</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interface vs Abstract class</h2></header><div class=entry-content><p>Interface vs. Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.
모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.
이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.
추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.
일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 05:39:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interface vs Abstract class" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/interface-vs-abstract-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Access Modifiers</h2></header><div class=entry-content><p>Access Modifiers 1. 주제 분류의 적절성 분석 “Access Modifiers(접근 제어자)” 를 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming(객체지향 프로그래밍)” 에 분류하는 것은 매우 적절합니다. 접근 제어자는 객체지향 프로그래밍 (OOP, Object-Oriented Programming) 의 핵심 원칙인 캡슐화 (encapsulation) 와 정보 은닉 (data hiding) 을 실현하는 주요 수단이기 때문입니다. 클래스, 메서드, 변수 등 구성 요소의 접근 범위를 제어하여 소프트웨어 아키텍처의 구조적 안정성과 보안성을 높이는 데 필수적입니다 [3][5][12].
...</p></div><footer class=entry-footer><span title='2024-09-23 04:49:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;38 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Modifiers" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/access-modifiers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>다형성 (Polymorphism)</h2></header><div class=entry-content><p>다형성 (Polymorphism) 1. 주제의 분류 분석 조사한 내용을 바탕으로 " 다형성 (Polymorphism)" 의 분류를 분석하면:
제시된 분류: “Computer Science and Engineering” > “System and Software Architecture” > “Principles” > “Programming Paradigms” > “Object-Oriented Programming” > “Primary Principles”
분석 결과: 이 분류는 부분적으로 적절하지만 개선이 필요합니다.
근거:
적절한 부분: 다형성은 확실히 객체지향 프로그래밍의 핵심 원칙 중 하나입니다 개선이 필요한 부분: 다형성은 객체지향 프로그래밍에만 국한되지 않고, 함수형 프로그래밍, 타입 이론 등 더 넓은 프로그래밍 패러다임에서 사용됩니다 개선된 분류 제안: “Computer Science and Engineering” > “Programming Language Theory” > “Type Systems” > “Polymorphism” 또는 “Computer Science and Engineering” > “Programming Paradigms” > “Language Features” > “Polymorphism”
...</p></div><footer class=entry-footer><span title='2024-09-22 10:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다형성 (Polymorphism)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>상속 (Inheritance)</h2></header><div class=entry-content><p>상속 (Inheritance) 먼저 " 상속 (Inheritance)" 이라는 주제에 대해 체계적으로 조사하겠습니다.이제 상속의 다양한 유형과 구현 방법에 대해 추가로 조사하겠습니다.이제 상속의 메커니즘 방법론에 대해 더 조사하겠습니다.추가적으로 상속의 장단점과 설계 원칙에 대해 조사하겠습니다.이제 상속의 활용 사례와 실제 구현 예시에 대해 조사하겠습니다.이제 충분한 정보를 수집했으니 체계적으로 정리하겠습니다.
1. 주제 분류 적절성 분석 제시된 분류 “Computer Science and Engineering” > “System and Software Architecture” > “Principles” > “Programming Paradigms” > “Object-Oriented Programming” > “Primary Principles” 는 적절합니다.
...</p></div><footer class=entry-footer><span title='2024-09-22 10:10:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상속 (Inheritance)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/inheritance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>추상화 (Abstraction)</h2></header><div class=entry-content><p>추상화 (Abstraction) 추상화 (Abstraction) 는 복잡한 현실 세계를 간결하고 명확하게 단순화시키는 과정으로, 컴퓨터 과학과 소프트웨어 공학의 핵심 개념이다. 하위 세부사항을 숨기고 상위 수준에서 문제를 다룰 수 있게 하여 시스템의 복잡성을 효과적으로 관리한다.
데이터 추상화와 제어 추상화를 통해 구현 세부 사항을 숨기고, 인터페이스를 통해 필요한 기능만을 노출함으로써 모듈화와 유지보수성을 향상시킨다.
객체지향 프로그래밍의 핵심으로 추상 클래스, 인터페이스, 템플릿 메서드 패턴 등 다양한 기법을 통해 복잡한 시스템을 계층적으로 설계하고, 모듈화와 재사용성을 강화한다. 적절한 추상화 수준을 유지하면 유지보수성과 확장성이 향상되지만, 과도한 추상화는 오히려 복잡성과 성능 저하를 초래할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-22 06:46:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 추상화 (Abstraction)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/abstraction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding) vs. 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩 (Overriding) vs. 오버로딩 (Overloading) 1. 주제 분류의 적절성 분석 " 오버라이딩 (Overriding) vs. 오버로딩 (Overloading)" 은 객체지향 프로그래밍 (Object-Oriented Programming, OOP) 에서 다형성 (polymorphism) 을 실현하는 핵심 개념입니다. 이 두 기능은 메서드의 재정의와 다중 정의를 통해 소프트웨어 아키텍처의 유연성과 확장성을 높이며, 시스템 및 소프트웨어 아키텍처의 원칙과 밀접하게 연관되어 있습니다. 따라서 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming” 분류는 매우 적절합니다 [1][7][19].
...</p></div><footer class=entry-footer><span title='2024-09-22 04:56:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding) vs. 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/overriding-vs-overloading/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Encapsulation</h2></header><div class=entry-content><p>캡슐화 (Encapsulation) 1. 주제의 분류 적절성 평가 캡슐화 (Encapsulation) 는 객체지향 프로그래밍 (Object-Oriented Programming, OOP) 의 4 대 핵심 원리 중 하나로, 복잡한 시스템을 단순화하고 구현 세부사항을 숨겨 인터페이스 중심의 설계를 가능하게 합니다. 이는 소프트웨어 아키텍처의 설계 원칙과 프로그래밍 패러다임 분류에 부합하며, 객체지향 프로그래밍 내에서 필수적인 개념이기 때문에 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming > Primary Principles” 분류는 매우 적절합니다.
...</p></div><footer class=entry-footer><span title='2024-09-22 02:26:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulation" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>