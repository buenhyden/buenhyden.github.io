<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Real-Time-APIs | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/real-time-apis/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/real-time-apis/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/real-time-apis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/real-time-apis/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Real-Time-APIs"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Real-Time-APIs"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Real-Time-APIs</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Socket vs. Long Polling</h2></header><div class=entry-content><p>Web Socket vs. Long Polling 실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.
기본 개념 WebSocket WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-09 02:31:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Socket vs. Long Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/websocket/web-socket-vs-long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-sent Events vs. Websocket</h2></header><div class=entry-content><p>Server-sent Events vs. Websocket 웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.
서버 전송 이벤트(SSE) 개념과 작동 원리 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, EventSource API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-03 05:41:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-sent Events vs. Websocket" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming APIs</h2></header><div class=entry-content><p>Streaming APIs 스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다. 전통적인 RESTful API가 요청-응답 패턴을 기반으로 하는 반면, 스트리밍 API는 지속적인 연결을 통해 실시간 데이터를 제공한다. 이러한 접근 방식은 데이터가 생성되는 즉시 클라이언트에게 전달할 수 있어 실시간성이 중요한 애플리케이션에 적합하다.
스트리밍 API의 기본 원리는 클라이언트와 서버 간에 한 번 연결을 수립한 후, 서버가 필요에 따라 데이터를 푸시하는 방식으로 동작하다. 이는 폴링(polling) 방식의 단점인 불필요한 요청과 네트워크 오버헤드를 극복할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:41:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming APIs" href=https://buenhyden.github.io/posts/backend-development/backend-fundamentals/backend-basics/request-response-cycle/streaming/streaming-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pub/Sub APIs</h2></header><div class=entry-content><p>Pub/Sub APIs Pub/Sub 패턴의 기본 개념 Pub/Sub(Publish-Subscribe) 패턴은 메시지 기반 아키텍처의 핵심 패러다임으로, 데이터를 생성하는 발행자(Publisher)와 데이터를 소비하는 구독자(Subscriber) 사이의 느슨한 결합(loose coupling)을 제공한다. 이 패턴에서 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 자동으로 그 메시지를 수신한다.
Pub/Sub 패턴의 가장 중요한 특징은 발행자와 구독자가 서로에 대해 직접적인 지식이 필요 없다는 점이다. 발행자는 단순히 주제에 메시지를 보내고, 시스템이 해당 주제의 모든 구독자에게 메시지를 전달한다. 이러한 분리는 시스템 구성 요소 간의 의존성을 줄이고 확장성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pub/Sub APIs" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/pub-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Websocket API vs. Websocket</h2></header><div class=entry-content><p>Websocket API vs. Websocket WebSocket이란? WebSocket은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 통신 프로토콜이다. HTTP와 달리, 연결이 한 번 수립되면 계속 유지되며, 클라이언트와 서버가 서로 독립적으로 메시지를 주고받을 수 있다.
WebSocket 프로토콜은 RFC 6455에 정의되어 있으며, ‘ws://’ 또는 암호화된 연결을 위한 ‘wss://’ URI 스키마를 사용한다. WebSocket은 HTTP 핸드셰이크를 사용하여 연결을 시작한 다음, 프로토콜을 WebSocket으로 업그레이드한다.
WebSocket API란? WebSocket API는 웹 애플리케이션에서 WebSocket 프로토콜을 사용할 수 있게 해주는 인터페이스이다. 이것은 W3C에서 표준화한 웹 API로, 자바스크립트를 통해 WebSocket 프로토콜을 구현할 수 있도록 한다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:38:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Websocket API vs. Websocket" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/websocket/websocket-api-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Types of Real-time APIs</h2></header><div class=entry-content><p>Types of Real-time APIs Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다. 이는 사용자 경험을 향상시키고, 데이터 정확성과 응답성을 높이는 데 중요한 역할을 한다.
Real-time API의 주요 유형 WebSocket API 특징: 단일 TCP 연결을 통해 양방향 통신을 지원. 클라이언트와 서버가 모두 데이터를 주고받을 수 있음. 낮은 지연 시간과 효율적인 데이터 전송 가능. 사용 사례: 채팅 애플리케이션, 온라인 게임, 협업 도구. Server-Sent Events (SSE) API 특징: HTTP 기반 단방향 통신(서버 → 클라이언트). 지속적인 연결 유지 및 자동 재연결 지원. 텍스트 기반 데이터 전송(UTF-8). 사용 사례: 실시간 알림, 뉴스 피드, 주식 가격 업데이트. Streaming API 특징: 서버에서 클라이언트로 지속적인 데이터 스트림 제공. 대규모 데이터 처리에 적합(예: 비디오, 오디오 스트리밍). WebSocket 또는 SSE를 기반으로 구현 가능. 사용 사례: 라이브 비디오 스트리밍, 소셜 미디어 피드, IoT 센서 데이터. Pub/Sub API 특징: Publish-Subscribe 패턴 기반. 발행자(Publisher)가 특정 주제(Topic)에 메시지를 게시하면 구독자(Subscriber)가 이를 수신. 데이터 생산자와 소비자를 분리하여 확장성과 효율성 제공. 사용 사례: 메시징 시스템(Kafka, PubNub), IoT 장치 간 통신. Push API 특징: 서버에서 클라이언트로 푸시 알림 전송. 클라이언트가 활성화되지 않아도 메시지 수신 가능. 모바일 애플리케이션에서 주로 사용됨. 사용 사례: 모바일 푸시 알림(Firebase Cloud Messaging), 이메일 알림. Event-Driven API 특징: 이벤트 중심 설계로 상태 변화나 특정 이벤트 발생 시 데이터를 전달. 이벤트 구독 및 처리에 최적화됨. 사용 사례: IoT 애플리케이션, 실시간 모니터링 시스템. Real-Time API 기술 비교 기본 특성 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 통신 방향 양방향(전이중) 단방향(서버→클라이언트) 단방향/양방향 가능 다방향(다대다) 단방향(서버→클라이언트) 이벤트 기반 프로토콜 WS/WSS HTTP/HTTPS HTTP/HTTPS 다양(MQTT, AMQP 등) HTTP/HTTPS 다양 연결 유지 지속 연결 지속 연결 지속 연결 지속/비지속 가능 비연결성 이벤트 발생 시 자동 재연결 수동 구현 필요 내장 지원 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 메시지 포맷 텍스트/바이너리 텍스트(UTF-8) 다양(JSON, XML 등) 다양 JSON 다양 데이터 크기 프레임 크기 제한 제한 없음 청크 단위 전송 일반적으로 작은 메시지 작은 메시지 이벤트 크기 기술적 특성 및 구현 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 연결 설정 HTTP 업그레이드 후 WS 프로토콜 일반 HTTP 연결 HTTP 연결 다양한 연결 방식 서비스 워커 등록 이벤트 리스너 등록 클라이언트 API WebSocket EventSource HTTP/Fetch 라이브러리별 다양 Push API, Service Worker 이벤트 리스너 서버 구현 WebSocket 서버 필요 일반 HTTP 서버 일반 HTTP 서버 메시지 브로커 서버 푸시 서비스 이벤트 처리 시스템 확장성 연결 유지 부담 상대적으로 가벼움 리소스 집약적 높은 확장성 높은 확장성 높은 확장성 헤더 오버헤드 낮음(최초 연결 후) 중간 중간 낮음 중간 구현에 따라 다름 통합 난이도 중간 쉬움 중간 중간~어려움 어려움 중간~어려움 활용 사례 및 지원 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 즉시성 매우 높음 높음 중간~높음 중간~높음 중간 중간~높음 브라우저 지원 대부분 지원 대부분 지원(IE 제외) 모두 지원 라이브러리 필요 대부분 지원 구현에 따라 다름 보안 고려사항 WSS 필수, 인증 필요 HTTPS 권장, 인증 필요 HTTPS 권장, 인증 필요 인증/권한 관리 중요 인증 키/토큰 관리 이벤트 검증 중요 리소스 사용량 중간~높음 낮음~중간 중간~높음 중간 낮음 중간 최적 사용 사례 채팅, 게임, 협업 도구 알림, 뉴스 피드, 실시간 데이터 대용량 데이터 전송 분산 메시징, IoT 알림, 백그라운드 메시지 마이크로서비스, 이벤트 기록 성능 및 구현 고려사항 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 지연 시간 매우 낮음(~100ms) 낮음(~500ms) 중간(~1s) 중간 높음(몇 초~몇 분) 구현에 따라 다름 처리량 높음 중간 매우 높음 매우 높음 낮음 구현에 따라 다름 배터리 영향 중간~높음 낮음~중간 중간~높음 구현에 따라 다름 낮음(백그라운드) 구현에 따라 다름 방화벽 통과 일부 제한 가능 대부분 허용 대부분 허용 혼합 대부분 허용 구현에 따라 다름 저대역폭 환경 적합하지 않음 적합함 적합하지 않음 구현에 따라 다름 적합함 구현에 따라 다름 오프라인 지원 미지원 미지원 미지원 일부 지원 가능 지원(백그라운드) 일부 지원 가능 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2025-02-15 01:56:00 +0000 UTC'>February 15, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Real-time APIs" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/real-time-apis/types-of-real-time-apis/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>