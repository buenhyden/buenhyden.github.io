<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/testing/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/testing/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/testing/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Testing"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Testing"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Testing</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>QA vs QC vs Testing</h2></header><div class=entry-content><p>Quality Assurance (QA) and Quality Control (QC) and Testing Quality Assurance (QA)는 제품이나 서비스의 품질을 보장하기 위한 계획적이고 체계적인 활동들의 집합이다.
QA는 프로세스 중심적이며, 품질 문제가 발생하기 전에 예방하는 것을 목표로 한다.
전체 개발 수명주기에 걸쳐 품질 기준과 절차를 수립하고 관리한다.
Quality Control (QC)는 개발된 제품이나 서비스가 정해진 품질 기준을 충족하는지 확인하는 활동이다.
QC는 제품 중심적이며, 실제 결과물을 검사하고 결함을 찾아내는 데 중점을 둔다.
주로 테스트와 검토를 통해 이루어진다.
Testing은 소프트웨어가 예상대로 작동하는지 확인하는 구체적인 실행 활동이다.
버그를 찾아내고, 시스템의 기능성과 성능을 검증하는 것이 주요 목적이다.
QC의 중요한 하위 활동으로 볼 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-05 07:13:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;366 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to QA vs QC vs Testing" href=https://buenhyden.github.io/posts/qa/quality-assurance-vs-quality-control-vs-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cypress</h2></header><div class=entry-content><p>Cypress Cypress는 JavaScript 기반의 강력한 프론트엔드 테스팅 프레임워크.
웹 애플리케이션의 엔드투엔드(E2E) 테스트를 위해 설계되었다.
주요 특징 브라우저 내 실행: Cypress는 애플리케이션과 동일한 실행 루프에서 작동하여 더 빠르고 안정적인 테스트를 가능하게 한다. 자동 대기: 요소가 나타나거나 애니메이션이 완료될 때까지 자동으로 기다려 별도의 대기 시간 설정이 필요 없다. 실시간 리로드: 테스트 파일을 저장하면 자동으로 테스트를 다시 실행한다. 디버깅 용이성: 시간 여행 디버깅, 스냅샷 기능 등을 통해 테스트 실패 원인을 쉽게 파악할 수 있다. 네트워크 트래픽 제어: 웹 트래픽을 읽고 수정할 수 있어 다양한 시나리오 테스트가 가능하다. 장점 속도와 안정성: 브라우저 내에서 직접 실행되어 빠르고 안정적인 테스트가 가능하다. 사용 편의성: 직관적인 API와 풍부한 문서를 제공하여 쉽게 학습하고 사용할 수 있다. 크로스 브라우저 테스팅: Chrome, Firefox, Edge 등 다양한 브라우저에서 테스트 가능하다. 실시간 디버깅: 테스트 실행 중 실시간으로 문제를 식별하고 디버깅할 수 있다. CI/CD 통합: 지속적 통합 및 배포 파이프라인과 쉽게 통합된다. 잠재적 한계 JavaScript/Node.js 생태계에 최적화 크로스 브라우저 지원이 제한적 모바일 웹 테스트에는 다소 제한적 사용 방법 설치: npm을 통해 Cypress를 설치한다.
...</p></div><footer class=entry-footer><span title='2024-11-22 23:53:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cypress" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/testing/cypress/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Playwright</h2></header><div class=entry-content><p>Playwright Playwright는 Microsoft에서 개발한 현대적이고 강력한 웹 자동화 및 테스팅 라이브러리.
크로스 브라우저, 크로스 플랫폼 웹 테스팅을 위해 설계되었으며, Chromium, Firefox, WebKit을 포함한 주요 브라우저들을 단일 API로 제어할 수 있다.
안정적이고 신뢰할 수 있는 E2E 테스트 환경을 제공하며, 복잡한 애플리케이션에서도 안정적으로 동작한다.
주요 특징 다중 브라우저 지원
Playwright는 다음 브라우저들을 완벽하게 지원한다:
Google Chrome Microsoft Edge Mozilla Firefox Apple Safari (WebKit)
이는 개발자들이 여러 브라우저에서 일관된 테스트를 수행할 수 있게 해준다. 최신 웹 기술 대응
현대 웹 애플리케이션의 복잡한 시나리오를 처리할 수 있는 고급 기능 제공:
...</p></div><footer class=entry-footer><span title='2024-11-22 23:52:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Playwright" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/testing/playwright/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Puppeteer</h2></header><div class=entry-content><p>Puppeteer Puppeteer는 Google에서 개발한 Node.js 라이브러리로, 프로그래밍을 통해 Chrome 또는 Chromium 브라우저를 제어할 수 있게 해주는 고급 웹 자동화 도구.
기본적으로 헤드리스 모드로 실행되지만, 필요에 따라 전체 브라우저 인터페이스를 표시할 수도 있다.
Puppeteer는 브라우저 자동화의 복잡성을 추상화하여 개발자가 더 쉽고 효율적으로 웹 상호작용을 프로그래밍할 수 있도록 설계되었다.
브라우저의 모든 기능을 프로그래밍적으로 제어할 수 있게 함으로써, 테스팅, 웹 스크래핑, PDF 생성 등 다양한 use case를 지원한다.
주요 특징 포괄적인 브라우저 제어:
Puppeteer는 다음과 같은 고급 브라우저 제어 기능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-11-22 23:52:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;515 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Puppeteer" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/testing/puppeteer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jasmine</h2></header><div class=entry-content><p>Jasmine Jasmine은 JavaScript 애플리케이션을 위한 행위 주도 개발(BDD) 스타일의 테스팅 프레임워크이다.
간단하고 읽기 쉬운 문법을 제공하여, 테스트 코드가 마치 일반 문장을 읽는 것처럼 자연스럽게 느껴지도록 설계되었다.
특히 assertion이 내장되어 있어 별도의 라이브러리가 필요하지 않다는 장점이 있다.
동기 및 비동기 코드 모두에 대한 자동화된 테스트 실행이 가능하다.
주요 특징 브라우저와 Node.js 환경에서 모두 실행 가능 외부 의존성 없이 독립적으로 사용 가능 DOM이 필요 없음 간결하고 이해하기 쉬운 문법 제공 풍부하고 직관적인 API 제공 Python, Ruby 등 다른 언어에서도 사용 가능 장점 가독성이 높은 테스트 코드 작성 가능 다양한 JavaScript 환경과 도구와의 호환성 활발한 커뮤니티 지원 설정이 간단하고 리소스 사용이 적음 기본 구조와 문법 Jasmine의 기본적인 테스트 구조:
...</p></div><footer class=entry-footer><span title='2024-11-22 06:17:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jasmine" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/testing/jasmine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Karma</h2></header><div class=entry-content><p>Karma Karma는 모든 브라우저에서 JavaScript 코드를 테스트할 수 있게 해주는 테스트 러너이다.
Google의 AngularJS 팀이 개발했으며, 특히 브라우저 기반의 자동화된 테스트 실행에 특화되어 있다.
여러 브라우저에서 동시에 테스트를 실행하고, 실시간으로 결과를 확인할 수 있다는 점이 큰 특징이다.
정의와 목적 JavaScript 코드를 실제 브라우저에서 테스트할 수 있게 해주는 도구 개발자에게 생산적인 테스팅 환경을 제공하는 것이 주요 목적 설정과 기본 구조 Karma의 설정은 karma.conf.js 파일을 통해 이루어진다.
기본적인 설정 파일은 다음과 같은 구조를 가진다:
...</p></div><footer class=entry-footer><span title='2024-11-22 06:17:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;541 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Karma" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/testing/karma/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Junit</h2></header><div class=entry-content><p>Junit Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크.
소프트웨어 개발 과정에서 코드의 품질을 보장하고 버그를 사전에 발견하는 데 중요한 역할을 한다.
JUnit은 Kent Beck과 Erich Gamma에 의해 1997년에 처음 개발되었.
당시 소프트웨어 개발에서 테스트의 중요성이 점점 커지면서, 개발자들이 쉽게 사용할 수 있는 테스트 프레임워크의 필요성이 대두되었.
현재는 JUnit 5 버전까지 발전했으며, 각 버전마다 더욱 강력하고 사용하기 쉬운 기능들이 추가되었다.
Spring Boot 2.2.0 버전부터는 기본적으로 JUnit 5를 지원한다.
...</p></div><footer class=entry-footer><span title='2024-11-20 00:23:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;564 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Junit" href=https://buenhyden.github.io/posts/programming-languages/java/testing/junit/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Consumer-side contract test</h2></header><div class=entry-content><p>Consumer-side Contract Test Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.
Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.
Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다. 격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다. 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다. 구현 단계 모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다. 테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다. 테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다. 계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다. 계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해). 장점 빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다. 명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다. 주의사항 과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다. 유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다. 완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 10:59:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;226 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-side contract test" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Consumer-Driven Contract Testing</h2></header><div class=entry-content><p>Consumer-Driven Contract Testing Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.
CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.
CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자가 테스트의 주도권을 가진다. 실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다. 격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다. 구현 단계 소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다. 계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다. 계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다. 제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다. 장점 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다. 주의사항 계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음. 계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의. 도구 Pact: CDC 테스팅을 위한 대표적인 도구. Testsigma: CDC 테스팅을 지원하는 또 다른 도구. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;197 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-Driven Contract Testing" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Component Test</h2></header><div class=entry-content><p>Service Component Test Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.
주요 특징 격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다. 경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다. 집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다. 반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다. 구현 방법 테스트 환경 설정:
...</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;297 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Component Test" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>