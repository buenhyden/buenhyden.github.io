<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Performance vs Scalability</h2></header><div class=entry-content><p>Performance Vs Scalability 성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 핵심적인 두 축이다. 성능은 시스템이 현재 주어진 자원으로 얼마나 빠르게 작업을 수행하는지를 의미하며, 확장성은 시스템이 증가하는 부하나 사용자 수에 따라 성능을 유지하거나 향상시킬 수 있는 능력을 말한다. 각각 단일 요청 처리 효율과 부하 증가 대응 능력을 의미한다. 이 두 개념은 서로 보완적이며, 시스템 설계 시 목적과 상황에 따라 적절히 균형을 맞추는 것이 중요합니다. 2025 년 현재 클라우드 네이티브 아키텍처와 AI 기반 자동화 기술이 이 분야의 핵심 트렌드로 부상하고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Performance vs Scalability" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/performance-vs-scalability/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Preorder Traversal</h2></header><div class=entry-content><p>전위 순회(Preorder Traversal) 전위 순회(Preorder Traversal)는 트리 자료구조를 탐색하는 가장 기본적인 방법 중 하나이다.
전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태이다.
이 방법에서는 다음과 같은 순서로 노드를 방문한다:
현재 노드(루트)를 방문합니다. 왼쪽 서브트리를 전위 순회한다. 오른쪽 서브트리를 전위 순회한다. 이 과정은 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 “전위(Pre)“는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Preorder Traversal" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>TCPIP 4 Layers vs. OSI 7 Layers</h2></header><div class=entry-content><p>TCPIP 4 Layers vs. OSI 7 Layers 네트워크 통신을 이해하기 위한 두 가지 주요 참조 모델인 OSI 7계층과 TCP/IP 4계층 모델은 네트워크 통신과 프로토콜에 대한 개념적 프레임워크를 제공한다.
두 모델은 서로 다른 접근 방식과 구조를 가지고 있지만, 궁극적인 목표는 동일하다:
시스템 간의 효율적이고 신뢰할 수 있는 통신을 가능하게 하는 것
OSI 7계층 모델과 TCP/IP 4계층 모델은 각각 고유한 장점과 특성을 가지고 있다.
OSI 모델은 더 세분화되고 개념적인 접근을 제공하여 네트워크 통신의 복잡성을 이해하는 데 유용한 프레임워크를 제공한다. 반면 TCP/IP 모델은 실용적이고 구현 중심적인 접근으로 현대 인터넷의 기반을 형성했다.
...</p></div><footer class=entry-footer><span title='2024-10-19 02:11:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCPIP 4 Layers vs. OSI 7 Layers" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Native Compiler</h2></header><div class=entry-content><p>Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.
네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/native-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Latency vs Throughput</h2></header><div class=entry-content><p>Latency vs. Throughput Latency 와 Throughput 은 시스템 성능 평가의 양대 축으로 상호 보완적인 지표이다. Latency는 데이터 전송 지연 시간 (밀리초 단위) 으로, 실시간 화상 회의나 온라인 게임에서 사용자 경험에 직접적 영향을 미친다. Throughput은 초당 처리 가능한 데이터량 (MBps) 으로 대용량 트래픽 처리 능력을 결정한다. 시스템 설계자는 대역폭, 병목 현상, 하드웨어 자원 등 다양한 요소를 고려하여 균형점을 찾아야 한다. 이를 통해 실시간 시스템, 대용량 데이터 처리 등 다양한 응용 분야에서 최적의 성능을 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Latency vs Throughput" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ANSI</h2></header><div class=entry-content><p>ANSI “ANSI 인코딩"이라는 용어는 실제로 약간의 혼란을 불러일으키는 명칭이다.
엄밀히 말하면, ANSI(American National Standards Institute)는 표준을 개발하고 승인하는 미국 비영리 조직의 이름이지, 특정 문자 인코딩이 아니다. 그러나 이 용어는 일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.
실제로 “ANSI 인코딩"이라고 불리는 것은 다음과 같다:
Windows 코드 페이지: Windows에서 기본 8비트 문자 세트로 사용되는 인코딩 ISO-8859 계열의 확장: ASCII의 7비트를 8비트로 확장한 다양한 문자 세트 로컬 시스템의 기본 인코딩: Windows의 지역 설정에 따라 달라지는 인코딩 이러한 혼란은 Windows가 등장한 초기에 마이크로소프트가 당시 발전 중이던 ANSI 표준을 기반으로 문자 세트를 개발했기 때문에 발생했다. 그러나 이 문자 세트들은 결국 정식 ANSI 표준으로 채택되지 않았으나, 이름은 그대로 남게 되었다.
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ANSI" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Inorder Traversal</h2></header><div class=entry-content><p>중위 순회(Inorder Traversal) 중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다. 이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.
왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.
이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inorder Traversal" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Low-Level Virtual Machine</h2></header><div class=entry-content><p>Low-Level Virtual Machine (LLVM) LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.
원래 “Low-Level Virtual Machine"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.
LLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 지속적 최적화(Lifelong Optimization) 를 지원한다.
LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:41:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Low-Level Virtual Machine" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Functions</h2></header><div class=entry-content><p>Functions 함수는 프로그래밍의 핵심 구성 요소로, 특정 작업을 수행하는 독립적이고 재사용 가능한 코드 블록이다.
함수는 입력값(매개변수)을 받아 처리한 후 결과값을 반환할 수 있다.
함수는 코드의 가독성을 높이고 모듈화된 구조를 만들어 유지보수와 확장성을 크게 개선할 수 있다.
함수는 프로그래밍의 근본 개념으로, 다양한 언어에서 조금씩 다른 문법과 용법을 가지고 있지만 기본적인 원리는 동일하다.
각 언어의 특성과 장점을 이해하고 적재적소에 적용함으로써 더 효율적이고 관리하기 쉬운 소프트웨어를 개발할 수 있다.
함수의 기본 개념 함수는 하나의 작업 또는 연산을 수행하기 위해 정의된 코드 집합이며, 필요에 따라 여러 번 호출하여 사용할 수 있다. 함수는 입력 값(매개변수)을 받고, 이를 처리한 후 결과(반환 값)를 돌려줄 수 있어 코드 재사용과 분업에 용이하다. 함수 선언 및 구현 함수 정의: 함수를 정의할 때는 함수 이름과 괄호 안에 입력 매개변수를 명시하며, 중괄호 또는 들여쓰기로 본문을 구분한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 01:09:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Functions" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cross Compiler</h2></header><div class=entry-content><p>Cross Compiler 크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러이다. 이는 임베디드 시스템이나 운영체제 개발처럼 대상 시스템이 컴파일러를 직접 실행하기에 부적합한 경우에 자주 사용되며, 한 개발 환경에서 여러 플랫폼용 소프트웨어를 동시에 개발할 수 있게 해준다.
크로스 컴파일러는 소프트웨어 개발의 다양한 분야, 특히 임베디드 시스템, 모바일 애플리케이션, 게임 콘솔, IoT 기기 개발에서 필수적인 도구이다. 이 기술은 개발자가 한 시스템에서 개발하면서 다양한 타겟 플랫폼용 코드를 생성할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:29:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cross Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>