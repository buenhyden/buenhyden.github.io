<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EUC-KR</h2></header><div class=entry-content><p>EUC-KR EUC-KR은 한국어 컴퓨팅 발전 과정에서 중요한 역할을 했으며, 특히 인터넷 초기에 한국어 웹 페이지와 시스템에서 널리 사용되었다. 그러나 현대 소프트웨어 개발에서는 UTF-8이 표준이 되었으며, EUC-KR은 주로 레거시 시스템이나 특수한 상황에서만 사용된다.
EUC-KR의 기본 개념과 역사적 배경 EUC-KR은 한국어 텍스트를 컴퓨터에서 표현하기 위해 개발된 문자 인코딩 방식이다.
여기서 ‘EUC’는 ‘Extended Unix Code’의 약자로, 유닉스 시스템에서 다양한 언어를 지원하기 위한 확장 인코딩 체계를 의미한다. ‘KR’은 단순히 Korea(한국)를 뜻한다.
역사적 발전 과정 EUC-KR의 역사는 한국의 컴퓨터화와 직접적으로 연결되어 있다:
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to EUC-KR" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/euc-kr/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Level Order Traversal</h2></header><div class=entry-content><p>레벨 순서 순회 (Level Order Traversal) 트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.
이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.
레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.
큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.
특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Level Order Traversal" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Compiler vs Interpreter vs Assembler</h2></header><div class=entry-content><p>Compiler vs. Interpreter vs. Assembler 컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.
각각의 도구는 입력 언어, 처리 방식, 실행 시간 및 사용 목적에 따라 차별화된 특징을 가지며, 개발 환경이나 애플리케이션의 요구사항에 맞춰 선택된다.
컴파일러 (Compiler) 컴파일러는 C, C++, Java와 같이 고수준 언어로 작성된 소스 코드를 한 번에 분석하고 번역하여 실행 가능한 기계어 또는 객체 코드를 생성한다.
작동 원리:
어휘 분석(Lexical Analysis): 소스 코드를 토큰(token)으로 분해한다. 구문 분석(Syntax Analysis): 토큰들을 구문 규칙에 따라 분석하여 파싱 트리를 생성한다. 의미 분석(Semantic Analysis): 코드의 의미를 검사하고 타입 체킹 등을 수행한다. 중간 코드 생성(Intermediate Code Generation): 최적화를 위한 중간 표현을 생성한다. 코드 최적화(Code Optimization): 중간 코드를 최적화하여 효율성을 높인다. 목적 코드 생성(Code Generation): 최종적으로 목표 기계어 또는 바이트코드를 생성한다. 특징:
...</p></div><footer class=entry-footer><span title='2024-12-05 03:57:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Compiler vs Interpreter vs Assembler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler-vs-interpreter-vs-assembler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>의사코드(Pseudocode)</h2></header><div class=entry-content><p>의사코드(Pseudocode) 의사코드(Pseudocode)는 알고리즘을 설명하기 위한 비공식적이고 고수준의 표현 방식으로, 특정 프로그래밍 언어의 문법에 얽매이지 않고 간단한 텍스트 형태로 작성된다.
이는 개발자가 문제를 해결하기 위한 논리를 설계하고, 이를 기반으로 실제 코드를 작성하기 전에 구조를 검토할 수 있도록 돕는다.
의사코드는 알고리즘 설계와 문제 해결 과정에서 중요한 도구로, 논리를 명확히 하고 코드 작성을 체계적으로 준비할 수 있도록 돕는다.
이를 통해 프로그래머는 복잡한 문제를 단순화하고 효율적으로 해결할 수 있다.
의사코드는 알고리즘 설계와 문제 해결 과정에서 매우 유용한 도구이다.
프로그래밍 언어의 복잡한 문법에 얽매이지 않고 순수하게 알고리즘의 논리에 집중할 수 있게 해주며, 다양한 배경을 가진 사람들 간의 의사소통을 원활하게 한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 01:09:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 의사코드(Pseudocode)" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Just-In-Time (JIT) Compiler</h2></header><div class=entry-content><p>Just-In-Time (JIT) Compiler Just-In-Time (JIT) 컴파일러는 프로그램 실행 도중에 필요할 때마다 바이트코드나 중간 표현(IR)을 해당 플랫폼의 네이티브 기계어로 변환하는 동적 컴파일 기술이다.
JIT 컴파일러는 전통적인 정적 컴파일러와 달리 프로그램이 실행되는 동안 “핫스팟"이라고 부르는 자주 실행되는 코드 영역을 감지하여, 이 부분을 최적화된 기계어 코드로 변환한 후 캐시에 저장함으로써 이후부터는 빠른 실행 속도를 제공할 수 있다. 주로 자바(JVM), 자바스크립트(V8), 닷넷(CLR) 등에서 사용되며, 런타임 최적화를 통해 애플리케이션 성능을 크게 향상시킨다.
JIT 컴파일은 런타임 유연성과 성능 사이의 균형을 찾은 기술이다.
모던 프로그래밍 언어와 프레임워크에서 필수적인 요소로 자리잡았으며, 클라우드 네이티브 환경과 실시간 애플리케이션에서 더욱 중요해질 전망이다.
개발자는 대상 시스템의 요구사항에 따라 JIT과 AOT를 전략적으로 조합해 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 17:55:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Just-In-Time (JIT) Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Native Compiler vs Cross Compiler</h2></header><div class=entry-content><p>Native Compiler vs. Cross Compiler Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.
Native Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다. Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다. 네이티브 컴파일러(Native Compiler)의 이해 네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 03:33:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler vs Cross Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Traversal 방법 비교</h2></header><div class=entry-content><p>Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.
각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.
트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.
중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traversal 방법 비교" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Runtime</h2></header><div class=entry-content><p>Runtime 컴퓨터 과학에서 런타임(runtime) 은 프로그램이 실제로 실행되는 기간과 그 실행 환경 전체를 의미한다.
프로그램이 컴파일되어 기계어 코드로 번역된 후, 운영체제에 의해 메모리에 로드되고 CPU가 해당 코드를 실행하는 순간부터 프로그램 실행이 종료될 때까지의 모든 활동을 포괄하는 개념이다.
컴퓨터 과학에서 런타임은 단순히 프로그램이 실행되는 시간만을 의미하지 않는다. 이는 코드 실행을 지원하는 복잡한 환경, 시스템, 메커니즘의 총체를 의미한다. 현대 소프트웨어 개발에서 런타임의 이해는 효율적이고 안정적인 애플리케이션을 구축하는 데 필수적이다.
런타임 환경의 선택과 최적화는 애플리케이션의 성능, 보안, 확장성, 유지보수성에 직접적인 영향을 미친다. 각 런타임은 고유한 장단점과 특성을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 04:12:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Runtime" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/runtime/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JIT Compiler vs AOT Compiler</h2></header><div class=entry-content><p>JIT Compiler vs. AOT Compiler JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.
JIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.
JIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.
현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.
앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JIT Compiler vs AOT Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/jit-compiler-vs-aot-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AOT vs. JIT vs. Interpreter</h2></header><div class=entry-content><p>AOT vs. JIT vs. Interpreter AOT, JIT, 그리고 인터프리터는 모두 소스 코드를 실행 가능한 형태로 변환하는 언어 처리 방식이지만, 언제 어떻게 변환이 이루어지는지에 따라 큰 차이가 있다.
프로그래밍 언어로 작성된 코드가 컴퓨터에서 실행되기 위해서는 기계어로 변환되는 과정이 필요하다.
이 변환 과정은 크게 세 가지 주요 접근 방식—AOT(Ahead-of-Time) 컴파일, JIT(Just-In-Time) 컴파일, 인터프리테이션(Interpretation)—으로 구분된다.
각 방식은 코드 변환의 시점과 방법에 차이가 있으며, 성능, 유연성, 개발 생산성 등에 서로 다른 영향을 미친다.
AOT 컴파일러, JIT 컴파일러, 인터프리터는 각각 고유한 장단점을 가진 코드 실행 메커니즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 00:21:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AOT vs. JIT vs. Interpreter" href=https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/aot-vs-jit-vs-interpreter/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>