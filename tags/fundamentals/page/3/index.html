<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Runtime</h2></header><div class=entry-content><p>Runtime 컴퓨터 과학에서 런타임(runtime) 은 프로그램이 실제로 실행되는 기간과 그 실행 환경 전체를 의미한다.
프로그램이 컴파일되어 기계어 코드로 번역된 후, 운영체제에 의해 메모리에 로드되고 CPU가 해당 코드를 실행하는 순간부터 프로그램 실행이 종료될 때까지의 모든 활동을 포괄하는 개념이다.
컴퓨터 과학에서 런타임은 단순히 프로그램이 실행되는 시간만을 의미하지 않는다. 이는 코드 실행을 지원하는 복잡한 환경, 시스템, 메커니즘의 총체를 의미한다. 현대 소프트웨어 개발에서 런타임의 이해는 효율적이고 안정적인 애플리케이션을 구축하는 데 필수적이다.
런타임 환경의 선택과 최적화는 애플리케이션의 성능, 보안, 확장성, 유지보수성에 직접적인 영향을 미친다. 각 런타임은 고유한 장단점과 특성을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 04:12:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2878 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Runtime" href=https://buenhyden.github.io/posts/computer-science/fundamentals/runtime/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 5. Session Layer</h2></header><div class=entry-content><p>Session Layer(세션 계층) 세션 계층은 OSI 모델의 5번째 계층으로, 통신 세션을 구성하는 계층이다.
응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 프로세스들의 논리적인 연결을 담당한다.
세션 계층은 네트워크 통신에서 연결의 지속성과 신뢰성을 보장하는 중요한 역할을 수행한다.
특히 장기간 지속되는 연결이 필요한 애플리케이션에서 중요한 기능을 제공한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 세션 연결 설정 및 유지, 종료 데이터 교환 동기화 체크포인팅을 통한 데이터 복구 대화 제어 (Duplex, Half-duplex, Full-duplex 통신) 특징 TCP/IP 세션을 관리하고 연결을 유지한다. 양방향 통신을 지원합니다. 인증과 권한 부여 기능을 제공할 수 있습니다. 데이터 단위 세션 계층의 데이터 단위는 일반적으로 “메시지"라고 불린다.
...</p></div><footer class=entry-footer><span title='2024-10-16 07:17:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 5. Session Layer" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/osi-7-layers-5-session-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JIT Compiler vs AOT Compiler</h2></header><div class=entry-content><p>JIT Compiler Vs AOT Compiler JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.
JIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.
JIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.
현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.
앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1268 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JIT Compiler vs AOT Compiler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AOT Vs JIT Vs Interpreter</h2></header><div class=entry-content><p>AOT Vs JIT Vs Interpreter AOT, JIT, 그리고 인터프리터는 모두 소스 코드를 실행 가능한 형태로 변환하는 언어 처리 방식이지만, 언제 어떻게 변환이 이루어지는지에 따라 큰 차이가 있다.
프로그래밍 언어로 작성된 코드가 컴퓨터에서 실행되기 위해서는 기계어로 변환되는 과정이 필요하다.
이 변환 과정은 크게 세 가지 주요 접근 방식—AOT(Ahead-of-Time) 컴파일, JIT(Just-In-Time) 컴파일, 인터프리테이션(Interpretation)—으로 구분된다.
각 방식은 코드 변환의 시점과 방법에 차이가 있으며, 성능, 유연성, 개발 생산성 등에 서로 다른 영향을 미친다.
AOT 컴파일러, JIT 컴파일러, 인터프리터는 각각 고유한 장단점을 가진 코드 실행 메커니즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 00:21:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2485 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AOT Vs JIT Vs Interpreter" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/aot-vs-jit-vs-interpreter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 6. Presentation Layer</h2></header><div class=entry-content><p>Presentation Layer(프레젠테이션 계층) 프레젠테이션 계층은 OSI 모델의 6번째 계층으로, 데이터의 표현 방식을 담당한다.
이 계층은 응용 계층과 세션 계층 사이에 위치하며, 데이터의 형식과 구조를 결정한다.
프레젠테이션 계층은 네트워크 통신에서 데이터의 표현과 보안을 담당하는 중요한 계층으로, 다양한 시스템 간의 원활한 데이터 교환을 가능하게 한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 데이터 변환: 송신 측과 수신 측 사이에서 데이터 형식을 변환한다. 인코딩과 디코딩: 데이터를 다양한 형식으로 인코딩하고 디코딩한다. 암호화와 복호화: 데이터의 보안을 위해 암호화 및 복호화를 수행한다. 데이터 압축: 효율적인 전송을 위해 데이터를 압축하고 해제한다. 특징 데이터의 의미와 구문을 보존하면서 형식을 변환한다. 응용 계층의 부담을 덜어주는 역할을 한다. 다양한 데이터 형식을 지원한다 (예: JPEG, MPEG, ASCII, EBCDIC). 프레젠테이션 계층의 중요한 표준들 문자 인코딩:
...</p></div><footer class=entry-footer><span title='2024-10-16 07:17:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;244 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 6. Presentation Layer" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/osi-7-layers-6-presentation-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 7. Application Layer</h2></header><div class=entry-content><p>Application Layer(애플리케이션 계층) 애플리케이션 계층은 OSI 모델의 최상위 계층으로, 사용자와 직접 상호작용하는 소프트웨어를 지원하는 계층이다.
이 계층은 사용자가 네트워크 자원에 접근할 수 있도록 인터페이스를 제공한다.
애플리케이션 계층은 네트워크 통신의 최종 목적지로, 사용자의 요구사항을 네트워크 서비스로 연결하는 중요한 역할을 수행한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 사용자와 네트워크 간의 인터페이스 제공 다양한 네트워크 서비스 제공 (이메일, 파일 전송, 웹 브라우징 등) 사용자 데이터의 송수신 관리 네트워크 자원에 대한 접근 제어 특징 사용자 지향적: 사용자가 직접 상호작용하는 유일한 OSI 계층. 다양한 프로토콜: 각 애플리케이션의 요구사항에 맞는 다양한 프로토콜을 사용한다. 데이터 형식 관리: 애플리케이션 간에 교환되는 데이터의 형식을 관리한다. 보안 및 인증: 사용자 인증 및 데이터 암호화와 같은 보안 메커니즘을 구현한다. 하위 계층의 서비스를 활용하여 작동 데이터 단위 애플리케이션 계층의 데이터 단위는 “메시지” 또는 “데이터"라고 불린다.
...</p></div><footer class=entry-footer><span title='2024-10-16 07:16:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;185 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 7. Application Layer" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/osi-7-layers-7-application-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import Vs Require 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/modules/import-vs-require/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Async and Await</h2></header><div class=entry-content><p>Async and Await 참고 및 출처</p></div><footer class=entry-footer><span title='2025-03-04 09:47:00 +0000 UTC'>March 4, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Async and Await" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/promises/async-and-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying vs. Partial Application</h2></header><div class=entry-content><p>Currying vs. Partial Application 자바스크립트의 함수형 프로그래밍에서 가장 중요한 개념 중 두 가지는 커링(Currying)과 부분 적용(Partial Application)이다. 이 두 기법은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.
커링과 부분 적용은 자바스크립트의 콜백 함수를 더 효과적으로 다루기 위한 강력한 기법이다.
두 패턴 모두 함수의 재사용성을 높이고 코드를 더 모듈화하는 데 도움이 된다.
두 기법의 핵심 차이는 인자 처리 방식과 최종 함수의 구조에 있다.
커링은 항상 단일 인자 함수의 체인을 만들고, 부분 적용은 일부 인자를 고정한 새로운 함수를 만든다.
...</p></div><footer class=entry-footer><span title='2024-12-26 10:17:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1705 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying vs. Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/currying-vs-partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Partial Application</h2></header><div class=entry-content><p>Partial Application 함수형 프로그래밍에서 콜백 함수를 더 효과적으로 활용하는 핵심 기법 중 하나가 부분 적용(Partial Application)이다.
부분 적용은 함수형 프로그래밍의 강력한 도구로, 함수의 재사용성과 조합성을 크게 향상시킨다.
커링과는 다른 접근 방식을 취하지만, 둘 다 함수를 더 작고 재사용 가능한 단위로 분해하는 데 도움이 된다.
부분 적용의 주요 이점:
코드 중복 감소: 공통 인자를 가진 함수 호출을 단순화한다. 의도 명확화: 특화된 함수 이름을 통해 코드의 의도를 명확히 한다. 조합성 향상: 함수를 더 작고 조합 가능한 단위로 분해한다. 유연성: 필요에 따라 어떤 인자든 부분 적용할 수 있다. 자바스크립트의 콜백 패턴과 함께 부분 적용을 사용하면, 보다 선언적이고 재사용 가능한 코드를 작성할 수 있다. 특히 이벤트 처리, API 호출, 데이터 변환 같은 영역에서 부분 적용은 코드 품질을 향상시키는 실용적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 09:54:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1990 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/partial-application/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>