<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Failback vs. Fail Over</h2></header><div class=entry-content><p>Failback vs. Fail Over Failover 와 Failback 은 고가용성과 재해 복구 전략에서 중요한 이중 절차이다. 페일오버 (Failover) 는 Active-Passive/Active-Active 구성에서 장애 감지 후 트래픽 전환을 수행하며, AWS ELB, Kubernetes Pod 재배치 등에 적용된다. 페일백 (Failback) 은 데이터 동기화 검증 후 점진적 복구를 수행하며, DB 복제본 재동기화, 클라우드 리전 복구 시나리오에서 활용된다.
설계 방식에 따라 RTO(Recovery Time Objective) 와 RPO(Recovery Point Objective) 에 큰 영향을 미친다.
2025 년 현재 AI 기반 자동 전환 알고리즘과 블록체인 검증 기술이 접목되는 추세이다.
...</p></div><footer class=entry-footer><span title='2025-05-18 12:46:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Failback vs. Fail Over" href=https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/fallback/failback-vs-fail-over/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pagination</h2></header><div class=entry-content><p>Pagination API 설계에서 페이지네이션은 대량의 데이터를 효율적으로 전송하고 관리하기 위한 핵심 요소이다. 페이지네이션을 통해 서버는 데이터를 작은 “페이지” 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.
페이지네이션의 필요성과 중요성 페이지네이션이 필요한 주요 이유는 다음과 같다:
성능 최적화
대규모 데이터셋을 한 번에 전송하면 여러 문제가 발생한다:
서버 부하 증가: 대량의 레코드를 검색하고 직렬화하는 과정은 서버 리소스를 많이 소모한다. 네트워크 부하: 대용량 응답은 네트워크 대역폭을 많이 사용하며, 특히 모바일 환경에서 문제가 된다. 응답 지연: 큰 데이터셋을 처리하는 데 시간이 오래 걸려 사용자 경험이 저하된다. 메모리 사용량: 클라이언트와 서버 모두 대량의 데이터를 메모리에 로드해야 한다. 사용자 경험 향상
페이지네이션은 사용자 인터페이스와 경험을 개선한다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pagination" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-implementation/request-response-handling/pagination/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>URI Design</h2></header><div class=entry-content><p>URI Design URI(Uniform Resource Identifier) 디자인은 API 설계의 근본적인 요소로, 개발자 경험과 API의 사용성, 유지보수성에 직접적인 영향을 미친다. 잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.
URI의 기본 개념과 구조 URI는 인터넷에서 특정 리소스를 고유하게 식별하는 문자열이다. API 설계에서 URI는 클라이언트가 서버의 리소스와 상호 작용하는 진입점 역할을 한다.
URI의 구성 요소 URI의 주요 구성 요소를 이해하는 것은 효과적인 디자인의 시작점이다:
1 2 3 4 https://api.example.com:8080/v1/customers/42/orders?status=pending#summary \___/ \______________/\__/\_________________/ \____________/ \______/ | | | | | | scheme authority port path query fragment 스킴(Scheme): URI가 사용하는 프로토콜(https, http 등) 권한(Authority): 서비스의 도메인 이름 또는 IP 주소 포트(Port): 서비스가 수신 대기하는 네트워크 포트(종종 생략됨) 경로(Path): 리소스의 위치를 계층적으로 나타내는 문자열 쿼리(Query): 리소스에 대한 추가 매개변수(필터링, 정렬 등) 프래그먼트(Fragment): 리소스 내의 특정 부분을 가리키는 식별자(일반적으로 API에서 덜 사용됨) URI vs. URL vs. URN URI 개념을 정확히 이해하기 위해서는 관련 용어의 차이점을 아는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to URI Design" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-design-principles/api-endpoint-design/uri-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NP-Hard vs. NP-Complete</h2></header><div class=entry-content><p>NP-Hard vs. NP-Complete 계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.
이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.
NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.
핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:02:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NP-Hard vs. NP-Complete" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying vs. Partial Application</h2></header><div class=entry-content><p>Currying vs. Partial Application 자바스크립트의 함수형 프로그래밍에서 가장 중요한 개념 중 두 가지는 커링(Currying)과 부분 적용(Partial Application)이다. 이 두 기법은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.
커링과 부분 적용은 자바스크립트의 콜백 함수를 더 효과적으로 다루기 위한 강력한 기법이다.
두 패턴 모두 함수의 재사용성을 높이고 코드를 더 모듈화하는 데 도움이 된다.
두 기법의 핵심 차이는 인자 처리 방식과 최종 함수의 구조에 있다.
커링은 항상 단일 인자 함수의 체인을 만들고, 부분 적용은 일부 인자를 고정한 새로운 함수를 만든다.
...</p></div><footer class=entry-footer><span title='2024-12-26 10:17:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying vs. Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/asynchronous-programming/callback/currying-vs-partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Partial Application</h2></header><div class=entry-content><p>Partial Application 함수형 프로그래밍에서 콜백 함수를 더 효과적으로 활용하는 핵심 기법 중 하나가 부분 적용(Partial Application)이다.
부분 적용은 함수형 프로그래밍의 강력한 도구로, 함수의 재사용성과 조합성을 크게 향상시킨다.
커링과는 다른 접근 방식을 취하지만, 둘 다 함수를 더 작고 재사용 가능한 단위로 분해하는 데 도움이 된다.
부분 적용의 주요 이점:
코드 중복 감소: 공통 인자를 가진 함수 호출을 단순화한다. 의도 명확화: 특화된 함수 이름을 통해 코드의 의도를 명확히 한다. 조합성 향상: 함수를 더 작고 조합 가능한 단위로 분해한다. 유연성: 필요에 따라 어떤 인자든 부분 적용할 수 있다. 자바스크립트의 콜백 패턴과 함께 부분 적용을 사용하면, 보다 선언적이고 재사용 가능한 코드를 작성할 수 있다. 특히 이벤트 처리, API 호출, 데이터 변환 같은 영역에서 부분 적용은 코드 품질을 향상시키는 실용적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 09:54:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/asynchronous-programming/callback/partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying</h2></header><div class=entry-content><p>Currying 커링(Currying)은 함수형 프로그래밍에서 유래한 중요한 개념으로, 여러 개의 인자를 받는 함수를 단일 인자를 받는 일련의 함수들로 변환하는 기법이다.
이 기법은 수학자이자 논리학자인 하스켈 커리(Haskell Curry)의 이름을 따서 명명되었다.
커링은 자바스크립트의 함수형 프로그래밍 패러다임에서 특히 유용하며, 함수 합성과 부분 적용을 가능하게 하는 강력한 도구이다.
커링은 자바스크립트에서 함수형 프로그래밍을 구현하는 데 중요한 기법 중 하나이다.
이 기법은 코드의 재사용성과 모듈성을 높이고, 함수 조합을 용이하게 하며, 복잡한 로직을 더 작고 관리하기 쉬운 단위로 분해하는 데 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 07:51:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/asynchronous-programming/callback/currying/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Format</h2></header><div class=entry-content><p>Format 데이터 포맷은 정보를 구조화하고, 저장하며, 교환하는 표준화된 방식이다. 데이터 포맷은 IT 시스템 간의 효율적인 통신과 데이터 처리의 기반이 되며, 다양한 응용 프로그램과 시스템에서 데이터를 해석하고 활용하는 방식을 결정한다.
데이터 포맷은 현대 IT 환경에서 정보 교환과 저장의 핵심 요소이다. 적절한 데이터 포맷을 선택하고 효과적으로 구현하는 것은 시스템의 성능, 확장성, 유지보수성에 직접적인 영향을 미친다.
데이터 포맷의 기본 개념 데이터 포맷은 데이터를 표현하는 구조화된 양식으로, 다음과 같은 역할을 한다:
데이터 구조화: 원시 데이터를 의미 있는 형태로 구조화한다. 데이터 교환: 서로 다른 시스템 간에 데이터를 교환할 수 있게 한다. 데이터 저장: 정보를 효율적으로 저장하고 검색할 수 있게 한다. 데이터 표준화: 데이터 처리 방식을 표준화하여 호환성을 보장한다. 주요 데이터 포맷 유형 텍스트 기반 데이터 포맷 JSON (JavaScript Object Notation) JSON은 경량화된 데이터 교환 형식으로, 사람이 읽고 쓰기 쉬우며 기계가 파싱하고 생성하기 쉽다.
...</p></div><footer class=entry-footer><span title='2024-12-16 12:27:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Format" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-types--formats/exchange-formats/__index/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>