<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>코드 중복도 (Code Duplication)</h2></header><div class=entry-content><p>코드 중복도 (Code Duplication) 코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다.
중복된 코드는 유지보수를 어렵게 만들고, 버그 수정 시 여러 곳을 동시에 수정해야 하는 문제를 야기한다.
이는 일반적으로 바람직하지 않은 프로그래밍 관행으로 간주되며, 소프트웨어의 유지보수성과 확장성을 저해할 수 있다.
특징과 특성 유지보수 어려움: 중복된 코드는 변경 시 여러 곳을 동시에 수정해야 하므로 유지보수가 어려워진다. 버그 발생 가능성 증가: 한 곳의 수정을 다른 곳에 반영하지 않을 경우, 일관성이 깨지고 버그가 발생할 수 있다. 코드량 증가: 중복 코드는 전체 코드의 양을 증가시켜 가독성을 떨어뜨리고 디버깅을 어렵게 만든다. OCP(Open-Closed Principle) 위배: 중복 코드는 수정에 닫혀 있어야 한다는 SOLID 원칙에 위배된다. 중복 코드 감지 방법 수동 코드 리뷰: 개발팀이 협력하여 코드를 검토하고 중복을 식별한다. 코드 분석 도구 사용: SonarQube, PMD, ESLint 등의 도구를 활용하여 자동으로 중복 코드를 탐지한다. 버전 관리 시스템 활용: Git 등의 버전 관리 시스템을 통해 코드 변경 사항을 비교하여 중복을 식별한다. IDE 기능 활용: 대부분의 현대적인 IDE는 코드 중복을 찾는 기능을 내장하고 있다. 코드 중복의 유형 완전 중복(Exact Duplication):
동일한 코드가 그대로 복사되어 사용되는 경우.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:58:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코드 중복도 (Code Duplication)" href=https://buenhyden.github.io/posts/qa/fundamentals/quality-metric/code-duplication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>결합도 (Coupling)</h2></header><div class=entry-content><p>결합도 (Coupling) 결합도는 서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표이다.
낮은 결합도는 모듈이 독립적이며 변경 시 다른 모듈에 미치는 영향이 적음을 의미한다.
모듈이란 클래스, 컴포넌트, 패키지 등 코드의 논리적 단위를 의미한다.
특징 및 기능 모듈 간 상호작용 정도를 나타냄 소프트웨어 구조의 품질을 평가하는 지표로 사용 유지보수성, 재사용성, 테스트 용이성에 영향을 미침 결합도의 종류 낮은 결합도부터 높은 결합도 순
내용 결합도(Content Coupling):
가장 강한 형태의 결합도로, 한 모듈이 다른 모듈의 내부 동작에 직접 관여하는 경우이다.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:54:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 결합도 (Coupling)" href=https://buenhyden.github.io/posts/qa/fundamentals/quality-metric/coupling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>테스트 커버리지 (Test Coverage)</h2></header><div class=entry-content><p>테스트 커버리지 (Test Coverage) 테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도. 즉, 작성된 테스트 코드가 실제 프로덕션 코드를 얼마나 검증하고 있는지를 백분율로 표현한다.
테스트 커버리지를 측정하기 위해서는 실제로 코드가 실행되어야 하므로 테스트 커버리지는 기본적으로 동적 테스팅에 해당한다.
그리고, 테스트 커버리지를 측정하기 위해서는 코드의 내부 구조를 알아야 한다.
예를 들어:
구문 커버리지를 측정하려면 어떤 코드 라인이 실행되었는지 알아야 한다. 분기 커버리지를 측정하려면 조건문의 각 분기가 실행되었는지 알아야 한다. 경로 커버리지를 측정하려면 코드의 모든 가능한 실행 경로를 알아야 한다.
이러한 특성 때문에 테스트 커버리지는 화이트박스 테스팅 기법으로 분류된다. 테스트 커버리지가 실제 코드 실행을 통해(동적) 코드의 내부 구조를 분석하여(화이트박스) 테스트의 완성도를 측정하는 도구이다.
테스트 커버리지 자체는 측정 도구이며, 이를 측정하는 과정에서 정적 분석 도구를 보조적으로 사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-28 09:47:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테스트 커버리지 (Test Coverage)" href=https://buenhyden.github.io/posts/qa/fundamentals/quality-metric/test-coverage/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Halstead Complexity</h2></header><div class=entry-content><p>Halstead Complexity Halstead 복잡도는 1977년 Maurice Howard Halstead가 제안한 소프트웨어 메트릭으로, 프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다.
이는 프로그램의 구현 난이도와 이해도를 정량적으로 평가하는 방법을 제공한다.
코드의 구현을 반영하지만 특정 플랫폼에서의 실행과는 독립적이다.
기본 측정 요소:
프로그램의 기본 요소는 다음과 같이 정의된다:
n1: 고유 연산자의 수 n2: 고유 피연산자의 수 N1: 총 연산자의 출현 횟수 N2: 총 피연산자의 출현 횟수
예를 들어, 다음 코드를 살펴보자. 1 sum = a + b * 2; 이 코드에서:
...</p></div><footer class=entry-footer><span title='2024-10-28 09:43:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Halstead Complexity" href=https://buenhyden.github.io/posts/qa/fundamentals/quality-metric/halstead-complexity/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>순환 복잡도 (Cyclomatic Complexity)</h2></header><div class=entry-content><p>순환 복잡도 (Cyclomatic Complexity) 순환 복잡도는 1976년 Thomas McCabe가 제안한 메트릭으로, 프로그램의 논리적 복잡성을 정량적으로 측정하는 지표이다.
코드 내의 독립적인 경로의 수를 측정하여, 해당 코드를 완전히 테스트하기 위해 필요한 최소한의 테스트 케이스 수를 나타낸다.
순환 복잡도의 계산 방법은 다음과 같다:
V(G) = E - N + 2P
여기서:
E는 제어 흐름 그래프의 엣지(연결선) 수 N은 노드(구문) 수 P는 연결된 컴포넌트 수(일반적으로 1) 또는 더 간단하게:
V(G) = 분기문의 수 + 1
여기서 분기문은 if, while, for, case 등의 조건문을 의미한다.
...</p></div><footer class=entry-footer><span title='2024-10-28 07:12:00 +0000 UTC'>October 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 순환 복잡도 (Cyclomatic Complexity)" href=https://buenhyden.github.io/posts/qa/fundamentals/quality-metric/cyclomatic-complexity/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YAML vs. JSON vs. XML</h2></header><div class=entry-content><p>YAML vs. JSON vs. XML 데이터 교환과 구성 파일 형식으로 YAML, JSON, XML은 현대 소프트웨어 개발에서 가장 널리 사용되는 세 가지 형식이다.
개요 및 역사 YAML (YAML Ain’t Markup Language) YAML은 2001년에 클라크 에반스(Clark Evans), 이니 넷(Ingy döt Net), 오렌 벤-코바(Oren Ben-Koki)에 의해 개발되었다. 원래는 “Yet Another Markup Language"의 약자였으나, 후에 “YAML Ain’t Markup Language"라는 재귀적 약자로 변경되었다. YAML은 인간 친화적인 구문과 읽기 쉬운 형식에 중점을 둔 데이터 직렬화 형식이다.
...</p></div><footer class=entry-footer><span title='2024-10-26 09:35:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAML vs. JSON vs. XML" href=https://buenhyden.github.io/posts/data/fundamentals/format/text-based/yaml/yaml-vs-json-vs-xml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serialization and Deserialization</h2></header><div class=entry-content><p>Serialization and Deserialization 직렬화(Serialization)와 역직렬화(Deserialization)는 객체 지향 프로그래밍, 데이터 저장, 네트워크 통신 등 다양한 분야에서 핵심적인 역할을 한다.
직렬화와 역직렬화의 개념 직렬화(Serialization)는 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형식으로 변환하는 과정이다. 이 과정에서 객체의 상태는 바이트 스트림이나 텍스트 형식(예: JSON, XML)으로 변환된다. 직렬화는 복잡한 데이터 구조를 선형적인(linear) 형태로 “펼치는” 작업이라고 볼 수 있다.
역직렬화(Deserialization)는 직렬화의 반대 과정으로, 저장되거나 전송된 바이트 스트림이나 텍스트를 원래의 객체 구조로 다시 변환하는 작업이다. 이 과정을 통해 저장된 데이터를 애플리케이션에서 다시 사용할 수 있게 된다.
...</p></div><footer class=entry-footer><span title='2024-10-26 09:29:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serialization and Deserialization" href=https://buenhyden.github.io/posts/data/fundamentals/serialization-and-deserialization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터 불일치 (Data Inconsistency)</h2></header><div class=entry-content><p>데이터 불일치 (Data Inconsistency) 동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황
Source: https://www.geeksforgeeks.org/what-is-data-inconsistency-in-dbms/
발생 조건 데이터 불일치가 발생하는 주요 조건:
동시성 작업 여러 프로세스나 스레드가 동시에 데이터를 수정할 때 트랜잭션이 적절히 관리되지 않을 때 분산 환경 네트워크 지연이나 실패가 발생할 때 데이터 복제 과정에서 시간 차이가 발생할 때 캐싱 문제 캐시 무효화가 제대로 이루어지지 않을 때 캐시와 원본 데이터 간의 동기화 실패 시스템 오류 하드웨어 오류, 네트워크 문제, 소프트웨어 버그 등으로 인해 발생할 수 있다. 데이터 통합 문제: 서로 다른 소스의 데이터를 통합할 때 발생할 수 있다 해결책 및 방지책 데이터 표준화: 데이터 형식, 값, 표현을 일관되게 만든다. 데이터 검증: 데이터 입력 시 유효성 검사를 수행한다. 데이터 정제: 오류를 식별하고 수정하는 과정을 거친다. 데이터 거버넌스: 데이터 관리에 대한 명확한 정책과 절차를 수립한다. 동기화 메커니즘: 분산 시스템에서 데이터 동기화를 위한 알고리즘을 사용한다. 실제 시스템에서의 예방책 데이터 감사: 정기적인 데이터 감사를 통해 불일치를 식별한다. 자동화 도구 사용: 데이터 품질 관리 도구를 활용하여 불일치를 자동으로 탐지한다. 데이터 프로파일링: 데이터의 특성을 이해하고 잠재적 문제를 파악한다. 버전 관리: 데이터 변경 이력을 추적하여 불일치 발생 시 원인을 파악한다. 고려사항 및 주의사항 성능 영향: 데이터 일관성 유지 메커니즘이 시스템 성능에 미치는 영향을 고려해야 한다. 확장성: 대규모 분산 시스템에서의 데이터 일관성 유지 방법을 고려해야 한다. 사용자 교육: 데이터 입력 및 수정 시 주의사항에 대해 사용자를 교육해야 한다. 비즈니스 규칙 반영: 데이터 일관성 규칙에 비즈니스 로직을 반영해야 한다. 주의 사항 및 모범 사례 버전 관리 모든 데이터 변경에 버전 번호 부여 낙관적 락킹 구현 충돌 감지 및 해결 메커니즘 구축 캐시 전략 Cache-Aside 패턴 사용 적절한 TTL(Time-To-Live) 설정 캐시 무효화 전략 수립 동기화 메커니즘 분산 락 사용 이벤트 기반 동기화 멱등성 보장 모니터링 및 감사 버전 이력 관리 변경 로그 기록 불일치 감지 알림 실제 구현시 고려사항 확장성 수평적 확장을 고려한 설계 샤딩 전략 수립 복제 지연 관리 성능 캐시 적중률 최적화 인덱스 전략 수립 배치 처리 활용 복구 전략 백업 및 복구 계획 롤백 메커니즘 데이터 정합성 검증 모범 사례 단일 진실 소스(Single Source of Truth) 유지 데이터 품질 메트릭 정의 및 모니터링 데이터 소유권 및 책임 명확화 지속적인 데이터 품질 개선 프로세스 구축 데이터 불일치 해결을 위한 명확한 워크플로우 수립 파이썬 예제로 보는 데이터 불일치 다음은 데이터 불일치가 발생할 수 있는 상황과 이를 해결하는 방법을 보여주는 예제
...</p></div><footer class=entry-footer><span title='2024-10-25 07:22:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 불일치 (Data Inconsistency)" href=https://buenhyden.github.io/posts/databases/fundamentals/data-inconsistency/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cloud Networking</h2></header><div class=entry-content><p>Cloud Networking 클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.
기존의 물리적 네트워크와 달리, 가상화 기술을 기반으로 하여 더욱 유연하고 확장성 있는 네트워크 구성이 가능하다.
클라우드 서비스의 안정적인 제공과 효율적인 리소스 관리를 위해서는 견고한 네트워크 인프라가 필수적이다.
기본 개념 클라우드 네트워킹은 클라우드 기반 서비스를 사용하여 조직의 직원, 리소스 및 애플리케이션을 연결하는 기업 네트워크를 배포하는 것.
이는 가상 라우터, 방화벽, 네트워크 관리 소프트웨어 등으로 구성된 WAN(Wide Area Network)이다.
...</p></div><footer class=entry-footer><span title='2024-10-20 17:39:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud Networking" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/cloud-networking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Transmission</h2></header><div class=entry-content><p>Data Transmission 데이터 전송 및 처리 방식은 다양한 기준에 따라 분류되며, 각 방식은 특정한 통신 환경과 요구 사항에 맞게 선택된다.
전송 방향에 따른 분류 단방향 전송 (Simplex)
데이터가 한 방향으로만 전송된다. 예: 라디오 방송, TV 방송 장점: 단순하고 효율적인 채널 사용 단점: 상호작용이 불가능 반이중 전송 (Half-Duplex)
양방향으로 데이터 전송이 가능하지만, 동시에는 불가능하다. 예: 무전기 장점: 양방향 통신 가능, 에러 감지에 유용 단점: 동시 통신 불가 전이중 전송 (Full-Duplex)
양방향으로 동시에 데이터 전송이 가능하다. 예: 전화 통화, 현대적인 컴퓨터 네트워크 장점: 실시간 양방향 통신 가능, 높은 효율성 단점: 복잡한 하드웨어 필요 비트 전송 방식에 따른 분류 직렬 전송 (Serial Transmission)
...</p></div><footer class=entry-footer><span title='2024-10-20 09:32:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Transmission" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/data-transmission/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>