<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming vs. Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-10-20 08:44:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/streaming-vs-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking 카테고리 동기(Synchronous) 비동기(Asynchronous) Blocking Non-Blocking 핵심 개념 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업을 시작하지 않음 작업들이 독립적으로 실행되며, 이전 작업의 완료를 기다리지 않고 다음 작업 수행 가능 호출된 함수가 작업을 완료할 때까지 제어권을 반환하지 않음 호출된 함수가 작업 완료 여부와 관계없이 즉시 제어권을 반환함 작업 처리 방식 순차적으로 작업을 처리하며, 각 작업이 완료된 후 다음 작업 시작 여러 작업이 동시에 처리될 수 있으며, 작업 완료 순서는 불확실할 수 있음 호출한 함수는 작업이 완료될 때까지 대기 상태 유지 호출한 함수는 작업 진행 중에도 다른 작업 수행 가능 제어 흐름 프로그램의 제어 흐름이 순차적이고 예측 가능함 제어 흐름이 비선형적이며, 콜백이나 이벤트로 처리 제어권이 호출된 함수에 완전히 넘어감 제어권이 호출한 함수에 즉시 반환됨 결과 처리 작업 완료 후 바로 결과를 반환받아 처리 콜백 함수, Promise, async/await 등을 통해 결과 처리 결과를 직접 반환받아 처리 상태 확인이나 콜백을 통해 결과 처리 주요 특징 - 코드의 실행 순서가 명확함
- 직관적인 코드 흐름
- 단순한 구현 - 작업의 병렬 처리 가능
- 복잡한 이벤트 처리
- 높은 확장성 - 자원을 점유하며 대기
- 단순한 구현
- 예측 가능한 실행 - 자원의 효율적 활용
- 복잡한 구현
- 높은 동시성 에러 처리 try-catch 블록으로 즉시 에러 처리 가능 Promise의 catch나 async/await의 try-catch로 처리 동기적 에러 처리 가능 비동기적 에러 처리 메커니즘 필요 성능 특성 - 단순 작업에서 오버헤드 적음
- 순차 처리로 인한 대기 시간 발생 - 동시 처리로 인한 전체 처리 시간 감소
- 컨텍스트 스위칭 오버헤드 - I/O 작업에서 성능 저하
- 리소스 독점 - 리소스 효율적 활용
- 높은 처리량 적합한 사용 사례 - 간단한 계산 작업
- 메모리 내 데이터 처리
- 순차적 처리 필요 작업 - 네트워크 요청
- 대용량 파일 처리
- 독립적 실행 가능 작업 - CPU 연산 작업
- 간단한 파일 작업
- 메모리 작업 - I/O 작업
- 네트워크 통신
- 대용량 처리 실행 순서 코드 작성 순서와 실행 순서가 동일 실행 순서가 코드 작성 순서와 다를 수 있음 작업 완료 순서가 예측 가능 작업 완료 순서가 불확실 자원 활용 단일 자원을 순차적으로 사용 여러 자원을 동시에 효율적으로 활용 자원을 독점적으로 사용 자원을 공유하여 사용 응답성 작업 완료 전까지 다른 작업 불가 여러 작업의 동시 처리로 높은 응답성 대기 시간 동안 응답 불가 지속적인 응답 가능 디버깅 코드 흐름 추적이 용이함 비동기 로직으로 인한 디버깅 어려움 문제 발생 지점 파악 쉬움 문제 발생 지점 추적 어려움 확장성 수직적 확장에 제한적 수평적/수직적 확장 용이 동시 처리 능력 제한적 높은 동시성 처리 가능 데이터 일관성 데이터 일관성 보장이 쉬움 경쟁 조건 고려 필요 순차적 처리로 일관성 보장 동시성 제어 메커니즘 필요 추가적인 고려사항:
...</p></div><footer class=entry-footer><span title='2024-10-06 12:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/synchronous-and-asynchronous-and-blocking-and-non-blocking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg vs. pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ER(Entity-Relationship) 모델링</h2></header><div class=entry-content><p>ER(Entity-Relationship) 모델링 ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.
![An entity–attribute-relationship diagram for an MMORPG using Chen’s notation](1024px-ER_Diagram_MMORPG.png “https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png_
주요 구성 요소 개체(Entity)
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.
예를 들어, ‘학생’, ‘강좌’, ‘교수’ 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.
예시:
학생 개체의 경우: 실체: 개별 학생들 표현: ‘학생’ 이라는 개체로 모델링 속성: 학번, 이름, 학과, 연락처 등 속성(Attribute)
속성은 개체의 특성이나 성질을 나타낸다.
타원형으로 표현되며, 개체와 선으로 연결된다.
속성의 종류: 단일값 속성: 하나의 값만 가지는 속성 (예: 학번) 다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호) 유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이) 키 속성: 개체를 유일하게 식별하는 속성 (예: 학번) 관계(Relationship)
관계는 개체들 간의 연관성을 나타낸다.
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.
관계의 종류: 일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결 일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결 다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결
관계 표현 예시: [학생] ----&lt; 수강 >---- [강좌] | | (학번) (과목코드) (이름) (과목명) (학과) (학점) ER 모델링의 단계 요구사항 분석
시스템에서 필요한 데이터와 기능을 파악한다.
예: “대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…”
...</p></div><footer class=entry-footer><span title='2024-10-25 02:06:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ER(Entity-Relationship) 모델링" href=https://buenhyden.github.io/posts/databases/fundamentals/entity-relationship-modeling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UTF-8</h2></header><div class=entry-content><p>UTF-8 UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.
역사적 배경과 개발 동기 문자 인코딩의 역사적 진화 컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.
...</p></div><footer class=entry-footer><span title='2025-03-12 13:16:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UTF-8" href=https://buenhyden.github.io/posts/data/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NP-Hard vs. NP-Complete</h2></header><div class=entry-content><p>NP-Hard vs. NP-Complete 계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.
이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.
NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.
핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:02:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NP-Hard vs. NP-Complete" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/classes/np-hard/np-hard-vs-np-complete/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Currying vs. Partial Application</h2></header><div class=entry-content><p>Currying vs. Partial Application 자바스크립트의 함수형 프로그래밍에서 가장 중요한 개념 중 두 가지는 커링(Currying)과 부분 적용(Partial Application)이다. 이 두 기법은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.
커링과 부분 적용은 자바스크립트의 콜백 함수를 더 효과적으로 다루기 위한 강력한 기법이다.
두 패턴 모두 함수의 재사용성을 높이고 코드를 더 모듈화하는 데 도움이 된다.
두 기법의 핵심 차이는 인자 처리 방식과 최종 함수의 구조에 있다.
커링은 항상 단일 인자 함수의 체인을 만들고, 부분 적용은 일부 인자를 고정한 새로운 함수를 만든다.
...</p></div><footer class=entry-footer><span title='2024-12-26 10:17:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Currying vs. Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/currying-vs-partial-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Partial Application</h2></header><div class=entry-content><p>Partial Application 함수형 프로그래밍에서 콜백 함수를 더 효과적으로 활용하는 핵심 기법 중 하나가 부분 적용(Partial Application)이다.
부분 적용은 함수형 프로그래밍의 강력한 도구로, 함수의 재사용성과 조합성을 크게 향상시킨다.
커링과는 다른 접근 방식을 취하지만, 둘 다 함수를 더 작고 재사용 가능한 단위로 분해하는 데 도움이 된다.
부분 적용의 주요 이점:
코드 중복 감소: 공통 인자를 가진 함수 호출을 단순화한다. 의도 명확화: 특화된 함수 이름을 통해 코드의 의도를 명확히 한다. 조합성 향상: 함수를 더 작고 조합 가능한 단위로 분해한다. 유연성: 필요에 따라 어떤 인자든 부분 적용할 수 있다. 자바스크립트의 콜백 패턴과 함께 부분 적용을 사용하면, 보다 선언적이고 재사용 가능한 코드를 작성할 수 있다. 특히 이벤트 처리, API 호출, 데이터 변환 같은 영역에서 부분 적용은 코드 품질을 향상시키는 실용적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-12-26 09:54:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Partial Application" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/partial-application/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>