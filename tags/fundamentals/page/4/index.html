<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Poetry vs uv vs Rye</h2></header><div class=entry-content><p>Poetry vs. Uv vs. Rye Poetry, uv, Rye는 모두 파이썬 프로젝트 관리와 패키지 설치를 위한 도구들이다.
각각의 도구는 고유한 특징과 장단점을 가지고 있어 개발자들의 다양한 요구사항을 충족시키고 있다.
Poetry는 파이썬 프로젝트의 의존성 관리와 패키징을 위한 도구로, 2018년에 출시되었다.
주요 특징으로는 의존성 해결, 가상 환경 관리, 프로젝트 패키징 등이 있다.
uv는 Rust로 작성된 초고속 파이썬 패키지 설치 및 의존성 해결 도구이다. pip와 pip-tools의 대체제로 설계되었으며, 속도와 효율성에 중점을 두고 있다.
Rye는 Flask의 개발자인 Armin Ronacher가 개발한 올인원 파이썬 프로젝트 관리 도구이다.
파이썬 버전 관리, 의존성 관리, 가상 환경 생성 등 다양한 기능을 제공한다.
Poetry, uv, Rye에 대한 비교를 요청하신 카테고리별로 표로 정리했습니다. 각 도구의 특징을 비교하여 살펴볼 수 있도록 구성했습니다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:41:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry vs uv vs Rye" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming vs. Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-10-20 08:44:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/posts/system-design/distributed-systems/stream-processing-systems/streaming/streaming-vs-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg vs. pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ER(Entity-Relationship) 모델링</h2></header><div class=entry-content><p>ER(Entity-Relationship) 모델링 ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.
https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png
주요 구성 요소 개체(Entity)
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.
예를 들어, ‘학생’, ‘강좌’, ‘교수’ 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.
예시:
학생 개체의 경우: 실체: 개별 학생들 표현: ‘학생’ 이라는 개체로 모델링 속성: 학번, 이름, 학과, 연락처 등 속성(Attribute)
속성은 개체의 특성이나 성질을 나타낸다.
타원형으로 표현되며, 개체와 선으로 연결된다.
속성의 종류: 단일값 속성: 하나의 값만 가지는 속성 (예: 학번) 다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호) 유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이) 키 속성: 개체를 유일하게 식별하는 속성 (예: 학번) 관계(Relationship)
관계는 개체들 간의 연관성을 나타낸다.
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.
관계의 종류: 일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결 일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결 다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결
관계 표현 예시: 1 2 3 4 5 [학생] ----&lt; 수강 >---- [강좌] | | (학번) (과목코드) (이름) (과목명) (학과) (학점) ER 모델링의 단계 요구사항 분석
시스템에서 필요한 데이터와 기능을 파악한다.
예: “대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…”
...</p></div><footer class=entry-footer><span title='2024-10-25 02:06:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ER(Entity-Relationship) 모델링" href=https://buenhyden.github.io/posts/system-design/database-systems/data-modeling/entity-relationship/entity-relationship-modeling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Failback vs. Fail Over</h2></header><div class=entry-content><p>Failback vs. Fail Over Failover 와 Failback 은 고가용성과 재해 복구 전략에서 중요한 이중 절차이다. 페일오버 (Failover) 는 Active-Passive/Active-Active 구성에서 장애 감지 후 트래픽 전환을 수행하며, AWS ELB, Kubernetes Pod 재배치 등에 적용된다. 페일백 (Failback) 은 데이터 동기화 검증 후 점진적 복구를 수행하며, DB 복제본 재동기화, 클라우드 리전 복구 시나리오에서 활용된다.
설계 방식에 따라 RTO(Recovery Time Objective) 와 RPO(Recovery Point Objective) 에 큰 영향을 미친다.
2025 년 현재 AI 기반 자동 전환 알고리즘과 블록체인 검증 기술이 접목되는 추세이다.
...</p></div><footer class=entry-footer><span title='2025-05-18 12:46:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Failback vs. Fail Over" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/fault-tolerance/failback/failback-vs-fail-over/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Availability in Numbers</h2></header><div class=entry-content><p>Availability in Numbers “Availability in Numbers” 는 분산 시스템에서 서비스의 지속적인 접근성을 수치로 표현하고 설계하는 방법론이다. 가용성은 업타임 대 전체 운영 시간의 비율로 계산되며, 일반적으로 ‘9 의 개수 ‘(예: 99.9%, 99.999%) 로 표현된다. 이 수치는 허용 가능한 연간, 월간, 일간 다운타임을 결정하며, 시스템 설계 시 중복성 구현, 장애 감지 및 복구 메커니즘, 분산 아키텍처 패턴 등을 통해 달성된다. 가용성 설계는 시스템의 중요성, 비용, 성능 간의 균형을 고려하여 비즈니스 요구에 맞게 조정되어야 하며, 다양한 가용성 패턴을 적용해 단일 장애점을 제거하는 것이 핵심이다.
...</p></div><footer class=entry-footer><span title='2025-05-15 05:00:00 +0000 UTC'>May 15, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Availability in Numbers" href=https://buenhyden.github.io/posts/system-design/quality-attribute/quality-attributes/run-time-reliability-and-efficiency/availability/availability-in-numbers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain Name</h2></header><div class=entry-content><p>Domain Name 도메인 이름은 인터넷의 기본 구성 요소로, 특히 API 디자인과 웹 서비스 개발에서 중요한 역할을 한다.
도메인 이름의 기본 개념 도메인 이름이란? 도메인 이름은 인터넷에서 특정 위치를 식별하는 사람이 읽을 수 있는 주소이다. 컴퓨터가 서로 통신할 때 사용하는 숫자로 된 IP 주소(예: 192.168.1.1) 대신, 사람이 기억하고 입력하기 쉬운 텍스트 형식(예: example.com)을 제공한다.
도메인 이름의 주요 목적은 다음과 같다:
기억하기 쉬운 웹 주소 제공 브랜드 아이덴티티 확립 웹사이트와 서비스에 대한 접근성 향상 IP 주소가 변경되더라도 일관된 접근점 유지 도메인 이름 시스템(DNS)과의 관계 도메인 이름 시스템(DNS)은 도메인 이름을 IP 주소로 변환하는 인터넷의 전화번호부와 같은 역할을 한다. 사용자가 브라우저에 도메인 이름을 입력하면, DNS는 해당 도메인 이름과 연결된 IP 주소를 찾아 사용자를 올바른 서버로 연결한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Name" href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/internet/domain-name/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hosting</h2></header><div class=entry-content><p>Hosting 호스팅은 API 설계와 배포에 있어 핵심적인 요소이다. 잘 설계된 API 도 적절한 호스팅 환경이 없다면 사용자에게 안정적으로 서비스를 제공할 수 없다.
호스팅의 기본 개념 호스팅이란 무엇인가? 호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다. API 호스팅은 API 가 24 시간 내내 접근 가능하고, 안정적으로 요청을 처리하며, 적절한 보안과 성능을 유지할 수 있도록 한다.
호스팅 서비스는 다음과 같은 기본 요소를 제공한다:
...</p></div><footer class=entry-footer><span title='2025-03-31 23:50:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;55 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hosting" href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/internet/hosting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UTF-8</h2></header><div class=entry-content><p>UTF-8 UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.
역사적 배경과 개발 동기 문자 인코딩의 역사적 진화 컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.
...</p></div><footer class=entry-footer><span title='2025-03-12 13:16:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UTF-8" href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character/types/unicode/utf-8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pagination</h2></header><div class=entry-content><p>Pagination API 설계에서 페이지네이션은 대량의 데이터를 효율적으로 전송하고 관리하기 위한 핵심 요소이다. 페이지네이션을 통해 서버는 데이터를 작은 “페이지” 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.
페이지네이션의 필요성과 중요성 페이지네이션이 필요한 주요 이유는 다음과 같다:
성능 최적화
대규모 데이터셋을 한 번에 전송하면 여러 문제가 발생한다:
서버 부하 증가: 대량의 레코드를 검색하고 직렬화하는 과정은 서버 리소스를 많이 소모한다. 네트워크 부하: 대용량 응답은 네트워크 대역폭을 많이 사용하며, 특히 모바일 환경에서 문제가 된다. 응답 지연: 큰 데이터셋을 처리하는 데 시간이 오래 걸려 사용자 경험이 저하된다. 메모리 사용량: 클라이언트와 서버 모두 대량의 데이터를 메모리에 로드해야 한다. 사용자 경험 향상
페이지네이션은 사용자 인터페이스와 경험을 개선한다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pagination" href=https://buenhyden.github.io/posts/software-engineering/software-development/service-and-application-engineering/api-design-and-implementation/api-performance/pagination/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/fundamentals/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/fundamentals/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>