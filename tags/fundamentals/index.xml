<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Fundamentals on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/fundamentals/</link>
    <description>Recent content in Fundamentals on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.157.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 18 May 2025 12:46:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/fundamentals/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Native Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/native-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/native-compiler/</guid>
      <description>Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러</description>
    </item>
    <item>
      <title>ANSI</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/ansi/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/ansi/</guid>
      <description>일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.</description>
    </item>
    <item>
      <title>Low-Level Virtual Machine</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/low-level-virtual-machine/</link>
      <pubDate>Thu, 05 Dec 2024 03:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/low-level-virtual-machine/</guid>
      <description>LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크</description>
    </item>
    <item>
      <title>Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/cross-compiler/</guid>
      <description>크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러</description>
    </item>
    <item>
      <title>복잡도 클래스(Complexity Classes)</title>
      <link>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/complexity-classes/</link>
      <pubDate>Sun, 13 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/complexity-classes/</guid>
      <description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</description>
    </item>
    <item>
      <title>CP949</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/cp949/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/cp949/</guid>
      <description>CP949(Code Page 949)는 한국어 문자를 표현하기 위해 마이크로소프트가 개발한 문자 인코딩이다.</description>
    </item>
    <item>
      <title>Adjacency Matrix vs Adjacency List</title>
      <link>https://buenhyden.github.io/posts/computer-science/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 15:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/advanced-trees--graphs/graph-structures--algorithms/graph-representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</guid>
      <description>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.</description>
    </item>
    <item>
      <title>LLVM vs 기존 컴파일러 비교</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Thu, 05 Dec 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</guid>
      <description>LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.</description>
    </item>
    <item>
      <title>CSR vs SSR</title>
      <link>https://buenhyden.github.io/posts/software-development/platform-development/frontend-development/advanced-topics/rendering/csr-vs-ssr/</link>
      <pubDate>Mon, 02 Dec 2024 12:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/platform-development/frontend-development/advanced-topics/rendering/csr-vs-ssr/</guid>
      <description>Client Side Rendering (CSR)은 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링하며, Server Side Rendering (SSR)은 서버에서 HTML을 생성하여 클라이언트에 전달한다.</description>
    </item>
    <item>
      <title>Ahead-of-Time Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/</guid>
      <description>**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술</description>
    </item>
    <item>
      <title>EUC-KR</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/euc-kr/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/character-encoding/regional-encodings/euc-kr/</guid>
      <description>EUC-KR은 한국어 텍스트를 컴퓨터에서 표현하기 위해 개발된 문자 인코딩 방식이다.</description>
    </item>
    <item>
      <title>Just-In-Time (JIT) Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/just-in-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 17:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/compiler-types/just-in-time-compiler/</guid>
      <description>**JIT(Just-In-Time) 컴파일**은 프로그램 실행 시점에 코드를 기계어로 변환하는 기술로, **인터프리터의 유연성**과 **컴파일러의 성능**을 결합한 혁신적인 방식</description>
    </item>
    <item>
      <title>Native Compiler vs Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/native-compiler-vs-cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 03:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/native-compiler-vs-cross-compiler/</guid>
      <description>Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.</description>
    </item>
    <item>
      <title>Traversal 방법 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science/tree-structures--algorithms/binary-trees/tree-traversals/comparison-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/tree-structures--algorithms/binary-trees/tree-traversals/comparison-traversal/</guid>
      <description>트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.</description>
    </item>
    <item>
      <title>JIT Compiler vs AOT Compiler</title>
      <link>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/jit-compiler-vs-aot-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/jit-compiler-vs-aot-compiler/</guid>
      <description>JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/posts/computer-science/advanced-algorithms/advanced-string-algorithms/suffix-arrays/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Sat, 12 Oct 2024 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/advanced-algorithms/advanced-string-algorithms/suffix-arrays/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</title>
      <link>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</guid>
      <description>데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.</description>
    </item>
    <item>
      <title>Encoding and Decoding</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/encoding-and-decoding/</link>
      <pubDate>Sat, 26 Oct 2024 07:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/encoding-and-decoding/</guid>
      <description>인코딩(Encoding)은 데이터를 특정 형식으로 변환하는 과정이고, 디코딩(Decoding)은 인코딩의 반대 과정으로, 변환된 데이터를 원래의 형식으로 되돌리는 과정</description>
    </item>
    <item>
      <title>Poetry vs uv vs Rye</title>
      <link>https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/package-management/poetry-vs-uv-vs-rye/</link>
      <pubDate>Wed, 27 Nov 2024 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/package-management/poetry-vs-uv-vs-rye/</guid>
      <description>파이썬 프로젝트 관리와 패키지 설치를 위한 도구들</description>
    </item>
    <item>
      <title>setup.cfg vs pyproject.toml</title>
      <link>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/setup.cfg-vs-pyproject.toml/</link>
      <pubDate>Wed, 27 Nov 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/setup.cfg-vs-pyproject.toml/</guid>
      <description>Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.</description>
    </item>
    <item>
      <title>Failback vs. Fail Over</title>
      <link>https://buenhyden.github.io/posts/software-development/distributed-systems/reliability--resilience/recovery-patterns/fallback/failback-vs-fail-over/</link>
      <pubDate>Sun, 18 May 2025 12:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/distributed-systems/reliability--resilience/recovery-patterns/fallback/failback-vs-fail-over/</guid>
      <description>Failover 는 주 시스템에 장애 발생 시 대기 시스템으로 자동 전환하여 서비스 연속성을 유지하는 방식이며, Failback 은 주 시스템이 복구된 후 원래 상태로 되돌리는 과정이다. 이 두 메커니즘은 고가용성 시스템에서 다운타임을 최소화하고 비즈니스 연속성을 보장하는 필수적인 재해 복구 전략을 구성한다.</description>
    </item>
    <item>
      <title>Pagination</title>
      <link>https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-implementation/request-response-handling/pagination/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-implementation/request-response-handling/pagination/</guid>
      <description>페이지네이션을 통해 서버는 데이터를 작은 &amp;#34;페이지&amp;#34; 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.</description>
    </item>
    <item>
      <title>URI Design</title>
      <link>https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-design-principles/api-endpoint-design/uri-design/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-design-principles/api-endpoint-design/uri-design/</guid>
      <description>잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.</description>
    </item>
    <item>
      <title>Deterministic vs. Nondeterministic computation</title>
      <link>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/</guid>
      <description>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</description>
    </item>
    <item>
      <title>P vs NP problem</title>
      <link>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/</guid>
      <description>P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다</description>
    </item>
    <item>
      <title>NP-Hard vs. NP-Complete</title>
      <link>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/</link>
      <pubDate>Fri, 27 Dec 2024 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/np-hard-vs-np-complete/</guid>
      <description>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</description>
    </item>
    <item>
      <title>Currying vs. Partial Application</title>
      <link>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/currying-vs-partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 10:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/currying-vs-partial-application/</guid>
      <description> 커링(Currying)과 부분 적용(Partial Application)은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.</description>
    </item>
    <item>
      <title>Partial Application</title>
      <link>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/partial-application/</guid>
      <description>부분 적용이란 여러 개의 인자를 받는 함수에 일부 인자를 미리 제공하여, 나머지 인자만 받는 새로운 함수를 생성하는 기법이다.</description>
    </item>
    <item>
      <title>Currying</title>
      <link>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/currying/</link>
      <pubDate>Thu, 26 Dec 2024 07:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/javascript-family/javascript/core-features/asynchronous-programming/callback/currying/</guid>
      <description>여러 개의 인자를 받는 함수를 단일 인자를 받는 일련의 함수들로 변환하는 기법이다.</description>
    </item>
    <item>
      <title>Format</title>
      <link>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/__index/</link>
      <pubDate>Mon, 16 Dec 2024 12:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/__index/</guid>
      <description>데이터 포맷은 정보를 구조화하고, 저장하며, 교환하는 표준화된 방식이다.</description>
    </item>
    <item>
      <title>Little Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/binary-operations/endianness/little-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/binary-operations/endianness/little-endian/</guid>
      <description>리틀 엔디안은 낮은 자리의 바이트가 낮은 메모리 주소에 먼저 저장되는 방식이다. 즉, 데이터의 &amp;#34;작은&amp;#34; 부분(Least Significant Byte)이 메모리의 작은 주소에 위치한다.</description>
    </item>
    <item>
      <title>Big Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/binary-operations/endianness/big-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/computer-systems/data-representation--encoding/binary-operations/endianness/big-endian/</guid>
      <description>빅 엔디안은 가장 중요한 바이트(Most Significant Byte, MSB)를 먼저 저장하는 방식이다. 즉, 높은 자리의 바이트가 낮은 메모리 주소에 위치한다.</description>
    </item>
    <item>
      <title>Asymptotic Notation</title>
      <link>https://buenhyden.github.io/posts/computer-science/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/</link>
      <pubDate>Fri, 06 Dec 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/</guid>
      <description>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.</description>
    </item>
    <item>
      <title>setup.cfg</title>
      <link>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/setup.cfg/</link>
      <pubDate>Wed, 27 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/setup.cfg/</guid>
      <description>파이썬 프로젝트의 설정을 관리하는 구성 파일</description>
    </item>
    <item>
      <title>The pyproject.toml file</title>
      <link>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/the-pyproject.toml-file/</link>
      <pubDate>Wed, 27 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/getting-started/configuration/the-pyproject.toml-file/</guid>
      <description>Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일</description>
    </item>
    <item>
      <title>Generator and Iterator</title>
      <link>https://buenhyden.github.io/posts/software-development/python/getting-started/control-flow/generator-and-iterator/</link>
      <pubDate>Sun, 24 Nov 2024 10:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/getting-started/control-flow/generator-and-iterator/</guid>
      <description>이터레이터는 값을 차례대로 반환하는 객체로, `__iter__()`와 `__next__()` 메서드를 구현한다.  제너레이터는 `yield` 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.</description>
    </item>
    <item>
      <title>Python - Generators</title>
      <link>https://buenhyden.github.io/posts/software-development/python/getting-started/functions-and-modules/functions/generators/</link>
      <pubDate>Sun, 24 Nov 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/python/getting-started/functions-and-modules/functions/generators/</guid>
      <description>반복 가능한 객체를 생성하는 강력한 도구</description>
    </item>
    <item>
      <title>Java Keywords</title>
      <link>https://buenhyden.github.io/posts/software-development/java/getting-started/syntax-basics/keywords/</link>
      <pubDate>Wed, 20 Nov 2024 02:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/java/getting-started/syntax-basics/keywords/</guid>
      <description>키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.  변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.</description>
    </item>
    <item>
      <title>Black-box Test and White-box Test</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-test-and-white-box-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/test-design-techniques/black-box-test-and-white-box-test/</guid>
      <description>Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Fakes</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/fakes/</link>
      <pubDate>Fri, 01 Nov 2024 21:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/fakes/</guid>
      <description>실제 객체의 간단한 구현을 제공하는 테스트용 객체</description>
    </item>
    <item>
      <title>Dummy Objects</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/dummy-objects/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/dummy-objects/</guid>
      <description>테스트 과정에서 실제로는 사용되지 않지만 메서드의 파라미터를 채우기 위해 전달되는 객체</description>
    </item>
    <item>
      <title>Spies</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/spies/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/spies/</guid>
      <description>실제 객체의 메서드 호출을 추적하고 기록하는 데 사용</description>
    </item>
    <item>
      <title>Stubs</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/stubs/</link>
      <pubDate>Fri, 01 Nov 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/testing-fundamentals/test-double/stubs/</guid>
      <description>테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘</description>
    </item>
    <item>
      <title>코드 크기 메트릭(Lines of Code, LOC)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/lines-of-code/</link>
      <pubDate>Mon, 28 Oct 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/lines-of-code/</guid>
      <description>이 메트릭은 프로그램의 크기를 코드 라인 수로 표현하며, 소프트웨어 개발 프로젝트의 규모 추정, 생산성 측정, 품질 관리 등에 활용된다</description>
    </item>
    <item>
      <title>유지보수성 지수 (Maintainability Index)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/maintainability-index/</link>
      <pubDate>Mon, 28 Oct 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/maintainability-index/</guid>
      <description>유지보수성 지수는 코드를 얼마나 쉽게 유지보수할 수 있는지를 나타내는 0에서 100 사이의 수치로 높을수록 코드의 유지보수가 더 쉽다는 것을 의미한다.</description>
    </item>
    <item>
      <title>응집도(Cohesion)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/cohesion/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/cohesion/</guid>
      <description>하나의 모듈이 얼마나 단일한 목적에 집중되어 있는지를 나타낸다.</description>
    </item>
    <item>
      <title>코드 중복도 (Code Duplication)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/code-duplication/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/code-duplication/</guid>
      <description>코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다</description>
    </item>
    <item>
      <title>결합도 (Coupling)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/coupling/</link>
      <pubDate>Mon, 28 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/coupling/</guid>
      <description>서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표</description>
    </item>
    <item>
      <title>테스트 커버리지 (Test Coverage)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/test-and-process-metrics/test-coverage/</link>
      <pubDate>Mon, 28 Oct 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/test-and-process-metrics/test-coverage/</guid>
      <description>테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도</description>
    </item>
    <item>
      <title>Halstead Complexity</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/halstead-complexity/</guid>
      <description>프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다</description>
    </item>
    <item>
      <title>순환 복잡도 (Cyclomatic Complexity)</title>
      <link>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/cyclomatic-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/development-practices/testing--quality/quality-assurance/quality-metrics/code-quality-metrics/complexity/cyclomatic-complexity/</guid>
      <description>프로그램의 논리적 복잡성을 정량적으로 측정하는 지표</description>
    </item>
    <item>
      <title>YAML vs. JSON vs. XML</title>
      <link>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/yaml-vs-json-vs-xml/</link>
      <pubDate>Sat, 26 Oct 2024 09:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/yaml-vs-json-vs-xml/</guid>
      <description>데이터 교환과 구성 파일 형식으로 YAML, JSON, XML은 현대 소프트웨어 개발에서 가장 널리 사용되는 세 가지 형식이다.</description>
    </item>
    <item>
      <title>Serialization and Deserialization</title>
      <link>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/serialization--processing/serialization-and-deserialization/</link>
      <pubDate>Sat, 26 Oct 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/serialization--processing/serialization-and-deserialization/</guid>
      <description>직렬화(Serialization)는 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형식으로 변환하는 과정이다. 역직렬화(Deserialization)는 직렬화의 반대 과정으로, 저장되거나 전송된 바이트 스트림이나 텍스트를 원래의 객체 구조로 다시 변환하는 작업이다.</description>
    </item>
    <item>
      <title>데이터 불일치 (Data Inconsistency)</title>
      <link>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-quality/database-problems/data-inconsistency/</link>
      <pubDate>Fri, 25 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-quality/database-problems/data-inconsistency/</guid>
      <description>동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황</description>
    </item>
    <item>
      <title>Packet</title>
      <link>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/packet/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/packet/</guid>
      <description>패킷(Packet)은 네트워크를 통해 전송되는 데이터의 기본 단위</description>
    </item>
    <item>
      <title>Routing</title>
      <link>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/routing/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/routing/</guid>
      <description>데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.</description>
    </item>
    <item>
      <title>Network Hop</title>
      <link>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/network-hop/</link>
      <pubDate>Wed, 16 Oct 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/network-hop/</guid>
      <description>네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.</description>
    </item>
    <item>
      <title>프래그먼테이션 (Fragmentation)</title>
      <link>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/fragmentation/</link>
      <pubDate>Wed, 16 Oct 2024 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/fragmentation/</guid>
      <description>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</description>
    </item>
    <item>
      <title>Metric</title>
      <link>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/metrics/metrics/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/metrics/metrics/</guid>
      <description>Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값</description>
    </item>
    <item>
      <title>Trace</title>
      <link>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/tracing/tracing/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/tracing/tracing/</guid>
      <description>분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것</description>
    </item>
    <item>
      <title>Log</title>
      <link>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/logging/logging/</link>
      <pubDate>Sat, 28 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/engineering-operations/monitoring--observability/monitoring-fundamentals/three-pillars-of-observability/logging/logging/</guid>
      <description>Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.</description>
    </item>
    <item>
      <title>Incremental Model</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/incremental-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/incremental-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식.</description>
    </item>
    <item>
      <title>Rapid Application Development</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/hybrid-and-modern/rad/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/hybrid-and-modern/rad/</guid>
      <description>빠른 프로토타이핑과 반복적인 개발을 통해 신속하게 애플리케이션을 구축하는 접근 방식</description>
    </item>
    <item>
      <title>Iterative Model</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/iterative-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/iterative-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분으로 나누어 반복적으로 개발하고 개선하는 방법</description>
    </item>
    <item>
      <title>Spiral Model</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/spiral-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/spiral-model/</guid>
      <description>위험 분석을 중심으로 반복적인 개발을 수행하며, 각 반복 주기마다 위험 요소를 평가하고 대응한다.</description>
    </item>
    <item>
      <title>V Model</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/v-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/v-model/</guid>
      <description>개발 단계와 테스트 단계를 병행하여 진행하는 검증(Verification)과 확인(Validation) 중심의 접근 방식이다.</description>
    </item>
    <item>
      <title>Waterfall Model</title>
      <link>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/waterfall-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development/fundamentals/sdlc/methodologies/traditional/waterfall-model/</guid>
      <description>각 단계를 순차적으로 진행하며, 이전 단계가 완료되어야 다음 단계로 넘어가는 전통적인 모델.</description>
    </item>
  </channel>
</rss>
