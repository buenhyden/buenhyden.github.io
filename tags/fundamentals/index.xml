<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Fundamentals on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/fundamentals/</link>
    <description>Recent content in Fundamentals on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.5</generator>
    <language>en</language>
    <lastBuildDate>Sun, 18 May 2025 12:46:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/fundamentals/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Performance vs Scalability</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/</guid>
      <description>성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 상호 보완적이면서도 때로는 상충하는 핵심 속성이다.  성능은 단일 작업을 얼마나 빠르게 처리할 수 있는지를 나타내는 반면, 확장성은 부하가 증가할 때 시스템이 이를 효과적으로 처리할 수 있는 능력을 의미한다.  성능이 좋은 시스템이 반드시 확장성이 좋은 것은 아니며, 그 반대도 마찬가지이다. 이 두 특성의 균형을 맞추는 것은 현대 시스템 설계의 핵심 과제로, 분산 시스템, 로드 밸런싱, 캐싱, 데이터베이스 샤딩 등의 기술을 통해 해결할 수 있다.</description>
    </item>
    <item>
      <title>Basic Syntax</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/</link>
      <pubDate>Fri, 20 Dec 2024 12:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/</guid>
      <description>Python의 기본 구문법</description>
    </item>
    <item>
      <title>ASCII(American Standard Code for Information Interchange)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ascii/</link>
      <pubDate>Fri, 13 Dec 2024 16:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ascii/</guid>
      <description>ASCII는 현대 컴퓨터 시스템과 통신 프로토콜의 근간이 된 가장 기본적인 문자 인코딩 표준이다.</description>
    </item>
    <item>
      <title>인접 행렬(Adjacency Matrix)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/</link>
      <pubDate>Sat, 07 Dec 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/</guid>
      <description>수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.</description>
    </item>
    <item>
      <title>Algorithmic Complexity</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/algorithmic-complexity/</link>
      <pubDate>Fri, 06 Dec 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/algorithmic-complexity/</guid>
      <description>알고리즘 복잡도는 프로그램이나 알고리즘이 문제를 해결할 때 소요하는 시간과 공간, 즉 컴퓨팅 자원의 사용량을 입력 크기에 따라 수학적으로 분석하는 방법이다.</description>
    </item>
    <item>
      <title>Preorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/</guid>
      <description>전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태로, 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 &amp;#34;전위(Pre)&amp;#34;는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.</description>
    </item>
    <item>
      <title>Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/</link>
      <pubDate>Fri, 06 Dec 2024 03:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/</guid>
      <description>트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다.</description>
    </item>
    <item>
      <title>어셈블러(Assembler)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/assembler/</link>
      <pubDate>Thu, 05 Dec 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/assembler/</guid>
      <description>Assembler는 어셈블리 언어로 작성된 소스 코드를 컴퓨터가 직접 실행할 수 있는 기계어 코드로 변환하는 번역 도구</description>
    </item>
    <item>
      <title>Control Structures</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/</link>
      <pubDate>Thu, 05 Dec 2024 03:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/</guid>
      <description>Control Structures는 프로그램 내에서 실행 흐름을 제어하는 기본적이고 필수적인 구성 요소이다.  이 구조들은 코드의 순차적 실행, 조건에 따른 분기 처리, 그리고 반복문 실행을 통해 프로그램이 동적으로 동작할 수 있도록 돕는다.</description>
    </item>
    <item>
      <title>Fundamentals of Databases</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/</link>
      <pubDate>Fri, 25 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/</guid>
      <description>&lt;h2 id=&#34;fundamentals-of-databases&#34;&gt;Fundamentals of Databases&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;용어-정리&#34;&gt;용어 정리&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;hr&gt;</description>
    </item>
    <item>
      <title>TCPIP 4 Layers vs. OSI 7 Layers</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/</link>
      <pubDate>Sat, 19 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/</guid>
      <description>OSI 7계층은 네트워크 통신의 표준 참조 모델이며, TCP/IP 4계층은 이를 바탕으로 구현된 실제 인터넷 통신의 기반이 된다.</description>
    </item>
    <item>
      <title>TCP/IP 4 Layers - 1. Network Access Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/network-access-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/network-access-layer/</guid>
      <description>데이터를 전송 매체에 맞게 포맷팅하고 물리적 하드웨어 주소를 기반으로 데이터를 주소 지정한다</description>
    </item>
    <item>
      <title>OSI 7 Layers - 1. Physical Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/physical-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/physical-layer/</guid>
      <description>OSI 7계층의 가장 첫 번째 계층으로, 실제 데이터가 전기 신호나 빛으로 변환되어 전송되는 곳</description>
    </item>
    <item>
      <title>Native Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/native-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/native-compiler/</guid>
      <description>Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러</description>
    </item>
    <item>
      <title>튜링 기계 (Turing Machine)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/turing-machine/</link>
      <pubDate>Sun, 13 Oct 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/turing-machine/</guid>
      <description>튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.</description>
    </item>
    <item>
      <title>Language Syntax</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/</link>
      <pubDate>Fri, 04 Oct 2024 03:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/</guid>
      <description>프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다.</description>
    </item>
    <item>
      <title>Latency vs Throughput</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/latency-vs-throughput/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/latency-vs-throughput/</guid>
      <description>지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다.</description>
    </item>
    <item>
      <title>ANSI</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/</guid>
      <description>일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.</description>
    </item>
    <item>
      <title>인접 리스트 (Adjacency List)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-list/</guid>
      <description>인접 리스트는 그래프 표현 방법 중 하나로, 각 정점(vertex)에 연결된 인접 정점들을 리스트 형태로 저장하는 방식이다.</description>
    </item>
    <item>
      <title>Inorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/</guid>
      <description>왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.</description>
    </item>
    <item>
      <title>Low-Level Virtual Machine</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/</link>
      <pubDate>Thu, 05 Dec 2024 03:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/</guid>
      <description>LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크</description>
    </item>
    <item>
      <title>Functions</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/</link>
      <pubDate>Thu, 05 Dec 2024 01:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/</guid>
      <description>함수는 프로그래밍의 핵심 구성 요소로, 특정 작업을 수행하는 독립적이고 재사용 가능한 코드 블록이다.</description>
    </item>
    <item>
      <title>라이브러리 (Library)와 프레임워크 (Framework)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/library-and-framework/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/library-and-framework/</guid>
      <description>라이브러리(Library)는 특정 기능을 수행하는 코드의 모음이고, 프레임워크(Framework)는 애플리케이션 개발의 기본 구조를 제공한다.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 2. Internet Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/internet-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/internet-layer/</guid>
      <description>인터넷 계층은 TCP/IP 프로토콜 스택에서 네트워크 간의 통신을 담당하는 핵심 계층으로, 네트워크 간 데이터 전송을 담당하며, 데이터 패킷이 출발지에서 목적지까지 효율적으로 전달되도록 라우팅과 주소 지정(Addressing)을 수행한다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 2. DataLink Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/datalink-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/datalink-layer/</guid>
      <description>OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당</description>
    </item>
    <item>
      <title>OSI 7Layers</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/</link>
      <pubDate>Wed, 16 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/</guid>
      <description>OSI 7 계층 모델은 국제표준화기구 (ISO) 에서 개발한 개방형 시스템 상호 연결 참조 모델로, 네트워크 통신 과정을 7 개의 계층으로 나누어 표준화한 것이다. 각 계층은 특정 네트워크 기능을 담당하며, 이러한 계층적 구조는 네트워크 문제 해결과 시스템 간 상호 운용성을 높이는 데 기여한다.</description>
    </item>
    <item>
      <title>Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/</guid>
      <description>크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러</description>
    </item>
    <item>
      <title>복잡도 클래스(Complexity Classes)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/</link>
      <pubDate>Sun, 13 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/</guid>
      <description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</description>
    </item>
    <item>
      <title>컴파일러(Compiler)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/</link>
      <pubDate>Sun, 06 Oct 2024 05:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/</guid>
      <description>우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램</description>
    </item>
    <item>
      <title>Availability vs Consistency</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/availability-vs-consistency/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/availability-vs-consistency/</guid>
      <description>가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다.</description>
    </item>
    <item>
      <title>CP949</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/cp949/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/cp949/</guid>
      <description>CP949(Code Page 949)는 한국어 문자를 표현하기 위해 마이크로소프트가 개발한 문자 인코딩이다.</description>
    </item>
    <item>
      <title>Network Topologies</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/network-topologies/</link>
      <pubDate>Mon, 16 Dec 2024 03:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/network-topologies/</guid>
      <description>네트워크 토폴로지는 컴퓨터 네트워크의 노드 (장치) 와 링크 (연결) 가 배열되고 연결되는 구조와 방식을 의미한다. 버스형, 성형, 링형, 메시형, 트리형 등 다양한 유형이 있으며, 물리적 배치와 논리적 데이터 흐름을 모두 포함한다. 각 토폴로지는 고유한 장단점을 가지며, 네트워크의 성능, 확장성, 신뢰성 및 비용에 직접적인 영향을 미친다.</description>
    </item>
    <item>
      <title>Adjacency Matrix vs Adjacency List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 15:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</guid>
      <description>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.</description>
    </item>
    <item>
      <title>Postorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/postorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/postorder-traversal/</guid>
      <description>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.</description>
    </item>
    <item>
      <title>LLVM vs 기존 컴파일러 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Thu, 05 Dec 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</guid>
      <description>LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.</description>
    </item>
    <item>
      <title>CSR vs SSR</title>
      <link>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/csr-vs-ssr/</link>
      <pubDate>Mon, 02 Dec 2024 12:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/csr-vs-ssr/</guid>
      <description>Client Side Rendering (CSR)은 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링하며, Server Side Rendering (SSR)은 서버에서 HTML을 생성하여 클라이언트에 전달한다.</description>
    </item>
    <item>
      <title>Python Web Framework</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/</link>
      <pubDate>Fri, 29 Nov 2024 04:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/</guid>
      <description>동적 웹사이트, 웹 서비스 및 웹 애플리케이션의 개발을 지원하기 위해 만들어진 소프트웨어 프레임워크</description>
    </item>
    <item>
      <title>Event Brokers</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/fundamentals/event-brokers/</link>
      <pubDate>Fri, 25 Oct 2024 06:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/fundamentals/event-brokers/</guid>
      <description>Event Broker는 이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 3. Transport Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/transport-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/transport-layer/</guid>
      <description>전송 계층은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신을 제공한다.</description>
    </item>
    <item>
      <title>TCP/IP 4Layers</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/</link>
      <pubDate>Thu, 17 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/</guid>
      <description>인터넷 프로토콜 스위트의 구조를 설명하는 계층화된 모델.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 3. Network Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/</guid>
      <description>3계층으로, 서로 다른 네트워크 간의 데이터 전송을 담당</description>
    </item>
    <item>
      <title>Ahead-of-Time Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/ahead-of-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/ahead-of-time-compiler/</guid>
      <description>**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술</description>
    </item>
    <item>
      <title>Programming Language Control Structures</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/programming-language-control-structures/</link>
      <pubDate>Sun, 06 Oct 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/programming-language-control-structures/</guid>
      <description>프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.</description>
    </item>
    <item>
      <title>인터프리터(Interpreter)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/interpreter/</link>
      <pubDate>Sun, 06 Oct 2024 05:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/interpreter/</guid>
      <description>프로그래밍 언어의 소스 코드를 직접 실행하는 프로그램 또는 환경</description>
    </item>
    <item>
      <title>EUC-KR</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/euc-kr/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/euc-kr/</guid>
      <description>EUC-KR은 한국어 텍스트를 컴퓨터에서 표현하기 위해 개발된 문자 인코딩 방식이다.</description>
    </item>
    <item>
      <title>Level Order Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/</guid>
      <description>레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.</description>
    </item>
    <item>
      <title>Compiler vs Interpreter vs Assembler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler-vs-interpreter-vs-assembler/</link>
      <pubDate>Thu, 05 Dec 2024 03:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler-vs-interpreter-vs-assembler/</guid>
      <description>컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.</description>
    </item>
    <item>
      <title>의사코드(Pseudocode)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/</link>
      <pubDate>Thu, 05 Dec 2024 01:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/</guid>
      <description>의사코드(Pseudocode)는 알고리즘을 설명하기 위한 비공식적이고 고수준의 표현 방식으로, 특정 프로그래밍 언어의 문법에 얽매이지 않고 간단한 텍스트 형태로 작성된다.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 4. Application Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/application-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/application-layer/</guid>
      <description>TCP/IP 프로토콜 스택에서 가장 상위 계층으로, 사용자와 가장 가까운 계층으로 이메일, 웹 서핑, 파일 전송 등의 서비스를 위한 프로토콜들이 모여 있는 계층이다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 4. Transport Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/transport-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/transport-layer/</guid>
      <description>4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다</description>
    </item>
    <item>
      <title>Just-In-Time (JIT) Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 17:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/</guid>
      <description>**JIT(Just-In-Time) 컴파일**은 프로그램 실행 시점에 코드를 기계어로 변환하는 기술로, **인터프리터의 유연성**과 **컴파일러의 성능**을 결합한 혁신적인 방식</description>
    </item>
    <item>
      <title>Native Compiler vs Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 03:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/</guid>
      <description>Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.</description>
    </item>
    <item>
      <title>Consistency Patterns</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/</link>
      <pubDate>Wed, 09 Oct 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/</guid>
      <description>분산 시스템에서 **일관성 패턴**은 시스템의 요구사항, 성능, 가용성, 지연 시간 간의 균형을 맞추기 위한 핵심 전략이다. 대표적인 패턴으로는 **Strong, Eventual, Causal, Weak Consistency** 등이 있으며, 시스템 요구 사항에 따라 다르게 적용되며 서로 다른 트레이드오프를 제공한다. 실무에서는 하이브리드 일관성 모델을 활용하거나, 동적으로 일관성을 조정하는 구조가 확대되고 있다. 2025 년에는 AI 기반 예측, Adaptive Consistency, 규제 대응 설계 전략 등이 주목받고 있다.</description>
    </item>
    <item>
      <title>Unicode</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/</link>
      <pubDate>Fri, 13 Dec 2024 16:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/</guid>
      <description>Unicode는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 국제 표준이다. 단순히 말해서, Unicode는 각 문자에 고유한 번호(코드 포인트)를 할당하는 표준화된 방식이다.</description>
    </item>
    <item>
      <title>Traversal 방법 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Fri, 06 Dec 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/</guid>
      <description>트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.</description>
    </item>
    <item>
      <title>Runtime</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/runtime/</link>
      <pubDate>Thu, 05 Dec 2024 04:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/runtime/</guid>
      <description>컴퓨터 과학에서 **런타임(runtime)** 은 프로그램이 실제로 실행되는 기간과 그 실행 환경 전체를 의미한다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 5. Session Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/session-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/session-layer/</guid>
      <description>세션 계층은 OSI 모델의 5번째 계층으로, 통신 세션을 구성하는 계층으로 응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 프로세스들의 논리적인 연결을 담당한다.</description>
    </item>
    <item>
      <title>JIT Compiler vs AOT Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/jit-compiler-vs-aot-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/jit-compiler-vs-aot-compiler/</guid>
      <description>JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다</description>
    </item>
    <item>
      <title>AOT vs. JIT vs. Interpreter</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/aot-vs-jit-vs-interpreter/</link>
      <pubDate>Mon, 14 Oct 2024 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/aot-vs-jit-vs-interpreter/</guid>
      <description>AOT, JIT, 그리고 인터프리터는 모두 소스 코드를 실행 가능한 형태로 변환하는 언어 처리 방식이지만, 언제 어떻게 변환이 이루어지는지에 따라 큰 차이가 있다.</description>
    </item>
    <item>
      <title>Availability Patterns</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/availability-patterns/</link>
      <pubDate>Wed, 09 Oct 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/availability-patterns/</guid>
      <description>가용성 패턴은 분산 시스템과 클라우드 환경에서 서비스의 안정적인 운영을 보장하기 위한 설계 패턴이다. 이 패턴들은 시스템의 일부가 실패하더라도 전체 시스템의 가용성을 유지하고, 장애에 대한 복원력을 제공하며, 사용자에게 지속적인 서비스를 제공하는 것을 목표로 한다. 서킷 브레이커, 벌크헤드, 헬스 엔드포인트 모니터링 등 다양한 패턴을 포함한다.</description>
    </item>
    <item>
      <title>언어 프로세서(Language Processor)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/</link>
      <pubDate>Thu, 05 Dec 2024 03:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/</guid>
      <description>소스 코드나 어셈블리어 등 인간이 이해하기 편한 언어로 작성된 코드를 컴퓨터가 실행할 수 있는 기계어나 그에 가까운 형태로 변환하는 역할을 한다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 6. Presentation Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/presentation-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/presentation-layer/</guid>
      <description>OSI 7계층 모델에서 6번째 계층으로, 데이터의 표현과 암호화를 담당하는 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Background Jobs</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/async-and-background-processing/background-jobs/</link>
      <pubDate>Wed, 09 Oct 2024 04:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/async-and-background-processing/background-jobs/</guid>
      <description>백그라운드 작업 (Background Jobs) 은 사용자 요청 처리 흐름에서 분리되어 비동기적으로 실행되는 작업으로 시스템의 응답성과 확장성을 향상시킨다. 이러한 작업은 대용량 데이터 처리, 장기 실행 워크플로우, 실패 재시도, 이벤트 기반 트리거 등 다양한 시나리오에서 활용된다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 7. Application Layer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/application-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/application-layer/</guid>
      <description>OSI 7계층 모델에서 최상위 계층으로, 사용자와 네트워크 간의 직접적인 상호작용을 담당한다</description>
    </item>
    <item>
      <title>가비지 컬렉션 (Garbage Collection, GC)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/memory-management/garbage-collection/</link>
      <pubDate>Sun, 06 Oct 2024 10:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/memory-management/garbage-collection/</guid>
      <description>프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Sat, 12 Oct 2024 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>Json (JavaScript Object Notation)</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/json/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/json/</guid>
      <description>&lt;h2 id=&#34;json-javascript-object-notation&#34;&gt;Json (JavaScript Object Notation)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;용어-정리&#34;&gt;용어 정리&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;h3 id=&#34;1-주제의-분류-적절성&#34;&gt;1. 주제의 분류 적절성&lt;/h3&gt;
&lt;p&gt;JSON(JavaScript Object Notation, 자바스크립트 객체 표기법) 은 &amp;ldquo;Computer Science and Engineering&amp;rdquo; &amp;gt; &amp;ldquo;Backend Development&amp;rdquo; &amp;gt; &amp;ldquo;Backend Fundamentals&amp;rdquo; &amp;gt; &amp;ldquo;Data Exchange&amp;rdquo; &amp;gt; &amp;ldquo;Format&amp;rdquo; &amp;gt; &amp;ldquo;Text-Based&amp;rdquo; 분류에 매우 적합하다. JSON 은 백엔드 시스템에서 데이터 교환, 저장, API 응답 등 핵심적인 역할을 하는 대표적인 텍스트 기반 데이터 포맷이다 [1][2][3].&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-요약-설명-200-자-내외&#34;&gt;2. 요약 설명 (200 자 내외)&lt;/h3&gt;
&lt;p&gt;JSON 은 텍스트 기반의 경량 데이터 교환 포맷으로, 다양한 언어와 플랫폼에서 구조화된 데이터를 직관적으로 표현하고 교환할 수 있다. 웹 API, 설정 파일, NoSQL 데이터베이스 등에서 표준적으로 사용된다 [2][3][8].&lt;/p&gt;</description>
    </item>
    <item>
      <title>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</guid>
      <description>데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.</description>
    </item>
    <item>
      <title>TOML (Tom&#39;s Obvious Minimal Language)</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/toml/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/toml/</guid>
      <description>서로 다른 시스템이나 프로그램 간에 데이터를 주고받을 때 사용하는 표준화된 형식</description>
    </item>
    <item>
      <title>YAML (YAML Ain&#39;t Markup Language)</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/</guid>
      <description>YAML은 데이터를 표현하기 위한 인간 친화적인 직렬화 언어로, 프로그래밍 언어에 의존하지 않고 다양한 시스템 간에 데이터를 교환할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Encoding and Decoding</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/</link>
      <pubDate>Sat, 26 Oct 2024 07:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/</guid>
      <description>인코딩(Encoding)은 데이터를 특정 형식으로 변환하는 과정이고, 디코딩(Decoding)은 인코딩의 반대 과정으로, 변환된 데이터를 원래의 형식으로 되돌리는 과정</description>
    </item>
    <item>
      <title>Blocking vs Non-Blocking</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/blocking-vs-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/blocking-vs-non-blocking/</guid>
      <description>프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.</description>
    </item>
    <item>
      <title>Poetry vs uv vs Rye</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/</link>
      <pubDate>Wed, 27 Nov 2024 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/</guid>
      <description>파이썬 프로젝트 관리와 패키지 설치를 위한 도구들</description>
    </item>
    <item>
      <title>Streaming vs Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-vs-polling/</link>
      <pubDate>Sun, 20 Oct 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-vs-polling/</guid>
      <description>Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술</description>
    </item>
    <item>
      <title>동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/synchronization-and-asynchronization/synchronous-and-asynchronous-and-blocking-and-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/synchronization-and-asynchronization/synchronous-and-asynchronous-and-blocking-and-non-blocking/</guid>
      <description>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</description>
    </item>
    <item>
      <title>Lock and Mutex</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/lock-and-mutex/</link>
      <pubDate>Sat, 05 Oct 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/lock-and-mutex/</guid>
      <description>Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.</description>
    </item>
    <item>
      <title>setup.cfg vs pyproject.toml</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/</link>
      <pubDate>Wed, 27 Nov 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/</guid>
      <description>Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.</description>
    </item>
    <item>
      <title>Connection Pool</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-integration/connection-pool/</link>
      <pubDate>Fri, 25 Oct 2024 06:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-integration/connection-pool/</guid>
      <description>Connection pool은 데이터베이스 연결을 재사용 가능한 형태로 캐시하는 메커니즘이다.  이는 애플리케이션이 데이터베이스에 연결할 때마다 새로운 연결을 생성하는 대신, 미리 생성된 연결을 사용할 수 있게 해준다.</description>
    </item>
    <item>
      <title>ER(Entity-Relationship) 모델링</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/</link>
      <pubDate>Fri, 25 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/</guid>
      <description>실제 세계의 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 표현하여 데이터베이스를 설계하는 방법</description>
    </item>
    <item>
      <title>Failback vs. Fail Over</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/failback/failback-vs-fail-over/</link>
      <pubDate>Sun, 18 May 2025 12:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/failback/failback-vs-fail-over/</guid>
      <description>Failover 는 주 시스템에 장애 발생 시 대기 시스템으로 자동 전환하여 서비스 연속성을 유지하는 방식이며, Failback 은 주 시스템이 복구된 후 원래 상태로 되돌리는 과정이다. 이 두 메커니즘은 고가용성 시스템에서 다운타임을 최소화하고 비즈니스 연속성을 보장하는 필수적인 재해 복구 전략을 구성한다.</description>
    </item>
    <item>
      <title>Failback</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/failback/</link>
      <pubDate>Sun, 18 May 2025 12:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/failback/</guid>
      <description>Failback 은 장애 발생 시 예비 시스템으로 전환된 (Failover) 서비스를 원본 시스템으로 복구하는 프로세스이다. 데이터 동기화, 서비스 재개, 자원 재배치 등을 통해 시스템의 정상 운영 상태를 복원하며, 계획된 유지보수나 비상 복구 시나리오에서 필수적으로 적용된다.</description>
    </item>
    <item>
      <title>Horizontal vs. Vertical Scaling</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/horizontal-vs-vertical-scaling/</link>
      <pubDate>Thu, 03 Apr 2025 15:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/scalability-and-performance/horizontal-vs-vertical-scaling/</guid>
      <description>수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다.</description>
    </item>
    <item>
      <title>Domain Name System</title>
      <link>https://buenhyden.github.io/posts/backend-development/web-infrastructure/domain-name-system/</link>
      <pubDate>Tue, 01 Apr 2025 02:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/web-infrastructure/domain-name-system/</guid>
      <description>DNS(Domain Name System)는 인터넷의 전화번호부와 같은 역할을 한다. 사람이 읽고 이해할 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(예: 192.0.2.1)로 변환해주는 시스템이다.</description>
    </item>
    <item>
      <title>Instrumentation</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/instrumentation/</link>
      <pubDate>Sat, 22 Mar 2025 14:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/instrumentation/</guid>
      <description>애플리케이션 코드에 특정 로직을 추가하여 메트릭, 로그, 트레이스와 같은 데이터를 수집하고 분석할 수 있도록 만드는 과정이다</description>
    </item>
    <item>
      <title>PACELC Theorem</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/pacelc-theorem/</link>
      <pubDate>Sat, 22 Mar 2025 06:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/pacelc-theorem/</guid>
      <description>PACELC 정리는 CAP 이론을 확장하여 네트워크 분할 (Partition) 발생 시 **A(가용성) vs C(일관성)**, 정상 시 **L(지연 시간) vs C(일관성)** 간 트레이드오프를 명시하는 이론이다. 이는 시스템 설계 시 필연적인 선택과 트레이드오프를 요구한다. 2025 년 현재 초대규모 분산 시스템에서 동적 리소스 할당과 AI 기반 자동 최적화 기술에 필수적으로 적용되며, 클라우드 네이티브 아키텍처 설계의 핵심 원칙으로 작용한다.</description>
    </item>
    <item>
      <title>UTF-8</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/</link>
      <pubDate>Wed, 12 Mar 2025 13:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/</guid>
      <description>UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다.</description>
    </item>
    <item>
      <title>Base64</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/base64/</link>
      <pubDate>Wed, 12 Mar 2025 13:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/base64/</guid>
      <description>Base64는 바이너리 데이터를 텍스트 형식으로 안전하게 변환하기 위한 인코딩 시스템이다.</description>
    </item>
    <item>
      <title>API First Design</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-first-design/</link>
      <pubDate>Thu, 27 Feb 2025 13:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-first-design/</guid>
      <description>API를 먼저 설계하고 이를 중심으로 개발을 진행함으로써, 다양한 클라이언트 플랫폼을 지원하고 개발 효율성을 높일 수 있다. 단순히 기술적 측면뿐만 아니라 비즈니스 민첩성, 개발자 경험, 제품 품질 등 여러 측면에서 이점을 제공한다. 올바르게 적용하기 위해서는 명확한 설계 표준, 적절한 도구, 그리고 팀 문화의 변화가 필요하다. 마이크로서비스 아키텍처, 클라우드 네이티브 애플리케이션, 그리고 다양한 디지털 채널을 통합해야 하는 현대 비즈니스 환경에서 그 중요성이 더욱 부각되고 있다.</description>
    </item>
    <item>
      <title>Pagination</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/pagination/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/pagination/</guid>
      <description>페이지네이션을 통해 서버는 데이터를 작은 &amp;#34;페이지&amp;#34; 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.</description>
    </item>
    <item>
      <title>URI Design</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-endpoint-design/uri-design/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-endpoint-design/uri-design/</guid>
      <description>잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.</description>
    </item>
    <item>
      <title>Versioning Strategies</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/versioning/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/versioning/</guid>
      <description>API 버전 관리는 현대 소프트웨어 개발의 핵심 요소로, 기존 클라이언트의 호환성을 유지하면서 API를 발전시키는 방법이다.</description>
    </item>
    <item>
      <title>AI Engineer vs. ML Engineer</title>
      <link>https://buenhyden.github.io/posts/ai/ai-engineering/fundamentals/ai-engineer-vs-ml-engineer/</link>
      <pubDate>Tue, 25 Feb 2025 14:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/ai/ai-engineering/fundamentals/ai-engineer-vs-ml-engineer/</guid>
      <description>AI Engineer는 NLP, Computer Vision 등을 포함한 복합적인 AI 시스템을 개발하고 ML Engineer는 데이터 기반 ML 모델 구축 및 최적화를 수행한다.</description>
    </item>
    <item>
      <title>AI vs. AGI</title>
      <link>https://buenhyden.github.io/posts/ai/fundamentals/ai-vs-agi/</link>
      <pubDate>Tue, 25 Feb 2025 14:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/ai/fundamentals/ai-vs-agi/</guid>
      <description>AI (Artificial Intelligence)는 특정 작업을 수행하기 위해 인간의 지능을 모방하는 기술이며 AGI (Artificial General Intelligence)는 모든 지적 작업에서 인간 수준의 인지 능력을 갖춘 이론적 시스템을 말한다.</description>
    </item>
    <item>
      <title>CAP Theorem</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/cap-theorem/</link>
      <pubDate>Thu, 20 Feb 2025 00:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/cap-theorem/</guid>
      <description>CAP 이론은 분산 시스템에서 일관성 (Consistency), 가용성 (Availability), 파티션 내성 (Partition Tolerance) 세 가지 속성 중 동시에 두 가지만 보장할 수 있다는 원칙이다. 네트워크 파티션 발생 시 시스템은 일관성과 가용성 중 하나를 선택해야 하며, 이는 분산 데이터베이스와 같은 시스템 설계에 중요한 영향을 미친다. 파티션 내성은 현실적인 분산 환경에서 필수적이므로 실제로는 일관성과 가용성 사이의 트레이드오프가 핵심이다.</description>
    </item>
    <item>
      <title>Fail Over</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/fail-over/</link>
      <pubDate>Tue, 18 Feb 2025 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/fail-over/</guid>
      <description>페일오버(Failover)는 시스템의 주요 구성 요소가 실패했을 때 자동으로 대체 구성 요소로 전환하여 서비스 연속성을 보장하는 고가용성 아키텍처 패턴으로 장애 감지, 전환 메커니즘, 데이터 동기화가 핵심 요소이다. 단일 장애점을 해결하기 위해 중복성을 도입하고, 액티브 - 패시브, 액티브 - 액티브, N&#43;1 등 다양한 구현 방식을 통해 시스템 다운타임을 최소화하고 비즈니스 연속성을 유지한다.  현대 IT 환경에서는 클라우드 기반 페일오버, 컨테이너화된 환경의 자동화된 페일오버, AI 기반 사전 예측 페일오버 등으로 진화하고 있으며, 비즈니스 연속성과 사용자 경험 보장에 필수적이다.</description>
    </item>
    <item>
      <title>Replication</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/replication/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/application-architecture/reliability-patterns/availability/replication/</guid>
      <description>복제 (Replication) 는 데이터나 서비스의 사본을 여러 노드나 시스템에 분산 저장하는 기법으로, 시스템의 가용성, 내결함성, 확장성을 향상시킨다. 주로 마스터 - 슬레이브, 다중 마스터, 액티브 - 액티브와 같은 아키텍처로 구현되며, 동기식 또는 비동기식 복제 방식을 사용한다. CAP 이론에 따라 일관성과 가용성 사이의 균형을 고려해 설계된다.</description>
    </item>
    <item>
      <title>Hashing</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/hashing/</link>
      <pubDate>Thu, 02 Jan 2025 01:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/hashing/</guid>
      <description>해싱(Hashing)은 임의의 크기를 가진 데이터를 고정된 크기의 값으로 변환하는 과정이다.</description>
    </item>
    <item>
      <title>Network Types</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/</link>
      <pubDate>Mon, 30 Dec 2024 03:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/</guid>
      <description>네트워크 유형은 컴퓨터나 장치들이 상호 연결되는 방식과 범위에 따라 분류되는 네트워크 구조를 의미한다. PAN, LAN, MAN, WAN 과 같은 지리적 범위에 따른 분류와 버스, 스타, 링, 메시, 트리와 같은 토폴로지 기반 분류로 나뉘며, 각 유형은 고유한 특성, 장단점, 적용 사례를 가지고 있어 다양한 네트워킹 요구사항을 충족시킨다.</description>
    </item>
    <item>
      <title>Deterministic vs. Nondeterministic computation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/deterministic-vs-nondeterministic-computation/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/deterministic-vs-nondeterministic-computation/</guid>
      <description>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</description>
    </item>
    <item>
      <title>P vs NP problem</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/</guid>
      <description>P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다</description>
    </item>
    <item>
      <title>NP-Hard vs. NP-Complete</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/</link>
      <pubDate>Fri, 27 Dec 2024 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/</guid>
      <description>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</description>
    </item>
    <item>
      <title>Event Loop</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/fundamentals/async-programming/event-loop/</link>
      <pubDate>Thu, 26 Dec 2024 14:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/fundamentals/async-programming/event-loop/</guid>
      <description>Node.js의 이벤트 루프는 Node.js 애플리케이션의 핵심 작동 원리로, 비동기 I/O 작업을 효율적으로 처리하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Currying vs. Partial Application</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying-vs-partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 10:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying-vs-partial-application/</guid>
      <description> 커링(Currying)과 부분 적용(Partial Application)은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.</description>
    </item>
    <item>
      <title>Partial Application</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/partial-application/</guid>
      <description>부분 적용이란 여러 개의 인자를 받는 함수에 일부 인자를 미리 제공하여, 나머지 인자만 받는 새로운 함수를 생성하는 기법이다.</description>
    </item>
    <item>
      <title>Currying</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying/</link>
      <pubDate>Thu, 26 Dec 2024 07:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying/</guid>
      <description>여러 개의 인자를 받는 함수를 단일 인자를 받는 일련의 함수들로 변환하는 기법이다.</description>
    </item>
    <item>
      <title>지연 초기화(Lazy Initialization)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/</link>
      <pubDate>Wed, 18 Dec 2024 10:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/</guid>
      <description>지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법</description>
    </item>
    <item>
      <title>UML</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/principles-and-modeling/documentation/uml/uml/</link>
      <pubDate>Mon, 16 Dec 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/principles-and-modeling/documentation/uml/uml/</guid>
      <description>UML(Unified Modeling Language)은 시스템, 소프트웨어, 비즈니스 프로세스를 시각적으로 모델링하기 위한 표준화된 범용 모델링 언어이다.</description>
    </item>
    <item>
      <title>Format</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/</link>
      <pubDate>Mon, 16 Dec 2024 12:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/</guid>
      <description>데이터 포맷은 정보를 구조화하고, 저장하며, 교환하는 표준화된 방식이다.</description>
    </item>
    <item>
      <title>Bitwise Operators</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/bitwise-operations/</link>
      <pubDate>Sat, 14 Dec 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/bitwise-operations/</guid>
      <description>비트와이즈 연산자는 비트 수준에서 작동하는 연산자로, 데이터를 효율적으로 다루는 데 필수적인 도구</description>
    </item>
    <item>
      <title>Little Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/little-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/little-endian/</guid>
      <description>리틀 엔디안은 낮은 자리의 바이트가 낮은 메모리 주소에 먼저 저장되는 방식이다. 즉, 데이터의 &amp;#34;작은&amp;#34; 부분(Least Significant Byte)이 메모리의 작은 주소에 위치한다.</description>
    </item>
    <item>
      <title>Big Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/big-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/big-endian/</guid>
      <description>빅 엔디안은 가장 중요한 바이트(Most Significant Byte, MSB)를 먼저 저장하는 방식이다. 즉, 높은 자리의 바이트가 낮은 메모리 주소에 위치한다.</description>
    </item>
    <item>
      <title>Endianness</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/</link>
      <pubDate>Fri, 13 Dec 2024 16:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/</guid>
      <description>Endianness(엔디안)는 컴퓨터 메모리에서 데이터를 저장하는 바이트 순서를 의미한다.</description>
    </item>
    <item>
      <title>Floating Point Numbers</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/floating-point/</link>
      <pubDate>Fri, 13 Dec 2024 16:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/floating-point/</guid>
      <description>부동소수점 수는 컴퓨터에서 실수를 표현하는 핵심적인 방식</description>
    </item>
    <item>
      <title>문자 인코딩(Character Encodings)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/</link>
      <pubDate>Fri, 13 Dec 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/</guid>
      <description>문자 인코딩은 인간이 읽을 수 있는 텍스트를 컴퓨터가 이해할 수 있는 이진 형식으로 변환하는 방법을 정의한다.</description>
    </item>
    <item>
      <title>NP-난해(NP-Hard)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/</guid>
      <description>문제 H가 NP-Hard라는 것은, 모든 NP 문제가 다항 시간 내에 H로 환원(reduce)될 수 있다는 것을 의미한다.</description>
    </item>
    <item>
      <title>다항 공간(Polynomial Space) 클래스</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/polynomial-space/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/polynomial-space/</guid>
      <description>PSPACE는 결정론적 튜링 기계에서 다항 크기의 메모리를 사용하여 해결할 수 있는 모든 결정 문제의 집합이다.</description>
    </item>
    <item>
      <title>지수 시간(Exponential Time) 복잡도</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/exponential-time/</link>
      <pubDate>Thu, 12 Dec 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/exponential-time/</guid>
      <description>지수 시간(Exponential Time) 복잡도는 알고리즘의 실행 시간이 입력 크기에 대해 지수적으로 증가하는 경우를 나타낸다.</description>
    </item>
    <item>
      <title>NP-완전(NP-Complete)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-complete/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-complete/</guid>
      <description>NP-완전 문제는 NP 클래스 내에서 가장 &amp;#34;어려운&amp;#34; 문제들이다.</description>
    </item>
    <item>
      <title>다항 시간(Polynomial Time, P)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/polynomial-time/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/polynomial-time/</guid>
      <description>다항 시간(Polynomial Time)이란 알고리즘의 실행 시간이 입력 크기 n에 대한 다항식 함수로 표현될 수 있음을 의미한다.  즉, 알고리즘의 시간 복잡도가 O(n^k) 형태로 표현되는 경우를 말한다.</description>
    </item>
    <item>
      <title>비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/</link>
      <pubDate>Thu, 12 Dec 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/</guid>
      <description>비결정론적 다항 시간(NP)은 비결정론적 튜링 기계(Non-deterministic Turing Machine)에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합을 의미한다. 좀 더 직관적인 정의로는 &amp;#34;해답이 주어졌을 때 그 해답이 올바른지 다항 시간 내에 검증할 수 있는 문제들의 집합&amp;#34;이라고 할 수 있다.</description>
    </item>
    <item>
      <title>Asymptotic Notation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/asymptotic-notation/</link>
      <pubDate>Fri, 06 Dec 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/asymptotic-notation/</guid>
      <description>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.</description>
    </item>
    <item>
      <title>CSR</title>
      <link>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/</link>
      <pubDate>Mon, 02 Dec 2024 03:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/</guid>
      <description>웹 애플리케이션에서 클라이언트 측, 즉 사용자의 웹 브라우저에서 JavaScript를 사용하여 웹 페이지를 렌더링하는 방식</description>
    </item>
    <item>
      <title>setup.cfg</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg/</link>
      <pubDate>Wed, 27 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg/</guid>
      <description>파이썬 프로젝트의 설정을 관리하는 구성 파일</description>
    </item>
    <item>
      <title>Poetry</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/</guid>
      <description>Python 프로젝트의 의존성 관리와 패키징을 위한 도구</description>
    </item>
    <item>
      <title>The pyproject.toml file</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/</link>
      <pubDate>Wed, 27 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/</guid>
      <description>Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일</description>
    </item>
    <item>
      <title>Rye</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/</link>
      <pubDate>Wed, 27 Nov 2024 04:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/</guid>
      <description>Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.</description>
    </item>
    <item>
      <title>uv</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/uv/</link>
      <pubDate>Wed, 27 Nov 2024 04:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/uv/</guid>
      <description>Rust로 작성된 UV는 기존의 pip, pip-tools, virtualenv 등을 대체할 수 있는 초고속 파이썬 패키지 설치 및 의존성 해결 도구이다.</description>
    </item>
    <item>
      <title>PEP</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/</guid>
      <description>Python Enhancement Proposal의 약자로 파이썬 커뮤니티에 새로운 기능을 알리거나 설명하는 설계 문서.</description>
    </item>
    <item>
      <title>Python Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/keywords/</link>
      <pubDate>Sun, 24 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/keywords/</guid>
      <description>파이썬에서 이미 예약되어있는 문자열</description>
    </item>
    <item>
      <title>Generator and Iterator</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/generator-and-iterator/</link>
      <pubDate>Sun, 24 Nov 2024 10:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/generator-and-iterator/</guid>
      <description>이터레이터는 값을 차례대로 반환하는 객체로, `__iter__()`와 `__next__()` 메서드를 구현한다.  제너레이터는 `yield` 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.</description>
    </item>
    <item>
      <title>Python - Generators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/functions/generators/</link>
      <pubDate>Sun, 24 Nov 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/functions/generators/</guid>
      <description>반복 가능한 객체를 생성하는 강력한 도구</description>
    </item>
    <item>
      <title>연산자(Operators)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/operations/operators/</link>
      <pubDate>Sun, 24 Nov 2024 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/operations/operators/</guid>
      <description>연산자는 프로그래밍의 기본적인 구성 요소로, 데이터를 조작하고 계산하는 데 사용된다.</description>
    </item>
    <item>
      <title>Java Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/</link>
      <pubDate>Wed, 20 Nov 2024 02:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/</guid>
      <description>키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.  변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/async-and-background-processing/asynchronism/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/async-and-background-processing/asynchronism/back-pressure/</guid>
      <description>시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.</description>
    </item>
    <item>
      <title>비대칭키 암호화 (Asymmetric Encryption)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/asymmetric-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 21:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/asymmetric-encryption/</guid>
      <description>공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식</description>
    </item>
    <item>
      <title>대칭키 암호화 (Symmetric Encryption)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/symmetric-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 21:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/symmetric-encryption/</guid>
      <description>동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식</description>
    </item>
    <item>
      <title>동형 암호화(Homomorphic Encryption)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/homomorphic-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 13:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/encryption/homomorphic-encryption/</guid>
      <description>동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술</description>
    </item>
    <item>
      <title>양자 암호화(quantum cryptography)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/quantum-cryptography/</link>
      <pubDate>Sat, 09 Nov 2024 13:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/quantum-cryptography/</guid>
      <description>양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술</description>
    </item>
    <item>
      <title>영지식 증명(Zero-Knowledge Proof, ZKP)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/zero-knowledge-proof/</link>
      <pubDate>Sat, 09 Nov 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/zero-knowledge-proof/</guid>
      <description>영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.</description>
    </item>
    <item>
      <title>OWASP Top 10</title>
      <link>https://buenhyden.github.io/posts/security-engineering/fundamentals/owasp-top-10/</link>
      <pubDate>Sat, 09 Nov 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/fundamentals/owasp-top-10/</guid>
      <description>웹 애플리케이션의 가장 심각한 보안 위험 10가지를 정리한 보고서</description>
    </item>
    <item>
      <title>디지털 서명 (digital signature)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/authentication/digital-signature/</link>
      <pubDate>Sat, 09 Nov 2024 06:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/authentication/digital-signature/</guid>
      <description>전자 문서나 메시지의 진위성, 무결성, 그리고 부인 방지를 보장하기 위해 사용되는 암호화 기술</description>
    </item>
    <item>
      <title>Message Authentication Code</title>
      <link>https://buenhyden.github.io/posts/security-engineering/cryptography/authentication/message-authentication-code/</link>
      <pubDate>Fri, 08 Nov 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/cryptography/authentication/message-authentication-code/</guid>
      <description>Message Authentication Code는 메시지의 무결성(integrity)과 출처 인증(authentication)을 동시에 보장하기 위한 암호학적 도구로, 메시지와 비밀키를 입력으로 받아 고정된 길이의 값을 생성하며, 이 값은 메시지에 대한 일종의 디지털 지문 역할을 한다.</description>
    </item>
    <item>
      <title>Black-box Test and White-box Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-test-and-white-box-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-test-and-white-box-test/</guid>
      <description>Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Fakes</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/fakes/</link>
      <pubDate>Fri, 01 Nov 2024 21:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/fakes/</guid>
      <description>실제 객체의 간단한 구현을 제공하는 테스트용 객체</description>
    </item>
    <item>
      <title>Dummy Objects</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/dummy-objects/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/dummy-objects/</guid>
      <description>테스트 과정에서 실제로는 사용되지 않지만 메서드의 파라미터를 채우기 위해 전달되는 객체</description>
    </item>
    <item>
      <title>Spies</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/spies/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/spies/</guid>
      <description>실제 객체의 메서드 호출을 추적하고 기록하는 데 사용</description>
    </item>
    <item>
      <title>Test Double</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/</guid>
      <description>소프트웨어 테스트에서 실제 객체를 대신하여 사용되는 테스트용 객체</description>
    </item>
    <item>
      <title>Stubs</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/stubs/</link>
      <pubDate>Fri, 01 Nov 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/stubs/</guid>
      <description>테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘</description>
    </item>
    <item>
      <title>코드 크기 메트릭(Lines of Code, LOC)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/lines-of-code/</link>
      <pubDate>Mon, 28 Oct 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/lines-of-code/</guid>
      <description>이 메트릭은 프로그램의 크기를 코드 라인 수로 표현하며, 소프트웨어 개발 프로젝트의 규모 추정, 생산성 측정, 품질 관리 등에 활용된다</description>
    </item>
    <item>
      <title>유지보수성 지수 (Maintainability Index)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/maintainability-index/</link>
      <pubDate>Mon, 28 Oct 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/maintainability-index/</guid>
      <description>유지보수성 지수는 코드를 얼마나 쉽게 유지보수할 수 있는지를 나타내는 0에서 100 사이의 수치로 높을수록 코드의 유지보수가 더 쉽다는 것을 의미한다.</description>
    </item>
    <item>
      <title>응집도(Cohesion)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cohesion/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cohesion/</guid>
      <description>하나의 모듈이 얼마나 단일한 목적에 집중되어 있는지를 나타낸다.</description>
    </item>
    <item>
      <title>코드 중복도 (Code Duplication)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/code-duplication/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/code-duplication/</guid>
      <description>코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다</description>
    </item>
    <item>
      <title>결합도 (Coupling)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/coupling/</link>
      <pubDate>Mon, 28 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/coupling/</guid>
      <description>서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표</description>
    </item>
    <item>
      <title>테스트 커버리지 (Test Coverage)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/test-coverage/</link>
      <pubDate>Mon, 28 Oct 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/test-coverage/</guid>
      <description>테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도</description>
    </item>
    <item>
      <title>Halstead Complexity</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/halstead-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/halstead-complexity/</guid>
      <description>프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다</description>
    </item>
    <item>
      <title>순환 복잡도 (Cyclomatic Complexity)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cyclomatic-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cyclomatic-complexity/</guid>
      <description>프로그램의 논리적 복잡성을 정량적으로 측정하는 지표</description>
    </item>
    <item>
      <title>품질 메트릭 (Quality Metric)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/</link>
      <pubDate>Mon, 28 Oct 2024 05:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/</guid>
      <description>소프트웨어 개발 프로세스, 제품, 테스트 활동의 품질과 효과성을 평가하고 측정하는 데 사용되는 정량적 지표이다</description>
    </item>
    <item>
      <title>YAML vs. JSON vs. XML</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/yaml-vs-json-vs-xml/</link>
      <pubDate>Sat, 26 Oct 2024 09:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/yaml-vs-json-vs-xml/</guid>
      <description>데이터 교환과 구성 파일 형식으로 YAML, JSON, XML은 현대 소프트웨어 개발에서 가장 널리 사용되는 세 가지 형식이다.</description>
    </item>
    <item>
      <title>Serialization and Deserialization</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/serialization-and-deserialization/</link>
      <pubDate>Sat, 26 Oct 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/serialization-and-deserialization/</guid>
      <description>직렬화(Serialization)는 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형식으로 변환하는 과정이다. 역직렬화(Deserialization)는 직렬화의 반대 과정으로, 저장되거나 전송된 바이트 스트림이나 텍스트를 원래의 객체 구조로 다시 변환하는 작업이다.</description>
    </item>
    <item>
      <title>데이터 불일치 (Data Inconsistency)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-inconsistency/</link>
      <pubDate>Fri, 25 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-inconsistency/</guid>
      <description>동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황</description>
    </item>
    <item>
      <title>Cloud Networking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/cloud-networking/</link>
      <pubDate>Sun, 20 Oct 2024 17:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/cloud-networking/</guid>
      <description>클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.</description>
    </item>
    <item>
      <title>스트리밍 (Streaming)</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/</link>
      <pubDate>Sun, 20 Oct 2024 06:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/</guid>
      <description>스트리밍은 인터넷을 통해 오디오, 비디오 및 기타 콘텐츠를 실시간으로 전송하고 재생하는 기술</description>
    </item>
    <item>
      <title>네트워크 기능 가상화(Network Functions Virtualization, NFV)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/</link>
      <pubDate>Sun, 20 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/</guid>
      <description>NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.</description>
    </item>
    <item>
      <title>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/</link>
      <pubDate>Sun, 20 Oct 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/</guid>
      <description>네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.</description>
    </item>
    <item>
      <title>RDMA</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/rdma/</link>
      <pubDate>Sun, 20 Oct 2024 01:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/rdma/</guid>
      <description>네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술</description>
    </item>
    <item>
      <title>Media Access Control Address (MAC Address)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/cross-layer-functions/addressing-schemes/physical/mac-address/</link>
      <pubDate>Wed, 16 Oct 2024 12:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/cross-layer-functions/addressing-schemes/physical/mac-address/</guid>
      <description>네트워크 장비를 식별하기 위한 고유한 하드웨어 주소</description>
    </item>
    <item>
      <title>Packet</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/packet/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/packet/</guid>
      <description>패킷(Packet)은 네트워크를 통해 전송되는 데이터의 기본 단위</description>
    </item>
    <item>
      <title>Routing</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/routing/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/routing/</guid>
      <description>데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.</description>
    </item>
    <item>
      <title>Network Hop</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/network-hop/</link>
      <pubDate>Wed, 16 Oct 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/network-hop/</guid>
      <description>네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.</description>
    </item>
    <item>
      <title>프래그먼테이션 (Fragmentation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/fragmentation/</link>
      <pubDate>Wed, 16 Oct 2024 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/fragmentation/</guid>
      <description>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/</guid>
      <description>환원 가능성은 하나의 문제를 다른 문제로 &amp;#34;변환&amp;#34;할 수 있는 능력을 의미한다.</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>Linearizability</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/linearizability/</link>
      <pubDate>Wed, 09 Oct 2024 08:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/linearizability/</guid>
      <description>선형화 가능성은 분산 시스템에서 동시에 발생하는 작업들이 마치 단일 시스템에서 순차적으로 실행된 것처럼 보이게 하는 강력한 일관성 모델이다. 이는 모든 작업이 실시간 순서를 준수하면서 단일 순차적 순서대로 실행되는 것처럼 동작하도록 보장하여, 분산 환경에서도 마치 하나의 시스템처럼 일관된 상태를 유지한다.</description>
    </item>
    <item>
      <title>Causal Consistency</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/causal-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 08:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/causal-consistency/</guid>
      <description>인과적 일관성은 분산 시스템에서 연산 간의 인과 관계를 유지하는 일관성 모델로, 관련된 연산은 동일한 순서로 보장하되, 독립적인 연산은 순서에 구애받지 않아 성능과 가용성을 향상시킨다.</description>
    </item>
    <item>
      <title>Eventual Consistency</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/eventual-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/eventual-consistency/</guid>
      <description>Eventual Consistency 는 분산 시스템에서 데이터가 즉시 일관되지 않아도 시간이 지나면 모든 노드가 동일한 상태로 수렴함을 보장하는 일관성 모델이다. 이는 높은 가용성과 확장성을 지원하지만, 일시적인 데이터 불일치와 충돌 해결이 필요하다</description>
    </item>
    <item>
      <title>Weak Consistency</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/weak-consistency/</link>
      <pubDate>Wed, 09 Oct 2024 05:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/system-design-and-architecture/system-concepts/consistency-models/weak-consistency/</guid>
      <description>약한 일관성 (Weak Consistency) 은 분산 시스템에서 데이터 일관성 모델 중 하나로, 데이터의 최신 상태를 즉시 보장하지 않으며, 일시적인 불일치 상태를 허용하는 모델입니다. 시스템의 가용성과 성능을 우선시하는 환경에서 유용하게 활용된다.</description>
    </item>
    <item>
      <title>동시성 (Concurrency)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/concurrency/</link>
      <pubDate>Fri, 04 Oct 2024 06:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/concurrency/</guid>
      <description>동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다.</description>
    </item>
    <item>
      <title>병렬성 (Parallelism)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/parallelism/</link>
      <pubDate>Fri, 04 Oct 2024 02:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/parallelism/</guid>
      <description>병렬성(Parallelism)은 컴퓨터 프로그래밍에서 여러 작업을 동시에 실행하여 전체적인 처리 속도를 향상시키는 기술을 말한다.</description>
    </item>
    <item>
      <title>동시성 제어 (Concurrency Control)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/</link>
      <pubDate>Wed, 02 Oct 2024 02:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/</guid>
      <description>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘</description>
    </item>
    <item>
      <title>Metric</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/metrics/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/metrics/</guid>
      <description>Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값</description>
    </item>
    <item>
      <title>Trace</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/tracing/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/tracing/</guid>
      <description>분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것</description>
    </item>
    <item>
      <title>Log</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/</link>
      <pubDate>Sat, 28 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/</guid>
      <description>Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.</description>
    </item>
    <item>
      <title>Client Server Architecture</title>
      <link>https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/styles/distributed/client-server-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/architecture-knowledge/architectural-styles-and-patterns/styles/distributed/client-server-architecture/</guid>
      <description>클라이언트-서버 아키텍처는 네트워크 환경에서 **클라이언트**와 **서버**가 역할을 분담하여 상호작용하는 모델이다. 클라이언트(Client)가 요청(Request)을 보내고, 서버(Server)가 요청을 처리하여 응답(Response)한다.</description>
    </item>
  </channel>
</rss>
