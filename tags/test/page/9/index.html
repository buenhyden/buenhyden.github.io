<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Test | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/test/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/test/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/test/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/test/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Test"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Test"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Test</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>회귀 테스트 (Regression Test)</h2></header><div class=entry-content><p>회귀 테스트 (Regression Test) 회귀 테스트는 소프트웨어의 변경이나 수정 후에 기존 기능이 여전히 올바르게 작동하는지 확인하는 테스트이다.
온라인 쇼핑몰의 회귀 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import unittest from shopping_mall import ShoppingCart, Product, User class ShoppingMallRegressionTest(unittest.TestCase): def setUp(self): """테스트 준비: 필요한 객체들을 초기화합니다.""" self.cart = ShoppingCart() self.user = User("test_user") self.product = Product("노트북", 1000000) def test_existing_cart_functionality(self): """장바구니 기능 회귀 테스트 장바구니 할인 기능이 추가된 후에도 기존 장바구니 기능들이 정상적으로 작동하는지 확인합니다. """ # 상품 추가 테스트 self.cart.add_item(self.product) self.assertEqual(len(self.cart.items), 1) # 상품 제거 테스트 self.cart.remove_item(self.product) self.assertEqual(len(self.cart.items), 0) # 금액 계산 테스트 self.cart.add_item(self.product, quantity=2) self.assertEqual(self.cart.total_price, 2000000) def test_new_discount_feature(self): """새로운 할인 기능 테스트 새로 추가된 할인 기능이 기존 가격 계산 로직을 망가뜨리지 않는지 확인합니다. """ # 기본 가격 계산 self.cart.add_item(self.product) base_price = self.cart.total_price # 할인 적용 self.cart.apply_discount(10) # 10% 할인 # 할인된 가격 확인 expected_price = base_price * 0.9 self.assertEqual(self.cart.total_price, expected_price) # 할인 제거 후 원래 가격으로 복원되는지 확인 self.cart.remove_discount() self.assertEqual(self.cart.total_price, base_price) 특징과 목적 회귀 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-30 14:28:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 회귀 테스트 (Regression Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/regression-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>사용성 테스트 (Usability Test)</h2></header><div class=entry-content><p>사용성 테스트 (Usability Test) 사용성 테스트는 제품이나 서비스를 실제 사용자가 사용해보면서 그 과정을 관찰하고 분석하는 테스트 방법이다.
이는 사용자가 제품을 얼마나 쉽고 효율적으로 사용할 수 있는지를 평가한다.
모바일 앱의 사용성 테스트 시나리오:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def run_shopping_app_test(): """쇼핑앱 사용성 테스트 시나리오""" test = UsabilityTest() # 테스트 작업 정의 test.add_task( "상품검색", "원하는 상품을 검색하고 찾기", "3번 이내의 클릭으로 원하는 상품 도달" ) test.add_task( "장바구니추가", "상품을 장바구니에 추가하기", "오류 없이 상품을 장바구니에 추가" ) test.add_task( "결제진행", "장바구니에서 결제 완료까지", "5분 이내 결제 완료" ) # 테스트 참가자의 수행 결과 기록 test.record_task_result("user1", "상품검색", { "time": 45, # 초 단위 "errors": 1, "satisfaction": 4 # 5점 만점 }) # 결과 분석 test.analyze_results() 특징과 목적 사용성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-30 14:25:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사용성 테스트 (Usability Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/usability-test/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Stubs</h2></header><div class=entry-content><p>Stubs Stubbing은 테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘
목적 의존성 격리: 실제 구현체로부터 테스트 대상을 분리하여 독립적인 테스트를 가능하게 합니다. 특정 시나리오 테스트: 다양한 상황에 대한 테스트를 용이하게 합니다. 미구현 코드 대체: 아직 개발되지 않은 부분을 임시로 대체할 수 있습니다. 테스트 속도 향상: 실제 리소스 접근 없이 빠른 테스트가 가능합니다. 특징 미리 정의된 응답(canned answer)을 제공합니다. 실제 코드의 동작을 단순화하여 모사합니다. 주로 상태 테스팅에 중점을 둡니다. 메서드 호출의 결과만 정의하며, 호출 여부는 검증하지 않습니다. 사용 사례 구현되지 않은 함수나 외부 라이브러리 함수를 사용할 때 복잡한 로직을 단순화하여 테스트하고자 할 때 특정 조건에서의 예외 상황을 테스트할 때 외부 의존성(예: 데이터베이스, 네트워크 요청)을 가진 코드를 테스트할 때 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from unittest.mock import Mock, patch import pytest from datetime import datetime # 테스트할 실제 클래스 class PaymentService: def __init__(self, payment_gateway): self.payment_gateway = payment_gateway def process_payment(self, amount): if amount &lt;= 0: raise ValueError("Amount must be positive") response = self.payment_gateway.charge(amount) if response['status'] == 'success': return True return False # 외부 결제 게이트웨이 클래스 (실제로는 외부 서비스) class PaymentGateway: def charge(self, amount): # 실제로는 외부 API를 호출하는 복잡한 로직 pass # Stub 예시 class PaymentGatewayStub: def charge(self, amount): # 항상 성공 응답을 반환하는 단순한 구현 return {'status': 'success', 'timestamp': datetime.now()} # 테스트 코드 def test_payment_service_with_stub(): # Stub 사용 gateway_stub = PaymentGatewayStub() payment_service = PaymentService(gateway_stub) assert payment_service.process_payment(100) == True Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // Jest를 사용한 테스트 예시 const { jest } = require('@jest/globals'); // 테스트할 실제 클래스 class UserService { constructor(database) { this.database = database; } async getUserById(id) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } return user; } async updateUserEmail(id, newEmail) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } user.email = newEmail; await this.database.updateUser(id, user); return user; } } // Stub 예시 class DatabaseStub { constructor() { this.users = new Map([ [1, { id: 1, name: 'John Doe', email: 'john@example.com' }], [2, { id: 2, name: 'Jane Doe', email: 'jane@example.com' }] ]); } async findUser(id) { return this.users.get(id); } async updateUser(id, userData) { this.users.set(id, userData); return userData; } } // 테스트 코드 describe('UserService', () => { // Stub을 사용한 테스트 describe('with stub', () => { const dbStub = new DatabaseStub(); const userService = new UserService(dbStub); test('should return user when exists', async () => { const user = await userService.getUserById(1); expect(user.name).toBe('John Doe'); }); test('should throw error when user not found', async () => { await expect(userService.getUserById(999)) .rejects .toThrow('User not found'); }); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-30 09:29:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stubs" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/stubs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mocks</h2></header><div class=entry-content><p>Mocks 소프트웨어 테스트에서 사용되는 중요한 기법으로, 실제 객체를 모방하는 가짜 객체를 만들어 테스트하는 방법
Mocking은 테스트하고자 하는 코드가 의존하는 부분을 가짜(mock)로 대체하는 기법으로, 단위 테스트를 작성할 때 특히 유용하다.
목적 외부 의존성 제어: 실제 외부 리소스에 의존하지 않고 테스트를 수행할 수 있게 합니다. 특정 시나리오 테스트: 예외 상황이나 복잡한 시나리오를 쉽게 재현할 수 있습니다. 테스트 속도 향상: 실제 리소스 접근 시간을 절약하여 테스트 실행 속도를 높입니다. 독립적인 테스트: 다른 컴포넌트의 구현 여부와 관계없이 테스트를 진행할 수 있습니다. 장점 빠른 테스트 속도: 외부 리소스 접근 시간을 절약합니다. 예외 시나리오 테스트 용이성: 특정 상황에서의 예외 처리를 쉽게 테스트할 수 있습니다. 외부 리소스 접근 회피: 실제 환경에 의존하지 않고 테스트할 수 있습니다. 복잡한 시나리오 테스트: 다양한 상태를 쉽게 재현할 수 있습니다. 단점 잠재적 부작용: 모킹된 동작과 실제 코드의 동작이 다를 수 있습니다. 모킹 오버헤드: 모킹 코드 작성과 설정에 추가 작업이 필요합니다. 모킹의 복잡성: 잘못된 모킹 설정은 테스트의 신뢰성을 떨어뜨릴 수 있습니다. 테스트의 일관성 문제: 모킹을 남용하면 테스트 코드와 실제 코드 간의 일관성이 떨어질 수 있습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from unittest.mock import Mock, patch import pytest from datetime import datetime # 테스트할 실제 클래스 class PaymentService: def __init__(self, payment_gateway): self.payment_gateway = payment_gateway def process_payment(self, amount): if amount &lt;= 0: raise ValueError("Amount must be positive") response = self.payment_gateway.charge(amount) if response['status'] == 'success': return True return False # 외부 결제 게이트웨이 클래스 (실제로는 외부 서비스) class PaymentGateway: def charge(self, amount): # 실제로는 외부 API를 호출하는 복잡한 로직 pass def test_payment_service_with_mock(): # Mock 객체 생성 mock_gateway = Mock() # Mock 동작 정의 mock_gateway.charge.return_value = {'status': 'success'} payment_service = PaymentService(mock_gateway) result = payment_service.process_payment(100) # 검증 assert result == True mock_gateway.charge.assert_called_once_with(100) # Mock을 사용한 다양한 시나리오 테스트 def test_payment_service_failed_payment(): mock_gateway = Mock() mock_gateway.charge.return_value = {'status': 'failed'} payment_service = PaymentService(mock_gateway) result = payment_service.process_payment(50) assert result == False mock_gateway.charge.assert_called_once() # Patch 데코레이터를 사용한 테스트 @patch('__main__.PaymentGateway') def test_payment_service_with_patch(mock_gateway_class): mock_gateway_instance = Mock() mock_gateway_class.return_value = mock_gateway_instance mock_gateway_instance.charge.return_value = {'status': 'success'} payment_service = PaymentService(PaymentGateway()) result = payment_service.process_payment(200) assert result == True mock_gateway_instance.charge.assert_called_once_with(200) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // Jest를 사용한 테스트 예시 const { jest } = require('@jest/globals'); // 테스트할 실제 클래스 class UserService { constructor(database) { this.database = database; } async getUserById(id) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } return user; } async updateUserEmail(id, newEmail) { const user = await this.database.findUser(id); if (!user) { throw new Error('User not found'); } user.email = newEmail; await this.database.updateUser(id, user); return user; } } // 테스트 코드 describe('UserService', () => { // Mock을 사용한 테스트 describe('with mock', () => { // Jest mock 생성 const mockDatabase = { findUser: jest.fn(), updateUser: jest.fn() }; const userService = new UserService(mockDatabase); beforeEach(() => { // 각 테스트 전에 mock 초기화 jest.clearAllMocks(); }); test('should call database with correct id', async () => { const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' }; mockDatabase.findUser.mockResolvedValue(mockUser); const user = await userService.getUserById(1); expect(mockDatabase.findUser).toHaveBeenCalledWith(1); expect(user).toEqual(mockUser); }); test('should update user email', async () => { const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' }; const updatedUser = { ...mockUser, email: 'new@example.com' }; mockDatabase.findUser.mockResolvedValue(mockUser); mockDatabase.updateUser.mockResolvedValue(updatedUser); const result = await userService.updateUserEmail(1, 'new@example.com'); expect(mockDatabase.findUser).toHaveBeenCalledWith(1); expect(mockDatabase.updateUser).toHaveBeenCalledWith(1, updatedUser); expect(result.email).toBe('new@example.com'); }); test('should handle database errors', async () => { mockDatabase.findUser.mockRejectedValue(new Error('Database error')); await expect(userService.getUserById(1)) .rejects .toThrow('Database error'); }); }); }); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-30 06:14:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mocks" href=https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/mocks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>호환성 테스트 (Compatibility Test)</h2></header><div class=entry-content><p>호환성 테스트 (Compatibility Test) 호환성 테스트는 소프트웨어가 다양한 하드웨어, 운영체제, 네트워크 환경 등에서 올바르게 작동하는지 확인하기 위해 수행되는 테스트이다.
특징과 목적 호환성 테스트의 주요 특징과 목적은 다음과 같다:
철저함: 다양한 환경에서 발생할 수 있는 문제를 찾아낸다. 확장성: 발견된 문제를 쉽게 재현하고 해결할 수 있어야 한다. 사용자 경험 보장: 모든 사용자가 비슷한 경험을 할 수 있도록 한다. 테스트 범위 호환성 테스트는 다음과 같은 범위를 포함한다:
하드웨어 호환성 소프트웨어 호환성 (운영체제, 브라우저 등) 네트워크 호환성 데이터베이스 호환성 수행 시점 호환성 테스트는 일반적으로 소프트웨어 개발의 후반부, 특히 알파 테스트와 베타 테스트 단계에서 수행된다.
...</p></div><footer class=entry-footer><span title='2024-11-30 03:27:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;472 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 호환성 테스트 (Compatibility Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/compatibility-test/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/test/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/test/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>