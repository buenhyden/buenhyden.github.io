<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Linear-Data-Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/non-linear-data-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/non-linear-data-structure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/non-linear-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/non-linear-data-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-Linear-Data-Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-Linear-Data-Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Non-Linear-Data-Structure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fenwick Tree</h2></header><div class=entry-content><p>Fenwick Tree (Binary Indexed Tree, BIT) Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.
1994년 Peter M. Fenwick에 의해 제안되었다.
데이터를 저장하고 조작하는 방식을 정의하며, 특정 연산을 효율적으로 수행할 수 있게 해줍니다.
https://en.wikipedia.org/wiki/Fenwick_tree#/media/File:16-node_Fenwick_tree.svg
일반적인 트리와 달리, 배열을 사용하여 이진 트리를 암시적으로 표현한다.
각 인덱스는 이진수 표현에서 마지막 1의 위치에 따라 관리하는 구간의 크기가 결정된다.
...</p></div><footer class=entry-footer><span title='2025-01-07 12:56:00 +0000 UTC'>January 7, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fenwick Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Segment Tree</h2></header><div class=entry-content><p>Segment Tree 세그먼트 트리는 구간 또는 범위에 대한 정보를 저장하고 관리하는 트리 형태의 자료구조이다. 데이터베이스, 파일 시스템, 네트워크 라우팅 등 다양한 응용 프로그램에서 사용되며, 효율적인 구간 쿼리와 업데이트 연산을 제공하는 특수한 데이터 구조이다.
https://www.geeksforgeeks.org/segment-tree-data-structure/
특징 완전 이진 트리 구조를 가진다. 각 노드는 배열의 특정 구간에 대한 정보를 저장한다. 리프 노드는 배열의 개별 원소를 나타낸다. 부모 노드는 자식 노드들의 정보를 결합한 값을 저장한다. 장점 구간 쿼리의 시간 복잡도가 O(log n)으로 매우 효율적이다. 데이터 업데이트 시 O(log n) 시간에 트리를 갱신할 수 있다. 동적인 상황에서도 효율적으로 작동한다. 단점 일반 배열에 비해 더 많은 메모리를 사용한다 (약 4n의 공간 복잡도). 구현이 상대적으로 복잡할 수 있다. 응용 데이터베이스 시스템의 범위 쿼리 최적화 컴퓨터 그래픽스의 렌더링 최적화 네트워크 라우팅 테이블 관리 금융 데이터 분석의 구간 통계 계산 동작 원리 트리 구축 (Build):
...</p></div><footer class=entry-footer><span title='2025-01-07 12:56:00 +0000 UTC'>January 7, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;861 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Segment Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Hash Map</h2></header><div class=entry-content><p>Concurrent Hash Map ConcurrentHashMap은 여러 스레드가 동시에 안전하게 접근할 수 있도록 설계된 HashMap의 동시성 버전이다.
이 자료구조는 멀티스레드 환경에서 높은 성능과 확장성을 제공하면서도 스레드 안전성을 보장한다.
Java의 동시성 컬렉션 중 하나로, 멀티스레드 환경에서 안전하게 사용할 수 있도록 설계된 Map 구현체이다.
Java를 제외한 프로그래밍 언어와 라이브러리에서도 동시성을 지원하기 위해 구현되어 있는 자료 구조이다.
특징 Thread-safe: 내부적으로 동기화 처리가 되어 있어 멀티스레드 환경에서 안전하다. 높은 동시성: 여러 스레드가 동시에 맵을 수정할 수 있으며, 읽기 작업은 락 없이 수행된다. 원자적 연산 지원: putIfAbsent(), replace(), remove() 등의 원자적 연산을 제공한다. 일관성 있는 반복자: 반복자가 생성된 시점의 맵 상태를 반영하며, ConcurrentModificationException을 발생시키지 않는다. 락 스트라이핑(Lock Striping): 맵을 여러 부분으로 나누어 각각 독립적으로 잠금을 걸어 동시성을 향상시킨다. Null 불허: 키와 값에 null을 허용하지 않는다. 이는 동시성 환경에서 null의 의미가 모호해질 수 있기 때문이다. 약한 일관성: 순간적으로 맵의 상태가 일관되지 않을 수 있지만, 최종적으로는 일관된 상태로 수렴한다. 구현 방식 ConcurrentHashMap은 다음과 같은 기술을 사용하여 구현된다:
...</p></div><footer class=entry-footer><span title='2025-01-06 13:21:00 +0000 UTC'>January 6, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;517 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Hash Map" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BSP Tree</h2></header><div class=entry-content><p>BSP Tree (Binary Space Partitioning Tree) BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것이다. 이 과정에서 생성되는 트리를 BSP 트리라고 한다.
https://www.researchgate.net/figure/Constructing-a-bsp-tree_fig1_238973971
특징 이진 트리 구조: 각 노드는 최대 두 개의 자식 노드를 가진다. 재귀적 분할: 공간을 계속해서 두 부분으로 나누어 표현한다. 볼록 집합: 분할된 각 공간은 볼록 집합(convex set)의 형태를 가진다. 계층적 구조: 공간을 계층적으로 표현할 수 있다. 장점 효율적인 렌더링: 3D 그래픽에서 렌더링 속도를 향상시킬 수 있다. 공간 분할: 복잡한 3D 공간을 효과적으로 표현할 수 있다. 충돌 감지: 게임이나 시뮬레이션에서 충돌 감지에 유용하다. 가시성 결정: 어떤 객체가 보이는지 빠르게 결정할 수 있다. 단점 전처리 시간: 초기 트리 구성에 많은 시간이 소요될 수 있다. 메모리 사용: 복잡한 공간의 경우 많은 메모리를 사용할 수 있다. 동적 환경에서의 한계: 자주 변하는 환경에서는 효율성이 떨어질 수 있다. 응용 3D 컴퓨터 그래픽스: 렌더링 최적화에 사용된다. 컴퓨터 게임: 특히 1인칭 슈팅 게임에서 널리 사용된다. CAD 시스템: 조립식 입체 기하학(CSG)에 활용된다. 로봇 공학: 충돌 감지 등에 사용된다. 동작 원리 분할 평면 선택: 공간을 분할할 평면을 선택한다. 공간 분할: 선택된 평면을 기준으로 공간을 두 부분으로 나눈다. 재귀적 분할: 각 부분에 대해 1, 2 과정을 반복한다. 종료 조건: 정해진 깊이에 도달하거나 더 이상 분할이 필요 없을 때 종료한다. 구성 요소 노드: 공간을 표현하는 기본 단위. 분할 평면: 각 노드에서 공간을 나누는 기준이 되는 평면. 왼쪽/오른쪽 자식 노드: 분할된 공간을 표현하는 하위 노드. 리프 노드: 더 이상 분할되지 않는 최종 공간을 나타내는 노드. 구현 방식 다음은 Python을 사용한 간단한 BSP Tree 구현 예시:
...</p></div><footer class=entry-footer><span title='2025-01-05 13:20:00 +0000 UTC'>January 5, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BSP Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>R-tree</h2></header><div class=entry-content><p>R-tree R-Tree는 다차원 공간 데이터를 효율적으로 저장하고 검색하기 위해 설계된 트리 기반의 데이터 구조로, 공간 인덱스 알고리즘이다.
2차원 이상의 공간 데이터를 인덱싱하고 검색하는 목적으로 사용된다. 이 구조는 점, 선, 면(다각형)과 같은 다차원 정보를 효율적으로 저장하고 관리한다.
https://www.geeksforgeeks.org/introduction-to-r-tree/
https://www.geeksforgeeks.org/introduction-to-r-tree/
특징 계층적 구조: R-Tree는 B-Tree와 유사한 계층적 구조를 가진다. MBR(Minimum Bounding Rectangle) 사용: 공간 객체를 포함하는 최소 크기의 사각형을 이용하여 데이터를 관리한다. 노드 분할: 각 노드는 최대 M개, 최소 m개의 엔트리를 포함할 수 있다. 동적 구조: 삽입과 삭제 연산을 통해 트리 구조를 동적으로 조정할 수 있다. 장점 효율적인 공간 검색: 복잡한 공간 데이터에 대해 빠른 검색이 가능하다. 다차원 데이터 처리: 2차원 이상의 공간 데이터를 효과적으로 다룰 수 있다. 범위 검색 최적화: 특정 영역 내의 객체를 효율적으로 찾을 수 있다. 단점 구현 복잡성: 구조가 복잡하여 구현과 관리가 어려울 수 있다. 오버랩 문제: 노드 간 MBR이 겹칠 수 있어 검색 성능이 저하될 수 있다. 불균형 가능성: 데이터 분포에 따라 트리가 불균형해질 수 있다. 응용 지리 정보 시스템(GIS): 지리 공간 데이터 관리 및 분석에 사용된다. 위치 기반 서비스(LBS): 사용자 위치 기반 정보 제공에 활용된다. 컴퓨터 그래픽스: 3D 모델링, 충돌 감지 등에 사용된다. 데이터베이스 시스템: 공간 데이터베이스에서 다차원 데이터 인덱싱에 활용된다. 동작 원리 삽입: 새로운 객체를 삽입할 때, 트리를 순회하며 가장 적합한 리프 노드를 찾아 삽입한다. 필요시 노드 분할이 발생한다. 검색: 루트 노드부터 시작하여 MBR이 겹치는 노드를 재귀적으로 탐색한다. 삭제: 객체를 삭제하고, 필요시 노드를 병합하거나 재분배한다. 구성 요소 노드: 각 노드는 MBR과 자식 노드 또는 실제 데이터에 대한 포인터를 포함한다. MBR: 각 노드가 포함하는 모든 객체를 감싸는 최소 크기의 사각형이다. 엔트리: 노드 내의 각 항목으로, MBR과 자식 노드 또는 실제 데이터에 대한 참조를 포함한다. 구현 방식 R-Tree의 기본적인 구현은 Python을 사용하여 다음과 같이 할 수 있다:
...</p></div><footer class=entry-footer><span title='2025-01-05 13:19:00 +0000 UTC'>January 5, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;457 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to R-tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/r-tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/non-linear-data-structure/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/non-linear-data-structure/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>