<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-Linear-Data-Structure | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/non-linear-data-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/non-linear-data-structure/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/non-linear-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/non-linear-data-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-Linear-Data-Structure"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-Linear-Data-Structure"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Non-Linear-Data-Structure</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Weighted Graphs</h2></header><div class=entry-content><p>Weighted Graphs 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-27 07:27:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Weighted Graphs" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/weighted-graphs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rope</h2></header><div class=entry-content><p>Rope Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조로, 각 리프 노드(끝 노드)는 문자열과 길이(“weight"라고도 함)를 저장하고, 트리의 상위 노드들은 왼쪽 서브트리의 모든 리프 노드 길이의 합을 저장한다.
https://www.geeksforgeeks.org/ropes-data-structure-fast-string-concatenation/
특징 트리 구조: Rope는 이진 트리 형태를 가진다. 분할 저장: 큰 문자열을 작은 조각으로 나누어 저장한다. 가중치: 각 노드는 왼쪽 서브트리의 문자열 길이를 저장한다. 불변성: 일반적으로 Rope의 노드들은 불변(immutable) 객체로 취급된다. 장점 효율적인 연산: 문자열 연결, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있다. 메모리 효율성: 대규모 문자열 조작 시 추가 메모리 사용이 적다. 지속성: 비파괴적 연산을 사용하면 여러 단계의 실행 취소를 쉽게 지원할 수 있다. 단점 복잡성: 구조가 복잡하여 구현과 관리가 어려울 수 있다. 오버헤드: 작은 문자열에 대해서는 일반 문자열보다 성능이 떨어질 수 있다. 메모리 사용: 부모 노드 저장을 위해 추가 메모리가 필요하다. 응용 텍스트 에디터: Sublime Text 등의 텍스트 에디터에서 대용량 텍스트 처리에 사용된다. 이메일 시스템: Gmail과 같은 이메일 시스템에서 메시지 처리에 활용된다. 프로그래밍 환경: Cedar 프로그래밍 환경에서 사용된다. 동작 원리 문자열 분할: 큰 문자열을 작은 조각으로 나누어 트리의 리프 노드에 저장한다. 트리 구성: 리프 노드들을 이진 트리 형태로 구성한다. 가중치 계산: 각 내부 노드는 왼쪽 서브트리의 문자열 길이 합을 저장한다. 연산 수행: 트리 구조를 활용하여 효율적인 문자열 연산을 수행한다. 구성 요소 리프 노드: 실제 문자열 조각과 그 길이를 저장한다. 내부 노드: 왼쪽 서브트리의 길이(가중치)를 저장한다. 루트 노드: 전체 Rope의 시작점이다. 링크: 노드 간의 연결을 나타낸다. 구현 방식 Rope의 기본적인 구현은 이진 트리를 기반으로 한다.
다음은 Python을 사용한 간단한 Rope 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-12-23 13:20:00 +0000 UTC'>December 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;446 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rope" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/rope/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AVL 트리 (AVL tree)</h2></header><div class=entry-content><p>AVL 트리 (AVL tree) AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리(self-balancing binary search tree)이다.
각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.
정렬된 정보의 빠른 저장과 검색을 위해 사용되는 자료구조이다.
https://en.wikipedia.org/wiki/AVL_tree
특징 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이(균형 인수)가 -1, 0, 1 중 하나이다. 트리의 높이는 항상 O(log N)을 유지한다 (N은 노드의 수). 자체 균형 기능으로 삽입, 삭제, 검색 연산의 시간 복잡도가 O(log N)으로 보장된다. 장점 검색, 삽입, 삭제 연산의 시간 복잡도가 O(log N)으로 보장된다. 트리의 균형을 유지하여 최악의 경우에도 효율적인 성능을 제공한다. 레드-블랙 트리에 비해 더 엄격한 균형을 유지하여 검색 작업에 더 효율적이다. 응용 데이터베이스 인덱싱 메모리 관리 시스템 파일 시스템 구현 맵(Map)과 셋(Set) 자료구조 구현 동작 원리 삽입: 새 노드를 일반 이진 검색 트리처럼 삽입한 후, 균형 인수를 확인하고 필요시 회전을 수행하여 균형을 유지한다. 일반적인 이진 탐색 트리처럼 새로운 노드를 삽입한다. 삽입 경로를 따라 올라가면서 각 노드의 높이를 갱신한다. 불균형이 발생한 경우(균형 인수의 절댓값이 2가 된 경우) 회전 연산을 수행한다. LL Case: 오른쪽 회전 RR Case: 왼쪽 회전 LR Case: 왼쪽-오른쪽 회전 RL Case: 오른쪽-왼쪽 회전 삭제: 노드를 제거한 후, 트리의 균형을 유지하기 위해 필요한 회전을 수행한다. 검색: 일반적인 이진 검색 트리와 동일한 방식으로 수행된다. 구성 요소 노드: 키 값, 왼쪽 자식 포인터, 오른쪽 자식 포인터, 높이 정보를 포함한다. 키(key): 데이터 값 높이(height): 해당 노드를 루트로 하는 서브트리의 높이 왼쪽 자식 포인터 오른쪽 자식 포인터 (선택적으로) 부모 노드 포인터 균형 인수(Balance Factor): 각 노드의 왼쪽과 오른쪽 서브트리의 높이 차이를 나타낸다. 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이 수식으로는 BF = height(left) - height(right) 이 값은 항상 -1, 0, 1 중 하나여야 합니다 회전 연산: 트리의 균형을 유지하기 위한 왼쪽 회전, 오른쪽 회전, 왼쪽-오른쪽 회전, 오른쪽-왼쪽 회전이 있다. 구현 방식 AVL 트리는 일반적으로 다음과 같은 구조로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-11-10 12:35:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;578 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AVL 트리 (AVL tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이진 검색 트리 (Binary Search Tree)</h2></header><div class=entry-content><p>이진 검색 트리 (Binary Search Tree) BST는 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용되는 특수한 이진 트리 구조이다.
데이터베이스, 검색 엔진, 파일 시스템 등 다양한 응용 프로그램에서 중요한 도구로 사용된다.
이진 검색 트리는 다음과 같은 속성을 가진 이진 트리이다:
각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값들만 포함된다. 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값들만 포함된다. 왼쪽과 오른쪽 서브트리도 각각 이진 검색 트리여야 한다. https://www.geeksforgeeks.org/introduction-to-binary-search-tree/?ref=lbp
...</p></div><footer class=entry-footer><span title='2024-11-10 12:34:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;662 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 트리 (Binary Search Tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-search-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>이진 트리 (Binary Tree)</h2></header><div class=entry-content><p>이진 트리 (Binary Tree) 이진 트리는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 데이터 구조로, 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용된다.
이 자식 노드들은 일반적으로 왼쪽 자식과 오른쪽 자식으로 불린다.
특징 각 노드는 최대 두 개의 자식을 가질 수 있다. 노드의 깊이는 루트 노드로부터 해당 노드까지의 간선 수이다. 트리의 높이는 루트에서 가장 먼 리프까지의 간선 수이다. 이진 트리의 리프 노드 수는 항상 두 자식을 가진 노드 수보다 1만큼 많다. 장점 효율적인 검색: 이진 검색 알고리즘을 사용할 수 있어 검색이 빠르다. 순서화된 순회: 중위, 전위, 후위 순회 등 다양한 순회 방법을 제공한다. 메모리 효율성: 다른 트리 구조에 비해 상대적으로 메모리 효율적이다. 구현 용이성: 이해하고 구현하기 쉬워 다양한 응용 분야에서 사용된다. 응용 데이터베이스 인덱싱 파일 시스템 구현 우선순위 큐 구현 심볼 테이블 관리 결정 트리 (의사결정 분석에 사용) 표현식 파싱 (컴파일러 설계) 네트워크 데이터 라우팅 동작 원리 검색: 루트에서 시작하여 찾고자 하는 값과 비교하며 왼쪽 또는 오른쪽으로 이동한다. 삽입: 적절한 위치를 찾아 새 노드를 추가한다. 삭제: 노드를 제거하고 트리의 속성을 유지하도록 재구성한다. 트리 순회(Tree Traversal) 전위 순회(Preorder): 노드 방문 -> 왼쪽 서브트리 -> 오른쪽 서브트리 중위 순회(Inorder): 왼쪽 서브트리 -> 노드 방문 -> 오른쪽 서브트리 후위 순회(Postorder): 왼쪽 서브트리 -> 오른쪽 서브트리 -> 노드 방문 레벨 순서 순회(Level-order): 각 레벨별로 왼쪽에서 오른쪽으로 순회 구성 요소 노드(Node): 데이터를 저장하는 기본 단위 데이터 필드: 실제 저장하는 값 왼쪽 자식 포인터: 왼쪽 자식 노드를 가리키는 참조 오른쪽 자식 포인터: 오른쪽 자식 노드를 가리키는 참조 루트: 트리의 최상위 노드. 리프: 자식이 없는 노드. 간선(Edge): 노드들을 연결하는 선 부모 노드와 자식 노드를 연결 방향성을 가짐 (부모에서 자식으로) 구현 방식 이진 트리는 일반적으로 연결된 노드를 사용하여 구현되지만, 배열을 사용하여 표현할 수도 있다.
...</p></div><footer class=entry-footer><span title='2024-11-10 07:05:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 트리 (Binary Tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/non-linear-data-structure/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/non-linear-data-structure/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>