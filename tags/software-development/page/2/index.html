<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software-Development | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/software-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/software-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/software-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/software-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software-Development"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software-Development"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>Software-Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Monitoring and Observability</h2></header><div class=entry-content><p>Monitoring and Observability 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monitoring and Observability" href=https://buenhyden.github.io/til/2024/09/28/monitoring-and-observability/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git 원격 저장소와 Branch</h2></header><div class=entry-content><p>Git의 원격 저장소와 Branch 원격 저장소와 협업 원격 저장소 기본 명령어 명령어 설명 사용 예시 git remote 원격 저장소 목록 조회 git remote git remote -v 상세 정보(URL) 조회 git remote -v git remote add 원격 저장소 추가 git remote add origin &lt;url> git remote rename 원격 저장소 이름 변경 git remote rename old new git remote remove 원격 저장소 삭제 git remote remove name 원격 저장소 목록 조회 git remote 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2971 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git 원격 저장소와 Branch" href=https://buenhyden.github.io/posts/devops/version-control-systems/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git의 고급 기능</h2></header><div class=entry-content><p>Git의 고급 기능 태그 프로젝트의 특정 시점을 표시하는 중요한 기능
릴리스 버전 관리나 중요한 커밋 지점을 식별하기 위해 사용된다.
두 가지 종류의 태그가 있으며 각각의 사용 목적과 특징이 다르다.
1 2 3 $ git tag v0.1 v1.3 태그의 종류 Lightweight 태그 특정 커밋에 대한 참조로 단순히 커밋에 이름을 부여하는 형태이다. 커밋 체크섬만을 저장한다. Annotated 태그 태그 생성자 정보, 날짜, 메시지 등 추가 메타데이터를 저장한다. Git 데이터베이스에 완전한 객체로 저장된다. 태그 생성하기 Lightweight 태그
Lightweight 태그를 만들 때는 -a, -s, -m 옵션을 사용하지 않는다.
git tag &lt;tagname> 1 git tag v1.0.0 Annotated 태그
tag 명령을 실행할 때 -a 옵션을 추가
-m 옵션으로 태그를 저장할 때 메시지를 함께 저장할 수 있다.
git tag -a &lt;tagname> -m "Message" 1 2 3 4 5 $ git tag -a v1.4 -m "my version 1.4" $ git tag v0.1 v1.3 v1.4 특정 커밋에 태그 생성 예전 커밋에 대해서도 태그할 수 있다. 커밋 히스토리는 아래와 같다고 가정한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3165 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git의 고급 기능" href=https://buenhyden.github.io/posts/devops/version-control-systems/git/git%EC%9D%98-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Github Actions</h2></header><div class=entry-content><p>Github Actions GitHub에서 제공하는 CI/CD 자동화 도구로, 코드 저장소에서 직접 소프트웨어 개발 워크플로우를 자동화할 수 있다.
주요 기능 자동화된 워크플로우: 코드 변경, 풀 리퀘스트 생성, 이슈 생성 등 다양한 이벤트에 반응하여 자동으로 워크플로우를 실행할 수 있습니다 CI/CD 파이프라인: 빌드, 테스트, 배포 과정을 자동화하여 지속적 통합 및 배포를 구현할 수 있습니다 다양한 환경 지원: Linux, Windows, macOS 가상 머신에서 워크플로우를 실행할 수 있으며, 자체 호스팅 러너도 지원합니다 재사용 가능한 액션: 복잡하지만 자주 반복되는 작업을 수행하는 사용자 지정 애플리케이션인 ‘액션’을 사용하여 워크플로우를 간소화할 수 있습니다 GitHub 통합: GitHub 저장소와 완벽하게 통합되어 있어 코드 관리와 자동화를 원활하게 연결할 수 있습니다 병렬 작업 실행: 여러 작업을 동시에 실행하여 효율성을 높일 수 있습니다 보안 및 액세스 제어: GitHub의 보안 기능과 통합되어 안전한 워크플로우 실행을 보장합니다 상세한 로깅 및 모니터링: 워크플로우 실행 상태와 결과를 쉽게 확인하고 문제를 진단할 수 있습니다 구성 요소 워크플로우(Workflow): 자동화된 전체 프로세스를 정의하는 가장 상위 개념입니다. YAML 파일로 작성되며 하나 이상의 작업을 포함합니다. 이벤트(Event): 워크플로우를 트리거하는 특정 활동입니다. 예를 들어 push, pull request, issue 생성 등이 있습니다. 작업(Job): 동일한 러너에서 실행되는 단계들의 집합입니다. 기본적으로 병렬로 실행되지만 순차적으로 실행되도록 설정할 수도 있습니다. 단계(Step): 작업 내에서 실행되는 개별 작업 단위입니다. 쉘 명령어를 실행하거나 액션을 사용할 수 있습니다. 액션(Action): 워크플로우에서 자주 반복되는 작업을 재사용 가능한 단위로 만든 것입니다. GitHub Marketplace에서 찾아 사용하거나 직접 만들 수 있습니다. 러너(Runner): 워크플로우 작업이 실행되는 서버입니다. GitHub에서 호스팅하는 러너를 사용하거나 자체 호스팅 러너를 설정할 수 있습니다.
서로 연결되어 GitHub Actions의 자동화된 CI/CD 파이프라인을 구성한다. 장점 자동화: 코드 빌드, 테스트, 배포 등의 워크플로우를 자동화하여 시간과 노력을 절약할 수 있습니다 GitHub와의 통합: GitHub 저장소와 완벽하게 통합되어 있어 개발 프로세스를 원활하게 관리할 수 있습니다 유연성과 사용자 정의: YAML 파일을 사용하여 워크플로우를 쉽게 구성하고 사용자 정의할 수 있습니다 광범위한 액션 생태계: GitHub Marketplace에서 다양한 사전 구축된 액션을 사용하거나 직접 만들 수 있습니다 실시간 피드백: 풀 리퀘스트와 커밋에 대한 워크플로우 상태를 즉시 확인할 수 있습니다 확장성: 다양한 규모의 프로젝트에 적용 가능하며, 여러 운영 체제와 환경에서 실행할 수 있습니다 비용 효율성: 공개 저장소에서는 무료로 사용할 수 있으며, 개인 저장소에서도 일정량의 무료 사용 시간을 제공합니다 커뮤니티 지원: 활발한 커뮤니티를 통해 다양한 액션과 지원을 받을 수 있습니다 단점 복잡한 워크플로우 구성: 복잡한 워크플로우를 설계하고 유지보수하는 것이 어려울 수 있습니다, 특히 초보자에게는 더욱 그렇습니다 리소스 제한: 실행 시간, 디스크 공간 등에 제한이 있어 리소스 집약적인 워크플로우에는 제약이 있을 수 있습니다 GitHub 의존성: GitHub 플랫폼에 강하게 의존하기 때문에, GitHub의 중단이나 장애가 CI/CD 워크플로우에 영향을 줄 수 있습니다 디버깅의 어려움: 워크플로우 실행 중 발생하는 문제를 디버깅하는 것이 어려울 수 있습니다 학습 곡선: YAML 문법과 CI/CD 개념에 익숙하지 않은 사용자에게는 상당한 학습 시간이 필요할 수 있습니다 실행 시간 제한: 각 작업은 최대 6시간까지만 실행할 수 있어, 매우 긴 작업에는 적합하지 않을 수 있습니다 API 요청 제한: 시간당 API 요청 횟수에 제한이 있어, 대규모 프로젝트에서는 문제가 될 수 있습니다 안정성 문제: 때때로 발생하는 중단이나 성능 저하로 인해 작업 시간을 잃을 수 있습니다 워크플로우 설정 방법 워크플로우 파일 생성:
프로젝트의 .github/workflows/ 디렉토리에 YAML 파일을 생성합니다. 이 파일에 워크플로우를 정의합니다. 워크플로우 정의:
YAML 파일에 원하는 자동화 작업을 정의합니다. 주요 구성 요소는 다음과 같습니다: 이벤트 트리거 설정 (예: push, pull request 등) 작업(jobs) 정의 실행 환경 지정 (예: ubuntu-latest) 단계(steps) 정의 커밋 및 푸시:
정의된 워크플로우 파일을 저장소에 커밋하고 푸시합니다. 실행 확인:
GitHub 저장소의 Actions 탭에서 워크플로우 실행 상태를 확인할 수 있습니다. 자주 사용하는 YAML 파일 예시 name: 워크플로우의 이름을 지정합니다. on: 워크플로우를 트리거하는 이벤트를 정의합니다. 여기서는 main 브랜치에 대한 push와 pull request 이벤트에 반응합니다. jobs: 실행할 작업들을 정의합니다. 여기서는 “build"라는 하나의 작업만 있습니다. runs-on: 작업을 실행할 환경을 지정합니다. 여기서는 최신 Ubuntu 환경을 사용합니다. steps: 작업 내에서 실행할 단계들을 정의합니다. 각 단계는 이름, 사용할 액션 또는 실행할 명령어를 포함합니다. uses: 미리 정의된 액션을 사용합니다. 예를 들어, actions/checkout@v2는 저장소의 코드를 체크아웃합니다. run: 직접 셸 명령어를 실행합니다. if: 조건부로 단계를 실행합니다. 여기서는 main 브랜치에 푸시된 경우에만 배포 단계를 실행합니다. env: 환경 변수를 설정합니다. 여기서는 비밀 값을 환경 변수로 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: CI/CD Pipeline on: push: branches: [ "main" ] pull_request: branches: [ "main" ] jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Repository uses: actions/checkout@v2 - name: Set up Node.js uses: actions/setup-node@v2 with: node-version: '14' - name: Install Dependencies run: npm install - name: Run Tests run: npm test - name: Deploy to Production if: github.ref == 'refs/heads/main' env: PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }} run: | echo "Deploying to production at $PRODUCTION_URL" # 프로덕션 환경에 배포하는 명령어 기본적인 Node.js 프로젝트 CI 워크플로우 여러 Node.js 버전에서 테스트 자동 의존성 설치 및 빌드 테스트 자동 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name: Node.js CI on: # 워크플로우 트리거 설정 push: branches: [ main ] pull_request: branches: [ main ] jobs: build: runs-on: ubuntu-latest # 실행 환경 설정 strategy: matrix: node-version: [14.x, 16.x, 18.x] # 테스트할 Node.js 버전들 steps: - uses: actions/checkout@v3 # 소스코드 체크아웃 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v3 with: node-version: ${{ matrix.node-version }} - run: npm ci # 의존성 설치 - run: npm run build # 빌드 - run: npm test # 테스트 실행 Docker 이미지 빌드 및 배포 워크플로우 Docker Hub 자동 인증 이미지 자동 빌드 및 푸시 보안 자격 증명 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 name: Docker Build and Push on: push: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Login to Docker Hub # Docker Hub 로그인 uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push # 이미지 빌드 및 푸시 uses: docker/build-push-action@v4 with: push: true tags: user/app:latest 자동화된 릴리스 생성 워크플로우 태그 기반 트리거 자동 릴리스 노트 생성 GitHub 릴리스 자동화 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name: Create Release on: push: tags: - 'v*' # v로 시작하는 모든 태그에 대해 실행 jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Create Release # GitHub 릴리스 생성 uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false 스케줄링된 작업 워크플로우 Cron 기반 실행 정기적인 유지보수 작업 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name: Scheduled Tasks on: schedule: - cron: '0 0 * * *' # 매일 자정에 실행 jobs: cleanup: runs-on: ubuntu-latest steps: - name: Cleanup old artifacts # 오래된 아티팩트 정리 uses: c-hive/gha-remove-artifacts@v1 with: age: '1 week' skip-recent: 5 PR 자동 리뷰 워크플로우 자동 코드 검사 테스트 실행 코드 커버리지 리포트 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name: PR Review on: pull_request: types: [opened, synchronize] jobs: review: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Run ESLint # ESLint 검사 run: | npm install npm run lint - name: Run tests # 테스트 실행 run: npm test - name: Code Coverage # 코드 커버리지 리포트 uses: codecov/codecov-action@v3 with: token: ${{ secrets.CODECOV_TOKEN }} 프라이빗 컨테이너 레지스트리를 사용하는 워크플로우 설정 방법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 name: Build and Push to Harbor Registry on: push: branches: [ main ] # 특정 태그에 대해서만 실행하고 싶다면 아래처럼 설정 # tags: # - 'v*' env: # Harbor 레지스트리 설정 REGISTRY: harbor.example.com # Harbor 레지스트리 주소 REPOSITORY: project-name/application # Harbor 프로젝트와 이미지명 IMAGE_TAG: ${{ github.sha }} # 이미지 태그 (커밋 해시 사용) jobs: build-and-push: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v3 # QEMU 설정 (다중 아키텍처 빌드시 필요) - name: Set up QEMU uses: docker/setup-qemu-action@v2 # Docker Buildx 설정 - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 # Harbor 레지스트리 로그인 - name: Login to Harbor uses: docker/login-action@v2 with: registry: ${{ env.REGISTRY }} username: ${{ secrets.HARBOR_USERNAME }} password: ${{ secrets.HARBOR_PASSWORD }} # 도커 메타데이터 설정 - name: Extract Docker metadata id: meta uses: docker/metadata-action@v4 with: images: ${{ env.REGISTRY }}/${{ env.REPOSITORY }} tags: | type=raw,value=${{ env.IMAGE_TAG }} type=raw,value=latest type=ref,event=branch type=ref,event=tag # 이미지 빌드 및 푸시 - name: Build and push Docker image uses: docker/build-push-action@v4 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} platforms: linux/amd64,linux/arm64 # 필요한 플랫폼 지정 cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.REPOSITORY }}:buildcache cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.REPOSITORY }}:buildcache,mode=max # 배포 결과 알림 (선택사항) - name: Notify deployment if: success() run: | echo "Image successfully built and pushed to Harbor:" echo "Registry: ${{ env.REGISTRY }}" echo "Repository: ${{ env.REPOSITORY }}" echo "Tags: ${{ steps.meta.outputs.tags }}" 주요 설정 사항 환경 변수 설정
...</p></div><footer class=entry-footer><span title='2024-09-28 03:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2157 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Github Actions" href=https://buenhyden.github.io/posts/devops/ci-and-cd/ci-and-cd-tools/github-actions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI</h2></header><div class=entry-content><p>Gitlab CI GitLab에 내장된 지속적 통합/배포 도구로, .gitlab-ci.yml 파일을 통해 파이프라인을 정의하고 관리
특징 통합성: GitLab 저장소와 긴밀하게 통합되어 있어 별도의 도구 없이 CI/CD 파이프라인을 구축할 수 있습니다. 유연성: YAML 파일을 통해 파이프라인을 구성할 수 있어 다양한 프로젝트 요구사항에 맞춤 설정이 가능합니다. 확장성: 다양한 Runner 유형을 지원하여 다양한 환경에서 작업을 실행할 수 있습니다. 가시성: 파이프라인 실행 상태와 결과를 GitLab 인터페이스에서 쉽게 확인할 수 있습니다. 기능 자동 빌드 및 테스트: 코드 변경 시 자동으로 빌드 및 테스트를 실행합니다. 환경 배포: 다양한 환경(개발, 스테이징, 프로덕션 등)에 자동으로 배포할 수 있습니다. 아티팩트 관리: 빌드 결과물을 저장하고 관리할 수 있습니다. 병렬 실행: 여러 작업을 동시에 실행하여 파이프라인 속도를 향상시킵니다. 환경 변수 관리: 민감한 정보를 안전하게 저장하고 사용할 수 있습니다. 구성요소 .gitlab-ci.yml: 파이프라인 구성 파일 Runners: 작업을 실행하는 에이전트 Jobs: 실행할 개별 작업 Stages: 작업의 실행 순서를 정의하는 단계 Pipeline: 전체 CI/CD 프로세스 장점 GitLab과의 긴밀한 통합 쉬운 설정과 사용 확장성과 유연성 무료로 사용 가능한 기능이 많음 단점 GitLab에 종속적 복잡한 워크플로우의 경우 설정이 복잡해질 수 있음 일부 고급 기능은 유료 버전에서만 사용 가능 설정 방법 프로젝트 루트에.gitlab-ci.yml 파일 생성 YAML 형식으로 파이프라인 구성 작성 변경사항을 커밋하고 푸시 GitLab에서 파이프라인 실행 확인 .gitlab-ci.yml 파일의 기본 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 stages: - build - test - deploy job1: stage: build script: - echo "Building the project..." job2: stage: test script: - echo "Running tests..." job3: stage: deploy script: - echo "Deploying to production..." 주요 구성 요소 stages: 파이프라인의 실행 단계를 정의합니다. 각 단계는 순차적으로 실행됩니다. jobs: 각 작업을 정의합니다. 작업은 특정 단계에 속하며, 실행할 스크립트를 포함합니다. script: 작업에서 실행할 명령어들을 정의합니다. image: 작업을 실행할 Docker 이미지를 지정합니다. artifacts: 작업 결과물을 저장하고 다른 작업에서 사용할 수 있게 합니다. cache: 작업 간에 공유할 파일이나 디렉토리를 지정합니다. 고급 구성 옵션 only/except: 특정 브랜치나 태그에서만 작업을 실행하거나 제외할 수 있습니다. variables: 파이프라인 전체 또는 특정 작업에서 사용할 변수를 정의합니다. before_script/after_script: 작업 실행 전후에 실행할 스크립트를 정의합니다. environment: 배포 환경을 지정합니다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 파이프라인 단계 정의 stages: - build - test - deploy # 캐시 설정: node_modules 폴더를 캐시하여 빌드 속도 향상 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build image: node:14 # Node.js 14 버전 이미지 사용 script: - npm install # 의존성 설치 - npm run build # 프로젝트 빌드 artifacts: paths: - dist/ # 빌드 결과물 저장 # 테스트 작업 정의 test: stage: test image: node:14 script: - npm install # 의존성 설치 - npm test # 테스트 실행 # 배포 작업 정의 deploy: stage: deploy image: alpine:latest script: - apk add --no-cache rsync openssh # 배포에 필요한 도구 설치 - mkdir -p ~/.ssh - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_SERVER_IP:/path/to/deployment/ only: - master # master 브랜치에 푸시될 때만 실행 stages: 파이프라인의 단계를 정의합니다. 여기서는 build, test, deploy 세 단계로 구성됩니다. cache: node_modules 폴더를 캐시하여 빌드 속도를 향상시킵니다. build 작업: stage: build로 빌드 단계에 할당합니다. Node.js 14 버전 이미지를 사용합니다. npm install로 의존성을 설치하고, npm run build로 프로젝트를 빌드합니다. artifacts를 사용하여 빌드 결과물을 저장합니다. test 작업: stage: test로 테스트 단계에 할당합니다. npm test 명령으로 테스트를 실행합니다. deploy 작업: stage: deploy로 배포 단계에 할당합니다. Alpine Linux 이미지를 사용하여 가벼운 환경을 구성합니다. SSH 키를 설정하고 rsync를 사용하여 빌드 결과물을 서버에 배포합니다. only: - master로 master 브랜치에 푸시될 때만 실행되도록 설정합니다. 기본 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # GitLab CI의 기본 설정 예시 image: node:16 # 기본 Docker 이미지 지정 # 파이프라인 스테이지 정의 stages: - build - test - deploy # 캐시 설정 - node_modules 디렉토리를 캐시 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build # 속한 스테이지 지정 script: - npm install # 의존성 설치 - npm run build # 빌드 실행 artifacts: # 빌드 결과물 저장 paths: - dist/ # 테스트 작업 정의 test: stage: test script: - npm run test # 테스트 실행 dependencies: # build 작업의 결과물 사용 - build # 배포 작업 정의 deploy: stage: deploy script: - echo "Deploying application…" - npm run deploy only: # main 브랜치에서만 실행 - main 고급 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 환경변수와 조건부 실행이 포함된 고급 설정 예시 variables: DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG # Docker 이미지 태그 정의 # 커스텀 도커 이미지 빌드 build_image: image: docker:20.10.16 services: - docker:20.10.16-dind # Docker-in-Docker 서비스 stage: build script: # Docker 레지스트리 로그인 - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Docker 이미지 빌드 및 푸시 - docker build -t $DOCKER_IMAGE . - docker push $DOCKER_IMAGE rules: - if: $CI_COMMIT_BRANCH == "main" # main 브랜치에서만 실행 when: always - when: never # 그 외의 경우 실행하지 않음 # 보안 스캔 작업 security_scan: image: security-scanner stage: test script: - scan-dependencies # 의존성 취약점 검사 - scan-code # 코드 보안 검사 allow_failure: true # 실패해도 파이프라인 계속 진행 # 스테이징 환경 배포 deploy_staging: stage: deploy environment: name: staging script: - deploy-to-kubernetes.sh --env staging rules: - if: $CI_COMMIT_BRANCH == "develop" 환경별 배포 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 환경별 배포 구성 예시 .deploy_template: &amp;deploy_template # 재사용 가능한 배포 템플릿 정의 script: - echo "Deploying to $CI_ENVIRONMENT_NAME" - kubectl apply -f k8s/$CI_ENVIRONMENT_NAME/ deploy_dev: &lt;&lt;: *deploy_template # 템플릿 상속 environment: name: development rules: - if: $CI_COMMIT_BRANCH == "develop" deploy_prod: &lt;&lt;: *deploy_template environment: name: production rules: - if: $CI_COMMIT_BRANCH == "main" when: manual # 수동 승인 후 배포 병렬 작업 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 병렬 테스트 실행 예시 test: parallel: 3 # 3개의 병렬 작업 생성 script: - npm run test -- --split=$CI_NODE_INDEX/$CI_NODE_TOTAL # 매트릭스 작업 정의 test_matrix: parallel: matrix: - NODE_VERSION: ["14", "16", "18"] DB_TYPE: ["mysql", "postgres"] script: - docker-compose run --rm -e NODE_VERSION=$NODE_VERSION -e DB_TYPE=$DB_TYPE test 캐시와 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 캐시와 아티팩트 관리 예시 build: cache: key: ${CI_COMMIT_REF_SLUG} # 브랜치별 캐시 키 paths: - node_modules/ - .npm/ policy: pull-push # 캐시 정책 설정 artifacts: paths: - dist/ # 빌드 결과물 - coverage/ # 테스트 커버리지 리포트 reports: junit: test-results.xml # 테스트 결과 리포트 coverage: coverage/lcov.info # 커버리지 리포트 expire_in: 1 week # 아티팩트 유효 기간 이러한 설정들은 프로젝트의 요구사항과 규모에 따라 적절히 조정하여 사용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1165 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gitlab CI" href=https://buenhyden.github.io/posts/devops/ci-and-cd/ci-and-cd-tools/gitlab-ci/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Concurrent Engineering Model</h2></header><div class=entry-content><p>동시공학 모델 (Concurrent Engineering Model) 소프트웨어 개발 프로세스를 최적화하고 효율성을 높이기 위한 접근 방식
특징 병렬 작업: 여러 개발 단계를 동시에 수행한다. 예를 들어, 설계와 구현, 테스트 등이 병렬적으로 진행된다. 팀 협업: 다양한 분야의 전문가들(영업, 마케팅, 설계, 구매, 생산, 품질관리 등)이 프로젝트 초기 단계부터 함께 참여한다. 조기 문제 해결: 제품 수명 주기 전체를 고려하여 초기 단계에서 잠재적 문제를 식별하고 해결한다. 통합된 환경: 모든 부문의 사람들이 함께 일할 수 있는 통합된 환경을 제공한다. 장점 시간과 비용 절감: 병렬 작업과 조기 문제 해결로 개발 시간과 비용을 줄일 수 있다 품질 향상: 다양한 전문가의 참여로 제품 품질이 향상된다 유연성: 변화하는 요구사항에 빠르게 대응할 수 있다 고객 만족도 증가: 고객의 요구사항을 초기 단계부터 반영할 수 있어 만족도가 높아진다 구현 요소 CAD/CAM 시스템: 설계와 생산 과정을 통합하는 데 중요한 역할 프로토타이핑: 초기 단계에서 제품의 프로토타입을 만들어 테스트 시뮬레이션: 제조 과정을 시뮬레이션하여 잠재적 문제를 예측 정보 공유 시스템: 팀 간의 효율적인 정보 공유를 위한 시스템을 구축 적합한 프로젝트 유형 복잡한 시스템 개발이나 빠르게 변화하는 시장 환경에서 효과적
...</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Engineering Model" href=https://buenhyden.github.io/posts/qa/sdlc/software-development-model/concurrent-engineering-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain-Driven Development</h2></header><div class=entry-content><p>도메인 주도 개발 (Domain-Driven Development, DDD) 복잡한 소프트웨어를 개발할 때 비즈니스 도메인을 중심으로 설계와 개발을 진행하는 방법론
도메인이란 소프트웨어가 해결하고자 하는 핵심 비즈니스 영역을 의미
주요 단계 전략적 설계(Strategic Design): 핵심 도메인 식별 바운디드 컨텍스트 정의 컨텍스트 맵 작성 전술적 설계(Tactical Design): 엔티티, 값 객체, 집합체 등의 도메인 모델 요소 설계 도메인 서비스 정의 리포지토리 및 팩토리 구현 구현 및 지속적 개선: 도메인 모델을 코드로 구현 지속적인 리팩토링과 모델 개선 특징 도메인 중심 접근: DDD는 비즈니스 도메인을 소프트웨어 설계의 핵심으로 삼습니다. 유비쿼터스 언어: 개발자와 도메인 전문가 간의 공통 언어를 사용하여 의사소통을 개선합니다. 바운디드 컨텍스트: 도메인 모델의 적용 범위를 명확히 정의합니다. 모델 주도 설계: 도메인 모델을 중심으로 소프트웨어를 설계합니다. 장점 비즈니스 목표와의 연계: 소프트웨어가 실제 비즈니스 요구사항을 더 잘 반영합니다. 복잡성 관리: 큰 시스템을 관리 가능한 바운디드 컨텍스트로 나눕니다. 유지보수성 향상: 도메인 모델이 코드에 직접 반영되어 유지보수가 용이합니다. 협업 개선: 도메인 전문가와 개발자 간의 의사소통이 향상됩니다. 단점 초기 학습 곡선: DDD 개념과 실践에 익숙해지는 데 시간이 필요합니다. 복잡한 도메인에서의 어려움: 매우 복잡한 도메인에서는 모델링이 어려울 수 있습니다. 초기 개발 속도 저하: 도메인 모델링에 시간이 소요되어 초기 개발 속도가 느려질 수 있습니다. 핵심 요소 엔티티(Entity): 고유한 식별자를 가지는 도메인 객체. 값 객체(Value Object): 속성만으로 정의되는 불변 객체. 집합체(Aggregate): 관련된 객체들의 집합. 도메인 서비스(Domain Service): 특정 엔티티에 속하지 않는 도메인 로직. 리포지토리(Repository): 도메인 객체의 저장소. 팩토리(Factory): 복잡한 객체의 생성을 담당. 적합한 프로젝트 유형 복잡한 비즈니스 로직을 가진 프로젝트: DDD는 복잡한 도메인을 효과적으로 모델링할 수 있습니다. 장기적인 유지보수가 필요한 프로젝트: DDD는 코드의 유지보수성을 향상시킵니다. 도메인 전문가와의 긴밀한 협업이 필요한 프로젝트: DDD는 도메인 전문가와 개발자 간의 협업을 강화합니다. 마이크로서비스 아키텍처를 사용하는 프로젝트: DDD의 바운디드 컨텍스트 개념은 마이크로서비스 설계에 적합합니다. 비즈니스 규칙이 자주 변경되는 프로젝트: DDD는 변화하는 비즈니스 요구사항에 유연하게 대응할 수 있습니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;280 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-Driven Development" href=https://buenhyden.github.io/posts/qa/sdlc/software-development-model/domain-driven-development/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Formal Methods Model</h2></header><div class=entry-content><p>포멀 메소드 모델 (Formal Methods Model) 소프트웨어 개발에서 수학적 기법을 사용하여 시스템을 명세, 개발, 분석 및 검증하는 엄격한 접근 방식
소프트웨어의 정확성, 신뢰성 및 안전성을 보장하는 데 중점을 둔다.
특징 수학적 기반: 집합론, 논리학, 대수학 등의 수학적 기법을 사용 명확성과 정확성: 모호함을 제거하고 요구사항을 정확하게 명세 검증 가능성: 수학적 증명을 통해 시스템의 특성을 검증할 수 있다 추상화: 복잡한 시스템을 추상적으로 표현하여 이해와 분석을 용이하게 한다. 주요 기법 명세 언어: Z 표기법, B 메소드, Event-B 등의 형식적 명세 언어를 사용한다. 정리 증명: Coq, Isabelle 등의 도구를 사용하여 시스템 속성을 수학적으로 증명한다. 모델 검사: SPIN과 같은 도구를 사용하여 시스템의 모든 가능한 상태를 검사한다. 추상 해석: Frama-C와 같은 도구를 사용하여 프로그램의 런타임 오류 부재 등을 검증한다. 단점 높은 전문성 요구: 수학적 지식과 형식적 방법에 대한 이해가 필요하다. 시간과 비용: 초기 개발 단계에서 추가적인 노력과 비용이 필요할 수 있다 규모의 한계: 대규모 시스템에 적용하기 어려울 수 있다 적합한 프로젝트 유형 안전 중요 시스템, 보안 중요 시스템, 그리고 고신뢰성이 요구되는 소프트웨어 개발에 적합
...</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;161 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Formal Methods Model" href=https://buenhyden.github.io/posts/qa/sdlc/software-development-model/formal-methods-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Incremental Model</h2></header><div class=entry-content><p>증분 모델 (Incremental Model) 전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식. 각 증분은 완전한 기능을 갖춘 소프트웨어의 일부분으로, 사용자에게 점진적으로 제공
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 800, 'height': 600, 'diagramPadding': 15}}}%% graph TD %% 시작점 Start([프로젝트 시작]) --> Initial[초기 요구사항 분석] %% 증분 1: 핵심 기능 subgraph Inc1 [증분 1: 핵심 기능] R1[요구분석] --> D1[설계] D1 --> I1[구현] I1 --> T1[테스트] T1 --> V1[검증] end %% 증분 2: 확장 기능 subgraph Inc2 [증분 2: 확장 기능] R2[요구분석] --> D2[설계] D2 --> I2[구현] I2 --> T2[테스트] T2 --> V2[검증] end %% 증분 3: 최종 기능 subgraph Inc3 [증분 3: 최종 기능] R3[요구분석] --> D3[설계] D3 --> I3[구현] I3 --> T3[테스트] T3 --> V3[검증] end %% 증분 간 연결 Initial --> Inc1 V1 --> Inc2 V2 --> Inc3 V3 --> End([프로젝트 완료]) %% 산출물 연결 V1 -.제품 릴리즈 1.-> Rel1[동작하는 핵심 시스템] V2 -.제품 릴리즈 2.-> Rel2[확장된 시스템] V3 -.최종 릴리즈.-> Rel3[완성된 시스템] %% 피드백 루프 Rel1 -.피드백.-> R2 Rel2 -.피드백.-> R3 %% 스타일 정의 classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px classDef phase fill:#e1f5fe,stroke:#01579b,stroke-width:1px classDef milestone fill:#e8f5e9,stroke:#2e7d32,stroke-width:1px classDef release fill:#fff3e0,stroke:#e65100,stroke-width:1px class Start,End,Initial milestone class R1,D1,I1,T1,V1,R2,D2,I2,T2,V2,R3,D3,I3,T3,V3 phase class Rel1,Rel2,Rel3 release style Inc1 fill:#f0f4f8,stroke:#666,stroke-width:1px style Inc2 fill:#e1f5fe,stroke:#666,stroke-width:1px style Inc3 fill:#e8f5e9,stroke:#666,stroke-width:1px 주요 단계 요구사항 분석: 현재 증분에 포함될 기능을 정의. 설계: 시스템 아키텍처와 상세 설계를 수행. 구현: 실제 코드를 작성. 테스트: 구현된 기능을 테스트하고 버그를 수정. 통합 및 배포: 새로운 증분을 기존 시스템과 통합하고 사용자에게 제공. 특징 단계적 개발: 전체 시스템을 여러 개의 증분으로 나누어 개발. 순차적 제공: 각 증분을 완성할 때마다 사용자에게 제공. 기능 우선순위: 중요도나 우선순위에 따라 증분을 계획. 반복적 프로세스: 각 증분마다 요구사항 분석부터 테스트까지의 과정을 반복. 점진적 기능 확장: 각 증분마다 새로운 기능이 추가되거나 기존 기능이 개선. 장점 조기 제품 출시: 첫 번째 증분부터 사용 가능한 제품을 제공할 수 있다. 유연한 변경 관리: 각 증분 사이에 요구사항 변경을 반영할 수 있다. 위험 감소: 중요한 기능을 먼저 개발하여 주요 위험을 조기에 해결할 수 있다. 사용자 피드백 활용: 각 증분 후 사용자 피드백을 받아 다음 증분에 반영할 수 있다. 병렬 개발 가능: 여러 팀이 동시에 다른 증분을 개발할 수 있다. 단점 전체 아키텍처 설계 필요: 초기에 전체 시스템의 아키텍처를 설계해야 한다. 인터페이스 관리 복잡성: 증분 간 인터페이스 관리가 복잡할 수 있다. 문서화 부담: 각 증분마다 문서화가 필요하여 작업량이 증가할 수 있다. 전체 비용 증가: 여러 번의 통합과 테스트로 인해 전체 비용이 증가할 수 있다. 적합한 프로젝트 유형 주요 요구사항은 명확하지만 세부사항은 변경될 수 있는 프로젝트 빠른 시장 출시가 필요한 프로젝트 새로운 기술이나 기능을 점진적으로 도입하고자 할 때 자금이나 인력 등의 자원이 제한적인 경우 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Incremental Model" href=https://buenhyden.github.io/posts/qa/sdlc/software-development-model/incremental-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>행동 주도 개발 (Behavior-Driven Development, BDD)</h2></header><div class=entry-content><p>행동 주도 개발 (Behavior-Driven Development, BDD) 테스트 주도 개발(TDD)에서 파생된 소프트웨어 개발 방법론으로, 사용자의 행동과 비즈니스 가치에 초점을 맞춥니다.
‘무엇을 테스트할 것인가’가 아닌 ‘시스템이 어떻게 행동해야 하는가’에 초점을 맞춘다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 Feature: 사용자 로그인 As a 등록된 사용자 I want to 시스템에 로그인하다 So that 나의 개인 정보에 접근할 수 있다 Scenario: 올바른 인증 정보로 로그인 Given 사용자가 로그인 페이지에 있다 When 올바른 이메일과 비밀번호를 입력한다 Then 시스템은 사용자를 대시보드로 리다이렉트한다 Scenario: 잘못된 비밀번호로 로그인 시도 Given 사용자가 로그인 페이지에 있다 When 올바른 이메일과 잘못된 비밀번호를 입력한다 Then 시스템은 "잘못된 인증 정보입니다" 메시지를 표시한다 주요 단계 Discovery: 사용자 스토리에서 구체적인 예제를 도출하는 협업 단계입니다. Formulation: 도출된 예제를 구조화된 형식(Given-When-Then)으로 작성합니다. Automation: 작성된 시나리오를 자동화된 테스트로 구현합니다. 특징 비즈니스 중심 접근: BDD는 비즈니스 요구사항을 중심으로 개발을 진행합니다. 공통 언어 사용: 개발자, 테스터, 비즈니스 이해관계자 모두가 이해할 수 있는 자연어로 요구사항을 표현합니다. 예제 기반 명세: 구체적인 시나리오와 예제를 통해 요구사항을 명확히 합니다. 자동화된 테스트: 명세를 자동화된 테스트로 변환하여 지속적인 검증을 가능하게 합니다. 장점 의사소통 개선: 비즈니스와 기술 팀 간의 이해도를 높입니다. 명확한 요구사항: 구체적인 예제를 통해 요구사항을 명확히 합니다. 품질 향상: 초기 단계부터 테스트를 고려하여 버그를 줄입니다. 문서화 효과: 테스트 자체가 살아있는 문서 역할을 합니다. 유지보수성 향상: 테스트가 요구사항을 반영하므로 변경 사항 추적이 용이합니다. 단점 초기 학습 곡선: 팀원들이 BDD 방식에 익숙해지는 데 시간이 필요합니다. 추가 시간 소요: 시나리오 작성과 합의 과정에 추가 시간이 필요할 수 있습니다. 도구 제한: BDD를 지원하는 도구가 상대적으로 적을 수 있습니다. 핵심 요소 Given-When-Then 구조: 시나리오를 구조화하는 기본 형식입니다. BDD 프레임워크: Cucumber, SpecFlow, JBehave, Behave 등의 도구를 사용합니다. 자연어 처리: 비즈니스 언어를 코드로 변환하는 기능이 필요합니다. 적합한 프로젝트 유형 복잡한 비즈니스 로직을 가진 프로젝트: 요구사항을 명확히 정의하고 검증하는 데 효과적입니다. 장기 유지보수가 필요한 프로젝트: 살아있는 문서로서의 테스트가 유지보수에 도움이 됩니다. 애자일 방법론을 사용하는 프로젝트: BDD는 애자일의 반복적이고 협력적인 특성과 잘 맞습니다. 도메인 주도 설계(DDD)를 적용하는 프로젝트: BDD는 DDD와 잘 어울리며, 특히 클린 아키텍처를 사용하는 안드로이드 프로젝트에 적합합니다. 품질이 중요한 미션 크리티컬 시스템: BDD는 높은 신뢰성이 요구되는 시스템에서 버그를 줄이고 품질을 향상시키는 데 도움이 됩니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 00:49:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;342 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 행동 주도 개발 (Behavior-Driven Development, BDD)" href=https://buenhyden.github.io/posts/qa/sdlc/software-development-model/behavior-driven-development/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/software-development/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/software-development/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>