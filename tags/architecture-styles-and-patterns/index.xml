<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture-Styles-and-Patterns on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/tags/architecture-styles-and-patterns/</link>
    <description>Recent content in Architecture-Styles-and-Patterns on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.148.1</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Jul 2025 10:14:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/tags/architecture-styles-and-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Event-Driven Pattern vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/event-driven-pattern-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/event-driven-pattern-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</guid>
      <description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description>
    </item>
    <item>
      <title>Data Mesh Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/data-mesh-architecture/</link>
      <pubDate>Sun, 06 Jul 2025 10:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/data-mesh-architecture/</guid>
      <description>Data Mesh Architecture 는 도메인 중심의 탈중앙화된 데이터 관리 방식으로, 각 비즈니스 도메인이 자체 데이터를 제품으로 취급하며 소유권을 갖는 아키텍처이다. 셀프서비스 인프라와 연합 거버넌스를 통해 확장성과 민첩성을 제공하며, 전통적인 중앙집중형 데이터 플랫폼의 한계를 극복한다.</description>
    </item>
    <item>
      <title>Kappa Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/kappa-architecture/</link>
      <pubDate>Sun, 06 Jul 2025 10:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/kappa-architecture/</guid>
      <description>Kappa 아키텍처는 배치와 스트림 분리 없이 &amp;#34;모든 데이터를 스트림으로 처리&amp;#34; 하는 단일 레이어 방식이다. 단순성, 코드 통일성, 실시간 응답성을 확보하고 이벤트 재처리 방식으로 유연하게 대응하지만, 이력 분석 및 리플레이 처리 비용 등의 trade-off 가 존재한다.</description>
    </item>
    <item>
      <title>Lakehouse Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/lakehouse-architecture/</link>
      <pubDate>Sun, 06 Jul 2025 10:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/lakehouse-architecture/</guid>
      <description>Lakehouse Architecture는 데이터 레이크의 유연성과 비용 효율성을 데이터 웨어하우스의 성능 및 거버넌스 기능과 결합한 차세대 데이터 관리 아키텍처이다. 오픈 포맷 (Parquet, Delta Lake) 을 기반으로 구조화 및 비구조화 데이터를 단일 플랫폼에서 통합 관리하며, ACID 트랜잭션과 스키마 진화를 지원하여 실시간 분석과 머신러닝을 가능하게 한다.</description>
    </item>
    <item>
      <title>Lambda Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/lambda-architecture/</link>
      <pubDate>Sun, 06 Jul 2025 10:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/lambda-architecture/</guid>
      <description>Lambda Architecture 는 배치 처리 (Batch Processing) 와 실시간 스트림 처리 (Real-time Stream Processing) 를 결합하여 대용량 데이터를 효과적으로 처리하는 하이브리드 아키텍처 패턴이다. 배치 레이어 (Batch Layer), 스피드 레이어 (Speed Layer), 서빙 레이어 (Serving Layer) 세 계층으로 구성되어 높은 처리량과 낮은 지연시간을 동시에 제공한다.</description>
    </item>
    <item>
      <title>Multi-Cloud Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/cloud-native/multi-cloud-architecture/</link>
      <pubDate>Sun, 06 Jul 2025 02:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/cloud-native/multi-cloud-architecture/</guid>
      <description>멀티클라우드 아키텍처 (Multi-Cloud Architecture) 는 둘 이상의 퍼블릭 클라우드 제공자를 활용해 애플리케이션이나 인프라를 분산 배치하는 전략이다. 이를 통해 유연성, 가용성, 비용 최적화, 벤더 종속성 해소, 규제 준수, 혁신 가속 등 다양한 이점을 얻을 수 있으며, 복잡한 관리와 보안, 네트워크, 데이터 일관성 등 도전 과제가 동반된다.</description>
    </item>
    <item>
      <title>Data-Centric Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/</link>
      <pubDate>Sun, 22 Jun 2025 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/data-centric/</guid>
      <description>Data-Centric Architecture 는 데이터가 시스템 설계와 운영의 중심에 위치하는 아키텍처 스타일로, 데이터의 일관성, 접근성, 관리 효율성을 극대화하여 데이터 기반 의사결정과 신속한 서비스 제공을 지원한다.</description>
    </item>
    <item>
      <title>Architecture Styles and Patterns</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/</link>
      <pubDate>Sat, 14 Jun 2025 07:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/</guid>
      <description>Architecture Styles and Patterns은 시스템의 고수준 구조를 정의하고 컴포넌트 간 상호작용을 조직화하는 재사용 가능한 설계 솔루션이다. Architecture Style 은 시스템 전체 구조와 상호작용 원칙을 정의하며, Architecture Pattern 은 특정 구조적 문제에 대한 재사용 가능한 해결책을 제공한다. 다양한 패턴이 존재하며, 각각 특정 문제를 해결하고 확장성, 유지보수성, 테스트 용이성을 향상시킨다.</description>
    </item>
    <item>
      <title>Load Shifting vs. Load Balancing</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/load-shifting-vs-load-balancing/</link>
      <pubDate>Fri, 04 Apr 2025 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/load-shifting-vs-load-balancing/</guid>
      <description>로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.</description>
    </item>
    <item>
      <title>Load shifting vs. autoscaling</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/load-shifting-vs-autoscaling/</link>
      <pubDate>Wed, 02 Apr 2025 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/load-shifting-vs-autoscaling/</guid>
      <description>**Load Shifting**과 **Autoscaling**은 백엔드 시스템에서 리소스를 효율적으로 관리하기 위한 두 가지 전략이다</description>
    </item>
    <item>
      <title>Load Shifting</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/load-shifting/</link>
      <pubDate>Tue, 01 Apr 2025 15:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/load-shifting/</guid>
      <description>로드 시프팅은 시스템 부하를 효율적으로 관리하는 전략으로, 피크 시간대의 작업 부하를 비피크 시간대로 이동시켜 자원 활용을 최적화하는 방법이다.</description>
    </item>
    <item>
      <title>Throttling</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/throttling/</link>
      <pubDate>Sun, 09 Mar 2025 16:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/throttling/</guid>
      <description>Throttling은 트래픽이 과도하게 몰릴 때 시스템이 완전히 중단되거나 요청을 거부하는 대신, 요청 처리 속도를 늦추거나 대기열에 넣어 점진적으로 처리하는 방식이다.</description>
    </item>
    <item>
      <title>Rate Limiting vs. Throttling</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/rate-limiting-vs-throttling/</link>
      <pubDate>Tue, 25 Feb 2025 13:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/comparative/rate-limiting-vs-throttling/</guid>
      <description>Rate Limiting은 특정 시간 프레임 내에 클라이언트가 API에 보낼 수 있는 요청 수를 제한하는 기술이며 Throttling은 요청 속도를 조절하여 제한에 도달했을 때 요청을 지연시키거나 대기열에 넣는다.</description>
    </item>
    <item>
      <title>Replication</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/replication/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/replication/</guid>
      <description>복제 (Replication) 는 데이터나 서비스의 사본을 여러 노드나 시스템에 분산 저장하는 기법으로, 시스템의 가용성, 내결함성, 확장성을 향상시킨다. 주로 마스터 - 슬레이브, 다중 마스터, 액티브 - 액티브와 같은 아키텍처로 구현되며, 동기식 또는 비동기식 복제 방식을 사용한다. CAP 이론에 따라 일관성과 가용성 사이의 균형을 고려해 설계된다.</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/rate-limiting/</link>
      <pubDate>Fri, 14 Feb 2025 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/rate-limiting/</guid>
      <description>Rate Limiting은 특정 시간 간격 동안 API에 대한 요청 수를 제한하는 기술이다. 쉽게 말해, 사용자나 클라이언트가 특정 시간 동안 보낼 수 있는 요청의 횟수에 상한선을 두는 것이다.</description>
    </item>
    <item>
      <title>Microservices Architecture</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/cloud-native/microservices-architecture/</link>
      <pubDate>Sat, 01 Feb 2025 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/cloud-native/microservices-architecture/</guid>
      <description>마이크로서비스 아키텍처는 하나의 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 아키텍처 스타일이다. 각 서비스는 특정 비즈니스 기능을 담당하며, API 를 통해 통신하고, 자체 데이터베이스를 보유한다. 확장성, 유연성, 기술적 다양성을 제공하여 현대 클라우드 네이티브 애플리케이션 개발의 핵심 방식으로 자리잡았다.</description>
    </item>
    <item>
      <title>Ambassador</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/deployment-and-scalability-patterns/ambassador/</link>
      <pubDate>Tue, 19 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/deployment-and-scalability-patterns/ambassador/</guid>
      <description>Ambassador Pattern은 클라이언트와 마이크로서비스 사이에 별도의 서비스(Ambassador)를 두어 통신을 관리하는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/rate-limiting/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/rate-limiting/rate-limiting/</guid>
      <description>클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.</description>
    </item>
    <item>
      <title>Consumer-side contract test</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-side-contract-test/</link>
      <pubDate>Mon, 18 Nov 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-side-contract-test/</guid>
      <description>테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.</description>
    </item>
    <item>
      <title>Consumer-Driven Contract Testing</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-driven-contract-testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/consumer-driven-contract-testing/</guid>
      <description>서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법</description>
    </item>
    <item>
      <title>Service Component Test</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/service-component-test/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-patterns-and-strategies/service-component-test/</guid>
      <description>개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/specialized-patterns/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/specialized-patterns/anti-corruption-layer/</guid>
      <description>이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.</description>
    </item>
    <item>
      <title>API Composition</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/api-composition-strategies/api-composition/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/api-composition-strategies/api-composition/</guid>
      <description>이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/cqrs/</guid>
      <description>CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/event-sourcing/</guid>
      <description>이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Backend for Frontend Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/integration-patterns/backend-for-frontend/</link>
      <pubDate>Thu, 14 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/integration-patterns/backend-for-frontend/</guid>
      <description>Backend for Frontend 아키텍처는 다양한 프론트엔드의 요구사항에 맞춤화된 백엔드 서비스를 제공하여 사용자 경험을 최적화하고, 보안성과 개발 효율성을 향상시키는 설계 패턴이다.</description>
    </item>
    <item>
      <title>API Gateway Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/integration-patterns/api-gateway-pattern/</link>
      <pubDate>Thu, 14 Nov 2024 01:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/integration-patterns/api-gateway-pattern/</guid>
      <description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/deployment-and-scalability-patterns/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/deployment-and-scalability-patterns/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Database per Service Pattern</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/shared-database/</guid>
      <description>여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다</description>
    </item>
    <item>
      <title>Idempotent Operations</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/idempotency/</link>
      <pubDate>Wed, 09 Oct 2024 02:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management-patterns/idempotency/</guid>
      <description>멱등 연산 (Idempotent Operation) 은 동일한 입력으로 여러 번 수행하더라도 결과가 첫 번째 수행한 것과 동일한 특성을 가진 연산이다. 분산 시스템, REST API, 데이터베이스 등에서 중요하게 활용되며, 시스템의 신뢰성과 일관성을 보장하는 핵심 원칙이다. 네트워크 오류나 중복 요청 상황에서도 안전하게 작업을 수행할 수 있게 해주는 설계 패턴으로 현대 시스템 아키텍처에서 필수적인 개념이다.</description>
    </item>
    <item>
      <title>Master-Slave</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/replication/replication-model/master-slave/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-scalability-patterns/replication/replication-model/master-slave/</guid>
      <description>하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다</description>
    </item>
  </channel>
</rss>
