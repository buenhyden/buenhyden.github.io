<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API-Design | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/api-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/api-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/api-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/api-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API-Design"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API-Design"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>API-Design</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Contract Testing</h2></header><div class=entry-content><p>Contract Testing 계약 테스트(Contract Testing)는 서비스 간 상호작용이 명시된 계약을 준수하는지 확인하는 테스트 방법론이다. 현대적인 소프트웨어 아키텍처, 특히 마이크로서비스 환경에서 매우 중요한 역할을 한다.
계약의 정의 API 계약은 서비스 제공자(Provider)와 소비자(Consumer) 간의 “약속"으로 볼 수 있다.
이 계약은 다음과 같은 요소를 포함한다:
API 엔드포인트 및 경로 요청 및 응답 형식(JSON, XML 등) 데이터 구조 및 필드 정의 상태 코드 및 오류 처리 방식 인증 및 권한 부여 요구사항 계약 테스트의 필요성 마이크로서비스 아키텍처에서는 수십, 수백 개의 서비스가 서로 상호작용한다.
...</p></div><footer class=entry-footer><span title='2025-03-10 02:52:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Contract Testing" href=https://buenhyden.github.io/posts/backend/api-design/api-lifecycle-management/testing/contract-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Load Testing</h2></header><div class=entry-content><p>Load Testing API 부하 테스트는 API가 예상된 사용자 부하와 그 이상의 상황에서 어떻게 동작하는지 검증하는 중요한 성능 테스트 유형이다.
API 부하 테스트의 기본 개념 부하 테스트란 무엇인가? 부하 테스트는 시스템에 점진적으로 부하를 증가시키면서 그 동작을, 분석하는 성능 테스트의 한 유형이다. API 부하 테스트는 특히 API가 다양한 부하 조건에서 어떻게 동작하는지 검증하는 데 초점을 맞춘다.
이런 테스트를 통해 다음과 같은 중요한 정보를 얻을 수 있다:
API의 최대 처리 용량(초당 요청 수) 응답 시간과 부하 간의 관계 병목 현상이 발생하는 지점 시스템의 안정성과 확장성 자원 사용률(CPU, 메모리, 네트워크 등) 다른 성능 테스트 유형과의 비교 부하 테스트는 다른 성능 테스트 유형과 목적과 접근 방식에서 차이가 있다:
...</p></div><footer class=entry-footer><span title='2025-03-10 02:52:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Testing" href=https://buenhyden.github.io/posts/backend/api-design/api-lifecycle-management/testing/load-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Socket vs. Long Polling</h2></header><div class=entry-content><p>Web Socket vs. Long Polling 실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.
기본 개념 WebSocket WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-09 02:31:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Socket vs. Long Polling" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/event-based-style/websocket/web-socket-vs-long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Integration Patterns</h2></header><div class=entry-content><p>API Integration Patterns API 통합 패턴은 다양한 시스템, 서비스, 애플리케이션이 효과적으로 통신하고 상호작용할 수 있도록 하는 설계 접근법이다. 이러한 패턴들은 복잡한 시스템 간의 통합 과정에서 발생하는 문제를 해결하고, 확장 가능하며 유지보수가 용이한 아키텍처를 구축하는 데 도움이 된다.
API 통합의 기본 개념 API 통합은 서로 다른 소프트웨어 시스템이 함께 작동할 수 있도록 연결하는 과정이다. 현대 기업 환경에서는 수많은 애플리케이션, 서비스, 데이터베이스가 존재하며, 이들 간의 원활한 정보 교환이 필수적이다. API 통합을 통해 이러한 시스템들은 서로의 기능을 활용하고 데이터를 공유할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-06 13:00:00 +0000 UTC'>March 6, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Integration Patterns" href=https://buenhyden.github.io/posts/backend/backend-architecture/api-design-architecture/api-integration-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-sent Events vs. Websocket</h2></header><div class=entry-content><p>Server-sent Events vs. Websocket 웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.
서버 전송 이벤트(SSE) 개념과 작동 원리 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, EventSource API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-03 05:41:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-sent Events vs. Websocket" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RFC 6749</h2></header><div class=entry-content><p>RFC 6749 RFC 6749는 OAuth 2.0 권한 부여 프레임워크(The OAuth 2.0 Authorization Framework)를 정의하는 인터넷 표준 문서이다. 이 문서는 2012년 10월에 인터넷 표준화 기구인 IETF(Internet Engineering Task Force)에 의해 발행되었다. 주 저자는 Dick Hardt이며, 여러 기술 전문가들의 협업으로 만들어졌다.
OAuth 2.0은 이전 버전인 OAuth 1.0(RFC 5849)의 후속 버전으로, 다양한 웹 애플리케이션, 데스크톱 애플리케이션, 모바일 애플리케이션 및 IoT 장치에서 안전한 권한 위임을 가능하게 하는 프로토콜이다. 간단히 말해, OAuth 2.0은 사용자가 자신의 비밀번호를 공유하지 않고도 제3자 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 해주는 프레임워크이다.
...</p></div><footer class=entry-footer><span title='2025-02-28 11:28:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 6749" href=https://buenhyden.github.io/posts/security/access-control/authentication/protocols/oauth/rfc-6749/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming APIs</h2></header><div class=entry-content><p>Streaming APIs 스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다. 전통적인 RESTful API가 요청-응답 패턴을 기반으로 하는 반면, 스트리밍 API는 지속적인 연결을 통해 실시간 데이터를 제공한다. 이러한 접근 방식은 데이터가 생성되는 즉시 클라이언트에게 전달할 수 있어 실시간성이 중요한 애플리케이션에 적합하다.
스트리밍 API의 기본 원리는 클라이언트와 서버 간에 한 번 연결을 수립한 후, 서버가 필요에 따라 데이터를 푸시하는 방식으로 동작하다. 이는 폴링(polling) 방식의 단점인 불필요한 요청과 네트워크 오버헤드를 극복할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:41:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming APIs" href=https://buenhyden.github.io/posts/networking/streaming/streaming-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend/event-driven-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pub/Sub APIs</h2></header><div class=entry-content><p>Pub/Sub APIs Pub/Sub 패턴의 기본 개념 Pub/Sub(Publish-Subscribe) 패턴은 메시지 기반 아키텍처의 핵심 패러다임으로, 데이터를 생성하는 발행자(Publisher)와 데이터를 소비하는 구독자(Subscriber) 사이의 느슨한 결합(loose coupling)을 제공한다. 이 패턴에서 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 자동으로 그 메시지를 수신한다.
Pub/Sub 패턴의 가장 중요한 특징은 발행자와 구독자가 서로에 대해 직접적인 지식이 필요 없다는 점이다. 발행자는 단순히 주제에 메시지를 보내고, 시스템이 해당 주제의 모든 구독자에게 메시지를 전달한다. 이러한 분리는 시스템 구성 요소 간의 의존성을 줄이고 확장성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pub/Sub APIs" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/event-based-style/pub-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Websocket API vs. Websocket</h2></header><div class=entry-content><p>Websocket API vs. Websocket WebSocket이란? WebSocket은 단일 TCP 연결을 통해 클라이언트와 서버 간의 양방향 통신 채널을 제공하는 통신 프로토콜이다. HTTP와 달리, 연결이 한 번 수립되면 계속 유지되며, 클라이언트와 서버가 서로 독립적으로 메시지를 주고받을 수 있다.
WebSocket 프로토콜은 RFC 6455에 정의되어 있으며, ‘ws://’ 또는 암호화된 연결을 위한 ‘wss://’ URI 스키마를 사용한다. WebSocket은 HTTP 핸드셰이크를 사용하여 연결을 시작한 다음, 프로토콜을 WebSocket으로 업그레이드한다.
WebSocket API란? WebSocket API는 웹 애플리케이션에서 WebSocket 프로토콜을 사용할 수 있게 해주는 인터페이스이다. 이것은 W3C에서 표준화한 웹 API로, 자바스크립트를 통해 WebSocket 프로토콜을 구현할 수 있도록 한다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:38:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Websocket API vs. Websocket" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/event-based-style/websocket/websocket-api-vs-websocket/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/api-design/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/api-design/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>