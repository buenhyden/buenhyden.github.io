<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API-Design | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/api-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/api-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/api-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/api-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API-Design"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API-Design"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>API-Design</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication</h2></header><div class=entry-content><p>Token Authentication 사용자 자격 증명 대신 고유한 토큰을 사용하여 인증을 수행하며, 반복적인 로그인 없이 지속적인 접근을 가능하게 한다.
주요 특징 상태 비저장(Stateless):
서버는 토큰의 유효성만 검증하면 되므로, 세션 정보를 저장할 필요가 없습니다.
확장성:
여러 서버에서도 동일한 토큰으로 인증이 가능합니다.
보안:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TokenSecurity: def __init__(self): self.blacklisted_tokens = set() def revoke_token(self, token: str): """토큰 무효화""" self.blacklisted_tokens.add(token) def is_token_blacklisted(self, token: str): """토큰 블랙리스트 확인""" return token in self.blacklisted_tokens def rotate_token(self, old_token: str): """토큰 교체""" # 이전 토큰 무효화 self.revoke_token(old_token) # 새 토큰 발급 payload = token_auth.verify_token(old_token) return token_auth.create_access_token(payload) 토큰 구조 일반적으로 JWT(JSON Web Token) 형식을 사용합니다. 헤더, 페이로드, 서명으로 구성됩니다. 장점 향상된 보안: 자격 증명 노출 위험 감소 확장성: 서버 부하 감소 및 분산 시스템 지원 유연성: 다양한 플랫폼과 디바이스 간 호환성 단점 토큰 관리의 복잡성 토큰 탈취 위험 중앙 집중식 시스템에 대한 의존성 주요 구성 요소 토큰 생성 및 발급 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class AuthenticationService: def __init__(self): self.token_auth = TokenAuth() async def authenticate_user(self, username: str, password: str): """사용자 인증 및 토큰 발급""" # 사용자 검증 user = await validate_user_credentials(username, password) if not user: raise HTTPException(status_code=401, detail="Invalid credentials") # 토큰 생성 access_token = self.token_auth.create_access_token( data={"sub": user.username, "role": user.role} ) return { "access_token": access_token, "token_type": "bearer" } 토큰 검증 및 보호된 리소스 접근 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_current_user(token: str = Depends(oauth2_scheme)): """현재 인증된 사용자 정보 획득""" credentials_exception = HTTPException( status_code=401, detail="Could not validate credentials", headers={"WWW-Authenticate": "Bearer"}, ) try: # 토큰 검증 payload = token_auth.verify_token(token) username = payload.get("sub") if username is None: raise credentials_exception # 사용자 정보 반환 return {"username": username, "role": payload.get("role")} except jwt.JWTError: raise credentials_exception 작동 원리 사용자가 자격 증명을 제공하여 로그인합니다. 서버는 자격 증명을 확인하고 유효한 경우 액세스 토큰을 생성합니다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킵니다. 서버는 각 요청마다 토큰을 검증하여 사용자를 인증합니다. 토큰 기반 인증의 모범 사례 토큰 만료 시간 설정:
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;600 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/token-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PCI DSS(Payment Card Industry Data Security Standard)</h2></header><div class=entry-content><p>PCI DSS(Payment Card Industry Data Security Standard) PCI DSS(Payment Card Industry Data Security Standard)는 신용카드 결제 과정에서 카드 소유자의 데이터를 안전하게 보호하기 위해 주요 글로벌 카드 브랜드(Visa, MasterCard, American Express, Discover, JCB)가 공동으로 제정한 국제 보안 표준이다.
이 표준은 카드 정보의 저장, 처리, 전송을 수행하는 모든 조직이 준수해야 하며, 이를 통해 카드 결제 산업의 데이터 보안을 강화하고 사기 및 데이터 유출을 방지하는 것을 목표로 한다.
2025년 3월 기준 PCI DSS v4.0은 기존 버전 대비 64개 신규 요구사항을 추가했으며, 특히 이메일 기반 공격 방지를 위한 DMARC 정책과 API 보안 강화 조치가 주목받고 있다.
조직들은 연간 1회 이상의 전체 시스템 진단과 분기별 외부 취약점 스캔을 통해 규정 준수를 유지해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-27 13:03:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;941 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PCI DSS(Payment Card Industry Data Security Standard)" href=https://buenhyden.github.io/posts/backend/api-design/standards-and-compliance/pci-dss/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>폴링(Polling)</h2></header><div class=entry-content><p>폴링(Polling) 폴링(Polling)은 소프트웨어 개발에서 중요한 통신 기법으로, 클라이언트가 주기적으로 서버에 데이터나 상태 변경을 요청하는 방식이다.
이 방법은 실시간 또는 준실시간 업데이트가 필요한 애플리케이션에서 자주 사용된다.
폴링의 작동 원리 클라이언트가 서버에 주기적으로 요청을 보낸다. 서버는 요청을 받아 처리하고 응답을 반환한다. 클라이언트는 응답을 받아 필요한 작업을 수행한다. 일정 시간 후 클라이언트는 다시 요청을 보낸다. 이 과정은 지속적으로 반복된다.
폴링의 장점 구현의 용이성: 폴링은 상대적으로 간단하게 구현할 수 있다. 호환성: 대부분의 환경과 기술에서 사용 가능하다. 요청 빈도 제어: 개발자가 요청 주기를 조절할 수 있어 유연성이 높다. 비실시간 업데이트에 적합: 즉각적인 업데이트가 필요하지 않은 경우에 효과적이다. 폴링의 단점 서버 부하: 불필요한 요청으로 인해 서버에 부담을 줄 수 있다. 실시간성 부족: 폴링 주기에 따라 실시간 업데이트가 지연될 수 있다. 리소스 낭비: 변경사항이 없어도 지속적으로 요청을 보내므로 리소스가 낭비될 수 있다. 폴링의 사용 사례 이메일 클라이언트: 새 메일 확인을 위해 주기적으로 서버에 요청을 보낸다. 주식 시세 모니터링: 일정 간격으로 최신 주가 정보를 요청한다. 소셜 미디어 피드: 새로운 게시물이나 알림을 확인하기 위해 사용된다. IoT 디바이스 모니터링: 센서 데이터를 주기적으로 확인한다. 폴링의 구현 폴링은 주로 JavaScript의 setInterval() 함수나 setTimeout() 함수를 사용하여 구현한다.
예를 들어:
...</p></div><footer class=entry-footer><span title='2024-10-20 16:50:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;245 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 폴링(Polling)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-19 07:35:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;698 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/hateoas/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>웹훅 (Webhook)</h2></header><div class=entry-content><p>웹훅 (Webhook) 웹훅은 웹 애플리케이션에서 특정 이벤트가 발생했을 때 다른 애플리케이션에 실시간으로 정보를 전달하는 방법이다.
쉽게 말해, 어떤 일이 일어났을 때 자동으로 알림을 보내는 시스템이라고 생각하면 된다.
웹훅의 작동 원리 애플리케이션 A가 특정 URL(콜백 URL)을 애플리케이션 B에 등록한다. 애플리케이션 B에서 중요한 이벤트가 발생한다. 애플리케이션 B는 등록된 URL로 HTTP POST 요청을 보낸다. 애플리케이션 A는 이 요청을 받아 필요한 작업을 수행한다. 웹훅의 장점 실시간 업데이트: 이벤트 발생 즉시 알림을 받을 수 있다. 효율성: 필요할 때만 통신하므로 리소스 사용이 적다. 자동화: 이벤트에 따른 작업을 자동으로 처리할 수 있다. 웹훅의 단점 보안 문제: 콜백 URL이 노출될 경우 악의적인 요청을 받을 수 있다. 신뢰성: 네트워크 문제로 알림이 손실될 수 있다. 단방향 통신: 서버에서 클라이언트로의 통신만 가능하다. 웹훅의 사용 사례 결제 시스템: 결제 완료 시 즉시 알림 소셜 미디어: 새 게시물 작성 시 연동 서비스에 알림 버전 관리 시스템: 코드 변경 시 자동 빌드 시작 IoT: 센서 데이터가 특정 값을 초과할 때 알림 웹훅 구현 시 주의사항 보안: 요청의 출처를 반드시 확인해야 한다. 에러 처리: 네트워크 문제 등으로 인한 실패에 대비해야 한다. 재시도 메커니즘: 전송 실패 시 재시도 로직을 구현해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-19 06:46:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 웹훅 (Webhook)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>WebRTC(Web Real-Time Communication) API</h2></header><div class=entry-content><p>WebRTC(Web Real-Time Communication) API WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술.
웹 브라우저 간에 실시간으로 음성, 영상, 데이터를 직접 주고받을 수 있게 해주는 기술로 기존의 웹 통신이 항상 서버를 거쳐야 했던 것과 달리, WebRTC는 브라우저 간 직접 통신(P2P)을 가능하게 한다.
핵심 구성 요소 WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술입니다. WebRTC API는 주로 세 가지 핵심 구성 요소로 이루어져 있습니다:
...</p></div><footer class=entry-footer><span title='2024-10-19 06:37:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebRTC(Web Real-Time Communication) API" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/webrtc-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events (SSE) 실시간 알림, 주식 시세, 실시간 점수 업데이트 등을 구현하기 위해서는 서버가 클라이언트에게 능동적으로 데이터를 보낼 수 있어야 한다.
이를 위한 기술 중 하나가 바로 SSE이다.
SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술이다.
WebSocket과 비교했을 때 더 단순하고 HTTP를 기반으로 하기 때문에 구현이 쉽다는 장점이 있다.
주요 특징 단방향 통신: SSE는 서버에서 클라이언트로의 단방향 통신만을 지원한다. HTTP 프로토콜 사용: SSE는 기존 HTTP 프로토콜을 사용하므로, 특별한 프로토콜이나 서버 설정이 필요하지 않다. 자동 재연결: 연결이 끊어졌을 때 브라우저가 자동으로 재연결을 시도한다. 개발자가 별도의 재연결 로직을 구현할 필요가 없다. 실시간 데이터 전송: 서버에서 발생하는 이벤트나 데이터 변경 사항을 클라이언트에게 실시간으로 전달할 수 있다. 장점 간단한 구현: WebSocket에 비해 구현이 더 간단하다. 브라우저 호환성: 대부분의 최신 브라우저에서 지원된다. 서버 부하 감소: HTTP 연결을 재사용하므로, WebSocket보다 서버 부하가 적을 수 있다. 방화벽 친화적: 기존 HTTP 프로토콜을 사용하므로 방화벽이나 프록시 서버와의 호환성이 좋다. 단점 단방향 통신: 양방향 통신이 필요한 경우에는 적합하지 않다. 연결 제한: 브라우저당 동시 SSE 연결 수에 제한이 있을 수 있다. IE 지원 부족: Internet Explorer에서는 지원되지 않는다. 동작 원리 클라이언트가 서버에 SSE 연결 요청을 보낸다. 서버는 클라이언트와 매핑되는 SSE 통신 객체(예: SseEmitter)를 생성한다. 서버에서 이벤트가 발생하면 해당 객체를 통해 클라이언트로 데이터를 전송한다. 활용사례 실시간 알림 시스템 주식 시세나 스포츠 점수 업데이트 소셜 미디어 피드 업데이트 로그 스트리밍 진행 상황 모니터링 고려사항 연결 관리:
...</p></div><footer class=entry-footer><span title='2024-10-19 06:18:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/backend/api-design/real-time-apis/server-sent-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SOAP API</h2></header><div class=entry-content><p>SOAP API SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜.
분산 환경에서 데이터를 교환하기 위해 설계된 웹 서비스 통신 방식.
SOAP API의 주요 특징 XML 기반: 모든 SOAP 메시지는 XML 형식으로 구성됩니다. 프로토콜 독립성: HTTP, SMTP 등 다양한 프로토콜을 통해 전송될 수 있습니다. 표준화: 잘 정의된 표준을 따르며, 이는 다양한 플랫폼과 언어 간의 호환성을 보장합니다. 보안성: WS-Security와 같은 웹 서비스 보안 표준을 지원합니다. SOAP 메시지 구조 SOAP 메시지는 다음과 같은 요소로 구성됩니다:
...</p></div><footer class=entry-footer><span title='2024-10-19 03:21:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/soap-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)</h2></header><div class=entry-content><p>동기(Synchronous) 동기(Synchronous)는 작업들이 순차적으로 실행되며, 하나의 작업이 완료된 후에 다음 작업이 시작되는 방식이다.
“동시에 일어난다"는 의미로, 요청과 그 결과가 동시에 일어난다는 약속이다.
파일에서 데이터를 읽고 처리하는 동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 동기식 처리 예제 function processUserData() { // 1. 파일을 읽을 때까지 다음 줄로 진행하지 않음 const userData = readFileSync('user.txt'); // 2. 데이터 처리가 완료될 때까지 대기 const processedData = processData(userData); // 3. 저장이 완료될 때까지 대기 saveToDatabase(processedData); // 4. 모든 작업이 완료된 후에만 실행 console.log('작업 완료!'); } 주요 특징 순차적 실행: 코드가 작성된 순서대로 실행된다. 블로킹(Blocking): 한 작업이 완료될 때까지 다음 작업은 대기한다. 예측 가능성: 코드의 실행 흐름이 명확하고 예측 가능하다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/synchronous-vs-asynchronous-apis/synchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비동기(Asynchronous)</h2></header><div class=entry-content><p>비동기(Asynchronous) 비동기(Asynchronous)는 작업들이 독립적으로 실행되며, 작업의 완료 여부와 관계없이 다음 작업이 시작될 수 있는 방식이다.
“동시에 일어나지 않는다"는 의미로, 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.
파일에서 데이터를 읽고 처리하는 비동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 비동기식 처리 예제 async function processUserData() { try { // 1. 파일을 읽는 동안 다른 작업 수행 가능 const userData = await readFile('user.txt'); // 2. 데이터 처리 중에도 다른 작업 가능 const processedData = await processData(userData); // 3. 데이터베이스 저장 중에도 다른 작업 가능 await saveToDatabase(processedData); console.log('작업 완료!'); } catch (error) { console.error('오류 발생:', error); } } // 메인 프로그램은 계속 실행됨 console.log('프로그램 시작'); processUserData(); console.log('다른 작업 진행 중…'); 주요 특징 비순차적 실행: 작업들이 독립적으로 실행될 수 있다. 논블로킹(Non-blocking): 한 작업이 다른 작업의 실행을 막지 않는다. 이벤트 기반: 작업 완료 시 이벤트나 콜백을 통해 결과를 처리한다. 동시성: 여러 작업을 동시에 처리할 수 있다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기(Asynchronous)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/synchronous-vs-asynchronous-apis/asynchronous/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/api-design/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>