<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API-Design | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/tags/api-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/tags/api-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/tags/api-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/tags/api-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API-Design"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API-Design"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/tags/>Tags</a></div><h1>API-Design</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PBAC</h2></header><div class=entry-content><p>정책 기반 접근 제어(Policy-Based Access Control, PBAC) 중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.
각 정책은 “누가”, “무엇을”, “어떤 조건에서” 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.
현대적인 클라우드 환경이나 마이크로서비스 아키텍처에서 특히 유용하다.
AWS IAM, Azure RBAC 등의 클라우드 서비스들이 PBAC를 구현한 대표적인 예시.
작동 방식:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Policy { constructor(name, conditions, effect) { this.name = name; this.conditions = conditions; this.effect = effect; // 'allow' 또는 'deny' } evaluate(context) { try { // 모든 조건을 평가 return this.conditions.every(condition => condition(context)); } catch (error) { console.error(`Policy evaluation error: ${error.message}`); return false; } } } class PolicyEngine { constructor() { this.policies = new Map(); } addPolicy(policy) { this.policies.set(policy.name, policy); } evaluateAccess(context) { let finalDecision = false; for (const policy of this.policies.values()) { const matches = policy.evaluate(context); if (matches) { finalDecision = policy.effect === 'allow'; // 명시적인 거부 정책이 있으면 즉시 거부 if (policy.effect === 'deny') { return false; } } } return finalDecision; } } // 정책 조건 예시들 const conditions = { isWorkingHours: (context) => { const hour = context.time.getHours(); return hour >= 9 && hour &lt; 18; }, isInternalNetwork: (context) => { return context.ipAddress.startsWith('192.168.'); }, hasRole: (role) => (context) => { return context.user.roles.includes(role); }, hasPermission: (permission) => (context) => { return context.user.permissions.includes(permission); } }; // 정책 엔진 사용 예시 const policyEngine = new PolicyEngine(); // HR 문서 접근 정책 const hrDocumentPolicy = new Policy( 'HR_Document_Access', [ conditions.isWorkingHours, conditions.isInternalNetwork, conditions.hasRole('HR'), conditions.hasPermission('read_hr_documents') ], 'allow' ); // 주말 접근 제한 정책 const weekendRestrictionPolicy = new Policy( 'Weekend_Restriction', [ (context) => { const day = context.time.getDay(); return day === 0 || day === 6; } ], 'deny' ); policyEngine.addPolicy(hrDocumentPolicy); policyEngine.addPolicy(weekendRestrictionPolicy); // 접근 시도 예시 const accessContext = { user: { name: 'Alice', roles: ['HR'], permissions: ['read_hr_documents'] }, time: new Date('2024-12-17T14:00:00'), // 평일 오후 2시 ipAddress: '192.168.1.100', resource: 'employee_records' }; const hasAccess = policyEngine.evaluateAccess(accessContext); console.log(`Access granted: ${hasAccess}`); 주요 특징 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 중앙 집중식 관리: 정책을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 컨텍스트 인식: 사용자 신원, 리소스 특성, 시간, 위치 등 다양한 컨텍스트 정보를 고려한다. 동적 평가: 접근 요청 시 실시간으로 정책을 평가하여 결정을 내린다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 정책 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 일관성 유지: 중앙에서 관리되는 정책으로 전체 시스템의 일관성을 보장한다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AdvancedPolicyEngine { constructor() { this.policies = new Map(); this.auditLog = []; } addPolicy(policy) { this.policies.set(policy.name, policy); } async evaluateAccess(context) { const decisions = []; const startTime = Date.now(); try { for (const policy of this.policies.values()) { const decision = { policyName: policy.name, effect: policy.effect, matches: await policy.evaluate(context), timestamp: new Date() }; decisions.push(decision); if (decision.matches && policy.effect === 'deny') { this.logDecision(context, decisions, 'denied'); return false; } } const finalDecision = decisions.some(d => d.matches && d.effect === 'allow'); this.logDecision(context, decisions, finalDecision ? 'allowed' : 'denied'); return finalDecision; } catch (error) { this.logError(context, error); throw error; } } logDecision(context, decisions, result) { const logEntry = { timestamp: new Date(), user: context.user.name, resource: context.resource, action: context.action, decisions: decisions, finalResult: result, contextSnapshot: { …context } }; this.auditLog.push(logEntry); } logError(context, error) { const errorEntry = { timestamp: new Date(), type: 'error', user: context.user.name, error: error.message, stack: error.stack, context: { …context } }; this.auditLog.push(errorEntry); } getAuditLog(filters = {}) { return this.auditLog.filter(entry => { return Object.entries(filters).every(([key, value]) => entry[key] === value ); }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PBAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/pbac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ABAC</h2></header><div class=entry-content><p>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC) ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.
이를 통해 매우 세분화되고 유연한 접근 제어가 가능하다.
의료, 금융, 정부 등 복잡한 보안 요구사항을 가진 분야에서 유용하게 활용될 수 있다.
주요 특징 유연성: 다양한 속성 조합을 통해 복잡한 접근 제어 정책을 수용할 수 있다. 세분화: 사용자 역할뿐만 아니라 다양한 속성을 고려하여 더 정교한 접근 제어가 가능하다. 동적 정책: 실시간 속성 변화에 따라 접근 제어 결정을 동적으로 수행할 수 있다. 확장성: 새로운 속성을 쉽게 추가하여 정책을 확장할 수 있다. ABAC의 주요 구성 요소 속성: 주체, 객체, 환경 조건에 대한 특성을 정의한다. 주체(Subject) 속성 사용자 ID, 이름, 직급, 부서, 보안 등급 근속 연수, 자격증, 교육 이수 여부 소속 조직, 프로젝트 참여 이력 객체(Object/Resource) 속성 데이터 분류, 보안 레벨 소유자, 작성일, 만료일 프로젝트 코드, 부서 코드 데이터 타입, 크기, 형식 행동(Action) 속성 읽기, 쓰기, 삭제, 수정 승인, 거부, 이관 다운로드, 공유, 인쇄 환경(Environment) 속성 접근 시간, 위치 네트워크 종류(내부/외부) 디바이스 종류, 보안 상태 현재 위험 수준 정책 모델: 속성들의 조합으로 접근 제어 규칙을 정의한다. 아키텍처 모델: ABAC 시스템의 구현 방식을 정의한다. ABAC의 장점 높은 유연성과 세분화된 접근 제어 가능 동적이고 컨텍스트 인식적인 정책 적용 가능 새로운 사용자나 리소스에 대해 개별 권한 설정 없이 속성만으로 접근 제어 가능 ABAC의 단점 구현 및 관리의 복잡성 성능 영향: 많은 속성을 평가해야 하므로 처리 시간이 길어질 수 있음 정책 설계의 어려움: 복잡한 속성 조합으로 인한 예기치 않은 결과 발생 가능성 모범 사례 정책 설계
...</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;494 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ABAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/abac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RBAC</h2></header><div class=entry-content><p>규칙 기반 접근 제어(Rule-Based Access Control, RBAC) RBAC는 “만약 ~라면 ~할 수 있다"와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다.
각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.
클라우드 환경, 마이크로서비스 아키텍처, IoT 시스템 등 동적이고 복잡한 환경에서 특히 유용하며, 보안 요구사항이 높고 빠르게 변화하는 조직에 적합하다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Rule { constructor(condition, consequence) { // 규칙의 조건부(if)와 결과부(then)를 정의합니다 this.condition = condition; this.consequence = consequence; } evaluate(context) { // 주어진 컨텍스트에 대해 규칙을 평가합니다 if (this.condition(context)) { return this.consequence; } return null; } } class RuleEngine { constructor() { this.rules = []; } addRule(rule) { // 새로운 규칙을 규칙 엔진에 추가합니다 this.rules.push(rule); } evaluateAccess(context) { // 모든 규칙을 순차적으로 평가합니다 for (const rule of this.rules) { const result = rule.evaluate(context); if (result !== null) { return result; } } // 기본적으로는 접근을 거부합니다 return false; } } 주요 특징 규칙 기반 결정: 사용자의 속성, 리소스의 특성, 환경 조건 등을 고려한 규칙을 설정하여 접근 권한을 결정한다. 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 동적 평가: 접근 요청 시 실시간으로 규칙을 평가하여 결정을 내린다. 중앙 집중식 관리: 규칙을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 규칙 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 투명성: 규칙이 명시적으로 정의되어 있어 접근 제어 결정의 이유를 쉽게 이해할 수 있다. 단점 복잡성: 규칙이 많아지면 관리가 복잡해질 수 있다. 성능 영향: 많은 규칙을 평가해야 할 경우 처리 시간이 길어질 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;291 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RBAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/rbac/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session based Auth</h2></header><div class=entry-content><p>Session Based Auth Session based Authentication은 웹 애플리케이션에서 사용자의 인증 상태를 유지하는 전통적인 방법 서버 측에서 사용자의 인증 상태와 데이터를 관리하는 방식이다. 사용자가 로그인하면 서버는 고유한 세션 ID를 생성하고, 이와 관련된 사용자 정보를 서버의 메모리나 데이터베이스에 저장한다.
주요 장점 서버 제어
서버가 세션을 완전히 제어할 수 있어 필요할 때 즉시 세션을 무효화할 수 있습니다.
보안성
세션 데이터가 서버에 안전하게 보관되며, 클라이언트는 세션 ID만 가지고 있습니다.
사용 편의성
기존 웹 애플리케이션과의 호환성이 좋고, 구현이 상대적으로 단순합니다.
...</p></div><footer class=entry-footer><span title='2024-11-06 11:30:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session based Auth" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/session-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SAML</h2></header><div class=entry-content><p>SAML 웹 애플리케이션에서 사용자 인증과 권한 부여를 위한 개방형 표준 프로토콜.
SAML은 사용자가 하나의 로그인 자격 증명으로 여러 웹 애플리케이션에 접근할 수 있게 해주는 인증 메커니즘.
주로 기업 환경에서 단일 로그인(SSO) 구현에 사용된다.
장점 통합 인증(SSO) 지원으로 사용자 편의성 향상 표준화된 XML 기반 프로토콜로 상호운용성 보장 강력한 보안 기능 제공 다양한 인증 방식 지원 주요 구성 요소 아이덴티티 제공자(IdP) 사용자 인증을 수행하고 인증 정보를 서비스 제공자에게 전달합니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class IdentityProvider: def __init__(self): self.private_key = load_private_key() self.certificate = load_certificate() def create_assertion(self, user_data): """SAML Assertion 생성""" assertion = { "issuer": "https://idp.example.com", "subject": user_data["username"], "attributes": { "email": user_data["email"], "role": user_data["role"] }, "conditions": { "notBefore": datetime.utcnow(), "notOnOrAfter": datetime.utcnow() + timedelta(minutes=5) } } return self.sign_assertion(assertion) 서비스 제공자(SP) IdP로부터 받은 인증 정보를 신뢰하고 사용자에게 서비스를 제공합니다.
...</p></div><footer class=entry-footer><span title='2024-11-06 11:25:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;570 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/saml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Basic Authentication</h2></header><div class=entry-content><p>Basic Authentication 이 인증 방식은 HTTP 프로토콜에 내장된 가장 기본적인 인증 메커니즘.
HTTP 헤더에 사용자의 인증 정보를 포함시켜 전송하는 방식
다음과 같은 경우에는 사용을 피해야 한다.
공개 웹사이트 사용자 계정 시스템 전자상거래 사이트 소셜 미디어 중요한 데이터 금융 정보 개인정보 의료 기록 높은 보안이 필요한 API 결제 시스템 인증 서비스 중요 비즈니스 로직 인증 과정 클라이언트가 보호된 리소스에 접근을 시도합니다.
서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 전송합니다.
1 2 HTTP/1.1 401 Unauthorized WWW-Authenticate: Basic realm="Access to the staging site" 클라이언트는 사용자명과 비밀번호를 base64로 인코딩하여 Authorization 헤더에 포함시켜 다시 요청을 보냅니다.
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;432 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Basic Authentication" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/basic-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cookie Based Auth</h2></header><div class=entry-content><p>Cookie Based Auth 웹 애플리케이션에서 사용자 세션을 유지하는 전통적인 방법
사용자의 인증 정보를 클라이언트 측의 쿠키에 저장하여 인증 상태를 유지하는 방식으로 Stateless한 HTTP 연결을 Stateful하게 만든다.
주요 특징 보안적 특징:
쿠키는 HttpOnly 플래그로 JavaScript 접근을 방지할 수 있습니다. Secure 플래그로 HTTPS 연결에서만 전송되도록 할 수 있습니다. SameSite 속성으로 CSRF 공격을 방지할 수 있습니다. 세션 관리:
서버는 세션 데이터를 메모리나 데이터베이스에 저장합니다. 세션 만료 시간을 설정하여 보안을 강화할 수 있습니다. 필요한 경우 사용자의 세션을 즉시 무효화할 수 있습니다. 확장성 고려사항:
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;586 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cookie Based Auth" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/cookie-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JWT</h2></header><div class=entry-content><p>JWT (Json Web Token) JWT (JSON Web Token)는 당사자 간에 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함된 방식을 정의하는 개방형 표준(RFC 7519)이다.
구조 1 2 3 4 5 6 7 // JWT 구조 header.payload.signature // 예시 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ. SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c JWT는 세 부분으로 구성됩니다:
헤더 (Header): 토큰 유형과 사용된 해시 알고리즘 정보를 포함
typ: 토큰의 유형 (일반적으로 “JWT”) alg: 서명 시 사용하는 알고리즘 (예: HS256, RS256) 1 2 3 4 { "alg": "HS256", // 서명 알고리즘 "typ": "JWT" // 토큰 타입 } 페이로드 (Payload): 클레임(claim)이라 불리는 엔티티와 추가 데이터를 포함
클레임(Claim)
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;756 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OAuth</h2></header><div class=entry-content><p>OAuth 사용자의 비밀번호를 공유하지 않고도 제3자 애플리케이션이 사용자의 데이터에 안전하게 접근할 수 있도록 하는 표준 프로토콜.
사용자가 자신의 정보에 대한 제한된 접근 권한을 다른 애플리케이션에 부여할 수 있게 해주는 표준 프로토콜.
권한 부여를 위한 프로토콜.
특징:
토큰 기반 인증 사용자 비밀번호 노출 없이 접근 권한 부여 다양한 애플리케이션 유형 지원 (웹, 모바일, 데스크톱 등) 구성 요소 Resource Owner: 데이터 소유자인 사용자 Client: OAuth를 사용하여 데이터에 접근하려는 애플리케이션 Resource Server: 보호된 데이터를 호스팅하는 서버 Authorization Server: 인증을 처리하고 토큰을 발급하는 서버 장점 보안성 향상 세분화된 권한 제어 사용자 경험 개선 사용 사례 소셜 미디어 로그인 타사 애플리케이션에 제한된 데이터 접근 권한 부여 API 접근 관리 토큰 유형 Access Token: 리소스에 접근하기 위한 단기 토큰 Refresh Token: 새로운 액세스 토큰을 얻기 위한 장기 토큰 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Python에서 토큰 관리 class TokenManager: def __init__(self): self.secret_key = "your_secret_key" def create_access_token(self, user_id: str): return jwt.encode( { "sub": user_id, "exp": datetime.utcnow() + timedelta(minutes=30), "type": "access" }, self.secret_key, algorithm="HS256" ) def create_refresh_token(self, user_id: str): return jwt.encode( { "sub": user_id, "exp": datetime.utcnow() + timedelta(days=30), "type": "refresh" }, self.secret_key, algorithm="HS256" ) 작동 방식 클라이언트가 사용자의 데이터 접근 요청 인증 서버가 사용자에게 동의 요청 사용자 동의 후 인증 서버가 클라이언트에게 액세스 토큰 발급 클라이언트는 토큰을 사용하여 리소스 서버의 데이터에 접근 Python으로 구현한 기본적인 OAuth 클라이언트:
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;885 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/oauth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>OpenID Connect</h2></header><div class=entry-content><p>OpenID Connect (OIDC) OpenID Connect (OIDC)는 OAuth 2.0 프로토콜 위에 구축된 인증 계층으로, 사용자 인증과 기본적인 프로필 정보 획득을 위한 표준화된 방법을 제공한다.
정의와 목적 OIDC는 OAuth 2.0을 확장하여 인증 기능을 추가한 프로토콜입니다. 사용자 신원 확인과 기본 프로필 정보 제공을 목적으로 합니다. 작동 방식 OAuth 2.0 흐름을 기반으로 하며, ID 토큰이라는 추가적인 토큰을 발급합니다. ID 토큰은 JWT(JSON Web Token) 형식으로, 사용자 정보를 포함합니다. 주요 구성 요소 ID 토큰 사용자 인증 정보를 포함한 JWT
...</p></div><footer class=entry-footer><span title='2024-11-06 11:24:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OpenID Connect" href=https://buenhyden.github.io/posts/backend/api-design/authentication-methods/openid-connect/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/tags/api-design/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/tags/api-design/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>