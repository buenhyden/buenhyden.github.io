<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – 11</title><link>https://buenhyden.github.io/til/2024/11/</link><description>Recent content in 11 on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://buenhyden.github.io/til/2024/11/index.xml" rel="self" type="application/rss+xml"/><item><title>Validation and Verification</title><link>https://buenhyden.github.io/til/2024/11/validation-and-verification/</link><pubDate>Thu, 28 Nov 2024 08:03:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/validation-and-verification/</guid><description>
&lt;h2>Validation and Verification&lt;/h2>&lt;p>소프트웨어 테스팅에서 Validation과 Verification은 서로 다른 관점과 목적을 가지고 있다.&lt;br>
Verification은 &amp;ldquo;제품을 올바르게 만들고 있는가?&amp;ldquo;를 확인하는 과정이고, Validation은 &amp;ldquo;올바른 제품을 만들고 있는가?&amp;ldquo;를 확인하는 과정이다.&lt;br>
이러한 근본적인 차이는 테스트 방법과 접근 방식에 큰 영향을 미친다.&lt;/p>
&lt;h3>Verification&lt;/h3>&lt;p>Verification은 &lt;strong>&amp;ldquo;우리가 제품을 올바르게 만들고 있는가?&amp;rdquo;&lt;/strong> 라는 질문에 답하는 프로세스로, 개발 과정 중에 제품이 명세된 요구사항과 설계 문서에 따라 정확하게 구현되고 있는지를 검증한다.&lt;/p>
&lt;p>개발자와 테스터가 수행하며, 코드 레벨에서의 정확성과 기술적 완성도를 중요시한다.&lt;br>
예를 들어, 특정 함수가 입력값에 대해 정확한 출력값을 반환하는지, 데이터베이스 쿼리가 예상대로 작동하는지 등을 확인한다.&lt;/p>
&lt;h3>Validation&lt;/h3>&lt;p>Validation은 &lt;strong>&amp;ldquo;우리가 올바른 제품을 만들고 있는가?&amp;rdquo;&lt;/strong> 라는 질문에 답하는 프로세스로, 개발된 제품이 실제 사용자의 요구사항과 기대를 충족시키는지 확인하는 과정이다.&lt;/p>
&lt;p>사용자 관점에서의 테스트가 주를 이루며, 실제 운영 환경에서의 적합성과 사용성을 중요시한다.&lt;br>
예를 들어, 사용자가 웹사이트에서 원하는 정보를 쉽게 찾을 수 있는지, 모바일 앱의 인터페이스가 직관적인지 등을 확인한다.&lt;/p>
&lt;h3>프로세스와 방법론의 차이&lt;/h3>&lt;p>Verification은 주로 정적 테스팅 방법을 사용한다.&lt;br>
코드 리뷰, 문서 검토, 정적 분석 등이 여기에 해당한다.&lt;br>
Validation은 동적 테스팅 방법을 주로 사용하며, 실제 시스템을 실행하면서 테스트를 수행한다.&lt;br>
사용자 시나리오 테스트, 성능 테스트, 사용성 테스트 등이 이에 해당한다.&lt;/p>
&lt;h3>품질 보증에서의 역할&lt;/h3>&lt;p>두 테스트 방식은 상호 보완적인 관계에 있다.&lt;br>
Verification이 제품의 기술적 완성도를 보장한다면, Validation은 제품의 실용적 가치를 보장한다.&lt;br>
따라서 효과적인 품질 보증을 위해서는 두 가지 접근 방식을 모두 적절히 활용해야 한다.&lt;/p>
&lt;h3>Validation and Verification&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교 기준&lt;/th>
&lt;th>Verification (검증)&lt;/th>
&lt;th>Validation (확인)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>제품을 올바르게 만들고 있는지 검증 (Building the product right)&lt;/td>
&lt;td>올바른 제품을 만들고 있는지 확인 (Building the right product)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>목적&lt;/td>
&lt;td>개발 중인 제품이 명세와 표준을 준수하는지 확인&lt;/td>
&lt;td>개발된 제품이 실제 사용자의 요구사항을 충족하는지 확인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수행 시점&lt;/td>
&lt;td>개발 단계에서 지속적으로 수행&lt;/td>
&lt;td>개발 후반부나 완료 단계에서 수행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수행 주체&lt;/td>
&lt;td>개발팀, QA팀, 테스트 엔지니어&lt;/td>
&lt;td>최종 사용자, 고객, QA팀&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>검증 대상&lt;/td>
&lt;td>코드, 문서, 설계 명세, 기술 표준 준수 여부&lt;/td>
&lt;td>사용자 요구사항, 비즈니스 목표 달성 여부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 활동&lt;/td>
&lt;td>- 코드 리뷰&lt;br>- 정적 분석&lt;br>- 단위 테스트&lt;br>- 통합 테스트&lt;br>- 기술 명세 검토&lt;/td>
&lt;td>- 시스템 테스트&lt;br>- 인수 테스트&lt;br>- 베타 테스트&lt;br>- 사용성 테스트&lt;br>- 성능 테스트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 방식&lt;/td>
&lt;td>- 화이트박스 테스팅&lt;br>- 정적 테스팅&lt;br>- 구조 기반 테스팅&lt;/td>
&lt;td>- 블랙박스 테스팅&lt;br>- 동적 테스팅&lt;br>- 행위 기반 테스팅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>평가 기준&lt;/td>
&lt;td>- 코딩 표준 준수&lt;br>- 기술 명세 충족&lt;br>- 설계 요구사항 만족&lt;/td>
&lt;td>- 사용자 요구사항 충족&lt;br>- 비즈니스 목표 달성&lt;br>- 실제 환경에서의 적합성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 산출물&lt;/td>
&lt;td>- 코드 리뷰 보고서&lt;br>- 테스트 결과 문서&lt;br>- 정적 분석 보고서&lt;br>- 기술 검토 문서&lt;/td>
&lt;td>- 사용자 인수 테스트 보고서&lt;br>- 시스템 테스트 결과&lt;br>- 성능 테스트 보고서&lt;br>- 베타 테스트 피드백&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>오류 발견 시점&lt;/td>
&lt;td>개발 초기 단계에서 발견 가능&lt;/td>
&lt;td>개발 후반부나 실제 사용 단계에서 발견&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>비용 영향&lt;/td>
&lt;td>초기에 문제 발견으로 수정 비용 최소화&lt;/td>
&lt;td>후반부 발견으로 수정 비용이 상대적으로 높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적용 범위&lt;/td>
&lt;td>개별 컴포넌트나 모듈 수준의 검증&lt;/td>
&lt;td>전체 시스템 수준의 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자동화 가능성&lt;/td>
&lt;td>높은 자동화 가능성 (단위 테스트, 정적 분석 등)&lt;/td>
&lt;td>부분적 자동화 가능 (일부 시스템 테스트)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>품질 관점&lt;/td>
&lt;td>내부 품질 (기술적 완성도) 중심&lt;/td>
&lt;td>외부 품질 (사용자 만족도) 중심&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리스크 관리&lt;/td>
&lt;td>기술적 리스크 감소에 중점&lt;/td>
&lt;td>비즈니스 리스크 감소에 중점&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>동적테스트(Dynamic Test)와 정적테스트(Static Test)</title><link>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</link><pubDate>Thu, 28 Nov 2024 02:35:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</guid><description>
&lt;h2>동적테스트(Dynamic Test)와 정적테스트(Static Test)&lt;/h2>&lt;p>동적테스트 (Dynamic Test)과 정적테스트(Static Test)&lt;/p>
&lt;p>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.&lt;br>
이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.&lt;/p>
&lt;p>효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.&lt;br>
예를 들어:&lt;/p>
&lt;ol>
&lt;li>개발 초기 단계:
&lt;ul>
&lt;li>정적 테스팅으로 기본적인 문제 해결&lt;/li>
&lt;li>코드 리뷰로 설계 문제 조기 발견&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 중기:
&lt;ul>
&lt;li>단위 테스트로 개별 기능 검증&lt;/li>
&lt;li>통합 테스트로 모듈 간 상호작용 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>개발 후기:
&lt;ul>
&lt;li>시스템 테스트로 전체 기능 검증&lt;/li>
&lt;li>성능 테스트로 실제 환경 적합성 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>동적 테스트 (Dynamic Test)&lt;/h3>&lt;p>소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.&lt;br>
소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.&lt;br>
소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.&lt;/p>
&lt;h4>동적 테스팅의 기본 원리&lt;/h4>&lt;p>동적 테스팅은 실행 시점의 프로그램 행동을 관찰한다.&lt;br>
프로그램이 실제 환경에서 어떻게 동작하는지, 어떤 결과를 출력하는지, 얼마나 빠르게 처리하는지 등을 직접적으로 확인할 수 있다.&lt;br>
예를 들어, 웹 애플리케이션을 테스트할 때 실제 사용자처럼 로그인을 시도하고 데이터를 입력하면서 시스템의 반응을 검증한다.&lt;/p>
&lt;h4>동적 테스팅의 특징&lt;/h4>&lt;ol>
&lt;li>실행 기반: 프로그램을 실제로 실행하여 메모리 사용, 성능, 보안 취약점, 오류 등을 분석한다.&lt;/li>
&lt;li>테스트 환경: 소프트웨어가 실행될 실제 또는 가상 환경에서 분석이 이루어진다.&lt;/li>
&lt;li>런타임 문제 발견: 메모리 누수, 경쟁 조건, 예외 처리 문제 등 실행 중에만 드러나는 문제를 발견할 수 있다.&lt;/li>
&lt;li>실제 사용 환경 반영: 소프트웨어가 실제로 어떻게 동작하는지, 실제 환경에서의 성능과 안정성을 평가할 수 있다.&lt;/li>
&lt;/ol>
&lt;h4>동적 테스팅의 장점&lt;/h4>&lt;ol>
&lt;li>오류 탐색 정확도 높음: 실제 실행 환경에서 테스트하므로 오류를 정확하게 찾아낼 수 있다.&lt;/li>
&lt;li>실제 사용 시나리오 검증: 사용자 관점에서 소프트웨어의 동작을 검증할 수 있다.&lt;/li>
&lt;li>복잡한 버그 발견: 여러 컴포넌트 간의 상호작용에서 발생하는 복잡한 버그를 찾아낼 수 있다.&lt;/li>
&lt;li>성능 및 보안 평가: 실제 운영 환경에서의 성능을 측정하고 보안 취약점을 발견할 수 있다.&lt;/li>
&lt;li>사용자 경험 검증: 실제 사용자 상호작용을 시뮬레이션하여 사용자 경험을 검증할 수 있다.&lt;/li>
&lt;li>조기 피드백: 개발 과정 초기에 문제를 발견하여 효과적인 개선이 가능하다.&lt;/li>
&lt;/ol>
&lt;h4>동적 테스팅 비교 분석&lt;/h4>&lt;p>각 테스트 방법은 소프트웨어 개발 생명주기의 다른 단계에서 중요한 역할을 한다:&lt;/p>
&lt;ol>
&lt;li>단위 테스트는 개발 초기 단계에서 개별 코드 단위의 정확성을 확인한다.&lt;/li>
&lt;li>통합 테스트는 여러 모듈이 결합될 때 정상적으로 작동하는지 검증한다.&lt;/li>
&lt;li>기능 테스트는 소프트웨어의 기능적 요구사항 충족 여부를 확인한다.&lt;/li>
&lt;li>보안 테스트는 시스템의 취약점을 식별하고 보안 위협을 방지한다.&lt;/li>
&lt;li>성능 테스트는 시스템의 속도, 안정성, 확장성 등을 평가한다.&lt;/li>
&lt;li>수용 테스트는 최종 사용자 관점에서 요구사항 충족 여부를 확인한다.&lt;/li>
&lt;li>스모크 테스트는 빌드의 기본적인 안정성을 빠르게 확인한다.&lt;/li>
&lt;li>엔드투엔드 테스트는 전체 시스템의 흐름을 처음부터 끝까지 검증한다.&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>테스트 유형&lt;/th>
&lt;th>주요 목적&lt;/th>
&lt;th>테스트 범위&lt;/th>
&lt;th>수행 시점&lt;/th>
&lt;th>수행 주체&lt;/th>
&lt;th>특징&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>단위테스트&lt;/td>
&lt;td>개별 구성 요소의 정확성 검증&lt;/td>
&lt;td>함수, 메서드, 클래스 단위&lt;/td>
&lt;td>개발 단계&lt;/td>
&lt;td>개발자&lt;/td>
&lt;td>자동화가 용이, 빠른 피드백 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>통합테스트&lt;/td>
&lt;td>모듈 간 상호작용 검증&lt;/td>
&lt;td>여러 모듈의 결합&lt;/td>
&lt;td>단위테스트 이후&lt;/td>
&lt;td>개발자/QA&lt;/td>
&lt;td>모듈 간 인터페이스 검증에 중점&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>기능테스트&lt;/td>
&lt;td>기능적 요구사항 충족 확인&lt;/td>
&lt;td>개별 기능 단위&lt;/td>
&lt;td>개발 완료 후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>사용자 시나리오 기반 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보안테스트&lt;/td>
&lt;td>보안 취약점 발견&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 후반/운영 중&lt;/td>
&lt;td>보안 전문가&lt;/td>
&lt;td>주기적인 수행 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능테스트&lt;/td>
&lt;td>시스템 성능 검증&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 후반&lt;/td>
&lt;td>성능 테스트 전문가&lt;/td>
&lt;td>특수 도구 활용 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수용테스트&lt;/td>
&lt;td>사용자 요구사항 충족 확인&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>개발 완료 후&lt;/td>
&lt;td>최종 사용자/고객&lt;/td>
&lt;td>실제 사용자 참여 필수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>스모크테스트&lt;/td>
&lt;td>기본 기능 동작 확인&lt;/td>
&lt;td>핵심 기능&lt;/td>
&lt;td>빌드 직후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>빠른 수행, 간단한 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>엔드투엔드테스트&lt;/td>
&lt;td>전체 비즈니스 프로세스 검증&lt;/td>
&lt;td>전체 시스템&lt;/td>
&lt;td>통합 완료 후&lt;/td>
&lt;td>QA 팀&lt;/td>
&lt;td>실제 환경과 유사한 조건에서 수행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>정적 테스트(Static Test)&lt;/h3>&lt;p>프로그램을 실행하지 않고 수행하는 테스트 방식&lt;br>
소프트웨어 개발 과정에서 생산되는 문서(코드, 설계서, 분석서, 계획서, 표준)에 대한 검토를 통해 오류를 발견하는 비실행 기반 테스트.&lt;/p>
&lt;h4>정적 테스팅의 기본 원리&lt;/h4>&lt;p>정적 테스팅은 소프트웨어의 정적 측면, 즉 실행하지 않고도 확인할 수 있는 특성들을 검사한다.&lt;br>
예를 들어, 코딩 표준 준수 여부, 변수 명명 규칙, 들여쓰기 등의 코드 스타일부터 메모리 누수 가능성이나 보안 취약점과 같은 잠재적 문제까지 다양한 측면을 검토한다.&lt;/p>
&lt;h4>정적 테스팅의 특징&lt;/h4>&lt;ol>
&lt;li>코드 실행 없이 수행: 프로그램을 실행하지 않고 소스 코드나 문서를 검토&lt;/li>
&lt;li>조기 결함 발견: 개발 초기 단계에서 잠재적 문제를 식별&lt;/li>
&lt;li>다양한 검토 대상: 코드, 요구사항 문서, 설계 문서 등 다양한 산출물 검토&lt;/li>
&lt;li>수동 및 자동화 방식: 인력에 의한 리뷰와 도구를 이용한 자동 분석 병행&lt;/li>
&lt;li>코딩 표준 준수 확인: 코딩 규칙, 가이드라인 준수 여부 검사&lt;/li>
&lt;/ol>
&lt;h4>정적 테스팅의 장점&lt;/h4>&lt;ol>
&lt;li>조기 결함 발견: 개발 초기에 문제를 발견하여 수정 비용과 시간 절감&lt;/li>
&lt;li>비용 효율성: 동적 테스팅에 비해 적은 비용으로 결함 발견 가능&lt;/li>
&lt;li>코드 품질 향상: 코딩 표준 준수와 구조적 문제 해결로 전반적인 코드 품질 개선&lt;/li>
&lt;li>보안성 강화: 보안 취약점을 조기에 발견하고 수정 가능&lt;/li>
&lt;li>개발 생산성 향상: 결함의 조기 발견으로 개발 과정의 효율성 증대&lt;/li>
&lt;li>협업 개선: 코드 리뷰를 통한 팀원 간 지식 공유와 의사소통 촉진&lt;/li>
&lt;li>테스트 범위 확대: 동적 테스팅으로 발견하기 어려운 결함 식별 가능&lt;/li>
&lt;/ol>
&lt;h4>정적 테스팅 비교 분석&lt;/h4>&lt;h5>Reviews (리뷰)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Informal Review&lt;/td>
&lt;td>• 공식적인 절차 없이 진행되는 검토 방식&lt;br>• 개발자 간 자유로운 토론과 피드백&lt;/td>
&lt;td>• 절차와 문서화 최소화&lt;br>• 빠른 피드백&lt;br>• 자유로운 의견 교환&lt;/td>
&lt;td>• 즉각적인 피드백 가능&lt;br>• 팀 내 지식 공유 촉진&lt;br>• 낮은 진입 장벽&lt;/td>
&lt;td>• 체계적인 추적이 어려움&lt;br>• 검토 누락 가능성&lt;br>• 품질 보증의 공식적 증거로 부족&lt;/td>
&lt;td>• 일상적인 코드 검토&lt;br>• quick fix 검증&lt;br>• 소규모 변경사항 검토&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Technical Review&lt;/td>
&lt;td>• 기술적 관점에서의 상세 검토&lt;br>• 동료 검토 중심의 체계적 접근&lt;/td>
&lt;td>• 기술적 완성도 중점&lt;br>• 대안 제시&lt;br>• 체크리스트 활용&lt;/td>
&lt;td>• 기술적 결함 조기 발견&lt;br>• 설계 개선 기회 제공&lt;br>• 기술 표준 준수 확인&lt;/td>
&lt;td>• 많은 시간과 자원 소요&lt;br>• 참여자의 전문성 필요&lt;br>• 범위 설정의 어려움&lt;/td>
&lt;td>• 아키텍처 검토&lt;br>• 성능 최적화 검증&lt;br>• 보안 취약점 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Walkthrough&lt;/td>
&lt;td>• 작성자가 주도하는 단계별 검토&lt;br>• 교육적 효과 중시&lt;/td>
&lt;td>• 시나리오 기반 검토&lt;br>• 상호 학습 기회&lt;br>• 단계별 설명&lt;/td>
&lt;td>• 지식 전파 효과적&lt;br>• 팀 이해도 향상&lt;br>• 새로운 관점 발견&lt;/td>
&lt;td>• 작성자 편향 가능성&lt;br>• 시간 소요가 큼&lt;br>• 객관성 확보 어려움&lt;/td>
&lt;td>• 신규 팀원 교육&lt;br>• 복잡한 로직 설명&lt;br>• 프로세스 이해&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Inspection&lt;/td>
&lt;td>• 가장 공식적이고 체계적인 검토&lt;br>• 철저한 문서화와 추적&lt;/td>
&lt;td>• 역할 분담 명확&lt;br>• 체계적 절차&lt;br>• 상세한 문서화&lt;/td>
&lt;td>• 높은 결함 발견율&lt;br>• 품질 보증 증거 확보&lt;br>• 체계적 개선 가능&lt;/td>
&lt;td>• 높은 비용과 시간&lt;br>• 과도한 문서화 부담&lt;br>• 유연성 부족&lt;/td>
&lt;td>• 중요 시스템 검증&lt;br>• 품질 인증 준비&lt;br>• 규제 준수 확인&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>Static Analysis (정적 분석)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Syntax Analysis&lt;/td>
&lt;td>• 코드의 문법적 오류 검출&lt;br>• 컴파일러 수준의 검사&lt;/td>
&lt;td>• 자동화된 검사&lt;br>• 즉각적 피드백&lt;br>• 기본적 오류 검출&lt;/td>
&lt;td>• 빠른 오류 발견&lt;br>• 개발 생산성 향상&lt;br>• 기본적 품질 보장&lt;/td>
&lt;td>• 의미적 오류 발견 불가&lt;br>• 단순 오류만 검출&lt;br>• 컨텍스트 이해 부족&lt;/td>
&lt;td>• 컴파일 전 검사&lt;br>• IDE 통합 검사&lt;br>• 기본 코드 검증&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Data Flow Analysis&lt;/td>
&lt;td>• 데이터의 흐름과 사용 패턴 분석&lt;br>• 변수 사용의 적절성 검증&lt;/td>
&lt;td>• 변수 추적&lt;br>• 초기화 검사&lt;br>• 사용 패턴 분석&lt;/td>
&lt;td>• 데이터 관련 버그 발견&lt;br>• 메모리 누수 방지&lt;br>• 안정성 향상&lt;/td>
&lt;td>• 분석 비용 높음&lt;br>• 오탐 가능성&lt;br>• 복잡한 패턴 분석 어려움&lt;/td>
&lt;td>• 메모리 관리 검증&lt;br>• 변수 사용 분석&lt;br>• 초기화 오류 검출&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Control Flow Analysis&lt;/td>
&lt;td>• 프로그램 실행 경로 분석&lt;br>• 로직 흐름 검증&lt;/td>
&lt;td>• 경로 분석&lt;br>• 도달성 검사&lt;br>• 순환 복잡도 측정&lt;/td>
&lt;td>• 논리적 오류 발견&lt;br>• 코드 복잡도 관리&lt;br>• 실행 경로 최적화&lt;/td>
&lt;td>• 동적 경로 예측 한계&lt;br>• 복잡한 조건 분석 어려움&lt;br>• 성능 오버헤드&lt;/td>
&lt;td>• 분기문 검증&lt;br>• 데드코드 탐지&lt;br>• 복잡도 측정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Code Quality Analysis&lt;/td>
&lt;td>• 코딩 표준 준수 여부 검사&lt;br>• 품질 메트릭스 측정&lt;/td>
&lt;td>• 표준 준수 검사&lt;br>• 메트릭스 측정&lt;br>• 품질 지표 산출&lt;/td>
&lt;td>• 일관된 코드 품질&lt;br>• 유지보수성 향상&lt;br>• 객관적 품질 평가&lt;/td>
&lt;td>• 맥락 이해 부족&lt;br>• 과도한 규칙 적용&lt;br>• 거짓 양성 보고&lt;/td>
&lt;td>• 코딩 표준 검증&lt;br>• 품질 지표 측정&lt;br>• 리팩토링 대상 식별&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>Formal Methods (정형 기법)&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>분류&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Model Checking&lt;/td>
&lt;td>• 시스템 모델의 수학적 검증&lt;br>• 상태 공간 탐색&lt;/td>
&lt;td>• 형식적 검증&lt;br>• 전수 검사&lt;br>• 자동화된 분석&lt;/td>
&lt;td>• 완벽한 검증 가능&lt;br>• 중요 속성 보장&lt;br>• 숨은 오류 발견&lt;/td>
&lt;td>• 높은 복잡도&lt;br>• 전문성 요구&lt;br>• 큰 시스템에 적용 어려움&lt;/td>
&lt;td>• 안전중심 시스템&lt;br>• 프로토콜 검증&lt;br>• 동시성 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Theorem Proving&lt;/td>
&lt;td>• 수학적 증명을 통한 검증&lt;br>• 논리적 정확성 입증&lt;/td>
&lt;td>• 수학적 엄밀성&lt;br>• 형식적 명세&lt;br>• 증명 기반 접근&lt;/td>
&lt;td>• 절대적 정확성&lt;br>• 핵심 속성 보장&lt;br>• 수학적 완전성&lt;/td>
&lt;td>• 매우 높은 비용&lt;br>• 전문가 필요&lt;br>• 실용성 제한적&lt;/td>
&lt;td>• 핵심 알고리즘 검증&lt;br>• 보안 프로토콜&lt;br>• 미션크리티컬 시스템&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>마이그레이션 (Migration)</title><link>https://buenhyden.github.io/til/2024/11/migration/</link><pubDate>Tue, 26 Nov 2024 15:05:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/migration/</guid><description>
&lt;h2>마이그레이션 (Migration)&lt;/h2>&lt;p>마이그레이션(Migration)은 IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정을 의미한다.&lt;/p>
&lt;p>마이그레이션은 기존 시스템 환경에서 새로운 환경으로 전환하는 것을 의미한다.&lt;br>
주요 목적은 비즈니스 선진화와 비용 절감, 시스템 성능 향상, 보안 강화 등이다.&lt;/p>
&lt;h3>마이그레이션의 유형&lt;/h3>&lt;ol>
&lt;li>데이터 마이그레이션: 데이터를 한 스토리지에서 다른 스토리지로 이동.&lt;/li>
&lt;li>애플리케이션 마이그레이션: 소프트웨어를 새로운 환경으로 이동.&lt;/li>
&lt;li>클라우드 마이그레이션: 온프레미스에서 클라우드로, 또는 클라우드 간 이동.&lt;/li>
&lt;li>비즈니스 프로세스 마이그레이션: 비즈니스 운영 방식 최적화를 위한 이동.&lt;/li>
&lt;/ol>
&lt;h3>마이그레이션 전략 (6R)&lt;/h3>&lt;ol>
&lt;li>Rehost (리호스팅): 애플리케이션 구조 변경 없이 클라우드로 전환&lt;/li>
&lt;li>Replatform (리플랫폼): 클라우드 환경의 일부 서비스를 활용하여 전환&lt;/li>
&lt;li>Refactor (리팩터): 클라우드 환경에 적합하게 애플리케이션 구조 변경&lt;/li>
&lt;li>Repurchase (리퍼체이스): 기존 시스템을 SaaS로 대체&lt;/li>
&lt;li>Retire (리타이어): 기존 시스템 폐기&lt;/li>
&lt;li>Retain (리테인): 현 상태 유지&lt;/li>
&lt;/ol>
&lt;h3>마이그레이션 과정&lt;/h3>&lt;ol>
&lt;li>계획: 요구사항 분석, 목표 설정, 전략 수립&lt;/li>
&lt;li>실행: 데이터 또는 시스템 이전&lt;/li>
&lt;li>검증: 이전된 데이터나 시스템의 정확성 및 성능 확인&lt;/li>
&lt;/ol>
&lt;h3>주의사항&lt;/h3>&lt;ol>
&lt;li>데이터 손실 위험: 마이그레이션 중 데이터 손실 가능성 고려&lt;/li>
&lt;li>보안: 데이터 암호화 및 보안 조치 필요&lt;/li>
&lt;li>호환성: 새 환경과의 호환성 확인&lt;/li>
&lt;li>성능: 마이그레이션 후 성능 저하 가능성 고려&lt;/li>
&lt;li>비용: 예상치 못한 추가 비용 발생 가능성&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>API Gateway</title><link>https://buenhyden.github.io/til/2024/11/api-gateway/</link><pubDate>Tue, 26 Nov 2024 09:40:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/api-gateway/</guid><description>
&lt;h2>API Gateway&lt;/h2>&lt;p>클라이언트와 백엔드 서비스 사이에서 중개자 역할을 하는 서버로, 여러 마이크로서비스나 백엔드 시스템에 대한 단일 진입점을 제공하는 중요한 컴포넌트&lt;/p>
&lt;h3>주요 기능&lt;/h3>&lt;ol>
&lt;li>
&lt;p>요청 라우팅 및 프록시&lt;br>
API Gateway는 클라이언트의 요청을 받아 적절한 백엔드 서비스로 라우팅한다.&lt;br>
이는 여러 마이크로서비스의 엔드포인트를 단일화하여 관리를 용이하게 한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>인증 및 권한 부여&lt;br>
클라이언트의 요청에 대한 인증(Authentication)과 권한 부여(Authorization)를 처리한다.&lt;br>
이를 통해 각 마이크로서비스에서 중복으로 보안 로직을 구현할 필요가 없어진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>프로토콜 변환&lt;br>
클라이언트와 서버 간의 다양한 프로토콜을 지원하고 필요에 따라 변환한다.&lt;br>
예를 들어, REST API와 WebSocket API를 모두 지원할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>로드 밸런싱&lt;br>
여러 백엔드 서버로 트래픽을 분산시켜 시스템의 부하를 관리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>캐싱&lt;br>
자주 요청되는 데이터를 캐시하여 응답 시간을 개선하고 백엔드 서버의 부하를 줄인다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>모니터링 및 로깅&lt;br>
API 호출에 대한 모니터링과 로깅을 중앙에서 관리한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;/h3>&lt;ol>
&lt;li>&lt;strong>단일 진입점&lt;/strong>: 클라이언트는 여러 서비스에 대해 하나의 엔드포인트만 알면 된다.&lt;/li>
&lt;li>&lt;strong>보안 강화&lt;/strong>: 인증, 권한 부여 등의 보안 기능을 중앙에서 관리할 수 있다.&lt;/li>
&lt;li>&lt;strong>캡슐화&lt;/strong>: 내부 시스템 구조를 클라이언트로부터 숨길 수 있다.&lt;/li>
&lt;li>&lt;strong>성능 최적화&lt;/strong>: 캐싱, 로드 밸런싱 등을 통해 전체 시스템의 성능을 향상시킬 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>단점&lt;/h3>&lt;ol>
&lt;li>&lt;strong>단일 장애 지점&lt;/strong>: API Gateway 자체가 다운되면 전체 시스템에 영향을 줄 수 있다.&lt;/li>
&lt;li>&lt;strong>추가 네트워크 홉&lt;/strong>: API Gateway를 거치는 추가적인 네트워크 홉으로 인해 약간의 지연이 발생할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>구현 방식&lt;/h3>&lt;ol>
&lt;li>&lt;strong>오픈소스 솔루션&lt;/strong>: 직접 운영하는 방식으로, 커스터마이징이 가능하지만 관리 부담이 있다.&lt;/li>
&lt;li>&lt;strong>클라우드 서비스&lt;/strong>: AWS API Gateway, Azure API Management 등의 관리형 서비스를 이용하는 방식&lt;/li>
&lt;/ol>
&lt;h3>사용 사례&lt;/h3>&lt;ol>
&lt;li>&lt;strong>마이크로서비스 아키텍처&lt;/strong>: 여러 마이크로서비스를 하나의 API로 통합하여 제공한다.&lt;/li>
&lt;li>&lt;strong>레거시 시스템 통합&lt;/strong>: 기존 레거시 시스템과 새로운 서비스를 통합하는 인터페이스로 사용된다.&lt;/li>
&lt;li>&lt;strong>멀티 클라우드 환경&lt;/strong>: 여러 클라우드 환경에 분산된 서비스를 단일 인터페이스로 제공한다.&lt;/li>
&lt;/ol>
&lt;p>API Gateway는 현대적인 분산 시스템 아키텍처에서 중요한 역할을 하며, 시스템의 확장성, 보안, 성능을 향상시키는 데 크게 기여한다.&lt;br>
그러나 구현 시 단일 장애 지점이 되지 않도록 주의해야 하며, 적절한 모니터링과 관리가 필요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>ER(Entity-Relationship) 모델링</title><link>https://buenhyden.github.io/til/2024/11/entity-relationship-modeling/</link><pubDate>Mon, 25 Nov 2024 02:06:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/entity-relationship-modeling/</guid><description>
&lt;h2>ER(Entity-Relationship) 모델링&lt;/h2>&lt;p>ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.&lt;br>
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/TIL/2024/11/1024px-ER_Diagram_MMORPG.png"
alt="An entity–attribute-relationship diagram for an MMORPG using Chens notation"
loading="lazy" />
&lt;/figure>&lt;br>
&lt;em>Source: &lt;a href="https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png&lt;/a>&lt;/em>&lt;/p>
&lt;h3>주요 구성 요소&lt;/h3>&lt;ol>
&lt;li>개체(Entity)&lt;br>
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.&lt;br>
예를 들어, &amp;lsquo;학생&amp;rsquo;, &amp;lsquo;강좌&amp;rsquo;, &amp;lsquo;교수&amp;rsquo; 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.&lt;br>
예시:&lt;br>
학생 개체의 경우:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>실체: 개별 학생들&lt;/li>
&lt;li>표현: &amp;lsquo;학생&amp;rsquo; 이라는 개체로 모델링&lt;/li>
&lt;li>속성: 학번, 이름, 학과, 연락처 등&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>속성(Attribute)&lt;br>
속성은 개체의 특성이나 성질을 나타낸다.&lt;br>
타원형으로 표현되며, 개체와 선으로 연결된다.&lt;br>
속성의 종류:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>단일값 속성: 하나의 값만 가지는 속성 (예: 학번)&lt;/li>
&lt;li>다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호)&lt;/li>
&lt;li>유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이)&lt;/li>
&lt;li>키 속성: 개체를 유일하게 식별하는 속성 (예: 학번)&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>관계(Relationship)&lt;br>
관계는 개체들 간의 연관성을 나타낸다.&lt;br>
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.&lt;br>
관계의 종류:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결&lt;/li>
&lt;li>일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결&lt;/li>
&lt;li>다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결&lt;br>
관계 표현 예시:&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>[학생] ----&amp;lt; 수강 &amp;gt;---- [강좌]
| |
(학번) (과목코드)
(이름) (과목명)
(학과) (학점)&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>ER 모델링의 단계&lt;/h3>&lt;ol>
&lt;li>
&lt;p>요구사항 분석&lt;br>
시스템에서 필요한 데이터와 기능을 파악한다.&lt;br>
예: &amp;ldquo;대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>개체 식별&lt;br>
주요 데이터 개체들을 파악한다.&lt;br>
예: 학생, 강좌, 교수, 학과 등&lt;/p>
&lt;/li>
&lt;li>
&lt;p>속성 정의&lt;br>
각 개체의 특성을 정의한다.&lt;br>
예: 학생(학번, 이름, 학과, 연락처)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>관계 설정&lt;br>
개체들 간의 관계를 정의한다.&lt;br>
예: 학생 - 수강 - 강좌 (다대다 관계)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>제약조건 정의&lt;br>
데이터의 무결성을 위한 제약조건을 설정한다.&lt;br>
예: &amp;ldquo;학생은 최대 6과목까지만 수강할 수 있다&amp;rdquo;&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>실제 적용 예시&lt;/h3>&lt;p>대학 수강신청 시스템의 ER 모델:&lt;/p>
&lt;p>개체:&lt;/p>
&lt;ul>
&lt;li>학생(학번, 이름, 학과, 연락처)&lt;/li>
&lt;li>강좌(과목코드, 과목명, 학점, 수강정원)&lt;/li>
&lt;li>교수(교수번호, 이름, 학과, 연구실)&lt;/li>
&lt;/ul>
&lt;p>관계:&lt;/p>
&lt;ul>
&lt;li>수강(학생-강좌): 다대다 관계&lt;/li>
&lt;li>담당(교수-강좌): 일대다 관계&lt;/li>
&lt;li>소속(학생-학과): 다대일 관계&lt;/li>
&lt;/ul>
&lt;p>제약조건:&lt;/p>
&lt;ul>
&lt;li>학생은 한 학기에 최대 18학점까지 수강 가능&lt;/li>
&lt;li>각 강좌는 반드시 한 명의 담당 교수가 있어야 함&lt;/li>
&lt;li>강좌별 수강 인원은 수강정원을 초과할 수 없음&lt;/li>
&lt;/ul>
&lt;h3>ER 모델링의 장점&lt;/h3>&lt;ol>
&lt;li>
&lt;p>직관적 이해&lt;br>
시각적 표현을 통해 시스템의 구조를 쉽게 이해할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>의사소통 도구&lt;br>
개발자, 사용자, 관리자 간의 효과적인 의사소통을 가능하게 한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>설계 검증&lt;br>
데이터베이스 구현 전에 설계상의 문제를 발견하고 수정할 수 있다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Software Architecture pattern and Software Design Pattern</title><link>https://buenhyden.github.io/til/2024/11/software-architecture-pattern-and-software-design-pattern/</link><pubDate>Sat, 23 Nov 2024 08:19:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/software-architecture-pattern-and-software-design-pattern/</guid><description>
&lt;h2>Software Architecture Pattern and Software Design Pattern&lt;/h2>&lt;p>Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.&lt;br>
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교 항목&lt;/th>
&lt;th>Software Architecture Pattern&lt;/th>
&lt;th>Software Design Pattern&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴&lt;/td>
&lt;td>특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>범위&lt;/td>
&lt;td>시스템 전체 또는 대규모 하위 시스템&lt;/td>
&lt;td>개별 컴포넌트나 모듈 수준&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추상화 수준&lt;/td>
&lt;td>높은 수준의 추상화&lt;/td>
&lt;td>상대적으로 낮은 수준의 추상화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>목적&lt;/td>
&lt;td>시스템의 전반적인 구조와 상호작용 정의&lt;/td>
&lt;td>특정 설계 문제에 대한 해결책 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>영향&lt;/td>
&lt;td>전체 시스템의 성능, 확장성, 유지보수성에 영향&lt;/td>
&lt;td>코드의 구조, 품질, 재사용성에 영향&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예시&lt;/td>
&lt;td>마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처&lt;/td>
&lt;td>싱글톤, 팩토리, 옵저버, 전략 패턴&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적용 시점&lt;/td>
&lt;td>시스템 설계 초기 단계&lt;/td>
&lt;td>상세 설계 및 구현 단계&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유연성&lt;/td>
&lt;td>시스템 수준의 변경에 대한 유연성 제공&lt;/td>
&lt;td>컴포넌트 수준의 변경에 대한 유연성 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>재사용성&lt;/td>
&lt;td>전체 시스템 구조의 재사용&lt;/td>
&lt;td>특정 문제 해결 방식의 재사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡성&lt;/td>
&lt;td>시스템 전체의 복잡성 관리&lt;/td>
&lt;td>특정 설계 문제의 복잡성 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>문서화&lt;/td>
&lt;td>시스템 아키텍처 다이어그램, 컴포넌트 명세&lt;/td>
&lt;td>클래스 다이어그램, 시퀀스 다이어그램&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 고려사항&lt;/td>
&lt;td>확장성, 성능, 보안, 유지보수성&lt;/td>
&lt;td>코드 재사용, 유연성, 결합도, 응집도&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</title><link>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous-and-blocking-and-non-blocking/</link><pubDate>Sun, 17 Nov 2024 12:30:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous-and-blocking-and-non-blocking/</guid><description>
&lt;h2>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>카테고리&lt;/th>
&lt;th>동기(Synchronous)&lt;/th>
&lt;th>비동기(Asynchronous)&lt;/th>
&lt;th>Blocking&lt;/th>
&lt;th>Non-Blocking&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>핵심 개념&lt;/strong>&lt;/td>
&lt;td>작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업을 시작하지 않음&lt;/td>
&lt;td>작업들이 독립적으로 실행되며, 이전 작업의 완료를 기다리지 않고 다음 작업 수행 가능&lt;/td>
&lt;td>호출된 함수가 작업을 완료할 때까지 제어권을 반환하지 않음&lt;/td>
&lt;td>호출된 함수가 작업 완료 여부와 관계없이 즉시 제어권을 반환함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>작업 처리 방식&lt;/strong>&lt;/td>
&lt;td>순차적으로 작업을 처리하며, 각 작업이 완료된 후 다음 작업 시작&lt;/td>
&lt;td>여러 작업이 동시에 처리될 수 있으며, 작업 완료 순서는 불확실할 수 있음&lt;/td>
&lt;td>호출한 함수는 작업이 완료될 때까지 대기 상태 유지&lt;/td>
&lt;td>호출한 함수는 작업 진행 중에도 다른 작업 수행 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>제어 흐름&lt;/strong>&lt;/td>
&lt;td>프로그램의 제어 흐름이 순차적이고 예측 가능함&lt;/td>
&lt;td>제어 흐름이 비선형적이며, 콜백이나 이벤트로 처리&lt;/td>
&lt;td>제어권이 호출된 함수에 완전히 넘어감&lt;/td>
&lt;td>제어권이 호출한 함수에 즉시 반환됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>결과 처리&lt;/strong>&lt;/td>
&lt;td>작업 완료 후 바로 결과를 반환받아 처리&lt;/td>
&lt;td>콜백 함수, Promise, async/await 등을 통해 결과 처리&lt;/td>
&lt;td>결과를 직접 반환받아 처리&lt;/td>
&lt;td>상태 확인이나 콜백을 통해 결과 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>주요 특징&lt;/strong>&lt;/td>
&lt;td>- 코드의 실행 순서가 명확함&lt;br>- 직관적인 코드 흐름&lt;br>- 단순한 구현&lt;/td>
&lt;td>- 작업의 병렬 처리 가능&lt;br>- 복잡한 이벤트 처리&lt;br>- 높은 확장성&lt;/td>
&lt;td>- 자원을 점유하며 대기&lt;br>- 단순한 구현&lt;br>- 예측 가능한 실행&lt;/td>
&lt;td>- 자원의 효율적 활용&lt;br>- 복잡한 구현&lt;br>- 높은 동시성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 처리&lt;/strong>&lt;/td>
&lt;td>try-catch 블록으로 즉시 에러 처리 가능&lt;/td>
&lt;td>Promise의 catch나 async/await의 try-catch로 처리&lt;/td>
&lt;td>동기적 에러 처리 가능&lt;/td>
&lt;td>비동기적 에러 처리 메커니즘 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능 특성&lt;/strong>&lt;/td>
&lt;td>- 단순 작업에서 오버헤드 적음&lt;br>- 순차 처리로 인한 대기 시간 발생&lt;/td>
&lt;td>- 동시 처리로 인한 전체 처리 시간 감소&lt;br>- 컨텍스트 스위칭 오버헤드&lt;/td>
&lt;td>- I/O 작업에서 성능 저하&lt;br>- 리소스 독점&lt;/td>
&lt;td>- 리소스 효율적 활용&lt;br>- 높은 처리량&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적합한 사용 사례&lt;/strong>&lt;/td>
&lt;td>- 간단한 계산 작업&lt;br>- 메모리 내 데이터 처리&lt;br>- 순차적 처리 필요 작업&lt;/td>
&lt;td>- 네트워크 요청&lt;br>- 대용량 파일 처리&lt;br>- 독립적 실행 가능 작업&lt;/td>
&lt;td>- CPU 연산 작업&lt;br>- 간단한 파일 작업&lt;br>- 메모리 작업&lt;/td>
&lt;td>- I/O 작업&lt;br>- 네트워크 통신&lt;br>- 대용량 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>실행 순서&lt;/strong>&lt;/td>
&lt;td>코드 작성 순서와 실행 순서가 동일&lt;/td>
&lt;td>실행 순서가 코드 작성 순서와 다를 수 있음&lt;/td>
&lt;td>작업 완료 순서가 예측 가능&lt;/td>
&lt;td>작업 완료 순서가 불확실&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>자원 활용&lt;/strong>&lt;/td>
&lt;td>단일 자원을 순차적으로 사용&lt;/td>
&lt;td>여러 자원을 동시에 효율적으로 활용&lt;/td>
&lt;td>자원을 독점적으로 사용&lt;/td>
&lt;td>자원을 공유하여 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>응답성&lt;/strong>&lt;/td>
&lt;td>작업 완료 전까지 다른 작업 불가&lt;/td>
&lt;td>여러 작업의 동시 처리로 높은 응답성&lt;/td>
&lt;td>대기 시간 동안 응답 불가&lt;/td>
&lt;td>지속적인 응답 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>디버깅&lt;/strong>&lt;/td>
&lt;td>코드 흐름 추적이 용이함&lt;/td>
&lt;td>비동기 로직으로 인한 디버깅 어려움&lt;/td>
&lt;td>문제 발생 지점 파악 쉬움&lt;/td>
&lt;td>문제 발생 지점 추적 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>확장성&lt;/strong>&lt;/td>
&lt;td>수직적 확장에 제한적&lt;/td>
&lt;td>수평적/수직적 확장 용이&lt;/td>
&lt;td>동시 처리 능력 제한적&lt;/td>
&lt;td>높은 동시성 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>데이터 일관성&lt;/strong>&lt;/td>
&lt;td>데이터 일관성 보장이 쉬움&lt;/td>
&lt;td>경쟁 조건 고려 필요&lt;/td>
&lt;td>순차적 처리로 일관성 보장&lt;/td>
&lt;td>동시성 제어 메커니즘 필요&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>추가적인 고려사항:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>시스템 설계 시 고려사항:&lt;/p>
&lt;ul>
&lt;li>시스템의 목적과 요구사항&lt;/li>
&lt;li>예상되는 부하와 처리량&lt;/li>
&lt;li>확장성 요구사항&lt;/li>
&lt;li>유지보수 용이성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 최적화:&lt;/p>
&lt;ul>
&lt;li>작업의 특성에 따른 적절한 방식 선택&lt;/li>
&lt;li>리소스 사용량 모니터링&lt;/li>
&lt;li>병목 현상 관리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>개발 복잡도:&lt;/p>
&lt;ul>
&lt;li>팀의 기술적 역량&lt;/li>
&lt;li>유지보수 가능성&lt;/li>
&lt;li>디버깅 용이성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주요 차이점 분석&lt;/h3>&lt;h4>제어 흐름의 관점&lt;/h4>&lt;p>동기/비동기는 &lt;strong>작업의 실행 순서와 완료 시점&lt;/strong>에 관한 것.&lt;br>
반면 Blocking/Non-Blocking은 제어권의 반환 시점에 관한 것이다.&lt;/p>
&lt;h4>성능과 자원 활용&lt;/h4>&lt;ul>
&lt;li>&lt;strong>동기&lt;/strong>: 순차적 실행으로 자원 사용이 효율적이지 않을 수 있다.&lt;/li>
&lt;li>&lt;strong>비동기&lt;/strong>: 병렬 처리로 자원을 효율적으로 활용할 수 있다.&lt;/li>
&lt;li>&lt;strong>Blocking&lt;/strong>: 대기 시간 동안 자원이 낭비될 수 있다.&lt;/li>
&lt;li>&lt;strong>Non-Blocking&lt;/strong>: 대기 시간을 다른 작업에 활용할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4>구현 복잡도&lt;/h4>&lt;p>동기와 Blocking 방식은 구현이 상대적으로 단순한 반면, 비동기와 Non-Blocking 방식은 콜백이나 이벤트 처리 등으로 인해 구현이 복잡할 수 있다.&lt;/p>
&lt;h3>조합별 비교 및 예시&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>동기 + Blocking&lt;/th>
&lt;th>동기 + Non-Blocking&lt;/th>
&lt;th>비동기 + Blocking&lt;/th>
&lt;th>비동기 + Non-Blocking&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>특징&lt;/strong>&lt;/td>
&lt;td>- 가장 단순한 실행 모델&lt;br>- 직관적인 코드 흐름&lt;br>- 순차적 실행 보장&lt;/td>
&lt;td>- 동기적 실행 흐름 유지&lt;br>- 리소스 점유 최소화&lt;br>Polling 방식 사용&lt;/td>
&lt;td>- Promise나 async/await 사용&lt;br>- 실행 순서 보장&lt;br>- 비동기 작업 대기&lt;/td>
&lt;td>- 가장 유연한 실행 모델&lt;br>- 높은 리소스 활용도&lt;br>- 이벤트 기반 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>장점&lt;/strong>&lt;/td>
&lt;td>- 구현이 단순&lt;br>- 디버깅 용이&lt;br>- 결과 예측 쉬움&lt;/td>
&lt;td>- 리소스 효율성&lt;br>- 응답성 유지&lt;br>- 동기 코드 장점 유지&lt;/td>
&lt;td>- 비동기 코드의 동기적 처리&lt;br>- 에러 처리 용이&lt;br>- 코드 가독성 좋음&lt;/td>
&lt;td>- 최고의 성능&lt;br>- 높은 확장성&lt;br>- 리소스 효율적 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>단점&lt;/strong>&lt;/td>
&lt;td>- 리소스 비효율적&lt;br>- 성능 저하&lt;br>- 응답성 저하&lt;/td>
&lt;td>- 구현 복잡도 증가&lt;br>CPU 사용률 증가&lt;br>Polling 오버헤드&lt;/td>
&lt;td>- 스레드 블로킹&lt;br>- 병렬 처리 제한&lt;br>- 성능 제약&lt;/td>
&lt;td>- 복잡한 에러 처리&lt;br>- 디버깅 어려움&lt;br>- 콜백 지옥 가능성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적합한 시나리오&lt;/strong>&lt;/td>
&lt;td>- 단순한 계산 작업&lt;br>- 메모리 내 연산&lt;br>- 설정 파일 로딩&lt;/td>
&lt;td>- 주기적 상태 확인&lt;br>- 실시간 모니터링&lt;br>- 센서 데이터 처리&lt;/td>
&lt;td>- 순차적 API 호출&lt;br>- 데이터베이스 트랜잭션&lt;br>- 의존적 비동기 작업&lt;/td>
&lt;td>- 웹 서버&lt;br>- 실시간 애플리케이션&lt;br>- 대용량 I/O 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>주의사항&lt;/strong>&lt;/td>
&lt;td>- 긴 작업 시 시스템 블로킹&lt;br>- 타임아웃 처리 필요&lt;br>- 리소스 고려&lt;/td>
&lt;td>- 무한 루프 주의&lt;br>CPU 사용량 모니터링&lt;br>- 폴링 간격 최적화&lt;/td>
&lt;td>- 데드락 가능성&lt;br>- 메모리 누수 주의&lt;br>- 타임아웃 설정&lt;/td>
&lt;td>- 상태 관리 복잡성&lt;br>- 동시성 제어&lt;br>- 메모리 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>동작 방식&lt;/strong>&lt;/td>
&lt;td>- 순차적 실행&lt;br>- 작업 완료까지 대기&lt;br>- 직접 결과 반환&lt;/td>
&lt;td>- 상태 확인 루프&lt;br>- 작업 병행 처리&lt;br>- 폴링 기반 결과 확인&lt;/td>
&lt;td>- 비동기 호출 후 대기&lt;br>Promise 기반 처리&lt;br>await 사용&lt;/td>
&lt;td>- 이벤트 루프 활용&lt;br>- 콜백 기반 처리&lt;br>- 비동기 이벤트 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>추가적인 구현 시 고려사항:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>에러 처리:&lt;/p>
&lt;ul>
&lt;li>동기 + Blocking: try-catch 직접 사용&lt;/li>
&lt;li>동기 + Non-Blocking: 상태 확인 시 에러 체크&lt;/li>
&lt;li>비동기 + Blocking: try-catch와 async/await 사용&lt;/li>
&lt;li>비동기 + Non-Blocking: 콜백의 에러 파라미터 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 최적화:&lt;/p>
&lt;ul>
&lt;li>동기 + Blocking: 작업 크기 최소화&lt;/li>
&lt;li>동기 + Non-Blocking: 폴링 간격 최적화&lt;/li>
&lt;li>비동기 + Blocking: 병렬 처리 가능성 검토&lt;/li>
&lt;li>비동기 + Non-Blocking: 이벤트 루프 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>리소스 관리:&lt;/p>
&lt;ul>
&lt;li>동기 + Blocking: 타임아웃 설정&lt;/li>
&lt;li>동기 + Non-Blocking: CPU 사용량 모니터링&lt;/li>
&lt;li>비동기 + Blocking: 메모리 누수 방지&lt;/li>
&lt;li>비동기 + Non-Blocking: 동시성 제어&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>각 조합의 선택은 애플리케이션의 요구사항, 성능 목표, 개발 팀의 역량 등을 종합적으로 고려하여 결정해야 한다.&lt;/p>
&lt;h4>예시&lt;/h4>&lt;ol>
&lt;li>동기(Synchronous) + Blocking&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 동기 + Blocking 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">syncBlockingExample&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1. 작업 시작&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 동기적으로 실행되며, 작업이 완료될 때까지 블로킹됨
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">fs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">readFileSync&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;example.txt&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;utf8&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 파일 읽기가 완료된 후에만 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2. 파일 내용:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 순차적으로 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;3. 작업 완료&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>동기(Synchronous) + Non-Blocking&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 동기 + Non-Blocking 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">syncNonBlockingExample&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1. 작업 시작&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 동기적이지만 블로킹하지 않음
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">let&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 작업 상태 확인 (polling)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">checkOperationStatus&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 다른 작업 수행 가능
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">doOtherWork&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2. 결과:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;3. 작업 완료&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="3">
&lt;li>비동기(Asynchronous) + Blocking&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 비동기 + Blocking 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">async&lt;/span> &lt;span class="kd">function&lt;/span> &lt;span class="nx">asyncBlockingExample&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1. 작업 시작&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 비동기 호출이지만 결과를 기다림 (블로킹)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kr">const&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kr">await&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Promise&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">resolve&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 비동기 작업 수행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">setTimeout&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">resolve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;작업 결과&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 블로킹되어 기다린 후 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2. 결과:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;3. 작업 완료&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="4">
&lt;li>비동기(Asynchronous) + Non-Blocking&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 비동기 + Non-Blocking 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">asyncNonBlockingExample&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1. 작업 시작&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 비동기 호출 후 즉시 반환
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">readFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;example.txt&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;utf8&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;에러 발생:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 작업 완료 시 콜백으로 처리
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;3. 파일 내용:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 파일 읽기 작업과 독립적으로 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2. 다른 작업 실행&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>적용 가이드라인&lt;/h3>&lt;ol>
&lt;li>동기 방식이 적합한 경우:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>작업의 순서가 중요한 경우&lt;/li>
&lt;li>데이터의 정합성이 중요한 경우&lt;/li>
&lt;li>간단한 스크립트나 배치 작업&lt;/li>
&lt;li>즉각적인 결과가 필요한 경우&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>비동기 방식이 적합한 경우:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>다중 사용자 처리가 필요한 경우&lt;/li>
&lt;li>긴 작업 시간이 예상되는 경우&lt;/li>
&lt;li>높은 처리량이 요구되는 경우&lt;/li>
&lt;li>실시간 데이터 처리가 필요한 경우&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Blocking이 적합한 경우:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>간단한 I/O 작업&lt;/li>
&lt;li>리소스 사용량이 적은 경우&lt;/li>
&lt;li>즉각적인 응답이 필요한 경우&lt;/li>
&lt;li>단일 사용자 시스템&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>Non-Blocking이 적합한 경우:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>높은 동시성이 요구되는 경우&lt;/li>
&lt;li>대규모 I/O 작업 처리&lt;/li>
&lt;li>실시간 네트워크 애플리케이션&lt;/li>
&lt;li>고성능이 요구되는 서버&lt;/li>
&lt;/ul>
&lt;h3>최적화 전략&lt;/h3>&lt;ol>
&lt;li>성능 최적화&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>작업의 특성에 따른 적절한 방식 선택&lt;/li>
&lt;li>리소스 사용량 모니터링&lt;/li>
&lt;li>타임아웃 설정&lt;/li>
&lt;li>에러 처리 메커니즘 구축&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>리소스 관리&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>메모리 사용량 관리&lt;/li>
&lt;li>스레드 풀 최적화&lt;/li>
&lt;li>커넥션 풀 관리&lt;/li>
&lt;li>캐시 활용&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Lock and Mutex</title><link>https://buenhyden.github.io/til/2024/11/lock-and-mutex/</link><pubDate>Sun, 17 Nov 2024 11:25:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/lock-and-mutex/</guid><description>
&lt;h2>Lock and Mutex&lt;/h2>&lt;p>Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Mutex&lt;/th>
&lt;th>Lock&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>기본 개념&lt;/strong>&lt;/td>
&lt;td>상호 배제를 위한 동기화 객체로, 소유권 개념이 있음&lt;/td>
&lt;td>일반적인 동기화 메커니즘으로, 단순한 잠금/해제 기능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>소유권&lt;/strong>&lt;/td>
&lt;td>소유권 개념이 있어 획득한 스레드만 해제 가능&lt;/td>
&lt;td>소유권 개념이 없어 다른 스레드도 해제 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>재진입성&lt;/strong>&lt;/td>
&lt;td>보통 재진입 가능 (같은 스레드가 여러 번 획득 가능)&lt;/td>
&lt;td>구현에 따라 재진입 가능할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>용도&lt;/strong>&lt;/td>
&lt;td>스레드 간 엄격한 상호 배제가 필요한 경우&lt;/td>
&lt;td>간단한 동기화가 필요한 일반적인 상황&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능&lt;/strong>&lt;/td>
&lt;td>소유권 검사 등으로 인한 오버헤드 존재&lt;/td>
&lt;td>상대적으로 가벼운 오버헤드, 단 구현에 따라 다름&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 처리&lt;/strong>&lt;/td>
&lt;td>소유권 위반 시 예외 발생 가능&lt;/td>
&lt;td>단순한 실패/성공 여부만 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>구현 복잡도&lt;/strong>&lt;/td>
&lt;td>상대적으로 복잡한 구현&lt;/td>
&lt;td>단순한 구현, 그러나 고급 기능 추가 시 복잡해질 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적용 범위&lt;/strong>&lt;/td>
&lt;td>프로세스 내 스레드 간 동기화&lt;/td>
&lt;td>프로세스 내 또는 프로세스 간 동기화에 사용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>우선순위 상속&lt;/strong>&lt;/td>
&lt;td>우선순위 상속 지원 가능&lt;/td>
&lt;td>일반적으로 지원하지 않음, 구현에 따라 다를 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>교착상태 처리&lt;/strong>&lt;/td>
&lt;td>소유권 추적으로 교착상태 감지 용이&lt;/td>
&lt;td>기본적인 교착상태 감지만 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 검사&lt;/strong>&lt;/td>
&lt;td>상세한 에러 검사 및 보고 기능&lt;/td>
&lt;td>기본적인 에러 검사, 구현에 따라 확장 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>메모리 사용&lt;/strong>&lt;/td>
&lt;td>소유권 정보 저장으로 추가 메모리 필요&lt;/td>
&lt;td>최소한의 메모리 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>유연성&lt;/strong>&lt;/td>
&lt;td>엄격한 규칙으로 유연성 제한&lt;/td>
&lt;td>상대적으로 유연한 사용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>디버깅&lt;/strong>&lt;/td>
&lt;td>소유권 정보로 디버깅 용이&lt;/td>
&lt;td>디버깅이 상대적으로 어려움, 구현에 따라 다를 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>사용 예시&lt;/strong>&lt;/td>
&lt;td>데이터베이스 트랜잭션, 파일 시스템 접근&lt;/td>
&lt;td>간단한 공유 자원 보호, 카운터&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>타임아웃 지원&lt;/strong>&lt;/td>
&lt;td>보통 타임아웃 기능 내장&lt;/td>
&lt;td>구현에 따라 타임아웃 지원 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>복구 기능&lt;/strong>&lt;/td>
&lt;td>비정상 종료 시 자동 복구 지원&lt;/td>
&lt;td>구현에 따라 자동 복구 기능 추가 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>중첩 사용&lt;/strong>&lt;/td>
&lt;td>재진입성으로 중첩 사용 가능&lt;/td>
&lt;td>구현에 따라 중첩 사용 가능, 주의 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>시스템 수준&lt;/strong>&lt;/td>
&lt;td>주로 커널 수준에서 구현&lt;/td>
&lt;td>사용자 수준 및 커널 수준 모두에서 구현 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>표준화&lt;/strong>&lt;/td>
&lt;td>POSIX 표준으로 잘 정의됨&lt;/td>
&lt;td>구현에 따라 동작이 다를 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능 특성&lt;/strong>&lt;/td>
&lt;td>경쟁 상황에서 성능 저하 가능&lt;/td>
&lt;td>스핀락 구현 시 짧은 대기 시간에 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>공정성&lt;/strong>&lt;/td>
&lt;td>일반적으로 공정성 메커니즘 내장&lt;/td>
&lt;td>구현에 따라 공정성 보장 여부가 다름&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>실제 구현 시에는 고려할 사항&lt;/h3>&lt;ul>
&lt;li>동시성 요구사항 (얼마나 많은 스레드가 동시에 접근하는가)&lt;/li>
&lt;li>성능 요구사항 (응답 시간, 처리량 등)&lt;/li>
&lt;li>리소스 사용량 (메모리, CPU 사용률)&lt;/li>
&lt;li>오류 처리 및 복구 요구사항&lt;/li>
&lt;li>데드록 방지 필요성&lt;/li>
&lt;li>플랫폼 및 운영체제의 지원 여부&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>VueJS vs ReactJS vs NextJS</title><link>https://buenhyden.github.io/til/2024/11/vuejs-vs-reactjs-vs-nextjs/</link><pubDate>Sun, 17 Nov 2024 04:51:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/vuejs-vs-reactjs-vs-nextjs/</guid><description>
&lt;h2>VueJS Vs ReactJS Vs NextJS&lt;/h2>&lt;p>VueJS, ReactJS, NextJS는 모두 현대적인 웹 애플리케이션을 개발하기 위한 JavaScript 기반의 프레임워크 및 라이브러리로, 각각 고유한 특징과 장단점을 가지고 있으며, 다양한 웹 개발 시나리오에 사용된다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>Vue.js&lt;/th>
&lt;th>React.js&lt;/th>
&lt;th>Next.js&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>기본 정의&lt;/strong>&lt;/td>
&lt;td>점진적이고 직관적인 JavaScript 프레임워크&lt;/td>
&lt;td>유연한 JavaScript UI 라이브러리&lt;/td>
&lt;td>React 기반 풀스택 웹 프레임워크&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>개발사 및 출시&lt;/strong>&lt;/td>
&lt;td>2014년, Evan You가 개발&lt;/td>
&lt;td>2013년, Facebook(현 Meta) 개발&lt;/td>
&lt;td>2016년, Vercel이 개발&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>핵심 철학&lt;/strong>&lt;/td>
&lt;td>점진적 도입이 가능한 유연한 프레임워크&lt;/td>
&lt;td>선언적 UI 개발과 컴포넌트 기반 구조&lt;/td>
&lt;td>React의 장점을 서버 사이드와 결합&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>기술적 특징&lt;/strong>&lt;/td>
&lt;td>- 반응형 데이터 바인딩&lt;br>- 양방향 데이터 흐름&lt;br>- 컴포넌트 기반 개발&lt;/td>
&lt;td>- Virtual DOM&lt;br>- 단방향 데이터 흐름&lt;br>JSX 문법&lt;/td>
&lt;td>- SSR/SSG 지원&lt;br>- 파일 기반 라우팅&lt;br>- 자동 코드 분할&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>상태 관리&lt;/strong>&lt;/td>
&lt;td>Vuex, Pinia (공식 상태 관리 도구)&lt;/td>
&lt;td>Redux, Context API (커뮤니티 기반)&lt;/td>
&lt;td>React 상태 관리 + 서버 상태&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능 최적화&lt;/strong>&lt;/td>
&lt;td>- 작은 번들 크기&lt;br>- 효율적인 반응형 시스템&lt;/td>
&lt;td>- Virtual DOM 기반 최적화&lt;br>- 메모이제이션&lt;/td>
&lt;td>- 자동 이미지 최적화&lt;br>- 경로 기반 코드 분할&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>사용 시나리오&lt;/strong>&lt;/td>
&lt;td>- 중소규모 애플리케이션&lt;br>- 점진적 마이그레이션&lt;br>- 빠른 개발 필요 시&lt;/td>
&lt;td>- 대규모 SPA&lt;br>- 복잡한 UI 개발&lt;br>- 커스텀 솔루션 필요 시&lt;/td>
&lt;td>- SEO 중심 프로젝트&lt;br>- 풀스택 애플리케이션&lt;br>- 엔터프라이즈급 개발&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>학습 용이성&lt;/strong>&lt;/td>
&lt;td>매우 낮은 진입 장벽, HTML 친화적&lt;/td>
&lt;td>중간 수준, JavaScript 숙련도 필요&lt;/td>
&lt;td>높은 수준, React 지식 필수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>생태계 특성&lt;/strong>&lt;/td>
&lt;td>공식 도구 중심의 통합된 생태계&lt;/td>
&lt;td>거대하고 다양한 커뮤니티 생태계&lt;/td>
&lt;td>React 생태계 + 서버 사이드 도구&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>개발 도구&lt;/strong>&lt;/td>
&lt;td>Vue CLI, Vue DevTools&lt;/td>
&lt;td>Create React App, React DevTools&lt;/td>
&lt;td>내장 빌드 시스템, 분석 도구&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>배포 특성&lt;/strong>&lt;/td>
&lt;td>단순한 정적 파일 배포 가능&lt;/td>
&lt;td>정적 파일 기반 배포&lt;/td>
&lt;td>서버 필요, Vercel 최적화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>프로젝트 확장성&lt;/strong>&lt;/td>
&lt;td>중간 수준의 모듈식 확장&lt;/td>
&lt;td>높은 자유도의 확장성&lt;/td>
&lt;td>풀스택 확장 용이&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이 세 기술은 각각의 고유한 장점과 사용 시나리오를 가지고 있다.&lt;br>
Vue.js는 빠른 학습과 개발이 가능하고, React.js는 유연하고 강력한 UI 개발을 지원하며, Next.js는 현대적인 웹 애플리케이션의 완벽한 솔루션을 제공한다.&lt;br>
프로젝트의 요구사항과 팀의 기술적 배경에 따라 적절한 선택을 하는 것이 중요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>ExpressJS vs NestJS</title><link>https://buenhyden.github.io/til/2024/11/expressjs-vs-nestjs/</link><pubDate>Sun, 17 Nov 2024 04:50:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/expressjs-vs-nestjs/</guid><description>
&lt;h2>ExpressJS Vs NestJS&lt;/h2>&lt;p>ExpressJS와 NestJS의 주요 특징들을 상세히 비교 분석하여 표로 정리해드리겠습니다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교 기준&lt;/th>
&lt;th>ExpressJS&lt;/th>
&lt;th>NestJS&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>프레임워크 특성&lt;/strong>&lt;/td>
&lt;td>미니멀리스트, 유연한 Node.js 웹 프레임워크&lt;/td>
&lt;td>TypeScript 기반의 구조화된 풀스택 프레임워크&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>아키텍처 스타일&lt;/strong>&lt;/td>
&lt;td>자유로운 구조 (개발자가 직접 설계)&lt;/td>
&lt;td>Angular 스타일의 모듈식 아키텍처 (강제됨)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>언어 지원&lt;/strong>&lt;/td>
&lt;td>JavaScript 중심 (TypeScript도 사용 가능)&lt;/td>
&lt;td>TypeScript 중심 (JavaScript도 사용 가능)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>학습 곡선&lt;/strong>&lt;/td>
&lt;td>낮음 (시작하기 쉬움)&lt;/td>
&lt;td>높음 (많은 개념과 패턴 학습 필요)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>기본 구조&lt;/strong>&lt;/td>
&lt;td>최소한의 구조만 제공&lt;/td>
&lt;td>모듈, 컨트롤러, 서비스 등 세분화된 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>라우팅 예시&lt;/strong>&lt;/td>
&lt;td>&lt;code>javascript app.get('/users', (req, res) =&amp;gt; { res.send('Users list'); });&lt;/code>&lt;/td>
&lt;td>&lt;code>typescript @Controller('users') export class UsersController { @Get() findAll(): string { return 'Users list'; } }&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>의존성 주입&lt;/strong>&lt;/td>
&lt;td>없음 (수동으로 구현 필요)&lt;/td>
&lt;td>내장된 강력한 DI 시스템 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>데코레이터 지원&lt;/strong>&lt;/td>
&lt;td>지원하지 않음&lt;/td>
&lt;td>광범위한 데코레이터 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>미들웨어 처리&lt;/strong>&lt;/td>
&lt;td>직관적이고 단순한 미들웨어 체인&lt;/td>
&lt;td>복잡하지만 강력한 미들웨어 시스템&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>테스트 용이성&lt;/strong>&lt;/td>
&lt;td>별도 테스트 도구 설정 필요&lt;/td>
&lt;td>내장된 테스트 도구 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>확장성&lt;/strong>&lt;/td>
&lt;td>수동 구성 필요&lt;/td>
&lt;td>모듈 시스템을 통한 쉬운 확장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능&lt;/strong>&lt;/td>
&lt;td>매우 가벼움 (적은 오버헤드)&lt;/td>
&lt;td>약간의 오버헤드 존재&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>실시간 처리&lt;/strong>&lt;/td>
&lt;td>WebSocket 수동 구현 필요&lt;/td>
&lt;td>WebSocket 데코레이터 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>유효성 검사&lt;/strong>&lt;/td>
&lt;td>외부 라이브러리 필요&lt;/td>
&lt;td>내장 파이프를 통한 유효성 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>문서화&lt;/strong>&lt;/td>
&lt;td>Swagger 등 수동 설정 필요&lt;/td>
&lt;td>자동 API 문서 생성 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적합한 프로젝트&lt;/strong>&lt;/td>
&lt;td>- 작은 규모의 프로젝트&lt;br>- 빠른 프로토타이핑&lt;br>- 마이크로서비스&lt;/td>
&lt;td>- 대규모 엔터프라이즈 애플리케이션&lt;br>- 복잡한 비즈니스 로직&lt;br>- 팀 프로젝트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>개발 생산성&lt;/strong>&lt;/td>
&lt;td>초기에는 빠르나 규모가 커지면 관리 어려움&lt;/td>
&lt;td>초기 설정에 시간이 걸리나 장기적으로 생산성 높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>커뮤니티/생태계&lt;/strong>&lt;/td>
&lt;td>매우 큰 커뮤니티, 풍부한 미들웨어&lt;/td>
&lt;td>성장하는 커뮤니티, 내장 기능 많음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 처리&lt;/strong>&lt;/td>
&lt;td>수동 구현 필요&lt;/td>
&lt;td>내장된 예외 필터 시스템&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>데이터베이스 통합&lt;/strong>&lt;/td>
&lt;td>ORM 선택 자유&lt;/td>
&lt;td>TypeORM/Sequelize 등과 쉬운 통합&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>보안 기능&lt;/strong>&lt;/td>
&lt;td>외부 미들웨어 필요&lt;/td>
&lt;td>내장된 보안 기능 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>모니터링/로깅&lt;/strong>&lt;/td>
&lt;td>외부 도구 통합 필요&lt;/td>
&lt;td>내장된 로깅 시스템 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>선택 가이드:&lt;/p>
&lt;p>ExpressJS를 선택하면 좋은 경우:&lt;/p>
&lt;ul>
&lt;li>작은 규모의 프로젝트를 빠르게 시작해야 할 때&lt;/li>
&lt;li>최대한의 자유도가 필요할 때&lt;/li>
&lt;li>가벼운 마이크로서비스를 구축할 때&lt;/li>
&lt;li>JavaScript에 익숙한 개발자가 많은 팀&lt;/li>
&lt;/ul>
&lt;p>NestJS를 선택하면 좋은 경우:&lt;/p>
&lt;ul>
&lt;li>대규모 엔터프라이즈 애플리케이션 개발 시&lt;/li>
&lt;li>체계적인 코드 구조가 필요할 때&lt;/li>
&lt;li>TypeScript를 사용하고 싶을 때&lt;/li>
&lt;li>Angular 경험이 있는 개발자가 많은 팀&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>ASGI CGI WSGI</title><link>https://buenhyden.github.io/til/2024/11/asgi-cgi-wsgi-%EB%B9%84%EA%B5%90/</link><pubDate>Sat, 16 Nov 2024 03:26:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/asgi-cgi-wsgi-%EB%B9%84%EA%B5%90/</guid><description>
&lt;h2>ASGI CGI WSGI 비교 분석&lt;/h2>&lt;p>이 기술들은 웹 서버와 애플리케이션 간의 통신 방식을 정의하는 인터페이스 규격.&lt;br>
시대 순으로 발전 과정을 이해하면 좋을 것 같다.&lt;/p>
&lt;h3>ASGI CGI WSGI 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특징&lt;/th>
&lt;th>CGI&lt;/th>
&lt;th>WSGI&lt;/th>
&lt;th>ASGI&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>등장 시기&lt;/td>
&lt;td>1990년대 초반&lt;/td>
&lt;td>2003년 (PEP 333)&lt;/td>
&lt;td>2016년&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>처리 방식&lt;/td>
&lt;td>프로세스 기반&lt;/td>
&lt;td>동기식&lt;/td>
&lt;td>비동기식&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능&lt;/td>
&lt;td>매 요청마다 새 프로세스 생성 (낮음)&lt;/td>
&lt;td>프로세스 재사용 (중간)&lt;/td>
&lt;td>비동기 처리로 높은 성능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프로토콜 지원&lt;/td>
&lt;td>HTTP/1.0&lt;/td>
&lt;td>HTTP/1.1&lt;/td>
&lt;td>HTTP/1.1, HTTP/2, WebSocket&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡도&lt;/td>
&lt;td>단순함&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>상대적으로 복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>높음 (프로세스당)&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동시성 처리&lt;/td>
&lt;td>프로세스 기반&lt;/td>
&lt;td>스레드/프로세스 기반&lt;/td>
&lt;td>이벤트 루프 기반&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 사용 사례&lt;/td>
&lt;td>레거시 시스템&lt;/td>
&lt;td>전통적인 웹 애플리케이션&lt;/td>
&lt;td>현대적 웹 애플리케이션&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>환경 변수 처리&lt;/td>
&lt;td>시스템 환경 변수&lt;/td>
&lt;td>environ 딕셔너리&lt;/td>
&lt;td>scope 딕셔너리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>스트리밍 지원&lt;/td>
&lt;td>제한적&lt;/td>
&lt;td>이터레이터 기반&lt;/td>
&lt;td>네이티브 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프레임워크 예시&lt;/td>
&lt;td>직접 구현&lt;/td>
&lt;td>Django, Flask&lt;/td>
&lt;td>FastAPI, Starlette&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>서버 예시&lt;/td>
&lt;td>Apache&lt;/td>
&lt;td>gunicorn, uWSGI&lt;/td>
&lt;td>uvicorn, daphne&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>오류 처리&lt;/td>
&lt;td>제한적&lt;/td>
&lt;td>표준화된 방식&lt;/td>
&lt;td>포괄적 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>설정 복잡도&lt;/td>
&lt;td>간단&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>상대적으로 복잡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확장성&lt;/td>
&lt;td>제한적&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>각 기술의 기본적인 구현 예제&lt;/h3>&lt;p>CGI (Common Gateway Interface):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="ch">#!/usr/bin/python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Content-Type: text/html&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;h1&amp;gt;Hello from CGI!&amp;lt;/h1&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;p&amp;gt;Environment Variables:&amp;lt;/p&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">environ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;lt;br&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>WSGI (Web Server Gateway Interface):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">simple_wsgi_app&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">environ&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start_response&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;간단한 WSGI 애플리케이션&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;200 OK&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">headers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[(&lt;/span>&lt;span class="s1">&amp;#39;Content-type&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">start_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">headers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 환경 변수에서 요청 정보 읽기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">request_method&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">environ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;REQUEST_METHOD&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path_info&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">environ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;PATH_INFO&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;Method: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">request_method&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">Path: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">path_info&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">encode&lt;/span>&lt;span class="p">()]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>ASGI (Asynchronous Server Gateway Interface):&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">simple_asgi_app&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">scope&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;간단한 ASGI 애플리케이션&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">assert&lt;/span> &lt;span class="n">scope&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;http&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 클라이언트로부터 요청 받기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 응답 보내기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;http.response.start&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;status&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;headers&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;content-type&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;http.response.body&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;body&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;Hello from ASGI!&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>각 기술의 주요 사용 시나리오&lt;/h3>&lt;h4>파일 업로드 처리&lt;/h4>&lt;p>CGI:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="ch">#!/usr/bin/python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">cgi&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">form&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cgi&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">FieldStorage&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">fileitem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">form&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;filename&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="n">fileitem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">basename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fileitem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/tmp/&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;wb&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fileitem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;파일이 업로드되었습니다&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;업로드 실패&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Content-Type: text/html&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>WSGI:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">file_upload_app&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">environ&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start_response&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">from&lt;/span> &lt;span class="nn">wsgiref.util&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">FileWrapper&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;200 OK&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">headers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[(&lt;/span>&lt;span class="s1">&amp;#39;Content-Type&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;text/html&amp;#39;&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">start_response&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">headers&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">environ&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;REQUEST_METHOD&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;POST&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">post_env&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">environ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copy&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">post_env&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;QUERY_STRING&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 파일 처리 로직&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="s2">&amp;#34;File uploaded successfully&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="s2">&amp;#34;Please upload a file&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>ASGI:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">file_upload_app&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">scope&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">scope&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;http&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 요청 본문 받기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">body&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">more_body&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">more_body&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">message&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">await&lt;/span> &lt;span class="n">receive&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">body&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;body&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">more_body&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;more_body&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 파일 처리 로직&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;http.response.start&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;status&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">200&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;headers&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;content-type&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;text/plain&amp;#39;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">({&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;type&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;http.response.body&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;body&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;File processed asynchronously&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Blocking vs Non-Blocking</title><link>https://buenhyden.github.io/til/2024/11/blocking-vs-non-blocking/</link><pubDate>Tue, 12 Nov 2024 12:36:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/blocking-vs-non-blocking/</guid><description>
&lt;h2>Blocking and Non-Blocking&lt;/h2>&lt;p>Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.&lt;br>
이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.&lt;/p>
&lt;p>Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.&lt;br>
Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.&lt;/p>
&lt;h3>Blocking&lt;/h3>&lt;p>Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.&lt;br>
해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.&lt;/p>
&lt;h4>동작 방식&lt;/h4>&lt;ol>
&lt;li>프로세스가 특정 작업을 요청한다.&lt;/li>
&lt;li>해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다.&lt;/li>
&lt;li>작업이 완료되면 프로세스는 다시 실행 상태로 전환된다.&lt;/li>
&lt;li>그동안 다른 작업은 수행될 수 없다.&lt;/li>
&lt;/ol>
&lt;h4>특징&lt;/h4>&lt;ul>
&lt;li>프로그램의 실행 흐름이 순차적이고 예측 가능하다.&lt;/li>
&lt;li>리소스 사용이 일시적으로 중단된다.&lt;/li>
&lt;li>응답을 즉시 받을 수 있다.&lt;/li>
&lt;li>프로그램 구조가 단순하고 직관적이다.&lt;/li>
&lt;/ul>
&lt;h4>실제 예시&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Blocking I/O의 예시&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;example.txt&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytesRead&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 이 지점에서 Blocking 발생&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">파일&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">읽기가&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">완료될&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">때까지&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">다음&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">코드로&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">진행하지&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">않음&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>성능 측면&lt;/h4>&lt;ul>
&lt;li>단일 작업의 처리 시간이 예측 가능하다.&lt;/li>
&lt;li>리소스 사용이 일시적으로 중단된다.&lt;/li>
&lt;li>대기 시간이 발생한다.&lt;/li>
&lt;/ul>
&lt;h4>구현 복잡도&lt;/h4>&lt;ul>
&lt;li>구현이 단순하다.&lt;/li>
&lt;li>디버깅이 쉽다.&lt;/li>
&lt;li>코드 흐름이 직관적이다.&lt;/li>
&lt;/ul>
&lt;h4>적합한 사례&lt;/h4>&lt;ul>
&lt;li>간단한 스크립트 작성&lt;/li>
&lt;li>순차적 데이터 처리&lt;/li>
&lt;li>즉각적인 응답이 필요한 경우&lt;/li>
&lt;li>작은 규모의 애플리케이션&lt;/li>
&lt;/ul>
&lt;h3>Non-Blocking&lt;/h3>&lt;p>Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.&lt;br>
작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.&lt;/p>
&lt;h4>동작 방식&lt;/h4>&lt;ol>
&lt;li>프로세스가 작업을 요청한다.&lt;/li>
&lt;li>작업의 완료 여부와 관계없이 즉시 제어권을 반환받는다.&lt;/li>
&lt;li>다른 작업을 계속 수행할 수 있다.&lt;/li>
&lt;li>작업이 완료되면 이벤트나 콜백을 통해 알림을 받는다.&lt;/li>
&lt;/ol>
&lt;h4>특징&lt;/h4>&lt;ul>
&lt;li>프로그램의 실행이 중단되지 않는다.&lt;/li>
&lt;li>리소스를 효율적으로 사용할 수 있다.&lt;/li>
&lt;li>높은 동시성을 제공한다.&lt;/li>
&lt;li>복잡한 프로그램 구조가 필요할 수 있다.&lt;/li>
&lt;/ul>
&lt;h4>실제 예시&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Non-Blocking I/O의 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">fs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">readFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;example.txt&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">data&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 파일을 읽는 동안에도 다음 코드가 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;파일 읽기를 요청했습니다.&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>성능 측면&lt;/h4>&lt;ul>
&lt;li>전체적인 처리량이 향상된다.&lt;/li>
&lt;li>리소스를 지속적으로 활용할 수 있다.&lt;/li>
&lt;li>대기 시간을 다른 작업으로 활용한다.&lt;/li>
&lt;/ul>
&lt;h4>구현 복잡도&lt;/h4>&lt;ul>
&lt;li>구현이 복잡할 수 있다.&lt;/li>
&lt;li>디버깅이 어려울 수 있다.&lt;/li>
&lt;li>콜백이나 이벤트 핸들링이 필요하다.&lt;/li>
&lt;/ul>
&lt;h4>적합한 사례&lt;/h4>&lt;ul>
&lt;li>대규모 네트워크 애플리케이션&lt;/li>
&lt;li>실시간 데이터 처리 시스템&lt;/li>
&lt;li>높은 동시성이 요구되는 서버&lt;/li>
&lt;li>사용자 인터페이스가 있는 애플리케이션&lt;/li>
&lt;/ul>
&lt;h3>Blocking과 Non-Blocking의 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>카테고리&lt;/th>
&lt;th>Blocking&lt;/th>
&lt;th>Non-Blocking&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>기본 개념&lt;/strong>&lt;/td>
&lt;td>- 호출된 함수가 자신의 작업을 완료할 때까지 제어권을 가지고 있음&lt;/td>
&lt;td>- 호출된 함수가 즉시 제어권을 반환함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 호출한 함수는 작업 완료까지 대기&lt;/td>
&lt;td>- 호출한 함수는 다른 작업을 계속 수행 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 실행 순서가 명확하고 예측 가능&lt;/td>
&lt;td>- 실행 순서가 비결정적일 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>제어권 처리&lt;/strong>&lt;/td>
&lt;td>- 제어권이 호출된 함수에 완전히 넘어감&lt;/td>
&lt;td>- 제어권이 호출한 함수에 즉시 반환됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 작업 완료 전까지 제어권 반환 없음&lt;/td>
&lt;td>- 작업 상태는 별도로 확인 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 호출 스택이 차단됨&lt;/td>
&lt;td>- 호출 스택이 차단되지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>리소스 관리&lt;/strong>&lt;/td>
&lt;td>- 작업 중 시스템 리소스를 독점&lt;/td>
&lt;td>- 리소스를 효율적으로 공유&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 메모리 사용량이 예측 가능&lt;/td>
&lt;td>- 동시성으로 인한 메모리 사용량 변동 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 리소스 해제가 명확함&lt;/td>
&lt;td>- 리소스 해제 시점 관리 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능 특성&lt;/strong>&lt;/td>
&lt;td>- 단순 작업에서는 오버헤드가 적음&lt;/td>
&lt;td>- 문맥 교환으로 인한 오버헤드 발생 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- I/O 작업에서 성능 저하&lt;/td>
&lt;td>- I/O 작업에서 높은 성능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 동시성 처리에 제한적&lt;/td>
&lt;td>- 높은 동시성 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 처리&lt;/strong>&lt;/td>
&lt;td>- 동기적 에러 처리 가능&lt;/td>
&lt;td>- 비동기적 에러 처리 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- try-catch로 직접적인 처리&lt;/td>
&lt;td>- 콜백이나 Promise로 에러 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 스택 트레이스가 명확함&lt;/td>
&lt;td>- 스택 트레이스 추적이 복잡할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적합한 사용 사례&lt;/strong>&lt;/td>
&lt;td>- 빠른 CPU 연산 작업&lt;/td>
&lt;td>- 네트워크 통신&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 간단한 파일 읽기/쓰기&lt;/td>
&lt;td>- 대용량 파일 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 메모리 내 데이터 처리&lt;/td>
&lt;td>- 데이터베이스 쿼리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 동기화가 필요한 작업&lt;/td>
&lt;td>- 독립적인 병렬 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>프로그래밍 모델&lt;/strong>&lt;/td>
&lt;td>- 절차적 프로그래밍에 적합&lt;/td>
&lt;td>- 이벤트 기반 프로그래밍에 적합&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 코드 흐름이 직관적&lt;/td>
&lt;td>- 콜백이나 Promise 기반&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 디버깅이 상대적으로 쉬움&lt;/td>
&lt;td>- 복잡한 비동기 패턴 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>시스템 확장성&lt;/strong>&lt;/td>
&lt;td>- 수직적 확장에 제한적&lt;/td>
&lt;td>- 수평적/수직적 확장 용이&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 동시 처리 능력 제한&lt;/td>
&lt;td>- 높은 동시성 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 시스템 리소스 제약&lt;/td>
&lt;td>- 효율적인 리소스 활용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>개발 복잡도&lt;/strong>&lt;/td>
&lt;td>- 구현이 단순하고 직관적&lt;/td>
&lt;td>- 상태 관리가 필요함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 코드 흐름 추적이 쉬움&lt;/td>
&lt;td>- 비동기 로직으로 인한 복잡도 증가&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 유지보수가 상대적으로 용이&lt;/td>
&lt;td>- 디버깅과 테스트가 어려울 수 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>실제 애플리케이션 개발에서는 각 작업의 특성과 요구사항을 고려하여 적절한 방식을 선택해야 한다.&lt;br>
특히:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>시스템의 응답성이 중요한 경우:&lt;/p>
&lt;ul>
&lt;li>Non-Blocking 방식이 더 적합할 수 있다.&lt;/li>
&lt;li>사용자 인터페이스의 반응성을 유지할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>정확성과 순서가 중요한 경우:&lt;/p>
&lt;ul>
&lt;li>Blocking 방식이 더 적합할 수 있다.&lt;/li>
&lt;li>작업의 순서와 결과를 정확히 제어할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>리소스 활용이 중요한 경우:&lt;/p>
&lt;ul>
&lt;li>Non-Blocking 방식이 시스템 리소스를 더 효율적으로 활용할 수 있다.&lt;/li>
&lt;li>높은 처리량이 필요한 시스템에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 특성들을 잘 이해하고 적절히 조합하여 사용하는 것이 현대 애플리케이션 개발에서 매우 중요하다.&lt;/p>
&lt;h3>최신 트렌드 및 발전 방향&lt;/h3>&lt;ol>
&lt;li>시스템 설계 측면&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>하이브리드 접근 방식의 증가&lt;/li>
&lt;li>마이크로서비스 아키텍처에서의 활용&lt;/li>
&lt;li>클라우드 네이티브 환경에서의 최적화&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>프로그래밍 언어 측면&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>비동기 프로그래밍 지원 강화&lt;/li>
&lt;li>새로운 동시성 모델 도입&lt;/li>
&lt;li>효율적인 리소스 관리 메커니즘 개발&lt;/li>
&lt;/ul>
&lt;h3>실제 구현 시 고려사항&lt;/h3>&lt;ol>
&lt;li>시스템 설계 시 고려사항&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>작업의 특성과 요구사항 분석&lt;/li>
&lt;li>리소스 사용량 예측&lt;/li>
&lt;li>확장성 고려&lt;/li>
&lt;li>에러 처리 메커니즘 설계&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>성능 최적화&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>적절한 타임아웃 설정&lt;/li>
&lt;li>버퍼 크기 조정&lt;/li>
&lt;li>스레드 풀 관리&lt;/li>
&lt;li>메모리 사용량 모니터링&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>동기(Synchronous)와 비동기(Asynchronous)</title><link>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous/</link><pubDate>Tue, 12 Nov 2024 00:57:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous/</guid><description>
&lt;h2>동기(Synchronous)와 비동기(Asynchronous)&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>카테고리&lt;/th>
&lt;th>동기(Synchronous)&lt;/th>
&lt;th>비동기(Asynchronous)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>기본 개념&lt;/strong>&lt;/td>
&lt;td>- 작업이 순차적으로 실행됨&lt;/td>
&lt;td>- 작업이 독립적으로 실행됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 이전 작업이 완료될 때까지 다음 작업 대기&lt;/td>
&lt;td>- 작업의 완료를 기다리지 않고 다음 작업 진행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 실행 순서가 보장됨&lt;/td>
&lt;td>- 실행 순서가 보장되지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>처리 방식&lt;/strong>&lt;/td>
&lt;td>- 단일 스레드에서 순차적 처리&lt;/td>
&lt;td>- 멀티 스레드 또는 이벤트 루프 기반 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 작업 완료까지 대기&lt;/td>
&lt;td>- 작업 완료 시 콜백/Promise/async-await 등으로 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 직관적인 코드 흐름&lt;/td>
&lt;td>- 비선형적 코드 흐름&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>장점&lt;/strong>&lt;/td>
&lt;td>- 코드의 가독성이 좋음&lt;/td>
&lt;td>- 시스템 자원의 효율적 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 디버깅이 용이함&lt;/td>
&lt;td>- 더 나은 사용자 경험 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 에러 처리가 간단함&lt;/td>
&lt;td>- 높은 처리량(Throughput)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>단점&lt;/strong>&lt;/td>
&lt;td>- 시스템 자원 비효율적 사용&lt;/td>
&lt;td>- 코드의 복잡성 증가&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 응답 시간이 길어질 수 있음&lt;/td>
&lt;td>- 디버깅이 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 사용자 경험 저하 가능성&lt;/td>
&lt;td>- 에러 처리가 복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>적합한 사용 사례&lt;/strong>&lt;/td>
&lt;td>- 간단한 계산 작업&lt;/td>
&lt;td>- 네트워크 요청&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 메모리 내 데이터 처리&lt;/td>
&lt;td>- 파일 입출력&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 작은 크기의 데이터 처리&lt;/td>
&lt;td>- 대용량 데이터 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 순차적 처리가 필요한 작업&lt;/td>
&lt;td>- 독립적으로 실행 가능한 작업&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>에러 처리&lt;/strong>&lt;/td>
&lt;td>- try-catch 블록으로 직접 처리&lt;/td>
&lt;td>- Promise의 catch 또는 try-catch와 async-await 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 즉시 에러 감지 및 처리&lt;/td>
&lt;td>- 에러 처리가 비동기적으로 발생&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 스택 트레이스 추적이 용이&lt;/td>
&lt;td>- 에러 발생 지점 추적이 복잡할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>성능 특성&lt;/strong>&lt;/td>
&lt;td>- CPU 집약적 작업에 유리&lt;/td>
&lt;td>- I/O 집약적 작업에 유리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 메모리 사용량이 예측 가능&lt;/td>
&lt;td>- 동시 처리로 인한 메모리 사용량 변동&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 단일 작업 처리 시간이 빠름&lt;/td>
&lt;td>- 전체 처리량 최적화에 유리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>코드 관리&lt;/strong>&lt;/td>
&lt;td>- 코드 구조가 단순함&lt;/td>
&lt;td>- 상태 관리가 필요함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 유지보수가 상대적으로 쉬움&lt;/td>
&lt;td>- 비동기 패턴에 대한 이해 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 테스트 작성이 용이함&lt;/td>
&lt;td>- 테스트 시나리오가 복잡할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>리소스 활용&lt;/strong>&lt;/td>
&lt;td>- 단일 리소스 점유&lt;/td>
&lt;td>- 리소스의 효율적 분배&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 대기 시간 동안 블로킹&lt;/td>
&lt;td>- 대기 시간 동안 다른 작업 수행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>- 시스템 부하가 예측 가능&lt;/td>
&lt;td>- 동시성으로 인한 부하 변동 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>최신 트렌드 및 발전 방향&lt;/h3>&lt;h4>동기 프로그래밍의 발전&lt;/h4>&lt;ul>
&lt;li>코루틴(Coroutine) 도입&lt;/li>
&lt;li>제너레이터(Generator) 함수 활용&lt;/li>
&lt;li>구조적 동시성(Structured Concurrency) 개념 도입&lt;/li>
&lt;/ul>
&lt;h4>비동기 프로그래밍의 발전&lt;/h4>&lt;ul>
&lt;li>Promise와 async/await의 보편화&lt;/li>
&lt;li>반응형 프로그래밍(Reactive Programming)의 확산&lt;/li>
&lt;li>이벤트 기반 아키텍처의 발전&lt;/li>
&lt;li>비동기 스트림 처리 기술의 발전&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Session base Auth and Cookie base Auth</title><link>https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/</link><pubDate>Mon, 11 Nov 2024 02:10:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/</guid><description>
&lt;h2>Session Base Auth and Cookie Base Auth&lt;/h2>&lt;p>세션 기반 인증(Session Based Authentication)과 쿠키 기반 인증(Cookie Based Authentication)은 웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식이다.&lt;br>
두 용어는 종종 혼용되어 사용되지만, 정확히 말하면 서로 다른 개념으로, 쿠키 기반 인증은 클라이언트 측의 저장 메커니즘을 가리키는 반면, 세션 기반 인증은 서버 측의 상태 관리 방식을 의미한다.&lt;br>
실제로 대부분의 세션 기반 인증은 쿠키를 전송 수단으로 사용한다. 이것이 바로 이 두 용어가 자주 혼용되는 이유이다.&lt;/p>
&lt;p>두 인증 방식을 비교 분석한 표:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교 항목&lt;/th>
&lt;th>쿠키 기반 인증&lt;/th>
&lt;th>세션 기반 인증&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>데이터 저장 위치&lt;/td>
&lt;td>클라이언트 브라우저&lt;/td>
&lt;td>서버&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보안성&lt;/td>
&lt;td>상대적으로 낮음 (클라이언트에 데이터 노출)&lt;/td>
&lt;td>높음 (서버에서 데이터 관리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확장성&lt;/td>
&lt;td>높음 (서버 부하 적음)&lt;/td>
&lt;td>상대적으로 낮음 (서버 메모리 사용)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡도&lt;/td>
&lt;td>단순함&lt;/td>
&lt;td>더 복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 용량 제한&lt;/td>
&lt;td>브라우저 제한 (보통 4KB)&lt;/td>
&lt;td>서버 리소스에 따라 유동적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>클라이언트 의존성&lt;/td>
&lt;td>높음 (쿠키 비활성화 시 작동 안 함)&lt;/td>
&lt;td>낮음 (다른 전송 방식 사용 가능)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>서버 부하&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>상대적으로 높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CSRF 취약성&lt;/td>
&lt;td>취약할 수 있음&lt;/td>
&lt;td>대책 마련 시 더 안전&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 수정 위험&lt;/td>
&lt;td>클라이언트에서 수정 가능&lt;/td>
&lt;td>서버에서만 수정 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>만료 관리&lt;/td>
&lt;td>클라이언트 측에서 관리&lt;/td>
&lt;td>서버 측에서 관리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>실제로는 이 두 방식이 함께 사용되는 경우가 많다.&lt;br>
전형적인 세션 기반 인증의 구현 과정을 보면:&lt;/p>
&lt;ol>
&lt;li>사용자 로그인 시:&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 서버에서 세션 생성
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">userId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 세션 ID를 쿠키로 전송
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cookie&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;sessionId&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">sessionId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">httpOnly&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">secure&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>이후 요청 처리:&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 쿠키로부터 세션 ID 읽기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">sessionId&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">cookies&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sessionId&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 서버의 세션 저장소에서 데이터 조회
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">const&lt;/span> &lt;span class="nx">session&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kr">await&lt;/span> &lt;span class="nx">sessionStore&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">sessionId&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이러한 하이브리드 접근 방식의 장점은:&lt;/p>
&lt;ol>
&lt;li>보안성: 중요 데이터는 서버에 보관&lt;/li>
&lt;li>편의성: 쿠키의 자동 전송 메커니즘 활용&lt;/li>
&lt;li>유연성: 필요에 따라 추가 정보 저장 가능&lt;/li>
&lt;/ol>
&lt;p>따라서 &amp;ldquo;쿠키 기반 인증이냐 세션 기반 인증이냐&amp;quot;의 선택은 실제로는 &amp;ldquo;순수 쿠키 저장 방식이냐 쿠키-세션 하이브리드 방식이냐&amp;quot;의 선택이라고 볼 수 있다.&lt;br>
대부분의 현대 웹 애플리케이션은 보안과 사용자 경험을 위해 하이브리드 방식을 선택하고 있다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Linear Data Structure vs Non-Linear Data Structure</title><link>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</link><pubDate>Wed, 06 Nov 2024 11:00:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</guid><description>
&lt;h2>Linear Data Structure Vs Non-Linear Data Structure&lt;/h2>&lt;p>데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>측면&lt;/th>
&lt;th>Linear Data Structure&lt;/th>
&lt;th>Non-Linear Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>데이터 요소가 순차적 또는 선형적으로 배열된 구조&lt;/td>
&lt;td>데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조&lt;/td>
&lt;td>단일 레벨 구조&lt;/td>
&lt;td>다중 레벨 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 관계&lt;/td>
&lt;td>요소 간 1:1 관계&lt;/td>
&lt;td>요소 간 1:N 또는 N:N 관계&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>순회&lt;/td>
&lt;td>단일 실행으로 모든 요소 순회 가능&lt;/td>
&lt;td>단일 실행으로 모든 요소 순회 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡성&lt;/td>
&lt;td>구현이 상대적으로 간단&lt;/td>
&lt;td>구현이 상대적으로 복잡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>메모리 사용이 덜 효율적&lt;/td>
&lt;td>메모리 사용이 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>시간 복잡도&lt;/td>
&lt;td>입력 크기에 따라 증가&lt;/td>
&lt;td>특정 작업에서 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 접근&lt;/td>
&lt;td>순차적 접근&lt;/td>
&lt;td>계층적 또는 네트워크 기반 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>삽입/삭제&lt;/td>
&lt;td>상대적으로 간단&lt;/td>
&lt;td>더 복잡하지만 유연함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>응용 분야&lt;/td>
&lt;td>간단한 데이터 저장 및 처리&lt;/td>
&lt;td>복잡한 관계 표현, AI, 이미지 처리 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예시&lt;/td>
&lt;td>배열, 연결 리스트, 스택, 큐&lt;/td>
&lt;td>트리, 그래프, 해시 테이블, 힙&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>공통점:&lt;/p>
&lt;ol>
&lt;li>둘 다 데이터를 구조화하고 관리하는 방법을 제공한다.&lt;/li>
&lt;li>특정 작업에 대해 효율적인 알고리즘을 지원한다.&lt;/li>
&lt;li>데이터의 삽입, 삭제, 검색 연산을 수행할 수 있다.&lt;/li>
&lt;/ol>
&lt;p>주요 차이점:&lt;/p>
&lt;ol>
&lt;li>데이터 배열 방식 (순차적 vs 계층적/네트워크)&lt;/li>
&lt;li>구현 복잡도 (간단 vs 복잡)&lt;/li>
&lt;li>메모리 효율성 (덜 효율적 vs 더 효율적)&lt;/li>
&lt;li>데이터 관계 표현 (1:1 vs 1:N 또는 N:N)&lt;/li>
&lt;li>응용 분야 (간단한 데이터 처리 vs 복잡한 관계 표현)&lt;/li>
&lt;/ol>
&lt;h3>선형 데이터 구조 (Linear Data Structure) 유형&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구조&lt;/th>
&lt;th>정의&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>주요 연산&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Array&lt;/td>
&lt;td>연속된 메모리 위치에 동일한 유형의 요소를 저장하는 구조&lt;/td>
&lt;td>- 고정 크기&lt;br>- 인덱스로 접근&lt;/td>
&lt;td>- 빠른 접근 시간 O(1)&lt;br>- 메모리 효율적&lt;/td>
&lt;td>- 크기 변경 어려움&lt;br>- 삽입/삭제 비효율적&lt;/td>
&lt;td>접근, 검색, 삽입, 삭제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linked List&lt;/td>
&lt;td>노드가 데이터와 다음 노드 참조를 포함하는 연결 구조&lt;/td>
&lt;td>- 동적 크기&lt;br>- 비연속 메모리&lt;/td>
&lt;td>- 삽입/삭제 효율적&lt;br>- 유연한 크기&lt;/td>
&lt;td>- 임의 접근 어려움&lt;br>- 추가 메모리 필요&lt;/td>
&lt;td>삽입, 삭제, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stack&lt;/td>
&lt;td>LIFO(Last-In-First-Out) 원칙을 따르는 구조&lt;/td>
&lt;td>- 한쪽 끝에서만 연산&lt;br>- 후입선출&lt;/td>
&lt;td>- 간단한 구현&lt;br>- 역추적에 유용&lt;/td>
&lt;td>- 제한된 데이터 접근&lt;/td>
&lt;td>push, pop, peek&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue&lt;/td>
&lt;td>FIFO(First-In-First-Out) 원칙을 따르는 구조&lt;/td>
&lt;td>- 양쪽 끝에서 연산&lt;br>- 선입선출&lt;/td>
&lt;td>- 순서 보존&lt;br>- 버퍼링에 유용&lt;/td>
&lt;td>- 중간 데이터 접근 어려움&lt;/td>
&lt;td>enqueue, dequeue&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deque&lt;/td>
&lt;td>양쪽 끝에서 삽입과 삭제가 가능한 구조&lt;/td>
&lt;td>- 양방향 연산&lt;br>- 스택과 큐 기능 결합&lt;/td>
&lt;td>- 유연한 데이터 처리&lt;br>- 다양한 알고리즘 지원&lt;/td>
&lt;td>- 구현 복잡성&lt;/td>
&lt;td>pushFront, pushBack, popFront, popBack&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>비선형 데이터 구조 (Non-Linear Data Structure) 유형&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구조&lt;/th>
&lt;th>정의&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>주요 연산&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Graph&lt;/td>
&lt;td>노드(정점)와 엣지(간선)로 구성된 비선형 데이터 구조&lt;/td>
&lt;td>- 계층적 또는 네트워크 관계 표현&lt;br>- 방향성 있는/없는 그래프로 구분&lt;/td>
&lt;td>- 복잡한 관계 모델링&lt;br>- 효율적인 경로 탐색&lt;/td>
&lt;td>- 구현 복잡성&lt;br>- 메모리 사용량 큼&lt;/td>
&lt;td>삽입, 삭제, 탐색, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hash-based Structure&lt;/td>
&lt;td>키를 값에 매핑하는 데이터 구조&lt;/td>
&lt;td>- 해시 함수 사용&lt;br>- 충돌 해결 메커니즘 필요&lt;/td>
&lt;td>- 빠른 검색, 삽입, 삭제 (평균 O(1))&lt;br>- 효율적인 데이터 관리&lt;/td>
&lt;td>- 최악의 경우 성능 저하&lt;br>- 순서 정보 손실&lt;/td>
&lt;td>삽입, 검색, 삭제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tree&lt;/td>
&lt;td>계층적 구조를 가진 노드들의 집합&lt;/td>
&lt;td>- 루트 노드와 자식 노드로 구성&lt;br>- 사이클 없음&lt;/td>
&lt;td>- 계층적 데이터 표현&lt;br>- 효율적인 검색&lt;/td>
&lt;td>- 불균형 시 성능 저하&lt;br>- 구현 복잡성&lt;/td>
&lt;td>삽입, 삭제, 검색, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Heap&lt;/td>
&lt;td>완전 이진 트리 기반의 특수한 트리 구조&lt;/td>
&lt;td>- 최대 힙 또는 최소 힙&lt;br>- 부모-자식 간 대소 관계 유지&lt;/td>
&lt;td>- 최대/최소값 빠른 접근&lt;br>- 우선순위 큐 구현에 효과적&lt;/td>
&lt;td>- 임의 노드 접근 어려움&lt;br>- 중간값 찾기 비효율적&lt;/td>
&lt;td>삽입, 삭제, 힙 정렬&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Hash-based data structure가 Non-linear data structure로 분류되는 근거&lt;/p>
&lt;ol>
&lt;li>고유한 접근 방식: Hash-based 구조는 해시 함수를 사용하여 데이터를 저장하고 검색한다. 이는 다른 non-linear 구조와는 다른 독특한 접근 방식이다.&lt;/li>
&lt;li>성능 특성: Hash-based 구조는 평균적으로 O(1)의 시간 복잡도로 삽입, 검색, 삭제 연산을 수행할 수 있어, 다른 non-linear 구조와 구별된다.&lt;/li>
&lt;li>다양한 응용: Hash-based 구조는 associative arrays, 데이터베이스 인덱싱, 캐시, 집합 등 다양한 응용 분야에서 사용된다.&lt;/li>
&lt;li>충돌 해결 메커니즘: Hash-based 구조는 충돌 해결을 위한 고유한 메커니즘(예: separate chaining, linear probing)을 가지고 있어, 다른 non-linear 구조와 구별된다.&lt;/li>
&lt;li>공간-시간 트레이드오프: Hash-based 구조는 메모리 사용과 연산 속도 사이의 특별한 균형을 제공한다.&lt;/li>
&lt;li>확률적 성능: Hash-based 구조의 성능은 해시 함수의 품질과 충돌 해결 방법에 따라 확률적으로 결정되며, 이는 다른 non-linear 구조와 다른 특성이다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Primitive data structure vs Non-Primitive data structure</title><link>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</link><pubDate>Wed, 06 Nov 2024 08:39:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</guid><description>
&lt;h2>Primitive Data Structure Vs Non-Primitive Data Structure&lt;/h2>&lt;h3>Primitive Data Structure&lt;/h3>&lt;p>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.&lt;br>
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.&lt;/p>
&lt;h4>주요 특징&lt;/h4>&lt;ol>
&lt;li>&lt;strong>단순성&lt;/strong>: 가장 기본적이고 이해하기 쉬운 데이터 타입이다.&lt;/li>
&lt;li>&lt;strong>고정 크기&lt;/strong>: 일반적으로 고정된 메모리 크기를 가진다.&lt;/li>
&lt;li>&lt;strong>효율성&lt;/strong>: 메모리 사용과 접근 시간 측면에서 매우 효율적이다.&lt;/li>
&lt;li>&lt;strong>직접 표현&lt;/strong>: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다.&lt;/li>
&lt;li>&lt;strong>값 의미론&lt;/strong>: 변수에 실제 값이 직접 저장된다.&lt;/li>
&lt;li>&lt;strong>스택 할당&lt;/strong>: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다.&lt;/li>
&lt;/ol>
&lt;p>주요 primitive data structure들을 비교 분석하여 정리한 표:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 타입&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>비트 수&lt;/th>
&lt;th>값 범위&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>Java&lt;/th>
&lt;th>JavaScript&lt;/th>
&lt;th>Python&lt;/th>
&lt;th>Go&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Boolean&lt;/td>
&lt;td>참/거짓 값을 나타내는 논리 데이터 타입&lt;/td>
&lt;td>1 비트 또는 1 바이트&lt;/td>
&lt;td>true/false&lt;/td>
&lt;td>조건문과 논리 연산에 사용&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>bool&lt;/td>
&lt;td>bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Character&lt;/td>
&lt;td>단일 문자를 나타내는 데이터 타입&lt;/td>
&lt;td>16 비트 (Java), 8 비트 (대부분)&lt;/td>
&lt;td>U+0000 ~ U+FFFF (Java)&lt;/td>
&lt;td>문자 인코딩에 따라 다름&lt;/td>
&lt;td>char&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>byte (uint8)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>String&lt;/td>
&lt;td>문자열을 나타내는 데이터 타입&lt;/td>
&lt;td>가변&lt;/td>
&lt;td>제한 없음 (메모리 한계까지)&lt;/td>
&lt;td>불변(Java, Python), 가변(JavaScript)&lt;/td>
&lt;td>String&lt;/td>
&lt;td>String&lt;/td>
&lt;td>str&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Half Precision)&lt;/td>
&lt;td>16비트 부동 소수점&lt;/td>
&lt;td>16 비트&lt;/td>
&lt;td>±6.10 × 10^−5 ~ ±6.55 × 10^4&lt;/td>
&lt;td>정밀도 낮음, 저장 공간 절약&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>float16 (패키지)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Single Precision)&lt;/td>
&lt;td>32비트 부동 소수점&lt;/td>
&lt;td>32 비트&lt;/td>
&lt;td>±1.18 × 10^−38 ~ ±3.4 × 10^38&lt;/td>
&lt;td>일반적인 실수 계산에 사용&lt;/td>
&lt;td>float&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>float&lt;/td>
&lt;td>float32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Double Precision)&lt;/td>
&lt;td>64비트 부동 소수점&lt;/td>
&lt;td>64 비트&lt;/td>
&lt;td>±2.23 × 10^−308 ~ ±1.80 × 10^308&lt;/td>
&lt;td>높은 정밀도 필요 시 사용&lt;/td>
&lt;td>double&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>float&lt;/td>
&lt;td>float64&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Quadruple Precision)&lt;/td>
&lt;td>128비트 부동 소수점&lt;/td>
&lt;td>128 비트&lt;/td>
&lt;td>±3.36 × 10^−4932 ~ ±1.18 × 10^4932&lt;/td>
&lt;td>매우 높은 정밀도, 특수 용도&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Decimal (모듈)&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Byte)&lt;/td>
&lt;td>8비트 정수&lt;/td>
&lt;td>8 비트&lt;/td>
&lt;td>-128 ~ 127&lt;/td>
&lt;td>작은 범위의 정수에 사용&lt;/td>
&lt;td>byte&lt;/td>
&lt;td>-&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Short)&lt;/td>
&lt;td>16비트 정수&lt;/td>
&lt;td>16 비트&lt;/td>
&lt;td>-32,768 ~ 32,767&lt;/td>
&lt;td>중간 범위의 정수에 사용&lt;/td>
&lt;td>short&lt;/td>
&lt;td>-&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Int)&lt;/td>
&lt;td>32비트 정수&lt;/td>
&lt;td>32 비트&lt;/td>
&lt;td>-2^31 ~ 2^31 - 1&lt;/td>
&lt;td>가장 일반적으로 사용되는 정수 타입&lt;/td>
&lt;td>int&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Long)&lt;/td>
&lt;td>64비트 정수&lt;/td>
&lt;td>64 비트&lt;/td>
&lt;td>-2^63 ~ 2^63 - 1&lt;/td>
&lt;td>매우 큰 정수 값에 사용&lt;/td>
&lt;td>long&lt;/td>
&lt;td>BigInt&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int64&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>사용법:&lt;/p>
&lt;ul>
&lt;li>Java:
&lt;ul>
&lt;li>Boolean: &lt;code>boolean b = true;&lt;/code>&lt;/li>
&lt;li>Character: &lt;code>char c = 'A';&lt;/code>&lt;/li>
&lt;li>String: &lt;code>String s = &amp;quot;Hello&amp;quot;;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>float f = 3.14f;&lt;/code> &lt;code>double d = 3.14;&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>byte b = 100;&lt;/code> &lt;code>short s = 1000;&lt;/code> &lt;code>int i = 10000;&lt;/code> &lt;code>long l = 1000000L;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JavaScript:
&lt;ul>
&lt;li>Boolean: &lt;code>let b = true;&lt;/code>&lt;/li>
&lt;li>String: &lt;code>let s = &amp;quot;Hello&amp;quot;;&lt;/code>&lt;/li>
&lt;li>Number: &lt;code>let n = 3.14;&lt;/code> (모든 숫자는 64비트 부동 소수점)&lt;/li>
&lt;li>BigInt: &lt;code>let bi = 1234567890123456789n;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python:
&lt;ul>
&lt;li>Boolean: &lt;code>b = True&lt;/code>&lt;/li>
&lt;li>String: &lt;code>s = &amp;quot;Hello&amp;quot;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>f = 3.14&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>i = 10000&lt;/code> (자동으로 크기 조정)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go:
&lt;ul>
&lt;li>Boolean: &lt;code>var b bool = true&lt;/code>&lt;/li>
&lt;li>String: &lt;code>var s string = &amp;quot;Hello&amp;quot;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>var f float32 = 3.14&lt;/code> &lt;code>var d float64 = 3.14&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>var i int = 10000&lt;/code> &lt;code>var l int64 = 1000000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>각 언어별 특징:&lt;/p>
&lt;ul>
&lt;li>Java: 가장 세분화된 데이터 타입 지원&lt;/li>
&lt;li>JavaScript: 동적 타입 언어로, 대부분의 숫자를 Number로 처리&lt;/li>
&lt;li>Python: 동적 타입 언어로, 정수와 부동소수점을 자동으로 처리&lt;/li>
&lt;li>Go: 정적 타입 언어로, 명시적인 타입 선언 필요&lt;/li>
&lt;/ul>
&lt;h3>Non-Primitive Data Structure&lt;/h3>&lt;p>Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다. 이는 프로그래밍 언어에서 기본적으로 제공하는 원시 자료형을 조합하여 만든 사용자 정의 자료구조라고도 볼 수 있다.&lt;/p>
&lt;h4>주요 특징&lt;/h4>&lt;ol>
&lt;li>&lt;strong>복합성&lt;/strong>: 여러 원시 자료형을 조합하여 만들어진 복합적인 구조를 가진다.&lt;/li>
&lt;li>&lt;strong>유연성&lt;/strong>: 데이터의 저장, 접근, 수정이 더 유연하게 이루어질 수 있다.&lt;/li>
&lt;li>&lt;strong>동적 크기&lt;/strong>: 대부분의 비원시 자료구조는 크기가 동적으로 변할 수 있다.&lt;/li>
&lt;li>&lt;strong>참조 타입&lt;/strong>: 변수에 값 대신 메모리 주소를 저장한다.&lt;/li>
&lt;/ol>
&lt;h4>분류&lt;/h4>&lt;p>Non-primitive data structure는 크게 두 가지로 분류된다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>Linear Data Structure&lt;/th>
&lt;th>Non-Linear Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>데이터 요소가 순차적으로 배열되어 각 요소가 이전 및 다음 요소와 연결된 구조&lt;/td>
&lt;td>데이터 요소가 계층적으로 구성되어 여러 경로로 연결될 수 있는 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>특징&lt;/td>
&lt;td>- 단일 레벨 구조&lt;br>- 한 번의 실행으로 모든 요소 순회 가능&lt;br>- 구현이 상대적으로 간단&lt;br>- 메모리 사용이 덜 효율적&lt;/td>
&lt;td>- 다중 레벨 구조&lt;br>- 한 번의 실행으로 모든 요소 순회 불가&lt;br>- 구현이 상대적으로 복잡&lt;br>- 메모리 사용이 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 유형&lt;/td>
&lt;td>Array, Linked List, Stack, Queue, Deque&lt;/td>
&lt;td>Graph, Hash-based Structure, Tree, Heap&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>각 데이터 구조의 특징과 주요 프로그래밍 언어에서의 지원 여부 및 사용법&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>유형&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>Java&lt;/th>
&lt;th>JavaScript&lt;/th>
&lt;th>Python&lt;/th>
&lt;th>Go&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Array&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>연속된 메모리 위치에 요소 저장, 인덱스로 빠른 접근 가능&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;td>기본 지원 (List)&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linked List&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>노드가 다음 노드를 가리키는 구조, 삽입/삭제 효율적&lt;/td>
&lt;td>java.util.LinkedList&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stack&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>LIFO 원칙, 푸시/팝 연산&lt;/td>
&lt;td>java.util.Stack&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>리스트로 구현 가능&lt;/td>
&lt;td>슬라이스로 구현 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>FIFO 원칙, 인큐/디큐 연산&lt;/td>
&lt;td>java.util.Queue&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>queue 모듈&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deque&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>양쪽 끝에서 삽입/삭제 가능&lt;/td>
&lt;td>java.util.Deque&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>collections.deque&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Graph&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>노드와 엣지로 구성, 복잡한 관계 표현&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>networkx 라이브러리&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hash-based Structure&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>키-값 쌍으로 데이터 저장, 빠른 검색&lt;/td>
&lt;td>java.util.HashMap&lt;/td>
&lt;td>Object, Map&lt;/td>
&lt;td>dict&lt;/td>
&lt;td>map&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tree&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>계층적 구조, 루트와 자식 노드로 구성&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Heap&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>완전 이진 트리 기반, 최대/최소 값 빠른 접근&lt;/td>
&lt;td>java.util.PriorityQueue&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>heapq 모듈&lt;/td>
&lt;td>container/heap&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>각 언어별 특징:&lt;/p>
&lt;ul>
&lt;li>Java: 대부분의 데이터 구조를 기본적으로 지원하거나 java.util 패키지를 통해 제공한다.&lt;/li>
&lt;li>JavaScript: 배열과 객체를 기본으로 제공하며, 다른 구조는 사용자 정의나 라이브러리를 통해 구현해야 한다.&lt;/li>
&lt;li>Python: 리스트, 딕셔너리, 세트 등 다양한 데이터 구조를 기본으로 제공하며, 추가 모듈을 통해 더 많은 구조를 지원한다.&lt;/li>
&lt;li>Go: 배열, 슬라이스, 맵을 기본으로 제공하며, container 패키지를 통해 list, heap 등을 지원한다.&lt;/li>
&lt;/ul>
&lt;p>이 데이터 구조들은 각각의 특성에 따라 다양한 상황에서 효율적으로 사용될 수 있으며, 프로그래밍 언어별로 지원 방식이 다르므로 적절한 선택이 중요하다.&lt;/p>
&lt;h3>Primitive Data Structure Vs Non-Primitive Data Structure 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Primitive Data Structure&lt;/th>
&lt;th>Non-Primitive Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>프로그래밍 언어에 내장된 기본 데이터 타입&lt;/td>
&lt;td>기본 데이터 타입을 사용하여 구축된 복잡한 데이터 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예시&lt;/td>
&lt;td>정수, 실수, 문자, 불리언&lt;/td>
&lt;td>배열, 연결 리스트, 스택, 큐, 트리, 그래프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>크기&lt;/td>
&lt;td>고정 크기&lt;/td>
&lt;td>동적 크기 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡성&lt;/td>
&lt;td>단순함&lt;/td>
&lt;td>복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 효율성&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>상대적으로 낮음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현&lt;/td>
&lt;td>언어에 내장됨&lt;/td>
&lt;td>사용자 정의 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NULL 값&lt;/td>
&lt;td>일반적으로 허용하지 않음&lt;/td>
&lt;td>허용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>연산&lt;/td>
&lt;td>기본 연산만 지원&lt;/td>
&lt;td>복잡한 연산 및 메서드 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추상화 수준&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 목적&lt;/td>
&lt;td>단순한 데이터 표현&lt;/td>
&lt;td>복잡한 데이터 관계 및 구조 표현&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>공통점:&lt;/p>
&lt;ol>
&lt;li>둘 다 데이터를 저장하고 관리하는 데 사용된다.&lt;/li>
&lt;li>프로그래밍에서 중요한 역할을 한다.&lt;/li>
&lt;li>특정 연산과 조작이 가능하다.&lt;/li>
&lt;/ol>
&lt;p>차이점:&lt;/p>
&lt;ol>
&lt;li>복잡성: Primitive는 단순하고, Non-Primitive는 복잡하다.&lt;/li>
&lt;li>크기: Primitive는 고정 크기, Non-Primitive는 동적 크기가 가능하다.&lt;/li>
&lt;li>구현: Primitive는 언어에 내장되어 있고, Non-Primitive는 사용자가 정의할 수 있다.&lt;/li>
&lt;li>유연성: Non-Primitive는 더 유연하고 다양한 데이터 관계를 표현할 수 있다.&lt;/li>
&lt;li>메모리 사용: Primitive가 일반적으로 더 효율적이다.&lt;/li>
&lt;li>기능: Non-Primitive는 더 복잡한 연산과 메서드를 제공한다.&lt;/li>
&lt;/ol>
&lt;p>Primitive data structure는 기본적이고 효율적인 데이터 표현에 사용되며, Non-Primitive data structure는 복잡한 데이터 관계와 구조를 표현하는 데 사용된다.
프로그래밍에서는 두 유형을 적절히 조합하여 효율적이고 강력한 애플리케이션을 구축한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>CSR vs SSR</title><link>https://buenhyden.github.io/til/2024/11/csr-vs-ssr/</link><pubDate>Sun, 03 Nov 2024 12:28:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/csr-vs-ssr/</guid><description>
&lt;h2>CSR (Client Side Rendering) Vs SSR (Server Side Rendering)&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>비교 항목&lt;/th>
&lt;th>Client Side Rendering (CSR)&lt;/th>
&lt;th>Server Side Rendering (SSR)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>렌더링 방식&lt;/td>
&lt;td>브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링&lt;/td>
&lt;td>서버에서 HTML을 생성하여 클라이언트에 전달&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>초기 로딩 시간&lt;/td>
&lt;td>상대적으로 긺 (JavaScript 번들을 모두 다운로드하고 실행해야 함)&lt;/td>
&lt;td>상대적으로 빠름 (이미 렌더링된 HTML을 받음)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>초기 컨텐츠 표시&lt;/td>
&lt;td>빈 페이지 후 로딩&lt;/td>
&lt;td>즉시 컨텐츠 표시&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>서버 부하&lt;/td>
&lt;td>낮음 (정적 파일만 제공)&lt;/td>
&lt;td>높음 (매 요청마다 HTML 생성)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SEO 친화성&lt;/td>
&lt;td>낮음 (JavaScript 실행 전까지 빈 HTML)&lt;/td>
&lt;td>높음 (완성된 HTML이 검색 엔진에 제공)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>상호작용성&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>상대적으로 낮음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>후속 페이지 로딩&lt;/td>
&lt;td>빠름&lt;/td>
&lt;td>각 요청마다 서버 처리 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Time to First Paint (TFP)&lt;/td>
&lt;td>느림&lt;/td>
&lt;td>빠름&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Time to Interactive (TTI)&lt;/td>
&lt;td>JavaScript 로드 후 빠름&lt;/td>
&lt;td>JavaScript 로드 필요시 추가 시간 소요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용량&lt;/td>
&lt;td>클라이언트 측 높음&lt;/td>
&lt;td>서버 측 높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자 경험&lt;/td>
&lt;td>초기 로딩 후 빠른 페이지 전환&lt;/td>
&lt;td>페이지 전환마다 서버 요청 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>캐싱 전략&lt;/td>
&lt;td>JavaScript 파일과 정적 자원 캐싱 용이&lt;/td>
&lt;td>동적 HTML 캐싱이 복잡할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>개발 복잡도&lt;/td>
&lt;td>상대적으로 단순 (단일 JavaScript 애플리케이션)&lt;/td>
&lt;td>상대적으로 복잡 (서버와 클라이언트 로직 모두 관리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보안&lt;/td>
&lt;td>중요 로직이 클라이언트에 노출될 수 있음&lt;/td>
&lt;td>중요 로직을 서버에서 처리하여 안전&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>오프라인 기능&lt;/td>
&lt;td>구현 용이&lt;/td>
&lt;td>제한적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 업데이트&lt;/td>
&lt;td>실시간 업데이트 용이&lt;/td>
&lt;td>페이지 새로고침 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>대역폭 사용&lt;/td>
&lt;td>초기에 높음, 이후 낮음&lt;/td>
&lt;td>지속적으로 중간 수준&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>서버 인프라 요구사항&lt;/td>
&lt;td>낮음 (정적 호스팅 가능)&lt;/td>
&lt;td>높음 (동적 서버 필요)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리소스 사용&lt;/td>
&lt;td>클라이언트 리소스 많이 사용&lt;/td>
&lt;td>서버 리소스 많이 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 업데이트&lt;/td>
&lt;td>실시간 업데이트 용이&lt;/td>
&lt;td>페이지 새로고침 필요할 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적합한 사용 사례&lt;/td>
&lt;td>대시보드, SPA, 관리자 패널&lt;/td>
&lt;td>블로그, 뉴스 사이트, 전자상거래&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프레임워크 예시&lt;/td>
&lt;td>React, Vue, Angular&lt;/td>
&lt;td>Next.js, Nuxt.js, Angular Universal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유지보수성&lt;/td>
&lt;td>프론트엔드 중심 유지보수&lt;/td>
&lt;td>프론트엔드와 백엔드 모두 유지보수 필요&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이 두 방식은 각각의 장단점이 있으며, 최근에는 이들의 장점을 결합한 하이브리드 렌더링 방식(예: Next.js의 정적 생성과 서버 사이드 렌더링 조합)이 많이 사용되고 있다.&lt;br>
프로젝트의 요구사항과 특성에 따라 적절한 렌더링 방식을 선택하는 것이 중요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Concurrency vs Parallelism</title><link>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</link><pubDate>Fri, 01 Nov 2024 02:38:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</guid><description>
&lt;h2>동시성 (Concurrency) Vs 병렬성 (Parallelism)&lt;/h2>&lt;p>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.&lt;br>
동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.&lt;br>
실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.&lt;/p>
&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/TIL/2024/11/8e925d68-4f47-4ef9-8d51-6a39f19c75d2.jpg"
alt="Concurrent vs Parallel"
loading="lazy" />
&lt;/figure>{: width=&amp;ldquo;700&amp;rdquo; height=&amp;ldquo;400&amp;rdquo; }&lt;br>
&lt;em>Source: &lt;a href="https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism" target="_blank" rel="noopener">https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism&lt;/a>&lt;/em>&lt;/p>
&lt;p>동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.&lt;br>
이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 &amp;ldquo;컨텍스트 스위칭(Context Switching)&amp;ldquo;이라고 한다.&lt;/p>
&lt;p>병렬성(Parallelism)은 여러 작업을 실제로 동시에 처리하는 개념으로, 여러 코어나 프로세서가 필요하며, 실제로 동시에 실행된다. 이로 인해 전체적인 처리 속도를 향상시킬 수 있다.&lt;br>
이러한 작업들은 여러 코어나 프로세서가 각각 독립적인 작업을 동시에 처리하며 각 작업은 서로 다른 하드웨어 자원을 사용한다.&lt;/p>
&lt;h3>동시성(Concurrency)과 병렬성(Parallelism) 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>동시성 (Concurrency)&lt;/th>
&lt;th>병렬성 (Parallelism)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>여러 작업을 번갈아가며 실행하여 동시에 처리되는 것처럼 보이게 함&lt;/td>
&lt;td>여러 작업을 실제로 동시에 처리함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실행 방식&lt;/td>
&lt;td>작업 간 빠른 전환 (Context Switching)&lt;/td>
&lt;td>실제 동시 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>하드웨어 요구사항&lt;/td>
&lt;td>단일 코어로도 가능&lt;/td>
&lt;td>다중 코어 또는 프로세서 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>목적&lt;/td>
&lt;td>응답성 향상, 자원 효율성 증대&lt;/td>
&lt;td>전체 처리 속도 향상&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 특성&lt;/td>
&lt;td>I/O 대기 시간 최소화&lt;/td>
&lt;td>CPU 처리량 최대화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡성&lt;/td>
&lt;td>작업 간 전환과 자원 공유로 인해 복잡할 수 있음&lt;/td>
&lt;td>작업 분할과 결과 통합 과정이 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적용 사례&lt;/td>
&lt;td>웹 서버, 사용자 인터페이스, 멀티태스킹 OS&lt;/td>
&lt;td>대규모 데이터 처리, 과학 계산, 그래픽 렌더링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 방법&lt;/td>
&lt;td>멀티스레딩, 비동기 프로그래밍&lt;/td>
&lt;td>멀티프로세싱, GPU 병렬 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 관리&lt;/td>
&lt;td>자원 공유와 동기화 필요&lt;/td>
&lt;td>각 작업이 독립적인 자원 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 공유&lt;/td>
&lt;td>쉬움 (공유 메모리)&lt;/td>
&lt;td>어려움 (프로세스 간 통신 필요)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리소스 효율성&lt;/td>
&lt;td>대기 시간 활용으로 효율적&lt;/td>
&lt;td>CPU 자원 최대 활용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>공유 메모리 사용&lt;/td>
&lt;td>독립적인 메모리 공간&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>적합한 작업&lt;/td>
&lt;td>I/O 바운드 작업&lt;br>(파일, 네트워크, DB 작업)&lt;/td>
&lt;td>CPU 바운드 작업&lt;br>(복잡한 계산, 데이터 처리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확장성&lt;/td>
&lt;td>단일 시스템 내에서 제한적&lt;br>I/O 작업에 대해 좋은 확장성&lt;/td>
&lt;td>여러 시스템으로 확장 가능&lt;br>CPU 코어 수에 비례하여 확장&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 향상&lt;/td>
&lt;td>응답 시간 개선에 중점&lt;/td>
&lt;td>처리량 증가에 중점&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>에러 처리&lt;/td>
&lt;td>상대적으로 단순&lt;/td>
&lt;td>복잡한 동기화 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디버깅 난이도&lt;/td>
&lt;td>상대적으로 어려움 (타이밍 이슈)&lt;/td>
&lt;td>매우 어려움 (동시성 문제 + 분산 시스템 이슈)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>프로그래밍 모델&lt;/td>
&lt;td>이벤트 기반, 콜백, Promises 등&lt;/td>
&lt;td>MapReduce, 데이터 병렬화 등&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>선택 기준표&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상황&lt;/th>
&lt;th>권장 방식&lt;/th>
&lt;th>이유&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>웹 서버 개발&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>대부분 I/O 작업 위주&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이미지 처리&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>CPU 집약적 작업&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용자 인터페이스&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>반응성 향상 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>대규모 데이터 분석&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>독립적인 데이터 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실시간 스트리밍&lt;/td>
&lt;td>동시성&lt;/td>
&lt;td>지속적인 I/O 처리 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>과학적 계산&lt;/td>
&lt;td>병렬성&lt;/td>
&lt;td>복잡한 계산 작업 분할 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>성능 비교표&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>작업 유형&lt;/th>
&lt;th>동시성 성능&lt;/th>
&lt;th>병렬성 성능&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>I/O 작업&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;td>보통&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CPU 작업&lt;/td>
&lt;td>보통&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>효율적&lt;/td>
&lt;td>많은 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>응답 시간&lt;/td>
&lt;td>일관적&lt;/td>
&lt;td>변동 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>처리량&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 활용&lt;/td>
&lt;td>효율적&lt;/td>
&lt;td>최대화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3>참고 및 출처&lt;/h3></description></item></channel></rss>