<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>11 :: hyunyoun's Blog</title><link>https://buenhyden.github.io/til/2024/11/</link><description/><generator>Hugo</generator><language>en</language><managingEditor>chochyjj@gmail.com (Hyunyoun Jo)</managingEditor><webMaster>chochyjj@gmail.com (Hyunyoun Jo)</webMaster><lastBuildDate>Thu, 28 Nov 2024 08:03:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/til/2024/11/index.xml" rel="self" type="application/rss+xml"/><item><title>Validation and Verification</title><link>https://buenhyden.github.io/til/2024/11/validation-and-verification/</link><pubDate>Thu, 28 Nov 2024 08:03:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/validation-and-verification/</guid><description>Verification은 "제품을 올바르게 만들고 있는가?"를 확인하는 과정이고, Validation은 "올바른 제품을 만들고 있는가?"를 확인하는 과정이다.</description></item><item><title>동적테스트(Dynamic Test)와 정적테스트(Static Test)</title><link>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</link><pubDate>Thu, 28 Nov 2024 02:35:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/</guid><description>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.</description></item><item><title>마이그레이션 (Migration)</title><link>https://buenhyden.github.io/til/2024/11/migration/</link><pubDate>Tue, 26 Nov 2024 15:05:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/migration/</guid><description>IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정</description></item><item><title>API Gateway</title><link>https://buenhyden.github.io/til/2024/11/api-gateway/</link><pubDate>Tue, 26 Nov 2024 09:40:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/api-gateway/</guid><description>클라이언트와 백엔드 서비스 사이에서 중개자 역할을 하는 서버로, 여러 마이크로서비스나 백엔드 시스템에 대한 단일 진입점을 제공하는 중요한 컴포넌트</description></item><item><title>ER(Entity-Relationship) 모델링</title><link>https://buenhyden.github.io/til/2024/11/entity-relationship-modeling/</link><pubDate>Mon, 25 Nov 2024 02:06:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/entity-relationship-modeling/</guid><description>실제 세계의 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 표현하여 데이터베이스를 설계하는 방법</description></item><item><title>Software Architecture pattern and Software Design Pattern</title><link>https://buenhyden.github.io/til/2024/11/software-architecture-pattern-and-software-design-pattern/</link><pubDate>Sat, 23 Nov 2024 08:19:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/software-architecture-pattern-and-software-design-pattern/</guid><description>Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다. 이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.</description></item><item><title>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</title><link>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous-and-blocking-and-non-blocking/</link><pubDate>Sun, 17 Nov 2024 12:30:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous-and-blocking-and-non-blocking/</guid><description>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</description></item><item><title>Lock and Mutex</title><link>https://buenhyden.github.io/til/2024/11/lock-and-mutex/</link><pubDate>Sun, 17 Nov 2024 11:25:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/lock-and-mutex/</guid><description>Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.</description></item><item><title>VueJS vs ReactJS vs NextJS</title><link>https://buenhyden.github.io/til/2024/11/vuejs-vs-reactjs-vs-nextjs/</link><pubDate>Sun, 17 Nov 2024 04:51:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/vuejs-vs-reactjs-vs-nextjs/</guid><description>VueJS, ReactJS, NextJS는 현대 웹 개발에서 사용되는 주요 프론트엔드 프레임워크와 라이브러리들이다.</description></item><item><title>ExpressJS vs NestJS</title><link>https://buenhyden.github.io/til/2024/11/expressjs-vs-nestjs/</link><pubDate>Sun, 17 Nov 2024 04:50:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/expressjs-vs-nestjs/</guid><description>Express.js와 Nest.js는</description></item><item><title>ASGI CGI WSGI</title><link>https://buenhyden.github.io/til/2024/11/asgi-cgi-wsgi-%EB%B9%84%EA%B5%90/</link><pubDate>Sat, 16 Nov 2024 03:26:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/asgi-cgi-wsgi-%EB%B9%84%EA%B5%90/</guid><description>웹 서버와 애플리케이션 간의 통신 방식을 정의하는 인터페이스 규격</description></item><item><title>Blocking vs Non-Blocking</title><link>https://buenhyden.github.io/til/2024/11/blocking-vs-non-blocking/</link><pubDate>Tue, 12 Nov 2024 12:36:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/blocking-vs-non-blocking/</guid><description>프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.</description></item><item><title>동기(Synchronous)와 비동기(Asynchronous)</title><link>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous/</link><pubDate>Tue, 12 Nov 2024 00:57:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous/</guid><description>프로그래밍에서 작업을 처리하는 두 가지 주요 방식</description></item><item><title>Session base Auth and Cookie base Auth</title><link>https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/</link><pubDate>Mon, 11 Nov 2024 02:10:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/</guid><description>세션 기반 인증(Session Based Authentication)과 쿠키 기반 인증(Cookie Based Authentication)은 웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식이다.</description></item><item><title>Linear Data Structure vs Non-Linear Data Structure</title><link>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</link><pubDate>Wed, 06 Nov 2024 11:00:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</guid><description>Linear Data Structure Vs Non-Linear Data Structure</description></item><item><title>Primitive data structure vs Non-Primitive data structure</title><link>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</link><pubDate>Wed, 06 Nov 2024 08:39:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</guid><description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description></item><item><title>CSR vs SSR</title><link>https://buenhyden.github.io/til/2024/11/csr-vs-ssr/</link><pubDate>Sun, 03 Nov 2024 12:28:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/csr-vs-ssr/</guid><description>Client Side Rendering (CSR)은 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링하며, Server Side Rendering (SSR)은 서버에서 HTML을 생성하여 클라이언트에 전달한다.</description></item><item><title>Concurrency vs Parallelism</title><link>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</link><pubDate>Fri, 01 Nov 2024 02:38:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2024/11/concurrency-vs-parallelism/</guid><description>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다. 동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.</description></item></channel></rss>