<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>01 | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="01 - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/11/01/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/til/2024/11/01/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/11/01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/11/01/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="01"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="01"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"11","item":"https://buenhyden.github.io/til/2024/11/"},{"@type":"ListItem","position":4,"name":"01","item":"https://buenhyden.github.io/til/2024/11/01/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/11/>11</a></div><h1>01</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx vs Apache HTTP Server vs Caddy</h2></header><div class=entry-content><p>Nginx Vs Apache HTTP Server Vs Caddy Nginx, Apache HTTP Server, 그리고 Caddy는 모두 웹 서버 소프트웨어입니다
Nginx는 2004년에 출시된 고성능 웹 서버로, 비동기 이벤트 기반 아키텍처를 사용한다.
주로 정적 콘텐츠 제공, 리버스 프록시, 로드 밸런싱에 사용되며, 적은 리소스로도 많은 동시 연결을 처리할 수 있다.
C언어로 작성되었으며, 현대적인 웹 서비스에서 널리 사용된다.
Apache HTTP Server는 1995년부터 시작된 가장 오래된 웹 서버 중 하나이다.
프로세스/스레드 기반의 아키텍처를 사용하며, 풍부한 모듈 시스템을 통해 다양한 기능을 확장할 수 있다.
안정성과 유연성이 뛰어나며, 광범위한 커뮤니티 지원을 받고 있다.
...</p></div><footer class=entry-footer><span title='2024-11-01 11:42:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;285 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Nginx vs Apache HTTP Server vs Caddy" href=https://buenhyden.github.io/til/2024/11/01/nginx-vs-apache-tomcat-vs-caddy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka Vs RabbitMQ Kafka와 RabbitMQ는 모두 메시지 브로커 시스템으로, 분산 시스템에서 데이터를 효율적으로 전송하고 처리하는 역할을 한다.
Apache Kafka:
분산 스트리밍 플랫폼 대용량 실시간 데이터 처리에 최적화 높은 처리량과 확장성 제공 데이터 스트림의 발행/구독, 저장, 처리 기능 제공 RabbitMQ:
메시지 지향 미들웨어 AMQP(Advanced Message Queuing Protocol) 구현 다양한 메시징 패턴 지원 신뢰성 있는 메시지 전달과 라우팅 기능 제공 Kafka Vs RabbitMQ 비교 분석 특성 Apache Kafka RabbitMQ 아키텍처 분산 로그 메시지 브로커 주요 용도 대용량 실시간 데이터 스트리밍 일반적인 메시징 시나리오 성능 매우 높은 처리량 중간 수준의 처리량 메시지 순서 파티션 내에서 보장 FIFO 큐로 보장 메시지 보존 장기간 보존 가능 일반적으로 단기 보존 확장성 수평적 확장 용이 클러스터링 지원 프로토콜 자체 프로토콜 AMQP, MQTT 등 다양한 프로토콜 지원 라우팅 복잡성 상대적으로 단순 복잡한 라우팅 가능 클라이언트 지원 제한적 다양한 언어 지원 관리 용이성 상대적으로 복잡 사용자 친화적 관리 도구 Kafka 선택이 좋은 경우: 대용량 데이터 처리가 필요할 때 실시간 스트림 처리가 중요할 때 높은 처리량이 요구될 때 장기간의 데이터 보존이 필요할 때 RabbitMQ 선택이 좋은 경우: 복잡한 라우팅이 필요할 때 전통적인 메시징 패턴을 사용할 때 낮은 지연시간이 중요할 때 관리의 용이성이 중요할 때 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-01 11:41:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;187 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/til/2024/11/01/kafka-vs-rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-01 01:34:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;154 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/til/2024/11/01/redis%EC%99%80-valkey/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ER(Entity-Relationship) 모델링</h2></header><div class=entry-content><p>ER(Entity-Relationship) 모델링 ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.
![An entity–attribute-relationship diagram for an MMORPG using Chen’s notation](1024px-ER_Diagram_MMORPG.png “https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png_
주요 구성 요소 개체(Entity)
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.
예를 들어, ‘학생’, ‘강좌’, ‘교수’ 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.
예시:
학생 개체의 경우: 실체: 개별 학생들 표현: ‘학생’ 이라는 개체로 모델링 속성: 학번, 이름, 학과, 연락처 등 속성(Attribute)
속성은 개체의 특성이나 성질을 나타낸다.
타원형으로 표현되며, 개체와 선으로 연결된다.
속성의 종류: 단일값 속성: 하나의 값만 가지는 속성 (예: 학번) 다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호) 유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이) 키 속성: 개체를 유일하게 식별하는 속성 (예: 학번) 관계(Relationship)
관계는 개체들 간의 연관성을 나타낸다.
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.
관계의 종류: 일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결 일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결 다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결
관계 표현 예시: 1 2 3 4 5 [학생] ----&lt; 수강 >---- [강좌] | | (학번) (과목코드) (이름) (과목명) (학과) (학점) ER 모델링의 단계 요구사항 분석
시스템에서 필요한 데이터와 기능을 파악한다.
예: “대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…”
...</p></div><footer class=entry-footer><span title='2024-11-01 02:06:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;355 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ER(Entity-Relationship) 모델링" href=https://buenhyden.github.io/til/2024/11/01/entity-relationship-modeling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elasticsearch and Opensearch</h2></header><div class=entry-content><p>Elasticsearch and Opensearch Elasticsearch와 OpenSearch는 이러한 대규모 데이터를 효율적으로 저장하고 검색할 수 있게 해주는 검색 엔진.
Elasticsearch와 OpenSearch의 비교 분석 항목 Elasticsearch OpenSearch 출시/개발 Elastic NV에서 개발, 2010년 출시 AWS가 Elasticsearch 7.10.2 버전을 포크하여 개발, 2021년 출시 라이선스 SSPL/Elastic 라이선스, AGPL(2024.08.29 추가) Apache 2.0 라이선스 호환성 Elastic Stack과 완벽한 통합 Elasticsearch API와 호환, 독립적인 생태계 구축 중 기능성 고급 기능들이 유료 라이선스로 제한 대부분의 기능이 무료로 제공 클라우드 지원 Elastic Cloud를 통한 관리형 서비스 AWS OpenSearch Service를 통한 관리형 서비스 보안 기능 기본 보안 기능 무료, 고급 기능 유료 대부분의 보안 기능 무료 제공 모니터링 Kibana를 통한 모니터링 OpenSearch Dashboards를 통한 모니터링 플러그인 생태계 풍부한 플러그인 생태계 성장 중인 플러그인 생태계 학습 자료 풍부한 문서와 커뮤니티 자료 상대적으로 적은 문서와 커뮤니티 자료 성능 매우 우수한 성능 Elasticsearch와 비슷한 수준의 성능 확장성 수평적 확장 용이 수평적 확장 용이 사용 난이도 초기 설정이 비교적 복잡 초기 설정이 비교적 단순 업데이트 주기 정기적인 업데이트 정기적인 업데이트 비용 고급 기능에 대한 라이선스 비용 발생 대부분 무료로 사용 가능 2024년 8월 29일 Elastic의 발표에 따르면,
Elasticsearch와 Kibana의 오픈소스 부분에 대해 GNU Affero General Public License v3 (AGPL)를 새로운 라이선스 옵션으로 추가하였다. 이는 기존의 Server Side Public License (SSPL)와 Elastic License 2.0 (ELv2) 옵션과 함께 제공된다.
주요 변경 사항:
...</p></div><footer class=entry-footer><span title='2024-11-01 06:06:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;347 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Elasticsearch and Opensearch" href=https://buenhyden.github.io/til/2024/11/01/elasticsearch-and-opensearch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) and Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) and Web Server 비교 항목 Web Application Server (WAS) Web Server 기본 개념 동적 컨텐츠를 처리하고 생성하는 미들웨어로, 애플리케이션의 로직을 실행하고 데이터베이스와 상호작용 클라이언트의 HTTP 요청을 처리하고 정적 컨텐츠(HTML, 이미지 등)를 제공하는 서버 주요 기능 - 동적 컨텐츠 생성
- 비즈니스 로직 처리
- 데이터베이스 연동
- 트랜잭션 관리
- 세션 관리 - 정적 파일 제공
- 리버스 프록시
- 로드 밸런싱
- 캐싱
- 보안 설정 처리 방식 요청을 받아 서버 내부에서 프로그램을 실행하고 결과를 동적으로 생성하여 응답 클라이언트 요청에 대해 이미 존재하는 정적 파일을 직접 전송 리소스 사용 CPU와 메모리를 많이 사용하며, 동적 처리로 인한 부하가 높음 상대적으로 적은 리소스를 사용하며, 정적 파일 처리에 최적화 성능 특성 - 동적 처리로 인한 지연 발생
- 복잡한 연산 가능
- 상대적으로 느린 응답 시간 - 빠른 응답 속도
- 높은 동시성 처리
- 단순한 요청 처리에 최적화 확장성 - 수직적/수평적 확장 가능
- 로드 밸런싱 필요
- 세션 클러스터링 고려 필요 - 쉬운 수평적 확장
- 단순한 로드 밸런싱
- 상태를 유지하지 않음 보안 - 애플리케이션 레벨 보안
- 인증/인가 처리
SQL 인젝션 방어
XSS 방어 - 네트워크 레벨 보안
SSL/TLS 처리
DDoS 방어
IP 기반 접근 제어 대표적 제품 - Apache Tomcat
JBoss/WildFly
WebLogic
WebSphere - Apache HTTP Server
Nginx
IIS
LiteSpeed 사용 사례 - 전자상거래 시스템
- 온라인 뱅킹
CRM 시스템
ERP 시스템 - 기업 웹사이트
- 블로그
- 포트폴리오 사이트
- 정적 문서 호스팅 프로그래밍 지원 Java, Python, PHP,.NET 등 다양한 프로그래밍 언어와 프레임워크 지원 제한된 스크립팅 기능만 제공 (주로 설정 파일을 통한 제어) 세션 관리 세션 생성, 유지, 만료 처리 등 복잡한 세션 관리 기능 제공 세션 관리 기능 없음 데이터베이스 연동 데이터베이스 커넥션 풀 관리 및 트랜잭션 처리 데이터베이스 연동 기능 없음 모니터링 - 애플리케이션 성능 모니터링
- 메모리 사용량
- 쓰레드 상태
DB 커넥션 상태 - HTTP 요청/응답 모니터링
- 네트워크 트래픽
- 리소스 사용량 장애 대응 - 애플리케이션 레벨 장애 복구
- 트랜잭션 롤백
- 세션 복구 - 서버 레벨 장애 복구
- 정적 파일 백업
- 서버 이중화 구성 복잡도 복잡한 설정과 최적화 필요 상대적으로 단순한 설정 운영 비용 높은 하드웨어 요구사항과 관리 비용 상대적으로 낮은 운영 비용 캐싱 메커니즘 - 동적 컨텐츠 캐싱
- 데이터베이스 쿼리 캐싱
- 세션 데이터 캐싱 - 정적 파일 캐싱
HTTP 응답 캐싱
- 리버스 프록시 캐싱 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-01 07:36:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;378 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) and Web Server" href=https://buenhyden.github.io/til/2024/11/01/web-application-server-and-web-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue vs Message Broker vs Event Broker</h2></header><div class=entry-content><p>Message Queue Vs Message Broker Vs Event Broker Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:
특성 Message Queue Message Broker Event Broker 주요 기능 메시지 저장 및 전달 메시지 라우팅, 변환, 저장 이벤트 라우팅, 스트리밍, 저장 통신 모델 주로 점대점(Point-to-Point) 점대점 및 발행-구독(Pub/Sub) 주로 발행-구독(Pub/Sub) 메시지 보존 소비 후 일반적으로 삭제 구성에 따라 다름 장기간 보존 가능 확장성 제한적 중간 높음 복잡성 낮음 중간 높음 주요 사용 사례 작업 큐잉, 비동기 처리 시스템 통합, 프로토콜 변환 실시간 데이터 스트리밍, 이벤트 소싱 메시지 순서 보장 일반적으로 보장 보장 가능 재생 기능 제한적 구성에 따라 다름 일반적으로 지원 프로토콜 지원 제한적 다양한 프로토콜 지원 다양한 프로토콜 지원 대표적 제품 RabbitMQ, Redis Apache Kafka, RabbitMQ Apache Kafka, Amazon Kinesis Message Queue Vs Message Broker Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-11-01 07:27:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;760 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue vs Message Broker vs Event Broker" href=https://buenhyden.github.io/til/2024/11/01/message-queue-vs-message-broker-vs-event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h2></header><div class=entry-content><p>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.
기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성
• 우수한 확장성
• 효율적인 로드밸런싱
• 실시간 데이터 동기화 • 구현이 상대적으로 간단
• 비용 효율적
• 지리적 분산 용이
• 읽기 성능 향상 단점 • 구현 비용이 높음
• 복잡한 구성
• 네트워크 대역폭 필요
• 관리 어려움 • 데이터 일관성 보장 어려움
• 쓰기 성능 향상 제한적
• 마스터 노드 병목 현상
• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리
• 실시간 데이터 처리
• 무중단 서비스 필요
• 대규모 동시 접속 처리 • 데이터 백업
• 읽기 작업이 많은 서비스
• 지역별 서비스 제공
• 재해 복구 대비 산업 분야 • 금융 거래 시스템
• 통신 서비스
• 대형 전자상거래
• 실시간 예약 시스템 • 콘텐츠 제공 서비스
• 분석 리포팅 시스템
• 글로벌 서비스
• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요
• 낮은 지연시간 필수
• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능
• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요
• 동일한 사양의 노드 권장
• 충분한 메모리 • 마스터 노드 성능 중요
• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요
• 모니터링 시스템 필수
• 정기적인 유지보수 • 상대적으로 간단한 관리
• 백업 정책 중요
• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-01 15:42:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;476 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)" href=https://buenhyden.github.io/til/2024/11/01/database-clustering-and-replication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 불일치 (Data Inconsistency)</h2></header><div class=entry-content><p>데이터 불일치 (Data Inconsistency) 동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황
Source: https://www.geeksforgeeks.org/what-is-data-inconsistency-in-dbms/
발생 조건 데이터 불일치가 발생하는 주요 조건:
동시성 작업 여러 프로세스나 스레드가 동시에 데이터를 수정할 때 트랜잭션이 적절히 관리되지 않을 때 분산 환경 네트워크 지연이나 실패가 발생할 때 데이터 복제 과정에서 시간 차이가 발생할 때 캐싱 문제 캐시 무효화가 제대로 이루어지지 않을 때 캐시와 원본 데이터 간의 동기화 실패 시스템 오류 하드웨어 오류, 네트워크 문제, 소프트웨어 버그 등으로 인해 발생할 수 있다. 데이터 통합 문제: 서로 다른 소스의 데이터를 통합할 때 발생할 수 있다 해결책 및 방지책 데이터 표준화: 데이터 형식, 값, 표현을 일관되게 만든다. 데이터 검증: 데이터 입력 시 유효성 검사를 수행한다. 데이터 정제: 오류를 식별하고 수정하는 과정을 거친다. 데이터 거버넌스: 데이터 관리에 대한 명확한 정책과 절차를 수립한다. 동기화 메커니즘: 분산 시스템에서 데이터 동기화를 위한 알고리즘을 사용한다. 실제 시스템에서의 예방책 데이터 감사: 정기적인 데이터 감사를 통해 불일치를 식별한다. 자동화 도구 사용: 데이터 품질 관리 도구를 활용하여 불일치를 자동으로 탐지한다. 데이터 프로파일링: 데이터의 특성을 이해하고 잠재적 문제를 파악한다. 버전 관리: 데이터 변경 이력을 추적하여 불일치 발생 시 원인을 파악한다. 고려사항 및 주의사항 성능 영향: 데이터 일관성 유지 메커니즘이 시스템 성능에 미치는 영향을 고려해야 한다. 확장성: 대규모 분산 시스템에서의 데이터 일관성 유지 방법을 고려해야 한다. 사용자 교육: 데이터 입력 및 수정 시 주의사항에 대해 사용자를 교육해야 한다. 비즈니스 규칙 반영: 데이터 일관성 규칙에 비즈니스 로직을 반영해야 한다. 주의 사항 및 모범 사례 버전 관리 모든 데이터 변경에 버전 번호 부여 낙관적 락킹 구현 충돌 감지 및 해결 메커니즘 구축 캐시 전략 Cache-Aside 패턴 사용 적절한 TTL(Time-To-Live) 설정 캐시 무효화 전략 수립 동기화 메커니즘 분산 락 사용 이벤트 기반 동기화 멱등성 보장 모니터링 및 감사 버전 이력 관리 변경 로그 기록 불일치 감지 알림 실제 구현시 고려사항 확장성 수평적 확장을 고려한 설계 샤딩 전략 수립 복제 지연 관리 성능 캐시 적중률 최적화 인덱스 전략 수립 배치 처리 활용 복구 전략 백업 및 복구 계획 롤백 메커니즘 데이터 정합성 검증 모범 사례 단일 진실 소스(Single Source of Truth) 유지 데이터 품질 메트릭 정의 및 모니터링 데이터 소유권 및 책임 명확화 지속적인 데이터 품질 개선 프로세스 구축 데이터 불일치 해결을 위한 명확한 워크플로우 수립 파이썬 예제로 보는 데이터 불일치 다음은 데이터 불일치가 발생할 수 있는 상황과 이를 해결하는 방법을 보여주는 예제
...</p></div><footer class=entry-footer><span title='2024-11-01 07:22:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;975 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 불일치 (Data Inconsistency)" href=https://buenhyden.github.io/til/2024/11/01/data-inconsistency/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>