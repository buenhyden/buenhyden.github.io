<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>동적테스트(Dynamic Test)와 정적테스트(Static Test) | hyunyoun's Blog</title>
<meta name=keywords content="QA,QC,Quality-Assurance,Quality-Control,Test,Dynamic-Test,Static-Test"><meta name=description content="소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="동적테스트(Dynamic Test)와 정적테스트(Static Test)"><meta property="og:description" content="소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2024-11-28T02:35:00+00:00"><meta property="article:modified_time" content="2024-11-28T02:35:00+00:00"><meta property="article:tag" content="QA"><meta property="article:tag" content="QC"><meta property="article:tag" content="Quality-Assurance"><meta property="article:tag" content="Quality-Control"><meta property="article:tag" content="Test"><meta property="article:tag" content="Dynamic-Test"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="동적테스트(Dynamic Test)와 정적테스트(Static Test)"><meta name=twitter:description content="소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"11","item":"https://buenhyden.github.io/til/2024/11/"},{"@type":"ListItem","position":4,"name":"동적테스트(Dynamic Test)와 정적테스트(Static Test)","item":"https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"동적테스트(Dynamic Test)와 정적테스트(Static Test)","name":"동적테스트(Dynamic Test)와 정적테스트(Static Test)","description":"소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.","keywords":["QA","QC","Quality-Assurance","Quality-Control","Test","Dynamic-Test","Static-Test"],"articleBody":"동적테스트(Dynamic Test)와 정적테스트(Static Test) 동적테스트 (Dynamic Test)과 정적테스트(Static Test)\n소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.\n이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.\n효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.\n예를 들어:\n개발 초기 단계: 정적 테스팅으로 기본적인 문제 해결 코드 리뷰로 설계 문제 조기 발견 개발 중기: 단위 테스트로 개별 기능 검증 통합 테스트로 모듈 간 상호작용 확인 개발 후기: 시스템 테스트로 전체 기능 검증 성능 테스트로 실제 환경 적합성 확인 동적 테스트 (Dynamic Test) 소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.\n소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.\n소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.\n동적 테스팅의 기본 원리 동적 테스팅은 실행 시점의 프로그램 행동을 관찰한다.\n프로그램이 실제 환경에서 어떻게 동작하는지, 어떤 결과를 출력하는지, 얼마나 빠르게 처리하는지 등을 직접적으로 확인할 수 있다.\n예를 들어, 웹 애플리케이션을 테스트할 때 실제 사용자처럼 로그인을 시도하고 데이터를 입력하면서 시스템의 반응을 검증한다.\n동적 테스팅의 특징 실행 기반: 프로그램을 실제로 실행하여 메모리 사용, 성능, 보안 취약점, 오류 등을 분석한다. 테스트 환경: 소프트웨어가 실행될 실제 또는 가상 환경에서 분석이 이루어진다. 런타임 문제 발견: 메모리 누수, 경쟁 조건, 예외 처리 문제 등 실행 중에만 드러나는 문제를 발견할 수 있다. 실제 사용 환경 반영: 소프트웨어가 실제로 어떻게 동작하는지, 실제 환경에서의 성능과 안정성을 평가할 수 있다. 동적 테스팅의 장점 오류 탐색 정확도 높음: 실제 실행 환경에서 테스트하므로 오류를 정확하게 찾아낼 수 있다. 실제 사용 시나리오 검증: 사용자 관점에서 소프트웨어의 동작을 검증할 수 있다. 복잡한 버그 발견: 여러 컴포넌트 간의 상호작용에서 발생하는 복잡한 버그를 찾아낼 수 있다. 성능 및 보안 평가: 실제 운영 환경에서의 성능을 측정하고 보안 취약점을 발견할 수 있다. 사용자 경험 검증: 실제 사용자 상호작용을 시뮬레이션하여 사용자 경험을 검증할 수 있다. 조기 피드백: 개발 과정 초기에 문제를 발견하여 효과적인 개선이 가능하다. 동적 테스팅 비교 분석 각 테스트 방법은 소프트웨어 개발 생명주기의 다른 단계에서 중요한 역할을 한다:\n단위 테스트는 개발 초기 단계에서 개별 코드 단위의 정확성을 확인한다. 통합 테스트는 여러 모듈이 결합될 때 정상적으로 작동하는지 검증한다. 기능 테스트는 소프트웨어의 기능적 요구사항 충족 여부를 확인한다. 보안 테스트는 시스템의 취약점을 식별하고 보안 위협을 방지한다. 성능 테스트는 시스템의 속도, 안정성, 확장성 등을 평가한다. 수용 테스트는 최종 사용자 관점에서 요구사항 충족 여부를 확인한다. 스모크 테스트는 빌드의 기본적인 안정성을 빠르게 확인한다. 엔드투엔드 테스트는 전체 시스템의 흐름을 처음부터 끝까지 검증한다. 테스트 유형 주요 목적 테스트 범위 수행 시점 수행 주체 특징 단위테스트 개별 구성 요소의 정확성 검증 함수, 메서드, 클래스 단위 개발 단계 개발자 자동화가 용이, 빠른 피드백 가능 통합테스트 모듈 간 상호작용 검증 여러 모듈의 결합 단위테스트 이후 개발자/QA 모듈 간 인터페이스 검증에 중점 기능테스트 기능적 요구사항 충족 확인 개별 기능 단위 개발 완료 후 QA 팀 사용자 시나리오 기반 검증 보안테스트 보안 취약점 발견 전체 시스템 개발 후반/운영 중 보안 전문가 주기적인 수행 필요 성능테스트 시스템 성능 검증 전체 시스템 개발 후반 성능 테스트 전문가 특수 도구 활용 필요 수용테스트 사용자 요구사항 충족 확인 전체 시스템 개발 완료 후 최종 사용자/고객 실제 사용자 참여 필수 스모크테스트 기본 기능 동작 확인 핵심 기능 빌드 직후 QA 팀 빠른 수행, 간단한 검증 엔드투엔드테스트 전체 비즈니스 프로세스 검증 전체 시스템 통합 완료 후 QA 팀 실제 환경과 유사한 조건에서 수행 정적 테스트(Static Test) 프로그램을 실행하지 않고 수행하는 테스트 방식\n소프트웨어 개발 과정에서 생산되는 문서(코드, 설계서, 분석서, 계획서, 표준)에 대한 검토를 통해 오류를 발견하는 비실행 기반 테스트.\n정적 테스팅의 기본 원리 정적 테스팅은 소프트웨어의 정적 측면, 즉 실행하지 않고도 확인할 수 있는 특성들을 검사한다.\n예를 들어, 코딩 표준 준수 여부, 변수 명명 규칙, 들여쓰기 등의 코드 스타일부터 메모리 누수 가능성이나 보안 취약점과 같은 잠재적 문제까지 다양한 측면을 검토한다.\n정적 테스팅의 특징 코드 실행 없이 수행: 프로그램을 실행하지 않고 소스 코드나 문서를 검토 조기 결함 발견: 개발 초기 단계에서 잠재적 문제를 식별 다양한 검토 대상: 코드, 요구사항 문서, 설계 문서 등 다양한 산출물 검토 수동 및 자동화 방식: 인력에 의한 리뷰와 도구를 이용한 자동 분석 병행 코딩 표준 준수 확인: 코딩 규칙, 가이드라인 준수 여부 검사 정적 테스팅의 장점 조기 결함 발견: 개발 초기에 문제를 발견하여 수정 비용과 시간 절감 비용 효율성: 동적 테스팅에 비해 적은 비용으로 결함 발견 가능 코드 품질 향상: 코딩 표준 준수와 구조적 문제 해결로 전반적인 코드 품질 개선 보안성 강화: 보안 취약점을 조기에 발견하고 수정 가능 개발 생산성 향상: 결함의 조기 발견으로 개발 과정의 효율성 증대 협업 개선: 코드 리뷰를 통한 팀원 간 지식 공유와 의사소통 촉진 테스트 범위 확대: 동적 테스팅으로 발견하기 어려운 결함 식별 가능 정적 테스팅 비교 분석 Reviews (리뷰) 분류 설명 특징 장점 단점 적용 사례 Informal Review • 공식적인 절차 없이 진행되는 검토 방식\n• 개발자 간 자유로운 토론과 피드백 • 절차와 문서화 최소화\n• 빠른 피드백\n• 자유로운 의견 교환 • 즉각적인 피드백 가능\n• 팀 내 지식 공유 촉진\n• 낮은 진입 장벽 • 체계적인 추적이 어려움\n• 검토 누락 가능성\n• 품질 보증의 공식적 증거로 부족 • 일상적인 코드 검토\n• quick fix 검증\n• 소규모 변경사항 검토 Technical Review • 기술적 관점에서의 상세 검토\n• 동료 검토 중심의 체계적 접근 • 기술적 완성도 중점\n• 대안 제시\n• 체크리스트 활용 • 기술적 결함 조기 발견\n• 설계 개선 기회 제공\n• 기술 표준 준수 확인 • 많은 시간과 자원 소요\n• 참여자의 전문성 필요\n• 범위 설정의 어려움 • 아키텍처 검토\n• 성능 최적화 검증\n• 보안 취약점 분석 Walkthrough • 작성자가 주도하는 단계별 검토\n• 교육적 효과 중시 • 시나리오 기반 검토\n• 상호 학습 기회\n• 단계별 설명 • 지식 전파 효과적\n• 팀 이해도 향상\n• 새로운 관점 발견 • 작성자 편향 가능성\n• 시간 소요가 큼\n• 객관성 확보 어려움 • 신규 팀원 교육\n• 복잡한 로직 설명\n• 프로세스 이해 Inspection • 가장 공식적이고 체계적인 검토\n• 철저한 문서화와 추적 • 역할 분담 명확\n• 체계적 절차\n• 상세한 문서화 • 높은 결함 발견율\n• 품질 보증 증거 확보\n• 체계적 개선 가능 • 높은 비용과 시간\n• 과도한 문서화 부담\n• 유연성 부족 • 중요 시스템 검증\n• 품질 인증 준비\n• 규제 준수 확인 Static Analysis (정적 분석) 분류 설명 특징 장점 단점 적용 사례 Syntax Analysis • 코드의 문법적 오류 검출\n• 컴파일러 수준의 검사 • 자동화된 검사\n• 즉각적 피드백\n• 기본적 오류 검출 • 빠른 오류 발견\n• 개발 생산성 향상\n• 기본적 품질 보장 • 의미적 오류 발견 불가\n• 단순 오류만 검출\n• 컨텍스트 이해 부족 • 컴파일 전 검사\n• IDE 통합 검사\n• 기본 코드 검증 Data Flow Analysis • 데이터의 흐름과 사용 패턴 분석\n• 변수 사용의 적절성 검증 • 변수 추적\n• 초기화 검사\n• 사용 패턴 분석 • 데이터 관련 버그 발견\n• 메모리 누수 방지\n• 안정성 향상 • 분석 비용 높음\n• 오탐 가능성\n• 복잡한 패턴 분석 어려움 • 메모리 관리 검증\n• 변수 사용 분석\n• 초기화 오류 검출 Control Flow Analysis • 프로그램 실행 경로 분석\n• 로직 흐름 검증 • 경로 분석\n• 도달성 검사\n• 순환 복잡도 측정 • 논리적 오류 발견\n• 코드 복잡도 관리\n• 실행 경로 최적화 • 동적 경로 예측 한계\n• 복잡한 조건 분석 어려움\n• 성능 오버헤드 • 분기문 검증\n• 데드코드 탐지\n• 복잡도 측정 Code Quality Analysis • 코딩 표준 준수 여부 검사\n• 품질 메트릭스 측정 • 표준 준수 검사\n• 메트릭스 측정\n• 품질 지표 산출 • 일관된 코드 품질\n• 유지보수성 향상\n• 객관적 품질 평가 • 맥락 이해 부족\n• 과도한 규칙 적용\n• 거짓 양성 보고 • 코딩 표준 검증\n• 품질 지표 측정\n• 리팩토링 대상 식별 Formal Methods (정형 기법) 분류 설명 특징 장점 단점 적용 사례 Model Checking • 시스템 모델의 수학적 검증\n• 상태 공간 탐색 • 형식적 검증\n• 전수 검사\n• 자동화된 분석 • 완벽한 검증 가능\n• 중요 속성 보장\n• 숨은 오류 발견 • 높은 복잡도\n• 전문성 요구\n• 큰 시스템에 적용 어려움 • 안전중심 시스템\n• 프로토콜 검증\n• 동시성 검사 Theorem Proving • 수학적 증명을 통한 검증\n• 논리적 정확성 입증 • 수학적 엄밀성\n• 형식적 명세\n• 증명 기반 접근 • 절대적 정확성\n• 핵심 속성 보장\n• 수학적 완전성 • 매우 높은 비용\n• 전문가 필요\n• 실용성 제한적 • 핵심 알고리즘 검증\n• 보안 프로토콜\n• 미션크리티컬 시스템 참고 및 출처 ","wordCount":"1325","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-28T02:35:00Z","dateModified":"2024-11-28T02:35:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2024/11/dynamic-test-and-static-test/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/11/>11</a></div><h1 class="post-title entry-hint-parent">동적테스트(Dynamic Test)와 정적테스트(Static Test)</h1><div class=post-description>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.</div><div class=post-meta><span title='2024-11-28 02:35:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1325 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#동적테스트dynamic-test와-정적테스트static-test>동적테스트(Dynamic Test)와 정적테스트(Static Test)</a><ul><li><a href=#동적-테스트-dynamic-test>동적 테스트 (Dynamic Test)</a></li><li><a href=#정적-테스트static-test>정적 테스트(Static Test)</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=동적테스트dynamic-test와-정적테스트static-test>동적테스트(Dynamic Test)와 정적테스트(Static Test)<a hidden class=anchor aria-hidden=true href=#동적테스트dynamic-test와-정적테스트static-test>#</a></h2><p>동적테스트 (Dynamic Test)과 정적테스트(Static Test)</p><p>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.<br>이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.</p><p>효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.<br>예를 들어:</p><ol><li>개발 초기 단계:<ul><li>정적 테스팅으로 기본적인 문제 해결</li><li>코드 리뷰로 설계 문제 조기 발견</li></ul></li><li>개발 중기:<ul><li>단위 테스트로 개별 기능 검증</li><li>통합 테스트로 모듈 간 상호작용 확인</li></ul></li><li>개발 후기:<ul><li>시스템 테스트로 전체 기능 검증</li><li>성능 테스트로 실제 환경 적합성 확인</li></ul></li></ol><h3 id=동적-테스트-dynamic-test>동적 테스트 (Dynamic Test)<a hidden class=anchor aria-hidden=true href=#동적-테스트-dynamic-test>#</a></h3><p>소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.<br>소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.<br>소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.</p><h4 id=동적-테스팅의-기본-원리>동적 테스팅의 기본 원리<a hidden class=anchor aria-hidden=true href=#동적-테스팅의-기본-원리>#</a></h4><p>동적 테스팅은 실행 시점의 프로그램 행동을 관찰한다.<br>프로그램이 실제 환경에서 어떻게 동작하는지, 어떤 결과를 출력하는지, 얼마나 빠르게 처리하는지 등을 직접적으로 확인할 수 있다.<br>예를 들어, 웹 애플리케이션을 테스트할 때 실제 사용자처럼 로그인을 시도하고 데이터를 입력하면서 시스템의 반응을 검증한다.</p><h4 id=동적-테스팅의-특징>동적 테스팅의 특징<a hidden class=anchor aria-hidden=true href=#동적-테스팅의-특징>#</a></h4><ol><li>실행 기반: 프로그램을 실제로 실행하여 메모리 사용, 성능, 보안 취약점, 오류 등을 분석한다.</li><li>테스트 환경: 소프트웨어가 실행될 실제 또는 가상 환경에서 분석이 이루어진다.</li><li>런타임 문제 발견: 메모리 누수, 경쟁 조건, 예외 처리 문제 등 실행 중에만 드러나는 문제를 발견할 수 있다.</li><li>실제 사용 환경 반영: 소프트웨어가 실제로 어떻게 동작하는지, 실제 환경에서의 성능과 안정성을 평가할 수 있다.</li></ol><h4 id=동적-테스팅의-장점>동적 테스팅의 장점<a hidden class=anchor aria-hidden=true href=#동적-테스팅의-장점>#</a></h4><ol><li>오류 탐색 정확도 높음: 실제 실행 환경에서 테스트하므로 오류를 정확하게 찾아낼 수 있다.</li><li>실제 사용 시나리오 검증: 사용자 관점에서 소프트웨어의 동작을 검증할 수 있다.</li><li>복잡한 버그 발견: 여러 컴포넌트 간의 상호작용에서 발생하는 복잡한 버그를 찾아낼 수 있다.</li><li>성능 및 보안 평가: 실제 운영 환경에서의 성능을 측정하고 보안 취약점을 발견할 수 있다.</li><li>사용자 경험 검증: 실제 사용자 상호작용을 시뮬레이션하여 사용자 경험을 검증할 수 있다.</li><li>조기 피드백: 개발 과정 초기에 문제를 발견하여 효과적인 개선이 가능하다.</li></ol><h4 id=동적-테스팅-비교-분석>동적 테스팅 비교 분석<a hidden class=anchor aria-hidden=true href=#동적-테스팅-비교-분석>#</a></h4><p>각 테스트 방법은 소프트웨어 개발 생명주기의 다른 단계에서 중요한 역할을 한다:</p><ol><li>단위 테스트는 개발 초기 단계에서 개별 코드 단위의 정확성을 확인한다.</li><li>통합 테스트는 여러 모듈이 결합될 때 정상적으로 작동하는지 검증한다.</li><li>기능 테스트는 소프트웨어의 기능적 요구사항 충족 여부를 확인한다.</li><li>보안 테스트는 시스템의 취약점을 식별하고 보안 위협을 방지한다.</li><li>성능 테스트는 시스템의 속도, 안정성, 확장성 등을 평가한다.</li><li>수용 테스트는 최종 사용자 관점에서 요구사항 충족 여부를 확인한다.</li><li>스모크 테스트는 빌드의 기본적인 안정성을 빠르게 확인한다.</li><li>엔드투엔드 테스트는 전체 시스템의 흐름을 처음부터 끝까지 검증한다.</li></ol><table><thead><tr><th>테스트 유형</th><th>주요 목적</th><th>테스트 범위</th><th>수행 시점</th><th>수행 주체</th><th>특징</th></tr></thead><tbody><tr><td>단위테스트</td><td>개별 구성 요소의 정확성 검증</td><td>함수, 메서드, 클래스 단위</td><td>개발 단계</td><td>개발자</td><td>자동화가 용이, 빠른 피드백 가능</td></tr><tr><td>통합테스트</td><td>모듈 간 상호작용 검증</td><td>여러 모듈의 결합</td><td>단위테스트 이후</td><td>개발자/QA</td><td>모듈 간 인터페이스 검증에 중점</td></tr><tr><td>기능테스트</td><td>기능적 요구사항 충족 확인</td><td>개별 기능 단위</td><td>개발 완료 후</td><td>QA 팀</td><td>사용자 시나리오 기반 검증</td></tr><tr><td>보안테스트</td><td>보안 취약점 발견</td><td>전체 시스템</td><td>개발 후반/운영 중</td><td>보안 전문가</td><td>주기적인 수행 필요</td></tr><tr><td>성능테스트</td><td>시스템 성능 검증</td><td>전체 시스템</td><td>개발 후반</td><td>성능 테스트 전문가</td><td>특수 도구 활용 필요</td></tr><tr><td>수용테스트</td><td>사용자 요구사항 충족 확인</td><td>전체 시스템</td><td>개발 완료 후</td><td>최종 사용자/고객</td><td>실제 사용자 참여 필수</td></tr><tr><td>스모크테스트</td><td>기본 기능 동작 확인</td><td>핵심 기능</td><td>빌드 직후</td><td>QA 팀</td><td>빠른 수행, 간단한 검증</td></tr><tr><td>엔드투엔드테스트</td><td>전체 비즈니스 프로세스 검증</td><td>전체 시스템</td><td>통합 완료 후</td><td>QA 팀</td><td>실제 환경과 유사한 조건에서 수행</td></tr></tbody></table><h3 id=정적-테스트static-test>정적 테스트(Static Test)<a hidden class=anchor aria-hidden=true href=#정적-테스트static-test>#</a></h3><p>프로그램을 실행하지 않고 수행하는 테스트 방식<br>소프트웨어 개발 과정에서 생산되는 문서(코드, 설계서, 분석서, 계획서, 표준)에 대한 검토를 통해 오류를 발견하는 비실행 기반 테스트.</p><h4 id=정적-테스팅의-기본-원리>정적 테스팅의 기본 원리<a hidden class=anchor aria-hidden=true href=#정적-테스팅의-기본-원리>#</a></h4><p>정적 테스팅은 소프트웨어의 정적 측면, 즉 실행하지 않고도 확인할 수 있는 특성들을 검사한다.<br>예를 들어, 코딩 표준 준수 여부, 변수 명명 규칙, 들여쓰기 등의 코드 스타일부터 메모리 누수 가능성이나 보안 취약점과 같은 잠재적 문제까지 다양한 측면을 검토한다.</p><h4 id=정적-테스팅의-특징>정적 테스팅의 특징<a hidden class=anchor aria-hidden=true href=#정적-테스팅의-특징>#</a></h4><ol><li>코드 실행 없이 수행: 프로그램을 실행하지 않고 소스 코드나 문서를 검토</li><li>조기 결함 발견: 개발 초기 단계에서 잠재적 문제를 식별</li><li>다양한 검토 대상: 코드, 요구사항 문서, 설계 문서 등 다양한 산출물 검토</li><li>수동 및 자동화 방식: 인력에 의한 리뷰와 도구를 이용한 자동 분석 병행</li><li>코딩 표준 준수 확인: 코딩 규칙, 가이드라인 준수 여부 검사</li></ol><h4 id=정적-테스팅의-장점>정적 테스팅의 장점<a hidden class=anchor aria-hidden=true href=#정적-테스팅의-장점>#</a></h4><ol><li>조기 결함 발견: 개발 초기에 문제를 발견하여 수정 비용과 시간 절감</li><li>비용 효율성: 동적 테스팅에 비해 적은 비용으로 결함 발견 가능</li><li>코드 품질 향상: 코딩 표준 준수와 구조적 문제 해결로 전반적인 코드 품질 개선</li><li>보안성 강화: 보안 취약점을 조기에 발견하고 수정 가능</li><li>개발 생산성 향상: 결함의 조기 발견으로 개발 과정의 효율성 증대</li><li>협업 개선: 코드 리뷰를 통한 팀원 간 지식 공유와 의사소통 촉진</li><li>테스트 범위 확대: 동적 테스팅으로 발견하기 어려운 결함 식별 가능</li></ol><h4 id=정적-테스팅-비교-분석>정적 테스팅 비교 분석<a hidden class=anchor aria-hidden=true href=#정적-테스팅-비교-분석>#</a></h4><h5 id=reviews-리뷰>Reviews (리뷰)<a hidden class=anchor aria-hidden=true href=#reviews-리뷰>#</a></h5><table><thead><tr><th>분류</th><th>설명</th><th>특징</th><th>장점</th><th>단점</th><th>적용 사례</th></tr></thead><tbody><tr><td>Informal Review</td><td>• 공식적인 절차 없이 진행되는 검토 방식<br>• 개발자 간 자유로운 토론과 피드백</td><td>• 절차와 문서화 최소화<br>• 빠른 피드백<br>• 자유로운 의견 교환</td><td>• 즉각적인 피드백 가능<br>• 팀 내 지식 공유 촉진<br>• 낮은 진입 장벽</td><td>• 체계적인 추적이 어려움<br>• 검토 누락 가능성<br>• 품질 보증의 공식적 증거로 부족</td><td>• 일상적인 코드 검토<br>• quick fix 검증<br>• 소규모 변경사항 검토</td></tr><tr><td>Technical Review</td><td>• 기술적 관점에서의 상세 검토<br>• 동료 검토 중심의 체계적 접근</td><td>• 기술적 완성도 중점<br>• 대안 제시<br>• 체크리스트 활용</td><td>• 기술적 결함 조기 발견<br>• 설계 개선 기회 제공<br>• 기술 표준 준수 확인</td><td>• 많은 시간과 자원 소요<br>• 참여자의 전문성 필요<br>• 범위 설정의 어려움</td><td>• 아키텍처 검토<br>• 성능 최적화 검증<br>• 보안 취약점 분석</td></tr><tr><td>Walkthrough</td><td>• 작성자가 주도하는 단계별 검토<br>• 교육적 효과 중시</td><td>• 시나리오 기반 검토<br>• 상호 학습 기회<br>• 단계별 설명</td><td>• 지식 전파 효과적<br>• 팀 이해도 향상<br>• 새로운 관점 발견</td><td>• 작성자 편향 가능성<br>• 시간 소요가 큼<br>• 객관성 확보 어려움</td><td>• 신규 팀원 교육<br>• 복잡한 로직 설명<br>• 프로세스 이해</td></tr><tr><td>Inspection</td><td>• 가장 공식적이고 체계적인 검토<br>• 철저한 문서화와 추적</td><td>• 역할 분담 명확<br>• 체계적 절차<br>• 상세한 문서화</td><td>• 높은 결함 발견율<br>• 품질 보증 증거 확보<br>• 체계적 개선 가능</td><td>• 높은 비용과 시간<br>• 과도한 문서화 부담<br>• 유연성 부족</td><td>• 중요 시스템 검증<br>• 품질 인증 준비<br>• 규제 준수 확인</td></tr></tbody></table><h5 id=static-analysis-정적-분석>Static Analysis (정적 분석)<a hidden class=anchor aria-hidden=true href=#static-analysis-정적-분석>#</a></h5><table><thead><tr><th>분류</th><th>설명</th><th>특징</th><th>장점</th><th>단점</th><th>적용 사례</th></tr></thead><tbody><tr><td>Syntax Analysis</td><td>• 코드의 문법적 오류 검출<br>• 컴파일러 수준의 검사</td><td>• 자동화된 검사<br>• 즉각적 피드백<br>• 기본적 오류 검출</td><td>• 빠른 오류 발견<br>• 개발 생산성 향상<br>• 기본적 품질 보장</td><td>• 의미적 오류 발견 불가<br>• 단순 오류만 검출<br>• 컨텍스트 이해 부족</td><td>• 컴파일 전 검사<br>• IDE 통합 검사<br>• 기본 코드 검증</td></tr><tr><td>Data Flow Analysis</td><td>• 데이터의 흐름과 사용 패턴 분석<br>• 변수 사용의 적절성 검증</td><td>• 변수 추적<br>• 초기화 검사<br>• 사용 패턴 분석</td><td>• 데이터 관련 버그 발견<br>• 메모리 누수 방지<br>• 안정성 향상</td><td>• 분석 비용 높음<br>• 오탐 가능성<br>• 복잡한 패턴 분석 어려움</td><td>• 메모리 관리 검증<br>• 변수 사용 분석<br>• 초기화 오류 검출</td></tr><tr><td>Control Flow Analysis</td><td>• 프로그램 실행 경로 분석<br>• 로직 흐름 검증</td><td>• 경로 분석<br>• 도달성 검사<br>• 순환 복잡도 측정</td><td>• 논리적 오류 발견<br>• 코드 복잡도 관리<br>• 실행 경로 최적화</td><td>• 동적 경로 예측 한계<br>• 복잡한 조건 분석 어려움<br>• 성능 오버헤드</td><td>• 분기문 검증<br>• 데드코드 탐지<br>• 복잡도 측정</td></tr><tr><td>Code Quality Analysis</td><td>• 코딩 표준 준수 여부 검사<br>• 품질 메트릭스 측정</td><td>• 표준 준수 검사<br>• 메트릭스 측정<br>• 품질 지표 산출</td><td>• 일관된 코드 품질<br>• 유지보수성 향상<br>• 객관적 품질 평가</td><td>• 맥락 이해 부족<br>• 과도한 규칙 적용<br>• 거짓 양성 보고</td><td>• 코딩 표준 검증<br>• 품질 지표 측정<br>• 리팩토링 대상 식별</td></tr></tbody></table><h5 id=formal-methods-정형-기법>Formal Methods (정형 기법)<a hidden class=anchor aria-hidden=true href=#formal-methods-정형-기법>#</a></h5><table><thead><tr><th>분류</th><th>설명</th><th>특징</th><th>장점</th><th>단점</th><th>적용 사례</th></tr></thead><tbody><tr><td>Model Checking</td><td>• 시스템 모델의 수학적 검증<br>• 상태 공간 탐색</td><td>• 형식적 검증<br>• 전수 검사<br>• 자동화된 분석</td><td>• 완벽한 검증 가능<br>• 중요 속성 보장<br>• 숨은 오류 발견</td><td>• 높은 복잡도<br>• 전문성 요구<br>• 큰 시스템에 적용 어려움</td><td>• 안전중심 시스템<br>• 프로토콜 검증<br>• 동시성 검사</td></tr><tr><td>Theorem Proving</td><td>• 수학적 증명을 통한 검증<br>• 논리적 정확성 입증</td><td>• 수학적 엄밀성<br>• 형식적 명세<br>• 증명 기반 접근</td><td>• 절대적 정확성<br>• 핵심 속성 보장<br>• 수학적 완전성</td><td>• 매우 높은 비용<br>• 전문가 필요<br>• 실용성 제한적</td><td>• 핵심 알고리즘 검증<br>• 보안 프로토콜<br>• 미션크리티컬 시스템</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/qa/>QA</a></li><li><a href=https://buenhyden.github.io/tags/qc/>QC</a></li><li><a href=https://buenhyden.github.io/tags/quality-assurance/>Quality-Assurance</a></li><li><a href=https://buenhyden.github.io/tags/quality-control/>Quality-Control</a></li><li><a href=https://buenhyden.github.io/tags/test/>Test</a></li><li><a href=https://buenhyden.github.io/tags/dynamic-test/>Dynamic-Test</a></li><li><a href=https://buenhyden.github.io/tags/static-test/>Static-Test</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>