<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blocking vs Non-Blocking | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Programming-Languages,Blocking,Non-Blocking"><meta name=description content="프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Blocking vs Non-Blocking"><meta property="og:description" content="프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2024-10-06T12:36:00+00:00"><meta property="article:modified_time" content="2024-10-06T12:36:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Blocking"><meta property="article:tag" content="Non-Blocking"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Blocking vs Non-Blocking"><meta name=twitter:description content="프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"10","item":"https://buenhyden.github.io/til/2024/10/"},{"@type":"ListItem","position":4,"name":"06","item":"https://buenhyden.github.io/til/2024/10/06/"},{"@type":"ListItem","position":5,"name":"Blocking vs Non-Blocking","item":"https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Blocking vs Non-Blocking","name":"Blocking vs Non-Blocking","description":"프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.","keywords":["Computer-System","Programming-Languages","Blocking","Non-Blocking"],"articleBody":"Blocking and Non-Blocking Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.\n이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.\nBlocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.\nBlocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.\nBlocking Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.\n해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.\n동작 방식 프로세스가 특정 작업을 요청한다. 해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다. 작업이 완료되면 프로세스는 다시 실행 상태로 전환된다. 그동안 다른 작업은 수행될 수 없다. 특징 프로그램의 실행 흐름이 순차적이고 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 응답을 즉시 받을 수 있다. 프로그램 구조가 단순하고 직관적이다. 실제 예시 1 2 3 4 5 6 // Blocking I/O의 예시 File file = new File(\"example.txt\"); FileInputStream input = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = input.read(buffer); // 이 지점에서 Blocking 발생 // 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음 성능 측면 단일 작업의 처리 시간이 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 대기 시간이 발생한다. 구현 복잡도 구현이 단순하다. 디버깅이 쉽다. 코드 흐름이 직관적이다. 적합한 사례 간단한 스크립트 작성 순차적 데이터 처리 즉각적인 응답이 필요한 경우 작은 규모의 애플리케이션 Non-Blocking Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.\n작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.\n동작 방식 프로세스가 작업을 요청한다. 작업의 완료 여부와 관계없이 즉시 제어권을 반환받는다. 다른 작업을 계속 수행할 수 있다. 작업이 완료되면 이벤트나 콜백을 통해 알림을 받는다. 특징 프로그램의 실행이 중단되지 않는다. 리소스를 효율적으로 사용할 수 있다. 높은 동시성을 제공한다. 복잡한 프로그램 구조가 필요할 수 있다. 실제 예시 1 2 3 4 5 6 7 // Non-Blocking I/O의 예시 fs.readFile('example.txt', (err, data) =\u003e { if (err) throw err; console.log(data); }); // 파일을 읽는 동안에도 다음 코드가 실행됨 console.log('파일 읽기를 요청했습니다.'); 성능 측면 전체적인 처리량이 향상된다. 리소스를 지속적으로 활용할 수 있다. 대기 시간을 다른 작업으로 활용한다. 구현 복잡도 구현이 복잡할 수 있다. 디버깅이 어려울 수 있다. 콜백이나 이벤트 핸들링이 필요하다. 적합한 사례 대규모 네트워크 애플리케이션 실시간 데이터 처리 시스템 높은 동시성이 요구되는 서버 사용자 인터페이스가 있는 애플리케이션 Blocking과 Non-Blocking의 비교 카테고리 Blocking Non-Blocking 기본 개념 - 호출된 함수가 자신의 작업을 완료할 때까지 제어권을 가지고 있음 - 호출된 함수가 즉시 제어권을 반환함 - 호출한 함수는 작업 완료까지 대기 - 호출한 함수는 다른 작업을 계속 수행 가능 - 실행 순서가 명확하고 예측 가능 - 실행 순서가 비결정적일 수 있음 제어권 처리 - 제어권이 호출된 함수에 완전히 넘어감 - 제어권이 호출한 함수에 즉시 반환됨 - 작업 완료 전까지 제어권 반환 없음 - 작업 상태는 별도로 확인 가능 - 호출 스택이 차단됨 - 호출 스택이 차단되지 않음 리소스 관리 - 작업 중 시스템 리소스를 독점 - 리소스를 효율적으로 공유 - 메모리 사용량이 예측 가능 - 동시성으로 인한 메모리 사용량 변동 가능 - 리소스 해제가 명확함 - 리소스 해제 시점 관리 필요 성능 특성 - 단순 작업에서는 오버헤드가 적음 - 문맥 교환으로 인한 오버헤드 발생 가능 - I/O 작업에서 성능 저하 - I/O 작업에서 높은 성능 - 동시성 처리에 제한적 - 높은 동시성 처리 가능 에러 처리 - 동기적 에러 처리 가능 - 비동기적 에러 처리 필요 - try-catch로 직접적인 처리 - 콜백이나 Promise로 에러 처리 - 스택 트레이스가 명확함 - 스택 트레이스 추적이 복잡할 수 있음 적합한 사용 사례 - 빠른 CPU 연산 작업 - 네트워크 통신 - 간단한 파일 읽기/쓰기 - 대용량 파일 처리 - 메모리 내 데이터 처리 - 데이터베이스 쿼리 - 동기화가 필요한 작업 - 독립적인 병렬 처리 프로그래밍 모델 - 절차적 프로그래밍에 적합 - 이벤트 기반 프로그래밍에 적합 - 코드 흐름이 직관적 - 콜백이나 Promise 기반 - 디버깅이 상대적으로 쉬움 - 복잡한 비동기 패턴 사용 시스템 확장성 - 수직적 확장에 제한적 - 수평적/수직적 확장 용이 - 동시 처리 능력 제한 - 높은 동시성 지원 - 시스템 리소스 제약 - 효율적인 리소스 활용 개발 복잡도 - 구현이 단순하고 직관적 - 상태 관리가 필요함 - 코드 흐름 추적이 쉬움 - 비동기 로직으로 인한 복잡도 증가 - 유지보수가 상대적으로 용이 - 디버깅과 테스트가 어려울 수 있음 실제 애플리케이션 개발에서는 각 작업의 특성과 요구사항을 고려하여 적절한 방식을 선택해야 한다.\n특히:\n시스템의 응답성이 중요한 경우:\nNon-Blocking 방식이 더 적합할 수 있다. 사용자 인터페이스의 반응성을 유지할 수 있다. 정확성과 순서가 중요한 경우:\nBlocking 방식이 더 적합할 수 있다. 작업의 순서와 결과를 정확히 제어할 수 있다. 리소스 활용이 중요한 경우:\nNon-Blocking 방식이 시스템 리소스를 더 효율적으로 활용할 수 있다. 높은 처리량이 필요한 시스템에 적합하다. 이러한 특성들을 잘 이해하고 적절히 조합하여 사용하는 것이 현대 애플리케이션 개발에서 매우 중요하다.\n최신 트렌드 및 발전 방향 시스템 설계 측면 하이브리드 접근 방식의 증가 마이크로서비스 아키텍처에서의 활용 클라우드 네이티브 환경에서의 최적화 프로그래밍 언어 측면 비동기 프로그래밍 지원 강화 새로운 동시성 모델 도입 효율적인 리소스 관리 메커니즘 개발 실제 구현 시 고려사항 시스템 설계 시 고려사항 작업의 특성과 요구사항 분석 리소스 사용량 예측 확장성 고려 에러 처리 메커니즘 설계 성능 최적화 적절한 타임아웃 설정 버퍼 크기 조정 스레드 풀 관리 메모리 사용량 모니터링 참고 및 출처 ","wordCount":"801","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-06T12:36:00Z","dateModified":"2024-10-06T12:36:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/10/>10</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/10/06/>06</a></div><h1 class="post-title entry-hint-parent">Blocking vs Non-Blocking</h1><div class=post-description>프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.</div><div class=post-meta><span title='2024-10-06 12:36:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;801 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/TIL/2024/10/06/Blocking-vs-Non-Blocking.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#blocking-and-non-blocking>Blocking and Non-Blocking</a><ul><li><a href=#blocking>Blocking</a></li><li><a href=#non-blocking>Non-Blocking</a></li><li><a href=#blocking과-non-blocking의-비교>Blocking과 Non-Blocking의 비교</a></li><li><a href=#최신-트렌드-및-발전-방향>최신 트렌드 및 발전 방향</a></li><li><a href=#실제-구현-시-고려사항>실제 구현 시 고려사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=blocking-and-non-blocking>Blocking and Non-Blocking<a hidden class=anchor aria-hidden=true href=#blocking-and-non-blocking>#</a></h2><p>Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.<br>이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.</p><p>Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.<br>Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.</p><h3 id=blocking>Blocking<a hidden class=anchor aria-hidden=true href=#blocking>#</a></h3><p>Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.<br>해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.</p><h4 id=동작-방식>동작 방식<a hidden class=anchor aria-hidden=true href=#동작-방식>#</a></h4><ol><li>프로세스가 특정 작업을 요청한다.</li><li>해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다.</li><li>작업이 완료되면 프로세스는 다시 실행 상태로 전환된다.</li><li>그동안 다른 작업은 수행될 수 없다.</li></ol><h4 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h4><ul><li>프로그램의 실행 흐름이 순차적이고 예측 가능하다.</li><li>리소스 사용이 일시적으로 중단된다.</li><li>응답을 즉시 받을 수 있다.</li><li>프로그램 구조가 단순하고 직관적이다.</li></ul><h4 id=실제-예시>실제 예시<a hidden class=anchor aria-hidden=true href=#실제-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Blocking I/O의 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>File</span><span class=w> </span><span class=n>file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=s>&#34;example.txt&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>FileInputStream</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileInputStream</span><span class=p>(</span><span class=n>file</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>1024</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>bytesRead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>.</span><span class=na>read</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span><span class=w> </span><span class=c1>// 이 지점에서 Blocking 발생</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=성능-측면>성능 측면<a hidden class=anchor aria-hidden=true href=#성능-측면>#</a></h4><ul><li>단일 작업의 처리 시간이 예측 가능하다.</li><li>리소스 사용이 일시적으로 중단된다.</li><li>대기 시간이 발생한다.</li></ul><h4 id=구현-복잡도>구현 복잡도<a hidden class=anchor aria-hidden=true href=#구현-복잡도>#</a></h4><ul><li>구현이 단순하다.</li><li>디버깅이 쉽다.</li><li>코드 흐름이 직관적이다.</li></ul><h4 id=적합한-사례>적합한 사례<a hidden class=anchor aria-hidden=true href=#적합한-사례>#</a></h4><ul><li>간단한 스크립트 작성</li><li>순차적 데이터 처리</li><li>즉각적인 응답이 필요한 경우</li><li>작은 규모의 애플리케이션</li></ul><h3 id=non-blocking>Non-Blocking<a hidden class=anchor aria-hidden=true href=#non-blocking>#</a></h3><p>Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.<br>작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.</p><h4 id=동작-방식-1>동작 방식<a hidden class=anchor aria-hidden=true href=#동작-방식-1>#</a></h4><ol><li>프로세스가 작업을 요청한다.</li><li>작업의 완료 여부와 관계없이 즉시 제어권을 반환받는다.</li><li>다른 작업을 계속 수행할 수 있다.</li><li>작업이 완료되면 이벤트나 콜백을 통해 알림을 받는다.</li></ol><h4 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h4><ul><li>프로그램의 실행이 중단되지 않는다.</li><li>리소스를 효율적으로 사용할 수 있다.</li><li>높은 동시성을 제공한다.</li><li>복잡한 프로그램 구조가 필요할 수 있다.</li></ul><h4 id=실제-예시-1>실제 예시<a hidden class=anchor aria-hidden=true href=#실제-예시-1>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Non-Blocking I/O의 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s1>&#39;example.txt&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=k>throw</span> <span class=nx>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// 파일을 읽는 동안에도 다음 코드가 실행됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;파일 읽기를 요청했습니다.&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=성능-측면-1>성능 측면<a hidden class=anchor aria-hidden=true href=#성능-측면-1>#</a></h4><ul><li>전체적인 처리량이 향상된다.</li><li>리소스를 지속적으로 활용할 수 있다.</li><li>대기 시간을 다른 작업으로 활용한다.</li></ul><h4 id=구현-복잡도-1>구현 복잡도<a hidden class=anchor aria-hidden=true href=#구현-복잡도-1>#</a></h4><ul><li>구현이 복잡할 수 있다.</li><li>디버깅이 어려울 수 있다.</li><li>콜백이나 이벤트 핸들링이 필요하다.</li></ul><h4 id=적합한-사례-1>적합한 사례<a hidden class=anchor aria-hidden=true href=#적합한-사례-1>#</a></h4><ul><li>대규모 네트워크 애플리케이션</li><li>실시간 데이터 처리 시스템</li><li>높은 동시성이 요구되는 서버</li><li>사용자 인터페이스가 있는 애플리케이션</li></ul><h3 id=blocking과-non-blocking의-비교>Blocking과 Non-Blocking의 비교<a hidden class=anchor aria-hidden=true href=#blocking과-non-blocking의-비교>#</a></h3><table><thead><tr><th>카테고리</th><th>Blocking</th><th>Non-Blocking</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>- 호출된 함수가 자신의 작업을 완료할 때까지 제어권을 가지고 있음</td><td>- 호출된 함수가 즉시 제어권을 반환함</td></tr><tr><td></td><td>- 호출한 함수는 작업 완료까지 대기</td><td>- 호출한 함수는 다른 작업을 계속 수행 가능</td></tr><tr><td></td><td>- 실행 순서가 명확하고 예측 가능</td><td>- 실행 순서가 비결정적일 수 있음</td></tr><tr><td><strong>제어권 처리</strong></td><td>- 제어권이 호출된 함수에 완전히 넘어감</td><td>- 제어권이 호출한 함수에 즉시 반환됨</td></tr><tr><td></td><td>- 작업 완료 전까지 제어권 반환 없음</td><td>- 작업 상태는 별도로 확인 가능</td></tr><tr><td></td><td>- 호출 스택이 차단됨</td><td>- 호출 스택이 차단되지 않음</td></tr><tr><td><strong>리소스 관리</strong></td><td>- 작업 중 시스템 리소스를 독점</td><td>- 리소스를 효율적으로 공유</td></tr><tr><td></td><td>- 메모리 사용량이 예측 가능</td><td>- 동시성으로 인한 메모리 사용량 변동 가능</td></tr><tr><td></td><td>- 리소스 해제가 명확함</td><td>- 리소스 해제 시점 관리 필요</td></tr><tr><td><strong>성능 특성</strong></td><td>- 단순 작업에서는 오버헤드가 적음</td><td>- 문맥 교환으로 인한 오버헤드 발생 가능</td></tr><tr><td></td><td>- I/O 작업에서 성능 저하</td><td>- I/O 작업에서 높은 성능</td></tr><tr><td></td><td>- 동시성 처리에 제한적</td><td>- 높은 동시성 처리 가능</td></tr><tr><td><strong>에러 처리</strong></td><td>- 동기적 에러 처리 가능</td><td>- 비동기적 에러 처리 필요</td></tr><tr><td></td><td>- try-catch로 직접적인 처리</td><td>- 콜백이나 Promise로 에러 처리</td></tr><tr><td></td><td>- 스택 트레이스가 명확함</td><td>- 스택 트레이스 추적이 복잡할 수 있음</td></tr><tr><td><strong>적합한 사용 사례</strong></td><td>- 빠른 CPU 연산 작업</td><td>- 네트워크 통신</td></tr><tr><td></td><td>- 간단한 파일 읽기/쓰기</td><td>- 대용량 파일 처리</td></tr><tr><td></td><td>- 메모리 내 데이터 처리</td><td>- 데이터베이스 쿼리</td></tr><tr><td></td><td>- 동기화가 필요한 작업</td><td>- 독립적인 병렬 처리</td></tr><tr><td><strong>프로그래밍 모델</strong></td><td>- 절차적 프로그래밍에 적합</td><td>- 이벤트 기반 프로그래밍에 적합</td></tr><tr><td></td><td>- 코드 흐름이 직관적</td><td>- 콜백이나 Promise 기반</td></tr><tr><td></td><td>- 디버깅이 상대적으로 쉬움</td><td>- 복잡한 비동기 패턴 사용</td></tr><tr><td><strong>시스템 확장성</strong></td><td>- 수직적 확장에 제한적</td><td>- 수평적/수직적 확장 용이</td></tr><tr><td></td><td>- 동시 처리 능력 제한</td><td>- 높은 동시성 지원</td></tr><tr><td></td><td>- 시스템 리소스 제약</td><td>- 효율적인 리소스 활용</td></tr><tr><td><strong>개발 복잡도</strong></td><td>- 구현이 단순하고 직관적</td><td>- 상태 관리가 필요함</td></tr><tr><td></td><td>- 코드 흐름 추적이 쉬움</td><td>- 비동기 로직으로 인한 복잡도 증가</td></tr><tr><td></td><td>- 유지보수가 상대적으로 용이</td><td>- 디버깅과 테스트가 어려울 수 있음</td></tr></tbody></table><p>실제 애플리케이션 개발에서는 각 작업의 특성과 요구사항을 고려하여 적절한 방식을 선택해야 한다.<br>특히:</p><ol><li><p>시스템의 응답성이 중요한 경우:</p><ul><li>Non-Blocking 방식이 더 적합할 수 있다.</li><li>사용자 인터페이스의 반응성을 유지할 수 있다.</li></ul></li><li><p>정확성과 순서가 중요한 경우:</p><ul><li>Blocking 방식이 더 적합할 수 있다.</li><li>작업의 순서와 결과를 정확히 제어할 수 있다.</li></ul></li><li><p>리소스 활용이 중요한 경우:</p><ul><li>Non-Blocking 방식이 시스템 리소스를 더 효율적으로 활용할 수 있다.</li><li>높은 처리량이 필요한 시스템에 적합하다.</li></ul></li></ol><p>이러한 특성들을 잘 이해하고 적절히 조합하여 사용하는 것이 현대 애플리케이션 개발에서 매우 중요하다.</p><h3 id=최신-트렌드-및-발전-방향>최신 트렌드 및 발전 방향<a hidden class=anchor aria-hidden=true href=#최신-트렌드-및-발전-방향>#</a></h3><ol><li>시스템 설계 측면</li></ol><ul><li>하이브리드 접근 방식의 증가</li><li>마이크로서비스 아키텍처에서의 활용</li><li>클라우드 네이티브 환경에서의 최적화</li></ul><ol start=2><li>프로그래밍 언어 측면</li></ol><ul><li>비동기 프로그래밍 지원 강화</li><li>새로운 동시성 모델 도입</li><li>효율적인 리소스 관리 메커니즘 개발</li></ul><h3 id=실제-구현-시-고려사항>실제 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#실제-구현-시-고려사항>#</a></h3><ol><li>시스템 설계 시 고려사항</li></ol><ul><li>작업의 특성과 요구사항 분석</li><li>리소스 사용량 예측</li><li>확장성 고려</li><li>에러 처리 메커니즘 설계</li></ul><ol start=2><li>성능 최적화</li></ol><ul><li>적절한 타임아웃 설정</li><li>버퍼 크기 조정</li><li>스레드 풀 관리</li><li>메모리 사용량 모니터링</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/blocking/>Blocking</a></li><li><a href=https://buenhyden.github.io/tags/non-blocking/>Non-Blocking</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>