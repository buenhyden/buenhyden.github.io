<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>18 | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="18 - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/10/18/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/til/2024/10/18/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/10/18/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/10/18/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="18"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="18"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"10","item":"https://buenhyden.github.io/til/2024/10/"},{"@type":"ListItem","position":4,"name":"18","item":"https://buenhyden.github.io/til/2024/10/18/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/10/>10</a></div><h1>18</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency vs Parallelism</h2></header><div class=entry-content><p>동시성 (Concurrency) Vs 병렬성 (Parallelism) 동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.
동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.
실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.
Source: &lt;https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism
동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.
이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 “컨텍스트 스위칭(Context Switching)“이라고 한다.
...</p></div><footer class=entry-footer><span title='2024-10-18 02:38:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;428 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrency vs Parallelism" href=https://buenhyden.github.io/til/2024/10/18/concurrency-vs-parallelism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Blocking vs Non-Blocking</h2></header><div class=entry-content><p>Blocking and Non-Blocking Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.
이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.
Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.
Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.
Blocking Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.
해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.
동작 방식 프로세스가 특정 작업을 요청한다. 해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다. 작업이 완료되면 프로세스는 다시 실행 상태로 전환된다. 그동안 다른 작업은 수행될 수 없다. 특징 프로그램의 실행 흐름이 순차적이고 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 응답을 즉시 받을 수 있다. 프로그램 구조가 단순하고 직관적이다. 실제 예시 1 2 3 4 5 6 // Blocking I/O의 예시 File file = new File("example.txt"); FileInputStream input = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = input.read(buffer); // 이 지점에서 Blocking 발생 // 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음 성능 측면 단일 작업의 처리 시간이 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 대기 시간이 발생한다. 구현 복잡도 구현이 단순하다. 디버깅이 쉽다. 코드 흐름이 직관적이다. 적합한 사례 간단한 스크립트 작성 순차적 데이터 처리 즉각적인 응답이 필요한 경우 작은 규모의 애플리케이션 Non-Blocking Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.
작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-18 12:36:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;801 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blocking vs Non-Blocking" href=https://buenhyden.github.io/til/2024/10/18/blocking-vs-non-blocking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)와 비동기(Asynchronous)</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 카테고리 동기(Synchronous) 비동기(Asynchronous) 기본 개념 - 작업이 순차적으로 실행됨 - 작업이 독립적으로 실행됨 - 이전 작업이 완료될 때까지 다음 작업 대기 - 작업의 완료를 기다리지 않고 다음 작업 진행 - 실행 순서가 보장됨 - 실행 순서가 보장되지 않음 처리 방식 - 단일 스레드에서 순차적 처리 - 멀티 스레드 또는 이벤트 루프 기반 처리 - 작업 완료까지 대기 - 작업 완료 시 콜백/Promise/async-await 등으로 처리 - 직관적인 코드 흐름 - 비선형적 코드 흐름 장점 - 코드의 가독성이 좋음 - 시스템 자원의 효율적 사용 - 디버깅이 용이함 - 더 나은 사용자 경험 제공 - 에러 처리가 간단함 - 높은 처리량(Throughput) 단점 - 시스템 자원 비효율적 사용 - 코드의 복잡성 증가 - 응답 시간이 길어질 수 있음 - 디버깅이 어려움 - 사용자 경험 저하 가능성 - 에러 처리가 복잡함 적합한 사용 사례 - 간단한 계산 작업 - 네트워크 요청 - 메모리 내 데이터 처리 - 파일 입출력 - 작은 크기의 데이터 처리 - 대용량 데이터 처리 - 순차적 처리가 필요한 작업 - 독립적으로 실행 가능한 작업 에러 처리 - try-catch 블록으로 직접 처리 - Promise의 catch 또는 try-catch와 async-await 사용 - 즉시 에러 감지 및 처리 - 에러 처리가 비동기적으로 발생 - 스택 트레이스 추적이 용이 - 에러 발생 지점 추적이 복잡할 수 있음 성능 특성 - CPU 집약적 작업에 유리 - I/O 집약적 작업에 유리 - 메모리 사용량이 예측 가능 - 동시 처리로 인한 메모리 사용량 변동 - 단일 작업 처리 시간이 빠름 - 전체 처리량 최적화에 유리 코드 관리 - 코드 구조가 단순함 - 상태 관리가 필요함 - 유지보수가 상대적으로 쉬움 - 비동기 패턴에 대한 이해 필요 - 테스트 작성이 용이함 - 테스트 시나리오가 복잡할 수 있음 리소스 활용 - 단일 리소스 점유 - 리소스의 효율적 분배 - 대기 시간 동안 블로킹 - 대기 시간 동안 다른 작업 수행 - 시스템 부하가 예측 가능 - 동시성으로 인한 부하 변동 가능 최신 트렌드 및 발전 방향 동기 프로그래밍의 발전 코루틴(Coroutine) 도입 제너레이터(Generator) 함수 활용 구조적 동시성(Structured Concurrency) 개념 도입 비동기 프로그래밍의 발전 Promise와 async/await의 보편화 반응형 프로그래밍(Reactive Programming)의 확산 이벤트 기반 아키텍처의 발전 비동기 스트림 처리 기술의 발전 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 00:57:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;341 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)와 비동기(Asynchronous)" href=https://buenhyden.github.io/til/2024/10/18/synchronous-and-asynchronous/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multithreading Vs Multiprocessing vs Multitasking</h2></header><div class=entry-content><p>Multithreading Vs Multiprocessing Vs Multitasking Multithreading, Multiprocessing, Multitasking은 컴퓨터 시스템에서 동시성과 병렬성을 구현하는 세 가지 주요 개념이다.
Multitasking은 단일 CPU에서 여러 작업(프로세스)을 동시에 실행하는 것처럼 보이게 하는 기술이다. 실제로는 CPU가 매우 빠르게 여러 작업 간을 전환하면서 실행한다.
목적: CPU 사용률을 최대화하고 사용자에게 여러 프로그램이 동시에 실행되는 것 같은 환상을 제공한다. 구현: 시분할(time-sharing) 방식을 사용하여 각 작업에 CPU 시간을 할당한다. Multithreading은 하나의 프로세스 내에서 여러 실행 흐름(스레드)을 동시에 처리하는 기술이다.
목적: 단일 프로세스의 성능을 향상시키고 자원을 효율적으로 사용한다. 특징: 스레드들은 같은 프로세스 내의 메모리와 자원을 공유한다. Multiprocessing은 여러 개의 프로세서(또는 코어)를 사용하여 여러 작업을 실제로 동시에 처리하는 기술이다.
...</p></div><footer class=entry-footer><span title='2024-10-18 14:39:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;343 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multithreading Vs Multiprocessing vs Multitasking" href=https://buenhyden.github.io/til/2024/10/18/multithreading-vs-multiprocessing-vs-multitasking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread</h2></header><div class=entry-content><p>Process Vs Thread 프로세스:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. 스레드:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. ![Single Threaded vs Multi-threaded Process](Screenshot-from-2024-02-26-11-48-56-768.png “https://www.geeksforgeeks.org/thread-in-operating-system/_
Process Vs Thread 특성 Process Thread 정의 실행 중인 프로그램의 인스턴스 프로세스 내에서 실행되는 더 작은 실행 단위 메모리 공간 독립적인 메모리 공간 (코드, 데이터, 스택, 힙) 프로세스의 메모리 공간 공유 (코드, 데이터, 힙), 독립적인 스택 구성 요소 - 코드 영역
- 데이터 영역
- 스택 영역
- 힙 영역 - 스레드 ID
- 프로그램 카운터
- 레지스터 집합
- 스택 자원 공유 다른 프로세스와 자원 공유 안 함 같은 프로세스 내 스레드 간 자원 공유 생성 비용 높음 낮음 컨텍스트 스위칭 비용이 큼 비용이 적음 (같은 프로세스 내에서) 안정성 높음 (한 프로세스의 오류가 다른 프로세스에 영향 없음) 상대적으로 낮음 (한 스레드의 오류가 전체 프로세스에 영향) 통신 프로세스 간 통신(IPC) 필요 (복잡하고 오버헤드 큼) 쉽고 빠른 통신 (공유 메모리 사용) 병렬 처리 가능하지만 오버헤드 큼 효율적인 병렬 처리 가능 메모리 구조 비교 메모리 영역 Process Thread 코드 영역 독립적 공유 데이터 영역 독립적 공유 힙 영역 독립적 공유 스택 영역 독립적 각 스레드마다 독립적 특성 상세 비교 특성 Process Thread 독립성 완전히 독립적 부분적으로 독립적 자원 공유 제한적 (IPC 필요) 쉽게 공유 가능 오류 영향 다른 프로세스에 영향 없음 같은 프로세스의 모든 스레드에 영향 동기화 필요성 낮음
- IPC 메커니즘 필요 공유 자원에 대한 동기화 필요
- 뮤텍스, 세마포어 등 사용 생성 시간 더 오래 걸림 더 빠름 종료 시간 더 오래 걸림 더 빠름 장단점 비교 구분 Process Thread 장점 - 높은 안정성
- 다른 프로세스의 영향 받지 않음
- 보안성이 높음 - 생성/종료가 빠름
- 자원 공유가 쉬움
- 통신 비용이 적음 단점 - 많은 시스템 자원 필요
- 프로세스 간 통신이 복잡
- 컨텍스트 스위칭 비용이 큼 - 동기화 문제 발생 가능
- 디버깅이 어려움
- 하나의 스레드 문제가 전체에 영향 사용 사례 비교 용도 Process 선호 Thread 선호 웹 서버 안정성이 중요한 경우 높은 동시성이 필요한 경우 GUI 앱 독립적인 작업이 많은 경우 반응성이 중요한 경우 데이터 처리 대용량 병렬 처리 데이터 공유가 많은 경우 시스템 서비스 격리가 필요한 경우 빈번한 통신이 필요한 경우 활용 예 - 독립적인 애플리케이션 - 웹 브라우저의 각 탭 - 다중 사용자 서버 - 웹 서버 요청 처리 - 게임 엔진 (렌더링, 물리 연산) - 멀티미디어 애플리케이션 동기화 메커니즘 비교 메커니즘 Process Thread 공유 메모리 명시적으로 설정 필요 기본적으로 공유 뮤텍스 프로세스 간 뮤텍스 필요 프로세스 내 뮤텍스 사용 세마포어 시스템 세마포어 필요 프로세스 내 세마포어 사용 메시지 전달 IPC 메커니즘 사용 직접 메모리 접근 이러한 차이점들을 이해하고 적절히 활용하면, 상황에 맞는 최적의 실행 단위를 선택할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-18 08:30:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;454 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread" href=https://buenhyden.github.io/til/2024/10/18/process-vs-thread/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process Vs Thread Vs Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-18 08:30:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/til/2024/10/18/process-vs-thread-vs-coroutine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Paging vs Segmentation</h2></header><div class=entry-content><p>Paging Vs Segmentation Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.
Paging:
프로세스의 주소 공간을 고정 크기의 페이지로 나누어 관리한다. 물리적 메모리를 같은 크기의 프레임으로 나눈다. 외부 단편화 문제를 해결하고 메모리 할당을 단순화한다. Segmentation:
프로세스를 논리적 단위인 세그먼트로 나누어 관리한다. 각 세그먼트의 크기는 가변적이다. 프로그램의 논리적 구조를 반영하여 메모리를 관리한다. Paging과 Segmentation 비교 특성 Paging Segmentation 분할 단위 고정 크기 페이지 가변 크기 세그먼트 주소 변환 페이지 테이블 사용 세그먼트 테이블 사용 외부 단편화 없음 발생 가능 내부 단편화 발생 가능 거의 없음 메모리 활용 효율적 유연함 구현 복잡도 상대적으로 간단 복잡함 공유와 보호 페이지 단위 세그먼트 단위 사용자 관점 투명함 프로그램 구조 반영 할당/해제 속도 빠름 상대적으로 느림 테이블 크기 큼 작음 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 08:24:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;114 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Paging vs Segmentation" href=https://buenhyden.github.io/til/2024/10/18/paging-vs-segmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking 카테고리 동기(Synchronous) 비동기(Asynchronous) Blocking Non-Blocking 핵심 개념 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업을 시작하지 않음 작업들이 독립적으로 실행되며, 이전 작업의 완료를 기다리지 않고 다음 작업 수행 가능 호출된 함수가 작업을 완료할 때까지 제어권을 반환하지 않음 호출된 함수가 작업 완료 여부와 관계없이 즉시 제어권을 반환함 작업 처리 방식 순차적으로 작업을 처리하며, 각 작업이 완료된 후 다음 작업 시작 여러 작업이 동시에 처리될 수 있으며, 작업 완료 순서는 불확실할 수 있음 호출한 함수는 작업이 완료될 때까지 대기 상태 유지 호출한 함수는 작업 진행 중에도 다른 작업 수행 가능 제어 흐름 프로그램의 제어 흐름이 순차적이고 예측 가능함 제어 흐름이 비선형적이며, 콜백이나 이벤트로 처리 제어권이 호출된 함수에 완전히 넘어감 제어권이 호출한 함수에 즉시 반환됨 결과 처리 작업 완료 후 바로 결과를 반환받아 처리 콜백 함수, Promise, async/await 등을 통해 결과 처리 결과를 직접 반환받아 처리 상태 확인이나 콜백을 통해 결과 처리 주요 특징 - 코드의 실행 순서가 명확함
- 직관적인 코드 흐름
- 단순한 구현 - 작업의 병렬 처리 가능
- 복잡한 이벤트 처리
- 높은 확장성 - 자원을 점유하며 대기
- 단순한 구현
- 예측 가능한 실행 - 자원의 효율적 활용
- 복잡한 구현
- 높은 동시성 에러 처리 try-catch 블록으로 즉시 에러 처리 가능 Promise의 catch나 async/await의 try-catch로 처리 동기적 에러 처리 가능 비동기적 에러 처리 메커니즘 필요 성능 특성 - 단순 작업에서 오버헤드 적음
- 순차 처리로 인한 대기 시간 발생 - 동시 처리로 인한 전체 처리 시간 감소
- 컨텍스트 스위칭 오버헤드 - I/O 작업에서 성능 저하
- 리소스 독점 - 리소스 효율적 활용
- 높은 처리량 적합한 사용 사례 - 간단한 계산 작업
- 메모리 내 데이터 처리
- 순차적 처리 필요 작업 - 네트워크 요청
- 대용량 파일 처리
- 독립적 실행 가능 작업 - CPU 연산 작업
- 간단한 파일 작업
- 메모리 작업 - I/O 작업
- 네트워크 통신
- 대용량 처리 실행 순서 코드 작성 순서와 실행 순서가 동일 실행 순서가 코드 작성 순서와 다를 수 있음 작업 완료 순서가 예측 가능 작업 완료 순서가 불확실 자원 활용 단일 자원을 순차적으로 사용 여러 자원을 동시에 효율적으로 활용 자원을 독점적으로 사용 자원을 공유하여 사용 응답성 작업 완료 전까지 다른 작업 불가 여러 작업의 동시 처리로 높은 응답성 대기 시간 동안 응답 불가 지속적인 응답 가능 디버깅 코드 흐름 추적이 용이함 비동기 로직으로 인한 디버깅 어려움 문제 발생 지점 파악 쉬움 문제 발생 지점 추적 어려움 확장성 수직적 확장에 제한적 수평적/수직적 확장 용이 동시 처리 능력 제한적 높은 동시성 처리 가능 데이터 일관성 데이터 일관성 보장이 쉬움 경쟁 조건 고려 필요 순차적 처리로 일관성 보장 동시성 제어 메커니즘 필요 추가적인 고려사항:
...</p></div><footer class=entry-footer><span title='2024-10-18 12:30:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1302 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking" href=https://buenhyden.github.io/til/2024/10/18/synchronous-and-asynchronous-and-blocking-and-non-blocking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock and Mutex</h2></header><div class=entry-content><p>Lock and Mutex Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.
특성 Mutex Lock 기본 개념 상호 배제를 위한 동기화 객체로, 소유권 개념이 있음 일반적인 동기화 메커니즘으로, 단순한 잠금/해제 기능 소유권 소유권 개념이 있어 획득한 스레드만 해제 가능 소유권 개념이 없어 다른 스레드도 해제 가능 재진입성 보통 재진입 가능 (같은 스레드가 여러 번 획득 가능) 구현에 따라 재진입 가능할 수 있음 용도 스레드 간 엄격한 상호 배제가 필요한 경우 간단한 동기화가 필요한 일반적인 상황 성능 소유권 검사 등으로 인한 오버헤드 존재 상대적으로 가벼운 오버헤드, 단 구현에 따라 다름 에러 처리 소유권 위반 시 예외 발생 가능 단순한 실패/성공 여부만 반환 구현 복잡도 상대적으로 복잡한 구현 단순한 구현, 그러나 고급 기능 추가 시 복잡해질 수 있음 적용 범위 프로세스 내 스레드 간 동기화 프로세스 내 또는 프로세스 간 동기화에 사용 가능 우선순위 상속 우선순위 상속 지원 가능 일반적으로 지원하지 않음, 구현에 따라 다를 수 있음 교착상태 처리 소유권 추적으로 교착상태 감지 용이 기본적인 교착상태 감지만 가능 에러 검사 상세한 에러 검사 및 보고 기능 기본적인 에러 검사, 구현에 따라 확장 가능 메모리 사용 소유권 정보 저장으로 추가 메모리 필요 최소한의 메모리 사용 유연성 엄격한 규칙으로 유연성 제한 상대적으로 유연한 사용 가능 디버깅 소유권 정보로 디버깅 용이 디버깅이 상대적으로 어려움, 구현에 따라 다를 수 있음 사용 예시 데이터베이스 트랜잭션, 파일 시스템 접근 간단한 공유 자원 보호, 카운터 타임아웃 지원 보통 타임아웃 기능 내장 구현에 따라 타임아웃 지원 가능 복구 기능 비정상 종료 시 자동 복구 지원 구현에 따라 자동 복구 기능 추가 가능 중첩 사용 재진입성으로 중첩 사용 가능 구현에 따라 중첩 사용 가능, 주의 필요 시스템 수준 주로 커널 수준에서 구현 사용자 수준 및 커널 수준 모두에서 구현 가능 표준화 POSIX 표준으로 잘 정의됨 구현에 따라 동작이 다를 수 있음 성능 특성 경쟁 상황에서 성능 저하 가능 스핀락 구현 시 짧은 대기 시간에 효율적 공정성 일반적으로 공정성 메커니즘 내장 구현에 따라 공정성 보장 여부가 다름 실제 구현 시에는 고려할 사항 동시성 요구사항 (얼마나 많은 스레드가 동시에 접근하는가) 성능 요구사항 (응답 시간, 처리량 등) 리소스 사용량 (메모리, CPU 사용률) 오류 처리 및 복구 요구사항 데드록 방지 필요성 플랫폼 및 운영체제의 지원 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 11:25:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock and Mutex" href=https://buenhyden.github.io/til/2024/10/18/lock-and-mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deadlock vs Livelock</h2></header><div class=entry-content><p>Deadlock Vs Livelock 데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다.
데드락(Deadlock)은 두 개 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 상태를 말하며, 상호 배제(Mutual Exclusion), 점유 대기(Hold and Wait), 비선점(No Preemption), 순환 대기(Circular Wait) 등의 조건이 충족되어야 한다. 예를 들어, 프로세스 A가 자원 X를 점유하고, 프로세스 B가 자원 Y를 점유한 상태에서, A는 Y를, B는 X를 요청하면 데드락이 발생한다
...</p></div><footer class=entry-footer><span title='2024-10-18 07:03:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deadlock vs Livelock" href=https://buenhyden.github.io/til/2024/10/18/deadlock-vs-livelock/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/til/2024/10/18/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>