<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC | hyunyoun's Blog</title>
<meta name=keywords content="Networking-and-Communications,APIs,RESTful-API,GraphQL-API,Webhook,Server-sent-Events,Websocket,WebRTC"><meta name=description content="API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC"><meta property="og:description" content="API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2024-10-19T06:08:00+00:00"><meta property="article:modified_time" content="2024-10-19T06:08:00+00:00"><meta property="article:tag" content="Networking-and-Communications"><meta property="article:tag" content="APIs"><meta property="article:tag" content="RESTful-API"><meta property="article:tag" content="GraphQL-API"><meta property="article:tag" content="Webhook"><meta property="article:tag" content="Server-Sent-Events"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC"><meta name=twitter:description content="API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"10","item":"https://buenhyden.github.io/til/2024/10/"},{"@type":"ListItem","position":4,"name":"19","item":"https://buenhyden.github.io/til/2024/10/19/"},{"@type":"ListItem","position":5,"name":"RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC","item":"https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC","name":"RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC","description":"API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석","keywords":["Networking-and-Communications","APIs","RESTful-API","GraphQL-API","Webhook","Server-sent-Events","Websocket","WebRTC"],"articleBody":"RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.\nRESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.\nGraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.\nWebhook은 특정 이벤트가 발생했을 때 실시간으로 정보를 전달하는 방식이다. 서버에서 클라이언트로 HTTP POST 요청을 보내는 방식으로 작동하며, 실시간 업데이트나 알림 시스템에 주로 사용된다.\nSSE는 서버에서 클라이언트로 단방향 실시간 데이터 스트림을 제공하는 기술입니다. HTTP 연결을 통해 서버가 클라이언트에게 업데이트를 푸시할 수 있으며, 실시간 알림이나 업데이트에 적합합니다.\nWebSocket은 클라이언트와 서버 간의 양방향, 전이중 통신을 제공하는 프로토콜이다. 단일 TCP 연결을 통해 실시간 데이터 교환이 가능하며, 채팅 애플리케이션이나 실시간 게임 등에 사용된다.\nWebRTC(Web Real-Time Communication)는 브라우저 간 직접적인 피어-투-피어 통신을 가능하게 하는 기술이다. 비디오, 음성, 데이터의 실시간 통신을 지원하며, 화상 통화나 파일 공유 등에 사용된다.\n비교 분석 표 특성 RESTful API GraphQL API Webhook Server-sent Events WebSocket WebRTC 통신 방향 양방향 양방향 단방향(서버→클라이언트) 단방향(서버→클라이언트) 양방향 양방향 실시간성 낮음 중간 높음 높음 매우 높음 매우 높음 프로토콜 HTTP HTTP HTTP HTTP WebSocket UDP/TCP 데이터 형식 JSON, XML 등 JSON JSON 텍스트 바이너리, 텍스트 바이너리, 텍스트 연결 유지 연결 유지 안 함 연결 유지 안 함 연결 유지 안 함 단방향 연결 유지 양방향 연결 유지 P2P 연결 주요 용도 일반적인 API 유연한 데이터 요청 이벤트 기반 알림 실시간 업데이트 실시간 양방향 통신 미디어 스트리밍, P2P 통신 확장성 높음 매우 높음 중간 중간 높음 높음 구현 복잡성 낮음 중간 낮음 낮음 중간 높음 이 표를 통해 각 기술의 특성과 용도를 비교할 수 있다.\n선택은 애플리케이션의 요구사항, 실시간성, 양방향 통신 필요 여부, 구현 복잡성 등을 고려하여 결정해야 한다.\n참고 및 출처 ","wordCount":"309","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-19T06:08:00Z","dateModified":"2024-10-19T06:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/10/>10</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/10/19/>19</a></div><h1 class="post-title entry-hint-parent">RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</h1><div class=post-description>API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석</div><div class=post-meta><span title='2024-10-19 06:08:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/TIL/2024/10/19/RESTful-API-vs-GraphQL-API-vs-Webhook-vs-Server-sent-Events-vs-Websocket-vs-WebRTC.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC</a><ul><li><a href=#비교-분석-표>비교 분석 표</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC<a hidden class=anchor aria-hidden=true href=#restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc>#</a></h2><p>API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.</p><p>RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.</p><p>GraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.</p><p>Webhook은 특정 이벤트가 발생했을 때 실시간으로 정보를 전달하는 방식이다. 서버에서 클라이언트로 HTTP POST 요청을 보내는 방식으로 작동하며, 실시간 업데이트나 알림 시스템에 주로 사용된다.</p><p>SSE는 서버에서 클라이언트로 단방향 실시간 데이터 스트림을 제공하는 기술입니다. HTTP 연결을 통해 서버가 클라이언트에게 업데이트를 푸시할 수 있으며, 실시간 알림이나 업데이트에 적합합니다.</p><p>WebSocket은 클라이언트와 서버 간의 양방향, 전이중 통신을 제공하는 프로토콜이다. 단일 TCP 연결을 통해 실시간 데이터 교환이 가능하며, 채팅 애플리케이션이나 실시간 게임 등에 사용된다.</p><p>WebRTC(Web Real-Time Communication)는 브라우저 간 직접적인 피어-투-피어 통신을 가능하게 하는 기술이다. 비디오, 음성, 데이터의 실시간 통신을 지원하며, 화상 통화나 파일 공유 등에 사용된다.</p><h3 id=비교-분석-표>비교 분석 표<a hidden class=anchor aria-hidden=true href=#비교-분석-표>#</a></h3><table><thead><tr><th>특성</th><th>RESTful API</th><th>GraphQL API</th><th>Webhook</th><th>Server-sent Events</th><th>WebSocket</th><th>WebRTC</th></tr></thead><tbody><tr><td>통신 방향</td><td>양방향</td><td>양방향</td><td>단방향(서버→클라이언트)</td><td>단방향(서버→클라이언트)</td><td>양방향</td><td>양방향</td></tr><tr><td>실시간성</td><td>낮음</td><td>중간</td><td>높음</td><td>높음</td><td>매우 높음</td><td>매우 높음</td></tr><tr><td>프로토콜</td><td>HTTP</td><td>HTTP</td><td>HTTP</td><td>HTTP</td><td>WebSocket</td><td>UDP/TCP</td></tr><tr><td>데이터 형식</td><td>JSON, XML 등</td><td>JSON</td><td>JSON</td><td>텍스트</td><td>바이너리, 텍스트</td><td>바이너리, 텍스트</td></tr><tr><td>연결 유지</td><td>연결 유지 안 함</td><td>연결 유지 안 함</td><td>연결 유지 안 함</td><td>단방향 연결 유지</td><td>양방향 연결 유지</td><td>P2P 연결</td></tr><tr><td>주요 용도</td><td>일반적인 API</td><td>유연한 데이터 요청</td><td>이벤트 기반 알림</td><td>실시간 업데이트</td><td>실시간 양방향 통신</td><td>미디어 스트리밍, P2P 통신</td></tr><tr><td>확장성</td><td>높음</td><td>매우 높음</td><td>중간</td><td>중간</td><td>높음</td><td>높음</td></tr><tr><td>구현 복잡성</td><td>낮음</td><td>중간</td><td>낮음</td><td>낮음</td><td>중간</td><td>높음</td></tr></tbody></table><p>이 표를 통해 각 기술의 특성과 용도를 비교할 수 있다.<br>선택은 애플리케이션의 요구사항, 실시간성, 양방향 통신 필요 여부, 구현 복잡성 등을 고려하여 결정해야 한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-and-communications/>Networking-and-Communications</a></li><li><a href=https://buenhyden.github.io/tags/apis/>APIs</a></li><li><a href=https://buenhyden.github.io/tags/restful-api/>RESTful-API</a></li><li><a href=https://buenhyden.github.io/tags/graphql-api/>GraphQL-API</a></li><li><a href=https://buenhyden.github.io/tags/webhook/>Webhook</a></li><li><a href=https://buenhyden.github.io/tags/server-sent-events/>Server-Sent-Events</a></li><li><a href=https://buenhyden.github.io/tags/websocket/>Websocket</a></li><li><a href=https://buenhyden.github.io/tags/webrtc/>WebRTC</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>