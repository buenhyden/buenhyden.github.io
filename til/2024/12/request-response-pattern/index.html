<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Request-Response Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture,Software-Architecture-Patterns,Application-Structure,MSA-Patterns,Communication,Request-Response-Pattern"><meta name=description content="Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/12/request-response-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/12/request-response-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/12/request-response-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Request-Response Pattern"><meta property="og:description" content="Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2024-12-28T06:18:00+00:00"><meta property="article:modified_time" content="2024-12-28T06:18:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="Software-Architecture"><meta property="article:tag" content="Software-Architecture-Patterns"><meta property="article:tag" content="Application-Structure"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Communication"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Request-Response Pattern"><meta name=twitter:description content="Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"12","item":"https://buenhyden.github.io/til/2024/12/"},{"@type":"ListItem","position":4,"name":"Request-Response Pattern","item":"https://buenhyden.github.io/til/2024/12/request-response-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Request-Response Pattern","name":"Request-Response Pattern","description":"Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.","keywords":["Software-Design-and-Architecture","Software-Architecture","Software-Architecture-Patterns","Application-Structure","MSA-Patterns","Communication","Request-Response-Pattern"],"articleBody":"Request-Response Pattern Request-Response Pattern은 마이크로서비스 아키텍처(MSA)에서 가장 기본적이고 널리 사용되는 통신 패턴 중 하나이다.\nRequest-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.\n이는 동기식 통신의 대표적인 예로, 클라이언트는 서버로부터 응답을 받을 때까지 대기한다.\n작동 방식 클라이언트가 서버에 요청을 보낸다. 서버는 요청을 받아 처리한다. 서버는 처리 결과를 응답으로 클라이언트에게 반환한다. 클라이언트는 응답을 받아 처리한다. sequenceDiagram participant Client participant Server Note over Client,Server: HTTP/REST 기반 통신 Client-\u003e\u003e+Server: GET /users/123 Note right of Server: 리소스 처리 Server--\u003e\u003e-Client: 200 OK (사용자 데이터) Client-\u003e\u003e+Server: POST /orders Note right of Server: 주문 생성 Server--\u003e\u003e-Client: 201 Created 구현 방식과 프로토콜 REST API 구현\nREST API는 HTTP 프로토콜을 기반으로 하는 가장 보편적인 구현 방식이다.\nREST는 다음과 같은 특징을 가진다:\n자원 중심 설계: 모든 리소스는 고유한 URI로 식별된다.\n예를 들어, ‘/users/123’은 ID가 123인 사용자 리소스를 나타낸다. HTTP 메서드 활용: GET(조회), POST(생성), PUT(수정), DELETE(삭제) 등의 표준 HTTP 메서드를 사용하여 리소스를 조작한다. 상태 없는(Stateless) 통신: 각 요청은 독립적이며, 서버는 이전 요청의 컨텍스트를 저장하지 않는다. gRPC 구현\ngRPC는 구글이 개발한 고성능 RPC 프레임워크로, 다음과 같은 특징이 있다:\nProtocol Buffers: 데이터를 효율적으로 직렬화하여 네트워크 대역폭을 절약합니다. 다양한 통신 모드: 단순 요청-응답뿐만 아니라, 스트리밍도 지원합니다. 강력한 타입 체크: 컴파일 시점에 타입 오류를 발견할 수 있습니다. GraphQL 구현\nGraphQL은 클라이언트가 필요한 데이터를 정확히 지정할 수 있는 쿼리 언어이다:\n선택적 데이터 조회: 클라이언트가 원하는 필드만 요청할 수 있다. 단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 처리된다. 효율적인 데이터 로딩: 오버페칭과 언더페칭 문제를 해결한다. 통신 모드와 처리 방식 일부 시나리오에서는 비동기 Request-Response 패턴을 사용할 수 있다.\n이 방식에서는 클라이언트가 요청을 보낸 후 즉시 응답을 받지만, 실제 처리 결과는 나중에 별도의 채널을 통해 받는다.\n이는 장시간 실행되는 작업이나 즉시 응답할 수 없는 상황에서 유용하다.\n동기식 처리\n동기식 처리는 클라이언트가 요청을 보내고 응답을 받을 때까지 대기하는 방식:\n1 2 3 4 // 동기식 요청 예시 public UserResponse getUserInfo(Long userId) { return userServiceClient.get(\"/users/\" + userId); } 비동기식 처리\n비동기식 처리는 요청을 보낸 후 즉시 제어를 반환하고, 나중에 응답을 처리한다:\n1 2 3 4 5 // 비동기식 요청 예시 public CompletableFuture\u003cUserResponse\u003e getUserInfoAsync(Long userId) { return userServiceClient.getAsync(\"/users/\" + userId) .thenApply(response -\u003e processResponse(response)); } 장점 명확한 통신: 요청과 응답이 명확히 구분되어 통신 흐름을 이해하기 쉽다. 신뢰성: 동기식 통신으로 응답을 즉시 받을 수 있어 신뢰성이 높다. 데이터 일관성: 요청에 대한 응답을 바로 받아 처리할 수 있어 데이터 일관성 유지에 유리하다. 오류 처리: 응답에 오류 정보를 포함시켜 효과적인 오류 처리가 가능하다. 단점 높은 결합도: 서비스 간 의존성이 높아질 수 있다. 지연 시간: 응답을 기다리는 동안 클라이언트가 차단될 수 있어 전체 시스템의 성능에 영향을 줄 수 있다. 확장성 제한: 동기식 통신으로 인해 시스템 확장에 제약이 있을 수 있다. 사용 사례 Request-Response Pattern은 다음과 같은 상황에서 주로 사용된다:\n데이터 조회: 특정 정보를 즉시 가져와야 하는 경우 인증 및 권한 부여: 사용자 인증이나 권한 확인이 필요한 경우 트랜잭션 처리: 즉각적인 응답이 필요한 금융 거래 등의 처리 실시간 상호작용: 사용자 인터페이스와 직접 연결된 작업 처리 참고 및 출처 ","wordCount":"467","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-28T06:18:00Z","dateModified":"2024-12-28T06:18:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2024/12/request-response-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/12/>12</a></div><h1 class="post-title entry-hint-parent">Request-Response Pattern</h1><div class=post-description>Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.</div><div class=post-meta><span title='2024-12-28 06:18:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;467 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/TIL/2024/12/Request-Response-Pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#request-response-pattern>Request-Response Pattern</a><ul><li><a href=#작동-방식>작동 방식</a></li><li><a href=#구현-방식과-프로토콜>구현 방식과 프로토콜</a></li><li><a href=#통신-모드와-처리-방식>통신 모드와 처리 방식</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#사용-사례>사용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=request-response-pattern>Request-Response Pattern<a hidden class=anchor aria-hidden=true href=#request-response-pattern>#</a></h2><p>Request-Response Pattern은 마이크로서비스 아키텍처(MSA)에서 가장 기본적이고 널리 사용되는 통신 패턴 중 하나이다.</p><p>Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.<br>이는 동기식 통신의 대표적인 예로, 클라이언트는 서버로부터 응답을 받을 때까지 대기한다.</p><h3 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h3><ol><li>클라이언트가 서버에 요청을 보낸다.</li><li>서버는 요청을 받아 처리한다.</li><li>서버는 처리 결과를 응답으로 클라이언트에게 반환한다.</li><li>클라이언트는 응답을 받아 처리한다.</li></ol><pre class=mermaid>sequenceDiagram
    participant Client
    participant Server
    
    Note over Client,Server: HTTP/REST 기반 통신
    Client-&gt;&gt;+Server: GET /users/123
    Note right of Server: 리소스 처리
    Server--&gt;&gt;-Client: 200 OK (사용자 데이터)
    
    Client-&gt;&gt;+Server: POST /orders
    Note right of Server: 주문 생성
    Server--&gt;&gt;-Client: 201 Created
</pre><h3 id=구현-방식과-프로토콜>구현 방식과 프로토콜<a hidden class=anchor aria-hidden=true href=#구현-방식과-프로토콜>#</a></h3><ol><li><p>REST API 구현<br>REST API는 HTTP 프로토콜을 기반으로 하는 가장 보편적인 구현 방식이다.<br>REST는 다음과 같은 특징을 가진다:</p><ul><li>자원 중심 설계: 모든 리소스는 고유한 URI로 식별된다.<br>예를 들어, &lsquo;/users/123&rsquo;은 ID가 123인 사용자 리소스를 나타낸다.</li><li>HTTP 메서드 활용: GET(조회), POST(생성), PUT(수정), DELETE(삭제) 등의 표준 HTTP 메서드를 사용하여 리소스를 조작한다.</li><li>상태 없는(Stateless) 통신: 각 요청은 독립적이며, 서버는 이전 요청의 컨텍스트를 저장하지 않는다.</li></ul></li><li><p>gRPC 구현<br>gRPC는 구글이 개발한 고성능 RPC 프레임워크로, 다음과 같은 특징이 있다:</p><ul><li>Protocol Buffers: 데이터를 효율적으로 직렬화하여 네트워크 대역폭을 절약합니다.</li><li>다양한 통신 모드: 단순 요청-응답뿐만 아니라, 스트리밍도 지원합니다.</li><li>강력한 타입 체크: 컴파일 시점에 타입 오류를 발견할 수 있습니다.</li></ul></li><li><p>GraphQL 구현<br>GraphQL은 클라이언트가 필요한 데이터를 정확히 지정할 수 있는 쿼리 언어이다:</p><ul><li>선택적 데이터 조회: 클라이언트가 원하는 필드만 요청할 수 있다.</li><li>단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 처리된다.</li><li>효율적인 데이터 로딩: 오버페칭과 언더페칭 문제를 해결한다.</li></ul></li></ol><h3 id=통신-모드와-처리-방식>통신 모드와 처리 방식<a hidden class=anchor aria-hidden=true href=#통신-모드와-처리-방식>#</a></h3><p>일부 시나리오에서는 비동기 Request-Response 패턴을 사용할 수 있다.<br>이 방식에서는 클라이언트가 요청을 보낸 후 즉시 응답을 받지만, 실제 처리 결과는 나중에 별도의 채널을 통해 받는다.<br>이는 장시간 실행되는 작업이나 즉시 응답할 수 없는 상황에서 유용하다.</p><ol><li><p>동기식 처리<br>동기식 처리는 클라이언트가 요청을 보내고 응답을 받을 때까지 대기하는 방식:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 동기식 요청 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>UserResponse</span><span class=w> </span><span class=nf>getUserInfo</span><span class=p>(</span><span class=n>Long</span><span class=w> </span><span class=n>userId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>userServiceClient</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=s>&#34;/users/&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>userId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>비동기식 처리<br>비동기식 처리는 요청을 보낸 후 즉시 제어를 반환하고, 나중에 응답을 처리한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 비동기식 요청 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>UserResponse</span><span class=o>&gt;</span><span class=w> </span><span class=nf>getUserInfoAsync</span><span class=p>(</span><span class=n>Long</span><span class=w> </span><span class=n>userId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>userServiceClient</span><span class=p>.</span><span class=na>getAsync</span><span class=p>(</span><span class=s>&#34;/users/&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>userId</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>thenApply</span><span class=p>(</span><span class=n>response</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>processResponse</span><span class=p>(</span><span class=n>response</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li><strong>명확한 통신</strong>: 요청과 응답이 명확히 구분되어 통신 흐름을 이해하기 쉽다.</li><li><strong>신뢰성</strong>: 동기식 통신으로 응답을 즉시 받을 수 있어 신뢰성이 높다.</li><li><strong>데이터 일관성</strong>: 요청에 대한 응답을 바로 받아 처리할 수 있어 데이터 일관성 유지에 유리하다.</li><li><strong>오류 처리</strong>: 응답에 오류 정보를 포함시켜 효과적인 오류 처리가 가능하다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li><strong>높은 결합도</strong>: 서비스 간 의존성이 높아질 수 있다.</li><li><strong>지연 시간</strong>: 응답을 기다리는 동안 클라이언트가 차단될 수 있어 전체 시스템의 성능에 영향을 줄 수 있다.</li><li><strong>확장성 제한</strong>: 동기식 통신으로 인해 시스템 확장에 제약이 있을 수 있다.</li></ol><h3 id=사용-사례>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h3><p>Request-Response Pattern은 다음과 같은 상황에서 주로 사용된다:</p><ol><li><strong>데이터 조회</strong>: 특정 정보를 즉시 가져와야 하는 경우</li><li><strong>인증 및 권한 부여</strong>: 사용자 인증이나 권한 확인이 필요한 경우</li><li><strong>트랜잭션 처리</strong>: 즉각적인 응답이 필요한 금융 거래 등의 처리</li><li><strong>실시간 상호작용</strong>: 사용자 인터페이스와 직접 연결된 작업 처리</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-architecture/>Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-architecture-patterns/>Software-Architecture-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/application-structure/>Application-Structure</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/communication/>Communication</a></li><li><a href=https://buenhyden.github.io/tags/request-response-pattern/>Request-Response-Pattern</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>