<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) | hyunyoun's Blog</title>
<meta name=keywords content="Backend,Database-Systems,Clustering,Replication"><meta name=description content="데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2024/12/database-clustering-and-replication/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2024/12/database-clustering-and-replication/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2024/12/database-clustering-and-replication/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)"><meta property="og:description" content="데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2024-12-05T15:42:00+00:00"><meta property="article:modified_time" content="2024-12-05T15:42:00+00:00"><meta property="article:tag" content="Backend"><meta property="article:tag" content="Database-Systems"><meta property="article:tag" content="Clustering"><meta property="article:tag" content="Replication"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)"><meta name=twitter:description content="데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2024","item":"https://buenhyden.github.io/til/2024/"},{"@type":"ListItem","position":3,"name":"12","item":"https://buenhyden.github.io/til/2024/12/"},{"@type":"ListItem","position":4,"name":"데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)","item":"https://buenhyden.github.io/til/2024/12/database-clustering-and-replication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)","name":"데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)","description":"데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다.","keywords":["Backend","Database-Systems","Clustering","Replication"],"articleBody":"데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.\n기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성\n• 우수한 확장성\n• 효율적인 로드밸런싱\n• 실시간 데이터 동기화 • 구현이 상대적으로 간단\n• 비용 효율적\n• 지리적 분산 용이\n• 읽기 성능 향상 단점 • 구현 비용이 높음\n• 복잡한 구성\n• 네트워크 대역폭 필요\n• 관리 어려움 • 데이터 일관성 보장 어려움\n• 쓰기 성능 향상 제한적\n• 마스터 노드 병목 현상\n• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리\n• 실시간 데이터 처리\n• 무중단 서비스 필요\n• 대규모 동시 접속 처리 • 데이터 백업\n• 읽기 작업이 많은 서비스\n• 지역별 서비스 제공\n• 재해 복구 대비 산업 분야 • 금융 거래 시스템\n• 통신 서비스\n• 대형 전자상거래\n• 실시간 예약 시스템 • 콘텐츠 제공 서비스\n• 분석 리포팅 시스템\n• 글로벌 서비스\n• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요\n• 낮은 지연시간 필수\n• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능\n• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요\n• 동일한 사양의 노드 권장\n• 충분한 메모리 • 마스터 노드 성능 중요\n• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요\n• 모니터링 시스템 필수\n• 정기적인 유지보수 • 상대적으로 간단한 관리\n• 백업 정책 중요\n• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:\n클러스터링은 모든 노드가 동등한 역할을 수행하는 반면, 레플리케이션은 마스터-슬레이브 구조를 가진다. 클러스터링은 실시간 데이터 동기화가 필수적이지만, 레플리케이션은 비동기식 복제도 가능하다. 비용 측면에서 클러스터링이 전반적으로 더 높은 투자가 필요하지만, 고성능과 고가용성을 요구하는 시스템에서는 필수적인 선택이 될 수 있다. 실제 적용 많은 현대적인 분산 데이터베이스 시스템에서는 클러스터링과 레플리케이션을 결합하여 최적의 성능과 가용성을 달성한다.\n예를 들어, Apache Cassandra, Google Spanner 등의 시스템은 두 기술의 장점을 통합하여 사용한다.\n선택 고려 사항 성능 요구사항: 높은 처리량이 필요하면 클러스터링 가용성 중요성: 시스템 지속성이 중요하면 레플리케이션 데이터 특성: 대규모 트랜잭션은 클러스터링, 읽기 집중적 워크로드는 레플리케이션 참고 및 출처 ","wordCount":"476","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-05T15:42:00Z","dateModified":"2024-12-05T15:42:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2024/12/database-clustering-and-replication/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/>2024</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2024/12/>12</a></div><h1 class="post-title entry-hint-parent">데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h1><div class=post-description>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다.</div><div class=post-meta><span title='2024-12-05 15:42:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;476 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/TIL/2024/12/Database-Clustering-and-Replication.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#데이터베이스-클러스터링-clustering과-레플리케이션replication>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</a><ul><li><a href=#기본-개념-비교>기본 개념 비교</a></li><li><a href=#기술적-특징-비교>기술적 특징 비교</a></li><li><a href=#장단점-비교>장단점 비교</a></li><li><a href=#적용-시나리오>적용 시나리오</a></li><li><a href=#구현-고려사항>구현 고려사항</a></li><li><a href=#비용-분석>비용 분석</a></li><li><a href=#실제-적용>실제 적용</a></li><li><a href=#선택-고려-사항>선택 고려 사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=데이터베이스-클러스터링-clustering과-레플리케이션replication>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)<a hidden class=anchor aria-hidden=true href=#데이터베이스-클러스터링-clustering과-레플리케이션replication>#</a></h2><p>두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.</p><h3 id=기본-개념-비교>기본 개념 비교<a hidden class=anchor aria-hidden=true href=#기본-개념-비교>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>정의</td><td>여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식</td><td>데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식</td></tr><tr><td>주요 목적</td><td>성능 향상 및 고가용성 확보</td><td>데이터 안정성 및 가용성 확보</td></tr><tr><td>작동 방식</td><td>여러 노드가 동시에 작업을 처리</td><td>마스터 DB의 데이터를 슬레이브 DB에 복제</td></tr><tr><td>데이터 동기화</td><td>실시간 동기화 필수</td><td>비동기 또는 동기식 복제 가능</td></tr></tbody></table><h3 id=기술적-특징-비교>기술적 특징 비교<a hidden class=anchor aria-hidden=true href=#기술적-특징-비교>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>노드 역할</td><td>모든 노드가 동등한 역할 수행</td><td>마스터-슬레이브 구조의 역할 구분</td></tr><tr><td>로드밸런싱</td><td>자동 로드밸런싱 지원</td><td>읽기 작업에 대한 로드밸런싱 가능</td></tr><tr><td>확장성</td><td>수평적 확장 용이</td><td>읽기 성능 위주의 확장</td></tr><tr><td>장애 대응</td><td>자동 페일오버 지원</td><td>수동 또는 반자동 페일오버</td></tr></tbody></table><h3 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>장점</td><td>• 높은 가용성<br>• 우수한 확장성<br>• 효율적인 로드밸런싱<br>• 실시간 데이터 동기화</td><td>• 구현이 상대적으로 간단<br>• 비용 효율적<br>• 지리적 분산 용이<br>• 읽기 성능 향상</td></tr><tr><td>단점</td><td>• 구현 비용이 높음<br>• 복잡한 구성<br>• 네트워크 대역폭 필요<br>• 관리 어려움</td><td>• 데이터 일관성 보장 어려움<br>• 쓰기 성능 향상 제한적<br>• 마스터 노드 병목 현상<br>• 복제 지연 가능성</td></tr></tbody></table><h3 id=적용-시나리오>적용 시나리오<a hidden class=anchor aria-hidden=true href=#적용-시나리오>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>최적 사용 사례</td><td>• 고성능이 필요한 트랜잭션 처리<br>• 실시간 데이터 처리<br>• 무중단 서비스 필요<br>• 대규모 동시 접속 처리</td><td>• 데이터 백업<br>• 읽기 작업이 많은 서비스<br>• 지역별 서비스 제공<br>• 재해 복구 대비</td></tr><tr><td>산업 분야</td><td>• 금융 거래 시스템<br>• 통신 서비스<br>• 대형 전자상거래<br>• 실시간 예약 시스템</td><td>• 콘텐츠 제공 서비스<br>• 분석 리포팅 시스템<br>• 글로벌 서비스<br>• 미디어 스트리밍</td></tr></tbody></table><h3 id=구현-고려사항>구현 고려사항<a hidden class=anchor aria-hidden=true href=#구현-고려사항>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>네트워크 요구사항</td><td>• 고속 전용 네트워크 필요<br>• 낮은 지연시간 필수<br>• 안정적인 네트워크 연결</td><td>• 일반 네트워크 사용 가능<br>• 비동기 복제 시 네트워크 요구사항 낮음</td></tr><tr><td>하드웨어 요구사항</td><td>• 고성능 서버 필요<br>• 동일한 사양의 노드 권장<br>• 충분한 메모리</td><td>• 마스터 노드 성능 중요<br>• 슬레이브는 상대적으로 낮은 사양 가능</td></tr><tr><td>운영 관리</td><td>• 전문 관리자 필요<br>• 모니터링 시스템 필수<br>• 정기적인 유지보수</td><td>• 상대적으로 간단한 관리<br>• 백업 정책 중요<br>• 복제 상태 모니터링</td></tr></tbody></table><h3 id=비용-분석>비용 분석<a hidden class=anchor aria-hidden=true href=#비용-분석>#</a></h3><table><thead><tr><th>구분</th><th>클러스터링 (Clustering)</th><th>레플리케이션 (Replication)</th></tr></thead><tbody><tr><td>초기 구축 비용</td><td>매우 높음</td><td>중간</td></tr><tr><td>운영 비용</td><td>높음</td><td>중간</td></tr><tr><td>유지보수 비용</td><td>높음</td><td>중간~낮음</td></tr><tr><td>ROI</td><td>장기적으로 높음</td><td>중단기적으로 높음</td></tr></tbody></table><p>특히 주목할 만한 차이점은 다음과 같다:</p><ol><li>클러스터링은 모든 노드가 동등한 역할을 수행하는 반면, 레플리케이션은 마스터-슬레이브 구조를 가진다.</li><li>클러스터링은 실시간 데이터 동기화가 필수적이지만, 레플리케이션은 비동기식 복제도 가능하다.</li><li>비용 측면에서 클러스터링이 전반적으로 더 높은 투자가 필요하지만, 고성능과 고가용성을 요구하는 시스템에서는 필수적인 선택이 될 수 있다.</li></ol><h3 id=실제-적용>실제 적용<a hidden class=anchor aria-hidden=true href=#실제-적용>#</a></h3><p>많은 현대적인 분산 데이터베이스 시스템에서는 클러스터링과 레플리케이션을 결합하여 최적의 성능과 가용성을 달성한다.<br>예를 들어, Apache Cassandra, Google Spanner 등의 시스템은 두 기술의 장점을 통합하여 사용한다.</p><h3 id=선택-고려-사항>선택 고려 사항<a hidden class=anchor aria-hidden=true href=#선택-고려-사항>#</a></h3><ul><li><strong>성능 요구사항</strong>: 높은 처리량이 필요하면 클러스터링</li><li><strong>가용성 중요성</strong>: 시스템 지속성이 중요하면 레플리케이션</li><li><strong>데이터 특성</strong>: 대규모 트랜잭션은 클러스터링, 읽기 집중적 워크로드는 레플리케이션</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend/>Backend</a></li><li><a href=https://buenhyden.github.io/tags/database-systems/>Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/clustering/>Clustering</a></li><li><a href=https://buenhyden.github.io/tags/replication/>Replication</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>