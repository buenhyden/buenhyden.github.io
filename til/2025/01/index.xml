<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>01 on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/til/2025/01/</link>
    <description>Recent content in 01 on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.141.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Jan 2025 08:02:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/til/2025/01/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Concurrent Hash Map vs Hash Map vs Hash Table</title>
      <link>https://buenhyden.github.io/til/2025/01/concurrent-hash-map-vs-hash-map-vs-hash-table/</link>
      <pubDate>Mon, 06 Jan 2025 14:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/concurrent-hash-map-vs-hash-map-vs-hash-table/</guid>
      <description>&lt;h2 id=&#34;concurrent-hash-map-vs-hash-map-vs-hash-table&#34;&gt;Concurrent Hash Map Vs Hash Map Vs Hash Table&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특성&lt;/th&gt;
          &lt;th&gt;Concurrent HashMap&lt;/th&gt;
          &lt;th&gt;HashMap&lt;/th&gt;
          &lt;th&gt;HashTable&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트/버킷 단위의 부분 동기화 지원&lt;/td&gt;
          &lt;td&gt;동기화 지원하지 않음&lt;/td&gt;
          &lt;td&gt;메서드 단위의 전체 동기화 지원&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동시성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능)&lt;/td&gt;
          &lt;td&gt;동시성 지원하지 않음 (단일 스레드 환경용)&lt;/td&gt;
          &lt;td&gt;낮은 동시성 (한 번에 하나의 스레드만 접근 가능)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동시 접근 시 높은 성능&lt;/td&gt;
          &lt;td&gt;단일 스레드에서 가장 높은 성능&lt;/td&gt;
          &lt;td&gt;동기화로 인한 성능 저하&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;null 허용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
          &lt;td&gt;key는 하나만 null 허용, value는 여러 개 null 허용&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;초기 용량&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 16, 세그먼트 수는 16&lt;/td&gt;
          &lt;td&gt;기본 16&lt;/td&gt;
          &lt;td&gt;기본 11&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;적재율&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;이터레이션&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;fail-safe 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;생성 시기&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Java 5&lt;/td&gt;
          &lt;td&gt;Java 1.2&lt;/td&gt;
          &lt;td&gt;Java 1.0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;메모리 사용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트로 인한 추가 메모리 필요&lt;/td&gt;
          &lt;td&gt;가장 적은 메모리 사용&lt;/td&gt;
          &lt;td&gt;동기화로 인한 추가 메모리 필요&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;용도&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;멀티스레드 환경의 동시성이 필요한 경우&lt;/td&gt;
          &lt;td&gt;단일 스레드 환경의 일반적인 경우&lt;/td&gt;
          &lt;td&gt;레거시 코드 호환성이 필요한 경우&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;순서 보장&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화 비용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;부분적 동기화로 중간 수준의 비용&lt;/td&gt;
          &lt;td&gt;동기화 비용 없음&lt;/td&gt;
          &lt;td&gt;전체 동기화로 높은 비용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;스레드 안전성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
          &lt;td&gt;스레드 안전하지 않음&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;키 충돌 처리&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;참고로 몇 가지 중요한 추가 설명을 하자면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Concurrent Data Structure</title>
      <link>https://buenhyden.github.io/til/2025/01/concurrent-data-structure/</link>
      <pubDate>Mon, 06 Jan 2025 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/concurrent-data-structure/</guid>
      <description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Wed, 08 Jan 2025 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>Memoization vs Tabulation</title>
      <link>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation/</link>
      <pubDate>Mon, 13 Jan 2025 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation/</guid>
      <description>Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법</description>
    </item>
    <item>
      <title>Iteration vs Recursion</title>
      <link>https://buenhyden.github.io/til/2025/01/iteration-vs-recursion/</link>
      <pubDate>Mon, 13 Jan 2025 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/iteration-vs-recursion/</guid>
      <description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</description>
    </item>
    <item>
      <title>Multithreading Vs Multiprocessing vs Multitasking</title>
      <link>https://buenhyden.github.io/til/2025/01/multithreading-vs-multiprocessing-vs-multitasking/</link>
      <pubDate>Tue, 14 Jan 2025 14:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/multithreading-vs-multiprocessing-vs-multitasking/</guid>
      <description>Multithreading, Multiprocessing, Multitasking은 컴퓨터 시스템에서 동시성과 병렬성을 구현하는 세 가지 주요 개념이다.</description>
    </item>
    <item>
      <title>Nginx vs Apache HTTP Server vs Caddy</title>
      <link>https://buenhyden.github.io/til/2025/01/nginx-vs-apache-tomcat-vs-caddy/</link>
      <pubDate>Thu, 16 Jan 2025 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/nginx-vs-apache-tomcat-vs-caddy/</guid>
      <description>Nginx, Apache HTTP Server, 그리고 Caddy는 모두 웹 서버 소프트웨어이다.</description>
    </item>
    <item>
      <title>Kafka vs RabbitMQ</title>
      <link>https://buenhyden.github.io/til/2025/01/kafka-vs-rabbitmq/</link>
      <pubDate>Thu, 16 Jan 2025 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/kafka-vs-rabbitmq/</guid>
      <description>Kafka와 RabbitMQ는 모두 메시지 브로커 시스템으로, 분산 시스템에서 데이터를 효율적으로 전송하고 처리하는 역할을 한다.</description>
    </item>
    <item>
      <title>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</link>
      <pubDate>Thu, 16 Jan 2025 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</guid>
      <description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description>
    </item>
    <item>
      <title>Shared Database vs Shared Database Per Service</title>
      <link>https://buenhyden.github.io/til/2025/01/shared-database-vs-shared-database-per-service/</link>
      <pubDate>Wed, 22 Jan 2025 08:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/shared-database-vs-shared-database-per-service/</guid>
      <description>&lt;h2 id=&#34;shared-database-vs-shared-database-per-service&#34;&gt;Shared Database vs Shared Database Per Service&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>ETL vs ELT</title>
      <link>https://buenhyden.github.io/til/2025/01/etl-vs-elt/</link>
      <pubDate>Wed, 22 Jan 2025 07:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/etl-vs-elt/</guid>
      <description>&lt;h2 id=&#34;etl-vs-elt&#34;&gt;ETL Vs ELT&lt;/h2&gt;
&lt;p&gt;ELT(Extract, Load, Transform)와 ETL(Extract, Transform, Load)은 데이터 통합 및 처리를 위한 두 가지 주요 접근 방식이다. 각각의 단계 순서와 처리 방식에 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;ETL Vs ELT&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Infographic-Option-4-2-970x546.png&#34;&gt;&lt;figcaption&gt;https://www.striim.com/blog/etl-vs-elt-differences/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;etl-extract-transform-load&#34;&gt;ETL (Extract, Transform, Load)&lt;/h3&gt;
&lt;p&gt;ETL(Extract, Transform, Load)은 데이터 통합 및 처리를 위한 중요한 프로세스이다.&lt;br&gt;
이 프로세스는 다양한 소스에서 데이터를 추출하고, 변환한 후 목표 시스템에 로드하는 세 단계로 구성된다.&lt;/p&gt;
&lt;h4 id=&#34;etl의-주요-단계&#34;&gt;ETL의 주요 단계&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;추출(Extract)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 소스(데이터베이스, API, 로그 파일 등)에서 원시 데이터를 추출한다.&lt;/li&gt;
&lt;li&gt;데이터는 구조화, 반구조화, 비구조화된 형태일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;변환(Transform)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Data Lake vs Data Warehouse  vs Data Lakehouse</title>
      <link>https://buenhyden.github.io/til/2025/01/data-lake-vs-data-warehouse--vs-data-lakehouse/</link>
      <pubDate>Wed, 22 Jan 2025 05:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/data-lake-vs-data-warehouse--vs-data-lakehouse/</guid>
      <description>데이터 레이크(Data Lake)와 데이터 웨어하우스(Data Warehouse)는 기업의 데이터 관리 및 분석을 위한 중요한 저장소 시스템이다.</description>
    </item>
    <item>
      <title>Callback vs Promise vs Async/Await</title>
      <link>https://buenhyden.github.io/til/2025/01/callback-vs-promise-vs-async-await/</link>
      <pubDate>Fri, 17 Jan 2025 09:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/callback-vs-promise-vs-async-await/</guid>
      <description>JavaScript의 비동기 처리 방식</description>
    </item>
    <item>
      <title>Paging vs Segmentation</title>
      <link>https://buenhyden.github.io/til/2025/01/paging-vs-segmentation/</link>
      <pubDate>Thu, 16 Jan 2025 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/paging-vs-segmentation/</guid>
      <description>Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.</description>
    </item>
    <item>
      <title>Poetry vs uv vs Rye</title>
      <link>https://buenhyden.github.io/til/2025/01/poetry-vs-uv-vs-rye/</link>
      <pubDate>Wed, 15 Jan 2025 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/poetry-vs-uv-vs-rye/</guid>
      <description>파이썬 프로젝트 관리와 패키지 설치를 위한 도구들</description>
    </item>
    <item>
      <title>Interface vs Abstract class</title>
      <link>https://buenhyden.github.io/til/2025/01/interface-vs-abstract-class/</link>
      <pubDate>Mon, 13 Jan 2025 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2025/01/interface-vs-abstract-class/</guid>
      <description>인터페이스는 클래스가 &amp;#39;무엇을 해야 하는지&amp;#39;를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.</description>
    </item>
  </channel>
</rss>
