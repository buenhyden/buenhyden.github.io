<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>01 :: hyunyoun's Blog</title><link>https://buenhyden.github.io/til/2025/01.html</link><description/><generator>Hugo</generator><language>en</language><managingEditor>chochyjj@gmail.com (Hyunyoun Jo)</managingEditor><webMaster>chochyjj@gmail.com (Hyunyoun Jo)</webMaster><lastBuildDate>Thu, 16 Jan 2025 11:42:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/til/2025/01/index.xml" rel="self" type="application/rss+xml"/><item><title>MSA 패턴 유형별 비교</title><link>https://buenhyden.github.io/til/2025/01/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90.html</link><pubDate>Sat, 04 Jan 2025 02:45:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90.html</guid><description>MSA의 주요 패턴 유형들을 체계적으로 정리한 것.</description></item><item><title>Concurrent Hash Map vs Hash Map vs Hash Table</title><link>https://buenhyden.github.io/til/2025/01/concurrent-hash-map-vs-hash-map-vs-hash-table.html</link><pubDate>Mon, 06 Jan 2025 14:35:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/concurrent-hash-map-vs-hash-map-vs-hash-table.html</guid><description>Concurrent Hash Map Vs Hash Map Vs Hash Table 특성 Concurrent HashMap HashMap HashTable 동기화 세그먼트/버킷 단위의 부분 동기화 지원 동기화 지원하지 않음 메서드 단위의 전체 동기화 지원 동시성 높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능) 동시성 지원하지 않음 (단일 스레드 환경용) 낮은 동시성 (한 번에 하나의 스레드만 접근 가능) 성능 동시 접근 시 높은 성능 단일 스레드에서 가장 높은 성능 동기화로 인한 성능 저하 null 허용 key와 value 모두 null 불가 key는 하나만 null 허용, value는 여러 개 null 허용 key와 value 모두 null 불가 초기 용량 기본 16, 세그먼트 수는 16 기본 16 기본 11 적재율 기본 0.75 기본 0.75 기본 0.75 이터레이션 fail-safe 이터레이터 제공 fail-fast 이터레이터 제공 fail-fast 이터레이터 제공 생성 시기 Java 5 Java 1.2 Java 1.0 메모리 사용 세그먼트로 인한 추가 메모리 필요 가장 적은 메모리 사용 동기화로 인한 추가 메모리 필요 용도 멀티스레드 환경의 동시성이 필요한 경우 단일 스레드 환경의 일반적인 경우 레거시 코드 호환성이 필요한 경우 확장성 동적 확장 가능 동적 확장 가능 동적 확장 가능 순서 보장 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 삽입 순서 보장하지 않음 동기화 비용 부분적 동기화로 중간 수준의 비용 동기화 비용 없음 전체 동기화로 높은 비용 스레드 안전성 스레드 안전 스레드 안전하지 않음 스레드 안전 키 충돌 처리 체이닝 방식 체이닝 방식 체이닝 방식 참고로 몇 가지 중요한 추가 설명을 하자면:</description></item><item><title>Concurrent Data Structure</title><link>https://buenhyden.github.io/til/2025/01/concurrent-data-structure.html</link><pubDate>Mon, 06 Jan 2025 12:55:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/concurrent-data-structure.html</guid><description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</description></item><item><title>Suffix Array vs Suffix Tree vs Trie</title><link>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie.html</link><pubDate>Wed, 08 Jan 2025 15:40:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie.html</guid><description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description></item><item><title>Memoization vs Tabulation</title><link>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation.html</link><pubDate>Mon, 13 Jan 2025 11:25:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/memoization-vs-tabulation.html</guid><description>Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법</description></item><item><title>Programming Language Control Structures</title><link>https://buenhyden.github.io/til/2025/01/programming-language-control-structures.html</link><pubDate>Mon, 13 Jan 2025 11:12:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/programming-language-control-structures.html</guid><description>프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.</description></item><item><title>Iteration vs Recursion</title><link>https://buenhyden.github.io/til/2025/01/iteration-vs-recursion.html</link><pubDate>Mon, 13 Jan 2025 11:03:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/iteration-vs-recursion.html</guid><description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</description></item><item><title>Multithreading Vs Multiprocessing vs Multitasking</title><link>https://buenhyden.github.io/til/2025/01/multithreading-vs-multiprocessing-vs-multitasking.html</link><pubDate>Tue, 14 Jan 2025 14:39:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/multithreading-vs-multiprocessing-vs-multitasking.html</guid><description>Multithreading, Multiprocessing, Multitasking은 컴퓨터 시스템에서 동시성과 병렬성을 구현하는 세 가지 주요 개념이다.</description></item><item><title>Nginx vs Apache HTTP Server vs Caddy</title><link>https://buenhyden.github.io/til/2025/01/nginx-vs-apache-tomcat-vs-caddy.html</link><pubDate>Thu, 16 Jan 2025 11:42:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/nginx-vs-apache-tomcat-vs-caddy.html</guid><description>Nginx, Apache HTTP Server, 그리고 Caddy는 모두 웹 서버 소프트웨어이다.</description></item><item><title>Kafka vs RabbitMQ</title><link>https://buenhyden.github.io/til/2025/01/kafka-vs-rabbitmq.html</link><pubDate>Thu, 16 Jan 2025 11:41:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/kafka-vs-rabbitmq.html</guid><description>Kafka와 RabbitMQ는 모두 메시지 브로커 시스템으로, 분산 시스템에서 데이터를 효율적으로 전송하고 처리하는 역할을 한다.</description></item><item><title>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title><link>https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern.html</link><pubDate>Thu, 16 Jan 2025 03:37:00 +0000</pubDate><author>chochyjj@gmail.com (Hyunyoun Jo)</author><guid>https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern.html</guid><description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description></item></channel></rss>