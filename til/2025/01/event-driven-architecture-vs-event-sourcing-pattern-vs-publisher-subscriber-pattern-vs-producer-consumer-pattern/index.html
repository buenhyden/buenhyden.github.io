<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture-Patterns,Event-Driven-Architecture,Event-Sourcing-Pattern,Publisher-Subscriber-Pattern,Producer-Consumer-Pattern"><meta name=description content="EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern"><meta property="og:description" content="EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2025-01-16T03:37:00+00:00"><meta property="article:modified_time" content="2025-01-16T03:37:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="Software-Architecture-Patterns"><meta property="article:tag" content="Event-Driven-Architecture"><meta property="article:tag" content="Event-Sourcing-Pattern"><meta property="article:tag" content="Publisher-Subscriber-Pattern"><meta property="article:tag" content="Producer-Consumer-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern"><meta name=twitter:description content="EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2025","item":"https://buenhyden.github.io/til/2025/"},{"@type":"ListItem","position":3,"name":"01","item":"https://buenhyden.github.io/til/2025/01/"},{"@type":"ListItem","position":4,"name":"Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern","item":"https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern","name":"Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern","description":"EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.","keywords":["Software-Design-and-Architecture","Software-Architecture-Patterns","Event-Driven-Architecture","Event-Sourcing-Pattern","Publisher-Subscriber-Pattern","Producer-Consumer-Pattern"],"articleBody":"Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.\n이들의 관계를 다음과 같이 설명할 수 있다:\nEvent-Driven Architecture (EDA)와 다른 패턴들의 관계:\nEDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:\n두 패턴 모두 비동기 메시징을 위한 디자인 패턴이지만, 약간의 차이가 있다. Publisher-Subscriber Pattern은 메시지를 특정 주제(topic)에 발행하고, 해당 주제를 구독하는 모든 구독자에게 메시지를 전달한다. Producer-Consumer Pattern은 일반적으로 메시지를 큐에 넣고, 하나의 소비자가 메시지를 처리한다. Publisher-Subscriber Pattern은 Producer-Consumer Pattern의 확장된 형태로 볼 수 있다. Event Sourcing Pattern과 다른 패턴들의 관계:\nEvent Sourcing은 시스템의 상태 변화를 이벤트로 저장하는 방식. 이 패턴은 Publisher-Subscriber 또는 Producer-Consumer 패턴을 활용하여 이벤트를 발행하고 구독할 수 있다. Event Sourcing은 EDA의 핵심 구성 요소 중 하나로, 이벤트의 저장과 재생을 통해 시스템의 상태를 관리한다. 통합적 관점: EDA는 이러한 패턴들을 포괄하는 상위 개념으로, 시스템 전체의 이벤트 중심 설계를 지향한다. Publisher-Subscriber와 Producer-Consumer 패턴은 EDA 내에서 이벤트의 생성과 소비를 관리하는 메커니즘을 제공한다. Event Sourcing은 이벤트의 지속성과 시스템 상태 관리를 담당하며, EDA의 이벤트 처리 방식을 보완한다. 이러한 패턴들은 서로 보완적인 관계를 가지며, 복잡한 분산 시스템에서 함께 사용되어 시너지 효과를 낼 수 있다.\n예를 들어, Event Sourcing을 통해 저장된 이벤트는 Publisher-Subscriber 패턴을 통해 다른 서비스에 전파될 수 있으며, 이는 전체적인 Event-Driven Architecture의 일부로 작동할 수 있다.\n특성 Event-Driven Architecture Event Sourcing Pattern Publisher-Subscriber Pattern Producer-Consumer Pattern 주요 목적 이벤트 중심의 시스템 설계 모든 상태 변경을 이벤트로 저장하고 재구성 메시지 발행자와 구독자 간 느슨한 결합 제공 데이터 생성과 소비 작업 분리 핵심 구성 요소 이벤트 생성자, 이벤트 채널, 이벤트 처리자 이벤트 스토어, 이벤트 생성자, 이벤트 소비자 발행자, 구독자, 메시지 브로커 프로듀서, 컨슈머, 공유 버퍼(큐) 데이터 흐름 이벤트 발생 → 채널 → 처리 이벤트 생성 → 저장 → 재생 메시지 발행 → 브로커 → 구독자 전달 데이터 생성 → 버퍼 저장 → 소비 주요 사용 사례 마이크로서비스, IoT, 실시간 분석 감사, 규정 준수, 복잡한 도메인 모델링 실시간 알림, 데이터 동기화 작업 큐, 로그 처리, 스트리밍 데이터 장점 높은 확장성, 반응성 완전한 감사 추적, 시간 기반 쿼리 느슨한 결합, 실시간 데이터 처리 비동기 처리, 부하 분산 단점 시스템 복잡도 증가, 일관성 유지 어려움 구현 복잡성, 스키마 변경 어려움 메시지 순서 보장 어려움, 복잡한 디버깅 버퍼 관리 복잡성, 메모리 사용량 증가 확장성 전체 시스템 확장성 제공 이벤트 저장소 확장성에 의존 메시지 브로커 확장성에 의존 프로듀서와 컨슈머 독립 확장 가능 데이터 저장 패턴에 따라 다름 모든 이벤트 영구 저장 일시적 저장 또는 즉시 처리 일시적 버퍼 저장 복잡성 수준 높음 높음 중간 중간 상태 관리 이벤트 기반 상태 변경 이벤트 기반 상태 재구성 현재 상태 중심 현재 상태 중심 Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Producer-Consumer Pattern과 Publisher-Subscriber Pattern은 비동기 통신을 위한 소프트웨어 아키텍처 패턴이지만, 몇 가지 중요한 차이점이 있다:\nProducer-Consumer Pattern과 Publisher-Subscriber Pattern의 주요 차이점을 다음 표로 정리했습니다:\n특성 Producer-Consumer Pattern Publisher-Subscriber Pattern 통신 방식 일대일 또는 일대다 일대다 메시지 처리 각 메시지는 단일 소비자에 의해 처리 하나의 메시지가 여러 구독자에 의해 동시에 처리 가능 결합도 생산자와 소비자 간의 결합도가 상대적으로 높음 발행자와 구독자 간의 결합도가 낮음 메시지 분배 작업 큐를 통해 메시지 분배 토픽/채널을 통해 메시지 분배 확장성 소비자 추가로 처리량 증가, 각 메시지는 하나의 소비자만 처리 새로운 구독자를 쉽게 추가 가능, 모든 구독자가 메시지를 받을 수 있음 사용 사례 작업 큐, 부하 분산, 비동기 처리 이벤트 기반 아키텍처, 실시간 업데이트, 다중 수신자에게 메시지 브로드캐스팅 메시지 보존 일반적으로 처리 후 메시지 삭제 메시지 브로커에 따라 메시지 보존 가능 구현 복잡성 상대적으로 단순 메시지 필터링, 라우팅 등으로 인해 더 복잡할 수 있음 동기화 생산자와 소비자 간 동기화 필요 발행자와 구독자 간 동기화 불필요 백프레셔 관리 큐 크기 제한으로 백프레셔 관리 가능 메시지 브로커를 통한 백프레셔 관리 참고 및 출처 ","wordCount":"626","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-16T03:37:00Z","dateModified":"2025-01-16T03:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2025/01/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2025/>2025</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2025/01/>01</a></div><h1 class="post-title entry-hint-parent">Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h1><div class=post-description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</div><div class=post-meta><span title='2025-01-16 03:37:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;626 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern</a><ul><li><a href=#publisher-subscriber-pattern-vs-producer-consumer-pattern>Publisher-Subscriber Pattern Vs Producer-Consumer Pattern</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern<a hidden class=anchor aria-hidden=true href=#event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern>#</a></h2><p>Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.<br>이들의 관계를 다음과 같이 설명할 수 있다:</p><ol><li><p>Event-Driven Architecture (EDA)와 다른 패턴들의 관계:</p><ul><li>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일.</li><li>Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다.</li><li>Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</li></ul></li><li><p>Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:</p><ul><li>두 패턴 모두 비동기 메시징을 위한 디자인 패턴이지만, 약간의 차이가 있다.</li><li>Publisher-Subscriber Pattern은 메시지를 특정 주제(topic)에 발행하고, 해당 주제를 구독하는 모든 구독자에게 메시지를 전달한다.</li><li>Producer-Consumer Pattern은 일반적으로 메시지를 큐에 넣고, 하나의 소비자가 메시지를 처리한다.</li><li>Publisher-Subscriber Pattern은 Producer-Consumer Pattern의 확장된 형태로 볼 수 있다.</li></ul></li><li><p>Event Sourcing Pattern과 다른 패턴들의 관계:</p></li></ol><ul><li>Event Sourcing은 시스템의 상태 변화를 이벤트로 저장하는 방식.</li><li>이 패턴은 Publisher-Subscriber 또는 Producer-Consumer 패턴을 활용하여 이벤트를 발행하고 구독할 수 있다.</li><li>Event Sourcing은 EDA의 핵심 구성 요소 중 하나로, 이벤트의 저장과 재생을 통해 시스템의 상태를 관리한다.</li></ul><ol start=4><li>통합적 관점:</li></ol><ul><li>EDA는 이러한 패턴들을 포괄하는 상위 개념으로, 시스템 전체의 이벤트 중심 설계를 지향한다.</li><li>Publisher-Subscriber와 Producer-Consumer 패턴은 EDA 내에서 이벤트의 생성과 소비를 관리하는 메커니즘을 제공한다.</li><li>Event Sourcing은 이벤트의 지속성과 시스템 상태 관리를 담당하며, EDA의 이벤트 처리 방식을 보완한다.</li></ul><p>이러한 패턴들은 서로 보완적인 관계를 가지며, 복잡한 분산 시스템에서 함께 사용되어 시너지 효과를 낼 수 있다.<br>예를 들어, Event Sourcing을 통해 저장된 이벤트는 Publisher-Subscriber 패턴을 통해 다른 서비스에 전파될 수 있으며, 이는 전체적인 Event-Driven Architecture의 일부로 작동할 수 있다.</p><table><thead><tr><th>특성</th><th>Event-Driven Architecture</th><th>Event Sourcing Pattern</th><th>Publisher-Subscriber Pattern</th><th>Producer-Consumer Pattern</th></tr></thead><tbody><tr><td>주요 목적</td><td>이벤트 중심의 시스템 설계</td><td>모든 상태 변경을 이벤트로 저장하고 재구성</td><td>메시지 발행자와 구독자 간 느슨한 결합 제공</td><td>데이터 생성과 소비 작업 분리</td></tr><tr><td>핵심 구성 요소</td><td>이벤트 생성자, 이벤트 채널, 이벤트 처리자</td><td>이벤트 스토어, 이벤트 생성자, 이벤트 소비자</td><td>발행자, 구독자, 메시지 브로커</td><td>프로듀서, 컨슈머, 공유 버퍼(큐)</td></tr><tr><td>데이터 흐름</td><td>이벤트 발생 → 채널 → 처리</td><td>이벤트 생성 → 저장 → 재생</td><td>메시지 발행 → 브로커 → 구독자 전달</td><td>데이터 생성 → 버퍼 저장 → 소비</td></tr><tr><td>주요 사용 사례</td><td>마이크로서비스, IoT, 실시간 분석</td><td>감사, 규정 준수, 복잡한 도메인 모델링</td><td>실시간 알림, 데이터 동기화</td><td>작업 큐, 로그 처리, 스트리밍 데이터</td></tr><tr><td>장점</td><td>높은 확장성, 반응성</td><td>완전한 감사 추적, 시간 기반 쿼리</td><td>느슨한 결합, 실시간 데이터 처리</td><td>비동기 처리, 부하 분산</td></tr><tr><td>단점</td><td>시스템 복잡도 증가, 일관성 유지 어려움</td><td>구현 복잡성, 스키마 변경 어려움</td><td>메시지 순서 보장 어려움, 복잡한 디버깅</td><td>버퍼 관리 복잡성, 메모리 사용량 증가</td></tr><tr><td>확장성</td><td>전체 시스템 확장성 제공</td><td>이벤트 저장소 확장성에 의존</td><td>메시지 브로커 확장성에 의존</td><td>프로듀서와 컨슈머 독립 확장 가능</td></tr><tr><td>데이터 저장</td><td>패턴에 따라 다름</td><td>모든 이벤트 영구 저장</td><td>일시적 저장 또는 즉시 처리</td><td>일시적 버퍼 저장</td></tr><tr><td>복잡성 수준</td><td>높음</td><td>높음</td><td>중간</td><td>중간</td></tr><tr><td>상태 관리</td><td>이벤트 기반 상태 변경</td><td>이벤트 기반 상태 재구성</td><td>현재 상태 중심</td><td>현재 상태 중심</td></tr></tbody></table><h3 id=publisher-subscriber-pattern-vs-producer-consumer-pattern>Publisher-Subscriber Pattern Vs Producer-Consumer Pattern<a hidden class=anchor aria-hidden=true href=#publisher-subscriber-pattern-vs-producer-consumer-pattern>#</a></h3><p>Producer-Consumer Pattern과 Publisher-Subscriber Pattern은 비동기 통신을 위한 소프트웨어 아키텍처 패턴이지만, 몇 가지 중요한 차이점이 있다:</p><p>Producer-Consumer Pattern과 Publisher-Subscriber Pattern의 주요 차이점을 다음 표로 정리했습니다:</p><table><thead><tr><th>특성</th><th>Producer-Consumer Pattern</th><th>Publisher-Subscriber Pattern</th></tr></thead><tbody><tr><td>통신 방식</td><td>일대일 또는 일대다</td><td>일대다</td></tr><tr><td>메시지 처리</td><td>각 메시지는 단일 소비자에 의해 처리</td><td>하나의 메시지가 여러 구독자에 의해 동시에 처리 가능</td></tr><tr><td>결합도</td><td>생산자와 소비자 간의 결합도가 상대적으로 높음</td><td>발행자와 구독자 간의 결합도가 낮음</td></tr><tr><td>메시지 분배</td><td>작업 큐를 통해 메시지 분배</td><td>토픽/채널을 통해 메시지 분배</td></tr><tr><td>확장성</td><td>소비자 추가로 처리량 증가, 각 메시지는 하나의 소비자만 처리</td><td>새로운 구독자를 쉽게 추가 가능, 모든 구독자가 메시지를 받을 수 있음</td></tr><tr><td>사용 사례</td><td>작업 큐, 부하 분산, 비동기 처리</td><td>이벤트 기반 아키텍처, 실시간 업데이트, 다중 수신자에게 메시지 브로드캐스팅</td></tr><tr><td>메시지 보존</td><td>일반적으로 처리 후 메시지 삭제</td><td>메시지 브로커에 따라 메시지 보존 가능</td></tr><tr><td>구현 복잡성</td><td>상대적으로 단순</td><td>메시지 필터링, 라우팅 등으로 인해 더 복잡할 수 있음</td></tr><tr><td>동기화</td><td>생산자와 소비자 간 동기화 필요</td><td>발행자와 구독자 간 동기화 불필요</td></tr><tr><td>백프레셔 관리</td><td>큐 크기 제한으로 백프레셔 관리 가능</td><td>메시지 브로커를 통한 백프레셔 관리</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-architecture-patterns/>Software-Architecture-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/event-driven-architecture/>Event-Driven-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/event-sourcing-pattern/>Event-Sourcing-Pattern</a></li><li><a href=https://buenhyden.github.io/tags/publisher-subscriber-pattern/>Publisher-Subscriber-Pattern</a></li><li><a href=https://buenhyden.github.io/tags/producer-consumer-pattern/>Producer-Consumer-Pattern</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>