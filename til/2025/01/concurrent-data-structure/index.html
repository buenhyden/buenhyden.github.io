<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrent Data Structure | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structure-and-Algorithm,Data-Structure,Non-Primitive-data-structure,Concurrent,Concurrent-HashMap,Concurrent-Skip-List,Lock-free-Queue,Lock-free-Stack,Read-Copy-Update-List,RCU-list"><meta name=description content="Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/til/2025/01/concurrent-data-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/til/2025/01/concurrent-data-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/til/2025/01/concurrent-data-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concurrent Data Structure"><meta property="og:description" content="Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="til"><meta property="article:published_time" content="2025-01-06T12:55:00+00:00"><meta property="article:modified_time" content="2025-01-06T12:55:00+00:00"><meta property="article:tag" content="Data-Structure-and-Algorithm"><meta property="article:tag" content="Data-Structure"><meta property="article:tag" content="Non-Primitive-Data-Structure"><meta property="article:tag" content="Concurrent"><meta property="article:tag" content="Concurrent-HashMap"><meta property="article:tag" content="Concurrent-Skip-List"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concurrent Data Structure"><meta name=twitter:description content="Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"TIL","item":"https://buenhyden.github.io/til/"},{"@type":"ListItem","position":2,"name":"2025","item":"https://buenhyden.github.io/til/2025/"},{"@type":"ListItem","position":3,"name":"01","item":"https://buenhyden.github.io/til/2025/01/"},{"@type":"ListItem","position":4,"name":"Concurrent Data Structure","item":"https://buenhyden.github.io/til/2025/01/concurrent-data-structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrent Data Structure","name":"Concurrent Data Structure","description":"Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.","keywords":["Data-Structure-and-Algorithm","Data-Structure","Non-Primitive-data-structure","Concurrent","Concurrent-HashMap","Concurrent-Skip-List","Lock-free-Queue","Lock-free-Stack","Read-Copy-Update-List","RCU-list"],"articleBody":"Concurrent Data Structure Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조이다.\n전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.\nConcurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계된 데이터 구조입니다.\nConcurrent Data Structure는 일반적으로 다음과 같은 방식으로 구현된다:\n세밀한 락(fine-grained locking) 사용 락 없는(lock-free) 알고리즘 대기 없는(wait-free) 알고리즘 지연된 삭제와 메모리 재사용 기법 이러한 구조는 고성능 멀티스레드 시스템, 데이터베이스, 운영체제, 네트워크 스택 등 다양한 분야에서 활용된다.\n주요 특징 스레드 안전성: 여러 스레드가 동시에 접근해도 데이터의 일관성을 유지한다. 높은 동시성: 여러 스레드가 동시에 작업을 수행할 수 있어 성능이 향상된다. 락 최소화: 전체 구조에 대한 락 대신 세밀한 락이나 락 없는 기법을 사용한다. 확장성: 스레드 수가 증가해도 성능 저하가 적다. 원자적 연산: Compare-And-Swap(CAS)과 같은 원자적 연산을 활용한다. Concurrent Data Structure 패턴 비교 특성 Concurrent HashMap Concurrent Skip List Lock-free Queue Lock-free Stack Read-Copy-Update (RCU) List 개념 동시에 여러 스레드가 접근 가능한 해시 기반 맵 동시성을 지원하는 계층화된 정렬 리스트 락 없이 동시 접근 가능한 FIFO 큐 락 없이 동시 접근 가능한 LIFO 스택 읽기에 최적화된 동시성 리스트 동기화 방식 세그먼트 락 또는 CAS CAS 기반 CAS 기반 CAS 기반 읽기는 락 없음, 쓰기는 RCU 메커니즘 주요 용도 동시성 캐시, 공유 데이터 저장 정렬된 데이터의 동시 접근 작업 큐, 버퍼 후입선출 데이터 관리 읽기가 빈번한 데이터 구조 성능 특성 읽기/쓰기 균형 로그 시간 복잡도 연산 높은 처리량 빠른 푸시/팝 연산 매우 빠른 읽기, 느린 쓰기 장점 높은 동시성, 확장성 효율적인 검색과 삽입 높은 동시성, 데드락 없음 단순한 구현, 높은 동시성 락 없는 읽기, 높은 확장성 단점 메모리 사용량 증가 구현 복잡도 높음 ABA 문제 가능성 ABA 문제, 제한된 확장성 복잡한 메모리 관리 메모리 사용 중간~높음 중간 낮음 낮음 높음 (여러 버전 유지) 구현 방식 버킷 배열, 연결 리스트/트리 계층화된 연결 리스트 연결 리스트, 원자적 포인터 연결 리스트, 원자적 포인터 버전 관리된 연결 리스트 특징 동적 크기 조정 확률적 밸런싱 대기 없는 연산 단순한 구조 읽기 최적화 구현 복잡도 중간 높음 중간 낮음 높음 확장성 매우 좋음 좋음 좋음 제한적 매우 좋음 (읽기) ABA 문제 해결됨 해결 필요 해결 필요 해결 필요 해결됨 순서 보장 보장 안 됨 정렬 순서 보장 FIFO 보장 LIFO 보장 보장 안 됨 사용 사례 데이터베이스, 캐시 시스템 정렬된 데이터 관리 작업 스케줄링, 이벤트 처리 메모리 할당자, 스택 추적 운영체제 커널, 네트워크 스택 참고 및 출처 ","wordCount":"383","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-06T12:55:00Z","dateModified":"2025-01-06T12:55:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/til/2025/01/concurrent-data-structure/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/>TIL</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2025/>2025</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/til/2025/01/>01</a></div><h1 class="post-title entry-hint-parent">Concurrent Data Structure</h1><div class=post-description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</div><div class=post-meta><span title='2025-01-06 12:55:00 +0000 UTC'>January 6, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;383 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#concurrent-data-structure>Concurrent Data Structure</a><ul><li><a href=#주요-특징>주요 특징</a></li><li><a href=#concurrent-data-structure-패턴-비교>Concurrent Data Structure 패턴 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=concurrent-data-structure>Concurrent Data Structure<a hidden class=anchor aria-hidden=true href=#concurrent-data-structure>#</a></h2><p>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조이다.<br>전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.<br>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계된 데이터 구조입니다.</p><p>Concurrent Data Structure는 일반적으로 다음과 같은 방식으로 구현된다:</p><ul><li>세밀한 락(fine-grained locking) 사용</li><li>락 없는(lock-free) 알고리즘</li><li>대기 없는(wait-free) 알고리즘</li><li>지연된 삭제와 메모리 재사용 기법</li></ul><p>이러한 구조는 고성능 멀티스레드 시스템, 데이터베이스, 운영체제, 네트워크 스택 등 다양한 분야에서 활용된다.</p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li>스레드 안전성: 여러 스레드가 동시에 접근해도 데이터의 일관성을 유지한다.</li><li>높은 동시성: 여러 스레드가 동시에 작업을 수행할 수 있어 성능이 향상된다.</li><li>락 최소화: 전체 구조에 대한 락 대신 세밀한 락이나 락 없는 기법을 사용한다.</li><li>확장성: 스레드 수가 증가해도 성능 저하가 적다.</li><li>원자적 연산: Compare-And-Swap(CAS)과 같은 원자적 연산을 활용한다.</li></ol><h3 id=concurrent-data-structure-패턴-비교>Concurrent Data Structure 패턴 비교<a hidden class=anchor aria-hidden=true href=#concurrent-data-structure-패턴-비교>#</a></h3><table><thead><tr><th>특성</th><th>Concurrent HashMap</th><th>Concurrent Skip List</th><th>Lock-free Queue</th><th>Lock-free Stack</th><th>Read-Copy-Update (RCU) List</th></tr></thead><tbody><tr><td>개념</td><td>동시에 여러 스레드가 접근 가능한 해시 기반 맵</td><td>동시성을 지원하는 계층화된 정렬 리스트</td><td>락 없이 동시 접근 가능한 FIFO 큐</td><td>락 없이 동시 접근 가능한 LIFO 스택</td><td>읽기에 최적화된 동시성 리스트</td></tr><tr><td>동기화 방식</td><td>세그먼트 락 또는 CAS</td><td>CAS 기반</td><td>CAS 기반</td><td>CAS 기반</td><td>읽기는 락 없음, 쓰기는 RCU 메커니즘</td></tr><tr><td>주요 용도</td><td>동시성 캐시, 공유 데이터 저장</td><td>정렬된 데이터의 동시 접근</td><td>작업 큐, 버퍼</td><td>후입선출 데이터 관리</td><td>읽기가 빈번한 데이터 구조</td></tr><tr><td>성능 특성</td><td>읽기/쓰기 균형</td><td>로그 시간 복잡도 연산</td><td>높은 처리량</td><td>빠른 푸시/팝 연산</td><td>매우 빠른 읽기, 느린 쓰기</td></tr><tr><td>장점</td><td>높은 동시성, 확장성</td><td>효율적인 검색과 삽입</td><td>높은 동시성, 데드락 없음</td><td>단순한 구현, 높은 동시성</td><td>락 없는 읽기, 높은 확장성</td></tr><tr><td>단점</td><td>메모리 사용량 증가</td><td>구현 복잡도 높음</td><td>ABA 문제 가능성</td><td>ABA 문제, 제한된 확장성</td><td>복잡한 메모리 관리</td></tr><tr><td>메모리 사용</td><td>중간~높음</td><td>중간</td><td>낮음</td><td>낮음</td><td>높음 (여러 버전 유지)</td></tr><tr><td>구현 방식</td><td>버킷 배열, 연결 리스트/트리</td><td>계층화된 연결 리스트</td><td>연결 리스트, 원자적 포인터</td><td>연결 리스트, 원자적 포인터</td><td>버전 관리된 연결 리스트</td></tr><tr><td>특징</td><td>동적 크기 조정</td><td>확률적 밸런싱</td><td>대기 없는 연산</td><td>단순한 구조</td><td>읽기 최적화</td></tr><tr><td>구현 복잡도</td><td>중간</td><td>높음</td><td>중간</td><td>낮음</td><td>높음</td></tr><tr><td>확장성</td><td>매우 좋음</td><td>좋음</td><td>좋음</td><td>제한적</td><td>매우 좋음 (읽기)</td></tr><tr><td>ABA 문제</td><td>해결됨</td><td>해결 필요</td><td>해결 필요</td><td>해결 필요</td><td>해결됨</td></tr><tr><td>순서 보장</td><td>보장 안 됨</td><td>정렬 순서 보장</td><td>FIFO 보장</td><td>LIFO 보장</td><td>보장 안 됨</td></tr><tr><td>사용 사례</td><td>데이터베이스, 캐시 시스템</td><td>정렬된 데이터 관리</td><td>작업 스케줄링, 이벤트 처리</td><td>메모리 할당자, 스택 추적</td><td>운영체제 커널, 네트워크 스택</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structure-and-algorithm/>Data-Structure-and-Algorithm</a></li><li><a href=https://buenhyden.github.io/tags/data-structure/>Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-primitive-data-structure/>Non-Primitive-Data-Structure</a></li><li><a href=https://buenhyden.github.io/tags/concurrent/>Concurrent</a></li><li><a href=https://buenhyden.github.io/tags/concurrent-hashmap/>Concurrent-HashMap</a></li><li><a href=https://buenhyden.github.io/tags/concurrent-skip-list/>Concurrent-Skip-List</a></li><li><a href=https://buenhyden.github.io/tags/lock-free-queue/>Lock-Free-Queue</a></li><li><a href=https://buenhyden.github.io/tags/lock-free-stack/>Lock-Free-Stack</a></li><li><a href=https://buenhyden.github.io/tags/read-copy-update-list/>Read-Copy-Update-List</a></li><li><a href=https://buenhyden.github.io/tags/rcu-list/>RCU-List</a></li></ul></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>