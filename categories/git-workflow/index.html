<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Workflow | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/git-workflow/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/git-workflow/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/git-workflow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/git-workflow/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git Workflow"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git Workflow"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Git Workflow</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Flow</h2></header><div class=entry-content><p>Git Flow Git Flow 는 Vincent Driessen 이 2010 년 제안한 Git 브랜치 관리 전략으로, 프로젝트의 개발, 릴리스, 유지보수를 효과적으로 수행할 수 있도록 고안되었다. 각 브랜치의 역할을 명확히 정의하여 협업과 코드 품질을 향상시킨다. 주요 브랜치로는 main, develop, feature, release, hotfix 가 있으며, 각 브랜치는 특정 목적에 따라 생성되고 병합된다.
핵심 개념 브랜치 기반의 워크플로우 모델로, 각 브랜치가 명확한 목적과 생명주기를 가지고 있다. 이를 통해 기능 개발, 릴리즈 준비, 버그 수정 등의 작업을 체계적으로 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/git-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Basic Commands</h2></header><div class=entry-content><p>Git Basic Commands Git Basic Commands는 버전 관리 시스템인 Git을 사용하기 위한 필수 명령어들의 집합입니다. 이 명령어들은 코드의 버전 관리, 협업, 이력 추적을 가능하게 하는 기본 도구이다. init, clone, add, commit, push, pull 등의 핵심 명령어들은 모든 Git 사용자가 일상적으로 사용하는 작업의 기반을 형성한다. 이러한 기본 명령어들을 이해하고 숙달하는 것은 효과적인 소프트웨어 개발과 팀 협업의 필수 요소이다.
핵심 개념 Git Basic Commands는 저장소 초기화, 변경사항 추적, 커밋 생성, 원격 저장소와의 동기화를 수행하는 기본 명령어들의 집합이다. 예를 들어, git add는 변경된 파일을 커밋 대상으로 지정하고, git commit은 실제로 변경 사항을 저장소에 기록한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:12:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Basic Commands" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/git-basic-commands/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitHub Flow</h2></header><div class=entry-content><p>GitHub Flow GitHub Flow는 GitHub에서 제안한 브랜치 전략으로, 메인 브랜치(main)와 기능 브랜치(feature)만을 사용하여 개발과 배포를 진행한다. 각 기능은 별도의 브랜치에서 개발되며, Pull Request를 통해 코드 리뷰와 테스트를 거친 후 메인 브랜치에 병합된다. 이러한 방식은 빠른 피드백과 지속적인 배포를 가능하게 한다.
Git Flow의 복잡성을 제거하고 웹 기반 애플리케이션 개발에 최적화된 워크플로우로, main 브랜치를 중심으로 기능 브랜치를 활용하여 빠른 개발 주기와 안정적인 배포를 동시에 달성할 수 있다.
핵심 개념 메인 브랜치(main): 항상 배포 가능한 상태를 유지하는 브랜치이다. 기능 브랜치(feature): 새로운 기능이나 수정 사항을 개발하는 브랜치로, 작업 완료 후 Pull Request를 통해 메인 브랜치에 병합된다. 모든 작업은 설명적인 이름의 기능 브랜치에서 수행한다.
정기적인 커밋과 원격 저장소 푸시
승인 후 즉시 main 브랜치에 병합되며 즉시 배포된다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitHub Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/github-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GitLab Flow</h2></header><div class=entry-content><p>GitLab Flow GitLab Flow는 GitLab에서 제안한 브랜치 전략으로, 기능 중심 개발과 이슈 추적을 통합하여 소프트웨어 개발을 간소화한다. 이는 GitFlow의 복잡성을 줄이고, GitHub Flow의 단순함을 유지하면서도 다양한 배포 환경을 지원하는 유연성을 제공한다.
핵심 개념 GitLab Flow의 핵심 개념은 다음과 같다:
업스트림 퍼스트(Upstream First): 항상 상위 환경으로 먼저 병합하는 원칙 이슈 추적 통합: GitLab 이슈와 머지 리퀘스트(MR)의 긴밀한 연계 상황별 워크플로우: 프로젝트 특성에 따라 선택 가능한 세 가지 모델 메인 브랜치: main: 배포 가능한 코드 보유. 환경 브랜치: 개발, 스테이징, 프로덕션 등 각 배포 환경에 대응하는 장수 브랜치 staging, pre-prod, production: 단계별 테스트 및 배포. 기능 브랜치: 새로운 기능 개발을 위한 단기 브랜치 feature/*: 기능 개발 후 main에 병합. 풀 리퀘스트: 코드 리뷰 및 병합 프로세스. graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|병합| staging[staging] staging -->|병합| pre-prod[pre-prod] pre-prod -->|병합| production[production] ▲ GitLab Flow 환경 브랜치 워크플로우[3][6]
https://www.linkedin.com/pulse/gitlab-flow-jadson-santos
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitLab Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/gitlab-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Branching and Merging</h2></header><div class=entry-content><p>Branching and Merging Branching and Merging은 Git 과 같은 분산 버전 관리 시스템에서 핵심적인 기능이다. 브랜칭은 독립적인 작업 공간을 생성하여 여러 개발자가 동시에 작업할 수 있게 하며, 머징은 이러한 작업 결과를 하나의 코드베이스로 통합한다. 이를 통해 병렬 개발, 기능 분리, 코드 안정성 유지 등이 가능해진다. Git, SVN, Mercurial 등 다양한 버전 관리 시스템에서 지원되며, 현대 소프트웨어 개발의 필수 요소이다.
핵심 개념 Branching (브랜칭): 코드베이스의 복사본 생성으로 기능 개발/버그 수정을 격리한다. Merging (머징): 분리된 변경 사항을 메인 코드베이스에 통합하는 과정이다. HEAD: 현재 작업 중인 브랜치의 최신 커밋을 가리키는 포인터이다. graph TD main[main] -->|분기| feature[feature/login] feature -->|머지| main main -->|배포| Production 목적 병렬 개발 환경 제공 코드 충돌 최소화 기능별/작업별 독립적 개발 지원 안정적인 배포 프로세스 구축 필요성 다수의 개발자가 동시에 작업하는 환경에서 협업 효율성 증대 프로덕션 코드의 안정성 보장 실험적 기능 개발과 버그 수정의 분리 코드 리뷰와 품질 관리 용이성 주요 기능 브랜치 생성/삭제 브랜치 전환 (Checkout) 코드 병합 (Merge) 리베이스 (Rebase) 충돌 해결 (Conflict Resolution) 특징 분산형 개발 지원 비선형적 개발 이력 관리 원격 저장소와의 동기화 다양한 병합 전략 제공 장점과 단점 구분 항목 설명 ✅ 장점 병렬 개발 여러 기능을 동시에 개발 가능 안정성 메인 브랜치의 안정성 유지 실험 용이성 실험적 기능을 안전하게 테스트 롤백 용이성 문제 발생 시 쉽게 이전 상태로 복구 ⚠ 단점 복잡성 브랜치가 많아지면 관리가 복잡 충돌 발생 병합 시 코드 충돌 가능성 학습 곡선 초보자에게 어려운 개념 리소스 사용 브랜치별 리소스 사용량 증가 주요 원리 구성 요소 기능 역할 HEAD 현재 브랜치 참조 현재 작업 중인 브랜치를 가리킴 Branch Pointer 커밋 참조 특정 커밋을 가리키는 포인터 Commit Object 변경사항 저장 코드 변경 내용과 메타데이터 저장 Tree Object 디렉토리 구조 파일과 디렉토리 구조 표현 Merge Base 공통 조상 커밋 브랜치 분기점 식별 Branching 브랜칭의 주요 원리는 포인터 기반의 참조 시스템이다:
...</p></div><footer class=entry-footer><span title='2024-09-28 09:56:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching and Merging" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/branching-and-merging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Trunk-based Development</h2></header><div class=entry-content><p>Trunk-based Development Trunk-based Development(TBD)는 모든 개발자가 단일 메인 브랜치(trunk)에 작고 빈번한 변경사항을 직접 통합하는 버전 관리 방법론이다. 이는 지속적 통합(CI)과 지속적 배포(CD)의 필수 전제조건으로, 현대 DevOps 환경에서 가장 효율적인 브랜치 전략으로 인정받고 있다. 긴 수명의 기능 브랜치 대신 짧은 수명의 브랜치나 직접 커밋을 통해 코드 통합의 마찰을 최소화하고, 항상 배포 가능한 상태의 코드베이스를 유지하는 것이 핵심이다.
핵심 개념 Trunk-based Development의 핵심 개념은 다음과 같다:
단일 메인 브랜치: 모든 개발이 하나의 trunk(main/master) 브랜치에 집중 작고 빈번한 커밋: 작업을 작은 단위로 나누어 자주 통합 짧은 수명의 브랜치: 필요한 경우 최대 1-2일 이내의 피처 브랜치 사용 지속적 통합: 하루에 여러 번 코드 통합 및 자동화된 테스트 항상 릴리스 가능한 상태: trunk는 언제나 프로덕션 배포가 가능한 상태 유지 피처 플래그: 미완성 기능을 main에 통합하되 런타임에 비활성화 graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|자동 배포| Production 목적 코드 통합의 복잡성과 병합 충돌 최소화 개발 및 배포 속도 극대화 지속적 통합/배포(CI/CD) 실현 팀 협업 효율성 향상 코드베이스의 일관성과 품질 유지 빠른 피드백 사이클 구현 필요성 현대 DevOps 및 애자일 개발 방법론의 요구사항 충족 마이크로서비스 아키텍처에서의 빠른 배포 필요 대규모 개발팀의 효율적인 협업 지원 병합 지옥(merge hell) 방지 지속적 배포를 통한 경쟁력 확보 고품질 소프트웨어의 빠른 출시 요구 역할 개발 프로세스 단순화: 복잡한 브랜치 모델 제거 배포 주기 가속화: 빠른 릴리스 사이클 지원 품질 보증: 지속적인 테스트를 통한 품질 유지 팀 협업 강화: 코드 리뷰와 페어 프로그래밍 촉진 기술 부채 방지: 장기 브랜치로 인한 기술 부채 최소화 특징 브랜치 최소화 통합의 빈도 극대화 Feature Toggle 사용 권장 Conflict를 예방하는 설계 주요 기능 직접 trunk 커밋: 소규모 팀의 경우 trunk에 직접 커밋 Pull Request 워크플로우: 코드 리뷰를 위한 짧은 수명의 브랜치 자동화된 테스트: 모든 커밋에 대한 자동 테스트 실행 피처 플래그: 기능의 점진적 롤아웃 지원 지속적 통합: 자동화된 빌드 및 테스트 파이프라인 브랜치별 CI: PR/브랜치 단위 자동화 검증 주요 원리 Trunk-based Development의 주요 원리는 다음 다이어그램으로 표현할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trunk-based Development" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/trunk-based-development/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git Submodule vs. Subtree</h2></header><div class=entry-content><p>Git Submodule vs. Subtree 깃 (Git) 은 소프트웨어 개발에서 널리 사용되는 분산형 버전 관리 시스템으로, 복잡한 프로젝트를 효율적으로 관리할 수 있게 해준다. 대규모 프로젝트에서는 종종 여러 저장소 (repository) 에 분산된 코드를 하나의 프로젝트 내에서 통합해야 하는 필요성이 생긴다. 이러한 필요성을 해결하기 위해 깃은 두 가지 주요 접근 방식인 서브모듈 (Submodule) 과 서브트리 (Subtree) 를 제공한다.
Git Submodule 과 Git Subtree 는 모두 하나의 Git 프로젝트 안에서 다른 Git 저장소를 하위 프로젝트처럼 관리하기 위한 방식이다. 하지만 방법은 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Submodule vs. Subtree" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Conflict Resolution</h2></header><div class=entry-content><p>Conflict Resolution Git 충돌 해결 (Conflict Resolution) 은 협업 개발 과정에서 발생하는 코드 충돌을 식별하고 해결하는 프로세스로, 3-way merge 알고리즘을 기반으로 한다. 여러 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고, 해결하는 전략과 도구, 워크플로우를 포함한다. 주요 단계는 충돌 탐지 → 수동/자동 해결 → 검증으로 구성되며, 최근 AI 기반 자동화 도구들이 주목받고 있다.
핵심 개념 Git 충돌 해결 (Conflict Resolution) 은 두 개 이상의 개발자가 동일한 파일의 동일한 부분을 수정할 때 발생하는 충돌을 식별하고 해결하는 과정이다. 충돌은 Git 이 변경사항을 자동으로 병합할 수 없을 때 발생하며, 개발자가 수동으로 어떤 변경사항을 유지할지 결정해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:57:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Conflict Resolution" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/conflict-resolution/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>