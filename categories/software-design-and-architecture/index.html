<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design and Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design and Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design and Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design and Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;738 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;626 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/til/2024/09/27/software-architecture-pattern-vs-software-design-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/til/2024/09/25/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멀티 테넌시(Multi-tenancy)</h2></header><div class=entry-content><p>멀티 테넌시(Multi-tenancy) 멀티 테넌시(Multi-tenancy)는 소프트웨어 아키텍처의 한 형태로, 단일 소프트웨어 인스턴스가 여러 사용자 그룹(테넌트)에게 서비스를 제공하는 구조를 말한다. 즉, 하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.
각 테넌트는 공통 인프라를 공유하면서도 자신만의 독립된 환경을 가진 것처럼 작동한다.
주요 특징:
단일 인스턴스로 여러 사용자 그룹 서비스 데이터와 구성의 논리적 분리 각 테넌트에 대한 개별화된 사용자 경험 제공 https://www.linkedin.com/pulse/saas-architecture-right-way-sk-reddy-2ozuc/
멀티 테넌시의 유형 멀티 테넌시는 다양한 형태로 구현될 수 있다:
단일 인스턴스, 단일 데이터베이스: 모든 테넌트가 동일한 애플리케이션 인스턴스와 데이터베이스를 공유한다. 비용 효율적이지만 확장성에 제한이 있을 수 있다. 단일 인스턴스, 다중 데이터베이스: 애플리케이션 인스턴스는 공유하지만 각 테넌트가 별도의 데이터베이스를 가진다. 데이터 격리 수준이 높아진다. 다중 인스턴스, 다중 데이터베이스: 각 테넌트가 독립된 애플리케이션 인스턴스와 데이터베이스를 가진다. 가장 높은 수준의 격리를 제공하지만 비용이 증가한다. 멀티 테넌시의 장점 비용 효율성: 인프라와 리소스를 공유함으로써 개발, 유지보수, 운영 비용을 절감할 수 있다. 효율적인 리소스 관리: 여러 고객이 동일한 인프라를 공유하므로 리소스 활용도가 높아진다. 간편한 업데이트와 유지보수: 단일 인스턴스를 업데이트하면 모든 테넌트에게 동시에 적용되어 관리가 용이하다. 확장성: 사용자 수나 데이터 양이 증가할 때 쉽게 확장할 수 있다. 데이터 통합 용이성: 모든 테넌트의 데이터가 중앙 집중화되어 있어 분석과 인사이트 도출이 용이하다. 멀티 테넌시의 단점과 과제 보안과 데이터 격리: 여러 테넌트의 데이터가 공존하므로 데이터 유출 위험이 있다. 철저한 보안 조치가 필요하다. 복잡한 아키텍처: 개인화와 데이터 격리를 위해 복잡한 설계가 필요하다. 성능 관리: 한 테넌트의 과도한 리소스 사용이 다른 테넌트에게 영향을 줄 수 있다. 규정 준수: 다양한 테넌트의 데이터를 처리할 때 각종 법적 규정과 프라이버시 요구사항을 준수해야 한다. 커스터마이징의 한계: 각 테넌트별로 세부적인 커스터마이징에 제한이 있을 수 있다. 멀티 테넌시 구현 시 고려사항 데이터 모델 설계: 테넌트 간 데이터 격리를 위한 효과적인 데이터 모델 설계가 필요하다. 보안 메커니즘: 강력한 인증, 권한 부여, 암호화 등의 보안 메커니즘 구현이 중요하다. 확장성 계획: 테넌트 수와 데이터 양 증가에 대비한 확장 계획을 수립해야 한다. 성능 모니터링: 각 테넌트의 리소스 사용량을 모니터링하고 최적화하는 시스템이 필요하다. 백업 및 복구 전략: 테넌트별 데이터 백업 및 복구 전략을 수립해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 14:06:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멀티 테넌시(Multi-tenancy)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serverless Architecture</h2></header><div class=entry-content><p>Serverless Architecture Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.
Serverless Architecture는 빠른 개발 속도와 비용 효율성으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;691 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/serverless-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Publisher-Subscriber Pattern</h2></header><div class=entry-content><p>Publisher-Subscriber Pattern Publisher-Subscriber Pattern(게시자-구독자 패턴)은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 분산 시스템에서 비동기 통신을 구현하는 데 널리 사용된다.
이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.
이 패턴은 컴포넌트 간의 느슨한 결합을 제공하여 확장성과 유연성을 높이는 데 기여한다.
https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber
기본 개념 Publisher-Subscriber 패턴의 핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:40:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publisher-Subscriber Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.
네트워크 불안정, 일시적인 서비스 중단 등 일시적인 실패 상황에서 시스템의 복원력(Resilience)을 강화하는 데 목적을 둔다.
이 패턴은 분산 시스템의 안정성을 높이는 필수 도구이지만, 남용할 경우 역효과를 낼 수 있으므로 신중한 정책 수립이 필요하다.
Retry Pattern의 핵심 개념 작동 원리
실패한 작업 자동 재시도: API 호출, 데이터베이스 접근 등 실패 가능성이 있는 작업을 정의된 정책에 따라 재시도한다. 일시적 오류 감지: 네트워크 타임아웃, HTTP 5xx 에러, 데이터베이스 연결 실패 등 일시적인 오류만 대상으로 한다. 주요 구성 요소
...</p></div><footer class=entry-footer><span title='2024-09-27 11:31:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/retry-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model-View-ViewModel Pattern</h2></header><div class=entry-content><p>Model-View-ViewModel Pattern MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.
이 패턴은 MVC(Model-View-Controller) 패턴의 발전된 형태로 볼 수 있다.
MVVM 패턴은 복잡한 UI 애플리케이션 개발에 특히 유용하며, 대규모 프로젝트에서 코드의 구조화와 관리를 용이하게 한다.
https://learn.microsoft.com/ko-kr/dotnet/architecture/maui/mvvm
MVVM의 구성 요소 MVVM 패턴은 세 가지 주요 구성 요소로 이루어져 있다:
모델(Model): 데이터와 비즈니스 로직을 담당한다. 데이터베이스나 웹 서비스와의 통신을 통해 데이터를 가져오거나 저장하는 역할을 한다. 뷰(View): 사용자 인터페이스(UI)를 담당한다. 데이터를 표시하고 사용자 입력을 받아 ViewModel에 전달한다. 버튼, 텍스트 박스 등 화면에 표시되는 모든 요소를 포함하며, 사용자와의 상호작용을 처리한다. 뷰모델(ViewModel): 뷰와 모델 사이의 중재자 역할을 한다. 뷰에서 보여지는 데이터와 이를 조작하는 메서드, 상태를 포함한다. MVVM의 핵심 개념 데이터 바인딩: MVVM의 핵심 아이디어는 뷰와 뷰모델 사이에 양방향 데이터 바인딩을 통해 자동 업데이트를 가능하게 하는 것이다. 이를 통해 뷰와 뷰모델 사이의 데이터 동기화가 자동으로 이루어진다. 명령(Command): 버튼 클릭과 같은 사용자 액션을 뷰모델에서 처리하기 위한 메커니즘이다. 뷰모델은 ICommand 인터페이스를 구현하여 뷰에서 발생하는 이벤트를 처리한다. 의존성 관리: 뷰모델을 중재자로 사용하여 뷰와 모델 사이의 의존성을 해결한다. 이로 인해 뷰와 모델의 결합도가 낮아진다. 테스트 용이성: 뷰와 모델이 분리되어 있어 각 구성 요소를 독립적으로 테스트하기 쉽다. MVVM의 장점 유지보수성 향상: UI와 비즈니스 로직이 분리되어 있어 코드의 유지보수가 용이하다. 재사용성 증가: 뷰모델은 여러 뷰에서 재사용될 수 있다. 자동 업데이트: 데이터 바인딩을 통해 뷰모델의 상태 변화가 자동으로 UI에 반영된다. 개발 효율성: 개발자는 데이터 변경에 직접 관여하지 않고, 뷰모델을 통해 데이터를 조작하고 업데이트할 수 있어 코드의 복잡성이 줄어든다. MVVM 구현 예시 다음은 간단한 카운터 애플리케이션의 MVVM 구현 예시
...</p></div><footer class=entry-footer><span title='2024-09-27 11:26:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;518 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model-View-ViewModel Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/software-design-and-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>