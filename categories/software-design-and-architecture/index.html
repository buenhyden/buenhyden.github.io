<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design and Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design and Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design and Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design and Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern vs. MVVC Pattern vs. MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Design Patterns</h2></header><div class=entry-content><p>Software Design Patterns 소프트웨어 디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제들에 대한 일반적이고 재사용 가능한 해결책이다.
이는 코드의 품질을 향상시키고 유지보수를 용이하게 만드는 중요한 도구이다.
디자인 패턴을 효과적으로 사용하려면 지속적인 학습과 실제 프로젝트에서의 적용 경험이 필요하다.
각 패턴의 장단점을 이해하고, 적절한 상황에서 올바르게 적용하는 것이 중요하다. 이를 통해 더 유연하고 유지보수가 용이한 소프트웨어를 설계할 수 있다.
디자인 패턴의 목적 코드 재사용성 향상: 검증된 해결책을 제공하여 개발 시간을 단축시킨다. 유지보수성 개선: 표준화된 방식으로 문제를 해결하여 코드의 이해와 수정을 쉽게 만든다. 확장성 증대: 기존 코드의 변경 없이 새로운 기능을 추가할 수 있게 한다. 복잡성 관리: 복잡한 시스템을 구조화하여 관리하기 쉽게 만든다. 디자인 패턴의 종류 디자인 패턴은 주로 세 가지 카테고리로 분류된다:
...</p></div><footer class=entry-footer><span title='2024-09-25 07:57:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/__index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/software-architecture-pattern-vs-software-design-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns vs. Creational Design Patterns vs. Structural Design Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hollywood Principle</h2></header><div class=entry-content><p>Hollywood Principle 할리우드 원칙은 “먼저 연락하지 마세요. 저희가 연락드리겠습니다(Don’t call us, we’ll call you)“라는 문구에서 이름을 따온 소프트웨어 설계 원칙이다.
이 표현은 할리우드 오디션에서 배우들에게 자주 하던 말에서 유래했다. 소프트웨어 설계에서 이 원칙은 제어 흐름의 역전을 의미하며, 고수준 컴포넌트가 저수준 컴포넌트를 직접 호출하는 대신, 상위 수준의 컴포넌트가 하위 수준의 컴포넌트를 직접 호출하지 않고, 추상화된 인터페이스를 통해 상호작용하도록 하는 구조를 만드는 것을 권장한다.
이 원칙은 템플릿 메서드, 옵저버, 의존성 주입과 같은 다양한 디자인 패턴의 기반이 되며, 현대적인 프레임워크와 리액티브 프로그래밍, 함수형 프로그래밍에서도 널리 활용된다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hollywood Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/hollywood-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Program Against Abstractions</h2></header><div class=entry-content><p>Program Against Abstractions “추상화에 대한 프로그래밍”(Program Against Abstractions)은 소프트웨어 설계의 핵심 원칙으로, 구체적인 구현보다는 추상적인 인터페이스나 기본 타입에 의존하여 코드를 작성해야 한다는 개념이다.
이 원칙은 “구현이 아닌 인터페이스에 대해 프로그래밍하라”(Program to an Interface, Not an Implementation)라는 표현으로도 널리 알려져 있다.
이 원칙의 핵심은 코드가 특정 구현의 세부 사항에 의존하는 대신 더 일반적이고 안정적인 추상화에 의존해야 한다는 것이다. 이를 통해 시스템은 더 유연해지고, 변경에 더 견고해지며, 재사용성이 향상된다.
“추상화에 대한 프로그래밍"은 소프트웨어 설계에서 중요한 원칙이다.
이 원칙을 따르면 코드의 결합도가 낮아지고, 유연성이 증가하며, 테스트와 유지 관리가 더 쉬워진다. 이 원칙은 SOLID 원칙, 디자인 패턴, 그리고 현대적인 소프트웨어 아키텍처의 많은 측면과 밀접하게 연관되어 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Program Against Abstractions" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/program-against-abstractions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Composition Over Inheritance</h2></header><div class=entry-content><p>Composition Over Inheritance 객체지향 프로그래밍에서 코드 재사용과 모듈화를 위한 두 가지 주요 방법이 있다: 상속(inheritance)과 합성(composition).
‘합성 우선 상속’ 원칙은 많은 경우에 상속보다 객체 합성을 선호해야 한다는 설계 지침이다. 이 원칙은 객체지향 설계의 유연성, 유지보수성, 확장성을 높이는 데 중요한 역할을 한다.
Composition Over Inheritance는 객체지향 설계에서 유연성과 유지보수성을 극대화할 수 있다.
상속 대신 객체 조합(Composition)을 우선시함으로써, 시스템의 복잡성을 관리하고 변화에 대응하기 용이한 설계를 가능하게 한다.
그러나 모든 설계 결정과 마찬가지로, 합성과 상속 중 어떤 것을 선택할지는 특정 맥락과 요구사항에 따라 달라진다. 진정한 “is-a” 관계가 있거나 다형성이 주요 목표인 경우에는 상속이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composition Over Inheritance" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/composition-over-inheritance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Encapsulate What Varies</h2></header><div class=entry-content><p>Encapsulate What Varies 소프트웨어 설계에서 “가변성 캡슐화(Encapsulate What Varies)” 원칙은 변경 가능성이 높은 부분을 식별하고 이를 캡슐화하여 나머지 코드에 미치는 영향을 최소화하는 접근 방식이다. 이 원칙은 객체지향 설계의 기본 개념 중 하나로, 유지보수성, 확장성, 재사용성을 높이는 데 중요한 역할을 한다.
원칙의 정의와 목적 “가변성 캡슐화” 원칙은 간단히 말해 “변화하는 것을 캡슐화하라"는 지침입니다. 이는 소프트웨어에서 변경될 가능성이 높은 부분을 식별하고, 그것을 나머지 시스템으로부터 분리하여 향후 변경이 시스템 전체에 미치는 영향을 최소화하는 것을 의미한다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulate What Varies" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/encapsulate-what-varies/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/software-design-and-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>