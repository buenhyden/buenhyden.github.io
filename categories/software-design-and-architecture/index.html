<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design and Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design and Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design and Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design and Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>클린 코드 (Clean Code)</h2></header><div class=entry-content><p>클린 코드 (Clean Code) 프로그램의 동작을 보장하면서도 가독성이 뛰어나고 유지보수가 쉬운 코드를 의미한다.
코드의 품질을 향상시켜 개발 속도를 높이고, 버그를 줄이며, 팀 내 협업을 원활하게 한다.
Robert C. Martin(일명 Uncle Bob)이 2008년에 출간한 “Clean Code: A Handbook of Agile Software Craftsmanship” 책을 통해 널리 알려졌다.
Clean Code의 중요성 가독성과 유지보수성 향상: 깨끗한 코드는 다른 개발자들이 쉽게 이해하고 수정할 수 있게 한다. 팀 협업 개선: 일관된 코딩 표준을 따르면 팀원 간 의사소통과 협업이 더 원활해진다. 디버깅과 문제 해결 용이: 명확하고 단순한 구조는 이슈를 더 쉽게 찾고 해결할 수 있게 한다. 코드 품질과 신뢰성 향상: 잘 구조화된 코드는 오류 발생 위험을 줄이고 더 높은 품질의 소프트웨어로 이어진다. 클린 코드를 작성하기 위한 주요 원칙 의미 있는 이름 사용 변수, 함수, 클래스 등의 이름은 그 목적과 기능을 명확히 나타내야 한다.
일관된 명명 규칙을 적용하고, 약어 사용은 자제한다.
...</p></div><footer class=entry-footer><span title='2024-09-19 05:44:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1710 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 클린 코드 (Clean Code)" href=https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern Vs MVVC Pattern Vs MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 1 2 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;586 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/til/2024/09/27/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;738 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Architecture Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;626 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/software-architecture-pattern-vs-software-design-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Twelve-Factor App methodology</h2></header><div class=entry-content><p>Twelve-Factor App Methodology 클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시한다.
12-Factor App 방법론은 다른 개발 방법론과 비교하여 다음과 같은 점에서 차별화된다:
클라우드 네이티브 애플리케이션에 최적화
12-Factor App 방법론은 클라우드 환경에서 실행되는 SaaS(Software-as-a-Service) 애플리케이션 개발에 특화되어 있다.
이는 클라우드의 확장성, 이식성, 배포 용이성을 최대한 활용할 수 있도록 설계되었다. 명확한 12가지 원칙 제시
다른 방법론들이 보다 광범위한 원칙을 제시하는 반면, 12-Factor App은 12가지 구체적인 원칙을 명확하게 정의한다. 이를 통해 개발자들은 실제 구현 시 명확한 가이드라인을 따를 수 있다. 환경 독립성 강조
12-Factor App은 코드베이스와 설정의 분리, 환경 간 격차 최소화 등을 통해 애플리케이션이 다양한 환경에서 일관되게 동작할 수 있도록 한다. 이는 개발, 스테이징, 프로덕션 환경 간의 차이를 최소화하여 배포 과정의 안정성을 높인다. 확장성과 유지보수성 중시
백엔드 서비스 분리, 프로세스 모델 적용, 포트 바인딩 등의 원칙을 통해 애플리케이션의 확장성과 유지보수성을 향상시킨다. 이는 대규모 시스템에서 특히 중요한 요소이다. 현대적인 개발 및 운영 관행 반영
지속적인 배포, 로그 처리, 관리 프로세스 등에 대한 원칙을 통해 현대적인 DevOps 관행을 자연스럽게 도입할 수 있도록 한다. 이는 애자일 방법론이나 DevOps와 잘 어울리면서도, 보다 구체적인 실천 방안을 제시한다. 12 Factors Codebase (코드베이스) 하나의 코드베이스를 버전 관리하고, 다양한 배포에 활용한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 01:40:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1170 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Twelve-Factor App methodology" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멀티 테넌시(Multi-tenancy)</h2></header><div class=entry-content><p>멀티 테넌시(Multi-tenancy) 멀티 테넌시(Multi-tenancy)는 소프트웨어 아키텍처의 한 형태로, 단일 소프트웨어 인스턴스가 여러 사용자 그룹(테넌트)에게 서비스를 제공하는 구조를 말한다. 즉, 하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.
각 테넌트는 공통 인프라를 공유하면서도 자신만의 독립된 환경을 가진 것처럼 작동한다.
주요 특징:
단일 인스턴스로 여러 사용자 그룹 서비스 데이터와 구성의 논리적 분리 각 테넌트에 대한 개별화된 사용자 경험 제공 https://www.linkedin.com/pulse/saas-architecture-right-way-sk-reddy-2ozuc/
멀티 테넌시의 유형 멀티 테넌시는 다양한 형태로 구현될 수 있다:
단일 인스턴스, 단일 데이터베이스: 모든 테넌트가 동일한 애플리케이션 인스턴스와 데이터베이스를 공유한다. 비용 효율적이지만 확장성에 제한이 있을 수 있다. 단일 인스턴스, 다중 데이터베이스: 애플리케이션 인스턴스는 공유하지만 각 테넌트가 별도의 데이터베이스를 가진다. 데이터 격리 수준이 높아진다. 다중 인스턴스, 다중 데이터베이스: 각 테넌트가 독립된 애플리케이션 인스턴스와 데이터베이스를 가진다. 가장 높은 수준의 격리를 제공하지만 비용이 증가한다. 멀티 테넌시의 장점 비용 효율성: 인프라와 리소스를 공유함으로써 개발, 유지보수, 운영 비용을 절감할 수 있다. 효율적인 리소스 관리: 여러 고객이 동일한 인프라를 공유하므로 리소스 활용도가 높아진다. 간편한 업데이트와 유지보수: 단일 인스턴스를 업데이트하면 모든 테넌트에게 동시에 적용되어 관리가 용이하다. 확장성: 사용자 수나 데이터 양이 증가할 때 쉽게 확장할 수 있다. 데이터 통합 용이성: 모든 테넌트의 데이터가 중앙 집중화되어 있어 분석과 인사이트 도출이 용이하다. 멀티 테넌시의 단점과 과제 보안과 데이터 격리: 여러 테넌트의 데이터가 공존하므로 데이터 유출 위험이 있다. 철저한 보안 조치가 필요하다. 복잡한 아키텍처: 개인화와 데이터 격리를 위해 복잡한 설계가 필요하다. 성능 관리: 한 테넌트의 과도한 리소스 사용이 다른 테넌트에게 영향을 줄 수 있다. 규정 준수: 다양한 테넌트의 데이터를 처리할 때 각종 법적 규정과 프라이버시 요구사항을 준수해야 한다. 커스터마이징의 한계: 각 테넌트별로 세부적인 커스터마이징에 제한이 있을 수 있다. 멀티 테넌시 구현 시 고려사항 데이터 모델 설계: 테넌트 간 데이터 격리를 위한 효과적인 데이터 모델 설계가 필요하다. 보안 메커니즘: 강력한 인증, 권한 부여, 암호화 등의 보안 메커니즘 구현이 중요하다. 확장성 계획: 테넌트 수와 데이터 양 증가에 대비한 확장 계획을 수립해야 한다. 성능 모니터링: 각 테넌트의 리소스 사용량을 모니터링하고 최적화하는 시스템이 필요하다. 백업 및 복구 전략: 테넌트별 데이터 백업 및 복구 전략을 수립해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 14:06:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멀티 테넌시(Multi-tenancy)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serverless Architecture</h2></header><div class=entry-content><p>Serverless Architecture Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.
Serverless Architecture는 빠른 개발 속도와 비용 효율성으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;691 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless Architecture" href=https://buenhyden.github.io/posts/devops/serverless/serverless-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/software-design-and-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>