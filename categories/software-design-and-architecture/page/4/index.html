<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design and Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design and Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design and Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design and Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Bus Pattern</h2></header><div class=entry-content><p>Event-Bus Pattern 소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴이다.
이 패턴은 발행-구독(Publish-Subscribe) 모델을 기반으로 하며, 컴포넌트 간의 느슨한 결합을 촉진한다.
장점 느슨한 결합: 컴포넌트 간 직접적인 의존성이 줄어들어 시스템의 유연성이 향상된다. 확장성: 새로운 컴포넌트를 쉽게 추가하거나 제거할 수 있어 시스템 확장이 용이한다. 비동기 통신: 이벤트 기반의 비동기 통신으로 시스템의 반응성과 성능이 향상된다. 단순화된 통신: 복잡한 컴포넌트 간 통신 로직을 단순화할 수 있다. 단점 복잡성 증가: 시스템 전체의 흐름을 파악하기 어려울 수 있다. 메모리 사용 증가: 모든 구독자에게 이벤트가 전달되므로 메모리 사용량이 증가할 수 있다. 디버깅의 어려움: 비동기적 특성으로 인해 문제 추적이 어려울 수 있다. 핵심 구성요소 https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5 Event Bus with multiple subscribers(green arrows) and notifiers(red arrows)
...</p></div><footer class=entry-footer><span title='2024-09-26 08:28:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Bus Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Client-Server Pattern</h2></header><div class=entry-content><p>Client-Server Pattern 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나눈다:
서비스를 제공하는 서버 서비스를 요청하는 클라이언트.
이들은 네트워크를 통해 서로 통신하며, 각자 명확한 역할과 책임을 가지고 있다. 클라이언트-서버 패턴 (Client-Server Pattern) 클라이언트-서버 패턴은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴이다.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나뉜다:
서비스를 제공하는 서버와 서비스를 요청하는 클라이언트이다.
주요 구성 요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
클라이언트 (Client):
...</p></div><footer class=entry-footer><span title='2024-09-26 08:27:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;264 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-Server Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/client-server-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Layered Pattern</h2></header><div class=entry-content><p>Layered Pattern 레이어드 패턴(Layered Pattern)은 소프트웨어 아키텍처에서 가장 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 구성 요소를 수평적 계층으로 조직화하여 각 계층이 특정 기능을 담당하도록 한다.
주요 계층의 역할과 책임 &lt;https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
일반적으로 레이어드 아키텍처는 다음과 같은 4개의 표준 계층으로 구성된다:
프레젠테이션 계층 (Presentation Layer): 사용자 또는 외부 시스템과의 상호작용을 담당합니다 입력 데이터의 기본적인 유효성 검사를 수행합니다 응답 데이터를 적절한 형식으로 변환합니다 REST API, 웹 인터페이스, CLI 등의 형태로 구현될 수 있습니다 비즈니스 계층 (Business Layer): 핵심 비즈니스 로직을 구현합니다 트랜잭션 관리를 담당합니다 도메인 객체들의 상태를 조작합니다 비즈니스 규칙을 검증합니다 도메인 계층 (Domain Layer): 비즈니스 도메인의 핵심 개념을 표현합니다 도메인 객체들의 상태와 행위를 정의합니다 비즈니스 규칙을 캡슐화합니다 특정 기술에 독립적입니다 데이터 접근 계층 (Data Access Layer): 데이터의 영속성을 관리합니다 데이터베이스나 외부 시스템과의 통신을 담당합니다 CRUD 작업을 추상화합니다 데이터 매핑을 처리합니다 작은 애플리케이션의 경우 3개 계층으로, 복잡한 애플리케이션은 5개 이상의 계층으로 구성될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-26 08:26:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;997 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Layered Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/layered-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로그램 설계 방법론</h2></header><div class=entry-content><p>프로그램 설계 방법론 소프트웨어 개발 과정에서 시스템을 구조화하고 모듈화하는 체계적인 접근 방식.
이는 소프트웨어의 품질, 유지보수성, 확장성을 향상시키는 데 중요한 역할을 한다.
주요 특징 체계적인 접근: 명확한 단계와 프로세스를 제공. 문서화: 설계 결정과 프로세스를 문서화하여 팀 내 의사소통을 개선. 재사용성: 코드와 설계 요소의 재사용을 촉진. 유지보수성: 시스템의 장기적인 유지보수와 진화를 고려. 품질 향상: 체계적인 접근을 통해 소프트웨어의 전반적인 품질을 향상. 주요 설계 방법론 구조적 설계 (Structured Design) 구조적 설계는 복잡한 시스템을 더 작고 관리하기 쉬운 모듈로 분해하는 접근 방식.
순차, 선택, 반복 구조를 기본으로 한다.
...</p></div><footer class=entry-footer><span title='2024-09-24 05:52:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2966 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로그램 설계 방법론" href=https://buenhyden.github.io/til/2024/09/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95%EB%A1%A0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 시스템이나 코드의 복잡성을 최소화하라.
잘못된 예 1 2 3 4 5 6 def complex_calculation(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z): # 너무 많은 파라미터와 복잡한 로직이 포함되어 있음 result = a + b - c * d / e + f - g + h + i - j + k * l / m - n + o - p + q + r - s + t + u - v + w - x + y - z return result # 주석: 함수가 너무 복잡하고 많은 파라미터를 사용하여 KISS를 위반합니다. 잘된 예 1 2 3 4 5 def simple_calculation(a,b,c): result = a + b - c return result # 주석: 필요한 최소한의 파라미터와 간단한 로직으로 KISS를 준수합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;123 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle 당장 필요하지 않은 기능을 미리 구현하지 마라.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.loyalty_points = 0 # 아직 사용하지 않는 기능 def upgrade_to_premium(self): self.premium_member = True def add_loyalty_points(self, points): # 아직 사용하지 않는 기능 self.loyalty_points += points # 주석: 아직 사용하지 않는 loyalty_points 기능을 미리 구현하여 YAGNI 원칙을 위반합니다. # 이는 불필요한 복잡성을 추가하고, 실제로 필요하지 않을 수 있는 기능을 유지보수해야 하는 부담을 줍니다. class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.vip_status = False # 아직 필요 없는 기능 self.loyalty_points = 0 # 아직 필요 없는 기능 self.referred_users = [] # 아직 필요 없는 기능 self.last_login_history = [] # 아직 필요 없는 기능 def calculate_benefits(self): # 복잡한 혜택 계산 로직 (아직 필요 없음) pass def generate_referral_code(self): # 추천 코드 생성 로직 (아직 필요 없음) pass def track_login_history(self): # 로그인 이력 추적 로직 (아직 필요 없음) pass 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 주석: 현재 필요한 기능만 구현하여 YAGNI 원칙을 준수합니다. # 이를 통해 코드를 간결하게 유지하고, 실제로 필요한 기능이 확인될 때 추가할 수 있습니다. # YAGNI 준수 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 나중에 필요할 때 기능을 추가 class PremiumUser(User): def __init__(self, name, email): super().__init__(name, email) self.premium_member = True def get_premium_benefits(self): return ["무료 배송", "특별 할인"] 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle 코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = width * height perimeter = 2 * (width + height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 면적과 둘레 계산 로직이 중복되어 DRY 원칙을 위반합니다. # 계산 로직이 변경될 경우 여러 곳을 수정해야 하며, 실수의 가능성이 높아집니다. # 코드 중복 class Order: def calculate_total_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 total = total * 1.1 # 배송비 추가 if total &lt; 50: total += 10 return total class Cart: def calculate_preview_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 (중복된 로직) total = total * 1.1 # 배송비 추가 (중복된 로직) if total &lt; 50: total += 10 return total 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = calculate_rectangle_area(width, height) perimeter = calculate_rectangle_perimeter(width, height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 계산 로직을 함수로 분리하여 재사용하므로 DRY 원칙을 준수합니다. # 로직 변경 시 한 곳만 수정하면 되어 유지보수가 용이하고 일관성을 유지할 수 있습니다. # DRY 원칙 적용 class PriceCalculator: @staticmethod def calculate_price(items): total = sum(item.price for item in items) total = PriceCalculator.apply_tax(total) total = PriceCalculator.add_shipping_fee(total) return total @staticmethod def apply_tax(amount): return amount * 1.1 @staticmethod def add_shipping_fee(amount): return amount + 10 if amount &lt; 50 else amount class Order: def calculate_total_price(self, items): return PriceCalculator.calculate_price(items) class Cart: def calculate_preview_price(self, items): return PriceCalculator.calculate_price(items) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.
단일 책임 원칙 (Single Responsibility Principle, SRP) 클래스는 단 하나의 책임만 가져야 한다.
여기서 ‘책임’이란 ‘변경의 이유’를 의미한다. 즉, 모듈은 오직 하나의 액터에 의해서만 변경되어야 한다.
이를 통해 코드의 모듈성과 유지보수성이 향상된다.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User: def __init__(self, name): self.name = name def get_name(self): return self.name def save(self): # 데이터베이스에 사용자 정보를 저장하는 로직 pass def send_email(self, message): # 이메일을 보내는 로직 pass # 주석: 이 클래스는 사용자 정보 관리, 데이터베이스 저장, 이메일 발송 등 # 여러 책임을 가지고 있어 SRP를 위반합니다. 변경 사유가 여러 개 발생할 수 있습니다. 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User: def __init__(self, name): self.name = name def get_name(self): return self.name class UserRepository: def save(self, user): # 데이터베이스에 사용자 정보를 저장하는 로직 pass class EmailService: def send_email(self, user, message): # 이메일을 보내는 로직 pass # 주석: 각 클래스가 단일 책임을 가지도록 분리되어 SRP를 준수합니다. # User 클래스는 사용자 정보만 관리하고, UserRepository는 저장을, # EmailService는 이메일 발송만 담당합니다. 각 기능의 변경이 다른 클래스에 영향을 주지 않습니다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다는 의미이다.
주로 상속이나 구성을 통해 달성되며, 안정적이고 오류가 적은 코드베이스를 만든다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동시성 프로그래밍 (Concurrency Programming)</h2></header><div class=entry-content><p>동시성 프로그래밍 (Concurrency Programming) 동시성 프로그래밍은 여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법.
이는 시스템의 효율성을 높이고 처리 시간을 줄이는 데 중점을 둔다.
특징 여러 작업의 실행 흐름을 겹치게 하거나 병렬로 처리 멀티스레딩, 멀티프로세싱, 비동기 프로그래밍 등의 기법 사용 사용 사례 웹 서버: 여러 사용자의 요청을 동시에 처리 데이터베이스 시스템: 다수의 쿼리를 병렬로 처리 UI 애플리케이션: 백그라운드 작업 수행 중 사용자 인터페이스 응답성 유지 장점 시스템 자원의 효율적 사용 응답성 향상 처리량 증가 성능 최적화 단점 코드 복잡성 증가 디버깅 어려움 동기화 문제 (Race Condition, Deadlock 등) 성능 오버헤드 가능성 고려사항 동기화 메커니즘: 적절한 락(Lock) 사용 데드락 방지 공유 자원 보호 성능 최적화: 스레드 풀 크기 조정 작업 크기 최적화 메모리 사용량 관리 오류 처리: 예외 처리 전략 실패 복구 메커니즘 타임아웃 설정 구현시 주의사항 상태 관리:
...</p></div><footer class=entry-footer><span title='2024-09-22 23:42:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;800 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 프로그래밍 (Concurrency Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>구조적 프로그래밍 (Structured Programming)</h2></header><div class=entry-content><p>구조적 프로그래밍 (Structured Programming) 구조적 프로그래밍은 1960년대에 등장한 프로그래밍 패러다임으로, 프로그램을 순차, 선택, 반복의 세 가지 기본 제어 구조로 구성하여 코드의 흐름을 체계적으로 관리하는 방식.
이 접근 방식은 코드를 모듈화하고 위에서 아래로 실행되는 절차적인 흐름을 강조한다.
특징 순차적 실행: 코드가 위에서 아래로 순서대로 실행됩니다. 모듈화: 프로그램을 작은 기능 단위로 나누어 구성합니다. 제어 구조: 순차, 선택(if-else, switch), 반복(for, while) 구조를 사용합니다. 단일 진입점과 단일 종료점: 각 모듈은 하나의 시작점과 끝점을 가집니다. GOTO문 사용 제한: 무분별한 흐름 제어를 방지합니다 장점 코드 가독성 향상: 체계적인 구조로 인해 코드 이해가 쉬워집니다. 유지보수 용이성: 모듈화된 구조로 인해 수정과 디버깅이 쉬워집니다. 개발 시간 단축: 모듈 재사용으로 개발 효율성이 증가합니다. 문제 중심 접근: 기계 중심이 아닌 문제 해결에 초점을 맞춥니다. 단점 실행 효율성 감소: 모듈 호출로 인한 오버헤드가 발생할 수 있습니다. 메모리 사용량 증가: 모듈 인터페이스로 인해 메모리 사용이 증가할 수 있습니다. 기계어 변환 시간: 고급 언어에서 기계어로의 변환에 시간이 소요됩니다. 개발 시간 증가: 언어 의존적인 특성으로 인해 개발에 더 많은 시간이 필요할 수 있습니다. 주의사항 및 고려사항 적절한 모듈화: 과도한 모듈화는 성능 저하를 초래할 수 있으므로 균형을 유지해야 합니다. 데이터 구조 설계: 프로그램의 데이터 구조를 신중히 설계해야 합니다. 재사용성 고려: 모듈을 설계할 때 재사용 가능성을 고려해야 합니다. 문서화: 각 모듈의 기능과 인터페이스를 명확히 문서화해야 합니다. 예시 Python 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # Python으로 구현한 학생 성적 관리 시스템 def get_student_info(): """사용자로부터 학생 정보를 입력받는 함수""" name = input("학생 이름을 입력하세요: ") scores = [] for subject in ["수학", "영어", "과학"]: while True: try: score = int(input(f"{subject} 점수를 입력하세요 (0-100): ")) if 0 &lt;= score &lt;= 100: scores.append(score) break print("점수는 0에서 100 사이여야 합니다.") except ValueError: print("숫자를 입력해주세요.") return name, scores def calculate_average(scores): """점수 리스트의 평균을 계산하는 함수""" return sum(scores) / len(scores) def determine_grade(average): """평균 점수를 기반으로 등급을 결정하는 함수""" if average >= 90: return 'A' elif average >= 80: return 'B' elif average >= 70: return 'C' elif average >= 60: return 'D' else: return 'F' def generate_report(name, scores, average, grade): """성적 보고서를 생성하는 함수""" report = f"\n성적 보고서\n" report += f"학생 이름: {name}\n" subjects = ["수학", "영어", "과학"] for subject, score in zip(subjects, scores): report += f"{subject}: {score}점\n" report += f"평균: {average:f}점\n" report += f"등급: {grade}" return report def main(): """메인 프로그램 함수""" try: # 학생 정보 입력 받기 name, scores = get_student_info() # 평균 계산 average = calculate_average(scores) # 등급 결정 grade = determine_grade(average) # 보고서 생성 report = generate_report(name, scores, average, grade) # 결과 출력 print(report) except Exception as e: print(f"오류가 발생했습니다: {str(e)}") if __name__ == "__main__": main() Javascript 모듈화: 각 기능이 독립적인 함수로 분리되어 있습니다. 정보 입력 (getStudentInfo) 계산 (calculateAverage) 등급 결정 (determineGrade) 보고서 생성 (generateReport) 순차적 실행: main 함수에서 프로그램의 실행 순서가 명확하게 정의되어 있습니다. 제어 구조: if-else, for, while 등의 구조화된 제어문만을 사용했습니다. 에러 처리: try-catch 구문을 사용하여 예외 상황을 처리합니다. 단일 책임: 각 함수는 하나의 명확한 작업만을 수행합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Node.js로 구현한 학생 성적 관리 시스템 const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); function promptQuestion(question) { return new Promise((resolve) => { rl.question(question, (answer) => { resolve(answer); }); }); } async function getStudentInfo() { const name = await promptQuestion("학생 이름을 입력하세요: "); const scores = []; const subjects = ["수학", "영어", "과학"]; for (const subject of subjects) { while (true) { const scoreStr = await promptQuestion(`${subject} 점수를 입력하세요 (0-100): `); const score = parseInt(scoreStr); if (!isNaN(score) && score >= 0 && score &lt;= 100) { scores.push(score); break; } console.log("올바른 점수를 입력해주세요 (0-100)"); } } return { name, scores }; } function calculateAverage(scores) { return scores.reduce((sum, score) => sum + score, 0) / scores.length; } function determineGrade(average) { if (average >= 90) return 'A'; if (average >= 80) return 'B'; if (average >= 70) return 'C'; if (average >= 60) return 'D'; return 'F'; } function generateReport(name, scores, average, grade) { const subjects = ["수학", "영어", "과학"]; let report = "\n성적 보고서\n"; report += `학생 이름: ${name}\n`; subjects.forEach((subject, index) => { report += `${subject}: ${scores[index]}점\n`; }); report += `평균: ${average.toFixed(2)}점\n`; report += `등급: ${grade}`; return report; } async function main() { try { // 학생 정보 입력 받기 const { name, scores } = await getStudentInfo(); // 평균 계산 const average = calculateAverage(scores); // 등급 결정 const grade = determineGrade(average); // 보고서 생성 const report = generateReport(name, scores, average, grade); // 결과 출력 console.log(report); } catch (error) { console.error("오류가 발생했습니다:", error.message); } finally { rl.close(); } } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 09:06:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;922 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 구조적 프로그래밍 (Structured Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-design-and-architecture/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/software-design-and-architecture/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>