<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design and Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-and-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-and-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-and-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design and Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design and Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design and Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Composition Over Inheritance</h2></header><div class=entry-content><p>Composition Over Inheritance 객체지향 프로그래밍에서 코드 재사용과 모듈화를 위한 두 가지 주요 방법이 있다: 상속(inheritance)과 합성(composition).
‘합성 우선 상속’ 원칙은 많은 경우에 상속보다 객체 합성을 선호해야 한다는 설계 지침이다. 이 원칙은 객체지향 설계의 유연성, 유지보수성, 확장성을 높이는 데 중요한 역할을 한다.
Composition Over Inheritance는 객체지향 설계에서 유연성과 유지보수성을 극대화할 수 있다.
상속 대신 객체 조합(Composition)을 우선시함으로써, 시스템의 복잡성을 관리하고 변화에 대응하기 용이한 설계를 가능하게 한다.
그러나 모든 설계 결정과 마찬가지로, 합성과 상속 중 어떤 것을 선택할지는 특정 맥락과 요구사항에 따라 달라진다. 진정한 “is-a” 관계가 있거나 다형성이 주요 목표인 경우에는 상속이 적절할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composition Over Inheritance" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/composition-over-inheritance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Encapsulate What Varies</h2></header><div class=entry-content><p>Encapsulate What Varies 소프트웨어 설계에서 “가변성 캡슐화(Encapsulate What Varies)” 원칙은 변경 가능성이 높은 부분을 식별하고 이를 캡슐화하여 나머지 코드에 미치는 영향을 최소화하는 접근 방식이다. 이 원칙은 객체지향 설계의 기본 개념 중 하나로, 유지보수성, 확장성, 재사용성을 높이는 데 중요한 역할을 한다.
원칙의 정의와 목적 “가변성 캡슐화” 원칙은 간단히 말해 “변화하는 것을 캡슐화하라"는 지침입니다. 이는 소프트웨어에서 변경될 가능성이 높은 부분을 식별하고, 그것을 나머지 시스템으로부터 분리하여 향후 변경이 시스템 전체에 미치는 영향을 최소화하는 것을 의미한다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:26:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulate What Varies" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/encapsulate-what-varies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Law of Demeter</h2></header><div class=entry-content><p>Law of Demeter 데메테르 법칙은 객체 지향 프로그래밍에서 중요한 소프트웨어 설계 원칙으로, “최소 지식 원칙”(Principle of Least Knowledge)이라고도 불린다. 이 원칙은 객체 간의 결합도를 낮추고 소프트웨어의 유지보수성을 향상시키는 것을 목표로 한다.
데메테르 법칙은 객체 지향 설계에서 결합도를 낮추고 캡슐화를 강화하는 중요한 원칙이다.
모든 상황에서 엄격하게 적용하기보다는 소프트웨어의 유지보수성, 가독성, 그리고 견고성을 향상시키는 방향으로 지침으로 활용하는 것이 좋다. 복잡한 객체 그래프를 통한 탐색을 피하고 객체에게 직접 책임을 부여함으로써 더 모듈화되고 유연한 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:25:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Law of Demeter" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/law-of-demeter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Twelve-Factor App methodology</h2></header><div class=entry-content><p>Twelve-Factor App Methodology 클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시한다.
12-Factor App 방법론은 다른 개발 방법론과 비교하여 다음과 같은 점에서 차별화된다:
클라우드 네이티브 애플리케이션에 최적화
12-Factor App 방법론은 클라우드 환경에서 실행되는 SaaS(Software-as-a-Service) 애플리케이션 개발에 특화되어 있다.
이는 클라우드의 확장성, 이식성, 배포 용이성을 최대한 활용할 수 있도록 설계되었다. 명확한 12가지 원칙 제시
다른 방법론들이 보다 광범위한 원칙을 제시하는 반면, 12-Factor App은 12가지 구체적인 원칙을 명확하게 정의한다. 이를 통해 개발자들은 실제 구현 시 명확한 가이드라인을 따를 수 있다. 환경 독립성 강조
12-Factor App은 코드베이스와 설정의 분리, 환경 간 격차 최소화 등을 통해 애플리케이션이 다양한 환경에서 일관되게 동작할 수 있도록 한다. 이는 개발, 스테이징, 프로덕션 환경 간의 차이를 최소화하여 배포 과정의 안정성을 높인다. 확장성과 유지보수성 중시
백엔드 서비스 분리, 프로세스 모델 적용, 포트 바인딩 등의 원칙을 통해 애플리케이션의 확장성과 유지보수성을 향상시킨다. 이는 대규모 시스템에서 특히 중요한 요소이다. 현대적인 개발 및 운영 관행 반영
지속적인 배포, 로그 처리, 관리 프로세스 등에 대한 원칙을 통해 현대적인 DevOps 관행을 자연스럽게 도입할 수 있도록 한다. 이는 애자일 방법론이나 DevOps와 잘 어울리면서도, 보다 구체적인 실천 방안을 제시한다. 12 Factors Codebase (코드베이스) 하나의 코드베이스를 버전 관리하고, 다양한 배포에 활용한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 01:40:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Twelve-Factor App methodology" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멀티 테넌시(Multi-tenancy)</h2></header><div class=entry-content><p>멀티 테넌시(Multi-tenancy) 멀티 테넌시(Multi-tenancy)는 소프트웨어 아키텍처의 한 형태로, 단일 소프트웨어 인스턴스가 여러 사용자 그룹(테넌트)에게 서비스를 제공하는 구조를 말한다. 즉, 하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.
각 테넌트는 공통 인프라를 공유하면서도 자신만의 독립된 환경을 가진 것처럼 작동한다.
주요 특징:
단일 인스턴스로 여러 사용자 그룹 서비스 데이터와 구성의 논리적 분리 각 테넌트에 대한 개별화된 사용자 경험 제공 https://www.linkedin.com/pulse/saas-architecture-right-way-sk-reddy-2ozuc/
멀티 테넌시의 유형 멀티 테넌시는 다양한 형태로 구현될 수 있다:
단일 인스턴스, 단일 데이터베이스: 모든 테넌트가 동일한 애플리케이션 인스턴스와 데이터베이스를 공유한다. 비용 효율적이지만 확장성에 제한이 있을 수 있다. 단일 인스턴스, 다중 데이터베이스: 애플리케이션 인스턴스는 공유하지만 각 테넌트가 별도의 데이터베이스를 가진다. 데이터 격리 수준이 높아진다. 다중 인스턴스, 다중 데이터베이스: 각 테넌트가 독립된 애플리케이션 인스턴스와 데이터베이스를 가진다. 가장 높은 수준의 격리를 제공하지만 비용이 증가한다. 멀티 테넌시의 장점 비용 효율성: 인프라와 리소스를 공유함으로써 개발, 유지보수, 운영 비용을 절감할 수 있다. 효율적인 리소스 관리: 여러 고객이 동일한 인프라를 공유하므로 리소스 활용도가 높아진다. 간편한 업데이트와 유지보수: 단일 인스턴스를 업데이트하면 모든 테넌트에게 동시에 적용되어 관리가 용이하다. 확장성: 사용자 수나 데이터 양이 증가할 때 쉽게 확장할 수 있다. 데이터 통합 용이성: 모든 테넌트의 데이터가 중앙 집중화되어 있어 분석과 인사이트 도출이 용이하다. 멀티 테넌시의 단점과 과제 보안과 데이터 격리: 여러 테넌트의 데이터가 공존하므로 데이터 유출 위험이 있다. 철저한 보안 조치가 필요하다. 복잡한 아키텍처: 개인화와 데이터 격리를 위해 복잡한 설계가 필요하다. 성능 관리: 한 테넌트의 과도한 리소스 사용이 다른 테넌트에게 영향을 줄 수 있다. 규정 준수: 다양한 테넌트의 데이터를 처리할 때 각종 법적 규정과 프라이버시 요구사항을 준수해야 한다. 커스터마이징의 한계: 각 테넌트별로 세부적인 커스터마이징에 제한이 있을 수 있다. 멀티 테넌시 구현 시 고려사항 데이터 모델 설계: 테넌트 간 데이터 격리를 위한 효과적인 데이터 모델 설계가 필요하다. 보안 메커니즘: 강력한 인증, 권한 부여, 암호화 등의 보안 메커니즘 구현이 중요하다. 확장성 계획: 테넌트 수와 데이터 양 증가에 대비한 확장 계획을 수립해야 한다. 성능 모니터링: 각 테넌트의 리소스 사용량을 모니터링하고 최적화하는 시스템이 필요하다. 백업 및 복구 전략: 테넌트별 데이터 백업 및 복구 전략을 수립해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 14:06:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멀티 테넌시(Multi-tenancy)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/multi-tenancy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Publisher-Subscriber Pattern</h2></header><div class=entry-content><p>Publisher-Subscriber Pattern Publisher-Subscriber Pattern(게시자-구독자 패턴)은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 분산 시스템에서 비동기 통신을 구현하는 데 널리 사용된다.
이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.
이 패턴은 컴포넌트 간의 느슨한 결합을 제공하여 확장성과 유연성을 높이는 데 기여한다.
https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber
기본 개념 Publisher-Subscriber 패턴의 핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:40:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publisher-Subscriber Pattern" href=https://buenhyden.github.io/posts/system-design/cloud-design-patterns/messaging/publisher-subscriber/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.
네트워크 불안정, 일시적인 서비스 중단 등 일시적인 실패 상황에서 시스템의 복원력(Resilience)을 강화하는 데 목적을 둔다.
이 패턴은 분산 시스템의 안정성을 높이는 필수 도구이지만, 남용할 경우 역효과를 낼 수 있으므로 신중한 정책 수립이 필요하다.
Retry Pattern의 핵심 개념 작동 원리
실패한 작업 자동 재시도: API 호출, 데이터베이스 접근 등 실패 가능성이 있는 작업을 정의된 정책에 따라 재시도한다. 일시적 오류 감지: 네트워크 타임아웃, HTTP 5xx 에러, 데이터베이스 연결 실패 등 일시적인 오류만 대상으로 한다. 주요 구성 요소
...</p></div><footer class=entry-footer><span title='2024-09-27 11:31:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/system-design/reliability-patterns/resiliency/retry/retry-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model-View-ViewModel Pattern</h2></header><div class=entry-content><p>Model-View-ViewModel Pattern MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.
이 패턴은 MVC(Model-View-Controller) 패턴의 발전된 형태로 볼 수 있다.
MVVM 패턴은 복잡한 UI 애플리케이션 개발에 특히 유용하며, 대규모 프로젝트에서 코드의 구조화와 관리를 용이하게 한다.
https://learn.microsoft.com/ko-kr/dotnet/architecture/maui/mvvm
MVVM의 구성 요소 MVVM 패턴은 세 가지 주요 구성 요소로 이루어져 있다:
모델(Model): 데이터와 비즈니스 로직을 담당한다. 데이터베이스나 웹 서비스와의 통신을 통해 데이터를 가져오거나 저장하는 역할을 한다. 뷰(View): 사용자 인터페이스(UI)를 담당한다. 데이터를 표시하고 사용자 입력을 받아 ViewModel에 전달한다. 버튼, 텍스트 박스 등 화면에 표시되는 모든 요소를 포함하며, 사용자와의 상호작용을 처리한다. 뷰모델(ViewModel): 뷰와 모델 사이의 중재자 역할을 한다. 뷰에서 보여지는 데이터와 이를 조작하는 메서드, 상태를 포함한다. MVVM의 핵심 개념 데이터 바인딩: MVVM의 핵심 아이디어는 뷰와 뷰모델 사이에 양방향 데이터 바인딩을 통해 자동 업데이트를 가능하게 하는 것이다. 이를 통해 뷰와 뷰모델 사이의 데이터 동기화가 자동으로 이루어진다. 명령(Command): 버튼 클릭과 같은 사용자 액션을 뷰모델에서 처리하기 위한 메커니즘이다. 뷰모델은 ICommand 인터페이스를 구현하여 뷰에서 발생하는 이벤트를 처리한다. 의존성 관리: 뷰모델을 중재자로 사용하여 뷰와 모델 사이의 의존성을 해결한다. 이로 인해 뷰와 모델의 결합도가 낮아진다. 테스트 용이성: 뷰와 모델이 분리되어 있어 각 구성 요소를 독립적으로 테스트하기 쉽다. MVVM의 장점 유지보수성 향상: UI와 비즈니스 로직이 분리되어 있어 코드의 유지보수가 용이하다. 재사용성 증가: 뷰모델은 여러 뷰에서 재사용될 수 있다. 자동 업데이트: 데이터 바인딩을 통해 뷰모델의 상태 변화가 자동으로 UI에 반영된다. 개발 효율성: 개발자는 데이터 변경에 직접 관여하지 않고, 뷰모델을 통해 데이터를 조작하고 업데이트할 수 있어 코드의 복잡성이 줄어든다. MVVM 구현 예시 다음은 간단한 카운터 애플리케이션의 MVVM 구현 예시
...</p></div><footer class=entry-footer><span title='2024-09-27 11:26:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model-View-ViewModel Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/model-view-viewmodel-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model–view–presenter Pattern</h2></header><div class=entry-content><p>Model–view–presenter Pattern Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, 관심사 분리 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.
MVC 패턴에서 파생되었으며, 주로 Windows Forms, ASP.NET, Java Swing 애플리케이션에서 활용된다.
이 패턴은 1990년대 Taligent사에서 처음 도입되었으며, 현재까지 엔터프라이즈급 애플리케이션에서 구조적 안정성을 제공하는 핵심 아키텍처로 자리잡았다. UI 복잡도가 높은 프로젝트에서 체계적인 관리를 원한다면 MVP 구현을 적극 고려해볼 만하다.
https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/
핵심 구성 요소 Model: 데이터 저장/관리 및 비즈니스 로직 처리 담당. 데이터베이스 연동, API 통신, 캐싱 기능 수행. UI와 독립적으로 동작하여 재사용성 향상. View: 사용자 인터페이스 표시 및 입력 이벤트 전달. 수동적(passive)으로 Presenter에 이벤트 전송. 데이터 표시 형식만 관리(예: 텍스트 박스 값 표시). Presenter: Model과 View의 중재자 역할. 사용자 입력 처리 → Model 업데이트 → 변경 사항 View 반영. 복잡한 UI 로직 캡슐화로 테스트 용이성 증대. 작동 메커니즘 사용자가 View와 상호작용하여 이벤트를 발생시킨다(예: 로그인). View → Presenter에 이벤트 전달 Presenter가 Model에서 데이터 검증/처리 처리 결과를 View에 반영(예: “로그인 성공” 메시지 표시) 주요 장점 유지보수성 향상:
...</p></div><footer class=entry-footer><span title='2024-09-27 09:10:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model–view–presenter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/modelviewpresenter-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-design-and-architecture/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/software-design-and-architecture/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>