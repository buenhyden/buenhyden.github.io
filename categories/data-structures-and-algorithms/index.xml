<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data Structures and Algorithms on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/data-structures-and-algorithms/</link>
    <description>Recent content in Data Structures and Algorithms on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.145.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 02 Mar 2025 03:13:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/data-structures-and-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithmic Complexity</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithmic-complexity/</link>
      <pubDate>Fri, 06 Dec 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithmic-complexity/</guid>
      <description>알고리즘 복잡도는 프로그램이나 알고리즘이 문제를 해결할 때 소요하는 시간과 공간, 즉 컴퓨팅 자원의 사용량을 입력 크기에 따라 수학적으로 분석하는 방법이다.</description>
    </item>
    <item>
      <title>Traversal</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/</link>
      <pubDate>Fri, 06 Dec 2024 03:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/</guid>
      <description>트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다.</description>
    </item>
    <item>
      <title>정렬 알고리즘 (Sorting Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/</link>
      <pubDate>Mon, 14 Oct 2024 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/</guid>
      <description>정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>검색 알고리즘 (Searching Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/</guid>
      <description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</description>
    </item>
    <item>
      <title>Data Structures</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/</link>
      <pubDate>Mon, 07 Oct 2024 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/</guid>
      <description>데이터를 효율적으로 저장, 관리, 접근하기 위한 방법</description>
    </item>
    <item>
      <title>배열 (Array)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array/</link>
      <pubDate>Mon, 07 Oct 2024 05:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array/</guid>
      <description>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.</description>
    </item>
    <item>
      <title>연결 리스트 (Linked List)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/</guid>
      <description>각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 선형 데이터 구조</description>
    </item>
    <item>
      <title>해시 테이블(Hash Tables)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/hash-tables/</link>
      <pubDate>Wed, 09 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/hash-tables/</guid>
      <description>키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 키를 인덱스로 변환</description>
    </item>
    <item>
      <title>스택 (Stack)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/</link>
      <pubDate>Wed, 09 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/</guid>
      <description>LIFO(Last In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>Concurrent Hash Map vs Hash Map vs Hash Table</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-hash-map-vs-hash-map-vs-hash-table/</link>
      <pubDate>Sat, 12 Oct 2024 14:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-hash-map-vs-hash-map-vs-hash-table/</guid>
      <description>&lt;h2 id=&#34;concurrent-hash-map-vs-hash-map-vs-hash-table&#34;&gt;Concurrent Hash Map Vs Hash Map Vs Hash Table&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특성&lt;/th&gt;
          &lt;th&gt;Concurrent HashMap&lt;/th&gt;
          &lt;th&gt;HashMap&lt;/th&gt;
          &lt;th&gt;HashTable&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트/버킷 단위의 부분 동기화 지원&lt;/td&gt;
          &lt;td&gt;동기화 지원하지 않음&lt;/td&gt;
          &lt;td&gt;메서드 단위의 전체 동기화 지원&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동시성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능)&lt;/td&gt;
          &lt;td&gt;동시성 지원하지 않음 (단일 스레드 환경용)&lt;/td&gt;
          &lt;td&gt;낮은 동시성 (한 번에 하나의 스레드만 접근 가능)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동시 접근 시 높은 성능&lt;/td&gt;
          &lt;td&gt;단일 스레드에서 가장 높은 성능&lt;/td&gt;
          &lt;td&gt;동기화로 인한 성능 저하&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;null 허용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
          &lt;td&gt;key는 하나만 null 허용, value는 여러 개 null 허용&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;초기 용량&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 16, 세그먼트 수는 16&lt;/td&gt;
          &lt;td&gt;기본 16&lt;/td&gt;
          &lt;td&gt;기본 11&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;적재율&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;이터레이션&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;fail-safe 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;생성 시기&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Java 5&lt;/td&gt;
          &lt;td&gt;Java 1.2&lt;/td&gt;
          &lt;td&gt;Java 1.0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;메모리 사용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트로 인한 추가 메모리 필요&lt;/td&gt;
          &lt;td&gt;가장 적은 메모리 사용&lt;/td&gt;
          &lt;td&gt;동기화로 인한 추가 메모리 필요&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;용도&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;멀티스레드 환경의 동시성이 필요한 경우&lt;/td&gt;
          &lt;td&gt;단일 스레드 환경의 일반적인 경우&lt;/td&gt;
          &lt;td&gt;레거시 코드 호환성이 필요한 경우&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;순서 보장&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화 비용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;부분적 동기화로 중간 수준의 비용&lt;/td&gt;
          &lt;td&gt;동기화 비용 없음&lt;/td&gt;
          &lt;td&gt;전체 동기화로 높은 비용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;스레드 안전성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
          &lt;td&gt;스레드 안전하지 않음&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;키 충돌 처리&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;참고로 몇 가지 중요한 추가 설명을 하자면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Concurrent Data Structures</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-data-structures/</link>
      <pubDate>Sat, 12 Oct 2024 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-data-structures/</guid>
      <description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</description>
    </item>
    <item>
      <title>Linear Data Structure vs Non-Linear Data Structure</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/</guid>
      <description>Linear Data Structure Vs Non-Linear Data Structure</description>
    </item>
    <item>
      <title>Primitive data structure vs Non-Primitive data structure</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 08:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/</guid>
      <description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description>
    </item>
    <item>
      <title>큐 (Queue)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/queue/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/queue/</guid>
      <description>FIFO(First In First Out) 원칙을 따르는 선형 데이터 구조</description>
    </item>
    <item>
      <title>Minimum Spanning Tree</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/</link>
      <pubDate>Sun, 02 Mar 2025 03:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/</guid>
      <description>&lt;h2 id=&#34;minimum-spanning-tree&#34;&gt;Minimum Spanning Tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Shortest Path</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/shortest-path/</link>
      <pubDate>Sun, 02 Mar 2025 03:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/shortest-path/</guid>
      <description>&lt;h2 id=&#34;shortest-path&#34;&gt;Shortest Path&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Rabin-Karp’s algorithm</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/rabin-karps-algorithm/</link>
      <pubDate>Sat, 01 Mar 2025 04:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/rabin-karps-algorithm/</guid>
      <description>&lt;h2 id=&#34;rabin-karps-algorithm&#34;&gt;Rabin-Karp’s algorithm&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Finding Hamiltonian Paths</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/finding-hamiltonian-paths/</link>
      <pubDate>Sat, 01 Mar 2025 04:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/finding-hamiltonian-paths/</guid>
      <description>&lt;h2 id=&#34;finding-hamiltonian-paths&#34;&gt;Finding Hamiltonian Paths&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Huffman Coding</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/huffman-coding/</link>
      <pubDate>Sat, 01 Mar 2025 04:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/huffman-coding/</guid>
      <description>&lt;h2 id=&#34;huffman-coding&#34;&gt;Huffman Coding&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Knight’s Tour Problem</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/knights-tour-problem/</link>
      <pubDate>Sat, 01 Mar 2025 04:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/knights-tour-problem/</guid>
      <description>&lt;h2 id=&#34;knights-tour-problem&#34;&gt;Knight’s Tour Problem&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Maze Solving Problem</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/maze-solving-problem/</link>
      <pubDate>Sat, 01 Mar 2025 04:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/maze-solving-problem/</guid>
      <description>&lt;h2 id=&#34;maze-solving-problem&#34;&gt;Maze Solving Problem&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Solving n Queen Problem</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/solving-n-queen-problem/</link>
      <pubDate>Sat, 01 Mar 2025 04:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/solving-n-queen-problem/</guid>
      <description>&lt;h2 id=&#34;solving-n-queen-problem&#34;&gt;Solving n Queen Problem&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Ford Fulkerson Algorithm</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/ford-fulkerson-algorithm/</link>
      <pubDate>Sat, 01 Mar 2025 04:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/ford-fulkerson-algorithm/</guid>
      <description>&lt;h2 id=&#34;ford-fulkerson-algorithm&#34;&gt;Ford Fulkerson Algorithm&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Recursion</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/</link>
      <pubDate>Mon, 14 Oct 2024 13:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/</guid>
      <description>재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/reducibility/</guid>
      <description>환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>브루트 포스 (Brute Force)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/brute-force/</link>
      <pubDate>Sun, 13 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/brute-force/</guid>
      <description>브루트 포스는 &amp;#34;무식한 힘&amp;#34;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>랜덤화 알고리즘 (Randomized Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/randomized-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/randomized-algorithm/</guid>
      <description>랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다.</description>
    </item>
    <item>
      <title>근사 알고리즘 (Approximation algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/</guid>
      <description>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &amp;#39;충분히 가까운&amp;#39; 해답을 찾는 알고리즘이다.</description>
    </item>
    <item>
      <title>동적 계획법 (Dynamic Programming)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/</guid>
      <description>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>백트래킹 (Backtracking)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/</guid>
      <description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</description>
    </item>
    <item>
      <title>분기 한정법 (Branch and Bound)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/</guid>
      <description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</description>
    </item>
    <item>
      <title>탐욕 알고리즘 (Greedy Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/</guid>
      <description>문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다. 즉, &amp;#39;탐욕적&amp;#39;으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.</description>
    </item>
    <item>
      <title>분할 정복 (Divide and Conquer)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/</link>
      <pubDate>Sun, 13 Oct 2024 05:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/</guid>
      <description>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.</description>
    </item>
    <item>
      <title>Problem Solving Techniques</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/</link>
      <pubDate>Sun, 13 Oct 2024 05:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/</guid>
      <description>&lt;h2 id=&#34;problem-solving-techniques&#34;&gt;Problem Solving Techniques&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Stack vs Queue</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack-vs-queue/</link>
      <pubDate>Wed, 09 Oct 2024 08:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack-vs-queue/</guid>
      <description>스택(Stack)과 큐(Queue)는 컴퓨터 과학에서 널리 사용되는 선형 자료구조로, 데이터의 저장 및 처리 방식에서 차이가 있다.</description>
    </item>
    <item>
      <title>Array vs Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array-vs-linked-list/</link>
      <pubDate>Mon, 07 Oct 2024 16:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array-vs-linked-list/</guid>
      <description>배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.</description>
    </item>
    <item>
      <title>그래프 (Graph)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/</link>
      <pubDate>Mon, 07 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/</guid>
      <description>노드(정점)와 엣지(간선)로 구성된 비선형 데이터 구조</description>
    </item>
    <item>
      <title>트리 (Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/</link>
      <pubDate>Mon, 07 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/</guid>
      <description>계층적 구조를 가진 비선형 데이터 구조로, 노드들이 부모-자식 관계로 연결되어 있다</description>
    </item>
  </channel>
</rss>
