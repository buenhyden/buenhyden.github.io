<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Development Model | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-development-model/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-development-model/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-development-model/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-development-model/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Development Model"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Development Model"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Development Model</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rapid Application Development</h2></header><div class=entry-content><p>라피드 애플리케이션 개발 모델 (Rapid Application Development, RAD) 빠른 프로토타이핑과 반복적인 개발을 통해 신속하게 애플리케이션을 구축하는 접근 방식
사용자 피드백을 중시하며 유연성과 속도에 초점을 맞춘다.
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 800, 'height': 600, 'diagramPadding': 15}}}%% graph TD Start([프로젝트 시작]) --> Planning subgraph RADProcess [RAD 개발 프로세스] subgraph Planning [1. 요구사항 계획] P1[비즈니스 분석] --> P2[범위 정의] P2 --> P3[팀 구성] end subgraph UserDesign [2. 사용자 설계] UD1[프로토타입 설계] --> UD2[사용자 피드백] UD2 --> UD3[설계 개선] end subgraph Construction [3. 구축] C1[컴포넌트 개발] --> C2[코딩/테스트] C2 --> C3[시스템 통합] end subgraph Transition [4. 전환] T1[최종 테스트] --> T2[사용자 교육] T2 --> T3[시스템 배포] end end %% 메인 프로세스 흐름 Planning --> UserDesign UserDesign --> Construction Construction --> Transition Transition --> End([프로젝트 완료]) %% 핵심 피드백 루프 UD2 -.피드백.-> P2 C3 -.피드백.-> UD1 %% RAD 핵심 특성 subgraph Features [핵심 특성] RC1[시간 박스형 개발] RC2[반복적 프로토타이핑] end %% 스타일 정의 classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px classDef phase fill:#e1f5fe,stroke:#01579b,stroke-width:1px classDef milestone fill:#e8f5e9,stroke:#2e7d32,stroke-width:1px class Start,End milestone class P1,P2,P3,UD1,UD2,UD3,C1,C2,C3,T1,T2,T3 phase class RC1,RC2 phase style RADProcess fill:#fafafa,stroke:#666,stroke-width:1px style Planning fill:#e3f2fd,stroke:#666,stroke-width:1px style UserDesign fill:#e8f5e9,stroke:#666,stroke-width:1px style Construction fill:#fff3e0,stroke:#666,stroke-width:1px style Transition fill:#f3e5f5,stroke:#666,stroke-width:1px style Features fill:#f5f5f5,stroke:#666,stroke-width:1px 주요 단계 요구사항 계획: 프로젝트 범위와 요구사항을 정의. 사용자 설계: 프로토타입을 만들고 사용자 피드백을 수집. 구축: 실제 소프트웨어를 개발하고 사용자 입력을 바탕으로 개선. 전환: 최종 테스트, 구현, 사용자 교육을 수행. 특징 반복적 개발: 짧은 개발 주기를 통해 지속적으로 프로토타입을 개선. 사용자 참여: 개발 전 과정에 걸쳐 사용자의 피드백을 적극적으로 수용. 컴포넌트 재사용: 기존 코드와 컴포넌트를 재활용하여 개발 속도를 높인다. 자동화 도구 활용: CASE(Computer-Aided Software Engineering) 도구를 사용하여 개발 과정을 가속화. 유연한 계획: 상세한 계획 대신 빠른 프로토타이핑에 중점을 둔다. 장점 개발 시간 단축: 빠른 프로토타이핑으로 제품을 신속하게 출시할 수 있다. 유연성: 요구사항 변경에 빠르게 대응할 수 있다. 사용자 만족도 향상: 지속적인 사용자 참여로 최종 제품의 품질이 향상된다. 위험 감소: 초기 단계부터 문제점을 식별하고 해결할 수 있다. 생산성 향상: 컴포넌트 재사용과 자동화 도구 활용으로 생산성이 증가한다. 단점 숙련된 개발자 필요: 고도의 기술을 가진 개발자 팀이 필요. 규모의 한계: 대규모 프로젝트에는 적합하지 않을 수 있다. 모듈화 필요: 모듈화가 가능한 프로젝트에만 적합. 비용 증가: 자동화 도구와 숙련된 인력으로 인해 초기 비용이 높을 수 있다. 문서화 부족: 빠른 개발로 인해 충분한 문서화가 이루어지지 않을 수 있다. 적합한 프로젝트 유형 구사항이 불명확하거나 자주 변경될 수 있는 프로젝트, 사용자 인터페이스가 중요한 프로젝트, 그리고 빠른 시장 출시가 필요한 프로젝트에 특히 적합 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-29 00:48:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;385 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rapid Application Development" href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/rapid-application-development/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Agile Model</h2></header><div class=entry-content><p>애자일(Agile) 모델 소프트웨어 개발에서 사용되는 반복적이고 점진적인 접근 방식으로 빠르게 변화하는 요구사항에 유연하게 대응하며 고객 만족을 최우선으로 한다.
핵심 원칙
프로세스와 도구보다 개인과 상호작용을 중시 포괄적인 문서보다 작동하는 소프트웨어를 중시 계약 협상보다 고객과의 협력을 중시 계획을 따르는 것보다 변화에 대응하는 것을 중시 %%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 800, 'height': 600, 'diagramPadding': 15}}}%% graph TD Start([스프린트 시작]) --> Planning subgraph AgileProcess [Agile 개발 프로세스] subgraph Planning [1. 계획] P1[요구사항 분석] --> P2[목표 정의] P2 --> P3[백로그 작성] end subgraph Design [2. 설계] D1[스토리 작성] --> D2[우선순위화] D2 --> D3[스프린트 계획] end subgraph Development [3. 개발] Dev1[코딩] --> Dev2[통합] Dev2 --> Dev3[구현] end subgraph Testing [4. 테스트] T1[단위 테스트] --> T2[통합 테스트] T2 --> T3[버그 수정] end subgraph Review [5. 검토] R1[시연] --> R2[피드백] R2 --> R3[회고] end end Planning --> Design Design --> Development Development --> Testing Testing --> Review Review --> Decision{목표 달성?} Decision -->|No| Planning Decision -->|Yes| End([스프린트 종료]) %% 핵심 피드백 루프만 유지 R2 -.피드백.-> P1 T3 -.개선.-> Dev1 %% 간소화된 애자일 특성 subgraph Principles [핵심 원칙] AC1[소통과 협력] AC2[변화 수용] end %% 스타일 정의 classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px classDef phase fill:#e1f5fe,stroke:#01579b,stroke-width:1px classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:1px classDef milestone fill:#e8f5e9,stroke:#2e7d32,stroke-width:1px class Start,End milestone class P1,P2,P3,D1,D2,D3,Dev1,Dev2,Dev3,T1,T2,T3,R1,R2,R3 phase class Decision decision class AC1,AC2 phase style AgileProcess fill:#fafafa,stroke:#666,stroke-width:1px style Principles fill:#f5f5f5,stroke:#666,stroke-width:1px 주요 단계 계획
이 단계에서는 고객의 요구사항을 수집하고 분석하여 프로젝트의 목표와 범위를 정의합니다
고객과 개발팀이 협력하여 프로젝트의 비전을 수립하고 초기 제품 백로그를 작성합니다 설계(디자인)
기획 의도에 맞는 설계와 디자인을 수행하는 단계입니다.
이 단계에서는 사용자 스토리를 작성하고 우선순위를 지정하며, 스프린트 계획을 수립합니다 개발(발전)
설계 단계에서 만들어진 계획을 바탕으로 실제 코딩 작업이 이루어집니다.
개발자들은 짧은 주기로 작동하는 소프트웨어를 만들어냅니다.
이 과정에서 지속적인 통합과 테스트가 수행됩니다. 테스트
개발된 기능에 대해 버그를 발견하고 수정하는 단계입니다.
단위 테스트, 통합 테스트 등 다양한 수준의 테스트가 수행되며, 이는 개발 과정 전반에 걸쳐 지속적으로 이루어집니다. 검토(피드백)
개발된 기능을 고객에게 시연하고 피드백을 받는 단계입니다.
이 과정을 통해 프로젝트의 진행 상황을 평가하고 필요한 조정사항을 파악합니다. 스프린트 리뷰와 회고를 통해 팀의 성과를 평가하고 개선점을 도출합니다 특징 반복적 개발: 짧은 주기(스프린트)로 개발을 반복하며 지속적으로 제품을 개선한다. 유연성: 요구사항 변경에 빠르게 대응할 수 있다. 고객 중심: 고객과의 지속적인 소통과 피드백을 통해 제품을 개선한다. 팀워크 강조: 자기 조직화된 팀이 협력하여 문제를 해결한다. 지속적인 개선: 정기적인 회고를 통해 프로세스를 개선한다. 주요 방법론 스크럼(Scrum): 가장 널리 사용되는 애자일 방법론으로, 스프린트라는 짧은 개발 주기를 반복. XP(eXtreme Programming): 페어 프로그래밍, 지속적인 통합 등의 실천 방법을 강조. 칸반(Kanban): 작업의 시각화와 작업 흐름 관리에 중점. 장점 빠른 제품 출시와 피드백 반영이 가능. 변화하는 요구사항에 유연하게 대응할 수 있다. 고객 만족도를 높일 수 있다. 팀의 생산성과 협업을 향상시킨다 단점 명확한 계획과 문서화가 부족할 수 있다. 지속적인 변경으로 인한 스트레스가 발생할 수 있다. 대규모 프로젝트에 적용하기 어려울 수 있다. 적합한 프로젝트 유형 현대 소프트웨어 개발에서 널리 사용되며, 특히 빠르게 변화하는 비즈니스 환경에서 효과적
...</p></div><footer class=entry-footer><span title='2024-09-29 00:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;455 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Agile Model" href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/agile-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>V Model</h2></header><div class=entry-content><p>V 모델 개발 단계와 테스트 단계를 병행하여 진행하는 검증(Verification)과 확인(Validation) 중심의 접근 방식이다.
폭포수 모델의 변형으로, 각 개발 단계에 대응하는 테스트 단계를 명시하여 검증과 확인을 강조한다.
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 600, 'height': 400, 'diagramPadding': 15}}}%% graph TB %% 개발 단계 (왼쪽) subgraph Development [개발 단계] R[요구사항 분석] --> SD[시스템 설계] SD --> AD[아키텍처 설계] AD --> MD[모듈 설계] MD --> CODE[구현] end %% 테스트 단계 (오른쪽) subgraph Testing [검증 단계] CODE --> UT[단위 테스트] UT --> IT[통합 테스트] IT --> ST[시스템 테스트] ST --> AT[인수 테스트] end %% 개발-테스트 단계 간 검증 관계 R -.검증 및 확인.-> AT SD -.검증 및 확인.-> ST AD -.검증 및 확인.-> IT MD -.검증 및 확인.-> UT %% 각 단계별 산출물 subgraph Artifacts [주요 산출물] %% 개발 단계 산출물 subgraph DevDoc [개발 문서] RD[요구사항 명세서] SDD[시스템 설계서] ADD[아키텍처 설계서] MDD[모듈 설계서] end %% 테스트 단계 산출물 subgraph TestDoc [테스트 문서] UTD[단위 테스트 계획/결과] ITD[통합 테스트 계획/결과] STD[시스템 테스트 계획/결과] ATD[인수 테스트 계획/결과] end end %% 단계와 산출물 연결 R --- RD SD --- SDD AD --- ADD MD --- MDD UT --- UTD IT --- ITD ST --- STD AT --- ATD %% 스타일링 classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px classDef development fill:#e1f5fe,stroke:#01579b,stroke-width:2px classDef testing fill:#fff3e0,stroke:#e65100,stroke-width:2px classDef artifact fill:#f5f5f5,stroke:#666,stroke-width:2px classDef verification stroke-dasharray: 5,5 %% 클래스 적용 class R,SD,AD,MD,CODE development class UT,IT,ST,AT testing class RD,SDD,ADD,MDD,UTD,ITD,STD,ATD artifact style Development fill:#f8f9fa,stroke:#666,stroke-width:2px style Testing fill:#f8f9fa,stroke:#666,stroke-width:2px style Artifacts fill:#fafafa,stroke:#666,stroke-width:2px,stroke-dasharray: 5 style DevDoc,TestDoc fill:#f5f5f5,stroke:#666,stroke-width:2px 주요 단계 개발 단계 (왼쪽) 요구사항 분석: 고객의 요구사항을 수집하고 분석. 시스템 설계: 전체 시스템의 아키텍처를 설계. 아키텍처 설계: 고수준 설계로, 모듈 간 상호작용과 데이터 흐름을 정의. 모듈 설계: 저수준 설계로, 각 모듈의 상세 기능과 로직을 설계. 구현: 실제 코드를 작성. 테스트 단계 (오른쪽) 단위 테스트: 개별 모듈의 기능을 검증. 통합 테스트: 모듈 간 상호작용을 검증. 시스템 테스트: 전체 시스템의 기능과 성능을 검증. 인수 테스트: 고객의 요구사항 충족 여부를 최종 검증. 특징 V자 형태의 구조: 개발 단계가 왼쪽에서 아래로 내려가고, 테스트 단계가 오른쪽으로 올라가는 V자 모양을 형성. 단계별 대응: 각 개발 단계에 대응하는 테스트 단계가 존재. 조기 결함 발견: 각 단계마다 테스트를 수행하여 결함을 빠르게 발견하고 수정할 수 있다. 체계적인 문서화: 각 단계에서 상세한 문서화를 통해 작업을 진행. 장점 결함을 조기에 발견하여 수정 비용을 절감할 수 있다. 체계적인 접근으로 프로젝트 관리가 용이. 각 단계별 문서화로 추적 가능성이 높다. 테스트 활동을 프로젝트 초기부터 계획하여 품질을 향상시킨다. 단점 요구사항 변경에 대한 유연성이 부족. 각 단계가 이전 단계에 종속되어 있어 진행이 경직될 수 있다. 대규모 프로젝트에서는 관리가 복잡해질 수 있다. 적합한 프로젝트 유형 요구사항이 명확하고 변경이 적은 프로젝트에 적합하며, 특히 안전이 중요한 산업(예: 항공우주, 국방)에서 자주 사용.
품질 보증과 체계적인 개발 프로세스를 중시하는 프로젝트에 효과적.
...</p></div><footer class=entry-footer><span title='2024-09-29 00:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;431 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to V Model" href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/v-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Waterfall Model</h2></header><div class=entry-content><p>폭포수(Waterfall) 모델 각 단계를 순차적으로 진행하며, 이전 단계가 완료되어야 다음 단계로 넘어가는 전통적인 모델.
%%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '14px'}, 'flowchart': {'width': 600, 'height': 400, 'diagramPadding': 15}}}%% graph TB %% 주요 개발 단계 Start([프로젝트 시작]) --> RA[요구사항 분석] RA --> SD[시스템 설계] SD --> DD[상세 설계] DD --> IM[구현] IM --> TE[테스트] TE --> DE[배포] DE --> MA[유지보수] MA --> End([프로젝트 종료]) %% 산출물 정의 subgraph Documents [단계별 산출물] subgraph Analysis [요구사항 분석] DOC1[요구사항 명세서] DOC2[타당성 분석서] end subgraph Design [설계] DOC3[시스템 설계서] DOC4[상세 설계서] end subgraph Implementation [구현] DOC5[소스 코드] DOC6[단위 테스트] end subgraph Test [테스트] DOC7[테스트 계획서] DOC8[테스트 결과서] end subgraph Deploy [배포] DOC9[사용자 매뉴얼] DOC10[운영 문서] end subgraph Maintenance [유지보수] DOC11[유지보수 보고서] DOC12[변경 이력서] end end %% 단계와 산출물 연결 RA -.생성.-> Analysis SD -.생성.-> Design DD -.생성.-> Design IM -.생성.-> Implementation TE -.생성.-> Test DE -.생성.-> Deploy MA -.생성.-> Maintenance %% 스타일링 classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px classDef phase fill:#e1f5fe,stroke:#01579b,stroke-width:2px classDef artifact fill:#fff3e0,stroke:#e65100,stroke-width:2px classDef milestone fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px class Start,End milestone class RA,SD,DD,IM,TE,DE,MA phase class DOC1,DOC2,DOC3,DOC4,DOC5,DOC6,DOC7,DOC8,DOC9,DOC10,DOC11,DOC12 artifact style Documents fill:#fafafa,stroke:#666,stroke-width:2px,stroke-dasharray: 5 style Analysis,Design,Implementation,Test,Deploy,Maintenance fill:#f5f5f5,stroke:#666,stroke-width:2px 주요 단계 타당성 조사: 프로젝트의 기술적, 경제적 타당성을 평가. 요구사항 분석: 시스템의 목적과 범위를 명확히 정의하고 요구사항 명세서를 작성. 설계: 시스템 아키텍처, 인터페이스, 프로그램 등을 설계. 구현(코딩): 실제 프로그램 코드를 작성. 테스트: 개발된 소프트웨어를 테스트하고 오류를 수정. 통합: 개발된 모듈을 하나의 시스템으로 통합. 유지보수: 소프트웨어를 배포하고 지속적으로 유지보수. 특징 순차적 진행: 각 단계가 순차적으로 진행되며, 한 단계가 완료되어야 다음 단계로 넘어간다. 문서 중심: 각 단계마다 상세한 문서를 작성하여 관리한다. 단계별 검증: 각 단계가 끝날 때마다 결과를 확인하고 다음 단계로 진행한다. 장점 이해하기 쉬움: 모델의 구조가 단순하고 직관적 관리 용이성: 각 단계가 명확히 구분되어 있어 프로젝트 관리가 용이 체계적 문서화: 각 단계마다 상세한 문서를 작성하므로 프로젝트의 진행 상황을 쉽게 파악할 수 있다 단점 변경 수용의 어려움: 요구사항 변경이나 오류 수정이 어렵다 늦은 결과 확인: 개발 후반부에 가서야 실제 동작하는 시스템을 볼 수 있다 유연성 부족: 각 단계가 엄격히 구분되어 있어 유연한 대응이 어렵다 적합한 프로젝트 유형 요구사항이 명확하고 변경이 적은 프로젝트에 적합
...</p></div><footer class=entry-footer><span title='2024-09-29 00:46:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Waterfall Model" href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/waterfall-model/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-development-model/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>