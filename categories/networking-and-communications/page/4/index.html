<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking and Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking and Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking and Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Networking and Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>웹훅 (Webhook)</h2></header><div class=entry-content><p>웹훅 (Webhook) 웹훅은 웹 애플리케이션에서 특정 이벤트가 발생했을 때 다른 애플리케이션에 실시간으로 정보를 전달하는 방법이다.
쉽게 말해, 어떤 일이 일어났을 때 자동으로 알림을 보내는 시스템이라고 생각하면 된다.
웹훅의 작동 원리 애플리케이션 A가 특정 URL(콜백 URL)을 애플리케이션 B에 등록한다. 애플리케이션 B에서 중요한 이벤트가 발생한다. 애플리케이션 B는 등록된 URL로 HTTP POST 요청을 보낸다. 애플리케이션 A는 이 요청을 받아 필요한 작업을 수행한다. 웹훅의 장점 실시간 업데이트: 이벤트 발생 즉시 알림을 받을 수 있다. 효율성: 필요할 때만 통신하므로 리소스 사용이 적다. 자동화: 이벤트에 따른 작업을 자동으로 처리할 수 있다. 웹훅의 단점 보안 문제: 콜백 URL이 노출될 경우 악의적인 요청을 받을 수 있다. 신뢰성: 네트워크 문제로 알림이 손실될 수 있다. 단방향 통신: 서버에서 클라이언트로의 통신만 가능하다. 웹훅의 사용 사례 결제 시스템: 결제 완료 시 즉시 알림 소셜 미디어: 새 게시물 작성 시 연동 서비스에 알림 버전 관리 시스템: 코드 변경 시 자동 빌드 시작 IoT: 센서 데이터가 특정 값을 초과할 때 알림 웹훅 구현 시 주의사항 보안: 요청의 출처를 반드시 확인해야 한다. 에러 처리: 네트워크 문제 등으로 인한 실패에 대비해야 한다. 재시도 메커니즘: 전송 실패 시 재시도 로직을 구현해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-20 06:46:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 웹훅 (Webhook)" href=https://buenhyden.github.io/posts/networking-and-communications/apis/webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</h2></header><div class=entry-content><p>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.
GraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-20 06:08:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC" href=https://buenhyden.github.io/til/2024/12/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming Vs Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-12-17 08:44:00 +0000 UTC'>December 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;256 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/til/2024/12/streaming-vs-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RDMA</h2></header><div class=entry-content><p>RDMA (Remote Direct Memory Access) 네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술
주요 특징:
낮은 지연 시간(Low Latency): CPU 개입 없이 메모리 간 직접 데이터 전송이 가능하므로, 전송 지연 시간이 매우 짧다. 높은 대역폭(High Bandwidth): 데이터 복사 과정이 없기 때문에 빠르고 효율적으로 대량의 데이터를 처리할 수 있다. 낮은 CPU 사용률(Low CPU Utilization): 데이터 전송 작업이 네트워크 어댑터(NIC)에서 이루어지기 때문에 CPU는 다른 작업에 집중할 수 있다. 제로-카피(Zero-Copy): 데이터가 중간 버퍼링 없이 메모리에서 바로 전송되므로, 데이터 복사로 인한 오버헤드가 없다. 효율성(Efficiency): 운영 체제와 CPU의 개입을 최소화하여 시스템 전체의 효율성을 높인다. 장점:
...</p></div><footer class=entry-footer><span title='2024-12-10 01:36:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDMA" href=https://buenhyden.github.io/posts/networking-and-communications/rdma/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events (SSE) 실시간 알림, 주식 시세, 실시간 점수 업데이트 등을 구현하기 위해서는 서버가 클라이언트에게 능동적으로 데이터를 보낼 수 있어야 한다.
이를 위한 기술 중 하나가 바로 SSE이다.
SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술이다.
WebSocket과 비교했을 때 더 단순하고 HTTP를 기반으로 하기 때문에 구현이 쉽다는 장점이 있다.
주요 특징 단방향 통신: SSE는 서버에서 클라이언트로의 단방향 통신만을 지원한다. HTTP 프로토콜 사용: SSE는 기존 HTTP 프로토콜을 사용하므로, 특별한 프로토콜이나 서버 설정이 필요하지 않다. 자동 재연결: 연결이 끊어졌을 때 브라우저가 자동으로 재연결을 시도한다. 개발자가 별도의 재연결 로직을 구현할 필요가 없다. 실시간 데이터 전송: 서버에서 발생하는 이벤트나 데이터 변경 사항을 클라이언트에게 실시간으로 전달할 수 있다. 장점 간단한 구현: WebSocket에 비해 구현이 더 간단하다. 브라우저 호환성: 대부분의 최신 브라우저에서 지원된다. 서버 부하 감소: HTTP 연결을 재사용하므로, WebSocket보다 서버 부하가 적을 수 있다. 방화벽 친화적: 기존 HTTP 프로토콜을 사용하므로 방화벽이나 프록시 서버와의 호환성이 좋다. 단점 단방향 통신: 양방향 통신이 필요한 경우에는 적합하지 않다. 연결 제한: 브라우저당 동시 SSE 연결 수에 제한이 있을 수 있다. IE 지원 부족: Internet Explorer에서는 지원되지 않는다. 동작 원리 클라이언트가 서버에 SSE 연결 요청을 보낸다. 서버는 클라이언트와 매핑되는 SSE 통신 객체(예: SseEmitter)를 생성한다. 서버에서 이벤트가 발생하면 해당 객체를 통해 클라이언트로 데이터를 전송한다. 활용사례 실시간 알림 시스템 주식 시세나 스포츠 점수 업데이트 소셜 미디어 피드 업데이트 로그 스트리밍 진행 상황 모니터링 고려사항 연결 관리:
...</p></div><footer class=entry-footer><span title='2024-11-30 06:18:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/networking-and-communications/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/networking-and-communications/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>