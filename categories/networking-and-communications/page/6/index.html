<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking and Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking and Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking and Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Networking and Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>WebRTC(Web Real-Time Communication) API</h2></header><div class=entry-content><p>WebRTC(Web Real-Time Communication) API WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술.
웹 브라우저 간에 실시간으로 음성, 영상, 데이터를 직접 주고받을 수 있게 해주는 기술로 기존의 웹 통신이 항상 서버를 거쳐야 했던 것과 달리, WebRTC는 브라우저 간 직접 통신(P2P)을 가능하게 한다.
핵심 구성 요소 WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술입니다. WebRTC API는 주로 세 가지 핵심 구성 요소로 이루어져 있습니다:
...</p></div><footer class=entry-footer><span title='2024-10-03 06:37:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebRTC(Web Real-Time Communication) API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/webrtc-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GraphQL API</h2></header><div class=entry-content><p>GraphQL API GraphQL은 API를 위한 쿼리 언어이자 서버 측 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청하고 받을 수 있게 해주는 강력한 도구.
2012년 Facebook에서 개발되어 2015년 공개된 GraphQL은 REST API의 한계를 극복하고자 설계되었습니다.
GraphQL의 주요 특징 선언적 데이터 fetching: 클라이언트가 필요한 데이터의 구조를 정확히 명시할 수 있습니다. 단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 전송됩니다. 강력한 타입 시스템: 스키마를 통해 데이터 구조를 명확히 정의합니다. 실시간 업데이트: Subscription을 통해 실시간 데이터 업데이트를 지원합니다. 효율적인 데이터 전송: Over-fetching과 Under-fetching 문제를 해결합니다. GraphQL의 주요 구성 요소 스키마 (Schema)
GraphQL API의 타입 시스템을 정의합니다.
사용 가능한 쿼리, 뮤테이션, 구독 및 사용자 정의 타입을 명시합니다.
...</p></div><footer class=entry-footer><span title='2024-10-03 03:22:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;449 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/graphql-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC API</h2></header><div class=entry-content><p>gRPC API gRPC(gRPC Remote Procedure Call)는 Google에서 개발한 오픈소스 원격 프로시저 호출(RPC) 시스템.
이 시스템은 효율적이고 빠른 서비스 간 통신을 제공하며, 다양한 프로그래밍 언어와 플랫폼에서 사용할 수 있다.
gRPC는 특히 다음과 같은 상황에서 유용하다:
마이크로서비스 아키텍처 서비스 간 효율적인 통신 강력한 타입 안정성 뛰어난 성능 실시간 통신이 필요한 시스템 채팅 애플리케이션 실시간 모니터링 게임 서버 모바일 애플리케이션 효율적인 데이터 전송 배터리 사용량 최적화 네트워크 대역폭 절약 gRPC의 주요 특징 Protocol Buffers 사용: gRPC는 데이터 직렬화를 위해 Protocol Buffers를 사용합니다. 이는 JSON이나 XML보다 더 작고 빠른 데이터 포맷을 제공합니다. HTTP/2 기반: HTTP/2 프로토콜을 사용하여 높은 성능과 낮은 지연 시간을 제공합니다. 양방향 스트리밍: 클라이언트와 서버 간의 양방향 스트리밍을 지원하여 실시간 데이터 교환이 가능합니다. 다양한 언어 지원: Java, Python, Go, C++, Ruby 등 다양한 프로그래밍 언어를 지원합니다. 강력한 타입 시스템: Protocol Buffers를 통해 강력한 타입 시스템을 제공하여 타입 안정성을 보장합니다. gRPC 작동 방식 서비스 정의:.proto 파일에 서비스와 메시지 구조를 정의합니다. 코드 생성: Protocol Buffer 컴파일러를 사용하여 서버와 클라이언트 코드를 자동으로 생성합니다. 서버 구현: 생성된 코드를 기반으로 서버 비즈니스 로직을 구현합니다. 클라이언트 구현: 생성된 클라이언트 코드를 사용하여 서버와 통신합니다. gRPC의 통신 유형 Unary RPC: 클라이언트가 단일 요청을 보내고 서버가 단일 응답을 반환합니다.
...</p></div><footer class=entry-footer><span title='2024-10-03 03:22:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;344 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RESTful API</h2></header><div class=entry-content><p>RESTful API(Representational State Transfer API) 웹 서비스를 설계하고 구현하기 위한 아키텍처 스타일
RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 간의 통신을 위한 표준화된 방식을 제공한다.
RESTful API의 주요 특징 자원 중심 구조: URI를 통해 자원을 명확하게 표현합니다. HTTP 메서드 활용: GET, POST, PUT, DELETE 등의 HTTP 메서드를 사용하여 자원에 대한 CRUD 작업을 수행합니다. 무상태성(Stateless): 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 균일한 인터페이스: 일관된 방식으로 자원에 접근할 수 있습니다. 설계 원칙 자원 식별: URI를 통해 자원을 명확하게 식별합니다. HTTP 메서드 사용: 적절한 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다. 자체 설명적 메시지: 요청과 응답은 자체적으로 이해할 수 있어야 합니다. HATEOAS(Hypermedia as the Engine of Application State): 응답에 관련 리소스의 링크를 포함합니다. 주요 제약 조건 클라이언트-서버 구조를 통해 관심사를 분리합니다. 이는 클라이언트와 서버가 독립적으로 발전할 수 있게 해줍니다. 예를 들어, 서버는 데이터 저장 방식을 변경할 수 있고, 클라이언트는 사용자 인터페이스를 개선할 수 있습니다. 무상태성(Stateless)을 유지합니다. 각 요청은 이전 요청과 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 이는 시스템의 확장성을 높여주지만, 매 요청마다 필요한 모든 정보를 포함해야 한다는 의미이기도 합니다. 캐시 가능성을 제공합니다. HTTP의 캐싱 메커니즘을 활용하여 성능을 개선할 수 있습니다. 예를 들어, 자주 변경되지 않는 사용자 프로필 이미지는 클라이언트에서 캐시할 수 있습니다. RESTful API 구현 예시 다음은 Node.js와 Express.js를 사용한 간단한 RESTful API 예제입니다:
...</p></div><footer class=entry-footer><span title='2024-10-03 03:21:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;482 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SOAP API</h2></header><div class=entry-content><p>SOAP API SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜.
분산 환경에서 데이터를 교환하기 위해 설계된 웹 서비스 통신 방식.
SOAP API의 주요 특징 XML 기반: 모든 SOAP 메시지는 XML 형식으로 구성됩니다. 프로토콜 독립성: HTTP, SMTP 등 다양한 프로토콜을 통해 전송될 수 있습니다. 표준화: 잘 정의된 표준을 따르며, 이는 다양한 플랫폼과 언어 간의 호환성을 보장합니다. 보안성: WS-Security와 같은 웹 서비스 보안 표준을 지원합니다. SOAP 메시지 구조 SOAP 메시지는 다음과 같은 요소로 구성됩니다:
...</p></div><footer class=entry-footer><span title='2024-10-03 03:21:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/networking-and-communications/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/networking-and-communications/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>