<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Networking and Communications | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/networking-and-communications/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/networking-and-communications/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/networking-and-communications/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/networking-and-communications/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Networking and Communications"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Networking and Communications"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Networking and Communications</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming Vs Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-12-17 08:44:00 +0000 UTC'>December 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;256 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/til/2024/12/streaming-vs-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-12-10 02:43:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RDMA</h2></header><div class=entry-content><p>RDMA (Remote Direct Memory Access) 네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술
주요 특징:
낮은 지연 시간(Low Latency): CPU 개입 없이 메모리 간 직접 데이터 전송이 가능하므로, 전송 지연 시간이 매우 짧다. 높은 대역폭(High Bandwidth): 데이터 복사 과정이 없기 때문에 빠르고 효율적으로 대량의 데이터를 처리할 수 있다. 낮은 CPU 사용률(Low CPU Utilization): 데이터 전송 작업이 네트워크 어댑터(NIC)에서 이루어지기 때문에 CPU는 다른 작업에 집중할 수 있다. 제로-카피(Zero-Copy): 데이터가 중간 버퍼링 없이 메모리에서 바로 전송되므로, 데이터 복사로 인한 오버헤드가 없다. 효율성(Efficiency): 운영 체제와 CPU의 개입을 최소화하여 시스템 전체의 효율성을 높인다. 장점:
...</p></div><footer class=entry-footer><span title='2024-12-10 01:36:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDMA" href=https://buenhyden.github.io/posts/networking-and-communications/rdma/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>쓰로틀링 (Throttling)</h2></header><div class=entry-content><p>쓰로틀링 (Throttling) 쓰로틀링(Throttling)은 시스템이나 리소스의 과도한 사용을 제어하고 관리하는 기술이다.
특정 시간 동안 처리할 수 있는 요청의 수나 데이터의 양을 제한함으로써 시스템의 과부하를 방지하고 안정적인 서비스를 제공하는 것이 주요 목적이다.
작동 방식 지정된 시간 간격 내에 허용된 요청 수를 초과하면 추가 요청을 거부하거나 지연시킨다. 예를 들어, 초당 1000개의 요청만 허용한다면 그 이상의 요청은 throttle된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ThrottlingController { private final int MAX_REQUESTS_PER_SECOND = 1000; private final Queue&lt;Long> requestTimestamps = new LinkedList&lt;>(); public boolean isRequestAllowed() { long currentTime = System.currentTimeMillis(); // 1초가 지난 타임스탬프 제거 while (!requestTimestamps.isEmpty() && requestTimestamps.peek() &lt; currentTime - 1000) { requestTimestamps.poll(); } // 현재 요청 수가 제한보다 적으면 허용 if (requestTimestamps.size() &lt; MAX_REQUESTS_PER_SECOND) { requestTimestamps.offer(currentTime); return true; } return false; } } 주요 용도 API 사용량 제한 서버 리소스 보호 DDoS 공격 방지 네트워크 트래픽 관리 쓰로틀링의 주요 유형 Rate Limiting (비율 제한)
...</p></div><footer class=entry-footer><span title='2024-12-06 04:14:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;590 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쓰로틀링 (Throttling)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events (SSE) 실시간 알림, 주식 시세, 실시간 점수 업데이트 등을 구현하기 위해서는 서버가 클라이언트에게 능동적으로 데이터를 보낼 수 있어야 한다.
이를 위한 기술 중 하나가 바로 SSE이다.
SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술이다.
WebSocket과 비교했을 때 더 단순하고 HTTP를 기반으로 하기 때문에 구현이 쉽다는 장점이 있다.
주요 특징 단방향 통신: SSE는 서버에서 클라이언트로의 단방향 통신만을 지원한다. HTTP 프로토콜 사용: SSE는 기존 HTTP 프로토콜을 사용하므로, 특별한 프로토콜이나 서버 설정이 필요하지 않다. 자동 재연결: 연결이 끊어졌을 때 브라우저가 자동으로 재연결을 시도한다. 개발자가 별도의 재연결 로직을 구현할 필요가 없다. 실시간 데이터 전송: 서버에서 발생하는 이벤트나 데이터 변경 사항을 클라이언트에게 실시간으로 전달할 수 있다. 장점 간단한 구현: WebSocket에 비해 구현이 더 간단하다. 브라우저 호환성: 대부분의 최신 브라우저에서 지원된다. 서버 부하 감소: HTTP 연결을 재사용하므로, WebSocket보다 서버 부하가 적을 수 있다. 방화벽 친화적: 기존 HTTP 프로토콜을 사용하므로 방화벽이나 프록시 서버와의 호환성이 좋다. 단점 단방향 통신: 양방향 통신이 필요한 경우에는 적합하지 않다. 연결 제한: 브라우저당 동시 SSE 연결 수에 제한이 있을 수 있다. IE 지원 부족: Internet Explorer에서는 지원되지 않는다. 동작 원리 클라이언트가 서버에 SSE 연결 요청을 보낸다. 서버는 클라이언트와 매핑되는 SSE 통신 객체(예: SseEmitter)를 생성한다. 서버에서 이벤트가 발생하면 해당 객체를 통해 클라이언트로 데이터를 전송한다. 활용사례 실시간 알림 시스템 주식 시세나 스포츠 점수 업데이트 소셜 미디어 피드 업데이트 로그 스트리밍 진행 상황 모니터링 고려사항 연결 관리:
...</p></div><footer class=entry-footer><span title='2024-11-30 06:18:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/networking-and-communications/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/networking-and-communications/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>