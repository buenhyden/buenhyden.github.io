<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tools | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/tools/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/tools/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/tools/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/tools/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Tools"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Tools"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Tools</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.
기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/kafka/kafka-vs-rabbitmq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. Kafka</h2></header><div class=entry-content><p>Apache Pulsar vs. Kafka 분산 메시징 시스템은 현대 데이터 중심 아키텍처의 중추 역할을 한다.
기본 개념 및 역사 Apache Kafka Apache Kafka는 2011년 LinkedIn에서 개발된 후 Apache 소프트웨어 재단으로 이관된 분산 스트리밍 플랫폼이다. 처음에는 LinkedIn 내부의 데이터 파이프라인 문제를 해결하기 위해 만들어졌지만, 이후 업계 표준 메시징 시스템으로 자리 잡았다. Kafka는 높은 처리량, 내구성, 확장성을 제공하는 로그 기반의 발행-구독(pub-sub) 메시징 시스템이다.
Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년에 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 다중 테넌트, 고성능 서비스로 설계되었으며, Kafka와 같은 발행-구독 메시징 시스템의 특성과 전통적인 메시지 큐의 장점을 결합했다. Pulsar는 처음부터 클라우드 네이티브 환경을 염두에 두고 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. Kafka" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/apache-pulsar/apache-pulsar-vs-kafka/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. RabbitMQ</h2></header><div class=entry-content><p>Apache Pulsar vs. RabbitMQ Apache Pulsar와 RabbitMQ는 메시징 시스템으로서 각각 고유한 강점과 약점을 가지고 있으며, 사용 사례에 따라 적합한 선택이 달라질 수 있다.
기본 개념 및 역사 Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 처음부터 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다.
RabbitMQ RabbitMQ는 2007년 Rabbit Technologies Ltd.에서 개발되었으며, 현재는 VMware의 일부인 Pivotal Software에서 관리되고 있다. Erlang으로 작성된 RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다. 신뢰성, 유연성, 상호 운용성에 중점을 두고 설계되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/tools/apache-pulsar/apache-pulsar-vs-rabbitmq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Portainer</h2></header><div class=entry-content><p>Portainer란? 컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구
개요 Docker, Kubernetes 등 다양한 컨테이너 플랫폼을 지원하는 범용 컨테이너 관리 솔루션 직관적인 웹 인터페이스를 통해 컨테이너 환경의 복잡성을 단순화 100만 명 이상의 사용자와 30,000개 이상의 GitHub 스타를 보유한 인기 있는 도구 주요 특징과 기능 컨테이너 관리: 컨테이너의 배포, 시작, 중지, 로그 확인 등을 GUI로 수행 스택 배포: Docker Compose를 사용한 멀티 컨테이너 애플리케이션 배포 지원 볼륨 및 네트워크 관리: 데이터 저장소와 네트워크 구성 관리 이미지 관리: Docker 레지스트리 연동 및 이미지 관리 리소스 모니터링: CPU, 메모리 사용량 등 컨테이너 성능 모니터링 템플릿: 미리 정의된 애플리케이션 템플릿을 통한 간편한 배포 장점 사용 편의성: 명령줄 지식 없이도 컨테이너 관리 가능 중앙 집중식 관리: 여러 Docker 환경을 단일 인터페이스에서 관리 보안 강화: 사용자 및 팀 단위의 접근 제어 기능 제공 확장성: 소규모 프로젝트부터 대규모 엔터프라이즈 환경까지 지원 버전 Community Edition (CE): 무료 오픈소스 버전 Business Edition (BE): 기업용 고급 기능(보안, 감사 등) 제공 버전 Portainer 설치 Host간 볼륨 매칭을 위한 디렉토리 생성 1 mkdir -p /kubernetes/portainer_data Portainerdmf docker run 명령어를 통해 docker에 설치
위에서 생성한 폴더와 마운트 1 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /kubernetes/portainer_data:/data portainer/portainer-ce:latest Portainer 로그인
웹브라우저 Portainer 서버(예: http://서버IP:9000)에 접근
[처음 접속시]
username과 password 입력
Source: hyunyoun
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Portainer" href=https://buenhyden.github.io/posts/devops/virtualization/containerization/tools/portainer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VMware</h2></header><div class=entry-content><p>VMware 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구
회사 및 라이선스:
VMware, Inc.에서 개발 대부분 유료 소프트웨어이며, 일부 제품(VMware Workstation Player)만 개인용으로 무료 제공 성능 및 기능:
일반적으로 성능이 우수하며, 최적화된 자원 관리 제공 고급 기능(스냅샷, 클론, 3D 가속, 암호화된 VM 등) 지원 vSphere를 통한 고급 네트워크 기능 제공 호환성:
Windows, macOS (Fusion), Linux 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
직관적이고 사용하기 쉬운 인터페이스 제공 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 12:55:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VMware" href=https://buenhyden.github.io/posts/devops/virtualization/tools/vmware/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VirtualBox</h2></header><div class=entry-content><p>Virtual Box 가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구.
회사 및 라이선스:
Oracle Corporation에서 개발 오픈 소스 소프트웨어로, 기본 버전은 무료로 사용 가능 성능 및 기능:
VMware에 비해 성능이 다소 떨어질 수 있음 기본적인 가상화 기능(스냅샷, 클론, 3D 가속 등) 제공 일부 고급 기능은 확장 팩 설치 필요 호환성:
Windows, macOS, Linux, Solaris 등 다양한 호스트 및 게스트 OS 지원 사용자 인터페이스:
비교적 간단한 인터페이스 제공, 일부 기능은 탐색이 어려울 수 있음 지원:
...</p></div><footer class=entry-footer><span title='2024-11-11 04:54:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VirtualBox" href=https://buenhyden.github.io/posts/devops/virtualization/tools/virtualbox/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Airflow</h2></header><div class=entry-content><p>Airflow Apache Airflow는 데이터 파이프라인을 구축, 관리, 모니터링하기 위한 오픈소스 플랫폼이다.
Airflow는 복잡한 데이터 파이프라인을 효율적으로 관리할 수 있게 해주는 강력한 도구이다.
데이터 엔지니어링 분야에서 널리 사용되며, 지속적으로 발전하고 있는 플랫폼이다.
기본적인 DAG(Directed Acyclic Graph) 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from airflow import DAG from airflow.operators.python import PythonOperator from datetime import datetime, timedelta # DAG 기본 설정 default_args = { 'owner': 'data_engineer', 'depends_on_past': False, 'start_date': datetime(2024, 1, 1), 'email': ['alert@example.com'], 'email_on_failure': True, 'retries': 1, 'retry_delay': timedelta(minutes=5) } # DAG 정의 dag = DAG( 'data_processing_pipeline', default_args=default_args, description='데이터 처리 파이프라인', schedule_interval='0 0 * * *' # 매일 자정에 실행 ) # 태스크 함수 정의 def extract_data(**context): # 데이터 추출 로직 raw_data = {'data': 'extracted_value'} context['task_instance'].xcom_push(key='raw_data', value=raw_data) def transform_data(**context): # 데이터 변환 로직 raw_data = context['task_instance'].xcom_pull(key='raw_data') transformed_data = {'data': f"transformed_{raw_data['data']}"} context['task_instance'].xcom_push(key='transformed_data', value=transformed_data) def load_data(**context): # 데이터 적재 로직 transformed_data = context['task_instance'].xcom_pull(key='transformed_data') print(f"Loading data: {transformed_data}") # 태스크 생성 extract_task = PythonOperator( task_id='extract_data', python_callable=extract_data, provide_context=True, dag=dag ) transform_task = PythonOperator( task_id='transform_data', python_callable=transform_data, provide_context=True, dag=dag ) load_task = PythonOperator( task_id='load_data', python_callable=load_data, provide_context=True, dag=dag ) # 태스크 의존성 설정 extract_task >> transform_task >> load_task Airflow의 주요 특징 Python 기반: DAG(Directed Acyclic Graph)를 Python 코드로 정의할 수 있어 유연성과 확장성이 뛰어나다. 스케줄링: 복잡한 워크플로우를 쉽게 스케줄링할 수 있다. 모니터링: 웹 인터페이스를 통해 작업 실행 상태를 실시간으로 모니터링할 수 있다. 확장성: 다양한 외부 시스템과 쉽게 통합할 수 있다. Airflow의 주요 구성 요소 DAG (Directed Acyclic Graph):
...</p></div><footer class=entry-footer><span title='2024-10-26 05:18:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Airflow" href=https://buenhyden.github.io/posts/data/data-engineering/data-pipelines/tools/airflow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git 원격 저장소와 Branch</h2></header><div class=entry-content><p>Git의 원격 저장소와 Branch 원격 저장소와 협업 원격 저장소 기본 명령어 명령어 설명 사용 예시 git remote 원격 저장소 목록 조회 git remote git remote -v 상세 정보(URL) 조회 git remote -v git remote add 원격 저장소 추가 git remote add origin &lt;url> git remote rename 원격 저장소 이름 변경 git remote rename old new git remote remove 원격 저장소 삭제 git remote remove name 원격 저장소 목록 조회 git remote 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git 원격 저장소와 Branch" href=https://buenhyden.github.io/posts/devops/version-control-systems/tools/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Git의 고급 기능</h2></header><div class=entry-content><p>Git의 고급 기능 태그 프로젝트의 특정 시점을 표시하는 중요한 기능
릴리스 버전 관리나 중요한 커밋 지점을 식별하기 위해 사용된다.
두 가지 종류의 태그가 있으며 각각의 사용 목적과 특징이 다르다.
1 2 3 $ git tag v0.1 v1.3 태그의 종류 Lightweight 태그 특정 커밋에 대한 참조로 단순히 커밋에 이름을 부여하는 형태이다. 커밋 체크섬만을 저장한다. Annotated 태그 태그 생성자 정보, 날짜, 메시지 등 추가 메타데이터를 저장한다. Git 데이터베이스에 완전한 객체로 저장된다. 태그 생성하기 Lightweight 태그
Lightweight 태그를 만들 때는 -a, -s, -m 옵션을 사용하지 않는다.
git tag &lt;tagname> 1 git tag v1.0.0 Annotated 태그
tag 명령을 실행할 때 -a 옵션을 추가
-m 옵션으로 태그를 저장할 때 메시지를 함께 저장할 수 있다.
git tag -a &lt;tagname> -m "Message" 1 2 3 4 5 $ git tag -a v1.4 -m "my version 1.4" $ git tag v0.1 v1.3 v1.4 특정 커밋에 태그 생성 예전 커밋에 대해서도 태그할 수 있다. 커밋 히스토리는 아래와 같다고 가정한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git의 고급 기능" href=https://buenhyden.github.io/posts/devops/version-control-systems/tools/git/git%EC%9D%98-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI</h2></header><div class=entry-content><p>Gitlab CI GitLab에 내장된 지속적 통합/배포 도구로, .gitlab-ci.yml 파일을 통해 파이프라인을 정의하고 관리
특징 통합성: GitLab 저장소와 긴밀하게 통합되어 있어 별도의 도구 없이 CI/CD 파이프라인을 구축할 수 있습니다. 유연성: YAML 파일을 통해 파이프라인을 구성할 수 있어 다양한 프로젝트 요구사항에 맞춤 설정이 가능합니다. 확장성: 다양한 Runner 유형을 지원하여 다양한 환경에서 작업을 실행할 수 있습니다. 가시성: 파이프라인 실행 상태와 결과를 GitLab 인터페이스에서 쉽게 확인할 수 있습니다. 기능 자동 빌드 및 테스트: 코드 변경 시 자동으로 빌드 및 테스트를 실행합니다. 환경 배포: 다양한 환경(개발, 스테이징, 프로덕션 등)에 자동으로 배포할 수 있습니다. 아티팩트 관리: 빌드 결과물을 저장하고 관리할 수 있습니다. 병렬 실행: 여러 작업을 동시에 실행하여 파이프라인 속도를 향상시킵니다. 환경 변수 관리: 민감한 정보를 안전하게 저장하고 사용할 수 있습니다. 구성요소 .gitlab-ci.yml: 파이프라인 구성 파일 Runners: 작업을 실행하는 에이전트 Jobs: 실행할 개별 작업 Stages: 작업의 실행 순서를 정의하는 단계 Pipeline: 전체 CI/CD 프로세스 장점 GitLab과의 긴밀한 통합 쉬운 설정과 사용 확장성과 유연성 무료로 사용 가능한 기능이 많음 단점 GitLab에 종속적 복잡한 워크플로우의 경우 설정이 복잡해질 수 있음 일부 고급 기능은 유료 버전에서만 사용 가능 설정 방법 프로젝트 루트에.gitlab-ci.yml 파일 생성 YAML 형식으로 파이프라인 구성 작성 변경사항을 커밋하고 푸시 GitLab에서 파이프라인 실행 확인 .gitlab-ci.yml 파일의 기본 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 stages: - build - test - deploy job1: stage: build script: - echo "Building the project..." job2: stage: test script: - echo "Running tests..." job3: stage: deploy script: - echo "Deploying to production..." 주요 구성 요소 stages: 파이프라인의 실행 단계를 정의합니다. 각 단계는 순차적으로 실행됩니다. jobs: 각 작업을 정의합니다. 작업은 특정 단계에 속하며, 실행할 스크립트를 포함합니다. script: 작업에서 실행할 명령어들을 정의합니다. image: 작업을 실행할 Docker 이미지를 지정합니다. artifacts: 작업 결과물을 저장하고 다른 작업에서 사용할 수 있게 합니다. cache: 작업 간에 공유할 파일이나 디렉토리를 지정합니다. 고급 구성 옵션 only/except: 특정 브랜치나 태그에서만 작업을 실행하거나 제외할 수 있습니다. variables: 파이프라인 전체 또는 특정 작업에서 사용할 변수를 정의합니다. before_script/after_script: 작업 실행 전후에 실행할 스크립트를 정의합니다. environment: 배포 환경을 지정합니다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 파이프라인 단계 정의 stages: - build - test - deploy # 캐시 설정: node_modules 폴더를 캐시하여 빌드 속도 향상 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build image: node:14 # Node.js 14 버전 이미지 사용 script: - npm install # 의존성 설치 - npm run build # 프로젝트 빌드 artifacts: paths: - dist/ # 빌드 결과물 저장 # 테스트 작업 정의 test: stage: test image: node:14 script: - npm install # 의존성 설치 - npm test # 테스트 실행 # 배포 작업 정의 deploy: stage: deploy image: alpine:latest script: - apk add --no-cache rsync openssh # 배포에 필요한 도구 설치 - mkdir -p ~/.ssh - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_SERVER_IP:/path/to/deployment/ only: - master # master 브랜치에 푸시될 때만 실행 stages: 파이프라인의 단계를 정의합니다. 여기서는 build, test, deploy 세 단계로 구성됩니다. cache: node_modules 폴더를 캐시하여 빌드 속도를 향상시킵니다. build 작업: stage: build로 빌드 단계에 할당합니다. Node.js 14 버전 이미지를 사용합니다. npm install로 의존성을 설치하고, npm run build로 프로젝트를 빌드합니다. artifacts를 사용하여 빌드 결과물을 저장합니다. test 작업: stage: test로 테스트 단계에 할당합니다. npm test 명령으로 테스트를 실행합니다. deploy 작업: stage: deploy로 배포 단계에 할당합니다. Alpine Linux 이미지를 사용하여 가벼운 환경을 구성합니다. SSH 키를 설정하고 rsync를 사용하여 빌드 결과물을 서버에 배포합니다. only: - master로 master 브랜치에 푸시될 때만 실행되도록 설정합니다. 기본 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # GitLab CI의 기본 설정 예시 image: node:16 # 기본 Docker 이미지 지정 # 파이프라인 스테이지 정의 stages: - build - test - deploy # 캐시 설정 - node_modules 디렉토리를 캐시 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build # 속한 스테이지 지정 script: - npm install # 의존성 설치 - npm run build # 빌드 실행 artifacts: # 빌드 결과물 저장 paths: - dist/ # 테스트 작업 정의 test: stage: test script: - npm run test # 테스트 실행 dependencies: # build 작업의 결과물 사용 - build # 배포 작업 정의 deploy: stage: deploy script: - echo "Deploying application…" - npm run deploy only: # main 브랜치에서만 실행 - main 고급 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 환경변수와 조건부 실행이 포함된 고급 설정 예시 variables: DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG # Docker 이미지 태그 정의 # 커스텀 도커 이미지 빌드 build_image: image: docker:20.10.16 services: - docker:20.10.16-dind # Docker-in-Docker 서비스 stage: build script: # Docker 레지스트리 로그인 - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Docker 이미지 빌드 및 푸시 - docker build -t $DOCKER_IMAGE . - docker push $DOCKER_IMAGE rules: - if: $CI_COMMIT_BRANCH == "main" # main 브랜치에서만 실행 when: always - when: never # 그 외의 경우 실행하지 않음 # 보안 스캔 작업 security_scan: image: security-scanner stage: test script: - scan-dependencies # 의존성 취약점 검사 - scan-code # 코드 보안 검사 allow_failure: true # 실패해도 파이프라인 계속 진행 # 스테이징 환경 배포 deploy_staging: stage: deploy environment: name: staging script: - deploy-to-kubernetes.sh --env staging rules: - if: $CI_COMMIT_BRANCH == "develop" 환경별 배포 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 환경별 배포 구성 예시 .deploy_template: &amp;deploy_template # 재사용 가능한 배포 템플릿 정의 script: - echo "Deploying to $CI_ENVIRONMENT_NAME" - kubectl apply -f k8s/$CI_ENVIRONMENT_NAME/ deploy_dev: &lt;&lt;: *deploy_template # 템플릿 상속 environment: name: development rules: - if: $CI_COMMIT_BRANCH == "develop" deploy_prod: &lt;&lt;: *deploy_template environment: name: production rules: - if: $CI_COMMIT_BRANCH == "main" when: manual # 수동 승인 후 배포 병렬 작업 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 병렬 테스트 실행 예시 test: parallel: 3 # 3개의 병렬 작업 생성 script: - npm run test -- --split=$CI_NODE_INDEX/$CI_NODE_TOTAL # 매트릭스 작업 정의 test_matrix: parallel: matrix: - NODE_VERSION: ["14", "16", "18"] DB_TYPE: ["mysql", "postgres"] script: - docker-compose run --rm -e NODE_VERSION=$NODE_VERSION -e DB_TYPE=$DB_TYPE test 캐시와 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 캐시와 아티팩트 관리 예시 build: cache: key: ${CI_COMMIT_REF_SLUG} # 브랜치별 캐시 키 paths: - node_modules/ - .npm/ policy: pull-push # 캐시 정책 설정 artifacts: paths: - dist/ # 빌드 결과물 - coverage/ # 테스트 커버리지 리포트 reports: junit: test-results.xml # 테스트 결과 리포트 coverage: coverage/lcov.info # 커버리지 리포트 expire_in: 1 week # 아티팩트 유효 기간 이러한 설정들은 프로젝트의 요구사항과 규모에 따라 적절히 조정하여 사용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gitlab CI" href=https://buenhyden.github.io/posts/devops/ci-and-cd/tools/gitlab-ci/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>