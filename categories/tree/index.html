<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tree | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/tree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/tree/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/tree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Tree"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Tree"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Tree</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Octree</h2></header><div class=entry-content><p>Octree Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.
각 노드는 공간의 한 영역을 나타내며, 필요에 따라 더 작은 영역으로 세분화된다.
![Octree](Octree2.png “https://ko.wikipedia.org/wiki/%ED%8C%94%EC%A7%84%ED%8A%B8%EB%A6%AC#/media/%ED%8C%8C%EC%9D%BC:Octree2.png _
특징 계층적 구조: 공간을 재귀적으로 분할하여 계층적으로 표현한다. 적응적 해상도: 필요한 영역만 세밀하게 분할하여 효율적인 공간 표현이 가능하다. 8분할: 각 노드는 최대 8개의 자식 노드를 가질 수 있다. 장점 효율적인 공간 표현: 복잡한 3차원 구조를 효율적으로 표현할 수 있다. 빠른 검색: 계층 구조를 활용하여 특정 영역의 빠른 검색이 가능하다. 메모리 효율성: 균일하지 않은 데이터 분포에 대해 메모리를 효율적으로 사용한다. 단점 구현 복잡성: 구현과 관리가 상대적으로 복잡할 수 있다. 메모리 오버헤드: 트리 구조로 인한 추가적인 메모리 사용이 발생할 수 있다. 불균형 가능성: 데이터 분포에 따라 트리가 불균형해질 수 있다. 응용 3D 컴퓨터 그래픽스: 3D 모델링, 렌더링, 충돌 감지 등에 사용된다. 로보틱스: 3D 환경 매핑 및 경로 계획에 활용된다. 게임 개발: 3D 게임 월드의 효율적인 표현과 관리에 사용된다. 과학 시뮬레이션: 대규모 3D 시뮬레이션에서 공간 데이터 관리에 활용된다. 동작 원리 초기화: 전체 3D 공간을 포함하는 루트 노드로 시작한다. 분할: 필요에 따라 각 노드를 8개의 자식 노드로 분할한다. 데이터 할당: 각 노드에 해당 영역의 데이터를 할당한다. 재귀적 분할: 특정 조건(예: 데이터 밀도, 깊이 제한)을 만족할 때까지 2-3 과정을 반복한다. 구성 요소 노드: 3D 공간의 한 영역을 나타내며, 데이터와 자식 노드에 대한 참조를 포함한다. 루트 노드: 전체 3D 공간을 나타내는 최상위 노드이다. 내부 노드: 8개의 자식 노드를 가질 수 있는 중간 노드이다. 리프 노드: 더 이상 분할되지 않는 최하위 노드로, 실제 데이터를 저장한다. 구현 방식 Octree의 기본적인 구현은 재귀적인 트리 구조를 사용한다.
다음은 Python을 사용한 간단한 Octree 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:57:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;490 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Octree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/octree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Splay Tree</h2></header><div class=entry-content><p>Splay Tree Splay Tree는 이진 검색 트리(Binary Search Tree)의 한 종류로, 데이터를 저장하고 효율적으로 검색, 삽입, 삭제할 수 있는 구조를 가지고 있다.
데이터베이스, 캐시 관리, 네트워크 라우팅 등 다양한 응용 분야에서 사용된다.
Splay Tree는 자체 균형 이진 검색 트리의 일종으로, 최근에 접근한 노드를 루트로 이동시키는 “splay” 연산을 통해 자가 조정되는 특징을 가진다.
특징 자체 균형: splay 연산을 통해 트리의 균형을 유지한다. 최근 접근 노드 최적화: 자주 접근하는 노드를 루트 근처로 이동시켜 빠른 접근을 가능하게 한다. 동적 구조: 삽입, 삭제, 검색 연산 후 트리 구조가 변경된다. 장점 구현이 상대적으로 단순하다. 자주 접근하는 데이터에 대해 빠른 접근 속도를 제공한다. 추가적인 균형 정보 저장이 필요 없다. 단점 최악의 경우 트리의 높이가 O(n)이 될 수 있다. 연산마다 트리 구조가 변경되어 예측이 어려울 수 있다. 응용 캐시 관리: 최근 접근 데이터의 빠른 검색에 활용. 네트워크 라우팅: IP 라우팅 테이블 관리. 자동 완성 및 검색 엔진: 빠른 검색 결과 제공. Garbage Collector 알고리즘. 동작 원리 Splay Tree의 핵심 동작은 “splay” 연산이다.
이 연산은 다음과 같은 단계로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:57:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;640 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Splay Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/splay-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fenwick Tree</h2></header><div class=entry-content><p>Fenwick Tree (Binary Indexed Tree, BIT) Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.
1994년 Peter M. Fenwick에 의해 제안되었다.
데이터를 저장하고 조작하는 방식을 정의하며, 특정 연산을 효율적으로 수행할 수 있게 해줍니다.
https://en.wikipedia.org/wiki/Fenwick_tree#/media/File:16-node_Fenwick_tree.svg
일반적인 트리와 달리, 배열을 사용하여 이진 트리를 암시적으로 표현한다.
각 인덱스는 이진수 표현에서 마지막 1의 위치에 따라 관리하는 구간의 크기가 결정된다.
...</p></div><footer class=entry-footer><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fenwick Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Segment Tree</h2></header><div class=entry-content><p>Segment Tree 세그먼트 트리는 구간 또는 범위에 대한 정보를 저장하고 관리하는 트리 형태의 자료구조이다. 데이터베이스, 파일 시스템, 네트워크 라우팅 등 다양한 응용 프로그램에서 사용되며, 효율적인 구간 쿼리와 업데이트 연산을 제공하는 특수한 데이터 구조이다.
https://www.geeksforgeeks.org/segment-tree-data-structure/
특징 완전 이진 트리 구조를 가진다. 각 노드는 배열의 특정 구간에 대한 정보를 저장한다. 리프 노드는 배열의 개별 원소를 나타낸다. 부모 노드는 자식 노드들의 정보를 결합한 값을 저장한다. 장점 구간 쿼리의 시간 복잡도가 O(log n)으로 매우 효율적이다. 데이터 업데이트 시 O(log n) 시간에 트리를 갱신할 수 있다. 동적인 상황에서도 효율적으로 작동한다. 단점 일반 배열에 비해 더 많은 메모리를 사용한다 (약 4n의 공간 복잡도). 구현이 상대적으로 복잡할 수 있다. 응용 데이터베이스 시스템의 범위 쿼리 최적화 컴퓨터 그래픽스의 렌더링 최적화 네트워크 라우팅 테이블 관리 금융 데이터 분석의 구간 통계 계산 동작 원리 트리 구축 (Build):
...</p></div><footer class=entry-footer><span title='2024-10-11 12:56:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;861 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Segment Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AVL 트리 (AVL tree)</h2></header><div class=entry-content><p>AVL 트리 (AVL tree) AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리(self-balancing binary search tree)이다.
각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.
정렬된 정보의 빠른 저장과 검색을 위해 사용되는 자료구조이다.
https://en.wikipedia.org/wiki/AVL_tree
특징 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이(균형 인수)가 -1, 0, 1 중 하나이다. 트리의 높이는 항상 O(log N)을 유지한다 (N은 노드의 수). 자체 균형 기능으로 삽입, 삭제, 검색 연산의 시간 복잡도가 O(log N)으로 보장된다. 장점 검색, 삽입, 삭제 연산의 시간 복잡도가 O(log N)으로 보장된다. 트리의 균형을 유지하여 최악의 경우에도 효율적인 성능을 제공한다. 레드-블랙 트리에 비해 더 엄격한 균형을 유지하여 검색 작업에 더 효율적이다. 응용 데이터베이스 인덱싱 메모리 관리 시스템 파일 시스템 구현 맵(Map)과 셋(Set) 자료구조 구현 동작 원리 삽입: 새 노드를 일반 이진 검색 트리처럼 삽입한 후, 균형 인수를 확인하고 필요시 회전을 수행하여 균형을 유지한다. 일반적인 이진 탐색 트리처럼 새로운 노드를 삽입한다. 삽입 경로를 따라 올라가면서 각 노드의 높이를 갱신한다. 불균형이 발생한 경우(균형 인수의 절댓값이 2가 된 경우) 회전 연산을 수행한다. LL Case: 오른쪽 회전 RR Case: 왼쪽 회전 LR Case: 왼쪽-오른쪽 회전 RL Case: 오른쪽-왼쪽 회전 삭제: 노드를 제거한 후, 트리의 균형을 유지하기 위해 필요한 회전을 수행한다. 검색: 일반적인 이진 검색 트리와 동일한 방식으로 수행된다. 구성 요소 노드: 키 값, 왼쪽 자식 포인터, 오른쪽 자식 포인터, 높이 정보를 포함한다. 키(key): 데이터 값 높이(height): 해당 노드를 루트로 하는 서브트리의 높이 왼쪽 자식 포인터 오른쪽 자식 포인터 (선택적으로) 부모 노드 포인터 균형 인수(Balance Factor): 각 노드의 왼쪽과 오른쪽 서브트리의 높이 차이를 나타낸다. 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이 수식으로는 BF = height(left) - height(right) 이 값은 항상 -1, 0, 1 중 하나여야 합니다 회전 연산: 트리의 균형을 유지하기 위한 왼쪽 회전, 오른쪽 회전, 왼쪽-오른쪽 회전, 오른쪽-왼쪽 회전이 있다. 구현 방식 AVL 트리는 일반적으로 다음과 같은 구조로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:35:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;578 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AVL 트리 (AVL tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>레드-블랙 트리 (red-black tree)</h2></header><div class=entry-content><p>레드-블랙 트리 (red-black tree) Red-black tree는 자체 균형 이진 검색 트리(self-balancing binary search tree)의 한 종류로, 컴퓨터 과학에서 정렬된 정보의 빠른 저장과 검색을 위해 사용되는 데이터 구조이다. 데이터베이스와 파일 시스템에서 널리 사용된다.
Red-black tree는 각 노드에 추가적인 색상 속성(빨간색 또는 검은색)을 가진 자체 균형 이진 검색 트리로, 트리의 균형을 유지하여 효율적인 검색, 삽입, 삭제 연산을 보장한다.
https://www.geeksforgeeks.org/introduction-to-red-black-tree/
특징 모든 노드는 빨간색 또는 검은색이다. 루트 노드는 항상 검은색이다. 모든 리프 노드(NIL 노드)는 검은색이다. 빨간색 노드의 자식은 항상 검은색이다 (연속된 빨간색 노드는 없음). 모든 경로에서 검은색 노드의 수는 동일하다. 장점 삽입, 삭제, 검색 연산의 시간 복잡도가 O(log n)으로 보장된다. 자체 균형 기능으로 효율적인 성능을 유지한다. AVL 트리에 비해 삽입과 삭제가 더 빠르다. 응용 데이터베이스 인덱싱 파일 시스템 구현 맵(Map)과 셋(Set) 자료구조 구현 구성 요소 노드: 값, 색상, 왼쪽 자식, 오른쪽 자식, 부모 노드 참조를 포함한다. 루트: 트리의 최상위 노드이다. NIL 노드: 리프 노드로 사용되는 특별한 검은색 노드이다. 구현 방식 Red-black tree는 일반적으로 다음과 같은 구조로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:35:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;683 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 레드-블랙 트리 (red-black tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/red-black-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BK-tree</h2></header><div class=entry-content><p>BK-tree BK-Tree(Burkhard-Keller Tree)는 메트릭 공간(metric space)에서 효율적인 근사 검색을 위해 설계된 트리 기반 데이터 구조이다.
주로 레벤슈타인 거리(Levenshtein Distance)를 활용한 문자열 유사성 검색, 맞춤법 검사, DNA 시퀀스 분석에 활용된다.
BK-Tree는 유사성 검색이 필요한 분야에서 여전히 유효하나, 최근에는 SymSpell 등 더 빠른 알고리즘도 등장했다.
그러나 이론적 우아함과 구현 용이성으로 교육 및 소규모 시스템에서 널리 사용된다.
BK-트리의 주요 특징 메트릭 공간에서의 효율적인 검색: BK-트리는 요소 간의 거리를 기반으로 데이터를 구성하여, 특정 요소와 유사한 요소를 빠르게 찾을 수 있다. 이산 메트릭 사용: 주로 레벤슈타인 거리(편집 거리)와 같은 이산 메트릭을 사용하여 문자열 간의 유사성을 측정한다. BK-트리의 구조 및 동작 원리 노드 구성: 각 노드는 하나의 요소를 저장하며, 자식 노드는 부모 노드와의 거리(d)를 기준으로 분류된다. 삽입: 새로운 요소를 삽입할 때, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 계산된 거리에 해당하는 자식 노드가 없으면 해당 위치에 새로운 노드를 추가하고, 있으면 해당 자식 노드로 이동하여 동일한 과정을 반복한다. 검색: 특정 요소와 유사한 요소를 찾기 위해, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 이 거리가 설정한 임계값 이하인 경우 해당 노드를 결과에 추가하고, 자식 노드들 중 현재 거리와 임계값의 차이 범위 내에 있는 노드들만 재귀적으로 탐색한다. BK-트리의 예시 단어 집합 {“book”, “books”, “cake”, “boo”, “boon”, “cook”, “cape”, “cart”}가 있을 때, 레벤슈타인 거리를 사용하여 BK-트리를 구성하면 다음과 같은 구조가 될 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;833 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BK-tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bk-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BSP Tree</h2></header><div class=entry-content><p>BSP Tree (Binary Space Partitioning Tree) BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것이다. 이 과정에서 생성되는 트리를 BSP 트리라고 한다.
https://www.researchgate.net/figure/Constructing-a-bsp-tree_fig1_238973971
특징 이진 트리 구조: 각 노드는 최대 두 개의 자식 노드를 가진다. 재귀적 분할: 공간을 계속해서 두 부분으로 나누어 표현한다. 볼록 집합: 분할된 각 공간은 볼록 집합(convex set)의 형태를 가진다. 계층적 구조: 공간을 계층적으로 표현할 수 있다. 장점 효율적인 렌더링: 3D 그래픽에서 렌더링 속도를 향상시킬 수 있다. 공간 분할: 복잡한 3D 공간을 효과적으로 표현할 수 있다. 충돌 감지: 게임이나 시뮬레이션에서 충돌 감지에 유용하다. 가시성 결정: 어떤 객체가 보이는지 빠르게 결정할 수 있다. 단점 전처리 시간: 초기 트리 구성에 많은 시간이 소요될 수 있다. 메모리 사용: 복잡한 공간의 경우 많은 메모리를 사용할 수 있다. 동적 환경에서의 한계: 자주 변하는 환경에서는 효율성이 떨어질 수 있다. 응용 3D 컴퓨터 그래픽스: 렌더링 최적화에 사용된다. 컴퓨터 게임: 특히 1인칭 슈팅 게임에서 널리 사용된다. CAD 시스템: 조립식 입체 기하학(CSG)에 활용된다. 로봇 공학: 충돌 감지 등에 사용된다. 동작 원리 분할 평면 선택: 공간을 분할할 평면을 선택한다. 공간 분할: 선택된 평면을 기준으로 공간을 두 부분으로 나눈다. 재귀적 분할: 각 부분에 대해 1, 2 과정을 반복한다. 종료 조건: 정해진 깊이에 도달하거나 더 이상 분할이 필요 없을 때 종료한다. 구성 요소 노드: 공간을 표현하는 기본 단위. 분할 평면: 각 노드에서 공간을 나누는 기준이 되는 평면. 왼쪽/오른쪽 자식 노드: 분할된 공간을 표현하는 하위 노드. 리프 노드: 더 이상 분할되지 않는 최종 공간을 나타내는 노드. 구현 방식 다음은 Python을 사용한 간단한 BSP Tree 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BSP Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>K-d Tree</h2></header><div class=entry-content><p>K-d Tree K-d Tree는 k차원 공간에서 점들을 효율적으로 저장하고 검색하기 위한 이진 트리 기반의 공간 분할 데이터 구조로, K-d Tree는 k차원 공간을 재귀적으로 분할하여 표현하는 이진 트리이다.
각 노드는 k차원 공간의 한 점을 나타내며, 비단말 노드는 해당 차원을 기준으로 공간을 두 개의 하위 공간으로 분할한다.
https://www.researchgate.net/figure/sualization-of-the-k-d-tree-algorithm_fig4_327289160
특징 다차원 데이터 처리: k차원 공간의 점들을 효율적으로 저장하고 검색할 수 있다. 계층적 구조: 공간을 재귀적으로 분할하여 계층적으로 표현한다. 차원 순환: 트리의 각 레벨마다 분할 기준이 되는 차원이 순환된다. 균형 구조: 중앙값을 기준으로 분할하여 균형 잡힌 트리를 구성한다. 장점 효율적인 검색: 다차원 공간에서의 근접 이웃 검색이나 범위 검색을 빠르게 수행할 수 있다. 차원 축소: 문제의 차원을 줄여 검색 시간을 단축하고 메모리 사용을 줄일 수 있다. 다양한 응용: 데이터 마이닝, 컴퓨터 그래픽스, 과학 계산 등 다양한 분야에 활용된다. 단점 고차원 데이터의 한계: 차원이 증가할수록 성능이 저하될 수 있다. 불균형 가능성: 데이터 분포에 따라 트리가 불균형해질 수 있다. 동적 데이터 처리의 어려움: 데이터 삽입/삭제 시 트리 재구성이 필요할 수 있다. 응용 최근접 이웃 검색: 머신러닝의 k-최근접 이웃(k-NN) 알고리즘에 활용된다. 범위 검색: 지리 정보 시스템(GIS)에서 특정 영역 내 객체 검색에 사용된다. 컴퓨터 비전: 이미지 처리와 특징점 매칭에 활용된다. 충돌 감지: 게임이나 시뮬레이션에서 객체 간 충돌 감지에 사용된다. 동작 원리 트리 구축:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;617 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to K-d Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Merkle Tree</h2></header><div class=entry-content><p>Merkle Tree 머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.
머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.
계층적 해시 구조 Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256). Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화. Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표. 예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;483 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Merkle Tree" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/tree/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>