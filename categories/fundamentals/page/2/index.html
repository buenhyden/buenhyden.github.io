<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/fundamentals/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg vs. pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/getting-started/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pagination</h2></header><div class=entry-content><p>Pagination API 설계에서 페이지네이션은 대량의 데이터를 효율적으로 전송하고 관리하기 위한 핵심 요소이다. 페이지네이션을 통해 서버는 데이터를 작은 “페이지” 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.
페이지네이션의 필요성과 중요성 페이지네이션이 필요한 주요 이유는 다음과 같다:
성능 최적화
대규모 데이터셋을 한 번에 전송하면 여러 문제가 발생한다:
서버 부하 증가: 대량의 레코드를 검색하고 직렬화하는 과정은 서버 리소스를 많이 소모한다. 네트워크 부하: 대용량 응답은 네트워크 대역폭을 많이 사용하며, 특히 모바일 환경에서 문제가 된다. 응답 지연: 큰 데이터셋을 처리하는 데 시간이 오래 걸려 사용자 경험이 저하된다. 메모리 사용량: 클라이언트와 서버 모두 대량의 데이터를 메모리에 로드해야 한다. 사용자 경험 향상
페이지네이션은 사용자 인터페이스와 경험을 개선한다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;<span>15 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Pagination" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-implementation/request-response-handling/pagination/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>URI Design</h2></header><div class=entry-content><p>URI Design URI(Uniform Resource Identifier) 디자인은 API 설계의 근본적인 요소로, 개발자 경험과 API의 사용성, 유지보수성에 직접적인 영향을 미친다. 잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.
URI의 기본 개념과 구조 URI는 인터넷에서 특정 리소스를 고유하게 식별하는 문자열이다. API 설계에서 URI는 클라이언트가 서버의 리소스와 상호 작용하는 진입점 역할을 한다.
URI의 구성 요소 URI의 주요 구성 요소를 이해하는 것은 효과적인 디자인의 시작점이다:
1 2 3 4 https://api.example.com:8080/v1/customers/42/orders?status=pending#summary \___/ \______________/\__/\_________________/ \____________/ \______/ | | | | | | scheme authority port path query fragment 스킴(Scheme): URI가 사용하는 프로토콜(https, http 등) 권한(Authority): 서비스의 도메인 이름 또는 IP 주소 포트(Port): 서비스가 수신 대기하는 네트워크 포트(종종 생략됨) 경로(Path): 리소스의 위치를 계층적으로 나타내는 문자열 쿼리(Query): 리소스에 대한 추가 매개변수(필터링, 정렬 등) 프래그먼트(Fragment): 리소스 내의 특정 부분을 가리키는 식별자(일반적으로 API에서 덜 사용됨) URI vs. URL vs. URN URI 개념을 정확히 이해하기 위해서는 관련 용어의 차이점을 아는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to URI Design" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/api-design-principles/api-endpoint-design/uri-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computability/computability-theory/decidability/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Format</h2></header><div class=entry-content><p>Format 데이터 포맷은 정보를 구조화하고, 저장하며, 교환하는 표준화된 방식이다. 데이터 포맷은 IT 시스템 간의 효율적인 통신과 데이터 처리의 기반이 되며, 다양한 응용 프로그램과 시스템에서 데이터를 해석하고 활용하는 방식을 결정한다.
데이터 포맷은 현대 IT 환경에서 정보 교환과 저장의 핵심 요소이다. 적절한 데이터 포맷을 선택하고 효과적으로 구현하는 것은 시스템의 성능, 확장성, 유지보수성에 직접적인 영향을 미친다.
데이터 포맷의 기본 개념 데이터 포맷은 데이터를 표현하는 구조화된 양식으로, 다음과 같은 역할을 한다:
데이터 구조화: 원시 데이터를 의미 있는 형태로 구조화한다. 데이터 교환: 서로 다른 시스템 간에 데이터를 교환할 수 있게 한다. 데이터 저장: 정보를 효율적으로 저장하고 검색할 수 있게 한다. 데이터 표준화: 데이터 처리 방식을 표준화하여 호환성을 보장한다. 주요 데이터 포맷 유형 텍스트 기반 데이터 포맷 JSON (JavaScript Object Notation) JSON은 경량화된 데이터 교환 형식으로, 사람이 읽고 쓰기 쉬우며 기계가 파싱하고 생성하기 쉽다.
...</p></div><footer class=entry-footer><span title='2024-12-16 12:27:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Format" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-types--formats/exchange-formats/__index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Little Endian</h2></header><div class=entry-content><p>Little Endian 리틀 엔디안(Little Endian)은 컴퓨터 시스템에서 메모리에 데이터를 저장하는 중요한 바이트 순서 방식이다.
엔디안은 컴퓨터가 여러 바이트로 구성된 데이터(예: 정수, 부동소수점)를 메모리에 저장하는 순서를 나타내는 용어이다.
리틀 엔디안은 현대 컴퓨터 시스템에서 가장 널리 사용되는 바이트 순서 방식이다.
대부분의 개발자는 리틀 엔디안 시스템에서 작업하게 될 가능성이 높지만, 네트워크 프로그래밍이나 다양한 플랫폼 간의 데이터 교환에서는 엔디안 차이를 인식하고 적절히 처리하는 것이 중요하다.
엔디안 관련 문제는 종종 디버깅하기 어려운 미묘한 버그를 발생시킬 수 있으므로, 바이너리 데이터를 처리할 때 항상 엔디안을 고려하는 습관을 들이는 것이 좋다. 다행히 대부분의 현대 프로그래밍 언어와 라이브러리는 엔디안 변환을 위한 도구를 제공하므로, 이러한 도구를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:20:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Little Endian" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/binary-operations/endianness/little-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Big Endian</h2></header><div class=entry-content><p>Big Endian 빅 엔디안(Big Endian)은 컴퓨터 시스템에서 데이터를 저장하는 바이트 순서 방식 중 하나이다.
엔디안은 컴퓨터가 메모리에 다중 바이트 데이터를 저장하는 순서를 의미한다. 모든 데이터는 결국 바이트 단위로 저장되는데, 2바이트 이상의 데이터(예: 정수, 부동소수점)를 저장할 때 바이트 배열 순서가 중요해진다.
빅 엔디안은 다중 바이트 데이터에서 가장 중요한 바이트를 먼저 저장하는 방식으로, 특히 네트워크 프로그래밍이나 크로스 플랫폼 개발에서 중요하다. 개발자는 데이터 교환 시 엔디안 차이를 인식하고 적절히 변환하는 것이 중요하다. 현대 프로그래밍 언어와 라이브러리는 대부분 이러한 변환을 위한 도구를 제공하므로, 이를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Big Endian" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/binary-operations/endianness/big-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asymptotic Notation</h2></header><div class=entry-content><p>점근적 표기법(Asymptotic Notation) 점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.
알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.
점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.
빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.
그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.
따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 10:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Asymptotic Notation" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg</h2></header><div class=entry-content><p>setup.cfg setup.cfg는 파이썬 프로젝트의 설정을 관리하는 구성 파일이다.
이 파일은 INI 형식으로 작성되며, setuptools가 프로젝트를 빌드하고 배포할 때 참조하는 중요한 설정들을 포함한다.
주요 특징 선언적 구성: setup.py에서 프로그래밍 방식으로 정의하던 설정을 보다 간단하고 명확한 형식으로 선언할 수 있습니다. 정적 메타데이터: 프로젝트의 이름, 버전, 설명 등 변경이 잦지 않은 정보를 저장하는 데 적합합니다. 도구별 설정: 다양한 개발 도구들의 설정을 한 곳에서 관리할 수 있습니다. 주요 섹션 [metadata]:
프로젝트의 기본 정보를 정의한다.
여기에는 프로젝트 이름, 버전, 작성자 정보, 라이선스 등이 포함된다.
이 정보는 PyPI에 패키지를 등록할 때 사용되며, pip로 패키지를 설치할 때 표시되는 정보의 기반이 된다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:24:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to setup.cfg" href=https://buenhyden.github.io/posts/programming-languages/python/getting-started/configuration/setup.cfg/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/fundamentals/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/fundamentals/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>