<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AOT Vs JIT Vs Interpreter</h2></header><div class=entry-content><p>AOT Vs JIT Vs Interpreter AOT, JIT, 그리고 인터프리터는 모두 소스 코드를 실행 가능한 형태로 변환하는 언어 처리 방식이지만, 언제 어떻게 변환이 이루어지는지에 따라 큰 차이가 있다.
프로그래밍 언어로 작성된 코드가 컴퓨터에서 실행되기 위해서는 기계어로 변환되는 과정이 필요하다.
이 변환 과정은 크게 세 가지 주요 접근 방식—AOT(Ahead-of-Time) 컴파일, JIT(Just-In-Time) 컴파일, 인터프리테이션(Interpretation)—으로 구분된다.
각 방식은 코드 변환의 시점과 방법에 차이가 있으며, 성능, 유연성, 개발 생산성 등에 서로 다른 영향을 미친다.
AOT 컴파일러, JIT 컴파일러, 인터프리터는 각각 고유한 장단점을 가진 코드 실행 메커니즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 00:21:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2485 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AOT Vs JIT Vs Interpreter" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/aot-vs-jit-vs-interpreter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Poetry vs uv vs Rye</h2></header><div class=entry-content><p>Poetry Vs Uv Vs Rye Poetry, uv, Rye는 모두 파이썬 프로젝트 관리와 패키지 설치를 위한 도구들이다.
각각의 도구는 고유한 특징과 장단점을 가지고 있어 개발자들의 다양한 요구사항을 충족시키고 있다.
Poetry는 파이썬 프로젝트의 의존성 관리와 패키징을 위한 도구로, 2018년에 출시되었다.
주요 특징으로는 의존성 해결, 가상 환경 관리, 프로젝트 패키징 등이 있다.
uv는 Rust로 작성된 초고속 파이썬 패키지 설치 및 의존성 해결 도구이다. pip와 pip-tools의 대체제로 설계되었으며, 속도와 효율성에 중점을 두고 있다.
Rye는 Flask의 개발자인 Armin Ronacher가 개발한 올인원 파이썬 프로젝트 관리 도구이다.
파이썬 버전 관리, 의존성 관리, 가상 환경 생성 등 다양한 기능을 제공한다.
Poetry, uv, Rye에 대한 비교를 요청하신 카테고리별로 표로 정리했습니다. 각 도구의 특징을 비교하여 살펴볼 수 있도록 구성했습니다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:41:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;577 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry vs uv vs Rye" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg Vs pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;602 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화(Lazy Initialization) 지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법이다.
지연 초기화는 리소스 사용을 최적화하고 애플리케이션의 시작 시간을 개선하는 강력한 도구이지만 무분별한 적용은 오히려 코드를 복잡하게 만들고 성능 문제를 야기할 수 있다.
지연 초기화의 기본 개념 지연 초기화는 객체나 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 설계 패턴이다.
이는 “필요할 때까지 만들지 말라"는 원칙에 기반한다.
기본 원리 즉시 초기화(Eager Initialization): 객체가 생성될 때 모든 의존성과 리소스를 즉시 초기화 지연 초기화(Lazy Initialization): 객체의 특정 부분이 실제로 사용될 때 해당 부분만 초기화 지연 초기화가 유용한 상황 비용이 많이 드는 연산: 메모리 사용량이 큰 객체, 계산 비용이 높은 값, 데이터베이스 연결 등 사용되지 않을 수 있는 컴포넌트: 애플리케이션의 모든 실행 경로에서 필요하지 않은 리소스 초기화 의존성 문제 해결: 순환 참조 같은 의존성 문제를 해결하기 위한 방법 지연 초기화의 구현 패턴 기본 지연 초기화 패턴 가장 단순한 형태의 지연 초기화 구현.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3465 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/lazy-initialization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Little Endian</h2></header><div class=entry-content><p>Little Endian 리틀 엔디안(Little Endian)은 컴퓨터 시스템에서 메모리에 데이터를 저장하는 중요한 바이트 순서 방식이다.
엔디안은 컴퓨터가 여러 바이트로 구성된 데이터(예: 정수, 부동소수점)를 메모리에 저장하는 순서를 나타내는 용어이다.
리틀 엔디안은 현대 컴퓨터 시스템에서 가장 널리 사용되는 바이트 순서 방식이다.
대부분의 개발자는 리틀 엔디안 시스템에서 작업하게 될 가능성이 높지만, 네트워크 프로그래밍이나 다양한 플랫폼 간의 데이터 교환에서는 엔디안 차이를 인식하고 적절히 처리하는 것이 중요하다.
엔디안 관련 문제는 종종 디버깅하기 어려운 미묘한 버그를 발생시킬 수 있으므로, 바이너리 데이터를 처리할 때 항상 엔디안을 고려하는 습관을 들이는 것이 좋다. 다행히 대부분의 현대 프로그래밍 언어와 라이브러리는 엔디안 변환을 위한 도구를 제공하므로, 이러한 도구를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:20:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;431 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Little Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/little-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Big Endian</h2></header><div class=entry-content><p>Big Endian 빅 엔디안(Big Endian)은 컴퓨터 시스템에서 데이터를 저장하는 바이트 순서 방식 중 하나이다.
엔디안은 컴퓨터가 메모리에 다중 바이트 데이터를 저장하는 순서를 의미한다. 모든 데이터는 결국 바이트 단위로 저장되는데, 2바이트 이상의 데이터(예: 정수, 부동소수점)를 저장할 때 바이트 배열 순서가 중요해진다.
빅 엔디안은 다중 바이트 데이터에서 가장 중요한 바이트를 먼저 저장하는 방식으로, 특히 네트워크 프로그래밍이나 크로스 플랫폼 개발에서 중요하다. 개발자는 데이터 교환 시 엔디안 차이를 인식하고 적절히 변환하는 것이 중요하다. 현대 프로그래밍 언어와 라이브러리는 대부분 이러한 변환을 위한 도구를 제공하므로, 이를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Big Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/big-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>setup.cfg</h2></header><div class=entry-content><p>setup.cfg setup.cfg는 파이썬 프로젝트의 설정을 관리하는 구성 파일이다.
이 파일은 INI 형식으로 작성되며, setuptools가 프로젝트를 빌드하고 배포할 때 참조하는 중요한 설정들을 포함한다.
주요 특징 선언적 구성: setup.py에서 프로그래밍 방식으로 정의하던 설정을 보다 간단하고 명확한 형식으로 선언할 수 있습니다. 정적 메타데이터: 프로젝트의 이름, 버전, 설명 등 변경이 잦지 않은 정보를 저장하는 데 적합합니다. 도구별 설정: 다양한 개발 도구들의 설정을 한 곳에서 관리할 수 있습니다. 주요 섹션 [metadata]:
프로젝트의 기본 정보를 정의한다.
여기에는 프로젝트 이름, 버전, 작성자 정보, 라이선스 등이 포함된다.
이 정보는 PyPI에 패키지를 등록할 때 사용되며, pip로 패키지를 설치할 때 표시되는 정보의 기반이 된다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:24:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;272 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>The pyproject.toml file</h2></header><div class=entry-content><p>The pyproject.toml File Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일.
TOML 형식을 사용하며 프로젝트의 메타데이터와 의존성을 중앙 집중적으로 관리한다.
주요 장점:
특정 빌드 시스템에 종속되지 않는 표준화된 설정 파일. TOML 형식을 사용하여 가독성이 높고 관리가 용이하다. 프로젝트의 모든 설정을 한 곳에서 관리할 수 있어 편리하다. pyproject.toml은 PEP 518, PEP 621 등의 파이썬 표준 제안에 의해 정의되었으며, 현대적인 파이썬 프로젝트 관리에 필수적인 요소로 자리잡고 있다.
역할 프로젝트 메타데이터 관리:
- 프로젝트 이름, 버전, 설명, 저자 등의 기본 정보를 포함한다.
- 라이선스, 키워드, 프로젝트 URL 등의 추가 정보도 저장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:54:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;616 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to The pyproject.toml file" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rye</h2></header><div class=entry-content><p>Rye Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.
Rye는 파이썬 개발자들이 겪는 다양한 환경 설정 및 관리 문제를 해결하기 위해 설계되었다.
주요 특징 통합 환경 관리: Rye는 파이썬 설치, 프로젝트 초기화, 의존성 관리, 가상 환경 설정 등을 단일 도구로 통합한다. pyproject.toml 기반: 프로젝트 구성을 위해 현대적인 pyproject.toml 파일을 사용한다. 빠른 성능: Rust로 작성되어 기존 도구들보다 훨씬 빠른 성능을 제공한다. 다목적성: 복잡한 프로젝트, 모노레포, 글로벌 도구 설치 등 다양한 시나리오를 지원한다. 자동화된 가상 환경: 프로젝트별로 독립적인 가상 환경을 자동으로 생성하고 관리한다. 설치 및 사용 Rye는 다양한 운영 체제에서 쉽게 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-27 04:19:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;232 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rye" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Generator and Iterator</h2></header><div class=entry-content><p>Generator and Iterator 이터레이터는 값을 차례대로 반환하는 객체로, __iter__()와 __next__() 메서드를 구현한다.
제너레이터는 yield 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.
제너레이터와 이터레이터의 주요 차이점 비교 항목 이터레이터 제너레이터 정의 방식 __iter__와 __next__ 메서드를 구현하는 클래스 yield 키워드를 사용하는 함수 상태 저장 인스턴스 변수를 통해 명시적으로 상태 저장 함수의 실행 상태가 자동으로 저장 메모리 사용 모든 상태를 명시적으로 저장해야 함 필요한 값만 생성하여 메모리 효율적 구현 복잡도 상대적으로 복잡함 (여러 메서드 구현 필요) 매우 단순함 (일반 함수처럼 작성) 용도 복잡한 이터레이션 로직이 필요한 경우 간단한 순차적 데이터 생성 재사용성 클래스로 구현되어 재사용 용이 한 번 순회하면 소진됨 기능 확장성 클래스이므로 추가 메서드와 속성 정의 가능 함수 범위로 제한됨 성능 상태 관리를 위한 추가 오버헤드 존재 매우 가벼움 코드 가독성 구조화된 형태로 명확하나 장황할 수 있음 간결하고 직관적 양방향 통신 메서드를 통해 구현 가능 send() 메서드로 기본 제공 이러한 차이점들은 실제 사용에서 다음과 같은 의미를 가진다.
...</p></div><footer class=entry-footer><span title='2024-11-24 10:43:00 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;990 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Generator and Iterator" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/generator-and-iterator/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/fundamentals/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/fundamentals/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>