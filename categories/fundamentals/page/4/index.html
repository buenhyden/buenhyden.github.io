<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AI Engineer vs. ML Engineer</h2></header><div class=entry-content><p>AI Engineer vs. ML Engineer 인공지능(AI)과 머신러닝(ML)이 기술 생태계에서 중추적 역할을 하게 되면서, AI 엔지니어와 ML 엔지니어라는 직무도 점차 중요해지고 있다. 이 두 역할은 겉보기에 유사해 보이지만, 그 책임과 요구되는 기술 세트, 업무 범위에서 중요한 차이가 있다.
정의와 범위 간단히 말해, AI 엔지니어링은 ML 엔지니어링을 포함하는 상위 개념이라고 볼 수 있다. 모든 머신러닝은 AI의 일부이지만, 모든 AI가 머신러닝을 사용하는 것은 아니다.
AI 엔지니어 AI 엔지니어는 인공지능 시스템 전반을 설계, 개발, 구현하는 전문가이다.
이들의 업무는 머신러닝을 포함한 다양한 AI 기술(자연어 처리, 컴퓨터 비전, 로보틱스, 지식 표현, 추론 시스템 등)을 아우른다. AI 엔지니어는 보다 광범위한 인공지능 문제를 해결하는 데 초점을 맞추며, 이론적 AI 연구를 실용적인 애플리케이션으로 변환하는 역할을 한다.
...</p></div><footer class=entry-footer><span title='2025-02-25 14:13:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AI Engineer vs. ML Engineer" href=https://buenhyden.github.io/posts/ai/llm-engineering/fundamentals/ai-engineer-vs-ml-engineer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>AI vs. AGI</h2></header><div class=entry-content><p>AI (Artificial Intelligence) vs. AGI (Artificial General Intelligence) 인공지능(AI)과 범용 인공지능(AGI) 사이의 구분은 AI 연구와 개발의 핵심 주제 중 하나이다.
두 개념은 기술적 역량, 개발 상태, 잠재적 영향 및 직면한 도전과제에서 근본적인 차이가 있다.
기본 개념과 정의 인공지능(AI) 인공지능은 인간의 지능을 시뮬레이션하도록 설계된 컴퓨터 시스템을 말한다. 현대 AI는 주로 특정 작업이나 문제 도메인에 특화된 ‘좁은 AI(Narrow AI)’ 또는 ‘약한 AI(Weak AI)‘의 형태로 존재한다. 이러한 시스템은 특정 작업(언어 번역, 이미지 인식, 게임 플레이 등)에서 뛰어난 성능을 보이지만, 학습한 영역 외의 작업으로 지식이나 능력을 일반화하는 데 제한이 있다.
...</p></div><footer class=entry-footer><span title='2025-02-25 14:13:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AI vs. AGI" href=https://buenhyden.github.io/posts/ai/llm-engineering/fundamentals/ai-vs-agi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>LLMs</h2></header><div class=entry-content><p>LLMs 대규모 언어 모델(Large Language Models, 줄여서 LLMs)은 인공지능의 한 분야인 자연어 처리(NLP)에서 사용되는 거대한 규모의 신경망 모델이다.이 모델들은 인간의 언어를 이해하고 생성하는 능력을 가지고 있으며, 수십억 또는 수천억 개의 매개변수(parameters)를 포함하고 있다.
LLM이 무엇인지 쉽게 이해하기 위해 비유를 들어보면:
여러분이 외국어를 배우는 과정을 생각해보자!
처음에는 단어를 몇 개 배우고, 그다음 간단한 문장을 만들고, 점차 다양한 책과 글을 읽으면서 언어의 미묘한 뉘앙스와 문맥적 의미를 이해하게 된다.
LLM도 유사한 과정을 거치지만, 인터넷에서 가져온 방대한 양의 텍스트를 ‘읽고’ 언어 패턴을 학습한다.
...</p></div><footer class=entry-footer><span title='2025-02-25 14:13:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to LLMs" href=https://buenhyden.github.io/posts/ai/llm-engineering/fundamentals/llms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화(Lazy Initialization) 지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법이다.
지연 초기화는 리소스 사용을 최적화하고 애플리케이션의 시작 시간을 개선하는 강력한 도구이지만 무분별한 적용은 오히려 코드를 복잡하게 만들고 성능 문제를 야기할 수 있다.
지연 초기화의 기본 개념 지연 초기화는 객체나 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 설계 패턴이다.
이는 “필요할 때까지 만들지 말라"는 원칙에 기반한다.
기본 원리 즉시 초기화(Eager Initialization): 객체가 생성될 때 모든 의존성과 리소스를 즉시 초기화 지연 초기화(Lazy Initialization): 객체의 특정 부분이 실제로 사용될 때 해당 부분만 초기화 지연 초기화가 유용한 상황 비용이 많이 드는 연산: 메모리 사용량이 큰 객체, 계산 비용이 높은 값, 데이터베이스 연결 등 사용되지 않을 수 있는 컴포넌트: 애플리케이션의 모든 실행 경로에서 필요하지 않은 리소스 초기화 의존성 문제 해결: 순환 참조 같은 의존성 문제를 해결하기 위한 방법 지연 초기화의 구현 패턴 기본 지연 초기화 패턴 가장 단순한 형태의 지연 초기화 구현.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Little Endian</h2></header><div class=entry-content><p>Little Endian 리틀 엔디안(Little Endian)은 컴퓨터 시스템에서 메모리에 데이터를 저장하는 중요한 바이트 순서 방식이다.
엔디안은 컴퓨터가 여러 바이트로 구성된 데이터(예: 정수, 부동소수점)를 메모리에 저장하는 순서를 나타내는 용어이다.
리틀 엔디안은 현대 컴퓨터 시스템에서 가장 널리 사용되는 바이트 순서 방식이다.
대부분의 개발자는 리틀 엔디안 시스템에서 작업하게 될 가능성이 높지만, 네트워크 프로그래밍이나 다양한 플랫폼 간의 데이터 교환에서는 엔디안 차이를 인식하고 적절히 처리하는 것이 중요하다.
엔디안 관련 문제는 종종 디버깅하기 어려운 미묘한 버그를 발생시킬 수 있으므로, 바이너리 데이터를 처리할 때 항상 엔디안을 고려하는 습관을 들이는 것이 좋다. 다행히 대부분의 현대 프로그래밍 언어와 라이브러리는 엔디안 변환을 위한 도구를 제공하므로, 이러한 도구를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:20:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Little Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/little-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Big Endian</h2></header><div class=entry-content><p>Big Endian 빅 엔디안(Big Endian)은 컴퓨터 시스템에서 데이터를 저장하는 바이트 순서 방식 중 하나이다.
엔디안은 컴퓨터가 메모리에 다중 바이트 데이터를 저장하는 순서를 의미한다. 모든 데이터는 결국 바이트 단위로 저장되는데, 2바이트 이상의 데이터(예: 정수, 부동소수점)를 저장할 때 바이트 배열 순서가 중요해진다.
빅 엔디안은 다중 바이트 데이터에서 가장 중요한 바이트를 먼저 저장하는 방식으로, 특히 네트워크 프로그래밍이나 크로스 플랫폼 개발에서 중요하다. 개발자는 데이터 교환 시 엔디안 차이를 인식하고 적절히 변환하는 것이 중요하다. 현대 프로그래밍 언어와 라이브러리는 대부분 이러한 변환을 위한 도구를 제공하므로, 이를 적절히 활용하면 엔디안 관련 문제를 효과적으로 처리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Big Endian" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/big-endian/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asymptotic Notation</h2></header><div class=entry-content><p>점근적 표기법(Asymptotic Notation) 점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.
알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.
점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.
빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.
그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.
따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 10:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asymptotic Notation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>The pyproject.toml file</h2></header><div class=entry-content><p>The pyproject.toml File Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일.
TOML 형식을 사용하며 프로젝트의 메타데이터와 의존성을 중앙 집중적으로 관리한다.
주요 장점:
특정 빌드 시스템에 종속되지 않는 표준화된 설정 파일. TOML 형식을 사용하여 가독성이 높고 관리가 용이하다. 프로젝트의 모든 설정을 한 곳에서 관리할 수 있어 편리하다. pyproject.toml은 PEP 518, PEP 621 등의 파이썬 표준 제안에 의해 정의되었으며, 현대적인 파이썬 프로젝트 관리에 필수적인 요소로 자리잡고 있다.
역할 프로젝트 메타데이터 관리:
- 프로젝트 이름, 버전, 설명, 저자 등의 기본 정보를 포함한다.
- 라이선스, 키워드, 프로젝트 URL 등의 추가 정보도 저장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:54:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to The pyproject.toml file" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/fundamentals/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/fundamentals/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>