<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fundamentals | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Fundamentals</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Performance vs Scalability</h2></header><div class=entry-content><p>Performance Vs Scalability 성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 핵심적인 두 축이다. 성능은 시스템이 현재 주어진 자원으로 얼마나 빠르게 작업을 수행하는지를 의미하며, 확장성은 시스템이 증가하는 부하나 사용자 수에 따라 성능을 유지하거나 향상시킬 수 있는 능력을 말한다. 각각 단일 요청 처리 효율과 부하 증가 대응 능력을 의미한다. 이 두 개념은 서로 보완적이며, 시스템 설계 시 목적과 상황에 따라 적절히 균형을 맞추는 것이 중요합니다. 2025 년 현재 클라우드 네이티브 아키텍처와 AI 기반 자동화 기술이 이 분야의 핵심 트렌드로 부상하고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Performance vs Scalability" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/performance-vs-scalability/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Preorder Traversal</h2></header><div class=entry-content><p>전위 순회(Preorder Traversal) 전위 순회(Preorder Traversal)는 트리 자료구조를 탐색하는 가장 기본적인 방법 중 하나이다.
전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태이다.
이 방법에서는 다음과 같은 순서로 노드를 방문한다:
현재 노드(루트)를 방문합니다. 왼쪽 서브트리를 전위 순회한다. 오른쪽 서브트리를 전위 순회한다. 이 과정은 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 “전위(Pre)“는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Preorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>TCPIP 4 Layers vs. OSI 7 Layers</h2></header><div class=entry-content><p>TCPIP 4 Layers vs. OSI 7 Layers 네트워크 통신을 이해하기 위한 두 가지 주요 참조 모델인 OSI 7계층과 TCP/IP 4계층 모델은 네트워크 통신과 프로토콜에 대한 개념적 프레임워크를 제공한다.
두 모델은 서로 다른 접근 방식과 구조를 가지고 있지만, 궁극적인 목표는 동일하다:
시스템 간의 효율적이고 신뢰할 수 있는 통신을 가능하게 하는 것
OSI 7계층 모델과 TCP/IP 4계층 모델은 각각 고유한 장점과 특성을 가지고 있다.
OSI 모델은 더 세분화되고 개념적인 접근을 제공하여 네트워크 통신의 복잡성을 이해하는 데 유용한 프레임워크를 제공한다. 반면 TCP/IP 모델은 실용적이고 구현 중심적인 접근으로 현대 인터넷의 기반을 형성했다.
...</p></div><footer class=entry-footer><span title='2024-10-19 02:11:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCPIP 4 Layers vs. OSI 7 Layers" href=https://buenhyden.github.io/posts/systems-and-infrastructure/networking-and-communication/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Latency vs Throughput</h2></header><div class=entry-content><p>Latency vs. Throughput Latency 와 Throughput 은 시스템 성능 평가의 양대 축으로 상호 보완적인 지표이다. Latency는 데이터 전송 지연 시간 (밀리초 단위) 으로, 실시간 화상 회의나 온라인 게임에서 사용자 경험에 직접적 영향을 미친다. Throughput은 초당 처리 가능한 데이터량 (MBps) 으로 대용량 트래픽 처리 능력을 결정한다. 시스템 설계자는 대역폭, 병목 현상, 하드웨어 자원 등 다양한 요소를 고려하여 균형점을 찾아야 한다. 이를 통해 실시간 시스템, 대용량 데이터 처리 등 다양한 응용 분야에서 최적의 성능을 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Latency vs Throughput" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/latency-vs-throughput/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Inorder Traversal</h2></header><div class=entry-content><p>중위 순회(Inorder Traversal) 중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다. 이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.
왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.
이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Low-Level Virtual Machine</h2></header><div class=entry-content><p>Low-Level Virtual Machine (LLVM) LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.
원래 “Low-Level Virtual Machine"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.
LLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 지속적 최적화(Lifelong Optimization) 를 지원한다.
LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:41:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Low-Level Virtual Machine" href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Functions</h2></header><div class=entry-content><p>Functions 함수는 프로그래밍의 핵심 구성 요소로, 특정 작업을 수행하는 독립적이고 재사용 가능한 코드 블록이다.
함수는 입력값(매개변수)을 받아 처리한 후 결과값을 반환할 수 있다.
함수는 코드의 가독성을 높이고 모듈화된 구조를 만들어 유지보수와 확장성을 크게 개선할 수 있다.
함수는 프로그래밍의 근본 개념으로, 다양한 언어에서 조금씩 다른 문법과 용법을 가지고 있지만 기본적인 원리는 동일하다.
각 언어의 특성과 장점을 이해하고 적재적소에 적용함으로써 더 효율적이고 관리하기 쉬운 소프트웨어를 개발할 수 있다.
함수의 기본 개념 함수는 하나의 작업 또는 연산을 수행하기 위해 정의된 코드 집합이며, 필요에 따라 여러 번 호출하여 사용할 수 있다. 함수는 입력 값(매개변수)을 받고, 이를 처리한 후 결과(반환 값)를 돌려줄 수 있어 코드 재사용과 분업에 용이하다. 함수 선언 및 구현 함수 정의: 함수를 정의할 때는 함수 이름과 괄호 안에 입력 매개변수를 명시하며, 중괄호 또는 들여쓰기로 본문을 구분한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 01:09:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Functions" href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/syntax-and-semantics/language-syntax/functions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Availability vs Consistency</h2></header><div class=entry-content><p>Availability vs. Consistency 분산 시스템 설계에서 “Availability(가용성)” 과 “Consistency(일관성)” 는 동시에 완벽히 만족시키기 어려운 특성이다.ㅇ이는 CAP 정리에 의해 설명된다. 시스템 설계 시, 네트워크 분할 상황에서 어느 특성을 우선시할지 결정해야 하며, 이는 시스템의 목적과 요구사항에 따라 달라진다. 2025 년 현재 AI 기반 최적화와 서버리스 아키텍처의 발전으로 새로운 패러다임이 형성되고 있다.
핵심 개념 가용성 (Availability)
가용성은 시스템이 서비스를 제공할 수 있는 능력을 의미한다. 분산 시스템에서 가용성이 높다는 것은 시스템의 일부가 실패하더라도 전체 시스템이 계속 작동하고 사용자 요청에 응답할 수 있음을 의미한다. 높은 가용성을 가진 시스템은 모든 작동 중인 노드가 항상 읽기 및 쓰기 요청에 응답할 수 있도록 보장한다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Availability vs Consistency" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/availability-vs-consistency/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Network Topologies</h2></header><div class=entry-content><p>Network Topologies 네트워크 토폴로지는 네트워크를 구성하는 노드와 링크의 물리적, 논리적 배치를 의미한다. 물리적 토폴로지는 실제 장치와 케이블의 배치를, 논리적 토폴로지는 데이터 흐름 경로를 나타낸다. 포인트 - 투 - 포인트, 버스, 스타, 링, 메시, 트리, 하이브리드 등 다양한 유형이 있으며, 각각은 구현 복잡성, 확장성, 장애 허용성, 비용 등에서 차이가 있다. 최근에는 클라우드, 에지 컴퓨팅, IoT 등의 발전으로 하이브리드 형태와 소프트웨어 정의 네트워킹이 주목받고 있다.
4. 핵심 개념 네트워크 토폴로지란 컴퓨터 네트워크에서 노드 (장치) 와 링크 (연결) 가 물리적 또는 논리적으로 배열되고 연결되는 방식을 말한다. 이는 네트워크의 성능, 신뢰성, 확장성에 직접적인 영향을 미치는 중요한 개념이다.
...</p></div><footer class=entry-footer><span title='2024-12-16 03:29:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Topologies" href=https://buenhyden.github.io/posts/systems-and-infrastructure/networking-and-communication/fundamentals/network-types/network-topologies/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adjacency Matrix vs Adjacency List</h2></header><div class=entry-content><p>그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교 그래프는 컴퓨터 과학에서 매우 중요한 자료구조로, 데이터 간의 관계를 효과적으로 표현할 수 있다.
그래프를 표현하는 방법을 선택할 때는 해결하려는 문제의 특성과 그래프의 구조를 고려해야 한다.
간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.
실제로는 두 방법을 혼합하거나 응용한 자료구조를 사용하기도 한다. 많은 실제 응용 사례(소셜 네트워크, 웹 페이지 연결 등)에서는 정점 수에 비해 간선 수가 적은 희소 그래프의 특성을 가지므로 인접 리스트가 더 많이 사용되는 경향이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 15:31:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adjacency Matrix vs Adjacency List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/fundamentals/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>