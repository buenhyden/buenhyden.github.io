<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory Architecture | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/memory-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/memory-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/memory-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/memory-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Memory Architecture"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Memory Architecture"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Memory Architecture</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy vs Cache Policy</h2></header><div class=entry-content><p>Cache Strategy vs Cache Policy 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 15:24:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy vs Cache Policy" href=https://buenhyden.github.io/til/2024/09/21/cache-strategy-vs-cache-policy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>캐시 (Cache)</h2></header><div class=entry-content><p>캐시 (Cache) 캐시(Cache)는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미한다.
데이터 접근 속도를 높이고 시스템 성능을 향상시킬 수 있다.
자주 사용되는 데이터는 빠르게 접근할 수 있는 위치에 복사해두는데 이 위치를 캐시(Cache)라고 말한다.
캐시의 특징 속도: 주 메모리나 디스크보다 훨씬 빠르다. 용량: 일반적으로 주 메모리보다 작다. 비용: 고속이기 때문에 상대적으로 비싸다. 캐시의 장점 빠른 데이터 접근: 자주 사용되는 데이터에 빠르게 접근할 수 있다. 시스템 성능 향상: 전체적인 시스템 응답 시간을 줄인다. 리소스 절약: 반복적인 데이터 요청을 줄여 서버 부하를 감소시킨다. 캐시 사용 시 주의점 일관성 유지: 원본 데이터가 변경될 때 캐시도 업데이트해야 한다. 캐시 크기 관리: 너무 크면 메모리 낭비, 너무 작으면 효율이 떨어진다. 캐시 교체 정책: 캐시가 가득 찼을 때 어떤 데이터를 제거할지 결정해야 한다. 캐시의 동작 과정 데이터 요청: 프로그램이 데이터를 요청한다. 캐시 확인: 시스템은 먼저 캐시에서 데이터를 찾는다. 캐시 히트(Cache Hit): 데이터가 캐시에 있으면 즉시 반환한다. 캐시 미스(Cache Miss): 데이터가 캐시에 없으면 주 메모리나 디스크에서 가져와 캐시에 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 캐시의 기본 작동 원리를 보여주는 예제 class SimpleCache: def __init__(self): self.cache = {} # 데이터를 저장할 공간 def get_data(self, key): # 1. 캐시에서 먼저 찾아봅니다 if key in self.cache: print("캐시에서 데이터를 찾았습니다!") return self.cache[key] # 2. 캐시에 없다면 원본 소스에서 가져옵니다 print("캐시에 없어서 원본에서 가져옵니다…") data = self.fetch_from_source(key) # 3. 다음 사용을 위해 캐시에 저장합니다 self.cache[key] = data return data 캐시의 종류 CPU 캐시: CPU와 주 메모리 사이에 위치한 고속의 소용량 메모리
역할:
...</p></div><footer class=entry-footer><span title='2024-09-22 13:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;835 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 캐시 (Cache)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Byte Addressable Memory vs Word Addressable Memory</h2></header><div class=entry-content><p>Byte Addressable Memory Vs Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.
이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.
Sourece: https://examradar.com/memory-organisation/
Byte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.
가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.
CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.
32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 11:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;609 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Byte Addressable Memory vs Word Addressable Memory" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/byte-addressable-memory-vs-word-addressable-memory/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Memory</h2></header><div class=entry-content><p>Cache Memory 캐시 메모리(Cache Memory)는 컴퓨터 아키텍처에서 중요한 역할을 하는 CPU와 주 메모리(RAM) 사이에 위치한 소규모의 고속 메모리이다.
주요 목적은 자주 사용되는 데이터와 명령어를 CPU 가까이에 저장하여 접근 시간을 줄이고 전체 시스템 성능을 향상시키는 것이다.
특징 속도: RAM보다 10-100배 빠르며, 응답 시간은 몇 나노초에 불과하다. 용량: RAM보다 작지만 더 빠른 SRAM을 사용한다. 비용: 단위 용량당 RAM보다 비싸지만 성능이 월등히 높다. 위치: CPU 칩 내부 또는 매우 가까운 곳에 위치한다. 작동 원리 지역성 원리: 최근 접근한 데이터나 명령어는 가까운 미래에 다시 사용될 가능성이 높다는 원리를 활용한다. 캐시 히트와 미스: CPU가 데이터를 요청할 때 캐시에서 찾으면 ‘캐시 히트’, 찾지 못하면 ‘캐시 미스’가 발생한다. 캐시 정책: 어떤 데이터를 캐시에 유지할지 결정하는 정책으로, LRU(Least Recently Used)나 MRU(Most Recently Used) 등이 있다. 캐시 레벨 L1 캐시: CPU에 가장 가까운 최소, 최고속 캐시로, 보통 명령어용(L1i)과 데이터용(L1d)으로 나뉜다. L2 캐시: L1보다 크고 느리지만 여전히 고속인 캐시이다. L3 캐시: 더 큰 용량을 제공하며, 여러 코어가 공유할 수 있다. 캐시 매핑 기법 직접 매핑: 각 메모리 블록이 특정 캐시 라인에 매핑된다. 완전 연관 매핑: 메모리 블록이 어느 캐시 라인에나 로드될 수 있다. 집합 연관 매핑: 직접과 완전 연관의 절충안으로, 메모리 블록이 특정 집합 내 어느 라인에나 로드될 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 11:36:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;193 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Memory" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/cache-memory/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-22 08:05:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;292 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-access-methods/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-22 08:04:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;144 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-address-modes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리의 계층 구조 (Memory Hierarchy)</h2></header><div class=entry-content><p>메모리의 계층 구조 (Memory Hierarchy) 메모리 계층 구조는 컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조.
이 구조는 속도, 용량, 비용 간의 균형을 고려하여 여러 종류의 메모리를 계층적으로 배치한다.
메모리 계층 구조의 각 레벨은 위로 올라갈수록 다음과 같은 특성을 가진다.
접근 속도가 빨라짐 용량이 작아짐 비트당 가격이 높아짐 CPU에 의한 접근 빈도가 증가함 1 2 3 4 5 6 7 8 계층 구조 (위에서 아래로): 레지스터 ↓ 캐시 (L1 → L2 → L3) ↓ 메인 메모리 (RAM) ↓ 보조 기억 장치 (SSD/HDD) 이러한 계층 구조는 ‘참조 지역성(Locality of Reference)’ 원리를 활용하여 전체 시스템의 성능을 최적화한다.
자주 사용되는 데이터를 빠른 상위 계층에 유지함으로써, 평균 데이터 접근 시간을 줄이고 전체적인 시스템 성능을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:33:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리의 계층 구조 (Memory Hierarchy)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;834 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-coherence/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Invalidation</h2></header><div class=entry-content><p>Cache Invalidation Cache Invalidation(캐시 무효화)는 캐시에 저장된 데이터가 더 이상 최신 상태가 아니거나 유효하지 않을 때, 이를 무효화하여 캐시가 최신 데이터를 제공하도록 보장하는 과정이다.
캐시 무효화는 캐싱 시스템에서 데이터 일관성을 유지하고, 잘못된 데이터를 반환하지 않도록 하기 위해 필수적인 메커니즘이다.
Cache Invalidation은 캐싱 시스템에서 필수적인 요소로, 데이터 일관성을 유지하고 잘못된 정보를 방지하기 위해 사용된다. Expiration(TTL), Active Invalidation, Validation-based Caching 등 다양한 전략을 상황에 맞게 선택해야 하며, 구현 시 성능과 복잡성을 균형 있게 고려해야 한다. 올바른 설계와 전략 선택은 시스템의 신뢰성과 효율성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;830 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Invalidation" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-invalidation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy</h2></header><div class=entry-content><p>Cache Strategy Cache Strategy(캐시 전략) 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.
캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.
캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;594 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-strategy/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/memory-architecture/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>