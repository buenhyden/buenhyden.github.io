<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Recursion | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/recursion/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/recursion/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/recursion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/recursion/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Recursion"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Recursion"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Recursion</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비꼬리 재귀(Non-tail Recursion)</h2></header><div class=entry-content><p>비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.
이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.
비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.
이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.
그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비꼬리 재귀(Non-tail Recursion)" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Recursion vs. Iteration</h2></header><div class=entry-content><p>Recursion vs. Iteration Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration vs. Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 11:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Recursion vs. Iteration" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/recursion-vs-iteration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>tail Recursion vs. Non-tail Recursion</h2></header><div class=entry-content><p>Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.
특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.
꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to tail Recursion vs. Non-tail Recursion" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>