<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Programming Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>가비지 컬렉션 (Garbage Collection, GC)</h2></header><div class=entry-content><p>가비지 컬렉션 (Garbage Collection, GC) 프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능
주요 특징 자동 메모리 관리: 프로그래머가 명시적으로 메모리를 해제할 필요가 없다. 메모리 누수 방지: 사용하지 않는 객체를 자동으로 제거하여 메모리 누수를 예방한다. 개발 생산성 향상: 메모리 관리에 대한 부담을 줄여 개발자가 비즈니스 로직에 집중할 수 있게 한다. 실행 시간 오버헤드: 가비지 컬렉션 프로세스가 실행되는 동안 프로그램의 성능에 영향을 줄 수 있다. 기본 원리 도달 가능성(Reachability): 프로그램의 루트(예: 전역 변수, 스택의 지역 변수)로부터 참조 체인을 따라 도달할 수 있는 객체는 “살아있는” 객체로 간주된다. 표시(Mark): GC는 먼저 모든 살아있는 객체를 표시한다. 수집(Sweep): 표시되지 않은 객체들은 “가비지"로 간주되어 메모리에서 해제된다. 주요 알고리즘 참조 카운팅(Reference Counting): 각 객체에 대한 참조 수를 추적하여 참조 수가 0이 되면 해당 객체를 수집합니다. 마크-스윕(Mark-and-Sweep): 루트에서 접근 가능한 모든 객체를 마크하고, 마크되지 않은 객체를 수집합니다. 세대별 수집(Generational Collection): 객체를 새로운 객체와 오래된 객체로 분류하여 효율적으로 관리합니다. 각 언어별 가비지 컬렉션의 특징 특징 Java Python JavaScript 기본 알고리즘 세대별 GC (Generational GC) 참조 카운팅 + 세대별 GC 표시-소거 (Mark-and-Sweep) 메모리 구분 Young Generation (Eden, S0, S1), Old Generation 3세대 (young, middle, old) Heap (New Space, Old Space) GC 종류 Serial, Parallel, CMS, G1, ZGC 참조 카운팅 GC, 세대별 GC V8 엔진의 자동 GC 수동 제어 System.gc() (권장하지 않음) gc.collect() 불가능 약한 참조 지원 WeakReference, SoftReference weakref 모듈 WeakMap, WeakSet 순환 참조 처리 자동 처리 순환 참조 감지기로 처리 자동 처리 GC 일시 중지 Stop-the-World (ZGC 제외) 참조 카운팅은 즉시 수행 증분식 GC로 최소화 튜닝 옵션 JVM 파라미터로 다양한 튜닝 가능 gc 모듈로 제한적 튜닝 엔진 내부에서 자동 최적화 메모리 모니터링 JVM 도구로 상세 모니터링 가능 gc 모듈로 제한적 모니터링 개발자 도구로 제한적 모니터링 각 언어별 가비지 컬렉션 장단점 장단점 Java Python Javascript 장점 - 매우 성숙하고 최적화된 GC 알고리즘
- 다양한 GC 알고리즘 선택 가능
- 세밀한 튜닝 가능 - 참조 카운팅으로 즉시 메모리 해제
- 간단한 구현
- 예측 가능한 동작 - 완전히 자동화된 메모리 관리
- 개발자 개입 최소화
- 증분식 GC로 성능 최적화 단점 - Stop-the-World로 인한 성능 영향
- 복잡한 튜닝 필요
- 메모리 오버헤드 - 순환 참조 처리에 추가 비용
- 참조 카운팅 오버헤드
- 멀티스레딩에서의 성능 영향 - 제어 불가능
- 메모리 사용 예측 어려움
- 브라우저마다 다른 구현 Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class GCDemo { public void createObjects() { // 강한 참조 StringBuilder builder = new StringBuilder(); // 약한 참조 WeakReference&lt;StringBuilder> weakBuilder = new WeakReference&lt;>(new StringBuilder()); // System.gc()를 호출하면 GC가 실행될 수 있지만, // 보장되지는 않습니다 System.gc(); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import gc class CircularRef: def __init__(self): self.ref = None def __del__(self): print("객체가 삭제됨") # 순환 참조 생성 a = CircularRef() b = CircularRef() a.ref = b b.ref = a # 참조 카운트 확인 print(sys.getrefcount(a)) # 2 (변수 a와 b.ref) # 명시적으로 GC 실행 gc.collect() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 // 표시-소거(Mark-and-Sweep) 알고리즘의 대상이 되는 객체 let user = { name: "John" }; // 객체에 대한 참조를 제거 user = null; // WeakMap을 사용한 약한 참조 예시 const weakMap = new WeakMap(); let key = {}; weakMap.set(key, "data"); key = null; // key 객체는 GC의 대상이 됨 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-01 10:19:00 +0000 UTC'>December 1, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;554 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가비지 컬렉션 (Garbage Collection, GC)" href=https://buenhyden.github.io/posts/programming-languages/concepts/garbage-collection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Web Application Server</h2></header><div class=entry-content><p>Python Web Application Server gunicorn, uwsgi, daphne, uvicorn은 모두 Python 웹 애플리케이션을 실행하고 서비스하기 위한 서버 프로그램들이다. 이들은 각각 고유한 특징과 용도를 가지고 있으며, 주로 WSGI(Web Server Gateway Interface) 또는 ASGI(Asynchronous Server Gateway Interface) 프로토콜을 구현한다.
서버 구현체 비교 분석 특성 Gunicorn uWSGI Daphne Uvicorn 서버 유형 WSGI 서버 WSGI/ASGI 서버 ASGI 서버 ASGI 서버 프로토콜 지원 HTTP/1.1 HTTP/1.1, HTTP/2, WebSocket HTTP/1.1, HTTP/2, WebSocket, Server-Sent Events HTTP/1.1, WebSocket 주요 특징 - 안정성과 신뢰성
- 간단한 설정
- 프로세스 관리 용이
- 자동 워커 관리
- 우수한 모니터링 - 다양한 프로토콜 지원
- 높은 확장성
- 복잡한 설정 가능
- 캐싱 기능
- 로드 밸런싱 - Django Channels 기본 서버
- 비동기 처리 최적화
WebSocket 특화
- 실시간 통신 강점 - 경량화 설계
- 빠른 속도
- 간단한 구성
FastAPI 권장 서버 성능 - 중간~높음
- 안정적 성능
- 동시성 처리 우수 - 매우 높음
- 리소스 사용량 다소 높음
- 복잡한 설정 필요 - 높음
- 비동기 처리 최적화
WebSocket 성능 우수 - 매우 높음
- 낮은 지연시간
- 효율적 리소스 사용 사용 사례 - Django/Flask 프로덕션
- 일반적인 웹 애플리케이션
REST API 서버 - 대규모 엔터프라이즈
- 복잡한 서버 구성
- 다중 프로토콜 지원 필요 - 실시간 애플리케이션
- 채팅 서비스
WebSocket 기반 서비스 - FastAPI 애플리케이션
- 마이크로서비스
- 고성능 API 서버 설정 복잡도 낮음 높음 중간 낮음 문서화 수준 우수함 매우 상세함 보통 우수함 커뮤니티 크기 매우 큼 큼 중간 커지는 중 주요 장점 - 안정성
- 쉬운 설정
- 넓은 생태계
- 좋은 모니터링 - 높은 성능
- 다양한 기능
- 유연한 설정
- 풍부한 기능 - 비동기 최적화
WebSocket 특화
Django 통합 우수 - 빠른 속도
- 간단한 설정
- 현대적 구조 주요 단점 - 비동기 제한적
WebSocket 미지원 - 복잡한 설정
- 높은 학습 곡선
- 리소스 사용량 - 제한적 사용 사례
- 작은 생태계 - 제한적 기능
- 새로운 생태계 권장 환경 - 안정성 중시
- 일반 웹 서비스
- 중소규모 서비스 - 대규모 서비스
- 복잡한 요구사항
- 리소스 여유 - 실시간 서비스
- Django Channels
- WebSocket 필수 - 현대적 API
- 마이크로서비스
- 고성능 요구 동시성 모델 프리포크(Pre-fork) 프리포크 + 스레드 비동기 이벤트 루프 비동기 이벤트 루프 로드 밸런싱 내장 내장 별도 설정 필요 Gunicorn과 함께 사용 시 가능 모니터링 내장 도구 우수 상세한 도구 제공 기본적 수준 기본적 수준 배포 용이성 매우 쉬움 복잡함 중간 쉬움 보안 기능 기본적인 보안 기능 다양한 보안 기능 Django 보안 기능 활용 기본적인 보안 기능 확장성 높음 매우 높음 중간 높음 웹소켓 지원 제한적 지원 완벽 지원 지원 호환성 Django, Flask 등 WSGI 프레임워크 Django, Flask, Pyramid 등 WSGI 프레임워크 Django Channels에 특화 FastAPI, Starlette 등 ASGI 프레임워크 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-17 14:06:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;438 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python Web Application Server" href=https://buenhyden.github.io/posts/programming-languages/python/library/python-web-application-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Linter와 Formatter</h2></header><div class=entry-content><p>Python Linter와 Formatter Linter와 Formatter는 코드의 품질과 일관성을 유지하는 데 필수적인 도구.
Linter는 코드의 잠재적인 에러, 버그, 스타일 문제, 그리고 의심스러운 구조들을 찾아내는 도구.
마치 교정 편집자가 글의 문법과 표현을 검토하는 것처럼, Linter는 코드의 품질을 검사한다.
주요 기능:
구문 오류 감지 코딩 스타일 검사 잠재적 버그 발견 코드 복잡도 분석 베스트 프랙티스 제안 보안 취약점 식별 성능 문제 파악 장점:
코드 품질 향상 일관된 코딩 스타일 유지 버그 조기 발견 단점:
...</p></div><footer class=entry-footer><span title='2024-11-13 13:46:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;491 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python Linter와 Formatter" href=https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/python-linter%EC%99%80-formatter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>반복문(Iteration)</h2></header><div class=entry-content><p>반복문(Iteration) 프로그래밍에서 반복문(Iteration)은 특정 코드 블록을 여러 번 실행하는 제어 구조이다.
반복문은 프로그램에서 같은 작업을 여러 번 수행해야 할 때 사용한다.
이를 통해 코드의 중복을 줄이고 효율적으로 작업을 처리할 수 있다.
주요 반복문 종류 for 문:
정해진 횟수만큼 반복할 때 주로 사용. 초기화, 조건, 증감식을 한 줄에 표현한다. while 문:
조건이 참인 동안 계속해서 반복한다. 반복 횟수가 정해지지 않았을 때 유용하다. do-while 문:
while 문과 비슷하지만, 최소 한 번은 실행된다. 반복문의 구성 요소 초기화: 반복문에서 사용할 변수를 초기화한다. 조건식: 반복을 계속할지 결정하는 조건을 설정한다. 반복 실행문: 조건이 참일 때 실행되는 코드 블록이다. 증감식: 반복 변수를 변경하여 언젠가 조건이 거짓이 되도록 한다. 반복문의 장점 코드 재사용: 같은 코드를 여러 번 작성하지 않아도 된다. 효율성: 대량의 데이터나 반복적인 작업을 효율적으로 처리할 수 있다. 가독성: 반복되는 작업을 간결하게 표현할 수 있다. 주의사항 무한 루프: 조건식이 항상 참이 되지 않도록 주의해야 한다. 성능: 중첩된 반복문은 성능에 영향을 줄 수 있으므로 필요한 경우에만 사용한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 15:06:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;152 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 반복문(Iteration)" href=https://buenhyden.github.io/posts/programming-languages/concepts/iteration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>재귀 (Recursion)</h2></header><div class=entry-content><p>재귀 (Recursion) 재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.
재귀 함수는 다음과 같은 두 가지 주요 부분으로 구성된다:
기본 조건 (Base Case): 재귀 호출을 멈추는 조건 재귀 호출 (Recursive Case): 함수가 자기 자신을 호출하는 부분 재귀의 작동 원리 재귀 함수가 호출될 때마다 새로운 함수의 복사본이 만들어져 실행된다.
이 과정은 기본 조건에 도달할 때까지 계속된다.
예를 들어, 팩토리얼을 계산하는 재귀 함수를 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-11-12 15:05:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;489 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 재귀 (Recursion)" href=https://buenhyden.github.io/posts/programming-languages/concepts/recursion/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/programming-languages/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/programming-languages/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>