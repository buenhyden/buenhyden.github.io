<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming Languages | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/programming-languages/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/programming-languages/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/programming-languages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/programming-languages/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming Languages"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming Languages"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Programming Languages</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback Function (콜백 함수)</h2></header><div class=entry-content><p>Callback Function 프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수.
하나의 함수가 실행되는 동안, 특정 시점이나 조건이 충족되었을 때 호출될 함수를 미리 전달하는 방식.
이 개념은 동기적(synchronous) 또는 비동기적(asynchronous) 작업에서 모두 사용되며, 특히 비동기 프로그래밍에서 매우 중요하다.
간단한 예시를 통해 콜백 함수의 개념을 이해:
1 2 3 4 5 6 7 8 9 10 function greet(name, callback) { console.log('안녕하세요, ' + name + '님!'); callback(); } function sayGoodbye() { console.log('안녕히 가세요!'); } greet('홍길동', sayGoodbye); 이 예시에서 sayGoodbye 함수가 콜백 함수로 greet 함수에 전달된다. greet 함수는 인사말을 출력한 후 콜백 함수를 실행한다. 콜백 함수의 동작 원리 함수 전달: 콜백 함수는 다른 함수의 매개변수로 전달된다. 호출 시점 결정: 전달받은 함수는 호출자 함수 내부에서 특정 조건이나 작업 완료 시 호출된다. 결과 처리: 콜백 함수는 호출자 함수의 결과나 상태를 기반으로 추가 작업을 수행한다. 콜백 함수의 장점 코드의 재사용성 동일한 함수에 다른 콜백을 전달하여 다양한 동작을 구현할 수 있다. 중복 코드를 줄일 수 있다. 유연성 실행 시점에 필요한 동작을 결정할 수 있다. 프로그램의 동작을 쉽게 변경할 수 있다. 비동기 프로그래밍 지원 긴 작업을 기다리지 않고 다른 작업을 수행할 수 있다. 프로그램의 반응성을 향상시킬 수 있다. 이벤트 처리 사용자의 행동(클릭, 키보드 입력 등)에 반응하는 데 사용된다. 웹 브라우저의 이벤트 리스너가 대표적인 예시이다. 콜백 함수의 종류 동기적(Synchronous) 콜백 호출자 함수가 실행되는 동안 즉시 호출된다. 일반적으로 작업 순서가 중요할 때 사용된다. 예시: 배열 메서드(forEach, map)에서 사용되는 콜백. 1 2 3 4 const numbers = [1, 2, 3]; numbers.forEach((num) => { console.log(num); // 배열의 각 요소를 출력 }); 비동기적(Asynchronous) 콜백 호출자 함수가 실행된 후, 특정 작업이 완료되었을 때 호출된다. 주로 시간이 걸리는 작업(예: 파일 읽기, API 요청)에서 사용된다. 예시: setTimeout 또는 이벤트 리스너. 1 2 3 setTimeout(() => { console.log("3초 후에 실행됩니다."); }, 3000); 콜백 함수를 사용하는 이유 비동기 작업 처리: 시간이 걸리는 작업(API 요청, 파일 읽기 등)을 처리하는 동안 메인 프로그램 흐름을 막지 않음. 코드 유연성 증가: 특정 작업 이후 실행할 동작을 동적으로 정의 가능. 모듈화 및 재사용성 증가: 코드의 특정 동작을 분리하여 재사용 가능. 주의할 점 콜백 지옥(Callback Hell)
복잡한 비동기 작업이 중첩되어 코드 가독성이 떨어지고 유지보수가 어려워지는 현상.
해결책 Promise 사용: 비동기 작업을 체인 형태로 작성하여 가독성을 개선. Async/Await 사용: 비동기 코드를 동기 코드처럼 작성 가능. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 잘못된 방식 getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { // 콜백 지옥… }); }); }); }); // 올바른 방식 // Promise나 async/await를 사용하여 개선 async function fetchData() { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); // 더 깔끔하고 읽기 쉬운 코드 } 오류 처리
콜백 함수에서 발생하는 오류를 적절히 처리해야 한다.
오류 처리 콜백을 별도로 제공하는 것이 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 잘못된 방식 function fetchData(callback) { // 에러 처리가 없음 callback(data); } // 올바른 방식 function fetchData(callback) { try { // 데이터 처리 callback(null, data); } catch (error) { callback(error, null); } } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 실행 순서 보장
비동기 콜백의 경우 실행 순서를 신중히 고려해야 한다.
필요한 경우 콜백 체인을 사용하여 순서를 보장할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function processUserUnsafe(userId) { let userData; fetchUserData( userId, (user) => { userData = user; console.log("1. 사용자 데이터 받음:", userData); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); // userData가 설정되기 전에 실행될 수 있음 console.log("2. userData 사용:", userData); } // 4. 콜백 체인을 사용한 실행 순서 보장 function processUserSafe(userId) { fetchUserData( userId, (user) => { console.log("1. 사용자 데이터 받음:", user); validateUser(user, (validatedUser) => { console.log("2. 사용자 검증 완료:", validatedUser); updateUser(validatedUser, (updatedUser) => { console.log("3. 사용자 정보 업데이트 완료:", updatedUser); }, (error) => console.error("사용자 업데이트 실패:", error) ); }, (error) => console.error("사용자 검증 실패:", error) ); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); } 파이썬에서의 콜백 함수 예제 파이썬에서도 함수를 매개변수로 전달하여 콜백 함수를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 12:45:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;803 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Function (콜백 함수)" href=https://buenhyden.github.io/posts/programming-languages/concepts/callback-function/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)</h2></header><div class=entry-content><p>동기(Synchronous) 동기(Synchronous)는 작업들이 순차적으로 실행되며, 하나의 작업이 완료된 후에 다음 작업이 시작되는 방식이다.
“동시에 일어난다"는 의미로, 요청과 그 결과가 동시에 일어난다는 약속이다.
파일에서 데이터를 읽고 처리하는 동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 동기식 처리 예제 function processUserData() { // 1. 파일을 읽을 때까지 다음 줄로 진행하지 않음 const userData = readFileSync('user.txt'); // 2. 데이터 처리가 완료될 때까지 대기 const processedData = processData(userData); // 3. 저장이 완료될 때까지 대기 saveToDatabase(processedData); // 4. 모든 작업이 완료된 후에만 실행 console.log('작업 완료!'); } 주요 특징 순차적 실행: 코드가 작성된 순서대로 실행된다. 블로킹(Blocking): 한 작업이 완료될 때까지 다음 작업은 대기한다. 예측 가능성: 코드의 실행 흐름이 명확하고 예측 가능하다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-11-12 00:57:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)" href=https://buenhyden.github.io/posts/programming-languages/concepts/synchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비동기(Asynchronous)</h2></header><div class=entry-content><p>비동기(Asynchronous) 비동기(Asynchronous)는 작업들이 독립적으로 실행되며, 작업의 완료 여부와 관계없이 다음 작업이 시작될 수 있는 방식이다.
“동시에 일어나지 않는다"는 의미로, 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.
파일에서 데이터를 읽고 처리하는 비동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 비동기식 처리 예제 async function processUserData() { try { // 1. 파일을 읽는 동안 다른 작업 수행 가능 const userData = await readFile('user.txt'); // 2. 데이터 처리 중에도 다른 작업 가능 const processedData = await processData(userData); // 3. 데이터베이스 저장 중에도 다른 작업 가능 await saveToDatabase(processedData); console.log('작업 완료!'); } catch (error) { console.error('오류 발생:', error); } } // 메인 프로그램은 계속 실행됨 console.log('프로그램 시작'); processUserData(); console.log('다른 작업 진행 중…'); 주요 특징 비순차적 실행: 작업들이 독립적으로 실행될 수 있다. 논블로킹(Non-blocking): 한 작업이 다른 작업의 실행을 막지 않는다. 이벤트 기반: 작업 완료 시 이벤트나 콜백을 통해 결과를 처리한다. 동시성: 여러 작업을 동시에 처리할 수 있다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-11-12 00:57:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기(Asynchronous)" href=https://buenhyden.github.io/posts/programming-languages/concepts/asynchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS</h2></header><div class=entry-content><p>NodeJS Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경
서버 사이드에서 JavaScript를 실행할 수 있게 해주는 플랫폼으로, 웹 서버 구축부터 네트워크 프로그래밍, 일반적인 서버 사이드 프로그래밍에 이르기까지 다양한 용도로 사용된다.
런타임 환경(Runtime Environment)
프로그램이 실행되는 동안 프로그램을 위한 ‘무대’를 제공하는 시스템.
이를 연극에 비유해보면, 런타임 환경은 배우(프로그램)가 공연할 수 있는 무대, 조명, 음향 시스템 등 모든 필요한 설비를 제공하는 극장과 같다.
주요 구성 요소
메모리 관리 런타임 환경은 프로그램이 사용할 메모리를 할당하고 관리. 기본 라이브러리 제공 런타임 환경은 프로그램이 필요로 하는 기본적인 기능들을 제공. 에러 처리 프로그램 실행 중 발생하는 오류를 감지하고 관리. 하드웨어 및 운영체제와의 상호작용 프로그램과 컴퓨터 시스템 사이의 중개자 역할. 중요성
...</p></div><footer class=entry-footer><span title='2024-11-07 04:45:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;859 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS" href=https://buenhyden.github.io/posts/programming-languages/javascript/nodejs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>코루틴(Coroutine)</h2></header><div class=entry-content><p>코루틴(Coroutine) 코루틴(Coroutine)은 복잡한 비동기 작업을 간단하고 효율적으로 처리할 수 있게 해주는 프로그래밍 개념이다.
프로그램의 실행 흐름을 제어할 수 있는 프로그래밍 구성 요소이다.
일반적인 함수와 달리, 코루틴은 실행을 일시 중단하고 재개할 수 있으며, 여러 진입점과 종료점을 가질 수 있다.
이는 마치 대화하는 것처럼, 실행을 주고받을 수 있다는 특징이 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 # Python에서의 간단한 코루틴 예제 async def simple_coroutine(): print("코루틴 시작") await asyncio.sleep(1) # 중단점 print("1초 후 재개") await asyncio.sleep(1) # 다른 중단점 print("또 1초 후 재개") # 코루틴 실행 async def main(): await simple_coroutine() asyncio.run(main()) https://medium.com/@turxan.dunya97/simple-explanation-what-is-coroutines-in-programming-d01e0ddf6f06
...</p></div><footer class=entry-footer><span title='2024-10-14 06:52:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코루틴(Coroutine)" href=https://buenhyden.github.io/posts/programming-languages/concepts/coroutine/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/programming-languages/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/programming-languages/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>