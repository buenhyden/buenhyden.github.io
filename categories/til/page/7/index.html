<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TIL | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/til/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/til/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/til/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/til/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="TIL"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="TIL"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>TIL</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ExpressJS vs NestJS</h2></header><div class=entry-content><p>ExpressJS Vs NestJS ExpressJS와 NestJS의 주요 특징들을 상세히 비교 분석하여 표로 정리해드리겠습니다.
비교 기준 ExpressJS NestJS 프레임워크 특성 미니멀리스트, 유연한 Node.js 웹 프레임워크 TypeScript 기반의 구조화된 풀스택 프레임워크 아키텍처 스타일 자유로운 구조 (개발자가 직접 설계) Angular 스타일의 모듈식 아키텍처 (강제됨) 언어 지원 JavaScript 중심 (TypeScript도 사용 가능) TypeScript 중심 (JavaScript도 사용 가능) 학습 곡선 낮음 (시작하기 쉬움) 높음 (많은 개념과 패턴 학습 필요) 기본 구조 최소한의 구조만 제공 모듈, 컨트롤러, 서비스 등 세분화된 구조 라우팅 예시 javascript app.get('/users', (req, res) => { res.send('Users list'); }); typescript @Controller('users') export class UsersController { @Get() findAll(): string { return 'Users list'; } } 의존성 주입 없음 (수동으로 구현 필요) 내장된 강력한 DI 시스템 제공 데코레이터 지원 지원하지 않음 광범위한 데코레이터 지원 미들웨어 처리 직관적이고 단순한 미들웨어 체인 복잡하지만 강력한 미들웨어 시스템 테스트 용이성 별도 테스트 도구 설정 필요 내장된 테스트 도구 제공 확장성 수동 구성 필요 모듈 시스템을 통한 쉬운 확장 성능 매우 가벼움 (적은 오버헤드) 약간의 오버헤드 존재 실시간 처리 WebSocket 수동 구현 필요 WebSocket 데코레이터 제공 유효성 검사 외부 라이브러리 필요 내장 파이프를 통한 유효성 검사 문서화 Swagger 등 수동 설정 필요 자동 API 문서 생성 지원 적합한 프로젝트 - 작은 규모의 프로젝트
- 빠른 프로토타이핑
- 마이크로서비스 - 대규모 엔터프라이즈 애플리케이션
- 복잡한 비즈니스 로직
- 팀 프로젝트 개발 생산성 초기에는 빠르나 규모가 커지면 관리 어려움 초기 설정에 시간이 걸리나 장기적으로 생산성 높음 커뮤니티/생태계 매우 큰 커뮤니티, 풍부한 미들웨어 성장하는 커뮤니티, 내장 기능 많음 에러 처리 수동 구현 필요 내장된 예외 필터 시스템 데이터베이스 통합 ORM 선택 자유 TypeORM/Sequelize 등과 쉬운 통합 보안 기능 외부 미들웨어 필요 내장된 보안 기능 제공 모니터링/로깅 외부 도구 통합 필요 내장된 로깅 시스템 제공 선택 가이드:
...</p></div><footer class=entry-footer><span title='2024-11-17 04:50:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ExpressJS vs NestJS" href=https://buenhyden.github.io/til/2024/11/expressjs-vs-nestjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ASGI CGI WSGI</h2></header><div class=entry-content><p>ASGI CGI WSGI 비교 분석 이 기술들은 웹 서버와 애플리케이션 간의 통신 방식을 정의하는 인터페이스 규격.
시대 순으로 발전 과정을 이해하면 좋을 것 같다.
ASGI CGI WSGI 비교 특징 CGI WSGI ASGI 등장 시기 1990년대 초반 2003년 (PEP 333) 2016년 처리 방식 프로세스 기반 동기식 비동기식 성능 매 요청마다 새 프로세스 생성 (낮음) 프로세스 재사용 (중간) 비동기 처리로 높은 성능 프로토콜 지원 HTTP/1.0 HTTP/1.1 HTTP/1.1, HTTP/2, WebSocket 구현 복잡도 단순함 중간 상대적으로 복잡함 메모리 사용 높음 (프로세스당) 중간 효율적 동시성 처리 프로세스 기반 스레드/프로세스 기반 이벤트 루프 기반 주요 사용 사례 레거시 시스템 전통적인 웹 애플리케이션 현대적 웹 애플리케이션 환경 변수 처리 시스템 환경 변수 environ 딕셔너리 scope 딕셔너리 스트리밍 지원 제한적 이터레이터 기반 네이티브 지원 프레임워크 예시 직접 구현 Django, Flask FastAPI, Starlette 서버 예시 Apache gunicorn, uWSGI uvicorn, daphne 오류 처리 제한적 표준화된 방식 포괄적 지원 설정 복잡도 간단 중간 상대적으로 복잡 확장성 제한적 중간 높음 각 기술의 기본적인 구현 예제 CGI (Common Gateway Interface):
...</p></div><footer class=entry-footer><span title='2024-11-16 03:26:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;497 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ASGI CGI WSGI" href=https://buenhyden.github.io/til/2024/11/asgi-cgi-wsgi-%EB%B9%84%EA%B5%90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blocking vs Non-Blocking</h2></header><div class=entry-content><p>Blocking and Non-Blocking Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.
이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.
Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.
Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.
Blocking Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.
해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.
동작 방식 프로세스가 특정 작업을 요청한다. 해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다. 작업이 완료되면 프로세스는 다시 실행 상태로 전환된다. 그동안 다른 작업은 수행될 수 없다. 특징 프로그램의 실행 흐름이 순차적이고 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 응답을 즉시 받을 수 있다. 프로그램 구조가 단순하고 직관적이다. 실제 예시 1 2 3 4 5 6 // Blocking I/O의 예시 File file = new File("example.txt"); FileInputStream input = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = input.read(buffer); // 이 지점에서 Blocking 발생 // 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음 성능 측면 단일 작업의 처리 시간이 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 대기 시간이 발생한다. 구현 복잡도 구현이 단순하다. 디버깅이 쉽다. 코드 흐름이 직관적이다. 적합한 사례 간단한 스크립트 작성 순차적 데이터 처리 즉각적인 응답이 필요한 경우 작은 규모의 애플리케이션 Non-Blocking Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.
작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 12:36:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;801 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blocking vs Non-Blocking" href=https://buenhyden.github.io/til/2024/11/blocking-vs-non-blocking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)와 비동기(Asynchronous)</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 카테고리 동기(Synchronous) 비동기(Asynchronous) 기본 개념 - 작업이 순차적으로 실행됨 - 작업이 독립적으로 실행됨 - 이전 작업이 완료될 때까지 다음 작업 대기 - 작업의 완료를 기다리지 않고 다음 작업 진행 - 실행 순서가 보장됨 - 실행 순서가 보장되지 않음 처리 방식 - 단일 스레드에서 순차적 처리 - 멀티 스레드 또는 이벤트 루프 기반 처리 - 작업 완료까지 대기 - 작업 완료 시 콜백/Promise/async-await 등으로 처리 - 직관적인 코드 흐름 - 비선형적 코드 흐름 장점 - 코드의 가독성이 좋음 - 시스템 자원의 효율적 사용 - 디버깅이 용이함 - 더 나은 사용자 경험 제공 - 에러 처리가 간단함 - 높은 처리량(Throughput) 단점 - 시스템 자원 비효율적 사용 - 코드의 복잡성 증가 - 응답 시간이 길어질 수 있음 - 디버깅이 어려움 - 사용자 경험 저하 가능성 - 에러 처리가 복잡함 적합한 사용 사례 - 간단한 계산 작업 - 네트워크 요청 - 메모리 내 데이터 처리 - 파일 입출력 - 작은 크기의 데이터 처리 - 대용량 데이터 처리 - 순차적 처리가 필요한 작업 - 독립적으로 실행 가능한 작업 에러 처리 - try-catch 블록으로 직접 처리 - Promise의 catch 또는 try-catch와 async-await 사용 - 즉시 에러 감지 및 처리 - 에러 처리가 비동기적으로 발생 - 스택 트레이스 추적이 용이 - 에러 발생 지점 추적이 복잡할 수 있음 성능 특성 - CPU 집약적 작업에 유리 - I/O 집약적 작업에 유리 - 메모리 사용량이 예측 가능 - 동시 처리로 인한 메모리 사용량 변동 - 단일 작업 처리 시간이 빠름 - 전체 처리량 최적화에 유리 코드 관리 - 코드 구조가 단순함 - 상태 관리가 필요함 - 유지보수가 상대적으로 쉬움 - 비동기 패턴에 대한 이해 필요 - 테스트 작성이 용이함 - 테스트 시나리오가 복잡할 수 있음 리소스 활용 - 단일 리소스 점유 - 리소스의 효율적 분배 - 대기 시간 동안 블로킹 - 대기 시간 동안 다른 작업 수행 - 시스템 부하가 예측 가능 - 동시성으로 인한 부하 변동 가능 최신 트렌드 및 발전 방향 동기 프로그래밍의 발전 코루틴(Coroutine) 도입 제너레이터(Generator) 함수 활용 구조적 동시성(Structured Concurrency) 개념 도입 비동기 프로그래밍의 발전 Promise와 async/await의 보편화 반응형 프로그래밍(Reactive Programming)의 확산 이벤트 기반 아키텍처의 발전 비동기 스트림 처리 기술의 발전 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 00:57:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;341 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)와 비동기(Asynchronous)" href=https://buenhyden.github.io/til/2024/11/synchronous-and-asynchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Session base Auth and Cookie base Auth</h2></header><div class=entry-content><p>Session Base Auth and Cookie Base Auth 세션 기반 인증(Session Based Authentication)과 쿠키 기반 인증(Cookie Based Authentication)은 웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식이다.
두 용어는 종종 혼용되어 사용되지만, 정확히 말하면 서로 다른 개념으로, 쿠키 기반 인증은 클라이언트 측의 저장 메커니즘을 가리키는 반면, 세션 기반 인증은 서버 측의 상태 관리 방식을 의미한다.
실제로 대부분의 세션 기반 인증은 쿠키를 전송 수단으로 사용한다. 이것이 바로 이 두 용어가 자주 혼용되는 이유이다.
...</p></div><footer class=entry-footer><span title='2024-11-11 02:10:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session base Auth and Cookie base Auth" href=https://buenhyden.github.io/til/2024/11/session-base-auth-and-cookie-base-auth/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/til/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/til/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>