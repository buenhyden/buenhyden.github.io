<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Engineering | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-engineering/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-engineering/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-engineering/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-engineering/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Engineering"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Engineering"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Engineering</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>System Design Overview</h2></header><div class=entry-content><p>System Design System Design 은 요구사항을 충족하는 대규모 시스템을 설계하고 구성하는 과정으로, 기능적/비기능적 요구사항을 고려해 컴포넌트 간 관계, 데이터 흐름, 장애 대응, 확장 구조를 정의한다. 이는 클라우드 환경, 분산 시스템, 고가용성 아키텍처 설계 등과 밀접하며, 효율적인 아키텍처 설계를 통해 성능, 확장성, 유지보수성을 극대화하는 것이 목적이다. 실무에서는 설계 원칙과 패턴, 트레이드오프 분석 등이 핵심이다.
등장 배경 및 발전 과정 시스템 디자인은 인터넷과 클라우드 컴퓨팅의 발전과 함께 등장했다.
초기 단일 서버 아키텍처에서 시작하여 웹 2.0 시대의 대용량 트래픽 처리 필요성, 클라우드 컴퓨팅의 보편화, 마이크로서비스 아키텍처의 등장으로 발전해왔다.
...</p></div><footer class=entry-footer><span title='2025-05-27 08:37:00 +0000 UTC'>May 27, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design Overview" href=https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Engineering Overview</h2></header><div class=entry-content><p>Software Engineering 소프트웨어 공학은 설계 원칙과 프로세스 모델을 기반으로 안정적이고 유지보수 가능한 시스템을 만드는 분야이다. 요구사항 정의 단계에서부터, 구조 설계 (아키텍처), 구현, 검증 (테스트), 배포, 유지보수까지 전 과정을 체계화한다. SOLID, SoC, DRY 등의 설계 원칙과 애자일, DevOps, CI/CD, Secure‑by‑Design 등의 방법론을 통해 품질 및 효율을 높인다. 실무에서는 조직규모, 도메인, 기술스택에 따라 프로젝트 특성에 맞는 전략이 요구된다.
핵심 개념 분류 개념 정확한 유형 설명 및 근거 기초 개념 소프트웨어 생명주기 (SDLC) 모델 / 프로세스 계획 → 폐기의 전 과정 (Waterfall, Agile 등은 모델) 요구사항 엔지니어링 활동 (Activity) 요구사항 분석, 명세, 검증, 관리 과정 소프트웨어 아키텍처 개념 / 설계 산출물 시스템 구조의 상위 수준 표현 품질 보증 (Quality Assurance) 프로세스 / 활동 품질 보장을 위한 테스트 및 검토 활동 심화 개념 모듈화 (Modularity) 설계 기법 / 원리 기능을 독립 모듈로 분리 추상화 (Abstraction) 설계 원리 (Design Principle) 복잡성 관리 기법 캡슐화 (Encapsulation) 객체지향 설계 원칙 정보 은닉을 통한 안정성 확보 의존성 관리 설계 기법 / 원리 모듈 간 결합도 최소화 설계 원칙 SOLID 객체지향 설계 원칙 (OOP Principles) 5 가지 핵심 원칙 (Robert C. Martin) SoC (Separation of Concerns) 설계 원리 (Architectural Principle) 관심사 분리를 통한 유지보수성 향상 KISS 설계 원리 (Heuristic Design Principle) 단순한 설계 지향 DRY 설계 원리 (Heuristic Design Principle) 중복 최소화 Secure-by-Design 보안 설계 전략 설계 단계에서 보안 내재화 생명주기 모델 Waterfall 생명주기 모델 (프로세스) 단계별 순차적 개발, 각 단계가 명확히 구분 [5]. Agile 생명주기 모델/방법론 반복적, 점진적, 협업 강조, 변화에 유연 [5]. DevOps 생명주기 모델/방법론 개발과 운영 통합, 자동화 및 협업 강조 [5]. Spiral 생명주기 모델 (프로세스) 위험 분석과 반복적 개발 결합 [5]. 프로세스 모델 DevOps 문화 + 자동화 프로세스 개발과 운영의 통합 접근 방식 품질 속성 ISO/IEC 25010 품질 속성 모델 (Quality Model) 기능성, 신뢰성, 보안성 등 8 대 속성 아키텍처 스타일 계층형 (Layered) 아키텍처 스타일 (Architecture Style) 표현 구조에 기반한 통신 방식 정의 이벤트 기반 (Event-driven) 아키텍처 스타일 (Architecture Style) 비동기 이벤트 흐름 중심 구조 마이크로서비스 (Microservices) 아키텍처 스타일 (Architecture Style) 독립 배포 가능한 서비스 단위 구성 아키텍처 패턴 클린 아키텍처 (Clean Architecture) 아키텍처 패턴 (Architecture Pattern) 의존성 역전 및 계층 분리 명확 도구 및 자동화 Git, CI/CD, 테스트 자동화, ASE 도구 / 자동화 기술 개발 및 품질 보증 자동화 지원 도구 협업 방법론 애자일 (Scrum, Kanban) 협업 방법론 / 개발 방법론 반복적 개발과 빠른 피드백 중심 방식 DevOps 협업 문화 / 프로세스 통합 프레임워크 자동화 기반의 개발–운영 연계 플랫폼 엔지니어링 운영 전략 / 엔지니어링 접근법 개발자 생산성 향상을 위한 내부 플랫폼 운영 품질 속성 기능성 (Functionality) 품질 속성 요구사항에 맞는 기능 제공 신뢰성 (Reliability) 품질 속성 오류 없이 안정적으로 동작 사용성 (Usability) 품질 속성 사용자가 쉽게 사용할 수 있음 유지보수성 (Maintainability) 품질 속성 변경, 수정, 확장이 용이함 효율성 (Efficiency) 품질 속성 자원 활용 및 성능 최적화 보안 (Security) 품질 속성/설계 원칙 외부 위협으로부터 안전하게 보호 이식성 (Portability) 품질 속성 다양한 환경에서 실행 가능 배경 초기 소프트웨어 개발:
1960 년대 이전까지는 소프트웨어 개발이 비체계적이고, 예산 초과, 일정 지연, 품질 저하 등 문제가 많았음. 소프트웨어 위기:
1960~70 년대, 소프트웨어의 복잡성 증가로 인해 소프트웨어 위기 (Software Crisis) 가 발생. 소프트웨어 공학 등장:
1968 년 NATO 소프트웨어 공학 회의에서 ’ 소프트웨어 공학 ’ 개념이 공식화됨. 현대:
SDLC, Agile, DevOps 등 다양한 방법론과 도구가 발전하며 효율적이고 신뢰성 높은 소프트웨어 개발이 가능해짐. 소프트웨어 위기 (Software Crisis) 란 1960 년대 후반부터 본격적으로 대두된 용어로, 소프트웨어 개발 및 유지보수 과정에서 발생하는 일련의 심각한 관리상 문제를 의미한다. 이는 컴퓨터 하드웨어의 성능이 빠르게 발전하고, 소프트웨어의 규모와 복잡성이 급격히 증가함에 따라 기존의 개발 방법론과 도구들이 부적합해지면서 나타난 현상이다.
소프트웨어 위기의 대표적인 증상은 다음과 같다: - 프로젝트 일정 및 예산 초과: 개발이 예정보다 오래 걸리고, 비용이 증가함. - 소프트웨어 품질 저하: 버그와 결함이 많아지고, 사용자 요구를 충족시키지 못함. - 유지보수의 어려움: 설계가 변경에 유연하지 못해 유지보수 비용이 증가함. - 프로젝트 관리의 어려움: 코드 관리와 프로젝트 통제가 힘들어짐. - 소프트웨어의 미전달: 최종적으로 소프트웨어가 고객에게 전달되지 못하는 경우도 발생
오늘날에는 ‘모던 소프트웨어 위기 (Modern Software Crisis)’ 혹은 ‘소프트웨어 난제 (Software Complexity Problem)’ 이라는 형태로 지속되고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 10:20:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Engineering Overview" href=https://buenhyden.github.io/posts/software-development--engineering/overview/software-engineering/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Architecture Styles and Patterns</h2></header><div class=entry-content><p>Architecture Styles and Patterns Architecture Styles and Patterns 는 애플리케이션 및 분산 시스템에서 반복적으로 나타나는 설계 구조를 체계화한 개념으로, 소프트웨어 시스템의 구조, 컴포넌트 간 상호작용, 데이터 흐름, 확장성, 유지보수성 등 시스템의 근간을 결정한다.
아키텍처 스타일은 응용 시스템의 전체 구조를 포괄하는 추상적 설계 지침 (예: 레이어드, 이벤트 드리븐, 마이크로서비스 등) 이며, 아키텍처 패턴은 이러한 스타일을 실제 구현 수준에서 구체화한 설계 템플릿이다. 스타일은 전체 조직 구조를 정의하며, 패턴은 모듈간 상호작용 및 컴포넌트 분리 방식 등 설계 상세를 제공한다. 각각은 요구사항에 따라 성능, 확장성, 유지보수성, 응답성, 보안 등 품질 속성에 대한 타협점을 설명하며, 실무에서는 이를 조합하거나 상황에 맞춰 커스터마이징하는 전략이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-06-14 07:18:00 +0000 UTC'>June 14, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Architecture Styles and Patterns" href=https://buenhyden.github.io/posts/system-architecture--design/overview/architecture-styles--patterns/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>