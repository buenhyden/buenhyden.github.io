<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Data Structure and Algorithm</title><link>https://buenhyden.github.io/categories/data-structure-and-algorithm/</link><description>Recent content in Data Structure and Algorithm on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 25 Nov 2024 09:18:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/categories/data-structure-and-algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structure</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</link><pubDate>Sun, 27 Oct 2024 06:25:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</guid><description>
&lt;h2>Data Structure&lt;span class="hx-absolute -hx-mt-20" id="data-structure">&lt;/span>
&lt;a href="#data-structure" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>데이터를 체계적으로 구성하고 저장하며, 효율적으로 처리하기 위한 방법을 제공한다.&lt;br>
 프로그래밍에서 데이터를 다루는 기본적인 도구로, 효율적인 알고리즘 설계와 문제 해결의 핵심 요소이다.&lt;/p>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>효율성&lt;/strong>: 데이터를 효율적으로 저장하고 검색하여 프로그램의 성능을 향상시킨다.&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>: 데이터 양이 증가해도 적절히 설계된 데이터 구조는 확장성을 제공한다.&lt;/li>
&lt;li>&lt;strong>유지보수성&lt;/strong>: 체계적인 데이터 구조는 코드 유지보수와 이해를 용이하게 만든다.&lt;/li>
&lt;li>&lt;strong>추상화&lt;/strong>: 데이터 구조는 추상 데이터 타입(ADT)을 구현하여 내부 동작을 숨기고, 사용자는 인터페이스만 활용한다.&lt;/li>
&lt;/ol>
&lt;h3>데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="데이터-구조">&lt;/span>
&lt;a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;img src="e1aca977880d4dce83f295c00.svg" alt="Types of Data Structure" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.designgurus.io/course-play/grokking-data-structures-for-coding-interviews/doc/types-of-data-structures" target="_blank" rel="noopener">https://www.designgurus.io/course-play/grokking-data-structures-for-coding-interviews/doc/types-of-data-structures&lt;/a> _&lt;/p>
&lt;h4>기본 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="기본-데이터-구조">&lt;/span>
&lt;a href="#%ea%b8%b0%eb%b3%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>선형 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="선형-데이터-구조">&lt;/span>
&lt;a href="#%ec%84%a0%ed%98%95-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>배열 (Array)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 연속된 메모리 공간&lt;br>• 인덱스로 직접 접근&lt;br>• 고정된 크기&lt;br>• 캐시 지역성 우수&lt;/td>
&lt;td>• 순차적 데이터 저장&lt;br>• 빈번한 읽기 작업&lt;br>• 크기가 고정된 데이터&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동적 배열 (Dynamic Array)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 크기 자동 조정&lt;br>• 여유 공간 유지&lt;br>• 재할당 비용 발생&lt;br>• 배열의 장점 유지&lt;/td>
&lt;td>• 가변 크기 데이터&lt;br>• 스택 구현&lt;br>• 버퍼 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>연결 리스트 (Linked List)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 동적 메모리 할당&lt;br>• 불연속 메모리&lt;br>• 포인터로 연결&lt;br>• 유연한 크기 조정&lt;/td>
&lt;td>• 빈번한 삽입/삭제&lt;br>• 메모리 효율성 중요&lt;br>• 스택/큐 구현&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>스택 (Stack)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• LIFO 구조&lt;br>• 제한된 접근&lt;br>• 간단한 구현&lt;br>• 함수 호출 관리&lt;/td>
&lt;td>• 함수 호출 스택&lt;br>• 실행 취소&lt;br>• 괄호 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>큐 (Queue)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• FIFO 구조&lt;br>• 순차적 처리&lt;br>• 대기열 관리&lt;br>• 버퍼링 지원&lt;/td>
&lt;td>• 작업 스케줄링&lt;br>• 버퍼 관리&lt;br>• BFS 구현&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>비선형 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="비선형-데이터-구조">&lt;/span>
&lt;a href="#%eb%b9%84%ec%84%a0%ed%98%95-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>이진 트리 (Binary Tree)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 계층적 구조&lt;br>• 최대 2개 자식&lt;br>• 재귀적 속성&lt;br>• 트리 순회 용이&lt;/td>
&lt;td>• 계층 데이터&lt;br>• 수식 표현&lt;br>• 결정 트리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이진 검색 트리 (BST)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 정렬된 트리&lt;br>• 중위 순회로 정렬&lt;br>• 불균형 가능&lt;br>• 검색 최적화&lt;/td>
&lt;td>• 정렬된 데이터&lt;br>• 범위 검색&lt;br>• 데이터베이스 인덱스&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>힙 (Heap)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 완전 이진 트리&lt;br>• 우선순위 관리&lt;br>• 부모-자식 관계&lt;br>• 효율적인 최댓값/최솟값&lt;/td>
&lt;td>• 우선순위 큐&lt;br>• 힙 정렬&lt;br>• 작업 스케줄링&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>고급 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="고급-데이터-구조">&lt;/span>
&lt;a href="#%ea%b3%a0%ea%b8%89-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>해시 기반 구조&lt;span class="hx-absolute -hx-mt-20" id="해시-기반-구조">&lt;/span>
&lt;a href="#%ed%95%b4%ec%8b%9c-%ea%b8%b0%eb%b0%98-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>해시 테이블&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>• 키-값 쌍&lt;br>• 해시 함수 사용&lt;br>• 충돌 해결 필요&lt;br>• 동적 크기 조정&lt;/td>
&lt;td>• 캐싱&lt;br>• 데이터베이스 인덱싱&lt;br>• 심볼 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>블룸 필터&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(k)&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(k)&lt;/td>
&lt;td>• 확률적 자료구조&lt;br>• 공간 효율적&lt;br>• 거짓 양성 가능&lt;br>• 삭제 불가&lt;/td>
&lt;td>• 중복 검사&lt;br>• 캐시 필터링&lt;br>• 스펠링 체크&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>균형 트리&lt;span class="hx-absolute -hx-mt-20" id="균형-트리">&lt;/span>
&lt;a href="#%ea%b7%a0%ed%98%95-%ed%8a%b8%eb%a6%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AVL 트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 엄격한 균형&lt;br>• 자동 재조정&lt;br>• 높이 차이 ≤1&lt;br>• 빈번한 회전&lt;/td>
&lt;td>• 안정적 성능 필요&lt;br>• 데이터베이스&lt;br>• 메모리 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>레드-블랙 트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 느슨한 균형&lt;br>• 컬러 속성&lt;br>• 적은 회전&lt;br>• 실용적 성능&lt;/td>
&lt;td>• 파일 시스템&lt;br>• 프로세스 스케줄링&lt;br>• STL 구현&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B-트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 다중 경로&lt;br>• 디스크 최적화&lt;br>• 노드당 많은 키&lt;br>• 높이 균형&lt;/td>
&lt;td>• 데이터베이스&lt;br>• 파일 시스템&lt;br>• 외부 메모리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>특수 목적 구조&lt;span class="hx-absolute -hx-mt-20" id="특수-목적-구조">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%88%98-%eb%aa%a9%ec%a0%81-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>트라이 (Trie)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>• 문자열 특화&lt;br>• 접두사 검색&lt;br>• 공간 집약적&lt;br>• 효율적 검색&lt;/td>
&lt;td>• 자동 완성&lt;br>• 사전&lt;br>• 라우팅 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>그래프&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(V+E)&lt;/td>
&lt;td>• 노드와 엣지&lt;br>• 다양한 표현&lt;br>• 복잡한 관계&lt;br>• 순환 가능&lt;/td>
&lt;td>• 소셜 네트워크&lt;br>• 네비게이션&lt;br>• 네트워크 토폴로지&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스조인트 셋&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>• 집합 관리&lt;br>• 경로 압축&lt;br>• 유니온-파인드&lt;br>• 거의 상수 시간&lt;/td>
&lt;td>• 크루스칼 알고리즘&lt;br>• 연결성 확인&lt;br>• 클러스터링&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>[m: 문자열 길이, V: 정점 수, E: 간선 수, α(n): 애커만 함수의 역함수]&lt;/p>
&lt;h3>데이터 구조의 선택 기준&lt;span class="hx-absolute -hx-mt-20" id="데이터-구조의-선택-기준">&lt;/span>
&lt;a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0%ec%9d%98-%ec%84%a0%ed%83%9d-%ea%b8%b0%ec%a4%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>다음과 같은 요소들을 고려하여 결정된다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>데이터 접근 패턴&lt;/p>
&lt;ul>
&lt;li>배열은 인덱스를 통한 빠른 접근이 가능하지만 삽입과 삭제가 어렵다.&lt;/li>
&lt;li>링크드 리스트는 삽입과 삭제가 용이하지만 데이터 접근 속도가 느릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>시간 복잡도와 공간 복잡도&lt;/p>
&lt;ul>
&lt;li>해시 테이블은 평균적으로 O(1)의 시간 복잡도를 가지지만, 최악의 경우 O(n)이 될 수 있다.&lt;/li>
&lt;li>이진 검색 트리는 평균적으로 O(log n)의 검색, 삽입, 삭제 시간이 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터의 크기와 형태&lt;/p>
&lt;ul>
&lt;li>대용량 데이터를 처리해야 하는 경우, 배열과 같은 연속된 메모리 공간을 요구하는 자료 구조는 부적합할 수 있다.&lt;/li>
&lt;li>트리나 그래프는 복잡한 데이터 구조를 나타내는 데 유리하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>특정 연산의 빈도&lt;/p>
&lt;ul>
&lt;li>큐나 스택은 삽입과 삭제가 빈번한 경우에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동시성 제어&lt;/p>
&lt;ul>
&lt;li>멀티스레드 환경에서는 스레드 안전성을 제공하는 자료 구조를 선택해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>사용 용이성 및 유지보수&lt;/p>
&lt;ul>
&lt;li>간단한 자료 구조를 선호하는 것이 유지 보수 측면에서 유리할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>응용 프로그램의 요구 사항&lt;/p>
&lt;ul>
&lt;li>각 응용 프로그램의 고유한 요구 사항과 제약 조건에 맞는 최적의 자료 구조를 선택해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>자료의 처리 시간과 활용 빈도&lt;/p>
&lt;ul>
&lt;li>자료의 처리 시간, 크기, 활용 빈도, 갱신 정도를 고려해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘과의 조화&lt;/p>
&lt;ul>
&lt;li>특정 자료 구조를 사용하는 것이 특정 알고리즘을 구현하기에 적합한 경우가 있으므로, 이 두 가지를 조화롭게 고려해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 기준들을 종합적으로 고려하여 문제 해결에 가장 적합한 데이터 구조를 선택해야 한다.&lt;br>
효율적인 데이터 구조 선택은 알고리즘의 성능을 최적화하고 전반적인 프로그램의 효율성을 높이는 데 중요한 역할을 한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>계산 복잡도 (Computational Complexity)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/</link><pubDate>Sat, 26 Oct 2024 01:46:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/</guid><description>
&lt;h2>계산 복잡도 (Computational Complexity)&lt;span class="hx-absolute -hx-mt-20" id="계산-복잡도-computational-complexity">&lt;/span>
&lt;a href="#%ea%b3%84%ec%82%b0-%eb%b3%b5%ec%9e%a1%eb%8f%84-computational-complexity" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>계산 복잡도 이론은 컴퓨터 과학의 중요한 분야로, 알고리즘과 문제의 효율성을 분석하고 분류하는 데 사용된다. 이는 알고리즘이나 문제를 해결하는 데 필요한 자원의 양을 측정하는 것으로, 주로 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 나누어 분석한다.&lt;/p>
&lt;p>계산 복잡도 이론은 다음과 같은 주요 특징을 가진다:&lt;/p>
&lt;ol>
&lt;li>문제 해결에 필요한 자원의 양을 정량화한다.&lt;/li>
&lt;li>알고리즘의 효율성을 평가하고 비교한다.&lt;/li>
&lt;li>문제를 복잡도 클래스로 분류한다.&lt;/li>
&lt;li>주로 최악의 경우 시나리오를 고려한다.&lt;/li>
&lt;/ol>
&lt;h3>시간복잡도와 공간복잡도 (Time Complexity and Space Complexity)&lt;span class="hx-absolute -hx-mt-20" id="시간복잡도와-공간복잡도-time-complexity-and-space-complexity">&lt;/span>
&lt;a href="#%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84%ec%99%80-%ea%b3%b5%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84-time-complexity-and-space-complexity" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>시간복잡도와 공간복잡도는 알고리즘의 효율성을 평가하는 중요한 개념으로, 이를 이해하고 최적화하는 것은 효율적인 알고리즘 설계의 핵심이다. 알고리즘의 효율성을 개선하기 위해서는 다양한 알고리즘 설계 기법을 이해하고 적용할 필요가 있으며, 이를 통해 더 나은 알고리즘을 개발할 수 있다.&lt;/p>
&lt;h3>시간복잡도 (Time Complexity)&lt;span class="hx-absolute -hx-mt-20" id="시간복잡도-time-complexity">&lt;/span>
&lt;a href="#%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84-time-complexity" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 측정한다:&lt;/p>
&lt;ul>
&lt;li>입력 크기에 따른 연산 횟수로 표현된다.&lt;/li>
&lt;li>주로 빅오(Big O) 표기법을 사용합니다.&lt;/li>
&lt;li>예: O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)&lt;br>
시간 복잡도는 알고리즘의 실행 속도를 나타내며, 주로 반복문의 수행 횟수에 큰 영향을 받는다.&lt;/li>
&lt;/ul>
&lt;h4>주요 종류 (Big O 표기법)&lt;span class="hx-absolute -hx-mt-20" id="주요-종류-big-o-표기법">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98-big-o-%ed%91%9c%ea%b8%b0%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>O(1) - 상수 시간&lt;span class="hx-absolute -hx-mt-20" id="o1---상수-시간">&lt;/span>
&lt;a href="#o1---%ec%83%81%ec%88%98-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기와 관계없이 항상 같은 시간이 걸린다.&lt;/li>
&lt;li>가장 효율적인 시간복잡도&lt;/li>
&lt;li>예: 배열의 첫 번째 요소 접근, 스택의 push/pop 연산&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">constant_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;배열의 첫 번째 요소를 반환하는 함수&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="kc">None&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(log n) - 로그 시간&lt;span class="hx-absolute -hx-mt-20" id="olog-n---로그-시간">&lt;/span>
&lt;a href="#olog-n---%eb%a1%9c%ea%b7%b8-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기가 증가할 때마다 처리 시간이 로그만큼만 증가&lt;/li>
&lt;li>매우 효율적이며, 큰 데이터셋에서도 좋은 성능을 보인다.&lt;/li>
&lt;li>예: 이진 탐색, 균형 이진 트리에서의 검색&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">binary_search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;정렬된 배열에서 이진 검색 수행&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(n) - 선형 시간&lt;span class="hx-absolute -hx-mt-20" id="on---선형-시간">&lt;/span>
&lt;a href="#on---%ec%84%a0%ed%98%95-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기에 비례하여 실행 시간이 증가합니다.&lt;/li>
&lt;li>적절한 효율성을 가지며, 많은 기본 알고리즘의 시간복잡도.&lt;/li>
&lt;li>예: 배열의 모든 요소 순회, 선형 탐색&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">linear_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;배열의 모든 요소를 순회하며 합계를 계산&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># n번 반복&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">num&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">total&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(n Log n) - 선형 로그 시간&lt;span class="hx-absolute -hx-mt-20" id="on-log-n---선형-로그-시간">&lt;/span>
&lt;a href="#on-log-n---%ec%84%a0%ed%98%95-%eb%a1%9c%ea%b7%b8-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>선형-로그 시간으로, 효율적인 정렬 알고리즘의 시간복잡도.&lt;/li>
&lt;li>대규모 데이터 정렬에 적합&lt;/li>
&lt;li>예: 퀵 정렬, 병합 정렬&lt;/li>
&lt;/ul>
&lt;h5>O(n^2) - 이차 시간&lt;span class="hx-absolute -hx-mt-20" id="on2---이차-시간">&lt;/span>
&lt;a href="#on2---%ec%9d%b4%ec%b0%a8-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기의 제곱에 비례하여 실행 시간이 증가한다.&lt;/li>
&lt;li>작은 입력에는 괜찮지만, 큰 데이터셋에서는 비효율적&lt;/li>
&lt;li>예: 버블 정렬, 선택 정렬&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">quadratic_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;모든 가능한 숫자 쌍의 합을 계산&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)):&lt;/span> &lt;span class="c1"># n번 반복&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)):&lt;/span> &lt;span class="c1"># 각각에 대해 n번 반복&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">results&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(2^n) - 지수 시간&lt;span class="hx-absolute -hx-mt-20" id="o2n---지수-시간">&lt;/span>
&lt;a href="#o2n---%ec%a7%80%ec%88%98-%ec%8b%9c%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>가장 비효율적인 시간복잡도&lt;/li>
&lt;li>입력이 하나 증가할 때마다 실행 시간이 두 배로 증가하는 알고리즘&lt;/li>
&lt;li>재귀적인 문제나 백트래킹 문제에서 발생&lt;/li>
&lt;li>예시: 피보나치 수열을 계산하는 단순 재귀 알고리즘.&lt;/li>
&lt;/ul>
&lt;h5>O(n!) - 팩토리얼 시간 복잡도&lt;span class="hx-absolute -hx-mt-20" id="on---팩토리얼-시간-복잡도">&lt;/span>
&lt;a href="#on---%ed%8c%a9%ed%86%a0%eb%a6%ac%ec%96%bc-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>매우 비효율적인 시간복잡도&lt;/li>
&lt;li>데이터의 모든 가능한 순열을 확인해야 하는 경우&lt;/li>
&lt;li>예시: 순열을 전부 확인하는 완전 탐색 알고리즘&lt;/li>
&lt;/ul>
&lt;h3>공간복잡도 (Space Complexity)&lt;span class="hx-absolute -hx-mt-20" id="공간복잡도-space-complexity">&lt;/span>
&lt;a href="#%ea%b3%b5%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84-space-complexity" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>공간 복잡도는 알고리즘이 실행되는 동안 사용하는 메모리의 양을 측정한다:&lt;/p>
&lt;ul>
&lt;li>고정 공간: 입력 크기와 무관한 공간 (변수, 상수 등)&lt;/li>
&lt;li>가변 공간: 입력 크기에 따라 변하는 공간 (동적 할당 메모리, 재귀 호출 스택 등)&lt;br>
공간 복잡도는 S(P) = c + Sp(n) 형태로 표현되며, c는 고정 공간, Sp(n)은 가변 공간을 나타낸다.&lt;/li>
&lt;/ul>
&lt;h4>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>O(1) - 상수 공간&lt;span class="hx-absolute -hx-mt-20" id="o1---상수-공간">&lt;/span>
&lt;a href="#o1---%ec%83%81%ec%88%98-%ea%b3%b5%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기와 관계없이 일정한 추가 공간만 사용한다.&lt;/li>
&lt;li>메모리 효율이 가장 좋다.&lt;/li>
&lt;li>예시: 간단한 변수 몇 개만 사용하는 경우&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">space_constant&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;입력 크기와 관계없이 일정한 추가 공간만 사용&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(n) - 선형 공간&lt;span class="hx-absolute -hx-mt-20" id="on---선형-공간">&lt;/span>
&lt;a href="#on---%ec%84%a0%ed%98%95-%ea%b3%b5%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기에 비례하는 추가 공간이 필요하다.&lt;/li>
&lt;li>많은 알고리즘의 일반적인 공간복잡도.&lt;/li>
&lt;li>예시: 입력 크기만큼의 새로운 배열을 생성하는 경우&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">space_linear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;입력 크기에 비례하는 추가 공간 사용&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span> &lt;span class="c1"># 크기 n의 새로운 배열 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">results&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>O(n^2) - 이차 공간&lt;span class="hx-absolute -hx-mt-20" id="on2---이차-공간">&lt;/span>
&lt;a href="#on2---%ec%9d%b4%ec%b0%a8-%ea%b3%b5%ea%b0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>입력 크기의 제곱에 비례하는 공간이 필요.&lt;/li>
&lt;li>큰 입력에 대해 많은 메모리가 필요.&lt;/li>
&lt;li>예시: n×n 크기의 2차원 행렬을 생성하는 경우&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">space_quadratic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;2차원 행렬 생성&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">matrix&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">row&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">matrix&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>시간 복잡도와 공간 복잡도의 관계&lt;span class="hx-absolute -hx-mt-20" id="시간-복잡도와-공간-복잡도의-관계">&lt;/span>
&lt;a href="#%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84%ec%99%80-%ea%b3%b5%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84%ec%9d%98-%ea%b4%80%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>시간 복잡도와 공간 복잡도는 종종 상호 관련이 있지만, 항상 반비례 관계에 있는 것은 아니다:&lt;/p>
&lt;ol>
&lt;li>일반적으로 시간을 절약하기 위해 더 많은 공간을 사용하거나, 공간을 절약하기 위해 더 많은 시간을 소비하는 경향이 있다.&lt;/li>
&lt;li>현대 컴퓨팅에서는 메모리가 상대적으로 풍부해져 시간 복잡도에 더 중점을 두는 경향이 있다.&lt;/li>
&lt;/ol>
&lt;h3>계산 복잡도의 중요성&lt;span class="hx-absolute -hx-mt-20" id="계산-복잡도의-중요성">&lt;/span>
&lt;a href="#%ea%b3%84%ec%82%b0-%eb%b3%b5%ec%9e%a1%eb%8f%84%ec%9d%98-%ec%a4%91%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>알고리즘 효율성 평가: 다양한 알고리즘의 성능을 객관적으로 비교할 수 있다.&lt;/li>
&lt;li>자원 사용 예측: 대규모 데이터 처리 시 필요한 시간과 메모리를 예측할 수 있다.&lt;/li>
&lt;li>알고리즘 설계: 효율적인 알고리즘을 개발하는 데 지침을 제공한다.&lt;/li>
&lt;li>문제 분류: NP-완전 문제와 같은 복잡도 클래스를 통해 문제의 난이도를 분류한다.&lt;/li>
&lt;/ol>
&lt;h3>최적화하는 방법&lt;span class="hx-absolute -hx-mt-20" id="최적화하는-방법">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%a0%81%ed%99%94%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>시간 복잡도와 공간 복잡도 사이에는 종종 트레이드오프 관계가 있으므로, 상황에 따라 적절한 균형을 찾는 것이 중요하다. 또한 실제 성능 측정을 통해 최적화의 효과를 확인하고, 필요한 수준의 성능과 자원 사용을 고려하여 균형을 맞추는 것이 중요하다.&lt;/p>
&lt;blockquote>
&lt;p>트레이드 오프(Trade-off)&lt;br>
두 개의 대안이 있을 때, 어느 하나를 선택하면 다른 하나의 성과가 줄어드는 상황.&lt;br>
즉, 한 쪽을 추구하면 다른 쪽을 희생해야 하는 관계를 의미한다.&lt;/p>
&lt;/blockquote>
&lt;p>시간 복잡도와 공간 복잡도를 최적화하는 방법은 다음과 같다:&lt;/p>
&lt;h4>시간 복잡도 최적화&lt;span class="hx-absolute -hx-mt-20" id="시간-복잡도-최적화">&lt;/span>
&lt;a href="#%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84-%ec%b5%9c%ec%a0%81%ed%99%94" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>
&lt;p>효율적인 알고리즘 선택&lt;/p>
&lt;ul>
&lt;li>정렬이 필요한 경우 O(n log n) 시간 복잡도를 가진 퀵 정렬이나 병합 정렬 사용&lt;/li>
&lt;li>탐색 시 이진 탐색 등의 O(log n) 알고리즘 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>반복문 최적화&lt;/p>
&lt;ul>
&lt;li>중첩 반복문 줄이기&lt;/li>
&lt;li>불필요한 반복 제거&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>적절한 자료구조 사용&lt;/p>
&lt;ul>
&lt;li>해시 테이블을 이용한 O(1) 시간 복잡도의 검색 구현&lt;/li>
&lt;li>균형 이진 트리를 이용한 O(log n) 시간 복잡도의 삽입/삭제/검색 구현&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>캐싱과 메모이제이션&lt;/p>
&lt;ul>
&lt;li>이미 계산된 결과를 저장하여 재사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동적 프로그래밍&lt;/p>
&lt;ul>
&lt;li>큰 문제를 작은 부분 문제로 나누어 해결&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4>공간 복잡도 최적화&lt;span class="hx-absolute -hx-mt-20" id="공간-복잡도-최적화">&lt;/span>
&lt;a href="#%ea%b3%b5%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84-%ec%b5%9c%ec%a0%81%ed%99%94" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>
&lt;p>인플레이스(In-place) 알고리즘 사용&lt;/p>
&lt;ul>
&lt;li>추가 메모리 사용을 최소화하는 알고리즘 선택&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메모리 재사용&lt;/p>
&lt;ul>
&lt;li>불필요한 변수 제거 및 변수 재사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>적절한 자료구조 선택&lt;/p>
&lt;ul>
&lt;li>상황에 맞는 효율적인 자료구조 사용 (예: 연결 리스트 대신 배열)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>재귀 대신 반복문 사용&lt;/p>
&lt;ul>
&lt;li>재귀 호출로 인한 스택 메모리 사용 줄이기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>비트 연산 활용&lt;/p>
&lt;ul>
&lt;li>정수형 변수를 비트 마스크로 활용하여 메모리 사용 줄이기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메모리 풀링&lt;/p>
&lt;ul>
&lt;li>객체 재사용을 통한 메모리 할당/해제 최소화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>알고리즘 설계 (Algorithm Design)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</link><pubDate>Mon, 28 Oct 2024 05:15:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/</guid><description>
&lt;h2>알고리즘 설계 (Algorithm Design)&lt;span class="hx-absolute -hx-mt-20" id="알고리즘-설계-algorithm-design">&lt;/span>
&lt;a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84-algorithm-design" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계는 주어진 문제를 효율적으로 해결하기 위한 체계적인 과정이다.&lt;/p>
&lt;p>알고리즘 설계의 주요 단계와 각 단계별 특징은 다음과 같다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>문제 정의 및 분석&lt;br>
이 단계에서는 해결해야 할 문제를 명확하게 이해하고 정의한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 문제의 본질을 파악하고 요구사항을 명확히 한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>문제의 입력과 출력을 구체적으로 분석한다.&lt;/li>
&lt;li>문제의 제약 조건과 범위를 파악한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계는 알고리즘 설계의 기초가 되며, 문제를 정확히 이해하지 못하면 잘못된 해결책을 도출할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 설계&lt;br>
문제 해결을 위한 구체적인 단계와 절차를 개발하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 문제를 해결하기 위한 효율적이고 체계적인 방법을 고안합니다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>문제를 더 작은 하위 문제로 분해한다.&lt;/li>
&lt;li>문제 해결을 위한 논리적 단계를 구성한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계에서는 다양한 알고리즘 설계 기법(분할 정복, 동적 프로그래밍, 탐욕 알고리즘 등)을 활용할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 표현&lt;br>
설계한 알고리즘을 명확하게 표현하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘을 다른 사람이 이해할 수 있도록 명확하게 기술한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>의사코드(pseudocode) 작성&lt;/li>
&lt;li>순서도(flowchart) 작성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 알고리즘은 명확하고 모호하지 않아야 하며, 각 단계가 실행 가능해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘 검증 및 분석&lt;br>
알고리즘의 정확성과 효율성을 평가하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘이 모든 가능한 입력에 대해 올바른 결과를 도출하는지 확인하고, 성능을 분석한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>알고리즘의 정확성 검증&lt;/li>
&lt;li>시간 복잡도와 공간 복잡도 분석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계에서는 알고리즘의 효율성을 평가하여 개선이 필요한 부분을 식별한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구현&lt;br>
알고리즘을 실제 프로그래밍 언어로 구현하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 설계한 알고리즘을 컴퓨터가 실행할 수 있는 형태로 변환한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>프로그래밍 언어 선택&lt;/li>
&lt;li>코드 작성 및 디버깅&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 구현 단계에서는 선택한 프로그래밍 언어의 특성을 고려하여 알고리즘을 최적화할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 및 유지보수&lt;br>
구현된 알고리즘을 테스트하고 필요에 따라 개선하는 단계이다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>목적&lt;/strong>: 알고리즘의 실제 성능을 확인하고 문제점을 해결한다.&lt;/li>
&lt;li>&lt;strong>주요 활동&lt;/strong>:
&lt;ul>
&lt;li>다양한 입력 데이터로 테스트 수행&lt;/li>
&lt;li>버그 수정 및 성능 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>특징&lt;/strong>: 이 단계는 지속적으로 이루어지며, 알고리즘의 품질을 향상시키는 데 중요한 역할을 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>알고리즘 설계는 반복적인 과정이며, 각 단계에서 발견된 문제점이나 개선사항을 바탕으로 이전 단계로 돌아가 수정하는 것이 일반적이다.&lt;br>
효과적인 알고리즘 설계를 위해서는 문제에 대한 깊은 이해와 다양한 알고리즘 기법에 대한 지식, 그리고 체계적인 접근 방식이 필요하다.&lt;/p>
&lt;h3>문제알고리즘 설계의 단계별 예시&lt;span class="hx-absolute -hx-mt-20" id="문제알고리즘-설계의-단계별-예시">&lt;/span>
&lt;a href="#%eb%ac%b8%ec%a0%9c%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84%ec%9d%98-%eb%8b%a8%ea%b3%84%eb%b3%84-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>스마트 주차장 관리 시스템의 알고리즘 설계 과정을 단계별로 상세히 살펴보자.&lt;/p>
&lt;h4>1. 문제 정의 및 분석&lt;span class="hx-absolute -hx-mt-20" id="1-문제-정의-및-분석">&lt;/span>
&lt;a href="#1-%eb%ac%b8%ec%a0%9c-%ec%a0%95%ec%9d%98-%eb%b0%8f-%eb%b6%84%ec%84%9d" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>스마트 주차장 관리 시스템은 주차장의 효율적인 운영과 사용자 편의성을 향상시키기 위한 자동화된 시스템.&lt;/p>
&lt;h5>입력 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="입력-데이터-구조">&lt;/span>
&lt;a href="#%ec%9e%85%eb%a0%a5-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>차량 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차량 번호&lt;/td>
&lt;td>차량 식별을 위한 고유 번호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량 크기&lt;/td>
&lt;td>소형/중형/대형으로 구분&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>입차 시간&lt;/td>
&lt;td>주차장 진입 시점 기록&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장애인 차량 여부&lt;/td>
&lt;td>장애인 전용 구역 사용 자격 확인&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기 주차권 보유 여부&lt;/td>
&lt;td>정기권 사용자 우선 배정 확인&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>주차장 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>전체 주차 공간 수&lt;/td>
&lt;td>주차장의 총 수용 가능 차량 수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주차 공간 상태&lt;/td>
&lt;td>각 공간의 사용 가능 여부(빈 공간/사용 중)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장애인 전용 구역 위치&lt;/td>
&lt;td>장애인 차량 전용 주차 구역 정보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구역별 센서 데이터&lt;/td>
&lt;td>각 주차 공간의 실시간 상태 모니터링 정보&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>요금 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>기본 요금&lt;/td>
&lt;td>최초 주차 시 적용되는 기본 요금&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추가 시간당 요금&lt;/td>
&lt;td>기본 시간 초과 시 적용되는 시간당 요금&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 종류별 요금&lt;/td>
&lt;td>다양한 정기권의 종류와 각각의 요금 체계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>출력 데이터 구조&lt;span class="hx-absolute -hx-mt-20" id="출력-데이터-구조">&lt;/span>
&lt;a href="#%ec%b6%9c%eb%a0%a5-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%a1%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>주차 관련 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>최적 주차 공간 위치&lt;/td>
&lt;td>차량 특성에 맞는 최적의 주차 공간 안내&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>현재 주차 가능 공간 수&lt;/td>
&lt;td>실시간 이용 가능한 주차 공간의 수&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주차장 점유율&lt;/td>
&lt;td>전체 주차 공간 대비 사용 중인 공간의 비율&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>요금 관련 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>주차 요금 계산 결과&lt;/td>
&lt;td>주차 시간에 따른 최종 요금 계산&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 잔여 기간&lt;/td>
&lt;td>정기권 사용자의 남은 사용 기간 정보&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>상태 정보&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>실시간 주차장 상태&lt;/td>
&lt;td>전체 주차장의 현재 운영 상태&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량별 주차 위치&lt;/td>
&lt;td>각 차량의 현재 주차 위치 정보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>경보 및 알림&lt;/td>
&lt;td>비상 상황 또는 주요 이벤트 알림&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>제약조건&lt;span class="hx-absolute -hx-mt-20" id="제약조건">&lt;/span>
&lt;a href="#%ec%a0%9c%ec%95%bd%ec%a1%b0%ea%b1%b4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>시스템 제약&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>제약 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>실시간 처리&lt;/td>
&lt;td>모든 데이터는 실시간으로 처리되어야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동시 다중 사용자 지원&lt;/td>
&lt;td>여러 사용자의 동시 접속 및 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>센서 데이터 처리 지연 최소화&lt;/td>
&lt;td>센서 데이터의 신속한 처리 및 반영&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>비즈니스 제약&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>제약 항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>장애인 구역 제한&lt;/td>
&lt;td>장애인 전용 구역은 해당 차량만 사용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>차량 크기별 공간 배정&lt;/td>
&lt;td>차량 크기에 적합한 주차 공간만 배정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>정기권 사용자 우선 배정&lt;/td>
&lt;td>정기권 보유 차량에 대한 우선 주차 공간 배정&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>2. 알고리즘 설계&lt;span class="hx-absolute -hx-mt-20" id="2-알고리즘-설계">&lt;/span>
&lt;a href="#2-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>이 시스템에서는 여러 알고리즘이 필요하며, 각각의 목적과 선택 이유를 정리한다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>최적 주차 공간 배정 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 가중 그래프 최단 경로 (Dijkstra&amp;rsquo;s Algorithm)&lt;/li>
&lt;li>목적: 차량 특성과 현재 위치에 기반한 최적 주차 공간 선택&lt;/li>
&lt;li>선택 이유: 다양한 조건(거리, 크기, 접근성)을 가중치로 반영 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>실시간 모니터링 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 이벤트 기반 상태 관리&lt;/li>
&lt;li>목적: 센서 데이터 실시간 처리 및 상태 업데이트&lt;/li>
&lt;li>선택 이유: 비동기 처리로 시스템 반응성 향상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>요금 계산 알고리즘&lt;/p>
&lt;ul>
&lt;li>알고리즘: 동적 프로그래밍&lt;/li>
&lt;li>목적: 다양한 요금제와 할인 적용&lt;/li>
&lt;li>선택 이유: 복잡한 요금 규칙을 효율적으로 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4>3. 알고리즘 표현&lt;span class="hx-absolute -hx-mt-20" id="3-알고리즘-표현">&lt;/span>
&lt;a href="#3-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ed%91%9c%ed%98%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>여기서는 최적 주차 공간 배정 알고리즘을 자세히 살펴보자.&lt;/p>
&lt;h5>의사코드&lt;span class="hx-absolute -hx-mt-20" id="의사코드">&lt;/span>
&lt;a href="#%ec%9d%98%ec%82%ac%ec%bd%94%eb%93%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>FUNCTION findOptimalParkingSpace(vehicleInfo, parkingLot):
// 초기화
availableSpaces = []
weightedGraph = createWeightedGraph(parkingLot)
// 적합한 주차 공간 필터링
FOR EACH space in parkingLot.spaces:
IF isSpaceSuitable(space, vehicleInfo):
availableSpaces.append(space)
// 각 공간에 대한 최적성 점수 계산
bestSpace = NULL
bestScore = INFINITY
FOR EACH space in availableSpaces:
score = calculateSpaceScore(space, vehicleInfo)
IF score &amp;lt; bestScore:
bestScore = score
bestSpace = space
RETURN bestSpace
FUNCTION calculateSpaceScore(space, vehicleInfo):
score = 0
// 거리 가중치
score &amp;#43;= getDistance(entrance, space) * DISTANCE_WEIGHT
// 크기 적합성 가중치
score &amp;#43;= getSizeFitScore(space, vehicleInfo) * SIZE_WEIGHT
// 특별 조건 가중치 (장애인 구역 등)
score &amp;#43;= getSpecialConditionScore(space, vehicleInfo) * SPECIAL_WEIGHT
RETURN score&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h5>순서도&lt;span class="hx-absolute -hx-mt-20" id="순서도">&lt;/span>
&lt;a href="#%ec%88%9c%ec%84%9c%eb%8f%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;pre class="mermaid hx-mt-6">flowchart TD
A([시작]) --> B[/차량정보 입력/]
B --> C[주차장 상태 조회]
C --> D[가용 공간 필터링]
D --> E{가용 공간 존재?}
E -->|No| F[/주차 불가 응답/]
E -->|Yes| G[공간별 점수 계산]
G --> H{특별 조건 차량?}
H -->|Yes| I[특별 구역 우선 점수 적용]
H -->|No| J[일반 점수 계산]
I --> K[최적 공간 선택]
J --> K
K --> L[/최적 주차 공간 안내/]
L --> M([종료])
F --> M&lt;/pre>&lt;h4>4. 구현&lt;span class="hx-absolute -hx-mt-20" id="4-구현">&lt;/span>
&lt;a href="#4-%ea%b5%ac%ed%98%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">dataclasses&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">typing&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Optional&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">datetime&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">datetime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">heapq&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Vehicle&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;차량 정보를 저장하는 클래스&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">plate_number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span> &lt;span class="c1"># &amp;#39;small&amp;#39;, &amp;#39;medium&amp;#39;, &amp;#39;large&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_disabled&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">has_subscription&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">entry_time&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">datetime&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@dataclass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ParkingSpace&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;주차 공간 정보를 저장하는 클래스&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">location&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_disabled_only&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">is_occupied&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sensor_status&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SmartParkingSystem&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total_spaces&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">]):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 스마트 주차 시스템 초기화
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> total_spaces: 전체 주차 공간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">total_spaces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">occupied_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="c1"># 차량별 주차 위치 추적&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">entrance_location&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 주차장 입구 위치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">find_optimal_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">Optional&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간을 찾는 메인 함수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 입차하는 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간 또는 None (가용 공간 없을 경우)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 가용 공간 필터링&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">space&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">spaces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_is_space_suitable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 최적 공간 선택&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_select_best_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">available_spaces&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_is_space_suitable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">bool&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간이 해당 차량에 적합한지 확인
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> space: 검사할 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 적합 여부
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_occupied&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled_only&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 차량 크기 체크&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_order&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;small&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;medium&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;large&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">size_order&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">size_order&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_select_best_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 가용 공간 중 최적의 공간 선택
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> available_spaces: 가용 주차 공간 리스트
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적의 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;inf&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">space&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">available_spaces&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_space_score&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">score&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">best_score&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">score&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">space&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">best_space&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_space_score&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간의 최적성 점수 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Args:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> space: 평가할 주차 공간
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> vehicle: 차량 정보
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> Returns:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 최적성 점수 (낮을수록 좋음)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">DISTANCE_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SIZE_FIT_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">2.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SPECIAL_CONDITION_WEIGHT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">3.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 거리 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">distance&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_distance&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">entrance_location&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">location&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">distance&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">DISTANCE_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 크기 적합성 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_fit_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_calculate_size_fit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">size_fit_score&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">SIZE_FIT_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 특별 조건 점수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_disabled_only&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">50&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">SPECIAL_CONDITION_WEIGHT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">score&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_distance&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">point1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">tuple&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 두 지점 간의 맨해튼 거리 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">point2&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_calculate_size_fit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vehicle&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 주차 공간과 차량 크기의 적합성 점수 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_values&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;small&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;medium&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;large&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size_values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">size_values&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">])&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>5. 테스트&lt;span class="hx-absolute -hx-mt-20" id="5-테스트">&lt;/span>
&lt;a href="#5-%ed%85%8c%ec%8a%a4%ed%8a%b8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">test_smart_parking_system&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;스마트 주차 시스템 테스트&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트용 주차 공간 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_spaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;large&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;B1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;small&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParkingSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;B2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;normal&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 시스템 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">parking_system&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SmartParkingSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test_spaces&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 케이스 정의&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_cases&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 일반 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;123가4567&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;medium&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 장애인 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;234가5678&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;small&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 대형 차량&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vehicle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;345가6789&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;large&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 테스트 실행&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">vehicle&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">test_cases&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">테스트 차량: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plate_number&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">space&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parking_system&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">find_optimal_space&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vehicle&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">space&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;배정된 주차 공간: &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">space&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;가용 주차 공간 없음&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;__main__&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_smart_parking_system&lt;/span>&lt;span class="p">()&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>6. 분석 및 개선사항&lt;span class="hx-absolute -hx-mt-20" id="6-분석-및-개선사항">&lt;/span>
&lt;a href="#6-%eb%b6%84%ec%84%9d-%eb%b0%8f-%ea%b0%9c%ec%84%a0%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ol>
&lt;li>
&lt;p>성능 분석&lt;/p>
&lt;ul>
&lt;li>시간 복잡도: O(n) (n: 주차 공간 수)&lt;/li>
&lt;li>공간 복잡도: O(m) (m: 현재 주차된 차량 수)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>개선 필요 사항&lt;/p>
&lt;ul>
&lt;li>동시성 제어 메커니즘 추가&lt;/li>
&lt;li>센서 데이터 실시간 업데이트 처리&lt;/li>
&lt;li>예약 시스템 통합&lt;/li>
&lt;li>결제 시스템 연동&lt;/li>
&lt;li>비상 상황 처리 로직 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>확장 가능한 기능&lt;/p>
&lt;ul>
&lt;li>모바일 앱 연동&lt;/li>
&lt;li>차량 번호판 인식 시스템 통합&lt;/li>
&lt;li>통계 분석 기능 추가&lt;/li>
&lt;li>예측 모델 도입&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3></description></item><item><title>Algorithm</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</link><pubDate>Tue, 29 Oct 2024 08:33:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</guid><description>
&lt;h2>Algorithm&lt;span class="hx-absolute -hx-mt-20" id="algorithm">&lt;/span>
&lt;a href="#algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘은 주어진 문제를 해결하기 위한 명확하고 순차적인 단계들의 집합이다.&lt;br>
우리의 일상생활에 비유하자면, 요리 레시피나 조립 설명서와 같은 것이라고 할 수 있다.&lt;br>
레시피가 음식을 만드는 정확한 순서와 방법을 알려주는 것처럼, 알고리즘은 컴퓨터가 특정 문제를 해결하기 위해 따라야 할 정확한 지침을 제공한다.&lt;/p>
&lt;p>&lt;img src="What-is-Algorithm_-1024x631.jpg" alt="What is Algorithm?" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/fundamentals-of-algorithms/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/fundamentals-of-algorithms/&lt;/a> _&lt;/p>
&lt;h3>특성&lt;span class="hx-absolute -hx-mt-20" id="특성">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>입력(Input)&lt;/strong>: 문제를 해결하기 위한 초기 데이터나 조건이 주어져야 한다.&lt;/li>
&lt;li>&lt;strong>출력(Output)&lt;/strong>: 알고리즘은 반드시 결과를 생성해야 한다.&lt;/li>
&lt;li>&lt;strong>명확성(Definiteness)&lt;/strong>: 각 단계는 모호하지 않고 정확해야 한다.&lt;/li>
&lt;li>&lt;strong>유한성(Finiteness)&lt;/strong>: 알고리즘은 반드시 유한한 단계 후에 종료되어야 한다.&lt;/li>
&lt;li>&lt;strong>효과성(Effectiveness)&lt;/strong>: 각 단계는 실제로 실행 가능해야 한다.&lt;/li>
&lt;/ol>
&lt;h3>필요한 이유&lt;span class="hx-absolute -hx-mt-20" id="필요한-이유">&lt;/span>
&lt;a href="#%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>프로그래밍에서 알고리즘이 필요한 이유는 여러 가지가 있다.&lt;br>
가장 중요한 것은 효율성이다.&lt;br>
같은 문제를 해결하더라도 어떤 알고리즘을 사용하느냐에 따라 실행 시간과 메모리 사용량이 크게 달라질 수 있다.&lt;/p>
&lt;p>예를 들어, 1부터 100까지의 합을 구하는 문제를 생각해보자.&lt;br>
단순히 반복문을 사용하여 더하는 방법도 있지만, 가우스의 덧셈 공식을 사용하면 단 한 번의 계산으로 결과를 얻을 수 있다.&lt;br>
이처럼 효율적인 알고리즘은 시간과 자원을 절약하게 해준다.&lt;/p>
&lt;h3>평가 기준&lt;span class="hx-absolute -hx-mt-20" id="평가-기준">&lt;/span>
&lt;a href="#%ed%8f%89%ea%b0%80-%ea%b8%b0%ec%a4%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>알고리즘을 평가할 때는 주로 시간 복잡도와 공간 복잡도를 고려한다.&lt;br>
시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 의미하며, 공간 복잡도는 필요한 메모리의 양을 의미한다.&lt;br>
이러한 복잡도는 보통 빅오(Big-O) 표기법을 사용하여 나타낸다.&lt;br>
예를 들어, O(n)은 입력 크기에 비례하여 시간이 증가함을 의미하고, O(log n)은 입력 크기가 커져도 시간이 로그함수처럼 완만하게 증가함을 의미한다.&lt;/p>
&lt;h3>중요성&lt;span class="hx-absolute -hx-mt-20" id="중요성">&lt;/span>
&lt;a href="#%ec%a4%91%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효율성 향상: 효율적인 알고리즘은 프로그램의 실행 속도를 높이고 시스템 자원 사용을 최소화한다.&lt;/li>
&lt;li>문제 해결 능력 개발: 알고리즘 학습은 논리적 사고력과 문제 해결 능력을 향상시킨다.&lt;/li>
&lt;li>복잡한 문제 해결: 알고리즘은 복잡한 문제를 체계적으로 분석하고 해결하는 데 도움을 준다.&lt;/li>
&lt;li>프로그래밍 역량 강화: 알고리즘에 대한 이해는 효율적인 코드 작성과 프로그램 최적화에 필수적이다.&lt;/li>
&lt;li>다양한 분야 응용: 알고리즘은 빅데이터 분석, 인공지능, 네트워크 통신 등 다양한 기술 분야에서 핵심적인 역할을 한다.&lt;/li>
&lt;/ol>
&lt;h3>알고리즘 설계의 기본 원칙&lt;span class="hx-absolute -hx-mt-20" id="알고리즘-설계의-기본-원칙">&lt;/span>
&lt;a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a4%ea%b3%84%ec%9d%98-%ea%b8%b0%eb%b3%b8-%ec%9b%90%ec%b9%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>좋은 알고리즘을 설계하기 위해서는 몇 가지 원칙을 고려해야 한다.&lt;br>
정확성이 가장 기본이 되어야 하며, 효율성을 고려해야 한다.&lt;br>
또한 알고리즘은 가능한 한 단순하고 이해하기 쉬워야 하며, 확장성이 있어야 한다.&lt;br>
문제를 작은 단위로 나누어 해결하는 분할 정복 방법이나, 최적의 해결책을 찾아가는 그리디 방법 등 다양한 설계 기법이 있다.&lt;/p>
&lt;h3>종류&lt;span class="hx-absolute -hx-mt-20" id="종류">&lt;/span>
&lt;a href="#%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>각 카테고리의 알고리즘들은 서로 다른 문제 영역에 특화되어 있으며, 실제 응용에서는 여러 알고리즘을 조합하여 사용하는 경우가 많다.&lt;br>
효율적인 프로그램 개발을 위해서는 각 알고리즘의 특성과 적용 가능한 상황을 잘 이해하고 있어야 한다.&lt;/p>
&lt;h4>정렬 알고리즘 (Sorting Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="정렬-알고리즘-sorting-algorithms">&lt;/span>
&lt;a href="#%ec%a0%95%eb%a0%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-sorting-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>안정성&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>비교 기반 정렬&lt;/td>
&lt;td>O(n log n) ~ O(n²)&lt;/td>
&lt;td>O(1) ~ O(n)&lt;/td>
&lt;td>변동적&lt;/td>
&lt;td>• 요소 간 비교를 통한 정렬&lt;br>• 범용적 사용 가능&lt;/td>
&lt;td>• 퀵 정렬&lt;br>• 병합 정렬&lt;br>• 힙 정렬&lt;/td>
&lt;td>• 데이터베이스 정렬&lt;br>• 파일 시스템&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분산 정렬&lt;/td>
&lt;td>O(n + k)&lt;/td>
&lt;td>O(n + k)&lt;/td>
&lt;td>대부분 안정적&lt;/td>
&lt;td>• 키 값의 분포를 이용&lt;br>• 특정 조건에서 매우 효율적&lt;/td>
&lt;td>• 기수 정렬&lt;br>• 계수 정렬&lt;/td>
&lt;td>• 정수 데이터 정렬&lt;br>• 문자열 정렬&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>검색 알고리즘 (Search Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="검색-알고리즘-search-algorithms">&lt;/span>
&lt;a href="#%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-search-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>전제 조건&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정렬 기반 검색&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>정렬된 데이터&lt;/td>
&lt;td>• 분할 정복 방식&lt;br>• 효율적인 검색&lt;/td>
&lt;td>• 이진 검색&lt;br>• 보간 검색&lt;/td>
&lt;td>• 데이터베이스 검색&lt;br>• 사전 검색&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>해시 기반 검색&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>해시 함수 필요&lt;/td>
&lt;td>• 직접 접근&lt;br>• 충돌 해결 필요&lt;/td>
&lt;td>• 해시 테이블 검색&lt;br>• 블룸 필터&lt;/td>
&lt;td>• 캐시 시스템&lt;br>• 데이터베이스 인덱싱&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>그래프 알고리즘 (Graph Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="그래프-알고리즘-graph-algorithms">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%9e%98%ed%94%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-graph-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>해결 문제&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>최단 경로&lt;/td>
&lt;td>O(V log V + E)&lt;/td>
&lt;td>O(V)&lt;/td>
&lt;td>경로 최적화&lt;/td>
&lt;td>• 가중치 고려&lt;br>• 다양한 최적화 가능&lt;/td>
&lt;td>• 다익스트라&lt;br>• 벨만-포드&lt;/td>
&lt;td>• 네비게이션&lt;br>• 네트워크 라우팅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>순회&lt;/td>
&lt;td>O(V + E)&lt;/td>
&lt;td>O(V)&lt;/td>
&lt;td>그래프 탐색&lt;/td>
&lt;td>• 전체 노드 방문&lt;br>• 연결성 확인&lt;/td>
&lt;td>• DFS&lt;br>• BFS&lt;/td>
&lt;td>• 웹 크롤링&lt;br>• 소셜 네트워크 분석&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>문자열 알고리즘 (String Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="문자열-알고리즘-string-algorithms">&lt;/span>
&lt;a href="#%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-string-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>주요 기능&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>패턴 매칭&lt;/td>
&lt;td>O(n + m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>문자열 검색&lt;/td>
&lt;td>• 패턴 찾기&lt;br>• 효율적인 매칭&lt;/td>
&lt;td>• KMP&lt;br>• Boyer-Moore&lt;/td>
&lt;td>• 텍스트 편집기&lt;br>• DNA 서열 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>문자열 처리&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1) ~ O(n)&lt;/td>
&lt;td>문자열 변환&lt;/td>
&lt;td>• 문자열 조작&lt;br>• 인코딩 처리&lt;/td>
&lt;td>• 라빈-카프&lt;br>• 매나처&lt;/td>
&lt;td>• 데이터 압축&lt;br>• 자연어 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>기하 알고리즘 (Geometric Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="기하-알고리즘-geometric-algorithms">&lt;/span>
&lt;a href="#%ea%b8%b0%ed%95%98-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-geometric-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>처리 대상&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>컨벡스 헐&lt;/td>
&lt;td>O(n log n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>점집합&lt;/td>
&lt;td>• 외곽선 찾기&lt;br>• 기하학적 최적화&lt;/td>
&lt;td>• Graham Scan&lt;br>• Jarvis March&lt;/td>
&lt;td>• 컴퓨터 그래픽스&lt;br>• 패턴 인식&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>근접점 쌍&lt;/td>
&lt;td>O(n log n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>점집합&lt;/td>
&lt;td>• 최근접 점 찾기&lt;br>• 공간 분할&lt;/td>
&lt;td>• 분할 정복&lt;br>• 평면 스위핑&lt;/td>
&lt;td>• 충돌 감지&lt;br>• 클러스터링&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>수치 알고리즘 (Numerical Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="수치-알고리즘-numerical-algorithms">&lt;/span>
&lt;a href="#%ec%88%98%ec%b9%98-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-numerical-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>정확도&lt;/th>
&lt;th>적용 분야&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>근사해 찾기&lt;/td>
&lt;td>변동적&lt;/td>
&lt;td>조절 가능&lt;/td>
&lt;td>수치 해석&lt;/td>
&lt;td>• 반복적 개선&lt;br>• 오차 최소화&lt;/td>
&lt;td>• 뉴턴-랩슨&lt;br>• 이분법&lt;/td>
&lt;td>• 공학 계산&lt;br>• 금융 모델링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>행렬 연산&lt;/td>
&lt;td>O(n³)&lt;/td>
&lt;td>정확함&lt;/td>
&lt;td>선형대수&lt;/td>
&lt;td>• 행렬 분해&lt;br>• 연립방정식 해결&lt;/td>
&lt;td>• 가우스 소거법&lt;br>• LU 분해&lt;/td>
&lt;td>• 3D 그래픽스&lt;br>• 신호 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>최적화 알고리즘 (Optimization Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="최적화-알고리즘-optimization-algorithms">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%a0%81%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-optimization-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>최적성&lt;/th>
&lt;th>적용 분야&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>전역 최적화&lt;/td>
&lt;td>변동적&lt;/td>
&lt;td>보장 가능&lt;/td>
&lt;td>조합 최적화&lt;/td>
&lt;td>• 전체 해 탐색&lt;br>• 최적해 보장&lt;/td>
&lt;td>• 분기 한정법&lt;br>• 동적 계획법&lt;/td>
&lt;td>• 물류 최적화&lt;br>• 자원 할당&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>근사 최적화&lt;/td>
&lt;td>다항시간&lt;/td>
&lt;td>근사해&lt;/td>
&lt;td>실시간 최적화&lt;/td>
&lt;td>• 빠른 해 도출&lt;br>• 실용적 해결책&lt;/td>
&lt;td>• 유전 알고리즘&lt;br>• 시뮬레이티드 어닐링&lt;/td>
&lt;td>• 스케줄링&lt;br>• 네트워크 설계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>암호화 알고리즘 (Cryptographic Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="암호화-알고리즘-cryptographic-algorithms">&lt;/span>
&lt;a href="#%ec%95%94%ed%98%b8%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-cryptographic-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>보안 강도&lt;/th>
&lt;th>속도&lt;/th>
&lt;th>용도&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대칭키 암호화&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>빠름&lt;/td>
&lt;td>데이터 보안&lt;/td>
&lt;td>• 같은 키로 암/복호화&lt;br>• 빠른 처리&lt;/td>
&lt;td>• AES&lt;br>• DES&lt;/td>
&lt;td>• 파일 암호화&lt;br>• 통신 보안&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>공개키 암호화&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>느림&lt;/td>
&lt;td>키 교환/인증&lt;/td>
&lt;td>• 공개키/개인키 쌍&lt;br>• 수학적 기반&lt;/td>
&lt;td>• RSA&lt;br>• ECC&lt;/td>
&lt;td>• 디지털 서명&lt;br>• SSL/TLS&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>머신러닝 알고리즘 (Machine Learning Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="머신러닝-알고리즘-machine-learning-algorithms">&lt;/span>
&lt;a href="#%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-machine-learning-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>학습 방식&lt;/th>
&lt;th>데이터 요구량&lt;/th>
&lt;th>적용 분야&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 알고리즘&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>지도 학습&lt;/td>
&lt;td>레이블 필요&lt;/td>
&lt;td>많음&lt;/td>
&lt;td>예측/분류&lt;/td>
&lt;td>• 입출력 쌍 학습&lt;br>• 패턴 인식&lt;/td>
&lt;td>• 신경망&lt;br>• SVM&lt;/td>
&lt;td>• 이미지 인식&lt;br>• 스팸 필터링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>비지도 학습&lt;/td>
&lt;td>레이블 불필요&lt;/td>
&lt;td>매우 많음&lt;/td>
&lt;td>패턴 발견&lt;/td>
&lt;td>• 데이터 구조 파악&lt;br>• 군집화&lt;/td>
&lt;td>• K-means&lt;br>• PCA&lt;/td>
&lt;td>• 추천 시스템&lt;br>• 이상 탐지&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>동적 프로그래밍 (Dynamic Programming)&lt;span class="hx-absolute -hx-mt-20" id="동적-프로그래밍-dynamic-programming">&lt;/span>
&lt;a href="#%eb%8f%99%ec%a0%81-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-dynamic-programming" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 유형&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>문제 특성&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>대표적 예제&lt;/th>
&lt;th>실제 응용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Top-Down&lt;/td>
&lt;td>O(상태 수 × 상태당 계산)&lt;/td>
&lt;td>O(상태 수)&lt;/td>
&lt;td>최적 부분 구조&lt;/td>
&lt;td>• 메모이제이션&lt;br>• 재귀적 구현&lt;/td>
&lt;td>• 피보나치 수열&lt;br>• 최장 공통 부분수열&lt;/td>
&lt;td>• 경로 계획&lt;br>• 리소스 할당&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Bottom-Up&lt;/td>
&lt;td>O(상태 수 × 상태당 계산)&lt;/td>
&lt;td>O(상태 수)&lt;/td>
&lt;td>중복 부분 문제&lt;/td>
&lt;td>• 테이블화&lt;br>• 반복적 구현&lt;/td>
&lt;td>• 배낭 문제&lt;br>• 최단 경로&lt;/td>
&lt;td>• 순서 최적화&lt;br>• 게임 전략&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>비결정성 (Non-determinism)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</link><pubDate>Mon, 25 Nov 2024 09:18:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</guid><description>
&lt;h2>비결정성 (Non-determinism)&lt;span class="hx-absolute -hx-mt-20" id="비결정성-non-determinism">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b2%b0%ec%a0%95%ec%84%b1-non-determinism" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성&lt;/p>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>다중 선택: 각 단계에서 여러 가능한 다음 단계 중 하나를 임의로 선택할 수 있다.&lt;/li>
&lt;li>병렬 처리: 여러 가능한 경로를 동시에 탐색할 수 있는 개념적 모델을 제공한다.&lt;/li>
&lt;li>결정성과의 차이: 결정성 알고리즘은 각 단계에서 다음 단계가 유일하게 결정되는 반면, 비결정성 알고리즘은 그렇지 않다.&lt;/li>
&lt;/ol>
&lt;h3>비결정성 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="비결정성-알고리즘">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b2%b0%ec%a0%95%ec%84%b1-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>비결정성 알고리즘은 다음과 같은 특징을 가진다.&lt;/p>
&lt;ol>
&lt;li>실행 경로의 다양성: 동일한 입력에 대해 여러 가능한 실행 경로가 존재한다.&lt;/li>
&lt;li>비결정도: 각 단계에서 선택 가능한 다음 단계의 최대 개수를 비결정도라고 한다.&lt;/li>
&lt;li>계산 능력: 비결정성 알고리즘과 결정성 알고리즘의 계산 능력은 동일하다.&lt;/li>
&lt;/ol>
&lt;h3>응용&lt;span class="hx-absolute -hx-mt-20" id="응용">&lt;/span>
&lt;a href="#%ec%9d%91%ec%9a%a9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>NP 문제: 비결정성 알고리즘으로 다항식 시간 내에 해결 가능한 결정형 문제를 NP 문제라고 한다.&lt;/li>
&lt;li>유한 오토마타: 비결정적 유한 오토마타(NFA)는 탐색과 백트래킹 기법을 통해 모든 가능한 선택을 시도한다.&lt;/li>
&lt;li>탐색 및 백트래킹 알고리즘: 비결정성은 여러 가지 경우를 순차적으로 계산하며 최적값을 갱신하는 백트래킹 기법의 모델로 사용된다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>간결한 표현: 복잡한 언어나 시스템을 비결정성을 통해 더 간결하게 정의할 수 있다.&lt;/li>
&lt;li>논증 간소화: 비결정성을 통해 공식적인 논증을 간단히 할 수 있다.&lt;/li>
&lt;li>모델링 유연성: 실제 세계의 불확실성이나 복잡성을 모델링하는 데 유용하다.&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">random&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">threading&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 결정적인 함수의 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">deterministic_sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="c1"># 항상 같은 입력에 대해 같은 결과&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 비결정적인 함수의 예&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">non_deterministic_choice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">choice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">options&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 매번 다른 결과가 나올 수 있음&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 비결정적인 멀티스레딩 예제&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">shared_counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">increment_counter&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">global&lt;/span> &lt;span class="n">shared_counter&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">shared_counter&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 의도적으로 경쟁 조건을 만듦&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">None&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shared_counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">run_concurrent_increments&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">increment_counter&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">shared_counter&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>다양한 상황에서 발생할 수 있다:&lt;/p>
&lt;ol>
&lt;li>병렬 처리와 동시성&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 동시성으로 인한 비결정적 결과&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">parallel_processing_example&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">worker&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 시간이 걸리는 작업 시뮬레이션&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">current_thread&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">worker&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">results&lt;/span> &lt;span class="c1"># 스레드 완료 순서가 매번 다를 수 있음&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>네트워크 통신&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">asyncio&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">fetch_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 네트워크 지연 시뮬레이션&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;Data from &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">except&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">fetch_multiple&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">urls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;url1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;url2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;url3&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">fetch_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">url&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">urls&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 완료 순서가 비결정적&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">await&lt;/span> &lt;span class="n">asyncio&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">gather&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">tasks&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="3">
&lt;li>리소스 경쟁&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SharedResource&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">add_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">with&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 경쟁 상태 시뮬레이션&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copy&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mf">0.1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">current&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">current&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>비결정성을 다루는 전략들&lt;span class="hx-absolute -hx-mt-20" id="비결정성을-다루는-전략들">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b2%b0%ec%a0%95%ec%84%b1%ec%9d%84-%eb%8b%a4%eb%a3%a8%eb%8a%94-%ec%a0%84%eb%9e%b5%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>동기화 메커니즘 사용:&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DeterministicCounter&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">increment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">with&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_lock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_count&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">get_count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">with&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_lock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_count&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>시드(Seed) 설정으로 재현 가능한 무작위성 구현:&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">reproducible_random_sequence&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seed&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">42&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">seed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seed&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">results&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">seed&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1"># 시드 초기화&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">results&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="3">
&lt;li>테스트를 위한 결정적 동작 모드:&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TestableSystem&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">deterministic_mode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">deterministic_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">deterministic_mode&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">get_random_value&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">deterministic_mode&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">42&lt;/span> &lt;span class="c1"># 테스트용 고정값&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>문제가 되는 상황들과 그 해결 방안&lt;span class="hx-absolute -hx-mt-20" id="문제가-되는-상황들과-그-해결-방안">&lt;/span>
&lt;a href="#%eb%ac%b8%ec%a0%9c%ea%b0%80-%eb%90%98%eb%8a%94-%ec%83%81%ed%99%a9%eb%93%a4%ea%b3%bc-%ea%b7%b8-%ed%95%b4%ea%b2%b0-%eb%b0%a9%ec%95%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분산 시스템에서의 시간 동기화&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">LogicalClock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Lock&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">get_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">with&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">received_time&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">with&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">received_time&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;ol start="2">
&lt;li>데이터베이스 트랜잭션&lt;/li>
&lt;/ol>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TransactionManager&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">locks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">begin_transaction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transaction_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uuid&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">uuid4&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">locks&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">transaction_id&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">set&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">transaction_id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">acquire_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transaction_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">resource_id&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">resource_id&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">locks&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">transaction_id&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2단계 락킹 프로토콜 구현&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">locks&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">transaction_id&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resource_id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>고려사항&lt;span class="hx-absolute -hx-mt-20" id="고려사항">&lt;/span>
&lt;a href="#%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>분산 시스템 설계&lt;/li>
&lt;li>병렬 알고리즘 구현&lt;/li>
&lt;li>네트워크 프로토콜 개발&lt;/li>
&lt;li>멀티스레드 프로그래밍&lt;/li>
&lt;li>암호화 시스템 구현&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>머신러닝 알고리즘 (Machine Learning Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/machine-learning-algorithms/</link><pubDate>Fri, 08 Nov 2024 07:21:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/machine-learning-algorithms/</guid><description>
&lt;h2>머신러닝 알고리즘 (Machine Learning Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="머신러닝-알고리즘-machine-learning-algorithms">&lt;/span>
&lt;a href="#%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-machine-learning-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>머신러닝 알고리즘은 컴퓨터가 명시적인 프로그래밍 없이 데이터로부터 패턴을 학습하고 예측이나 의사결정을 수행할 수 있게 하는 알고리즘.&lt;br>
이는 인공지능의 한 분야로, 데이터를 기반으로 하여 시스템이 자동으로 학습하고 성능을 개선하는 방법을 제공한다.&lt;/p>
&lt;p>예를 들어, 이메일 스팸 필터를 생각해보면, 전통적인 프로그래밍에서는 스팸을 식별하는 모든 규칙을 직접 코딩해야 했지만, 머신러닝에서는 시스템이 많은 이메일 예제를 학습하여 스스로 스팸을 식별하는 방법을 터득한다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>복잡한 데이터 패턴을 파악하고 분석할 수 있다.&lt;/li>
&lt;li>자동화를 통해 효율성을 높일 수 있다.&lt;/li>
&lt;li>다양한 분야에 적용 가능하다.&lt;/li>
&lt;li>지속적인 학습을 통해 성능이 향상된다.&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>대량의 고품질 데이터가 필요하다.&lt;/li>
&lt;li>학습에 많은 시간과 컴퓨팅 리소스가 필요할 수 있다.&lt;/li>
&lt;li>결과 해석이 어려울 수 있다.&lt;/li>
&lt;li>오류에 취약할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>데이터를 기반으로 학습한다.&lt;/li>
&lt;li>시간이 지남에 따라 성능이 개선된다.&lt;/li>
&lt;li>다양한 알고리즘 유형이 존재한다.&lt;/li>
&lt;li>복잡한 문제를 해결할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>지도학습 (Supervised Learning)&lt;span class="hx-absolute -hx-mt-20" id="지도학습-supervised-learning">&lt;/span>
&lt;a href="#%ec%a7%80%eb%8f%84%ed%95%99%ec%8a%b5-supervised-learning" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>레이블이 지정된 데이터로 학습한다.&lt;/p>
&lt;ul>
&lt;li>장점: 정확한 예측이 가능하다.&lt;/li>
&lt;li>단점: 레이블링된 데이터가 필요하다.&lt;/li>
&lt;li>활용 사례: 이미지 분류, 스팸 메일 필터링.&lt;/li>
&lt;/ul>
&lt;h4>비지도학습 (Unsupervised Learning)&lt;span class="hx-absolute -hx-mt-20" id="비지도학습-unsupervised-learning">&lt;/span>
&lt;a href="#%eb%b9%84%ec%a7%80%eb%8f%84%ed%95%99%ec%8a%b5-unsupervised-learning" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>레이블이 없는 데이터에서 패턴을 찾는다.&lt;/p>
&lt;ul>
&lt;li>장점: 숨겨진 패턴을 발견할 수 있습니다.&lt;/li>
&lt;li>단점: 결과 해석이 어려울 수 있습니다.&lt;/li>
&lt;li>활용 사례: 고객 세그먼테이션, 이상 탐지&lt;/li>
&lt;/ul>
&lt;h4>강화학습 (Reinforcement Learning)&lt;span class="hx-absolute -hx-mt-20" id="강화학습-reinforcement-learning">&lt;/span>
&lt;a href="#%ea%b0%95%ed%99%94%ed%95%99%ec%8a%b5-reinforcement-learning" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>환경과 상호작용하며 학습한다.&lt;/p>
&lt;ul>
&lt;li>장점: 복잡한 의사결정 문제에 적합합니다.&lt;/li>
&lt;li>단점: 학습에 많은 시간이 소요될 수 있습니다.&lt;/li>
&lt;li>활용 사례: 게임 AI, 로봇 제어&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>모델 경량화와 엣지 컴퓨팅&lt;/li>
&lt;li>멀티모달 학습과 적응형 모델&lt;/li>
&lt;li>윤리적 AI와 공정성 강화&lt;/li>
&lt;li>자동화된 머신러닝(AutoML)의 발전&lt;/li>
&lt;/ul>
&lt;h3>선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>문제의 특성: 분류, 회귀, 클러스터링 등 문제의 유형&lt;/li>
&lt;li>데이터의 특성: 데이터의 양, 품질, 형태&lt;/li>
&lt;li>계산 리소스: 가용한 컴퓨팅 파워와 메모리&lt;/li>
&lt;li>해석 가능성: 모델의 판단 근거가 중요한지 여부&lt;/li>
&lt;li>실시간 처리: 빠른 예측이 필요한지 여부&lt;/li>
&lt;/ul>
&lt;h3>7. 활용 사례&lt;span class="hx-absolute -hx-mt-20" id="7-활용-사례">&lt;/span>
&lt;a href="#7-%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>의료 분야:&lt;/p>
&lt;ul>
&lt;li>질병 진단&lt;/li>
&lt;li>의료 영상 분석&lt;/li>
&lt;li>신약 개발&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>금융 분야:&lt;/p>
&lt;ul>
&lt;li>사기 거래 탐지&lt;/li>
&lt;li>신용 평가&lt;/li>
&lt;li>주식 시장 예측&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>자율주행:&lt;/p>
&lt;ul>
&lt;li>객체 인식&lt;/li>
&lt;li>경로 계획&lt;/li>
&lt;li>장애물 회피&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>자연어 처리:&lt;/p>
&lt;ul>
&lt;li>기계 번역&lt;/li>
&lt;li>감정 분석&lt;/li>
&lt;li>챗봇 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>이미지 및 음성 인식&lt;/p>
&lt;/li>
&lt;li>
&lt;p>추천 시스템&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>최적화 알고리즘 (Optimization Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/optimization-algorithms/</link><pubDate>Wed, 06 Nov 2024 06:03:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/optimization-algorithms/</guid><description>
&lt;h2>최적화 알고리즘 (Optimization Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="최적화-알고리즘-optimization-algorithms">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%a0%81%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-optimization-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>주어진 문제에 대해 가장 효율적이거나 최적의 해결책을 찾기 위해 사용되는 방법론.&lt;br>
최적화 알고리즘은 특정 목적 함수(Objective Function)의 최대값이나 최소값을 찾는 데 사용된다.&lt;br>
머신러닝에서는 주로 손실 함수(Loss Function)를 최소화하여 모델의 성능을 향상시키는 데 활용된다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>복잡한 문제에 대한 효율적인 해결책 제공&lt;/li>
&lt;li>자동화된 학습 과정 지원&lt;/li>
&lt;li>다양한 분야에 적용 가능&lt;/li>
&lt;li>계산 효율성 향상&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>일부 알고리즘은 지역 최적해(local optima)에 빠질 수 있음&lt;/li>
&lt;li>하이퍼파라미터 조정의 어려움&lt;/li>
&lt;li>계산 비용이 높을 수 있음&lt;/li>
&lt;li>복잡한 문제에서 수렴 속도가 느릴 수 있음&lt;/li>
&lt;/ul>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>반복적인 과정을 통해 해를 개선&lt;/li>
&lt;li>목적 함수의 특성에 따라 다양한 알고리즘 존재&lt;/li>
&lt;li>그래디언트(기울기) 정보를 활용하는 경우가 많음&lt;/li>
&lt;li>수렴 속도와 정확도 사이의 트레이드오프 존재&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>수학적 최적화 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="수학적-최적화-알고리즘">&lt;/span>
&lt;a href="#%ec%88%98%ed%95%99%ec%a0%81-%ec%b5%9c%ec%a0%81%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>선형 계획법(Linear Programming)&lt;span class="hx-absolute -hx-mt-20" id="선형-계획법linear-programming">&lt;/span>
&lt;a href="#%ec%84%a0%ed%98%95-%ea%b3%84%ed%9a%8d%eb%b2%95linear-programming" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>선형 제약 조건과 목적 함수를 다룸&lt;/p>
&lt;ul>
&lt;li>장점: 정확한 해를 보장&lt;/li>
&lt;li>단점: 비선형 문제에 적용 불가&lt;/li>
&lt;li>활용: 자원 할당, 운송 문제&lt;/li>
&lt;/ul>
&lt;h5>비선형 계획법(Non-linear Programming)&lt;span class="hx-absolute -hx-mt-20" id="비선형-계획법non-linear-programming">&lt;/span>
&lt;a href="#%eb%b9%84%ec%84%a0%ed%98%95-%ea%b3%84%ed%9a%8d%eb%b2%95non-linear-programming" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>비선형 문제 해결&lt;/p>
&lt;ul>
&lt;li>장점: 현실적인 문제 모델링 가능&lt;/li>
&lt;li>단점: 계산 복잡도가 높음&lt;/li>
&lt;li>활용: 엔지니어링 설계, 경제 모델링&lt;/li>
&lt;/ul>
&lt;h4>메타휴리스틱 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="메타휴리스틱-알고리즘">&lt;/span>
&lt;a href="#%eb%a9%94%ed%83%80%ed%9c%b4%eb%a6%ac%ec%8a%a4%ed%8b%b1-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>유전 알고리즘(Genetic Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="유전-알고리즘genetic-algorithm">&lt;/span>
&lt;a href="#%ec%9c%a0%ec%a0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98genetic-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>진화론적 접근&lt;/p>
&lt;ul>
&lt;li>장점: 복잡한 문제에 적용 가능&lt;/li>
&lt;li>단점: 최적해 보장 없음&lt;/li>
&lt;li>활용: 회로 설계, 스케줄링&lt;/li>
&lt;/ul>
&lt;h5>시뮬레이티드 어닐링(Simulated Annealing)&lt;span class="hx-absolute -hx-mt-20" id="시뮬레이티드-어닐링simulated-annealing">&lt;/span>
&lt;a href="#%ec%8b%9c%eb%ae%ac%eb%a0%88%ec%9d%b4%ed%8b%b0%eb%93%9c-%ec%96%b4%eb%8b%90%eb%a7%81simulated-annealing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>물리적 어닐링 과정 모방&lt;/p>
&lt;ul>
&lt;li>장점: 지역 최적해 탈출 가능&lt;/li>
&lt;li>단점: 수렴 시간이 길 수 있음&lt;/li>
&lt;li>활용: VLSI 설계, 작업 할당&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>딥러닝과의 결합&lt;/li>
&lt;li>양자 컴퓨팅을 활용한 최적화&lt;/li>
&lt;li>멀티목적 최적화 기법 발전&lt;/li>
&lt;li>하이브리드 알고리즘 개발&lt;/li>
&lt;li>분산 최적화 시스템&lt;/li>
&lt;/ul>
&lt;h3>선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>문제의 특성과 규모&lt;/li>
&lt;li>계산 자원의 제약&lt;/li>
&lt;li>요구되는 해의 정확도&lt;/li>
&lt;li>실행 시간 제약&lt;/li>
&lt;li>문제의 차원 수&lt;/li>
&lt;li>제약 조건의 특성&lt;/li>
&lt;/ul>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>공학 분야:&lt;/p>
&lt;ul>
&lt;li>구조물 설계 최적화&lt;/li>
&lt;li>회로 설계&lt;/li>
&lt;li>로봇 경로 계획&lt;/li>
&lt;li>에너지 시스템 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>경영/경제 분야:&lt;/p>
&lt;ul>
&lt;li>포트폴리오 최적화&lt;/li>
&lt;li>생산 계획 수립&lt;/li>
&lt;li>재고 관리&lt;/li>
&lt;li>물류 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>인공지능/기계학습:&lt;/p>
&lt;ul>
&lt;li>신경망 학습&lt;/li>
&lt;li>하이퍼파라미터 최적화&lt;/li>
&lt;li>특징 선택&lt;/li>
&lt;li>모델 구조 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>운영 관리:&lt;/p>
&lt;ul>
&lt;li>작업 스케줄링&lt;/li>
&lt;li>자원 할당&lt;/li>
&lt;li>시설 위치 선정&lt;/li>
&lt;li>네트워크 설계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>암호화 알고리즘 (Encryption Algorithm)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/encryption-algorithm/</link><pubDate>Tue, 05 Nov 2024 15:29:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/encryption-algorithm/</guid><description>
&lt;h2>암호화 알고리즘 (Encryption Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="암호화-알고리즘-encryption-algorithm">&lt;/span>
&lt;a href="#%ec%95%94%ed%98%b8%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-encryption-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>암호화는 평문(원본 데이터)을 암호문(암호화된 데이터)으로 변환하는 과정이다.&lt;br>
이 과정에서 특정 키를 사용하며, 이 키 없이는 암호문을 해독할 수 없도록 설계된다.&lt;br>
현대의 암호화 알고리즘은 수학적 원리를 기반으로 하여 매우 높은 수준의 보안을 제공한다.&lt;/p>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>기밀성:&lt;/strong> 허가되지 않은 사용자가 데이터를 읽을 수 없도록 한다.&lt;/li>
&lt;li>&lt;strong>무결성:&lt;/strong> 데이터가 변조되지 않았음을 보장한다.&lt;/li>
&lt;li>&lt;strong>인증:&lt;/strong> 데이터의 출처를 확인할 수 있게 한다.&lt;/li>
&lt;li>&lt;strong>부인 방지:&lt;/strong> 송신자가 메시지 전송을 부인할 수 없게 한다.&lt;/li>
&lt;/ol>
&lt;h3>주요 암호화 알고리즘 분류&lt;span class="hx-absolute -hx-mt-20" id="주요-암호화-알고리즘-분류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%95%94%ed%98%b8%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%b6%84%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>대칭키 암호화 (Symmetric Key Encryption)&lt;span class="hx-absolute -hx-mt-20" id="대칭키-암호화-symmetric-key-encryption">&lt;/span>
&lt;a href="#%eb%8c%80%ec%b9%ad%ed%82%a4-%ec%95%94%ed%98%b8%ed%99%94-symmetric-key-encryption" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>특징&lt;span class="hx-absolute -hx-mt-20" id="특징-1">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>동일한 키로 암호화와 복호화를 수행&lt;/li>
&lt;li>빠른 처리 속도&lt;/li>
&lt;li>비교적 단순한 구조&lt;/li>
&lt;/ul>
&lt;h5>주요 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="주요-알고리즘">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;h6>AES (Advanced Encryption Standard)&lt;span class="hx-absolute -hx-mt-20" id="aes-advanced-encryption-standard">&lt;/span>
&lt;a href="#aes-advanced-encryption-standard" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>가장 널리 사용되는 표준 암호화 알고리즘&lt;/li>
&lt;li>128비트, 192비트, 256비트 키 크기 지원&lt;/li>
&lt;li>높은 보안성과 효율성&lt;/li>
&lt;li>활용: 금융 거래, 데이터 저장, 통신 보안&lt;/li>
&lt;/ul>
&lt;h6>DES (Data Encryption Standard)&lt;span class="hx-absolute -hx-mt-20" id="des-data-encryption-standard">&lt;/span>
&lt;a href="#des-data-encryption-standard" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>과거의 표준 암호화 알고리즘&lt;/li>
&lt;li>56비트 키 사용&lt;/li>
&lt;li>현재는 보안 강도가 낮아 권장되지 않음&lt;/li>
&lt;li>역사적 중요성을 가짐&lt;/li>
&lt;/ul>
&lt;h6>3DES (Triple DES)&lt;span class="hx-absolute -hx-mt-20" id="3des-triple-des">&lt;/span>
&lt;a href="#3des-triple-des" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>DES를 세 번 적용하여 보안성 강화&lt;/li>
&lt;li>112비트 또는 168비트 키 사용&lt;/li>
&lt;li>DES보다 안전하지만 속도가 느림&lt;/li>
&lt;li>레거시 시스템에서 여전히 사용&lt;/li>
&lt;/ul>
&lt;h4>비대칭키 암호화 (Asymmetric Key Encryption)&lt;span class="hx-absolute -hx-mt-20" id="비대칭키-암호화-asymmetric-key-encryption">&lt;/span>
&lt;a href="#%eb%b9%84%eb%8c%80%ec%b9%ad%ed%82%a4-%ec%95%94%ed%98%b8%ed%99%94-asymmetric-key-encryption" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>특징&lt;span class="hx-absolute -hx-mt-20" id="특징-2">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>공개키와 개인키 쌍을 사용&lt;/li>
&lt;li>높은 보안성&lt;/li>
&lt;li>키 교환 문제 해결&lt;/li>
&lt;li>처리 속도가 상대적으로 느림&lt;/li>
&lt;/ul>
&lt;h5>주요 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="주요-알고리즘-1">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;h6>RSA (Rivest-Shamir-Adleman)&lt;span class="hx-absolute -hx-mt-20" id="rsa-rivest-shamir-adleman">&lt;/span>
&lt;a href="#rsa-rivest-shamir-adleman" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>가장 널리 사용되는 공개키 암호화 방식&lt;/li>
&lt;li>소인수분해의 어려움을 기반으로 함&lt;/li>
&lt;li>디지털 서명에도 사용&lt;/li>
&lt;li>활용: SSL/TLS, 전자서명, 키 교환&lt;/li>
&lt;/ul>
&lt;h6>ECC (Elliptic Curve Cryptography)&lt;span class="hx-absolute -hx-mt-20" id="ecc-elliptic-curve-cryptography">&lt;/span>
&lt;a href="#ecc-elliptic-curve-cryptography" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>타원곡선의 수학적 특성을 이용&lt;/li>
&lt;li>RSA보다 짧은 키로 동등한 보안성 제공&lt;/li>
&lt;li>모바일 기기에 적합&lt;/li>
&lt;li>활용: 모바일 보안, IoT 기기&lt;/li>
&lt;/ul>
&lt;h4>해시 함수 (Hash Functions)&lt;span class="hx-absolute -hx-mt-20" id="해시-함수-hash-functions">&lt;/span>
&lt;a href="#%ed%95%b4%ec%8b%9c-%ed%95%a8%ec%88%98-hash-functions" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>특징&lt;span class="hx-absolute -hx-mt-20" id="특징-3">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;ul>
&lt;li>단방향 암호화&lt;/li>
&lt;li>고정된 길이의 출력 생성&lt;/li>
&lt;li>충돌 저항성&lt;/li>
&lt;/ul>
&lt;h5>주요 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="주요-알고리즘-2">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;h6>SHA (Secure Hash Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="sha-secure-hash-algorithm">&lt;/span>
&lt;a href="#sha-secure-hash-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>SHA-256, SHA-384, SHA-512 등 다양한 변형&lt;/li>
&lt;li>높은 보안성&lt;/li>
&lt;li>블록체인에서 널리 사용&lt;/li>
&lt;li>활용: 패스워드 저장, 무결성 검증&lt;/li>
&lt;/ul>
&lt;h6>MD5 (Message Digest Algorithm 5)&lt;span class="hx-absolute -hx-mt-20" id="md5-message-digest-algorithm-5">&lt;/span>
&lt;a href="#md5-message-digest-algorithm-5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h6>&lt;ul>
&lt;li>128비트 해시값 생성&lt;/li>
&lt;li>현재는 취약점이 발견되어 보안용도로 권장되지 않음&lt;/li>
&lt;li>무결성 검사에 제한적으로 사용&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 미래 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-미래-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%af%b8%eb%9e%98-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>양자 암호화&lt;/p>
&lt;ul>
&lt;li>양자 컴퓨터의 위협에 대비&lt;/li>
&lt;li>새로운 암호화 알고리즘 개발&lt;/li>
&lt;li>양자키분배(QKD) 기술&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동형 암호화&lt;/p>
&lt;ul>
&lt;li>암호화된 상태에서 연산 가능&lt;/li>
&lt;li>프라이버시 보존 계산&lt;/li>
&lt;li>클라우드 컴퓨팅에서의 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>경량 암호화&lt;/p>
&lt;ul>
&lt;li>IoT 기기를 위한 최적화&lt;/li>
&lt;li>제한된 리소스에서도 효율적 동작&lt;/li>
&lt;li>빠른 처리 속도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>암호화 알고리즘 선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="암호화-알고리즘-선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%95%94%ed%98%b8%ed%99%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>보안 요구사항&lt;/p>
&lt;ul>
&lt;li>필요한 보안 수준&lt;/li>
&lt;li>규제 및 컴플라이언스 요구사항&lt;/li>
&lt;li>위협 모델&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 요구사항&lt;/p>
&lt;ul>
&lt;li>처리 속도&lt;/li>
&lt;li>리소스 사용량&lt;/li>
&lt;li>확장성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구현 환경&lt;/p>
&lt;ul>
&lt;li>하드웨어 제약&lt;/li>
&lt;li>소프트웨어 호환성&lt;/li>
&lt;li>네트워크 환경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>통신 보안&lt;/p>
&lt;ul>
&lt;li>HTTPS 프로토콜에서의 데이터 암호화&lt;/li>
&lt;li>이메일 암호화 (PGP)&lt;/li>
&lt;li>메신저 앱의 종단간 암호화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터 보호&lt;/p>
&lt;ul>
&lt;li>파일 시스템 암호화&lt;/li>
&lt;li>데이터베이스 암호화&lt;/li>
&lt;li>백업 데이터 보호&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>인증 및 보안&lt;/p>
&lt;ul>
&lt;li>디지털 서명&lt;/li>
&lt;li>패스워드 해싱&lt;/li>
&lt;li>전자 상거래 보안&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>기하 알고리즘 (Geometric Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/geometric-algorithms/</link><pubDate>Tue, 05 Nov 2024 06:02:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/geometric-algorithms/</guid><description>
&lt;h2>기하 알고리즘 (Geometric Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="기하-알고리즘-geometric-algorithms">&lt;/span>
&lt;a href="#%ea%b8%b0%ed%95%98-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-geometric-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>기하 알고리즘은 2차원, 3차원 또는 더 높은 차원의 공간에 존재하는 점, 선, 다각형, 원 등의 기하학적 객체를 다루는 알고리즘.&lt;br>
이는 컴퓨터 과학에서 공간 데이터를 처리하고 분석하는 데 사용되는 중요한 도구.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>복잡한 공간 문제를 효율적으로 해결할 수 있다.&lt;/li>
&lt;li>컴퓨터 비전, 로봇공학, GIS 등 다양한 분야에 응용 가능하다.&lt;/li>
&lt;li>데이터 및 물체 분석, 분류, 계산에서 핵심 기술로 활용된다.&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>구현이 복잡할 수 있다.&lt;/li>
&lt;li>부동소수점 연산으로 인한 정밀도 문제가 발생할 수 있다.&lt;/li>
&lt;li>일부 알고리즘의 경우 시간 복잡도가 높을 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>벡터, 내적, 외적 등의 수학적 개념을 활용한다.&lt;/li>
&lt;li>CCW(Counter-Clockwise) 알고리즘 등 특수한 기법을 사용한다.&lt;/li>
&lt;li>동적 변화에 대응하는 알고리즘 설계가 중요하다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>볼록 껍질 알고리즘(Convex Hull Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="볼록-껍질-알고리즘convex-hull-algorithms">&lt;/span>
&lt;a href="#%eb%b3%bc%eb%a1%9d-%ea%bb%8d%ec%a7%88-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98convex-hull-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>점들을 포함하는 가장 작은 볼록 다각형을 찾는다.&lt;/p>
&lt;ul>
&lt;li>장점: 물체 인식, 충돌 감지에 유용&lt;/li>
&lt;li>단점: 3차원 이상에서 복잡도 증가&lt;/li>
&lt;li>대표적 알고리즘: Graham&amp;rsquo;s Scan, Jarvis March&lt;/li>
&lt;/ul>
&lt;h4>선분 교차 판정 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="선분-교차-판정-알고리즘">&lt;/span>
&lt;a href="#%ec%84%a0%eb%b6%84-%ea%b5%90%ec%b0%a8-%ed%8c%90%ec%a0%95-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>두 선분의 교차 여부를 판단&lt;/p>
&lt;ul>
&lt;li>장점: 구현이 비교적 간단&lt;/li>
&lt;li>단점: 부동소수점 오차 처리 필요&lt;/li>
&lt;li>활용: 충돌 감지, GIS 시스템&lt;/li>
&lt;/ul>
&lt;h4>점 포함 판정 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="점-포함-판정-알고리즘">&lt;/span>
&lt;a href="#%ec%a0%90-%ed%8f%ac%ed%95%a8-%ed%8c%90%ec%a0%95-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>점이 다각형 내부에 있는지 판단&lt;/p>
&lt;ul>
&lt;li>장점: 다양한 응용 가능&lt;/li>
&lt;li>단점: 복잡한 다각형에서 계산 비용 증가&lt;/li>
&lt;li>활용: 지도 시스템, 게임 개발&lt;/li>
&lt;/ul>
&lt;h4>최근접 쌍 문제 (Closest Pair Problem)&lt;span class="hx-absolute -hx-mt-20" id="최근접-쌍-문제-closest-pair-problem">&lt;/span>
&lt;a href="#%ec%b5%9c%ea%b7%bc%ec%a0%91-%ec%8c%8d-%eb%ac%b8%ec%a0%9c-closest-pair-problem" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>주어진 점들 중 가장 가까운 두 점을 찾습니다.&lt;/p>
&lt;ul>
&lt;li>장점: 분할 정복 방법으로 효율적인 해결이 가능합니다.&lt;/li>
&lt;li>활용: 클러스터링, 패턴 인식 등에 사용됩니다.&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>현재 기하 알고리즘 분야의 주요 발전 방향은 다음과 같습니다:&lt;/p>
&lt;ul>
&lt;li>GPU 가속을 활용한 병렬 처리 최적화&lt;/li>
&lt;li>머신러닝과의 결합을 통한 성능 향상&lt;/li>
&lt;li>실시간 처리를 위한 근사 알고리즘 개발&lt;/li>
&lt;li>고차원 데이터 처리를 위한 새로운 접근법&lt;/li>
&lt;li>로봇 공학과의 통합을 위한 발전&lt;/li>
&lt;/ul>
&lt;h3>선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>기하 알고리즘 선택 시 다음 사항들을 고려해야 합니다:&lt;/p>
&lt;ul>
&lt;li>문제의 차원(2D, 3D 등)&lt;/li>
&lt;li>정밀도 요구사항&lt;/li>
&lt;li>성능 요구사항(실시간 처리 필요 여부)&lt;/li>
&lt;li>특수 케이스 처리 필요성&lt;/li>
&lt;li>구현의 복잡도&lt;/li>
&lt;li>메모리 사용량&lt;/li>
&lt;/ul>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>기하 알고리즘은 다양한 분야에서 활용됩니다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>컴퓨터 그래픽스:&lt;/p>
&lt;ul>
&lt;li>3D 모델링&lt;/li>
&lt;li>애니메이션&lt;/li>
&lt;li>게임 개발&lt;/li>
&lt;li>가상현실(VR) 응용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>로보틱스:&lt;/p>
&lt;ul>
&lt;li>경로 계획&lt;/li>
&lt;li>충돌 회피&lt;/li>
&lt;li>모션 플래닝&lt;/li>
&lt;li>공간 인식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>지리 정보 시스템(GIS):&lt;/p>
&lt;ul>
&lt;li>지도 제작&lt;/li>
&lt;li>공간 분석&lt;/li>
&lt;li>위치 기반 서비스&lt;/li>
&lt;li>네비게이션 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>산업 응용:&lt;/p>
&lt;ul>
&lt;li>CAD/CAM 시스템&lt;/li>
&lt;li>3D 프린팅&lt;/li>
&lt;li>컴퓨터 비전&lt;/li>
&lt;li>패턴 인식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>문자열 알고리즘 (String Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/string-algorithms/</link><pubDate>Tue, 05 Nov 2024 06:02:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/string-algorithms/</guid><description>
&lt;h2>문자열 알고리즘 (String Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="문자열-알고리즘-string-algorithms">&lt;/span>
&lt;a href="#%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-string-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>문자열 알고리즘은 텍스트 데이터를 처리하고 분석하는 알고리즘의 집합.&lt;br>
이는 문자열 검색, 패턴 매칭, 문자열 압축 등 다양한 작업을 수행하는 데 사용된다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>텍스트 데이터의 효율적인 처리가 가능하다.&lt;/li>
&lt;li>다양한 응용 분야에서 활용될 수 있다.&lt;/li>
&lt;li>대용량 데이터 처리에 유용하다.&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>일부 알고리즘은 구현이 복잡할 수 있다.&lt;/li>
&lt;li>특정 상황에서 성능 저하가 발생할 수 있다.&lt;/li>
&lt;li>알고리즘 선택에 따라 메모리 사용량이 증가할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>패턴 매칭과 검색에 중점을 둔다.&lt;/li>
&lt;li>전처리 과정을 통해 효율성을 높인다.&lt;/li>
&lt;li>다양한 최적화 기법을 사용한다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류와 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-종류와-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98%ec%99%80-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>KMP(Knuth-Morris-Pratt) 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="kmpknuth-morris-pratt-알고리즘">&lt;/span>
&lt;a href="#kmpknuth-morris-pratt-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>접두사와 접미사의 개념을 활용하여 불필요한 비교를 줄인다.&lt;/p>
&lt;ul>
&lt;li>장점: 선형 시간 복잡도 O(n+m)으로 효율적이다.&lt;/li>
&lt;li>단점: 구현이 복잡할 수 있다.&lt;/li>
&lt;li>활용 사례: 텍스트 편집기의 검색 기능, 바이러스 시그니처 검색&lt;/li>
&lt;/ul>
&lt;h4>라빈-카프(Rabin-Karp) 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="라빈-카프rabin-karp-알고리즘">&lt;/span>
&lt;a href="#%eb%9d%bc%eb%b9%88-%ec%b9%b4%ed%94%84rabin-karp-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>해시 함수를 사용하여 문자열을 비교한다.&lt;/p>
&lt;ul>
&lt;li>장점: 다중 패턴 검색에 효과적이다.&lt;/li>
&lt;li>단점: 해시 충돌 가능성이 있다.&lt;/li>
&lt;li>활용 사례: 표절 검사, 네트워크 패킷 분석&lt;/li>
&lt;/ul>
&lt;h4>보이어-무어(Boyer-Moore) 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="보이어-무어boyer-moore-알고리즘">&lt;/span>
&lt;a href="#%eb%b3%b4%ec%9d%b4%ec%96%b4-%eb%ac%b4%ec%96%b4boyer-moore-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>오른쪽에서 왼쪽으로 비교하며, 불일치 발생 시 효과적으로 이동한다.&lt;/p>
&lt;ul>
&lt;li>장점: 실제 상황에서 매우 빠른 성능을 보인다.&lt;/li>
&lt;li>단점: 전처리 과정이 필요하다.&lt;/li>
&lt;li>활용 사례: 데이터베이스 검색, 텍스트 에디터의 검색 기능&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>머신러닝과 결합한 하이브리드 문자열 알고리즘 개발&lt;/li>
&lt;li>대규모 데이터 처리를 위한 분산 문자열 알고리즘 연구&lt;/li>
&lt;li>실시간 스트리밍 데이터 처리 지원&lt;/li>
&lt;li>자연어 처리와의 결합&lt;/li>
&lt;li>압축된 상태에서의 문자열 처리&lt;/li>
&lt;li>양자 컴퓨팅을 활용한 문자열 알고리즘 최적화&lt;/li>
&lt;/ul>
&lt;h3>선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>데이터의 크기와 특성&lt;/li>
&lt;li>요구되는 성능 (시간 복잡도, 공간 복잡도)&lt;/li>
&lt;li>구현의 복잡성&lt;/li>
&lt;li>다중 패턴 검색 필요 여부&lt;/li>
&lt;/ul>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>검색 엔진:&lt;/p>
&lt;ul>
&lt;li>웹 페이지 검색&lt;/li>
&lt;li>문서 내용 검색&lt;/li>
&lt;li>실시간 검색 추천&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>생물정보학:&lt;/p>
&lt;ul>
&lt;li>DNA 서열 분석&lt;/li>
&lt;li>단백질 구조 비교&lt;/li>
&lt;li>유전자 패턴 매칭&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>텍스트 처리:&lt;/p>
&lt;ul>
&lt;li>스펠링 체크&lt;/li>
&lt;li>자동 완성&lt;/li>
&lt;li>표절 검사&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>보안 응용:&lt;/p>
&lt;ul>
&lt;li>바이러스 검사&lt;/li>
&lt;li>침입 탐지&lt;/li>
&lt;li>패턴 기반 악성코드 탐지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터 압축 알고리즘&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>그리디 알고리즘 (Greedy Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/greedy-algorithms/</link><pubDate>Tue, 05 Nov 2024 02:01:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/greedy-algorithms/</guid><description>
&lt;h2>그리디 알고리즘 (Greedy Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="그리디-알고리즘-greedy-algorithms">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%a6%ac%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-greedy-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&amp;ldquo;탐욕적&amp;rdquo; 또는 &amp;ldquo;욕심쟁이&amp;rdquo; 알고리즘이라고도 불리며, 현재 상황에서 가장 최적의 선택을 하는 방식으로 문제를 해결하는 알고리즘.&lt;br>
매 선택의 순간마다 당장 눈앞에 보이는 최적의 선택을 하여 최종적인 해답에 도달하는 방식이다.&lt;/p>
&lt;p>예를 들어, 거스름돈을 계산할 때 가장 큰 단위의 동전부터 사용하는 것이 그리디 알고리즘의 대표적인 예시이다.&lt;br>
500원짜리 동전을 최대한 사용하고, 그 다음 100원, 50원 순으로 사용하는 방식.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>단순성: 직관적이고 이해하기 쉬워서 구현이 간단하다.&lt;/li>
&lt;li>속도: 매 단계에서 최적의 선택을 하므로 계산 속도가 빠르다.&lt;/li>
&lt;li>효율성: 많은 문제에서 적절한 해를 빠르게 제공한다.&lt;/li>
&lt;li>근사해 제공: NP-Hard 문제에서 근사해를 빠르게 찾을 수 있다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>최적해 보장 불가: 항상 최적해를 보장하지 않는다.&lt;/li>
&lt;li>문제 특성 의존성: 그리디 특성을 가진 문제에만 적용 가능하다.&lt;/li>
&lt;li>전역 최적화 부재: 지역적 최적해가 전역 최적해를 보장하지 않는다.&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>탐욕적 선택 속성(Greedy Choice Property): 각 단계에서 &lt;strong>현재 상태에서 최적의 선택&lt;/strong>을 한다.&lt;/li>
&lt;li>최적 부분 구조(Optimal Substructure): 문제의 최적해가 부분 문제의 최적해로 구성될 수 있다.&lt;/li>
&lt;li>단계적 선택: 문제를 해결하는 과정에서 매 단계마다 가장 최적의 선택을 한다.&lt;/li>
&lt;li>비가역적 선택: 한번 선택한 것은 다시 번복하지 않는다.&lt;/li>
&lt;/ol>
&lt;h3>그리디 알고리즘 종류와 특징&lt;span class="hx-absolute -hx-mt-20" id="그리디-알고리즘-종류와-특징">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%a6%ac%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%a2%85%eb%a5%98%ec%99%80-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>동전 거스름돈 문제&lt;span class="hx-absolute -hx-mt-20" id="동전-거스름돈-문제">&lt;/span>
&lt;a href="#%eb%8f%99%ec%a0%84-%ea%b1%b0%ec%8a%a4%eb%a6%84%eb%8f%88-%eb%ac%b8%ec%a0%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>가장 큰 단위의 동전부터 사용&lt;/p>
&lt;ul>
&lt;li>장점: 간단하고 빠른 해결 가능&lt;/li>
&lt;li>단점: 특정 동전 체계에서만 최적해 보장&lt;/li>
&lt;li>활용 사례: 자판기, 화폐 교환 시스템&lt;/li>
&lt;/ul>
&lt;h4>활동 선택 문제 (Activity Selection Problem)&lt;span class="hx-absolute -hx-mt-20" id="활동-선택-문제-activity-selection-problem">&lt;/span>
&lt;a href="#%ed%99%9c%eb%8f%99-%ec%84%a0%ed%83%9d-%eb%ac%b8%ec%a0%9c-activity-selection-problem" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>종료 시간을 기준으로 활동 선택&lt;/p>
&lt;ul>
&lt;li>장점: 최대 활동 수를 효율적으로 선택&lt;/li>
&lt;li>단점: 활동의 중요도를 고려하지 않음&lt;/li>
&lt;li>활용 사례: 회의실 예약 시스템, 작업 스케줄링&lt;/li>
&lt;/ul>
&lt;h4>분할 가능 배낭 문제 (Fractional Knapsack Problem)&lt;span class="hx-absolute -hx-mt-20" id="분할-가능-배낭-문제-fractional-knapsack-problem">&lt;/span>
&lt;a href="#%eb%b6%84%ed%95%a0-%ea%b0%80%eb%8a%a5-%eb%b0%b0%eb%82%ad-%eb%ac%b8%ec%a0%9c-fractional-knapsack-problem" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>단위 무게당 가치를 기준으로 물건 선택&lt;/p>
&lt;ul>
&lt;li>장점: 최적해 보장&lt;/li>
&lt;li>단점: 물건을 분할할 수 있는 경우에만 적용 가능&lt;/li>
&lt;li>활용 사례: 자원 할당, 투자 포트폴리오 구성&lt;/li>
&lt;/ul>
&lt;h4>크러스컬 알고리즘 (Kruskal&amp;rsquo;s Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="크러스컬-알고리즘-kruskals-algorithm">&lt;/span>
&lt;a href="#%ed%81%ac%eb%9f%ac%ec%8a%a4%ec%bb%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-kruskals-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>최소 신장 트리를 찾는 알고리즘&lt;/p>
&lt;ul>
&lt;li>장점: 희소 그래프에서 효율적&lt;/li>
&lt;li>단점: 밀집 그래프에서는 프림 알고리즘보다 성능이 떨어짐&lt;/li>
&lt;li>활용: 네트워크 설계, 통신망 구축&lt;/li>
&lt;/ul>
&lt;h4>허프만 코딩(Huffman Coding)&lt;span class="hx-absolute -hx-mt-20" id="허프만-코딩huffman-coding">&lt;/span>
&lt;a href="#%ed%97%88%ed%94%84%eb%a7%8c-%ec%bd%94%eb%94%a9huffman-coding" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>빈도수에 따라 가변 길이 코드 할당&lt;/p>
&lt;ul>
&lt;li>장점: 효율적인 데이터 압축 가능&lt;/li>
&lt;li>단점: 빈도수 정보가 필요함&lt;/li>
&lt;li>활용 사례: 데이터 압축, 파일 압축 알고리즘&lt;/li>
&lt;/ul>
&lt;h4>다익스트라 알고리즘(Dijkstra&amp;rsquo;s Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="다익스트라-알고리즘dijkstras-algorithm">&lt;/span>
&lt;a href="#%eb%8b%a4%ec%9d%b5%ec%8a%a4%ed%8a%b8%eb%9d%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98dijkstras-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>최단 경로를 찾기 위해 가장 가까운 노드 선택&lt;/p>
&lt;ul>
&lt;li>장점: 단일 출발점 최단 경로 문제 해결에 효율적&lt;/li>
&lt;li>단점: 음의 가중치를 가진 간선에 적용 불가&lt;/li>
&lt;li>활용 사례: 네트워크 라우팅, GPS 내비게이션 시스템&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>다중 목적 그리디 알고리즘: 여러 목적을 동시에 고려하는 알고리즘 개발&lt;/li>
&lt;li>그리디 알고리즘과 기계학습의 결합: 복잡한 최적화 문제 해결에 활용&lt;/li>
&lt;li>근사 알고리즘으로서의 활용: NP-Hard 문제의 근사해 도출에 사용&lt;/li>
&lt;/ol>
&lt;h3>그리디 알고리즘 선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="그리디-알고리즘-선택-시-고려사항">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%a6%ac%eb%94%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제의 최적 부분 구조 확인&lt;/li>
&lt;li>탐욕적 선택 속성 만족 여부 검토&lt;/li>
&lt;li>단계적 결정 가능성 평가&lt;/li>
&lt;li>정렬이나 우선순위 큐 관련 문제인지 확인&lt;/li>
&lt;/ol>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>네트워크 프로토콜: Open Shortest Path First 프로토콜&lt;/li>
&lt;li>인공지능: 실시간 얼굴 추적&lt;/li>
&lt;li>데이터 압축: 허프만 인코딩&lt;/li>
&lt;li>그래프 알고리즘: 최소 신장 트리, 최단 경로 문제&lt;/li>
&lt;li>스케줄링: 작업 스케줄링, 회의실 배정&lt;/li>
&lt;li>리소스 할당: 분할 가능 배낭 문제&lt;/li>
&lt;li>금융: 포트폴리오 최적화&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>그래프 알고리즘 (Graph Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/graph-algorithms/</link><pubDate>Tue, 05 Nov 2024 01:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/graph-algorithms/</guid><description>
&lt;h2>그래프 알고리즘 (Graph Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="그래프-알고리즘-graph-algorithms">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%9e%98%ed%94%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-graph-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>그래프 알고리즘은 복잡한 네트워크 구조에서 의미 있는 통찰력을 추출하는 데 사용되는 계산 기법.&lt;br>
이러한 알고리즘은 노드(또는 정점)와 엣지로 구성된 그래프 데이터를 분석하고 탐색한다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ol>
&lt;li>복잡한 관계를 시각적으로 표현하여 이해하기 쉽다.&lt;/li>
&lt;li>패턴 인식, 트렌드 분석, 이상 탐지 등을 가능하게 한다.&lt;/li>
&lt;li>다양한 실제 상황을 정확하게 모델링할 수 있다.&lt;/li>
&lt;li>효율적인 데이터 처리와 해석이 가능하다.&lt;/li>
&lt;/ol>
&lt;p>단점:&lt;/p>
&lt;ol>
&lt;li>대규모 데이터셋에서는 그래프가 복잡해져 이해하기 어려울 수 있다.&lt;/li>
&lt;li>그래프 생성과 분석에 시간과 전문 지식이 필요할 수 있다.&lt;/li>
&lt;li>인접 행렬을 사용할 경우, 희소 그래프에서 메모리 낭비가 발생할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>복잡하고 상호 연결된 데이터 구조에서 정보를 효율적으로 찾을 수 있다.&lt;/li>
&lt;li>노드 간의 관계를 탐색하고 분석하는 데 특화되어 있다.&lt;/li>
&lt;li>다양한 분야에서 활용되며, 특히 빅데이터, 소셜 미디어, 분산형 데이터 분석에 널리 사용된다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>너비 우선 탐색 (Breadth-First Search, BFS)&lt;span class="hx-absolute -hx-mt-20" id="너비-우선-탐색-breadth-first-search-bfs">&lt;/span>
&lt;a href="#%eb%84%88%eb%b9%84-%ec%9a%b0%ec%84%a0-%ed%83%90%ec%83%89-breadth-first-search-bfs" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>그래프를 레벨별로 탐색하는 알고리즘&lt;br>
루트 노드에서 시작하여 인접한 노드를 먼저 탐색&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>현재 노드와 가까운 노드부터 탐색&lt;/li>
&lt;li>큐를 사용하여 구현&lt;/li>
&lt;li>최단 경로 보장&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>최단 경로 찾기에 적합&lt;/li>
&lt;li>레벨 단위 탐색 가능&lt;/li>
&lt;li>완전 탐색 보장&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>최단 거리 문제&lt;/li>
&lt;li>네트워크 흐름&lt;/li>
&lt;li>웹 크롤링&lt;/li>
&lt;/ul>
&lt;h4>깊이 우선 탐색 (Depth-First Search, DFS)&lt;span class="hx-absolute -hx-mt-20" id="깊이-우선-탐색-depth-first-search-dfs">&lt;/span>
&lt;a href="#%ea%b9%8a%ec%9d%b4-%ec%9a%b0%ec%84%a0-%ed%83%90%ec%83%89-depth-first-search-dfs" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>그래프의 깊이를 우선으로 탐색하는 알고리즘&lt;br>
한 경로를 끝까지 탐색한 후 다음 경로로 이동한다.&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>한 방향으로 깊게 탐색한 후 다른 방향을 탐색&lt;/li>
&lt;li>스택이나 재귀를 사용하여 구현&lt;/li>
&lt;li>메모리 사용이 적음&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>구현이 비교적 간단&lt;/li>
&lt;li>메모리 효율적&lt;/li>
&lt;li>모든 노드 방문 보장&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>경로 찾기&lt;/li>
&lt;li>사이클 탐지&lt;/li>
&lt;li>위상 정렬&lt;/li>
&lt;/ul>
&lt;h4>다익스트라 알고리즘 (Dijkstra&amp;rsquo;s Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="다익스트라-알고리즘-dijkstras-algorithm">&lt;/span>
&lt;a href="#%eb%8b%a4%ec%9d%b5%ec%8a%a4%ed%8a%b8%eb%9d%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-dijkstras-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>가중치 그래프에서 최단 경로를 찾는 알고리즘&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>단일 출발점 최단 경로&lt;/li>
&lt;li>음의 가중치를 허용하지 않음&lt;/li>
&lt;li>그리디 방식 사용&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>효율적인 최단 경로 탐색&lt;/li>
&lt;li>실제 응용에서 널리 사용&lt;/li>
&lt;li>구현이 비교적 간단&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>GPS 내비게이션&lt;/li>
&lt;li>네트워크 라우팅&lt;/li>
&lt;li>소셜 네트워크 분석&lt;/li>
&lt;/ul>
&lt;h4>벨만-포드 알고리즘 (Bellman-Ford Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="벨만-포드-알고리즘-bellman-ford-algorithm">&lt;/span>
&lt;a href="#%eb%b2%a8%eb%a7%8c-%ed%8f%ac%eb%93%9c-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-bellman-ford-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>음의 가중치를 가진 그래프에서도 최단 경로를 찾을 수 있는 알고리즘&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>음의 가중치 허용&lt;/li>
&lt;li>음의 사이클 탐지 가능&lt;/li>
&lt;li>모든 간선을 반복 검사&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>음의 가중치 처리 가능&lt;/li>
&lt;li>음의 사이클 탐지&lt;/li>
&lt;li>구현이 간단&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>네트워크 라우팅&lt;/li>
&lt;li>금융 거래 시스템&lt;/li>
&lt;li>차익 거래 탐지&lt;/li>
&lt;/ul>
&lt;h4>크루스칼 알고리즘 (Kruskal&amp;rsquo;s Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="크루스칼-알고리즘-kruskals-algorithm">&lt;/span>
&lt;a href="#%ed%81%ac%eb%a3%a8%ec%8a%a4%ec%b9%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-kruskals-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>최소 신장 트리를 찾는 알고리즘&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>간선을 가중치 순으로 정렬&lt;/li>
&lt;li>Union-Find 자료구조 사용&lt;/li>
&lt;li>그리디 방식 적용&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>희소 그래프에서 효율적&lt;/li>
&lt;li>구현이 비교적 간단&lt;/li>
&lt;li>전역 최적해 보장&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>네트워크 설계&lt;/li>
&lt;li>클러스터링&lt;/li>
&lt;li>회로 설계&lt;/li>
&lt;/ul>
&lt;h4>프림 알고리즘 (Prim&amp;rsquo;s Algorithm)&lt;span class="hx-absolute -hx-mt-20" id="프림-알고리즘-prims-algorithm">&lt;/span>
&lt;a href="#%ed%94%84%eb%a6%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-prims-algorithm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>또 다른 최소 신장 트리 알고리즘&lt;/p>
&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>정점 중심의 확장&lt;/li>
&lt;li>우선순위 큐 사용&lt;/li>
&lt;li>연결된 정점들 중 최소 비용 선택&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>조밀한 그래프에서 효율적&lt;/li>
&lt;li>부분 결과 활용 가능&lt;/li>
&lt;li>안정적인 성능&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>통신망 구축&lt;/li>
&lt;li>파이프라인 설계&lt;/li>
&lt;li>전력망 구축&lt;/li>
&lt;/ul>
&lt;h4>코사라주 알고리즘 (Kosaraju)&lt;span class="hx-absolute -hx-mt-20" id="코사라주-알고리즘-kosaraju">&lt;/span>
&lt;a href="#%ec%bd%94%ec%82%ac%eb%9d%bc%ec%a3%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-kosaraju" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>특징:&lt;/p>
&lt;ul>
&lt;li>DFS를 두 번 수행&lt;/li>
&lt;li>방향 그래프의 강연결 요소 찾기&lt;/li>
&lt;li>선형 시간 복잡도&lt;/li>
&lt;/ul>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>구현이 비교적 간단&lt;/li>
&lt;li>효율적인 시간 복잡도&lt;/li>
&lt;li>모든 강연결 요소 탐지&lt;/li>
&lt;/ul>
&lt;p>활용:&lt;/p>
&lt;ul>
&lt;li>웹 페이지 분석&lt;/li>
&lt;li>사회 연결망 분석&lt;/li>
&lt;li>종속성 분석&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>대규모 그래프 처리를 위한 분산 알고리즘 개발&lt;/li>
&lt;li>실시간 그래프 처리 기술&lt;/li>
&lt;li>동적 그래프에 대한 효율적인 알고리즘&lt;/li>
&lt;li>머신러닝과의 결합&lt;/li>
&lt;/ul>
&lt;h3>실제 응용에서의 고려사항&lt;span class="hx-absolute -hx-mt-20" id="실제-응용에서의-고려사항">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%9d%91%ec%9a%a9%ec%97%90%ec%84%9c%ec%9d%98-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>성능 요구사항&lt;/p>
&lt;ul>
&lt;li>시간 복잡도&lt;/li>
&lt;li>공간 복잡도&lt;/li>
&lt;li>실시간 처리 여부&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>그래프 특성&lt;/p>
&lt;ul>
&lt;li>그래프 크기&lt;/li>
&lt;li>밀도&lt;/li>
&lt;li>방향성 여부&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>구현 환경&lt;/p>
&lt;ul>
&lt;li>메모리 제약&lt;/li>
&lt;li>병렬화 가능성&lt;/li>
&lt;li>확장성 요구사항&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>수치 알고리즘 (Numerical Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/numerical-algorithms/</link><pubDate>Mon, 04 Nov 2024 06:02:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/numerical-algorithms/</guid><description>
&lt;h2>수치 알고리즘 (Numerical Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="수치-알고리즘-numerical-algorithms">&lt;/span>
&lt;a href="#%ec%88%98%ec%b9%98-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-numerical-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>수치해석학의 일부로, 복잡한 수학적 문제를 컴퓨터를 이용해 수치적으로 근사해서 해결하는 알고리즘.&lt;br>
이는 정확한 해를 구하기 어려운 문제에 대해 근사값을 효율적으로 계산하는 방법을 제공한다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>복잡한 수학적 문제를 해결할 수 있다.&lt;/li>
&lt;li>컴퓨터를 이용해 빠르고 효율적인 계산이 가능하다.&lt;/li>
&lt;li>실제 응용 분야에서 유용하게 활용된다.&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>정확한 해가 아닌 근사값을 제공한다.&lt;/li>
&lt;li>일부 알고리즘은 구현이 복잡할 수 있다.&lt;/li>
&lt;li>수치적 안정성과 오차 관리가 중요한 이슈이다.&lt;/li>
&lt;/ul>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>반복적인 계산을 통해 해를 개선한다.&lt;/li>
&lt;li>오차 분석과 수렴성 연구가 중요하다.&lt;/li>
&lt;li>컴퓨터의 부동소수점 연산 특성을 고려해야 한다.&lt;/li>
&lt;li>정밀도와 계산 속도 사이의 트레이드오프가 있다&lt;/li>
&lt;li>많은 경우 근사해를 제공한다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>수치 알고리즘(Numerical Algorithms)에 대해 자세히 설명하겠습니다.&lt;/p>
&lt;h2>0. 개념과 정의&lt;span class="hx-absolute -hx-mt-20" id="0-개념과-정의">&lt;/span>
&lt;a href="#0-%ea%b0%9c%eb%85%90%ea%b3%bc-%ec%a0%95%ec%9d%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>수치 알고리즘은 수치해석학의 일부로, 복잡한 수학적 문제를 컴퓨터를 이용해 수치적으로 근사해서 해결하는 알고리즘입니다. 이는 정확한 해를 구하기 어려운 문제에 대해 근사값을 효율적으로 계산하는 방법을 제공합니다[1][3].&lt;/p>
&lt;h2>1. 장점&lt;span class="hx-absolute -hx-mt-20" id="1-장점">&lt;/span>
&lt;a href="#1-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>복잡한 수학적 문제를 해결할 수 있습니다.&lt;/li>
&lt;li>컴퓨터를 이용해 빠르고 효율적인 계산이 가능합니다.&lt;/li>
&lt;li>실제 응용 분야에서 유용하게 활용됩니다.&lt;/li>
&lt;/ul>
&lt;h2>2. 단점&lt;span class="hx-absolute -hx-mt-20" id="2-단점">&lt;/span>
&lt;a href="#2-%eb%8b%a8%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>정확한 해가 아닌 근사값을 제공합니다.&lt;/li>
&lt;li>일부 알고리즘은 구현이 복잡할 수 있습니다.&lt;/li>
&lt;li>수치적 안정성과 오차 관리가 중요한 이슈입니다.&lt;/li>
&lt;/ul>
&lt;h2>3. 특징&lt;span class="hx-absolute -hx-mt-20" id="3-특징">&lt;/span>
&lt;a href="#3-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>반복적인 계산을 통해 해를 개선합니다.&lt;/li>
&lt;li>오차 분석과 수렴성 연구가 중요합니다.&lt;/li>
&lt;li>컴퓨터의 부동소수점 연산 특성을 고려해야 합니다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류-1">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>방정식의 해 구하기&lt;span class="hx-absolute -hx-mt-20" id="방정식의-해-구하기">&lt;/span>
&lt;a href="#%eb%b0%a9%ec%a0%95%ec%8b%9d%ec%9d%98-%ed%95%b4-%ea%b5%ac%ed%95%98%ea%b8%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>이분법(Bisection Method)&lt;span class="hx-absolute -hx-mt-20" id="이분법bisection-method">&lt;/span>
&lt;a href="#%ec%9d%b4%eb%b6%84%eb%b2%95bisection-method" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>구간을 반으로 나누어 해를 찾음&lt;/p>
&lt;ul>
&lt;li>장점: 안정적이고 구현이 간단함&lt;/li>
&lt;li>단점: 수렴 속도가 느림&lt;/li>
&lt;li>활용: 단순한 방정식의 해 구하기&lt;/li>
&lt;/ul>
&lt;h5>뉴턴-랩슨 방법(Newton-Raphson Method)&lt;span class="hx-absolute -hx-mt-20" id="뉴턴-랩슨-방법newton-raphson-method">&lt;/span>
&lt;a href="#%eb%89%b4%ed%84%b4-%eb%9e%a9%ec%8a%a8-%eb%b0%a9%eb%b2%95newton-raphson-method" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>접선을 이용한 반복적 접근&lt;/p>
&lt;ul>
&lt;li>장점: 빠른 수렴 속도&lt;/li>
&lt;li>단점: 초기값에 민감함&lt;/li>
&lt;li>활용: 비선형 방정식 해결&lt;/li>
&lt;/ul>
&lt;h4>수치 적분&lt;span class="hx-absolute -hx-mt-20" id="수치-적분">&lt;/span>
&lt;a href="#%ec%88%98%ec%b9%98-%ec%a0%81%eb%b6%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;h5>사다리꼴 법칙(Trapezoidal Rule)&lt;span class="hx-absolute -hx-mt-20" id="사다리꼴-법칙trapezoidal-rule">&lt;/span>
&lt;a href="#%ec%82%ac%eb%8b%a4%eb%a6%ac%ea%bc%b4-%eb%b2%95%ec%b9%99trapezoidal-rule" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>구간을 사다리꼴로 근사&lt;/p>
&lt;ul>
&lt;li>장점: 구현이 간단하고 안정적&lt;/li>
&lt;li>단점: 정밀도가 상대적으로 낮음&lt;/li>
&lt;li>활용: 간단한 적분 계산&lt;/li>
&lt;/ul>
&lt;h5>심프슨 법칙(Simpson&amp;rsquo;s Rule)&lt;span class="hx-absolute -hx-mt-20" id="심프슨-법칙simpsons-rule">&lt;/span>
&lt;a href="#%ec%8b%ac%ed%94%84%ec%8a%a8-%eb%b2%95%ec%b9%99simpsons-rule" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h5>&lt;p>2차 다항식으로 근사&lt;/p>
&lt;ul>
&lt;li>장점: 높은 정확도&lt;/li>
&lt;li>단점: 계산이 복잡함&lt;/li>
&lt;li>활용: 정밀한 적분이 필요한 경우&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>머신러닝과의 결합: 수치 알고리즘을 개선하는데 AI 기술을 활용합니다.&lt;/li>
&lt;li>병렬 컴퓨팅: 대규모 수치 계산을 위한 병렬 알고리즘 개발이 진행 중입니다.&lt;/li>
&lt;li>양자 컴퓨팅: 양자 컴퓨터를 이용한 새로운 수치 알고리즘 연구가 이루어지고 있습니다.&lt;/li>
&lt;/ul>
&lt;h3>선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="선택-시-고려사항">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>문제의 특성과 요구되는 정확도&lt;/li>
&lt;li>계산 효율성과 수행 시간&lt;/li>
&lt;li>수치적 안정성&lt;/li>
&lt;li>구현의 복잡성&lt;/li>
&lt;/ul>
&lt;h3>활용 사례&lt;span class="hx-absolute -hx-mt-20" id="활용-사례">&lt;/span>
&lt;a href="#%ed%99%9c%ec%9a%a9-%ec%82%ac%eb%a1%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>과학 계산:&lt;/p>
&lt;ul>
&lt;li>물리 시뮬레이션&lt;/li>
&lt;li>기상 예측&lt;/li>
&lt;li>구조 해석&lt;/li>
&lt;li>유체 역학 계산&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>금융 공학:&lt;/p>
&lt;ul>
&lt;li>옵션 가격 계산&lt;/li>
&lt;li>리스크 분석&lt;/li>
&lt;li>포트폴리오 최적화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>공학 설계:&lt;/p>
&lt;ul>
&lt;li>CAD/CAM 시스템&lt;/li>
&lt;li>구조 최적화&lt;/li>
&lt;li>제어 시스템 설계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터 사이언스:&lt;/p>
&lt;ul>
&lt;li>통계적 계산&lt;/li>
&lt;li>최적화 문제&lt;/li>
&lt;li>신호 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>생명과학:&lt;/p>
&lt;ul>
&lt;li>단백질 구조 분석&lt;/li>
&lt;li>약물 설계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>컴퓨터 그래픽스:&lt;/p>
&lt;ul>
&lt;li>물리 기반 렌더링&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>정렬 알고리즘 (Sorting Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/sorting-algorithms/</link><pubDate>Sat, 02 Nov 2024 01:26:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/sorting-algorithms/</guid><description>
&lt;h2>정렬 알고리즘 (Sorting Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="정렬-알고리즘-sorting-algorithms">&lt;/span>
&lt;a href="#%ec%a0%95%eb%a0%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-sorting-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.&lt;br>
효율적인 정렬은 데이터 처리의 기본이 되며, 검색이나 데이터 분석의 성능을 크게 향상시킬 수 있다.&lt;br>
다양한 종류의 정렬 알고리즘이 있으며, 각각 고유한 특징과 장단점을 가지고 있다.&lt;/p>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>데이터를 정해진 순서(주로 오름차순이나 내림차순)로 재배열한다.&lt;/li>
&lt;li>알고리즘의 효율성은 주로 시간 복잡도와 공간 복잡도로 평가된다.&lt;/li>
&lt;li>안정 정렬과 불안정 정렬로 구분될 수 있다.&lt;/li>
&lt;li>데이터의 크기와 특성에 따라 적합한 알고리즘이 달라질 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>버블 정렬 (Bubble Sort)&lt;span class="hx-absolute -hx-mt-20" id="버블-정렬-bubble-sort">&lt;/span>
&lt;a href="#%eb%b2%84%eb%b8%94-%ec%a0%95%eb%a0%ac-bubble-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환한다.&lt;/li>
&lt;li>작동 방식:&lt;br>
1. 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환&lt;br>
2. 이 과정을 배열이 정렬될 때까지 반복&lt;br>
3. 각 패스마다 가장 큰 원소가 마지막 위치로 이동&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 구현이 간단하고 이해하기 쉽다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 대규모 데이터셋에 비효율적이며, 시간 복잡도가 O(n²)이다.&lt;/li>
&lt;/ul>
&lt;h4>선택 정렬 (Selection Sort)&lt;span class="hx-absolute -hx-mt-20" id="선택-정렬-selection-sort">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ec%a0%95%eb%a0%ac-selection-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 가장 작은(또는 큰) 원소를 선택하여 정렬된 부분의 끝에 배치한다.&lt;/li>
&lt;li>작동 방식:&lt;br>
1. 현재 위치에 들어갈 값을 찾기 위해 전체 스캔&lt;br>
2. 가장 작은 값을 현재 위치로 이동&lt;br>
3. 이를 반복하여 전체 배열 정렬&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 구현이 간단하고 메모리 사용이 적다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 시간 복잡도가 O(n²)로 대규모 데이터에 비효율적입니다.&lt;/li>
&lt;/ul>
&lt;h4>삽입 정렬 (Insertion Sort)&lt;span class="hx-absolute -hx-mt-20" id="삽입-정렬-insertion-sort">&lt;/span>
&lt;a href="#%ec%82%bd%ec%9e%85-%ec%a0%95%eb%a0%ac-insertion-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 적절한 위치에 삽입한다.&lt;/li>
&lt;li>작동 방식:
&lt;ol>
&lt;li>정렬되지 않은 부분에서 원소를 하나씩 가져와서&lt;/li>
&lt;li>정렬된 부분의 적절한 위치에 삽입&lt;/li>
&lt;li>전체가 정렬될 때까지 반복&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 작은 데이터셋이나 거의 정렬된 데이터에 효율적이다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 큰 데이터셋에서는 비효율적이며, 최악의 경우 O(n²)의 시간 복잡도를 가진다.&lt;/li>
&lt;/ul>
&lt;h4>퀵 정렬 (Quick Sort)&lt;span class="hx-absolute -hx-mt-20" id="퀵-정렬-quick-sort">&lt;/span>
&lt;a href="#%ed%80%b5-%ec%a0%95%eb%a0%ac-quick-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 분할 정복 방법을 사용하며, 피벗을 기준으로 데이터를 분할하고 재귀적으로 정렬한다.&lt;/li>
&lt;li>작동 방식:
&lt;ol>
&lt;li>피벗을 선택하여 배열을 분할&lt;/li>
&lt;li>피벗보다 작은 값과 큰 값으로 분류&lt;/li>
&lt;li>재귀적으로 부분 배열들을 정렬&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 평균적으로 매우 빠르며, 시간 복잡도가 O(n log n)이다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 최악의 경우 O(n²)의 시간 복잡도를 가지며, 불안정 정렬이다.&lt;/li>
&lt;/ul>
&lt;h4>병합 정렬 (Merge Sort)&lt;span class="hx-absolute -hx-mt-20" id="병합-정렬-merge-sort">&lt;/span>
&lt;a href="#%eb%b3%91%ed%95%a9-%ec%a0%95%eb%a0%ac-merge-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 분할 정복 방법을 사용하여 리스트를 작은 부분으로 나누고 정렬 후 병합한다.&lt;/li>
&lt;li>작동 방식:
&lt;ol>
&lt;li>배열을 반으로 나눔&lt;/li>
&lt;li>각 부분을 재귀적으로 정렬&lt;/li>
&lt;li>정렬된 부분들을 병합&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 안정적이며 항상 O(n log n)의 시간 복잡도를 보장한다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 추가적인 메모리 공간이 필요하다.&lt;/li>
&lt;/ul>
&lt;h4>힙 정렬 (Heap Sort)&lt;span class="hx-absolute -hx-mt-20" id="힙-정렬-heap-sort">&lt;/span>
&lt;a href="#%ed%9e%99-%ec%a0%95%eb%a0%ac-heap-sort" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>특징&lt;/strong>: 힙 자료구조를 사용하여 정렬한다.&lt;/li>
&lt;li>&lt;strong>장점&lt;/strong>: 시간 복잡도가 O(n log n)이며, 추가 메모리를 거의 사용하지 않는다.&lt;/li>
&lt;li>&lt;strong>단점&lt;/strong>: 불안정 정렬이며, 캐시 효율성이 떨어질 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>병렬 정렬 알고리즘 개발&lt;/li>
&lt;li>하이브리드 정렬 알고리즘&lt;/li>
&lt;li>GPU를 활용한 정렬&lt;/li>
&lt;li>분산 환경에서의 정렬 최적화&lt;/li>
&lt;/ul>
&lt;h3>선택 기준&lt;span class="hx-absolute -hx-mt-20" id="선택-기준">&lt;/span>
&lt;a href="#%ec%84%a0%ed%83%9d-%ea%b8%b0%ec%a4%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>실제 활용 사례와 선택 기준:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>작은 데이터셋 (n &amp;lt; 50)&lt;/p>
&lt;ul>
&lt;li>삽입 정렬 선호&lt;/li>
&lt;li>구현이 간단하고 오버헤드가 적음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>중간 크기 데이터셋&lt;/p>
&lt;ul>
&lt;li>퀵 정렬이나 병합 정렬 사용&lt;/li>
&lt;li>효율적인 성능과 안정성 균형&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>대규모 데이터셋&lt;/p>
&lt;ul>
&lt;li>병렬화된 퀵 정렬이나 병합 정렬&lt;/li>
&lt;li>분산 환경에서의 정렬 알고리즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>특수한 상황에서의 선택:&lt;/p>
&lt;ul>
&lt;li>메모리 제약이 심한 경우: 힙 정렬&lt;/li>
&lt;li>안정성이 중요한 경우: 병합 정렬&lt;/li>
&lt;li>거의 정렬된 데이터: 삽입 정렬&lt;/li>
&lt;li>고성능이 필요한 경우: 퀵 정렬&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Algorithm Design techniques</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</link><pubDate>Fri, 01 Nov 2024 07:30:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/</guid><description>
&lt;h2>Algorithm Design Techniques&lt;span class="hx-absolute -hx-mt-20" id="algorithm-design-techniques">&lt;/span>
&lt;a href="#algorithm-design-techniques" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.&lt;br>
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.&lt;/p>
&lt;p>분할 정복 (Divide and Conquer), 동적 계획법 (Dynamic Programming), 탐욕 알고리즘 (Greedy Algorithm), 백트래킹 (Backtracking), 분기 한정법 (Branch and Bound), 근사 알고리즘 (Approximation), Randomized Algorithm, 브루트 포스 (Brute Force)는 모두 복잡한 문제를 해결하기 위한 알고리즘 기법들이다.&lt;/p>
&lt;p>다음과 같은 공통점을 가지고 있다.&lt;/p>
&lt;ol>
&lt;li>문제 해결 접근법: 대부분의 기법들은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 접근 방식을 사용한다. 특히 분할 정복, 동적 계획법이 이런 특징을 잘 보여준다.&lt;/li>
&lt;li>최적화 목표: 대부분의 기법들은 주어진 문제에 대한 최적의 해결책을 찾는 것을 목표로 한다. 다만 접근 방식과 보장되는 최적성의 정도가 드랃.&lt;/li>
&lt;li>효율성 고려: 모든 기법들이 시간과 공간 복잡도를 고려하여 효율적인 해결책을 찾고자 한다.&lt;/li>
&lt;/ol>
&lt;p>각각의 알고리즘을 비교 분석하였다.&lt;/p>
&lt;ol>
&lt;li>문제 해결 방식:
&lt;ul>
&lt;li>분할 정복은 하위 문제들이 독립적이다.&lt;/li>
&lt;li>동적 계획법은 하위 문제들이 중복될 수 있으며, 이를 재활용한다.&lt;/li>
&lt;li>탐욕 알고리즘은 각 단계별로 독립적인 결정을 내리며, 지역적 최적해가 전역적 최적해로 이어지는 경우 적합하다.&lt;/li>
&lt;li>백트래킹과 분기 한정법은 체계적인 탐색을 수행하며, 제약 조건이 많은 최적화 문제에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>효율성:
&lt;ul>
&lt;li>동적 계획법과 분할 정복은 중복 계산을 줄여 효율성을 높인다.&lt;/li>
&lt;li>브루트 포스는 모든 경우를 탐색하여 비효율적일 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적해 보장:
&lt;ul>
&lt;li>분할 정복, 동적 계획법 브루트 포스는 최적해를 보장한다.&lt;/li>
&lt;li>탐욕 알고리즘은 일반적으로 최적해를 보장하지 않는다.&lt;/li>
&lt;li>근사 알고리즘은 최적해의 근사값을 제공한다.&lt;/li>
&lt;li>무작위 알고리즘은 확률적으로 좋은 해답을 제공한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적용 범위:
&lt;ul>
&lt;li>근사 알고리즘과 무작위 알고리즘은 NP-난해 문제 등 복잡한 문제에 적용될 수 있다.&lt;/li>
&lt;li>다른 기법들은 특정 유형의 문제에 더 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구현 복잡성:
&lt;ul>
&lt;li>브루트 포스는 구현이 간단하다.&lt;/li>
&lt;li>동적 계획법이나 분기 한정법은 상대적으로 구현이 복잡할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메모리 사용:
&lt;ul>
&lt;li>동적 계획법은 중간 결과를 저장하기 위해 추가 메모리를 사용한다.&lt;/li>
&lt;li>다른 기법들은 상대적으로 적은 메모리를 사용한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 알고리즘 기법들은 각각의 특성에 따라 적합한 문제 유형이 다르며, 때로는 여러 기법을 조합하여 사용하기도 한다. 문제의 성격과 요구사항에 따라 적절한 알고리즘을 선택하는 것이 중요하다.&lt;/p>
&lt;h3>Algorithm Design Techniques&lt;span class="hx-absolute -hx-mt-20" id="algorithm-design-techniques-1">&lt;/span>
&lt;a href="#algorithm-design-techniques-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 설계 기법&lt;/th>
&lt;th>핵심 개념&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>예시&lt;/th>
&lt;th>사용되는 접근 방법&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>분할 정복 (Divide and Conquer)&lt;/td>
&lt;td>문제를 더 작은 하위 문제로 나누고 재귀적으로 해결&lt;/td>
&lt;td>재귀적 구조, 하위 문제 독립성&lt;/td>
&lt;td>효율성, 병렬화 가능&lt;/td>
&lt;td>오버헤드, 메모리 사용량 증가&lt;/td>
&lt;td>병합 정렬, 퀵 정렬&lt;/td>
&lt;td>재귀적 접근, 분할 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동적 계획법 (Dynamic Programming)&lt;/td>
&lt;td>중복되는 하위 문제의 해결책을 저장하여 재사용&lt;/td>
&lt;td>최적 부분 구조, 중복 부분 문제&lt;/td>
&lt;td>시간 복잡도 감소, 최적해 보장&lt;/td>
&lt;td>메모리 사용량 증가, 구현 복잡성&lt;/td>
&lt;td>피보나치 수열, 배낭 문제&lt;/td>
&lt;td>메모이제이션, 타뷸레이션&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>탐욕 알고리즘 (Greedy Algorithm)&lt;/td>
&lt;td>각 단계에서 최선의 선택을 수행&lt;/td>
&lt;td>지역적 최적해 선택, 단순성&lt;/td>
&lt;td>구현 용이, 빠른 실행 시간&lt;/td>
&lt;td>전역 최적해 보장 못함&lt;/td>
&lt;td>크러스컬 알고리즘, 허프만 코딩&lt;/td>
&lt;td>선택적 접근, 순차적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>백트래킹 (Backtracking)&lt;/td>
&lt;td>가능한 모든 해결책을 탐색하며 조건 불만족 시 되돌아감&lt;/td>
&lt;td>깊이 우선 탐색, 가지치기&lt;/td>
&lt;td>모든 해결책 탐색 가능, 메모리 효율적&lt;/td>
&lt;td>최악의 경우 지수 시간 복잡도&lt;/td>
&lt;td>N-퀸 문제, 스도쿠&lt;/td>
&lt;td>재귀적 접근, 깊이 우선 탐색&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분기 한정법 (Branch and Bound)&lt;/td>
&lt;td>최적해를 찾기 위해 해 공간을 체계적으로 탐색&lt;/td>
&lt;td>너비 우선 탐색, 한계 함수 사용&lt;/td>
&lt;td>최적해 보장, 불필요한 탐색 제거&lt;/td>
&lt;td>메모리 사용량 증가, 구현 복잡성&lt;/td>
&lt;td>외판원 문제, 배낭 문제&lt;/td>
&lt;td>너비 우선 탐색, 한계 설정&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>근사 알고리즘 (Approximation)&lt;/td>
&lt;td>최적해에 근접한 해결책을 다항 시간 내에 찾음&lt;/td>
&lt;td>근사비 보장, 다항 시간 복잡도&lt;/td>
&lt;td>NP-난해 문제 해결 가능, 빠른 실행 시간&lt;/td>
&lt;td>최적해 보장 못함&lt;/td>
&lt;td>집합 커버 문제, 최대 컷 문제&lt;/td>
&lt;td>휴리스틱 접근, 반복적 개선&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Randomized Algorithm&lt;/td>
&lt;td>무작위성을 활용하여 문제 해결&lt;/td>
&lt;td>확률적 접근, 반복 실행&lt;/td>
&lt;td>평균 성능 우수, 구현 간단&lt;/td>
&lt;td>결과의 일관성 부족&lt;/td>
&lt;td>빠른 정렬, 소수 판별&lt;/td>
&lt;td>확률적 접근, 몬테카를로 방법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>브루트 포스 (Brute Force)&lt;/td>
&lt;td>가능한 모든 경우를 탐색하여 해결책 찾음&lt;/td>
&lt;td>완전 탐색, 단순 구현&lt;/td>
&lt;td>정확한 해 보장, 구현 용이&lt;/td>
&lt;td>시간 복잡도 높음, 비효율적&lt;/td>
&lt;td>문자열 매칭, 부분집합 생성&lt;/td>
&lt;td>전수 조사, 순차적 접근&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>이 표는 각 알고리즘 설계 기법의 주요 특성을 비교하고 있다.&lt;/p>
&lt;ul>
&lt;li>분할 정복과 동적 계획법은 문제를 작은 부분으로 나누어 해결한다는 점에서 유사하지만, 동적 계획법은 중복되는 하위 문제의 해결책을 저장하여 재사용한다는 점에서 차이가 있다.&lt;/li>
&lt;li>탐욕 알고리즘은 빠르고 구현이 쉽지만 항상 최적해를 보장하지는 않는다.&lt;/li>
&lt;li>백트래킹과 분기 한정법은 모두 탐색 공간을 체계적으로 탐색하지만, 백트래킹은 깊이 우선 탐색을, 분기 한정법은 너비 우선 탐색을 주로 사용한다.&lt;/li>
&lt;li>근사 알고리즘과 무작위 알고리즘은 정확한 해를 보장하지 않지만 빠른 실행 시간을 제공한다.&lt;/li>
&lt;li>브루트 포스는 가장 단순하지만 가장 비효율적인 방법으로, 다른 기법들의 기준점으로 사용될 수 있다.&lt;/li>
&lt;/ul>
&lt;p>각 기법은 특정 문제 유형에 더 적합할 수 있으며, 실제 적용 시에는 문제의 특성, 요구사항, 제약 조건 등을 고려하여 적절한 기법을 선택하거나 여러 기법을 조합하여 사용해야 한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Approaches to algorithm design</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</link><pubDate>Fri, 01 Nov 2024 07:30:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</guid><description>
&lt;h2>Approaches to Algorithm Design&lt;span class="hx-absolute -hx-mt-20" id="approaches-to-algorithm-design">&lt;/span>
&lt;a href="#approaches-to-algorithm-design" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.&lt;br>
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.&lt;/p>
&lt;h3>Approaches to Algorithm Design&lt;span class="hx-absolute -hx-mt-20" id="approaches-to-algorithm-design-1">&lt;/span>
&lt;a href="#approaches-to-algorithm-design-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>알고리즘 설계를 위한 접근 방법은 문제 해결을 위한 전략적인 사고 과정을 의미한다.&lt;br>
이는 알고리즘 설계 기법과는 구별되는 개념으로, 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞춘다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>접근 방법&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>적용 예시&lt;/th>
&lt;th>주요 관련 접근법&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>예증 (Exemplification)&lt;/td>
&lt;td>구체적인 예제를 통해 일반적 규칙을 유도하여 문제를 해결하는 방법으로, 실제 사례 분석을 통한 패턴 발견에 중점을 둠&lt;/td>
&lt;td>구체적인 예를 통해 패턴을 발견하기 쉬움&lt;br>직관적인 이해가 가능&lt;br>실제 사례 기반 학습으로 실용성 높음&lt;/td>
&lt;td>모든 경우를 고려하지 못할 수 있음&lt;br>예외 케이스 누락 위험&lt;br>과도한 일반화 위험&lt;/td>
&lt;td>수열의 일반항 찾기&lt;br>패턴 인식 문제&lt;br>규칙성 발견&lt;br>데이터 마이닝의 패턴 추출&lt;br>기계 학습의 특징 추출&lt;/td>
&lt;td>패턴 매칭&lt;br>귀납적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>패턴 매칭 (Pattern Matching)&lt;/td>
&lt;td>기존 문제와 유사한 패턴을 식별하고 해결 방법을 응용하며, 문제의 구조적 유사성에 기반한 접근&lt;/td>
&lt;td>기존 해결책을 응용하여 효율적&lt;br>검증된 방법론 활용 가능&lt;br>개발 시간 단축과 신뢰성 확보&lt;/td>
&lt;td>새로운 유형의 문제에 적용하기 어려움&lt;br>패턴 인식의 주관성&lt;br>잘못된 패턴 적용 시 비효율적&lt;/td>
&lt;td>문자열 매칭 알고리즘&lt;br>이미지 처리 문제&lt;br>자연어 처리&lt;br>유사도 기반 추천 시스템&lt;br>패턴 기반 보안 탐지&lt;/td>
&lt;td>예증&lt;br>유추적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>단순화와 일반화 (Simplification and Generalization)&lt;/td>
&lt;td>복잡한 문제를 단순한 형태로 변환한 후 점진적으로 일반화하며, 핵심 요소 추출에 중점&lt;/td>
&lt;td>복잡한 문제를 다루기 쉬워짐&lt;br>핵심 개념 파악 용이&lt;br>단계적 접근으로 검증 가능&lt;/td>
&lt;td>단순화 과정에서 중요한 요소를 놓칠 수 있음&lt;br>일반화 과정의 정확성 검증 필요&lt;br>실제 문제와의 괴리 가능성&lt;/td>
&lt;td>그래프 알고리즘&lt;br>기하학적 문제 해결&lt;br>시스템 모델링&lt;br>추상화 계층 설계&lt;br>복잡한 시스템 단순화&lt;/td>
&lt;td>수학적 모델링&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>귀납적 접근법 (Inductive Approach)&lt;/td>
&lt;td>기본 사례부터 시작하여 수학적 귀납법을 통해 일반적인 해결책으로 확장하며, 논리적 정당성 확보&lt;/td>
&lt;td>논리적 진행과 정확성 보장&lt;br>증명 가능한 해결책 도출&lt;br>체계적인 확장성 제공&lt;/td>
&lt;td>복잡한 귀납 과정 필요&lt;br>기본 사례 선정의 중요성&lt;br>일반화 과정의 복잡성&lt;/td>
&lt;td>재귀 함수 설계&lt;br>알고리즘 정확성 증명&lt;br>수학적 증명&lt;br>형식 검증&lt;br>기계 학습의 귀납적 추론&lt;/td>
&lt;td>예증&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자료구조 선택 (Data Structure Selection)&lt;/td>
&lt;td>문제의 특성과 요구사항을 분석하여 최적의 자료구조를 선택하고, 이를 기반으로 알고리즘 설계&lt;/td>
&lt;td>효율적인 성능 최적화&lt;br>메모리 사용 최적화&lt;br>알고리즘 복잡도 개선&lt;/td>
&lt;td>적절한 자료구조 선택에 시간 소요&lt;br>trade-off 분석 복잡성&lt;br>구현 난이도 증가&lt;/td>
&lt;td>해시 테이블 기반 검색&lt;br>트리 기반 알고리즘&lt;br>분산 데이터 구조&lt;br>빅데이터 처리 구조&lt;br>실시간 데이터 처리&lt;/td>
&lt;td>실험적-분석적 접근&lt;br>수학적 모델링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>상향식/하향식 접근법 (Bottom-up/Top-down)&lt;/td>
&lt;td>상향식: 기본 요소부터 점진적 구축&lt;br>하향식: 전체에서 세부로 분해하며, 두 방식의 상호보완적 활용 강조&lt;/td>
&lt;td>체계적인 문제 분석&lt;br>모듈화된 설계 가능&lt;br>복잡도 관리와 재사용성 향상&lt;/td>
&lt;td>전체 구조 파악의 어려움&lt;br>통합 과정의 복잡성&lt;br>두 접근법 간 균형 필요&lt;/td>
&lt;td>동적 프로그래밍&lt;br>분할 정복&lt;br>마이크로서비스 설계&lt;br>대규모 시스템 구조화&lt;br>복잡한 소프트웨어 아키텍처&lt;/td>
&lt;td>분석적 접근&lt;br>제약 기반 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>휴리스틱/메타휴리스틱 접근 (Heuristic/Metaheuristic)&lt;/td>
&lt;td>경험적 규칙과 직관을 활용한 실용적 해결책 도출(휴리스틱)과 이러한 전략들을 체계적으로 조합하고 제어(메타휴리스틱)&lt;/td>
&lt;td>복잡한 문제의 빠른 해결&lt;br>지역 최적해 탈출 가능&lt;br>유연한 전략 적용&lt;br>계산 비용 조절 가능&lt;/td>
&lt;td>최적해 보장 없음&lt;br>파라미터 튜닝 복잡성&lt;br>성능 예측 어려움&lt;br>휴리스틱 선택의 주관성&lt;/td>
&lt;td>외판원 문제(TSP)&lt;br>유전 알고리즘&lt;br>입자 군집 최적화&lt;br>강화학습&lt;br>진화 알고리즘&lt;/td>
&lt;td>확률적 접근법&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실험적-분석적 접근 (Experimental-Analytical)&lt;/td>
&lt;td>이론적 분석과 실험적 검증을 결합한 종합적 접근 방식으로, 이론과 실제의 균형을 추구&lt;/td>
&lt;td>이론과 실제의 통합적 이해&lt;br>체계적 검증 가능&lt;br>실용적 개선점 발견&lt;br>성능 예측과 검증&lt;/td>
&lt;td>시간과 자원 소모가 큼&lt;br>분석과 실험 설계의 복잡성&lt;br>이론-실제 간 격차 해결 필요&lt;/td>
&lt;td>알고리즘 성능 분석&lt;br>복잡도 검증&lt;br>데이터 기반 최적화&lt;br>벤치마킹&lt;br>성능 프로파일링&lt;/td>
&lt;td>수학적 모델링&lt;br>확률적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수학적 모델링 (Mathematical Modeling)&lt;/td>
&lt;td>문제를 수학적 모델로 형식화하여 체계적으로 접근하며, 이론적 기반 확보&lt;/td>
&lt;td>정확한 분석과 최적화&lt;br>이론적 기반 제공&lt;br>성능 예측 가능&lt;br>형식적 검증 가능&lt;/td>
&lt;td>복잡한 수학적 지식 필요&lt;br>현실 문제 단순화 필요&lt;br>모델 검증의 어려움&lt;/td>
&lt;td>최적화 문제&lt;br>시뮬레이션&lt;br>예측 모델링&lt;br>시스템 성능 분석&lt;br>금융 공학 알고리즘&lt;/td>
&lt;td>분석적 접근&lt;br>제약 기반 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>제약 기반 접근법 (Constraint-Based)&lt;/td>
&lt;td>문제의 제약조건을 중심으로 해결 공간을 체계적으로 정의하고 탐색&lt;/td>
&lt;td>명확한 문제 정의&lt;br>효율적 해공간 축소&lt;br>최적해 보장 가능성&lt;br>문제 범위 명확화&lt;/td>
&lt;td>제약조건 모델링 복잡성&lt;br>제약 충돌 해결&lt;br>확장성 제한&lt;br>과도한 제약 위험&lt;/td>
&lt;td>스케줄링 문제&lt;br>자원 할당&lt;br>제약 만족 문제&lt;br>구성 최적화&lt;br>실시간 제약 처리&lt;/td>
&lt;td>수학적 모델링&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>유추적 접근법 (Analogical)&lt;/td>
&lt;td>다른 분야나 유사 문제의 해결 방식을 창의적으로 적용하여 해결책 도출&lt;/td>
&lt;td>창의적 해결책 도출&lt;br>검증된 패턴 활용&lt;br>분야 간 지식 전이&lt;br>혁신적 접근 가능&lt;/td>
&lt;td>부적절한 유추 위험&lt;br>도메인 지식 필요&lt;br>적용 가능성 검증 필요&lt;/td>
&lt;td>생물학적 알고리즘&lt;br>자연 현상 모방&lt;br>학제 간 문제 해결&lt;br>혁신적 알고리즘&lt;br>창의적 문제 해결&lt;/td>
&lt;td>패턴 매칭&lt;br>변환적 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>변환적 접근 (Transformational)&lt;/td>
&lt;td>주어진 문제를 해결된 다른 형태로 변환하여 해결하며, 문제 간 관계성 활용&lt;/td>
&lt;td>검증된 해결책 활용&lt;br>문제 해결의 효율성&lt;br>기존 알고리즘 재사용&lt;br>문제 단순화 가능&lt;/td>
&lt;td>변환 과정의 오버헤드&lt;br>최적성 보장 어려움&lt;br>역변환 과정의 정확성&lt;/td>
&lt;td>NP 문제 변환&lt;br>그래프 변환&lt;br>컴파일러 최적화&lt;br>도메인 변환&lt;br>문제 재구성&lt;/td>
&lt;td>단순화와 일반화&lt;br>유추적 접근법&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확률적 접근법 (Probabilistic)&lt;/td>
&lt;td>확률 이론과 통계적 방법을 활용하여 불확실성을 고려한 해결책 도출&lt;/td>
&lt;td>불확실성 체계적 처리&lt;br>리스크 분석 가능&lt;br>실제 환경 적합성&lt;br>확장성 높음&lt;/td>
&lt;td>확률 모델 설계 복잡성&lt;br>데이터 의존성&lt;br>정확성 보장의 어려움&lt;/td>
&lt;td>몬테카를로 방법&lt;br>확률적 알고리즘&lt;br>베이지안 최적화&lt;br>불확실성 모델링&lt;br>기계 학습 알고리즘&lt;/td>
&lt;td>휴리스틱 접근&lt;br>실험적-분석적 접근&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>접근법들 간의 관계&lt;span class="hx-absolute -hx-mt-20" id="접근법들-간의-관계">&lt;/span>
&lt;a href="#%ec%a0%91%ea%b7%bc%eb%b2%95%eb%93%a4-%ea%b0%84%ec%9d%98-%ea%b4%80%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;pre class="mermaid hx-mt-6">flowchart TD
subgraph Problem_Analysis["문제 분석 단계"]
EX[예증 Exemplification]
PM[패턴 매칭 Pattern Matching]
SG[단순화와 일반화 Simplification &amp; Generalization]
end
subgraph Solution_Design["해결책 설계 단계"]
DS[자료구조 선택 Data Structure Selection]
BT[상향식/하향식 Bottom-up/Top-down]
BR[역방향 추론 Backward Reasoning]
IA[귀납적 접근 Inductive Approach]
end
subgraph Solution_Methods["해결 방법론"]
HM[휴리스틱/메타휴리스틱 Heuristic/Metaheuristic]
MM[수학적 모델링 Mathematical Modeling]
EA[실험적-분석적 Experimental-Analytical]
PA[확률적 접근 Probabilistic]
end
subgraph Advanced_Approaches["고급 접근법"]
TA[변환적 접근 Transformational]
CA[제약 기반 Constraint-Based]
AA[유추적 접근 Analogical]
end
EX &lt;--> PM
PM &lt;--> SG
SG &lt;--> DS
DS &lt;--> BT
BT &lt;--> BR
BR &lt;--> HM
HM &lt;--> MM
MM &lt;--> EA
EA &lt;--> PA
PA &lt;--> TA
TA &lt;--> CA
CA &lt;--> AA
Problem_Analysis &lt;--> Solution_Design
Solution_Design &lt;--> Solution_Methods
Solution_Methods &lt;--> Advanced_Approaches
style Problem_Analysis fill:#e6f3ff,stroke:#333,stroke-width:2px
style Solution_Design fill:#f0fff0,stroke:#333,stroke-width:2px
style Solution_Methods fill:#fff0f5,stroke:#333,stroke-width:2px
style Advanced_Approaches fill:#fff5e6,stroke:#333,stroke-width:2px&lt;/pre>&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>검색 알고리즘 (Searching Algorithms)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/searching-algorithms/</link><pubDate>Wed, 30 Oct 2024 01:27:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/searching-algorithms/</guid><description>
&lt;h2>검색 알고리즘 (Searching Algorithms)&lt;span class="hx-absolute -hx-mt-20" id="검색-알고리즘-searching-algorithms">&lt;/span>
&lt;a href="#%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-searching-algorithms" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 방법을 정의하는 알고리즘.&lt;br>
데이터의 정렬 상태, 크기, 구조 등에 따라 적합한 알고리즘이 달라진다.&lt;/p>
&lt;p>장점:&lt;/p>
&lt;ul>
&lt;li>데이터 검색 속도 향상&lt;/li>
&lt;li>대규모 데이터셋 처리 가능&lt;/li>
&lt;/ul>
&lt;p>단점:&lt;/p>
&lt;ul>
&lt;li>일부 알고리즘은 정렬된 데이터 필요&lt;/li>
&lt;li>구현 복잡도 증가 가능&lt;/li>
&lt;/ul>
&lt;h3>일반적인 특징&lt;span class="hx-absolute -hx-mt-20" id="일반적인-특징">&lt;/span>
&lt;a href="#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>효율성&lt;/strong>: 대부분의 검색 알고리즘은 효율적인 데이터 검색을 목표로 합니다.&lt;/li>
&lt;li>&lt;strong>정확성&lt;/strong>: 검색 결과는 항상 정확해야 합니다.&lt;/li>
&lt;li>&lt;strong>적응성&lt;/strong>: 다양한 데이터 구조와 크기에 적용할 수 있어야 합니다.&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>: 데이터셋의 크기가 증가해도 성능이 크게 저하되지 않아야 합니다.&lt;/li>
&lt;/ol>
&lt;h3>주요 종류&lt;span class="hx-absolute -hx-mt-20" id="주요-종류">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>기본 검색 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="기본-검색-알고리즘">&lt;/span>
&lt;a href="#%ea%b8%b0%eb%b3%b8-%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 이름&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>정렬 필요 여부&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>적합한 사용 케이스&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>순차 검색 (Sequential Search)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>불필요&lt;/td>
&lt;td>• 가장 단순한 검색 방법&lt;br>• 처음부터 끝까지 순차적으로 검색&lt;br>• 구현이 매우 간단&lt;/td>
&lt;td>• 소규모 데이터셋&lt;br>• 정렬되지 않은 데이터&lt;br>• 일회성 검색&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이진 검색 (Binary Search)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>필수&lt;/td>
&lt;td>• 정렬된 데이터에서만 사용 가능&lt;br>• 중간값을 기준으로 범위를 좁혀가며 검색&lt;br>• 분할 정복 방식&lt;/td>
&lt;td>• 대규모 정렬된 데이터&lt;br>• 반복적인 검색 작업&lt;br>• 정적인 데이터셋&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>해시 검색 (Hash Search)&lt;/td>
&lt;td>O(1) 평균&lt;br>O(n) 최악&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>불필요&lt;/td>
&lt;td>• 해시 함수를 사용하여 직접 접근&lt;br>• 충돌 해결 방법 필요&lt;br>• 키-값 쌍으로 데이터 저장&lt;/td>
&lt;td>• 빈번한 검색 작업&lt;br>• 키-값 데이터&lt;br>• 캐싱 시스템&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보간 검색 (Interpolation Search)&lt;/td>
&lt;td>O(log log n) 평균&lt;br>O(n) 최악&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>필수&lt;/td>
&lt;td>• 이진 검색의 개선 버전&lt;br>• 데이터 분포를 고려한 검색&lt;br>• 균등 분포에서 효율적&lt;/td>
&lt;td>• 균등 분포된 데이터&lt;br>• 정렬된 숫자 데이터&lt;br>• 큰 데이터셋&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>그래프 검색 알고리즘&lt;span class="hx-absolute -hx-mt-20" id="그래프-검색-알고리즘">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>알고리즘 이름&lt;/th>
&lt;th>시간 복잡도&lt;/th>
&lt;th>공간 복잡도&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>적합한 사용 케이스&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>깊이 우선 검색 (DFS)&lt;/td>
&lt;td>O(V + E)&lt;/td>
&lt;td>O(V)&lt;/td>
&lt;td>• 한 경로를 끝까지 탐색&lt;br>• 스택/재귀 사용&lt;br>• 메모리 효율적&lt;/td>
&lt;td>• 경로 존재 확인&lt;br>• 위상 정렬&lt;br>• 연결 요소 찾기&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>너비 우선 검색 (BFS)&lt;/td>
&lt;td>O(V + E)&lt;/td>
&lt;td>O(V)&lt;/td>
&lt;td>• 레벨 단위 탐색&lt;br>• 큐 사용&lt;br>• 최단 경로 보장&lt;/td>
&lt;td>• 최단 경로&lt;br>• 네트워크 분석&lt;br>• 레벨 단위 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>[V: 정점 수, E: 간선 수]&lt;/p>
&lt;h3>최신 트렌드와 발전 방향&lt;span class="hx-absolute -hx-mt-20" id="최신-트렌드와-발전-방향">&lt;/span>
&lt;a href="#%ec%b5%9c%ec%8b%a0-%ed%8a%b8%eb%a0%8c%eb%93%9c%ec%99%80-%eb%b0%9c%ec%a0%84-%eb%b0%a9%ed%96%a5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>병렬 검색 알고리즘 개발&lt;/li>
&lt;li>분산 환경에서의 검색 최적화&lt;/li>
&lt;li>머신러닝을 활용한 검색 성능 개선&lt;/li>
&lt;li>빅데이터 환경에 적합한 검색 알고리즘 연구&lt;/li>
&lt;/ul>
&lt;h3>검색 알고리즘 선택 시 고려사항&lt;span class="hx-absolute -hx-mt-20" id="검색-알고리즘-선택-시-고려사항">&lt;/span>
&lt;a href="#%ea%b2%80%ec%83%89-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%84%a0%ed%83%9d-%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>데이터의 특성&lt;/p>
&lt;ul>
&lt;li>데이터의 크기&lt;/li>
&lt;li>데이터의 정렬 상태&lt;/li>
&lt;li>데이터의 변경 빈도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 요구사항&lt;/p>
&lt;ul>
&lt;li>검색 속도 요구사항&lt;/li>
&lt;li>메모리 사용량 제약&lt;/li>
&lt;li>구현의 복잡도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>응용 환경&lt;/p>
&lt;ul>
&lt;li>검색 빈도&lt;/li>
&lt;li>삽입/삭제 빈도&lt;/li>
&lt;li>동시성 요구사항&amp;mdash;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Big O 표기법 (Big O notation)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</link><pubDate>Sat, 26 Oct 2024 01:32:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</guid><description>
&lt;h2>Big O 표기법 (Big O notation)&lt;span class="hx-absolute -hx-mt-20" id="big-o-표기법-big-o-notation">&lt;/span>
&lt;a href="#big-o-%ed%91%9c%ea%b8%b0%eb%b2%95-big-o-notation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>알고리즘의 성능과 효율성을 수학적으로 표현하는 방법으로, 주로 알고리즘이 처리해야 할 데이터의 크기(n)가 늘어날 때, 실행 시간이나 메모리 사용량이 어떻게 증가하는지를 나타낸다.&lt;/p>
&lt;p>주요 특징:&lt;/p>
&lt;ol>
&lt;li>최악의 경우 시나리오를 나타낸다.&lt;/li>
&lt;li>상수와 계수를 무시한다.&lt;/li>
&lt;li>가장 빠르게 증가하는 항만 고려한다.&lt;/li>
&lt;/ol>
&lt;p>Big O 표기의 예시:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>O(1) - 상수 시간&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">get_first_element&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># 배열의 크기와 관계없이 항상 첫 번째 요소에 즉시 접근&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이 함수는 배열의 크기와 관계없이 항상 동일한 시간이 걸린다.&lt;br>
입력 크기가 증가해도 실행 시간은 변하지 않습니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(n) - 선형 시간&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">find_element&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">element&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 배열의 모든 요소를 한 번씩 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">element&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>배열의 크기(n)에 비례하여 실행 시간이 증가한다.&lt;br>
배열이 두 배로 커지면 실행 시간도 약 두 배가 된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(n²) - 이차 시간&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">bubble_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 외부 루프&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 내부 루프&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]:&lt;/span> &lt;span class="c1"># 두 요소 비교&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>중첩된 두 개의 반복문으로 인해, 배열 크기의 제곱에 비례하는 시간이 걸린다.&lt;br>
입력이 두 배가 되면 실행 시간은 약 네 배가 된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(log n) - 로그 시간&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">binary_search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># 검색 범위를 절반으로 줄임&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># 검색 범위를 절반으로 줄임&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>이진 검색은 매 단계마다 검색 범위를 절반으로 줄인다.&lt;br>
따라서 입력이 두 배가 되어도 실행 시간은 단 1 스텝만 증가한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>O(n log n) - 선형 로그 시간&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1"># 분할 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">merge_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">:])&lt;/span> &lt;span class="c1"># 분할 단계&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 병합 단계&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>병합 정렬과 같은 효율적인 정렬 알고리즘들의 시간 복잡도.&lt;br>
각 단계에서 배열을 분할(log n)하고 병합(n)하는 과정을 거친다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>시간 복잡도 비교를 통한 효율성:&lt;br>
O(1) &amp;lt; O(log n) &amp;lt; O(n) &amp;lt; O(n log n) &amp;lt; O(n²) &amp;lt; O(2ⁿ)&lt;/p>
&lt;p>하지만 데이터의 크기가 커질수록 알고리즘의 효율성 차이는 매우 극적으로 나타나게 된다.&lt;br>
예를 들어, n이 1,000,000일 때 O(n)은 백만 번의 연산이 필요하지만, O(n²)은 1조 번의 연산이 필요하게 된다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>환원 가능성 (Reducibility)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</link><pubDate>Thu, 24 Oct 2024 12:03:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</guid><description>
&lt;h2>환원 가능성 (Reducibility)&lt;span class="hx-absolute -hx-mt-20" id="환원-가능성-reducibility">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90-%ea%b0%80%eb%8a%a5%ec%84%b1-reducibility" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.&lt;br>
더 구체적으로, 문제 A를 문제 B로 환원한다는 것은 문제 A를 해결하기 위해 문제 B의 해결 방법을 사용할 수 있다는 의미이다.&lt;/p>
&lt;h3>환원의 목적&lt;span class="hx-absolute -hx-mt-20" id="환원의-목적">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90%ec%9d%98-%eb%aa%a9%ec%a0%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>문제의 난이도 비교: 환원을 통해 두 문제의 상대적 난이도를 비교할 수 있다.&lt;/li>
&lt;li>알고리즘 재사용: 이미 해결 방법을 알고 있는 문제로 환원함으로써 새로운 문제를 해결할 수 있다.&lt;/li>
&lt;li>복잡도 클래스 간의 관계 이해: 환원을 통해 다양한 복잡도 클래스 간의 관계를 파악할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>환원의 예시&lt;span class="hx-absolute -hx-mt-20" id="환원의-예시">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90%ec%9d%98-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&amp;lsquo;2로 나누어 떨어지는지 확인하는 문제&amp;rsquo;를 &amp;lsquo;짝수인지 확인하는 문제&amp;rsquo;로 환원&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_even&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_divisible_by_two&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">is_even&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>부분집합의 합 문제를 SAT 문제로 환원&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">subset_sum_to_sat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 부분집합의 합 문제를 SAT 문제로 환원하는 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 각 숫자에 대해 변수 생성 (선택 여부를 나타냄)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">variables&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s1">&amp;#39;x&lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># SAT 식 생성&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">clauses&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 합이 target이 되어야 한다는 제약 조건 추가&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 실제로는 이진수 덧셈을 위한 추가 절들이 필요&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">clauses&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">solve_subset_sum_using_sat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 환원을 통한 문제 해결 예시
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 1. 부분집합의 합 문제를 SAT 문제로 변환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sat_formula&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">subset_sum_to_sat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 2. SAT 문제 해결&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sat_solution&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">solve_sat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sat_formula&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 3. SAT 해답을 원래 문제의 해답으로 변환&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">sat_solution&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="kc">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span> &lt;span class="c1"># 해답이 없음&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># SAT 해답에서 선택된 숫자들 추출&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">selected&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sat_solution&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">selected&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">selected&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;h3>환원의 중요한 성질들&lt;span class="hx-absolute -hx-mt-20" id="환원의-중요한-성질들">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90%ec%9d%98-%ec%a4%91%ec%9a%94%ed%95%9c-%ec%84%b1%ec%a7%88%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>다항 시간 환원(Polynomial-time Reduction)&lt;br>
복잡도 이론에서 특히 중요한 것은 &amp;lsquo;다항 시간 환원&amp;rsquo;이다.&lt;br>
이는 한 문제를 다른 문제로 다항 시간 내에 변환할 수 있음을 의미한다.&lt;br>
예를 들어, 문제 A를 문제 B로 다항 시간에 환원할 수 있다면, 우리는 이를 A ≤p B로 표기한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>환원의 전이성&lt;br>
환원은 전이적이다.&lt;br>
A가 B로 환원 가능하고, B가 C로 환원 가능하다면, A는 C로 환원 가능하다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>환원의 중요성&lt;span class="hx-absolute -hx-mt-20" id="환원의-중요성">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90%ec%9d%98-%ec%a4%91%ec%9a%94%ec%84%b1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>NP-완전성 증명: 어떤 문제가 NP-완전(NP-Complete)임을 증명하기 위해 환원을 사용한다.&lt;/li>
&lt;li>문제 해결의 효율성: 어려운 문제를 이미 해결 방법을 알고 있는 문제로 환원함으로써 효율적으로 해결할 수 있다.&lt;/li>
&lt;li>복잡도 클래스 간의 관계 이해: P vs NP 문제와 같은 중요한 미해결 문제에 접근하는 데 도움을 준다.&lt;/li>
&lt;/ol>
&lt;h3>환원의 단계&lt;span class="hx-absolute -hx-mt-20" id="환원의-단계">&lt;/span>
&lt;a href="#%ed%99%98%ec%9b%90%ec%9d%98-%eb%8b%a8%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>입력 변환: 원래 문제의 입력을 새로운 문제의 입력으로 변환한다.&lt;/li>
&lt;li>문제 해결: 변환된 문제를 해결한다.&lt;/li>
&lt;li>결과 해석: 새로운 문제의 해답을 원래 문제의 해답으로 해석한다.&lt;/li>
&lt;/ol>
&lt;p>환원 가능성은 계산 복잡도 이론의 핵심 개념으로, 다양한 문제들 사이의 관계를 이해하고 새로운 문제를 해결하는 데 중요한 도구이다.&lt;br>
이를 통해 우리는 문제의 난이도를 비교하고, 효율적인 알고리즘을 개발할 수 있다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>튜링 기계 (Turing Machine)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</link><pubDate>Thu, 24 Oct 2024 10:07:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</guid><description>
&lt;h2>튜링 기계 (Turing Machine)&lt;span class="hx-absolute -hx-mt-20" id="튜링-기계-turing-machine">&lt;/span>
&lt;a href="#%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84-turing-machine" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.&lt;br>
튜링 기계는 무한한 길이의 테이프, 읽기/쓰기 헤드, 그리고 상태 제어 장치로 구성된다.&lt;/p>
&lt;p>튜링 기계는 다음과 같은 요소로 구성된다:&lt;/p>
&lt;ol>
&lt;li>무한한 길이의 테이프: 계산에 필요한 데이터를 저장한다.&lt;/li>
&lt;li>읽기/쓰기 헤드: 테이프의 심볼을 읽고 쓸 수 있다.&lt;/li>
&lt;li>상태 레지스터: 현재 기계의 상태를 저장한다.&lt;/li>
&lt;li>유한한 규칙 집합: 기계의 동작을 정의한다.&lt;/li>
&lt;/ol>
&lt;p>튜링 기계의 작동 원리:&lt;/p>
&lt;ol>
&lt;li>테이프는 셀로 나뉘어 있으며, 각 셀에는 유한한 알파벳의 심볼이 들어간다.&lt;/li>
&lt;li>헤드는 한 번에 하나의 셀을 읽고 쓸 수 있다.&lt;/li>
&lt;li>각 단계에서 기계는 현재 상태와 읽은 심볼에 따라 다음 동작을 결정한다.&lt;/li>
&lt;li>동작은 심볼 쓰기, 헤드 이동(왼쪽 또는 오른쪽), 상태 변경을 포함한다.&lt;/li>
&lt;/ol>
&lt;p>튜링 기계의 수학적 정의:&lt;br>
튜링 기계 M은 7-튜플 (Q, Γ, b, Σ, δ, q0, F)로 정의된다:&lt;/p>
&lt;ul>
&lt;li>Q: 유한한 상태 집합&lt;/li>
&lt;li>Γ: 유한한 테이프 알파벳&lt;/li>
&lt;li>b: 빈 심볼 (Γ의 원소)&lt;/li>
&lt;li>Σ: 입력 알파벳 (Γ의 부분집합)&lt;/li>
&lt;li>δ: 전이 함수&lt;/li>
&lt;li>q0: 초기 상태 (Q의 원소)&lt;/li>
&lt;li>F: 최종 상태 집합 (Q의 부분집합)&lt;/li>
&lt;/ul>
&lt;p>튜링 기계의 중요성:&lt;/p>
&lt;ol>
&lt;li>계산 가능성: 튜링 기계는 알고리즘으로 해결할 수 있는 모든 문제를 해결할 수 있다.&lt;/li>
&lt;li>보편성: 모든 컴퓨터 알고리즘은 튜링 기계로 시뮬레이션 가능하다.&lt;/li>
&lt;li>계산 복잡도 이론: 문제의 난이도를 분석하는 데 사용된다.&lt;/li>
&lt;/ol>
&lt;p>튜링 기계(Turing Machine)는 계산 이론의 기초를 이루는 중요한 개념이지만, 몇 가지 중요한 한계점을 가지고 있다:&lt;/p>
&lt;ol>
&lt;li>정지 문제(Halting Problem):&lt;br>
튜링 기계의 가장 유명한 한계점이다.&lt;br>
임의의 프로그램과 입력이 주어졌을 때, 그 프로그램이 종료될지 아니면 무한히 실행될지를 결정하는 알고리즘은 존재하지 않는다.&lt;/li>
&lt;li>비가산 무한대 문제:&lt;br>
튜링 기계는 가산 무한대(countably infinite)의 수만큼 존재하지만, 실수의 집합과 같은 비가산 무한대(uncountably infinite)의 문제는 해결할 수 없다.&lt;/li>
&lt;li>실제 구현의 한계:&lt;br>
튜링 기계는 무한한 테이프를 가정하지만, 실제 컴퓨터는 유한한 메모리를 가진다. 이는 이론과 실제 사이의 간극을 만든다.&lt;/li>
&lt;li>효율성 문제:&lt;br>
튜링 기계는 계산 가능성을 보여주는 데는 유용하지만, 실제 계산에는 너무 느리고 비효율적이다.&lt;/li>
&lt;li>창의적 의사결정의 한계:&lt;br>
튜링 완전(Turing-complete) 기계는 자연에서 관찰되는 창의적 의사결정을 완전히 시뮬레이션하는 데 한계가 있다.&lt;/li>
&lt;li>재귀적으로 열거 가능하지 않은 언어: 튜링 기계로는 재귀적으로 열거할 수 없는 언어들이 존재한다.&lt;/li>
&lt;/ol>
&lt;h3>튜링 기계 (Turing Machine)의 유형&lt;span class="hx-absolute -hx-mt-20" id="튜링-기계-turing-machine의-유형">&lt;/span>
&lt;a href="#%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84-turing-machine%ec%9d%98-%ec%9c%a0%ed%98%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>복잡도 클래스(Complexity Classes)에서 결정론적 튜링 기계(Deterministic Turing Machine, DTM)와 비결정론적 튜링 기계(Nondeterministic Turing Machine, NTM)는 계산 복잡도 이론의 핵심 개념이다.&lt;br>
이 두 모델은 문제 해결의 효율성과 계산 능력을 분석하는 데 중요한 역할을 한다.&lt;/p>
&lt;h4>결정론적 튜링 기계&lt;span class="hx-absolute -hx-mt-20" id="결정론적-튜링-기계">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95%eb%a1%a0%ec%a0%81-%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>결정론적 튜링 기계(Deterministic Turing Machine, DTM)은 표준적인 튜링 기계 모델로, 각 상태와 입력 심볼에 대해 하나의 유일한 다음 동작이 결정된다.&lt;br>
계산 과정이 선형적이며 예측 가능하며, 7-튜플 M = (Q, Σ, Γ, δ, q0, qaccept, qreject)로 정의된다.&lt;/p>
&lt;p>동작 방식:&lt;/p>
&lt;ul>
&lt;li>현재 상태와 테이프의 심볼에 따라 단 하나의 다음 동작이 결정된다.&lt;/li>
&lt;li>각 단계에서 기계는 현재 상태와 읽은 심볼에 따라 유일한 다음 상태로 전이한다.&lt;/li>
&lt;/ul>
&lt;p>계산 과정:&lt;/p>
&lt;ul>
&lt;li>선형적인 계산 순서를 따른다.&lt;/li>
&lt;li>입력이 주어지면 항상 동일한 계산 과정을 거쳐 동일한 결과를 산출한다.&lt;/li>
&lt;/ul>
&lt;p>복잡도 클래스:&lt;/p>
&lt;ul>
&lt;li>P (Polynomial Time) 클래스는 DTM으로 다항 시간 내에 해결 가능한 문제들의 집합이다.&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 결정론적 튜링 기계의 동작을 시뮬레이션하는 간단한 예시&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DeterministicTuringMachine&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">tape&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span> &lt;span class="c1"># 테이프&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1"># 헤드 위치&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;q0&amp;#39;&lt;/span> &lt;span class="c1"># 초기 상태&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">step&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_symbol&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 상태와 심볼에 따라 다음 행동이 유일하게 결정됨&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;q0&amp;#39;&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">current_symbol&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;q1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;R&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 다음 상태, 쓸 심볼, 헤드 이동 방향&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># … 다른 상태 전이 규칙들 …&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>비결정론적 튜링 기계&lt;span class="hx-absolute -hx-mt-20" id="비결정론적-튜링-기계">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b2%b0%ec%a0%95%eb%a1%a0%ec%a0%81-%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>비결정론적 튜링 기계(Nondeterministic Turing Machine, NTM)은 각 단계에서 여러 가능한 동작 중 하나를 선택할 수 있는 기계로, 계산 과정이 트리 구조를 형성한다. 병렬 계산을 모델링하는 데 유용하며, 6-튜플 M = (Q, Σ, ι, ⊔, A, δ)로 정의된다.&lt;/p>
&lt;p>동작 방식:&lt;/p>
&lt;ul>
&lt;li>현재 상태와 테이프의 심볼에 대해 여러 가능한 다음 동작이 존재할 수 있다.&lt;/li>
&lt;li>각 단계에서 기계는 여러 가능한 전이 중 하나를 &amp;lsquo;선택&amp;rsquo;할 수 있다.&lt;/li>
&lt;/ul>
&lt;p>계산 과정:&lt;/p>
&lt;ul>
&lt;li>계산 과정이 트리 구조를 형성한다.&lt;/li>
&lt;li>여러 가능한 계산 경로를 동시에 탐색하는 것으로 간주된다.&lt;/li>
&lt;/ul>
&lt;p>복잡도 클래스:&lt;/p>
&lt;ul>
&lt;li>NP (Nondeterministic Polynomial Time) 클래스는 NTM으로 다항 시간 내에 해결 가능한 문제들의 집합이다.&lt;/li>
&lt;/ul>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 비결정론적 튜링 기계의 개념을 나타내는 의사 코드&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">NonDeterministicTuringMachine&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">tape&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;q0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">step&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_symbol&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 현재 상태와 심볼에 대해 여러 가능한 다음 행동이 존재&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">state&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;q0&amp;#39;&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">current_symbol&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;q1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;R&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="c1"># 가능한 선택 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;q2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;L&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="c1"># 가능한 선택 2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;q3&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;R&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 가능한 선택 3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h4>결정론적 튜링 기계와 비결정론적 튜링 기계 비교&lt;span class="hx-absolute -hx-mt-20" id="결정론적-튜링-기계와-비결정론적-튜링-기계-비교">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95%eb%a1%a0%ec%a0%81-%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84%ec%99%80-%eb%b9%84%ea%b2%b0%ec%a0%95%eb%a1%a0%ec%a0%81-%ed%8a%9c%eb%a7%81-%ea%b8%b0%ea%b3%84-%eb%b9%84%ea%b5%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>
&lt;img src="../File_Difference_between_deterministic_and_Nondeterministic.svg" alt="A comparison of deterministic and nondeterministic computation" loading="lazy" />&lt;br>
_Source: &lt;a href="https://en.wikipedia.org/wiki/Complexity_class" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Complexity_class&lt;/a> _&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>결정론적 튜링 기계 (DTM)&lt;/th>
&lt;th>비결정론적 튜링 기계 (NTM)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>계산 경로&lt;/td>
&lt;td>단일 경로&lt;/td>
&lt;td>다중 경로&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다음 상태 결정&lt;/td>
&lt;td>현재 상태와 입력 심볼에 의해 유일하게 결정&lt;/td>
&lt;td>여러 가능한 다음 상태 중 선택 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>계산 과정&lt;/td>
&lt;td>선형적이고 예측 가능&lt;/td>
&lt;td>트리 구조 형성, 병렬 탐색 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>시간 복잡도&lt;/td>
&lt;td>일반적으로 NTM보다 높음&lt;/td>
&lt;td>특정 문제에서 DTM보다 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 및 분석&lt;/td>
&lt;td>상대적으로 쉬움&lt;/td>
&lt;td>상대적으로 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실제 구현&lt;/td>
&lt;td>현실적으로 구현 가능&lt;/td>
&lt;td>이론적 모델, 실제 구현 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>계산 능력&lt;/td>
&lt;td>NTM과 동등한 계산 능력&lt;/td>
&lt;td>DTM과 동등한 계산 능력&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 응용&lt;/td>
&lt;td>일반적인 알고리즘 설계 및 분석&lt;/td>
&lt;td>NP 문제 해결, 복잡도 이론 연구&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>두 모델이 계산 능력 면에서는 동등하다고 하지만, NTM으로 해결할 수 있는 모든 문제는 DTM으로도 해결할 수 있지만, NTM이 특정 문제에서 더 효율적일 수 있다.&lt;/p>
&lt;h4>기타&lt;span class="hx-absolute -hx-mt-20" id="기타">&lt;/span>
&lt;a href="#%ea%b8%b0%ed%83%80" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>튜링 기계 유형&lt;/th>
&lt;th>개념&lt;/th>
&lt;th>주요 특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>다중 테이프 튜링 기계 (Multi-tape Turing Machine)&lt;/td>
&lt;td>여러 개의 테이프를 가진 튜링 기계&lt;/td>
&lt;td>- 각 테이프에 독립적인 읽기/쓰기 헤드 존재&lt;br>- 모든 테이프를 동시에 조작 가능&lt;/td>
&lt;td>- 복잡한 알고리즘을 더 효율적으로 구현&lt;br>- 병렬 처리 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>양자 튜링 기계 (Quantum Turing Machine)&lt;/td>
&lt;td>양자 컴퓨팅의 원리를 적용한 튜링 기계&lt;/td>
&lt;td>- 양자 중첩과 얽힘을 활용&lt;br>- 확률적 계산 수행&lt;/td>
&lt;td>- 특정 문제에 대해 고전적 튜링 기계보다 효율적&lt;br>- 양자 알고리즘 모델링에 적합&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다중 헤드 튜링 기계 (Multi-head Turing Machine)&lt;/td>
&lt;td>하나의 테이프에 여러 개의 읽기/쓰기 헤드를 가진 기계&lt;/td>
&lt;td>- 각 헤드가 독립적으로 동작&lt;br>- 동시에 여러 위치 접근 가능&lt;/td>
&lt;td>- 병렬 처리 모델링에 유용&lt;br>- 특정 연산의 효율성 향상&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다중 트랙 튜링 기계 (Multi-track Turing Machine)&lt;/td>
&lt;td>하나의 테이프에 여러 개의 트랙이 있는 기계&lt;/td>
&lt;td>- 하나의 헤드가 모든 트랙을 동시에 읽고 씀&lt;br>- 복잡한 데이터 구조 표현 가능&lt;/td>
&lt;td>- 구조화된 데이터 처리에 효율적&lt;br>- 메모리 사용 최적화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>양방향 무한 테이프 튜링 기계 (Two-way Infinite Tape Turing Machine)&lt;/td>
&lt;td>테이프가 양쪽 방향으로 무한히 확장되는 기계&lt;/td>
&lt;td>- 헤드가 양방향으로 자유롭게 이동 가능&lt;br>- 무한한 메모리 공간 제공&lt;/td>
&lt;td>- 메모리 제약 없는 계산 모델링&lt;br>- 특정 알고리즘에서 더 직관적인 설계 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>다차원 테이프 튜링 기계&lt;/td>
&lt;td>테이프가 2차원 이상의 구조를 가지는 기계&lt;/td>
&lt;td>- 헤드가 다차원으로 이동 가능&lt;br>- 공간적 문제 해결에 적합&lt;/td>
&lt;td>- 다차원 데이터 처리에 효율적&lt;br>- 특정 공간 알고리즘 모델링에 유용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>복잡도 클래스(Complexity Classes)</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</link><pubDate>Thu, 24 Oct 2024 09:54:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</guid><description>
&lt;h2>복잡도 클래스(Complexity Classes)&lt;span class="hx-absolute -hx-mt-20" id="복잡도-클래스complexity-classes">&lt;/span>
&lt;a href="#%eb%b3%b5%ec%9e%a1%eb%8f%84-%ed%81%b4%eb%9e%98%ec%8a%a4complexity-classes" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>복잡도 클래스(Complexity Classes)는 계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.&lt;br>
이는 문제를 해결하는 데 필요한 자원(시간 또는 공간)의 양에 따라 문제들을 분류한다.&lt;/p>
&lt;p>
&lt;img src="../complexity-classes.png" alt="Complexity Classes" loading="lazy" />&lt;br>
_Source: &lt;a href="https://www.geeksforgeeks.org/types-of-complexity-classes-p-np-conp-np-hard-and-np-complete/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/types-of-complexity-classes-p-np-conp-np-hard-and-np-complete/&lt;/a> _&lt;/p>
&lt;h3>P (Polynomial Time)&lt;span class="hx-absolute -hx-mt-20" id="p-polynomial-time">&lt;/span>
&lt;a href="#p-polynomial-time" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>결정론적 튜링 기계(Deterministic Turing Machine, DTM)로 다항 시간 내에 해결 가능한 문제들의 집합이다.&lt;br>
이 문제는 단순히 배열을 한 번 순회하면 되므로, 입력 크기에 비례하는 시간이 소요된다.&lt;br>
효율적으로 해결 가능한 문제들이 포함되며 대부분의 실용적인 문제들이 여기에 속한다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_sorted&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> P 클래스의 대표적인 예시: 배열이 정렬되어 있는지 확인
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 시간 복잡도: O(n)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>NP (Nondeterministic Polynomial Time)&lt;span class="hx-absolute -hx-mt-20" id="np-nondeterministic-polynomial-time">&lt;/span>
&lt;a href="#np-nondeterministic-polynomial-time" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>비결정론적 튜링 기계(Nondeterministic Turing Machine, NTM)로 다항 시간 내에 해결 가능한 문제들의 집합이다.&lt;br>
해답(subset)이 주어진 경우 검증은 쉽지만, 해답을 찾는 것은 어려울 수 있다.&lt;br>
&lt;code>P ⊆ NP (P는 NP의 부분집합)&lt;/code> 이다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">verify_subset_sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">subset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> NP 클래스의 대표적인 예시: 부분집합의 합 검증
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 검증은 O(n) 시간에 가능
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">subset_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">subset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">subset_sum&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">target&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>NP-Complete&lt;span class="hx-absolute -hx-mt-20" id="np-complete">&lt;/span>
&lt;a href="#np-complete" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>NP에 속하면서 모든 NP 문제가 다항 시간 내에 환원 가능한 문제들의 집합으로, NP 문제 중 가장 어려운 문제들이다.&lt;br>
하나의 NP-Complete 문제를 다항 시간에 해결하면 모든 NP 문제가 해결 가능하다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">verify_hamilton_cycle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cycle&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> NP-완전 문제의 예시: 해밀턴 순환 검증
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> cycle: 그래프의 정점들을 방문하는 순서
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">graph&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 모든 정점을 정확히 한 번씩 방문하는지 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cycle&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cycle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 연결성 확인&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">graph&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">cycle&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]][&lt;/span>&lt;span class="n">cycle&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>NP-Hard&lt;span class="hx-absolute -hx-mt-20" id="np-hard">&lt;/span>
&lt;a href="#np-hard" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>모든 NP 문제가 다항 시간 내에 환원 가능한 문제들의 집합으로, NP-Complete보다 더 어려운 문제들을 포함할 수 있다.&lt;br>
NP에 속하지 않을 수도 있다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">traveling_salesman_distance&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> NP-난해 문제의 예시: 외판원 문제의 경로 길이 계산
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total_distance&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total_distance&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">graph&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]][&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total_distance&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">graph&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]][&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="c1"># 시작점으로 돌아오기&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">total_distance&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>PSPACE (Polynomial Space)&lt;span class="hx-absolute -hx-mt-20" id="pspace-polynomial-space">&lt;/span>
&lt;a href="#pspace-polynomial-space" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>다항 공간 내에서 해결 가능한 문제들의 집합으로, 일부 게임 관련 문제들이 여기에 속한다.&lt;br>
&lt;code>NP ⊆ PSPACE (NP는 PSPACE의 부분집합)&lt;/code>이다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">evaluate_quantified_boolean_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> PSPACE-완전 문제의 예시: 양자화된 불리언 식의 평가
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">evaluate_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">variables&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">variables&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">formula&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">quantifiers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;exists&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">evaluate_quantified_boolean_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">or&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">evaluate_quantified_boolean_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># universal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">evaluate_quantified_boolean_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">evaluate_quantified_boolean_formula&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">formula&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>EXP (Exponential Time)&lt;span class="hx-absolute -hx-mt-20" id="exp-exponential-time">&lt;/span>
&lt;a href="#exp-exponential-time" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>지수 시간 내에 해결 가능한 문제들의 집합으로 대부분의 실용적인 문제들에는 적합하지 않다.&lt;br>
&lt;code>PSPACE ⊆ EXP (PSPACE는 EXP의 부분집합)&lt;/code>이다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">solve_generalized_chess&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> EXP 클래스의 예시: n x n 체스판에서의 게임 트리 탐색
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">is_game_over&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">evaluate_position&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">moves&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">generate_all_possible_moves&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;-inf&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">move&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">moves&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">solve_generalized_chess&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make_move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">board&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">move&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">best_score&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">best_score&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>L (Logarithmic Space)&lt;span class="hx-absolute -hx-mt-20" id="l-logarithmic-space">&lt;/span>
&lt;a href="#l-logarithmic-space" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>로그 공간 내에서 해결 가능한 문제들의 집합으로, 매우 제한된 메모리로 해결 가능한 문제들이다.&lt;br>
P의 부분집합&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">undirected_path_exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> L 클래스의 예시: 무향 그래프에서 경로 존재 여부 확인
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> 로그 공간만을 사용 (재귀 호출 스택만 사용)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">visited&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="kc">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">set&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">next_vertex&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">graph&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">next_vertex&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">undirected_path_exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">graph&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">next_vertex&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>복잡도 클래스 간의 관계&lt;span class="hx-absolute -hx-mt-20" id="복잡도-클래스-간의-관계">&lt;/span>
&lt;a href="#%eb%b3%b5%ec%9e%a1%eb%8f%84-%ed%81%b4%eb%9e%98%ec%8a%a4-%ea%b0%84%ec%9d%98-%ea%b4%80%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>복잡도 클래스 간의 관계는 다음과 같다:&lt;br>
&lt;code>L ⊆ NL ⊆ P ⊆ NP ⊆ PSPACE ⊆ EXPTIME ⊆ NEXPTIME ⊆ EXPSPACE&lt;/code>&lt;/p>
&lt;p>여기서 주요 관계를 설명하면:&lt;/p>
&lt;ol>
&lt;li>P ⊆ NP: 모든 다항 시간 해결 가능한 문제는 NP에 속한다.&lt;/li>
&lt;li>NP ⊆ PSPACE: NP의 모든 문제는 다항 공간 내에서 해결 가능하다.&lt;/li>
&lt;li>PSPACE ⊆ EXP: 다항 공간에서 해결 가능한 모든 문제는 지수 시간 내에 해결 가능하다.&lt;/li>
&lt;/ol>
&lt;p>주요 특징:&lt;/p>
&lt;ul>
&lt;li>P와 NP의 관계는 컴퓨터 과학의 가장 중요한 미해결 문제 중 하나이다.&lt;br>
P = NP인지 여부는 아직 밝혀지지 않았다.&lt;/li>
&lt;li>NP-complete 문제들은 NP의 가장 어려운 문제들로, 만약 하나의 NP-complete 문제가 P에 속한다면 P = NP가 된다.&lt;/li>
&lt;li>NP-hard 문제들은 NP의 모든 문제보다 어렵거나 같은 난이도를 가지며, NP에 속하지 않을 수도 있다.&lt;br>
이러한 복잡도 클래스 간의 관계는 문제의 난이도를 이해하고 효율적인 알고리즘을 설계하는 데 중요한 역할을 한다.&lt;/li>
&lt;/ul>
&lt;h3>P Vs NP 문제&lt;span class="hx-absolute -hx-mt-20" id="p-vs-np-문제">&lt;/span>
&lt;a href="#p-vs-np-%eb%ac%b8%ec%a0%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>P와 NP의 관계에 대한 미해결 문제로, 컴퓨터 과학의 가장 중요한 미해결 문제 중 하나이다.&lt;/p>
&lt;p>&lt;strong>핵심 질문:&lt;/strong> P = NP인가? 즉, 모든 NP 문제가 다항 시간 내에 해결 가능한가?&lt;br>
&lt;strong>가능한 결과:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>P = NP: 모든 NP 문제가 다항 시간 내에 해결 가능함&lt;/li>
&lt;li>P ≠ NP: NP 문제 중 다항 시간 내에 해결 불가능한 문제가 존재함&lt;/li>
&lt;li>증명 불가능: 현재의 수학적 체계로는 이 문제를 해결할 수 없음&lt;br>
대부분의 컴퓨터 과학자들은 P ≠ NP일 것으로 예상하고 있다.&lt;/li>
&lt;/ol>
&lt;h3>NP-완전 (NP-Complete)과 NP-난해 (NP-Hard)&lt;span class="hx-absolute -hx-mt-20" id="np-완전-np-complete과-np-난해-np-hard">&lt;/span>
&lt;a href="#np-%ec%99%84%ec%a0%84-np-complete%ea%b3%bc-np-%eb%82%9c%ed%95%b4-np-hard" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>NP-완전:&lt;/strong> NP에 속하면서 모든 NP 문제가 다항 시간 내에 환원(reduction) 가능한 문제들이다.&lt;/li>
&lt;li>&lt;strong>NP-난해:&lt;/strong> 모든 NP 문제가 다항 시간 내에 환원 가능한 문제들로, NP에 속하지 않을 수도 있다.&lt;br>
NP-완전 문제가 다항 시간 내에 해결 가능하다면 P = NP가 증명된다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item></channel></rss>