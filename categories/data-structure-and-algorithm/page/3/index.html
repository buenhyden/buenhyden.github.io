<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structure and Algorithm | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/data-structure-and-algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/data-structure-and-algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/data-structure-and-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/data-structure-and-algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data Structure and Algorithm"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data Structure and Algorithm"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Data Structure and Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>정렬 알고리즘 (Sorting Algorithms)</h2></header><div class=entry-content><p>정렬 알고리즘 (Sorting Algorithms) 정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.
효율적인 정렬은 데이터 처리의 기본이 되며, 검색이나 데이터 분석의 성능을 크게 향상시킬 수 있다.
다양한 종류의 정렬 알고리즘이 있으며, 각각 고유한 특징과 장단점을 가지고 있다.
특징 데이터를 정해진 순서(주로 오름차순이나 내림차순)로 재배열한다. 알고리즘의 효율성은 주로 시간 복잡도와 공간 복잡도로 평가된다. 안정 정렬과 불안정 정렬로 구분될 수 있다. 데이터의 크기와 특성에 따라 적합한 알고리즘이 달라질 수 있다. 주요 종류 버블 정렬 (Bubble Sort) 특징: 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환한다. 작동 방식:
1. 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환
2. 이 과정을 배열이 정렬될 때까지 반복
3. 각 패스마다 가장 큰 원소가 마지막 위치로 이동 장점: 구현이 간단하고 이해하기 쉽다. 단점: 대규모 데이터셋에 비효율적이며, 시간 복잡도가 O(n²)이다. 선택 정렬 (Selection Sort) 특징: 가장 작은(또는 큰) 원소를 선택하여 정렬된 부분의 끝에 배치한다. 작동 방식:
1. 현재 위치에 들어갈 값을 찾기 위해 전체 스캔
2. 가장 작은 값을 현재 위치로 이동
3. 이를 반복하여 전체 배열 정렬 장점: 구현이 간단하고 메모리 사용이 적다. 단점: 시간 복잡도가 O(n²)로 대규모 데이터에 비효율적입니다. 삽입 정렬 (Insertion Sort) 특징: 정렬되지 않은 부분에서 원소를 하나씩 꺼내 정렬된 부분의 적절한 위치에 삽입한다. 작동 방식: 정렬되지 않은 부분에서 원소를 하나씩 가져와서 정렬된 부분의 적절한 위치에 삽입 전체가 정렬될 때까지 반복 장점: 작은 데이터셋이나 거의 정렬된 데이터에 효율적이다. 단점: 큰 데이터셋에서는 비효율적이며, 최악의 경우 O(n²)의 시간 복잡도를 가진다. 퀵 정렬 (Quick Sort) 특징: 분할 정복 방법을 사용하며, 피벗을 기준으로 데이터를 분할하고 재귀적으로 정렬한다. 작동 방식: 피벗을 선택하여 배열을 분할 피벗보다 작은 값과 큰 값으로 분류 재귀적으로 부분 배열들을 정렬 장점: 평균적으로 매우 빠르며, 시간 복잡도가 O(n log n)이다. 단점: 최악의 경우 O(n²)의 시간 복잡도를 가지며, 불안정 정렬이다. 병합 정렬 (Merge Sort) 특징: 분할 정복 방법을 사용하여 리스트를 작은 부분으로 나누고 정렬 후 병합한다. 작동 방식: 배열을 반으로 나눔 각 부분을 재귀적으로 정렬 정렬된 부분들을 병합 장점: 안정적이며 항상 O(n log n)의 시간 복잡도를 보장한다. 단점: 추가적인 메모리 공간이 필요하다. 힙 정렬 (Heap Sort) 특징: 힙 자료구조를 사용하여 정렬한다. 장점: 시간 복잡도가 O(n log n)이며, 추가 메모리를 거의 사용하지 않는다. 단점: 불안정 정렬이며, 캐시 효율성이 떨어질 수 있다. 최신 트렌드와 발전 방향 병렬 정렬 알고리즘 개발 하이브리드 정렬 알고리즘 GPU를 활용한 정렬 분산 환경에서의 정렬 최적화 선택 기준 실제 활용 사례와 선택 기준:
...</p></div><footer class=entry-footer><span title='2024-11-02 01:26:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정렬 알고리즘 (Sorting Algorithms)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/sorting-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Approaches to algorithm design</h2></header><div class=entry-content><p>Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.
Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법은 문제 해결을 위한 전략적인 사고 과정을 의미한다.
이는 알고리즘 설계 기법과는 구별되는 개념으로, 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞춘다.
...</p></div><footer class=entry-footer><span title='2024-11-01 07:30:00 +0000 UTC'>November 1, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;951 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approaches to algorithm design" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>검색 알고리즘 (Searching Algorithms)</h2></header><div class=entry-content><p>검색 알고리즘 (Searching Algorithms) 데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 방법을 정의하는 알고리즘.
데이터의 정렬 상태, 크기, 구조 등에 따라 적합한 알고리즘이 달라진다.
장점:
데이터 검색 속도 향상 대규모 데이터셋 처리 가능 단점:
일부 알고리즘은 정렬된 데이터 필요 구현 복잡도 증가 가능 일반적인 특징 효율성: 대부분의 검색 알고리즘은 효율적인 데이터 검색을 목표로 합니다. 정확성: 검색 결과는 항상 정확해야 합니다. 적응성: 다양한 데이터 구조와 크기에 적용할 수 있어야 합니다. 확장성: 데이터셋의 크기가 증가해도 성능이 크게 저하되지 않아야 합니다. 주요 종류 기본 검색 알고리즘 알고리즘 이름 시간 복잡도 공간 복잡도 정렬 필요 여부 특징 적합한 사용 케이스 순차 검색 (Sequential Search) O(n) O(1) 불필요 • 가장 단순한 검색 방법
• 처음부터 끝까지 순차적으로 검색
• 구현이 매우 간단 • 소규모 데이터셋
• 정렬되지 않은 데이터
• 일회성 검색 이진 검색 (Binary Search) O(log n) O(1) 필수 • 정렬된 데이터에서만 사용 가능
• 중간값을 기준으로 범위를 좁혀가며 검색
• 분할 정복 방식 • 대규모 정렬된 데이터
• 반복적인 검색 작업
• 정적인 데이터셋 해시 검색 (Hash Search) O(1) 평균
O(n) 최악 O(n) 불필요 • 해시 함수를 사용하여 직접 접근
• 충돌 해결 방법 필요
• 키-값 쌍으로 데이터 저장 • 빈번한 검색 작업
• 키-값 데이터
• 캐싱 시스템 보간 검색 (Interpolation Search) O(log log n) 평균
O(n) 최악 O(1) 필수 • 이진 검색의 개선 버전
• 데이터 분포를 고려한 검색
• 균등 분포에서 효율적 • 균등 분포된 데이터
• 정렬된 숫자 데이터
• 큰 데이터셋 그래프 검색 알고리즘 알고리즘 이름 시간 복잡도 공간 복잡도 특징 적합한 사용 케이스 깊이 우선 검색 (DFS) O(V + E) O(V) • 한 경로를 끝까지 탐색
• 스택/재귀 사용
• 메모리 효율적 • 경로 존재 확인
• 위상 정렬
• 연결 요소 찾기 너비 우선 검색 (BFS) O(V + E) O(V) • 레벨 단위 탐색
• 큐 사용
• 최단 경로 보장 • 최단 경로
• 네트워크 분석
• 레벨 단위 처리 [V: 정점 수, E: 간선 수]
...</p></div><footer class=entry-footer><span title='2024-10-30 01:27:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 검색 알고리즘 (Searching Algorithms)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/searching-algorithms/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Big O 표기법 (Big O notation)</h2></header><div class=entry-content><p>Big O 표기법 (Big O notation) 알고리즘의 성능과 효율성을 수학적으로 표현하는 방법으로, 주로 알고리즘이 처리해야 할 데이터의 크기(n)가 늘어날 때, 실행 시간이나 메모리 사용량이 어떻게 증가하는지를 나타낸다.
주요 특징:
최악의 경우 시나리오를 나타낸다. 상수와 계수를 무시한다. 가장 빠르게 증가하는 항만 고려한다. Big O 표기의 예시:
O(1) - 상수 시간
1 2 def get_first_element(arr): return arr[0] # 배열의 크기와 관계없이 항상 첫 번째 요소에 즉시 접근 이 함수는 배열의 크기와 관계없이 항상 동일한 시간이 걸린다.
입력 크기가 증가해도 실행 시간은 변하지 않습니다.
...</p></div><footer class=entry-footer><span title='2024-10-26 01:32:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Big O 표기법 (Big O notation)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>환원 가능성 (Reducibility)</h2></header><div class=entry-content><p>환원 가능성 (Reducibility) 환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.
더 구체적으로, 문제 A를 문제 B로 환원한다는 것은 문제 A를 해결하기 위해 문제 B의 해결 방법을 사용할 수 있다는 의미이다.
환원의 목적 문제의 난이도 비교: 환원을 통해 두 문제의 상대적 난이도를 비교할 수 있다. 알고리즘 재사용: 이미 해결 방법을 알고 있는 문제로 환원함으로써 새로운 문제를 해결할 수 있다. 복잡도 클래스 간의 관계 이해: 환원을 통해 다양한 복잡도 클래스 간의 관계를 파악할 수 있다. 환원의 예시 ‘2로 나누어 떨어지는지 확인하는 문제’를 ‘짝수인지 확인하는 문제’로 환원
...</p></div><footer class=entry-footer><span title='2024-10-24 12:03:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 환원 가능성 (Reducibility)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/data-structure-and-algorithm/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/data-structure-and-algorithm/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>