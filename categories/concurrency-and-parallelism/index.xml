<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Concurrency and Parallelism on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/concurrency-and-parallelism/</link>
    <description>Recent content in Concurrency and Parallelism on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.150.0</generator>
    <language>en</language>
    <lastBuildDate>Mon, 04 Aug 2025 03:58:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/concurrency-and-parallelism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pessimistic vs. Optimistic Locking</title>
      <link>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-strategy/pessimistic-vs-optimistic-locking/</link>
      <pubDate>Mon, 04 Aug 2025 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-strategy/pessimistic-vs-optimistic-locking/</guid>
      <description>Pessimistic과 Optimistic Locking은 데이터 무결성 보장을 위한 두 가지 대표 동시성 제어 전략이다. 전자는 충돌을 사전에 차단하고, 후자는 충돌 발생 시 검증한다. 충돌 빈도, 시스템 환경, 성능 요구에 따라 적절히 선택해야 한다.</description>
    </item>
    <item>
      <title>Lock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/lock/</link>
      <pubDate>Mon, 04 Aug 2025 03:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/lock/</guid>
      <description>Lock은 멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하여 상호 배제(Mutual Exclusion)를 보장하는 동기화 수단이다. 임계 구역 보호를 통해 원자성을 제공하며, 경쟁 조건(Race Condition)을 방지한다. Spin Lock, Mutex, Reentrant Lock 등 다양한 유형이 존재하며, 선택에 따라 성능과 안정성에 영향을 미친다.</description>
    </item>
    <item>
      <title>Concurrency Problems</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/</link>
      <pubDate>Wed, 21 May 2025 05:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/</guid>
      <description>Deadlock, Livelock, Race Condition, Starvation은 동시성 환경에서 발생하는 대표적인 병목 현상이다. 데드락은 자원 상호 점유로 인한 정지, 라이브락은 지속된 상태 변화에도 진전 없음, 레이스 컨디션은 타이밍 의존으로 인한 예측 불가, 기아 상태는 낮은 우선순위로 인한 무한 대기를 초래한다.</description>
    </item>
    <item>
      <title>Livelock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/livelock/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/livelock/</guid>
      <description>라이브락(Livelock)은 둘 이상의 스레드나 프로세스가 서로 상태 변화에 반응해 계속 동작하지만, 실제 작업은 전혀 진전되지 않는 동시성 문제. 데드락과 달리 블로킹 없이 실행되나 결과는 없음. 재시도 제한, 랜덤 백오프 등이 해결책.</description>
    </item>
    <item>
      <title>Race Condition</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/race-condition/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/race-condition/</guid>
      <description>**Race Condition(경쟁 상태)**은 두 개 이상의 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 실행 순서나 타이밍에 따라 결과가 달라지는 동시성 문제. 이는 동기화 부족으로 인해 발생하며, 데이터 불일치, 보안 취약성, 시스템 오류를 유발할 수 있다. 락, 세마포어, 동기화 블록 등으로 예방할 수 있다.</description>
    </item>
    <item>
      <title>Starvation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/starvation/</link>
      <pubDate>Tue, 20 May 2025 14:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/starvation/</guid>
      <description>Starvation은 동시성 시스템에서 특정 프로세스나 스레드가 자원을 지속적으로 할당받지 못해 실행되지 않는 상태이다. 주로 우선순위 스케줄링, 자원 경합 등에서 발생하며 시스템의 공정성을 해친다. 에이징, 공정 락, 라운드 로빈 등으로 방지할 수 있다.</description>
    </item>
    <item>
      <title>Deadlock</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/deadlock/</link>
      <pubDate>Tue, 20 May 2025 14:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/deadlock/</guid>
      <description>Deadlock(교착상태) 은 둘 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 현상으로, 시스템 전체 성능과 안정성에 큰 영향을 미치는 주요 동시성 문제다. 상호 배제, 점유와 대기, 비선점, 순환 대기라는 네 가지 필요조건이 동시에 성립할 때 발생하며, 시스템 성능 저하와 응답 불가 상태를 초래한다.</description>
    </item>
    <item>
      <title>Mutual Exclusion</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/mutual-exclusion/</link>
      <pubDate>Tue, 20 May 2025 14:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-synchronization/mutual-exclusion/</guid>
      <description>**상호 배제(Mutual Exclusion)**는 여러 스레드나 프로세스가 공유 자원에 동시에 접근하지 못하도록 제어하여 데이터 일관성과 시스템 안정성을 보장하는 동시성 제어 기법이다. **임계 구역(Critical Section)**에 한 번에 하나의 실행 단위만 진입하도록 제한하며, **경쟁 상태(Race Condition)**를 방지한다. 구현에는 락(Lock), 세마포어(Semaphore), 뮤텍스(Mutex), 모니터(Monitor) 등이 사용되며, 분산 환경과 실시간 시스템에서도 필수적으로 활용된다.</description>
    </item>
  </channel>
</rss>
