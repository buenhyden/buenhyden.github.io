<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-pipeline-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/use-cases/industry-patterns/msa-pattern-comparison/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Polling publisher</h2></header><div class=entry-content><p>Polling Publisher Polling publisher는 마이크로서비스 아키텍처(MSA)에서 트랜잭셔널 메시징을 구현하는 방법 중 하나이다.
이 패턴은 Transactional Outbox 패턴과 함께 사용되어 데이터 일관성을 유지하면서 메시지를 안정적으로 발행하는 데 도움을 준다.
Polling publisher는 특히 소규모 시스템이나 간단한 구현이 필요한 경우에 적합한 방식이다. 그러나 대규모 시스템이나 실시간성이 중요한 경우에는 Transaction Log Tailing과 같은 다른 방식을 고려할 수 있다.
기본 개념 Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.
데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:46:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polling publisher" href=https://buenhyden.github.io/posts/software-engineering/application-development/asynchronous-processing/transactional-messaging/polling-publisher/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Transaction log tailing</h2></header><div class=entry-content><p>Transaction Log Tailing Transaction log tailing은 마이크로서비스 아키텍처(MSA)에서 Transactional Messaging을 구현하는 방법 중 하나이다.
이 패턴은 데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.
Transaction log tailing은 Polling publisher 방식과 비교될 수 있다. Polling은 주기적으로 데이터베이스를 조회하는 반면, log tailing은 실시간으로 변경사항을 감지한다. 이로 인해 log tailing이 더 빠르고 효율적이지만, 구현이 더 복잡할 수 있다.
이 패턴을 사용할 때는 메시지의 중복 발행 가능성을 고려해야 하며, 소비자 측에서 멱등성을 보장하는 방식으로 구현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Transaction log tailing" href=https://buenhyden.github.io/posts/software-engineering/application-development/asynchronous-processing/transactional-messaging/transaction-log-tailing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Transactional Outbox</h2></header><div class=entry-content><p>Transactional Outbox Transactional Outbox 패턴은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성과 메시지 전달의 신뢰성을 보장하기 위한 중요한 패턴이다.
Transactional Outbox 패턴은 데이터베이스 업데이트와 메시지 발행을 원자적으로 처리하기 위한 방법으로, 데이터베이스 트랜잭션과 메시지 발행 사이의 일관성을 보장하는 것을 목적으로 한다.
Transactional Outbox 패턴은 분산 시스템에서 데이터 일관성과 메시지 전달의 신뢰성을 높이는 효과적인 방법이다. 이 패턴을 통해 개발자는 복잡한 분산 트랜잭션 문제를 해결하고, 시스템의 안정성을 향상시킬 수 있다.
작동 방식 데이터베이스 업데이트와 함께 발행할 메시지를 ‘outbox’ 테이블에 저장한다. 이 두 작업은 하나의 데이터베이스 트랜잭션으로 처리된다. 별도의 프로세스(Message Relay)가 outbox 테이블에서 메시지를 읽어 실제 메시지 브로커로 전송한다. 주요 구성 요소 Outbox 테이블: 발행할 메시지를 임시로 저장하는 데이터베이스 테이블 Message Relay: outbox 테이블에서 메시지를 읽어 메시지 브로커로 전송하는 프로세스 구현 방법 a. Polling Publisher:
- 주기적으로 outbox 테이블을 폴링하여 미발행 메시지를 조회하고 발행한다.
- 구현이 간단하지만 실시간성이 떨어질 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Transactional Outbox" href=https://buenhyden.github.io/posts/software-engineering/application-development/asynchronous-processing/transactional-messaging/transactional-outbox/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Client-side UI composition</h2></header><div class=entry-content><p>Client-side UI Composition Client-side UI Composition은 마이크로서비스 아키텍처(MSA)에서 클라이언트(주로 브라우저)가 여러 마이크로서비스로부터 데이터를 직접 가져와 사용자 인터페이스(UI)를 구성하는 패턴이다.
이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.
이 패턴에서는 클라이언트(브라우저)가 여러 마이크로서비스로부터 데이터를 요청하고, 해당 데이터를 기반으로 UI를 렌더링한다. 각 마이크로서비스는 자신만의 UI 컴포넌트(HTML, CSS, JavaScript 등)를 제공하며, 클라이언트는 이러한 컴포넌트를 조합해 전체 화면을 구성한다.
예를 들어, 전자상거래 웹사이트의 상품 상세 페이지를 생각해보면:
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-side UI composition" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/use-cases/integration-patterns/ui-integration/client-side-ui-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-side page fragment composition</h2></header><div class=entry-content><p>Server-side Page Fragment Composition Server-side page fragment composition은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.
Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.
예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-side page fragment composition" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/use-cases/integration-patterns/ui-integration/server-side-page-fragment-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Key Authentication</h2></header><div class=entry-content><p>API Key Authentication API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.
API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.
API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Key Authentication" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/security/api-key-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.
CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.
CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.
CORS의 작동 원리 브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다. 서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다. 브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다. Origin의 정의
Origin은 다음 세 가지 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/security/cors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mutual TLS</h2></header><div class=entry-content><p>Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutual TLS" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/security/mutual-tls/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/msa-patterns/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>