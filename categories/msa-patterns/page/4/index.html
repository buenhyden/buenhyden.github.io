<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Distributed Tracing</h2></header><div class=entry-content><p>Distributed Tracing Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.
Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.
작동 원리 고유 식별자 할당: 각 요청에 고유한 Trace ID를 부여한다. 스팬 생성: 요청이 각 서비스를 통과할 때마다 ‘스팬’이라는 작업 단위가 생성된다. 계층 구조: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다. 메타데이터 수집: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다. Distributed Tracing의 중요성 복잡성 관리: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다. 성능 최적화: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다. 문제 해결: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다. 시스템 이해: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다. 주요 사용 사례 성능 병목 식별: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다. 오류 추적: 실패한 요청의 정확한 실패 지점과 원인을 파악한다. 서비스 의존성 분석: 서비스 간 통신 패턴과 의존성을 시각화한다. 최적화: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다. 구현 방법 계측: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다. 데이터 수집: 각 요청에 대한 스팬 데이터를 수집한다. 분석 및 시각화: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다. 주요 도구 Jaeger: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구. Zipkin: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다. Datadog APM: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다. New Relic: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다. 모범 사례 샘플링 전략 수립: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다. 컨텍스트 전파: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다. 표준화: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다. 시각화 도구 활용: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-03 01:59:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Distributed Tracing" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Health Check API</h2></header><div class=entry-content><p>Health Check API Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.
Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.
Health Check API의 중요성 고가용성 보장: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다. 문제 조기 발견: 서비스의 이상을 조기에 감지하여 대응할 수 있다. 시스템 안정성 향상: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다. Health Check API의 주요 기능 상태 확인: 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다. 종속성 검사: 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다. 리소스 모니터링: 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다. Health Check API의 중요성 장애 감지: 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다. 서비스 디스커버리 통합: 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다. 시스템 안정성 향상: 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다. Health Check API 구현 방법 엔드포인트 생성: 일반적으로 /health 또는 /ping 경로로 설정한다. 응답 코드: 정상 상태일 때 HTTP 200 OK를 반환한다. 상태 정보 포함: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다. Health Check 유형 Passive Health Checks: 실제 요청에 대한 응답을 모니터링한다. Active Health Checks: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다. Agent-based Health Checks: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다. Health Check API 구현 도구 Spring Boot Actuator: 자동으로 /actuator/health 엔드포인트를 제공한다. Kubernetes Probes: Liveness Probe: 애플리케이션이 살아있는지 확인 Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인 Startup Probe: 애플리케이션의 시작이 완료되었는지 확인 Health Check API 모범 사례 상세한 상태 정보: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다. 성능 고려: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다. 보안: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다. 로깅 및 모니터링: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다. 커스터마이징: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-03 01:59:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;367 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Health Check API" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log Aggregation</h2></header><div class=entry-content><p>Log Aggregation 마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.
Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.
Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 01:58:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;335 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log Aggregation" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dead Letter Queue</h2></header><div class=entry-content><p>Dead Letter Queue 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dead Letter Queue" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:10:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Competing Consumers</h2></header><div class=entry-content><p>Competing Consumers 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Competing Consumers" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Filter</h2></header><div class=entry-content><p>Message Filter 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Filter" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Router</h2></header><div class=entry-content><p>Message Router 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 12:09:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Router" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>3rd party registration</h2></header><div class=entry-content><p>3rd Party Registration 3rd Party Registration은 마이크로서비스 아키텍처에서 서비스 디스커버리를 위한 패턴 중 하나이다.
이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.
주요 특징:
서비스 인스턴스와 레지스트리 간의 결합도 감소 중앙 집중식 서비스 관리 다양한 언어와 프레임워크에 대한 일관된 등록 메커니즘 제공 3rd Party Registration 패턴은 마이크로서비스 아키텍처에서 서비스 디스커버리를 효과적으로 관리할 수 있는 방법이지만, 추가적인 복잡성을 감수해야 하므로, 시스템의 규모와 요구사항을 고려하여 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;263 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 3rd party registration" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Self registration</h2></header><div class=entry-content><p>Self registration 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-02 11:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Self registration" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/msa-patterns/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/msa-patterns/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>