<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Health Check API</h2></header><div class=entry-content><p>Health Check API Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.
Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.
Health Check API의 중요성 고가용성 보장: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다. 문제 조기 발견: 서비스의 이상을 조기에 감지하여 대응할 수 있다. 시스템 안정성 향상: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다. Health Check API의 주요 기능 상태 확인: 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다. 종속성 검사: 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다. 리소스 모니터링: 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다. Health Check API의 중요성 장애 감지: 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다. 서비스 디스커버리 통합: 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다. 시스템 안정성 향상: 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다. Health Check API 구현 방법 엔드포인트 생성: 일반적으로 /health 또는 /ping 경로로 설정한다. 응답 코드: 정상 상태일 때 HTTP 200 OK를 반환한다. 상태 정보 포함: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다. Health Check 유형 Passive Health Checks: 실제 요청에 대한 응답을 모니터링한다. Active Health Checks: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다. Agent-based Health Checks: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다. Health Check API 구현 도구 Spring Boot Actuator: 자동으로 /actuator/health 엔드포인트를 제공한다. Kubernetes Probes: Liveness Probe: 애플리케이션이 살아있는지 확인 Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인 Startup Probe: 애플리케이션의 시작이 완료되었는지 확인 Health Check API 모범 사례 상세한 상태 정보: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다. 성능 고려: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다. 보안: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다. 로깅 및 모니터링: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다. 커스터마이징: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 01:59:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Health Check API" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/health-check-api/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log Aggregation</h2></header><div class=entry-content><p>Log Aggregation 마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.
Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.
Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-11-16 01:58:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log Aggregation" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/log-aggregation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dead Letter Queue</h2></header><div class=entry-content><p>Dead Letter Queue Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.
Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.
Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.
데드 레터 큐에 메시지가 전달되는 일반적인 상황 존재하지 않는 큐로의 메시지 전송: 메시지가 존재하지 않는 큐로 전송될 때. 큐의 최대 길이 초과: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때. 메시지 크기 제한 초과: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때. 메시지 만료: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때. 메시지 거부: 다른 큐나 교환기에 의해 메시지가 거부되었을 때. 과도한 재시도 실패: 메시지가 여러 번 처리되었지만 계속해서 실패할 때. DLQ의 주요 특징 분리 저장: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다. 재처리 가능성: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다. 시스템 안정성 향상: 문제가 있는 메시지로 인한 시스템 장애를 방지한다. 모니터링 및 알림: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다. DLQ 구현 방법 큐 생성: 일반 큐와 별도로 DLQ를 생성한다. 재시도 정책 설정: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다. DLQ 연결: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다. DLQ 활용 전략 분석 및 디버깅: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다. 자동 재처리: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다. 알림 설정: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다. 로깅 및 모니터링: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다. 주의사항 보존 기간 설정: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다. 보안: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다. 성능 영향: DLQ 처리로 인한 시스템 부하를 고려해야 한다. 데드 레터 큐를 지원하는 주요 메시징 시스템 Amazon SQS: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다. Apache Kafka: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다. RabbitMQ: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다. 구현 예시 Node.js와 RabbitMQ를 사용
...</p></div><footer class=entry-footer><span title='2024-11-15 12:10:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dead Letter Queue" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/dead-letter-queue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker 메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.
메시지 브로커는 **생산자(Producer)**와 소비자(Consumer) 간의 메시지를 중개하여 전달하는 소프트웨어이다. 이를 통해 서로 다른 애플리케이션이나 서비스가 직접 통신하지 않고도 데이터를 교환할 수 있다. 메시지 브로커는 주로 비동기 통신과 데이터 전달 신뢰성을 보장하기 위해 사용된다.
메시지 브로커의 주요 역할 메시지 전달: 생산자가 생성한 메시지를 소비자에게 전달한다. 메시지 큐잉(Message Queuing): 메시지를 임시로 저장하여 소비자가 준비되었을 때 처리할 수 있도록 한다. 비동기 통신 지원: 실시간 응답을 기다리지 않고 독립적으로 작업을 처리할 수 있도록 지원한다. 라우팅(Routing): 특정 조건에 따라 메시지를 적절한 소비자에게 전달한다. 신뢰성 보장: 메시지가 손실되지 않도록 저장 및 재전송 기능을 제공한다. 확장성(Scalability): 시스템이 더 많은 메시지를 처리할 수 있도록 확장성을 제공한다. 메시지 브로커의 동작 방식 생산자(Producer): 메시지를 생성하고 브로커에 전달한다. 브로커(Broker): 메시지를 임시 저장하고, 특정 규칙에 따라 적절한 소비자에게 전달한다. 소비자(Consumer): 브로커에서 전달받은 메시지를 처리한다. 큐(Queue): 메시지가 순서대로 저장되는 대기열이다. 토픽(Topic): 여러 소비자가 동일한 메시지를 구독할 수 있는 주제 기반 구조이다. 메시지 브로커의 장점 서비스 간 느슨한 결합: 서비스들이 직접 통신하지 않고 브로커를 통해 데이터를 주고받아 독립성을 유지할 수 있다. 비동기 처리: 생산자와 소비자가 동시에 작동하지 않아도 작업이 진행될 수 있다. 확장성: 필요에 따라 브로커를 확장하여 더 많은 메시지를 처리할 수 있다. 신뢰성: 메시지가 손실되지 않도록 보장하며, 실패 시 재전송 기능을 제공한다. 유연한 통신 패턴 지원: 1:1(Point-to-Point), 1:N(Pub/Sub) 등 다양한 통신 방식을 지원한다. 메시지 브로커의 단점 운영 복잡성 증가: 추가적인 소프트웨어 구성 요소를 설치하고 관리해야 한다. 단일 장애 지점(Single Point of Failure): 브로커가 고장 나면 전체 시스템이 영향을 받을 수 있으므로 고가용성 설계가 필요하다. 병목현상 가능성: 처리량이 높은 경우 브로커가 병목현상이 될 수 있다. 주요 메시지 브로커 도구 RabbitMQ:
...</p></div><footer class=entry-footer><span title='2024-11-15 12:10:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/message-broker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Competing Consumers</h2></header><div class=entry-content><p>Competing Consumers Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.
Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.
작동 원리 메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다. 메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다. 경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다. 동작 방식 메시지 생산자(Producer): 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다. 메시지 큐(Message Queue): 게시된 메시지는 큐에 저장되어 대기한다. 메시지 소비자(Consumer): 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다. 이러한 구조를 통해 시스템은 작업 부하를 여러 소비자 인스턴스에 분산시켜 병목 현상을 방지하고, 동시 처리 능력을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Competing Consumers" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/competing-consumers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Filter</h2></header><div class=entry-content><p>Message Filter Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.
Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.
주요 특징 단일 입력 채널과 단일 출력 채널을 가진다. 정의된 기준에 따라 메시지를 평가한다. 기준을 충족하는 메시지만 출력 채널로 전달한다. 기준을 충족하지 않는 메시지는 폐기된다. 구현 방법 필터 조건 정의: 메시지를 평가할 기준을 설정한다. 메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다. 메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다. 구현 방식 메시지 필터는 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Filter" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/message-filter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Router</h2></header><div class=entry-content><p>Message Router Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.
Message Router는 MSA 환경에서 메시지 흐름을 효과적으로 관리하고 시스템의 유연성을 높이는 중요한 패턴이다. 적절히 구현하면 시스템의 확장성과 유지보수성을 크게 향상시킬 수 있다.
Message Router의 주요 특징 메시지 내용 기반 라우팅: 메시지의 페이로드나 헤더를 분석하여 라우팅 결정을 내린다. 동적 라우팅: 런타임에 라우팅 규칙을 변경할 수 있어 시스템의 유연성을 높인다. 다중 목적지 지원: 하나의 메시지를 여러 목적지로 라우팅할 수 있다. 메시지 변환: 필요에 따라 메시지 형식을 변환할 수 있다. Message Router의 종류 콘텐츠 기반 라우터: 메시지 내용을 분석하여 라우팅한다. 헤더 값 라우터: 메시지 헤더의 특정 값을 기준으로 라우팅한다. 수신자 목록 라우터: 미리 정의된 수신자 목록에 따라 메시지를 분배한다. 동적 라우터: 외부 조건이나 설정에 따라 라우팅 로직을 동적으로 변경한다. Message Router의 장점 유연성: 시스템 구성 요소 간의 결합도를 낮추어 유연성을 높인다. 확장성: 새로운 처리 로직이나 목적지를 쉽게 추가할 수 있다. 트래픽 관리: 메시지 흐름을 제어하여 시스템 부하를 관리할 수 있다. 비즈니스 로직 분리: 라우팅 로직을 중앙화하여 비즈니스 로직과 분리할 수 있다. 주의사항 복잡성 관리: 라우팅 규칙이 복잡해질수록 관리가 어려워질 수 있다. 성능 고려: 복잡한 라우팅 로직은 시스템 성능에 영향을 줄 수 있다. 오류 처리: 라우팅 실패 시의 오류 처리 전략이 필요하다. Message Router 구현 예시 Node.js를 사용한 Message Filter
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Router" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/message-router/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Idempotent Consumer</h2></header><div class=entry-content><p>Idempotent Consumer Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.
Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.
Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 11:43:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Idempotent Consumer" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/messaging/idempotent-consumer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain event</h2></header><div class=entry-content><p>Domain Event 도메인 이벤트(Domain Event)는 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하고 시스템 간 의존성을 줄이며 확장성을 높이는 데 중요한 개념이다.
도메인 이벤트는 주로 도메인 주도 설계(DDD) 의 개념에서 비롯되었으며, 비즈니스 로직과 시스템 상태 변화의 핵심을 나타낸다.
이를 통해 분산 시스템에서 데이터 일관성과 비즈니스 흐름을 효과적으로 관리할 수 있다.
도메인 이벤트는 도메인 내에서 발생한 중요한 상태 변화를 나타내는 객체이다.
이는 과거에 발생한 사건을 기술하며, 다른 모듈이나 시스템이 해당 이벤트를 구독하고 적절히 반응할 수 있도록 설계된다. 예를 들어, 전자상거래 시스템에서 “주문이 생성됨(Order Created)“이나 “결제가 완료됨(Payment Completed)” 같은 사건이 도메인 이벤트로 표현될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 11:08:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain event" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/maintaining-data-consistency/domain-event/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Saga Pattern</h2></header><div class=entry-content><p>Saga Pattern Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.
Saga Pattern은 여러 서비스에 걸친 데이터 일관성을 유지하기 위해 사용된다.
각 서비스의 로컬 트랜잭션을 순차적으로 실행하며, 실패 시 보상 트랜잭션을 통해 일관성을 유지한다.
주요 특징:
분산 환경에서의 트랜잭션 관리 순차적인 로컬 트랜잭션 실행 실패 시 보상 트랜잭션 실행 Saga Pattern의 구현 방식 Saga Pattern은 크게 두 가지 방식으로 구현할 수 있다:
Choreography-based Saga 각 서비스가 이벤트를 발행하고 구독하여 트랜잭션을 진행 중앙 조정자 없이 서비스 간 직접 통신
장점: 구현이 간단하고 이해하기 쉬움 서비스 간 결합도가 낮음
단점: 복잡한 워크플로우에서는 추적이 어려울 수 있음 순환 종속성 발생 가능성 https://microservices.io/patterns/data/saga.html
...</p></div><footer class=entry-footer><span title='2024-11-15 10:06:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Saga Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/maintaining-data-consistency/saga/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/msa-patterns/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/msa-patterns/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>