<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cache-Aside</h2></header><div class=entry-content><p>Cache-Aside Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.
Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.
이 패턴은 “Lazy Loading” 또는 “Look Aside” 패턴으로도 알려져 있다.
Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside
동작 방식 애플리케이션이 데이터를 요청한다. 캐시를 먼저 확인한다. 캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다. 캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다. 데이터베이스에서 가져온 데이터를 캐시에 저장한다. 데이터를 애플리케이션에 반환한다. 구현 시 고려사항 캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다. TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다. 캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다. 동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다. 장점 성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다. 데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다. 유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다. 장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다. 단점 초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다. 데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다. 추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다. 사용 예시 동시성 처리와 오류 복구를 포함한 버전
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;472 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache-Aside" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fail Fast</h2></header><div class=entry-content><p>Fail Fast Fail Fast는 MSA의 신뢰성을 높이는 중요한 패턴이다.
잠재적인 문제를 조기에 발견하고 빠르게 대응함으로써 전체 시스템의 안정성과 신뢰성을 향상시킬 수 있다.
Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙이다.
이는 잠재적인 오류를 조기에 감지하고 빠르게 대응하여 시스템의 안정성을 높이는 데 목적이 있다.
이 패턴을 효과적으로 적용하기 위해서는 철저한 모니터링과 로깅, 적절한 알림 시스템, 그리고 자동화된 복구 메커니즘이 함께 구현되어야 한다. 또한 각 서비스의 특성에 맞는 임계값과 정책을 설정하고, 지속적으로 이를 개선해 나가는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1033 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fail Fast" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Anti-Corruption Layer</h2></header><div class=entry-content><p>Anti-Corruption Layer Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.
ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.
주요 목적은 다음과 같다:
시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다. 도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다. 데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다. ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 10:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Anti-Corruption Layer" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Strangler Application</h2></header><div class=entry-content><p>Strangler Application Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.
Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.
Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 01:20:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;313 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strangler Application" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Application metrics</h2></header><div class=entry-content><p>Application Metrics 마이크로서비스 아키텍처(MSA) 패턴에서 Observability는 매우 중요한 개념이며, 그 중 Application Metrics는 핵심적인 요소이다.
Application Metrics는 애플리케이션의 성능과 동작을 이해하고 문제를 해결하는 데 필수적인 도구이다.
Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.
이는 개별 작업에 대한 통계를 수집하고, 이를 중앙 집중식 메트릭 서비스에 집계하여 보고 및 경고를 제공하는 패턴을 말한다.
Application Metrics는 MSA 환경에서 Observability를 달성하는 데 핵심적인 역할을 한다.
이를 통해 개발자와 운영팀은 복잡한 시스템을 더 잘 이해하고, 문제를 신속하게 해결하며, 시스템의 성능을 지속적으로 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-16 11:23:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Application metrics" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log deployments and changes</h2></header><div class=entry-content><p>Log Deployments and Changes “Log deployments and changes” 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.
패턴의 정의와 목적 “Log deployments and changes” 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.
이 패턴의 주요 목적은 다음과 같다:
시스템 변경사항과 문제 발생 간의 상관관계 파악 문제 해결 시간 단축 시스템 동작에 대한 이해도 향상 “Log deployments and changes” 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-16 11:23:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;331 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log deployments and changes" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Composition</h2></header><div class=entry-content><p>API Composition API Composition 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.
API Composition은 여러 마이크로서비스의 API 응답을 집계하여 단일 API 엔드포인트로 제공하는 패턴이다.
이를 통해 클라이언트는 복잡한 데이터 요구사항을 단일 요청으로 처리할 수 있다.
API Composition 패턴은 마이크로서비스 아키텍처에서 데이터 접근을 간소화하고 클라이언트 경험을 개선하는 강력한 도구이나 구현 시 성능과 복잡성을 고려해야 하며, 시스템의 요구사항에 따라 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-16 10:52:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;411 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Composition" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Audit Logging</h2></header><div class=entry-content><p>Audit Logging Audit Logging은 시스템 내에서 발생하는 중요한 이벤트와 변경사항을 기록하는 프로세스이다.
이는 사용자 활동, 시스템 변경, 데이터 접근 등을 포함하며, 시스템의 동작을 이해하고 문제를 해결하는 데 필수적이다.
Audit Logging은 MSA 환경에서 시스템의 투명성, 보안성, 그리고 문제 해결 능력을 크게 향상시킨다. 적절히 구현된 Audit Logging 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.
기본 구성 요소 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Audit Log 엔티티 예시 @Entity public class AuditLog { @Id @GeneratedValue private Long id; private String eventType; // 이벤트 유형 private String resourceType; // 리소스 유형 private String resourceId; // 리소스 식별자 private String userId; // 사용자 ID private String action; // 수행된 작업 private String oldValue; // 변경 전 값 private String newValue; // 변경 후 값 private LocalDateTime timestamp; // 발생 시간 private String ipAddress; // IP 주소 private String userAgent; // 사용자 에이전트 // getters, setters } Audit Logging의 중요성 규정 준수: PCI DSS, SOC 2 등의 산업 표준 및 규제 요구사항을 충족하는 데 필요하다. 보안 강화: 비정상적인 활동을 감지하고 보안 위협을 조사하는 데 도움이 된다. 문제 해결: 시스템 장애나 오류의 원인을 파악하는 데 유용하다. 사용자 행동 이해: 고객 지원, 시스템 개선을 위한 인사이트를 제공한다. Audit Logging 구현 방법 중앙 집중식 로깅 서비스: 모든 마이크로서비스의 로그를 한 곳에서 수집하고 저장한다. 표준화된 로그 형식: 일관된 형식을 사용하여 로그 분석을 용이하게 한다. 보안 및 접근 제어: 로그 데이터의 무결성과 기밀성을 보장한다. 확장성 고려: 대량의 로그 데이터를 효율적으로 처리할 수 있어야 한다. Audit Logging 구현 시 고려사항 과도한 로깅 vs 부족한 로깅: 적절한 수준의 로깅을 유지해야 한다. 성능 영향: 로깅이 시스템 성능에 미치는 영향을 최소화해야 한다. 데이터 보존 정책: 로그 데이터의 보존 기간과 방법을 정의해야 한다. 실시간 모니터링: 중요한 이벤트에 대한 실시간 알림 시스템을 구축해야 한다. Audit Logging 도구 및 기술 Elasticsearch, Logstash, Kibana (ELK) 스택: 로그 수집, 저장, 시각화에 널리 사용된다. Serilog:.NET 환경에서 구조화된 로깅을 위한 프레임워크이다. Kafka: 대규모 로그 스트림 처리에 적합한 메시징 시스템이다. Cloud-native 솔루션: AWS CloudWatch, Google Cloud Logging 등이 있다. Audit Logging을 효과적으로 구현하기 위한 방법 비즈니스 로직 내에 로깅 코드 추가: 장점: 구현이 비교적 간단하며, 특정 이벤트에 대한 상세한 로깅이 가능하다. 단점: 비즈니스 로직과 로깅 코드가 혼재되어 코드의 가독성과 유지보수성이 저하될 수 있다. AOP(Aspect-Oriented Programming) 활용: 장점: 비즈니스 로직과 로깅 기능을 분리하여 코드의 모듈성을 향상시킨다. 단점: 메서드명이나 인수에만 접근할 수 있어, 비즈니스 컨텍스트에 따른 상세한 로깅에는 한계가 있을 수 있다. 이벤트 소싱(Event Sourcing) 사용: 장점: 시스템의 상태 변화를 이벤트 형태로 저장하여, 모든 변경 이력을 추적할 수 있다. 단점: 쿼리 작업은 이벤트로 기록되지 않으므로, 이러한 작업에 대한 로깅은 별도의 방법을 통해 구현해야 한다. 모범 사례 상관 관계 ID 사용: 마이크로서비스 간 요청 추적을 위해 고유 ID를 사용한다. 컨텍스트 정보 포함: 사용자 ID, 서비스 이름, 요청 ID 등을 로그에 포함한다. 민감한 정보 보호: 개인정보나 보안 관련 데이터는 마스킹 처리한다. 로그 레벨 구분: 중요도에 따라 로그 레벨을 적절히 설정한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 02:13:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;477 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Audit Logging" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Exception Tracking</h2></header><div class=entry-content><p>Exception Tracking Exception Tracking은 분산 시스템 전반에 걸쳐 발생하는 예외를 중앙에서 수집, 집계, 분석하는 패턴이다.
이 패턴은 복잡한 마이크로서비스 환경에서 오류를 효과적으로 모니터링하고 디버깅하는 데 필수적이다.
Exception Tracking은 MSA 환경에서 시스템의 안정성을 유지하고 문제를 신속하게 해결하는 데 필수적인 도구이다.
이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고 사용자 경험을 개선할 수 있다.
주요 구성 요소 중앙 집중식 예외 로거: 여러 마이크로서비스에서 발생하는 예외 데이터를 수집하고 저장하는 전용 서비스나 도구이다. 예외 처리 미들웨어: 각 마이크로서비스에 구현되어 예외를 캐치하고 중앙 로거로 전달하는 컴포넌트이다. 상관 관계 ID: 여러 서비스에 걸친 요청 흐름과 관련 예외를 추적하는 데 사용되는 고유 식별자이다. 알림 및 모니터링: 중요한 문제에 대해 개발 및 운영 팀에 실시간으로 알리는 통합 모니터링 도구이다. 대시보드: 예외의 빈도, 심각도, 잠재적 영향 등에 대한 인사이트와 분석을 제공하는 사용자 인터페이스이다. Exception Tracking의 중요성 복잡성 관리: 수많은 서비스로 구성된 시스템에서 오류의 흐름을 파악할 수 있다. 성능 최적화: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다. 신속한 문제 해결: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다. 시스템 이해 향상: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다. 구현 방법 중앙 집중식 로깅 서비스 구축: ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 사용하여 모든 마이크로서비스의 로그를 한 곳에서 수집하고 분석한다. 고유 요청 ID 생성: 각 요청에 고유한 ID를 할당하여 여러 서비스에 걸친 예외 추적을 가능하게 한다. 표준화된 예외 형식 사용: 일관된 형식을 사용하여 예외 데이터를 수집하고 분석한다. 실시간 알림 설정: 중요한 예외 발생 시 개발팀에 즉시 알림을 보내도록 구성한다. Feign Error Decoder 활용: Spring Cloud Openfeign을 사용하는 경우, Feign Error Decoder를 구현하여 마이크로서비스 간 통신 중 발생하는 예외를 효과적으로 처리한다. 모범 사례 예외 분류 및 우선순위 지정: 예외의 심각도와 영향도에 따라 분류하고 우선순위를 지정한다. 컨텍스트 정보 포함: 예외 로그에 사용자 정보, 요청 세부 사항 등 충분한 컨텍스트 정보를 포함시킨다. 정기적인 분석 및 개선: 수집된 예외 데이터를 정기적으로 분석하여 시스템 안정성을 지속적으로 개선한다. Fail Fast 원칙 적용: 문제를 조기에 감지하고 신속하게 대응할 수 있도록 Fail Fast 원칙을 적용한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 02:12:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;318 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Exception Tracking" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Distributed Tracing</h2></header><div class=entry-content><p>Distributed Tracing Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.
Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.
작동 원리 고유 식별자 할당: 각 요청에 고유한 Trace ID를 부여한다. 스팬 생성: 요청이 각 서비스를 통과할 때마다 ‘스팬’이라는 작업 단위가 생성된다. 계층 구조: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다. 메타데이터 수집: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다. Distributed Tracing의 중요성 복잡성 관리: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다. 성능 최적화: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다. 문제 해결: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다. 시스템 이해: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다. 주요 사용 사례 성능 병목 식별: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다. 오류 추적: 실패한 요청의 정확한 실패 지점과 원인을 파악한다. 서비스 의존성 분석: 서비스 간 통신 패턴과 의존성을 시각화한다. 최적화: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다. 구현 방법 계측: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다. 데이터 수집: 각 요청에 대한 스팬 데이터를 수집한다. 분석 및 시각화: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다. 주요 도구 Jaeger: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구. Zipkin: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다. Datadog APM: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다. New Relic: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다. 모범 사례 샘플링 전략 수립: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다. 컨텍스트 전파: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다. 표준화: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다. 시각화 도구 활용: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 01:59:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;310 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Distributed Tracing" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/msa-patterns/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/msa-patterns/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>