<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service per Container</h2></header><div class=entry-content><p>Service per-Container “Service per-Container” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.
주요 특징 독립성: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다. 경량화: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다. 이식성: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 “한 번 빌드하고 어디서나 실행"이라는 원칙을 실현한다. 버전 관리: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다. 장점 확장성: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다. 장애 격리: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다. 기술 스택 다양성: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다. 배포 유연성: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다. 단점 복잡성 증가: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다. 리소스 오버헤드: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다. 통신 오버헤드: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다. 구현 시 고려사항 컨테이너 오케스트레이션: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다. 서비스 디스커버리: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다. 로깅 및 모니터링: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다. 보안: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다. 컨테이너 이미지 최적화 기반 이미지 최소화 멀티 스테이지 빌드 적용 캐시 레이어 최적화 불필요한 파일 제거 네트워킹 서비스간 통신 설정 네트워크 보안 정책 로드 밸런싱 구현 방법 컨테이너 이미지 생성: 각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다. Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다. 컨테이너 오케스트레이션: Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다. 서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다. 모니터링 및 로깅 설정: Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다. 예시 예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per Container" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/system-components/deployment-and-operations/service-per-container/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Single Service per Host</h2></header><div class=entry-content><p>Single Service per Host “Single Service per Host” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.
Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.
Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Single Service per Host" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/system-components/deployment-and-operations/single-service-per-host/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Serverless deployment</h2></header><div class=entry-content><p>Serverless Deployment Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 접근 방식이다.
Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.
결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:34:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless deployment" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/system-components/deployment-and-operations/serverless-deployment/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Sidecar Pattern</h2></header><div class=entry-content><p>Sidecar Pattern Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.
이는 주 애플리케이션의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있게 해준다.
![sidecar pattern that allows you to co-locate additional services within an independent container](Sidecar-768x440.webp “https://www.simform.com/blog/microservice-design-patterns/)
주요 목적은 다음과 같다:
애플리케이션 로직과 인프라 관심사의 분리 재사용 가능한 컴포넌트 제공 기존 애플리케이션의 기능 확장 다양한 언어와 프레임워크 지원 핵심 구성 요소 주 애플리케이션 컨테이너: 핵심 비즈니스 로직을 포함 Sidecar 컨테이너: 로깅, 모니터링, 보안 등의 부가 기능 제공 작동 방식 주 애플리케이션과 Sidecar는 동일한 호스트에서 실행된다. 두 컨테이너는 로컬 네트워크 인터페이스나 공유 파일 시스템을 통해 통신한다. Sidecar는 주 애플리케이션의 라이프사이클에 연결되어 함께 시작하고 종료된다. 장점 관심사의 분리: 핵심 비즈니스 로직과 부가 기능을 분리할 수 있다. 재사용성: Sidecar 컨테이너를 여러 애플리케이션에서 재사용할 수 있다. 기술 스택 독립성: 주 애플리케이션과 다른 언어로 Sidecar를 구현할 수 있다. 유지보수 용이성: Sidecar를 독립적으로 업데이트하고 관리할 수 있다. 사용 사례 로깅 및 모니터링 서비스 메시 구현 (예: Istio) 보안 및 인증 설정 관리 서비스 디스커버리 구현할 때 고려해야 할 사항들 성능 영향
...</p></div><footer class=entry-footer><span title='2024-11-13 10:07:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Sidecar Pattern" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/integration/sidecar-pattern/sidecar/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Externalized configuration</h2></header><div class=entry-content><p>Externalized Configuration Externalized Configuration 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.
이 패턴은 애플리케이션의 구성 정보를 외부 저장소에 보관하고, 런타임에 이를 읽어오는 방식으로 동작한다.
구성 정보는 데이터베이스, 파일 시스템, 환경 변수 등 다양한 외부 저장소에 보관될 수 있다.
이를 통해 각 환경(개발, 테스트, 운영 등)에 따라 다른 설정을 적용할 수 있으며, 설정 변경 시 애플리케이션을 재배포하지 않아도 된다.
Externalized Configuration 패턴은 마이크로서비스 아키텍처에서 구성 관리의 복잡성을 줄이고, 시스템의 유연성과 확장성을 높이는 데 크게 기여한다. 이 패턴을 효과적으로 사용하면 다양한 환경에서 애플리케이션을 쉽게 배포하고 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:10:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Externalized configuration" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/integration/external-configuration-store/externalized-configuration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Database per Service Pattern</h2></header><div class=entry-content><p>Database per Service Pattern “Database per Service Pattern"은 마이크로서비스 아키텍처에서 중요한 디자인 패턴 중 하나이다.
Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.
이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.
주요 특징:
각 서비스는 자신만의 전용 데이터베이스를 가짐 서비스 간 데이터 접근은 API를 통해서만 가능 각 서비스는 자신의 요구사항에 가장 적합한 데이터베이스 기술을 선택할 수 있음 Database per Service Pattern은 마이크로서비스 아키텍처에서 서비스 간 독립성과 확장성을 높인다.
하지만 이를 효과적으로 구현하기 위해서는 신중한 설계와 다양한 기술적 도전을 해결해야 한다.
각 서비스의 특성과 전체 시스템의 요구사항을 고려하여 이 패턴의 적용 여부를 결정해야 하며, 필요에 따라 다른 패턴들과 조합하여 사용하는 것이 좋다.
...</p></div><footer class=entry-footer><span title='2024-11-12 10:05:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Database per Service Pattern" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/data-management/database-per-service/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shared Database</h2></header><div class=entry-content><p>Shared Database 마이크로서비스 아키텍처(MSA)에서 “Shared Database” 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.
Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.
Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 07:39:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/architectue-patterns/data-management/shared-database/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/msa-patterns/page/4/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>