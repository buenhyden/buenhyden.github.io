<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>MSA Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Synchronous Communication Pattern</h2></header><div class=entry-content><p>Synchronous Communication Pattern Synchronous Communication Pattern은 한 서비스가 다른 서비스에 요청을 보내고 응답을 받을 때까지 기다리는 방식이다.
이는 실시간 상호작용이 필요한 경우에 주로 사용된다.
주요 특징:
실시간 상호작용 즉각적인 응답 블로킹 방식의 통신 sequenceDiagram participant Client participant Server Note over Client,Server: 동기식 통신 - 응답을 기다림 Client->>+Server: 요청 Note right of Server: 요청 처리 중 Server-->>-Client: 응답 Note over Client: 응답 받은 후&lt;br/>다음 작업 진행 실제 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // REST API를 사용한 동기식 통신 예시 @Service public class OrderService { private final RestTemplate restTemplate; private final String paymentServiceUrl = "http://payment-service/api/payments"; public OrderResponse createOrder(Order order) { // 주문 생성 로직 Order savedOrder = orderRepository.save(order); // 결제 서비스 호출 (동기식) PaymentRequest paymentRequest = new PaymentRequest( order.getId(), order.getAmount(), order.getPaymentDetails() ); try { PaymentResponse paymentResponse = restTemplate.postForObject( paymentServiceUrl, paymentRequest, PaymentResponse.class ); // 결제 결과에 따른 주문 상태 업데이트 if (paymentResponse.isSuccessful()) { savedOrder.setStatus(OrderStatus.PAID); } else { savedOrder.setStatus(OrderStatus.PAYMENT_FAILED); } orderRepository.save(savedOrder); return new OrderResponse(savedOrder, paymentResponse); } catch (RestClientException e) { // 오류 처리 savedOrder.setStatus(OrderStatus.ERROR); orderRepository.save(savedOrder); throw new OrderProcessingException("결제 처리 중 오류 발생", e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # FastAPI를 사용한 동기식 통신 예시 from fastapi import FastAPI, HTTPException from pydantic import BaseModel import httpx from typing import Optional class Order(BaseModel): id: str amount: float payment_details: dict class PaymentRequest(BaseModel): order_id: str amount: float details: dict class OrderService: def __init__(self): self.payment_service_url = "http://payment-service/api/payments" async def create_order(self, order: Order): # 주문 생성 로직 saved_order = await self.order_repository.save(order) # 결제 서비스 호출 (동기식) payment_request = PaymentRequest( order_id=order.id, amount=order.amount, details=order.payment_details ) try: async with httpx.AsyncClient() as client: response = await client.post( self.payment_service_url, json=payment_request.dict() ) payment_response = response.json() # 결제 결과에 따른 주문 상태 업데이트 if payment_response["successful"]: saved_order.status = "PAID" else: saved_order.status = "PAYMENT_FAILED" await self.order_repository.save(saved_order) return {"order": saved_order, "payment": payment_response} except httpx.RequestError as e: # 오류 처리 saved_order.status = "ERROR" await self.order_repository.save(saved_order) raise HTTPException( status_code=500, detail=f"결제 처리 중 오류 발생: {str(e)}" ) Synchronous Communication의 유형 HTTP 요청/응답: 가장 일반적인 동기식 통신 방법으로, REST API를 통해 구현된다.
...</p></div><footer class=entry-footer><span title='2024-12-28 03:56:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1463 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous Communication Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/synchronous-communication-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비동기 통신 패턴(Asynchronous Communication Pattern)</h2></header><div class=entry-content><p>비동기 통신 패턴(Asynchronous Communication Pattern) Asynchronous Communication Pattern은 마이크로서비스 간 통신에서 메시지를 보내는 서비스가 즉각적인 응답을 기다리지 않고 계속해서 작업을 수행할 수 있게 하는 방식이다.
이 패턴은 서비스 간 느슨한 결합을 가능하게 하며, 시스템의 확장성과 탄력성을 향상시킨다.
Asynchronous Communication Pattern은 MSA에서 서비스 간 효율적인 통신을 가능하게 하며, 시스템의 확장성과 탄력성을 크게 향상시킨다.
하지만 구현의 복잡성과 메시지 순서 관리 등의 도전 과제도 존재하므로, 이를 고려하여 적절히 설계하고 구현해야 한다.
Asynchronous Communication의 주요 특징 비동기 처리: 서비스는 메시지를 보낸 후 응답을 기다리지 않고 다음 작업을 수행한다. 메시지 브로커 사용: Kafka나 RabbitMQ와 같은 메시지 브로커를 통해 서비스 간 통신이 이루어진다. 유연성: 팀원들이 자신의 일정에 맞춰 작업할 수 있어 글로벌 팀이나 원격 근무에 적합하다. 확장성: 서비스들이 독립적으로 메시지를 처리할 수 있어 더 나은 확장성을 제공한다. Asynchronous Communication Pattern의 장점 높은 확장성: 서비스들이 독립적으로 메시지를 처리할 수 있어 시스템 전체의 확장성이 향상된다. 향상된 장애 허용성: 서비스 간 결합도가 낮아 한 서비스의 실패가 다른 서비스에 즉각적인 영향을 미치지 않는다. 유연한 의존성 관리: 이벤트 기반 아키텍처를 통해 서비스 간 의존성을 줄일 수 있다. 높은 처리량: 서비스들이 동시에 메시지를 처리할 수 있어 전체적인 처리량이 증가한다. Asynchronous Communication 구현 방식 메시징 시스템: Kafka, RabbitMQ 등의 메시지 브로커를 사용한다. 이벤트 기반 아키텍처: 서비스들이 이벤트를 발행하고 구독하는 방식으로 통신한다. 비동기 프로토콜: AMQP와 같은 비동기 프로토콜을 사용하여 메시지를 전송한다. Asynchronous Communication Pattern의 사용 사례 알림 시스템: SMS, 이메일 등의 알림을 보낼 때 사용된다. 주문 처리: 온라인 상점에서 주문 확인 메시지를 보낼 때 활용된다. 보고서 생성: 시간이 오래 걸리는 보고서 생성 작업에 적합하다. 구현 시 고려사항 메시지 순서: 메시지의 순서가 중요한 경우, 적절한 순서 보장 메커니즘을 구현해야 한다. 트랜잭션 관리: 클라이언트 측에서 트랜잭션을 관리하여 일관성을 유지해야 한다. 메시지 지속성: 시스템 장애 시에도 메시지가 손실되지 않도록 보장해야 한다. 모니터링 및 추적: 비동기 통신의 특성상 문제 발생 시 디버깅이 어려울 수 있으므로, 적절한 모니터링 및 추적 시스템을 구축해야 한다. Asynchronous Communication Pattern을 활용한 실제 구현 예시 %%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '12px'}, 'flowchart': {'width': 400, 'height': 250, 'diagramPadding': 8}}}%% sequenceDiagram participant Client participant OrderService participant MessageQueue participant PaymentService participant NotificationService Note over Client,NotificationService: Async Flow Client->>OrderService: 1. Create Order activate OrderService OrderService-->>Client: 2. Accepted (202) OrderService->>MessageQueue: 3. Publish Event deactivate OrderService MessageQueue->>PaymentService: 4a. Consume activate PaymentService PaymentService->>MessageQueue: 5a. Process deactivate PaymentService MessageQueue->>NotificationService: 4b. Consume activate NotificationService NotificationService-->>MessageQueue: 5b. Ack deactivate NotificationService MessageQueue->>OrderService: 6. Update activate OrderService OrderService->>MessageQueue: 7. Status deactivate OrderService MessageQueue->>NotificationService: 8. Send activate NotificationService NotificationService->>Client: 9. Push deactivate NotificationService 알림 시스템과 주문 처리 시스템
주요 컴포넌트와 특징:
...</p></div><footer class=entry-footer><span title='2024-12-28 03:56:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1273 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기 통신 패턴(Asynchronous Communication Pattern)" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/asynchronous-communication-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Auto-Scaling-Pattern</h2></header><div class=entry-content><p>Auto-Scaling-Pattern 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-26 02:39:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Auto-Scaling-Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/auto-scaling-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Multiple Service Instances per Host</h2></header><div class=entry-content><p>Multiple Service Instances per Host 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-26 02:14:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multiple Service Instances per Host" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-service-instances-per-host/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Instance per Container</h2></header><div class=entry-content><p>Service Instance per Container 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-26 02:14:00 +0000 UTC'>December 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Instance per Container" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-instance-per-container/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/msa-patterns/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/msa-patterns/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>