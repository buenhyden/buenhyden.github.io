<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architectural Patterns on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/architectural-patterns/</link>
    <description>Recent content in Architectural Patterns on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.145.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Nov 2024 01:40:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/architectural-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Twelve-Factor App methodology</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/twelve-factor-app-methodology/</guid>
      <description>클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/cqrs/</guid>
      <description>CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-sourcing/</guid>
      <description>&lt;h2 id=&#34;event-sourcing&#34;&gt;Event Sourcing&lt;/h2&gt;
&lt;p&gt;Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.&lt;br&gt;
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.&lt;/p&gt;
&lt;p&gt;Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;event-sourcing의-핵심-개념&#34;&gt;Event Sourcing의 핵심 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 중심 저장&lt;/strong&gt;: 시스템의 모든 상태 변경을 이벤트로 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;불변성&lt;/strong&gt;: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 순서&lt;/strong&gt;: 이벤트는 발생한 순서대로 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성&lt;/strong&gt;: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-장점&#34;&gt;Event Sourcing의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;완전한 감사 추적&lt;/strong&gt;: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 여행 가능&lt;/strong&gt;: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-구현-방법&#34;&gt;Event Sourcing의 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 정의&lt;/strong&gt;: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 저장소&lt;/strong&gt;: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 핸들러&lt;/strong&gt;: 각 이벤트 유형에 대한 처리 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성 로직&lt;/strong&gt;: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-주의사항&#34;&gt;Event Sourcing의 주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 버전 관리&lt;/strong&gt;: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최종 일관성&lt;/strong&gt;: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;이벤트-소싱의-구현-시-고려사항&#34;&gt;이벤트 소싱의 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;이벤트 저장소(Event Store)&lt;/strong&gt;: 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service-oriented architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/service-oriented-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/service-oriented-architecture/</guid>
      <description>**Service-Oriented Architecture(SOA)**는 기업의 복잡한 IT 시스템을 **비즈니스 기능 단위의 서비스**로 모듈화하고, 이를 조합해 유연한 애플리케이션을 구축하는 소프트웨어 설계 패턴이다.</description>
    </item>
    <item>
      <title>Message Queues and Streams</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/message-queues-and-streams/</link>
      <pubDate>Fri, 27 Sep 2024 09:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/message-queues-and-streams/</guid>
      <description>메시지 큐는 작업의 안정적인 처리와 시스템 간 결합도 감소에 적합하며, 스트림은 실시간 데이터 처리와 분석에 더 적합하다.</description>
    </item>
    <item>
      <title>Blackboard Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/blackboard-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/blackboard-pattern/</guid>
      <description>Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴으로 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.</description>
    </item>
  </channel>
</rss>
