<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concepts | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/concepts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/concepts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/concepts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concepts"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Concepts</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조건문 (Conditional Statements)</h2></header><div class=entry-content><p>조건문 (Conditional Statements) 프로그래밍에서 조건문(Conditional Statements)은 프로그램의 흐름을 제어하는 중요한 구조이다.
조건문은 특정 조건이 참(true)인지 거짓(false)인지에 따라 다른 코드 블록을 실행하도록 하는 프로그래밍 구조로, 이를 통해 프로그램은 다양한 상황에 대응할 수 있게 된다.
주요 조건문 종류 if 문:
가장 기본적인 조건문. 조건이 참일 때 특정 코드 블록을 실행한다. if-else 문:
조건이 참일 때와 거짓일 때 각각 다른 코드 블록을 실행한다. else if 문:
여러 조건을 순차적으로 검사할 때 사용한다. switch 문:
...</p></div><footer class=entry-footer><span title='2025-01-11 15:08:00 +0000 UTC'>January 11, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건문 (Conditional Statements)" href=https://buenhyden.github.io/posts/programming-languages/concepts/conditional-statements/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>폴링(Polling)</h2></header><div class=entry-content><p>폴링(Polling) 폴링(Polling)은 소프트웨어 개발에서 중요한 통신 기법으로, 클라이언트가 주기적으로 서버에 데이터나 상태 변경을 요청하는 방식이다.
이 방법은 실시간 또는 준실시간 업데이트가 필요한 애플리케이션에서 자주 사용된다.
폴링의 작동 원리 클라이언트가 서버에 주기적으로 요청을 보낸다. 서버는 요청을 받아 처리하고 응답을 반환한다. 클라이언트는 응답을 받아 필요한 작업을 수행한다. 일정 시간 후 클라이언트는 다시 요청을 보낸다. 이 과정은 지속적으로 반복된다.
폴링의 장점 구현의 용이성: 폴링은 상대적으로 간단하게 구현할 수 있다. 호환성: 대부분의 환경과 기술에서 사용 가능하다. 요청 빈도 제어: 개발자가 요청 주기를 조절할 수 있어 유연성이 높다. 비실시간 업데이트에 적합: 즉각적인 업데이트가 필요하지 않은 경우에 효과적이다. 폴링의 단점 서버 부하: 불필요한 요청으로 인해 서버에 부담을 줄 수 있다. 실시간성 부족: 폴링 주기에 따라 실시간 업데이트가 지연될 수 있다. 리소스 낭비: 변경사항이 없어도 지속적으로 요청을 보내므로 리소스가 낭비될 수 있다. 폴링의 사용 사례 이메일 클라이언트: 새 메일 확인을 위해 주기적으로 서버에 요청을 보낸다. 주식 시세 모니터링: 일정 간격으로 최신 주가 정보를 요청한다. 소셜 미디어 피드: 새로운 게시물이나 알림을 확인하기 위해 사용된다. IoT 디바이스 모니터링: 센서 데이터를 주기적으로 확인한다. 폴링의 구현 폴링은 주로 JavaScript의 setInterval() 함수나 setTimeout() 함수를 사용하여 구현한다.
예를 들어:
...</p></div><footer class=entry-footer><span title='2024-12-25 16:50:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;245 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 폴링(Polling)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>스트리밍 (Streaming)</h2></header><div class=entry-content><p>스트리밍 (Streaming) 스트리밍은 인터넷을 통해 오디오, 비디오 및 기타 콘텐츠를 실시간으로 전송하고 재생하는 기술이다.
이 기술은 사용자가 콘텐츠를 완전히 다운로드하지 않고도 즉시 소비할 수 있게 해준다.
스트리밍의 작동 원리 스트리밍은 대용량 콘텐츠를 작은 데이터 조각으로 나누어 연속적으로 전송한다.
사용자의 기기는 이 데이터를 받아 실시간으로 처리하고 재생한다.
이 과정은 다음과 같이 진행된다:
콘텐츠를 작은 패킷으로 분할 패킷을 순차적으로 전송 수신 기기에서 패킷을 버퍼링하고 재생 나머지 패킷이 계속 전송되는 동안 재생 시작 스트리밍의 유형 프로그레시브 다운로드: VOD, 인터넷 강좌 등에 적합 RTSP/RTMP 스트리밍: 실시간 대화형 플랫폼에 적합 적응형 HTTP 스트리밍: 유튜브, 넷플릭스와 같은 비디오 플랫폼에 적합 스트리밍 프로토콜 스트리밍에는 다양한 프로토콜이 사용된다:
...</p></div><footer class=entry-footer><span title='2024-12-20 06:48:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;377 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스트리밍 (Streaming)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/streaming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event Loop</h2></header><div class=entry-content><p>Event Loop 이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.
끊임없이 실행되는 프로세스로, 콜 스택이 비어있는지 확인하고 태스크 큐에서 콜백 함수를 가져와 실행하며, 자바스크립트 엔진이 아닌 호스팅 환경(브라우저 또는 Node.js)에서 제공되는 메커니즘이다. 또한, 비동기 작업의 완료 및 해당 콜백의 실행을 조정한다.
Event Loop의 구성 요소 콜 스택 (Call Stack): 현재 실행 중인 함수들이 쌓이는 곳. 후입선출(LIFO) 구조 웹 API (Web APIs): 브라우저에서 제공하는 비동기 작업을 처리하는 API. 콜백 큐 (Callback Queue): 비동기 작업이 완료된 후 실행될 콜백 함수들이 대기하는 곳. 선입선출(FIFO) 구조 이벤트 루프 (Event Loop): 콜 스택과 콜백 큐를 모니터링하며 작업을 조율. Event Loop의 동작 과정 JavaScript 코드가 실행되면 함수 호출은 콜 스택에 쌓인다. 비동기 함수(예: setTimeout, fetch)를 만나면 웹 API로 보내져 별도로 처리된다. 웹 API에서 작업이 완료되면 해당 콜백 함수를 콜백 큐로 보낸다. 이벤트 루프는 지속적으로 콜 스택이 비어있는지 확인한다. 콜 스택이 비어있다면, 이벤트 루프는 콜백 큐에서 가장 오래된 콜백을 콜 스택으로 이동시킨다. 이 과정을 반복한다. Event Loop의 기본 개념: 식당 시나리오 상황: 바쁜 식당에서 일하는 웨이터를 생각해보자.
...</p></div><footer class=entry-footer><span title='2024-12-17 12:44:00 +0000 UTC'>December 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;662 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Loop" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-12-10 02:43:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/concepts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/concepts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>