<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concepts | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/concepts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/concepts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/concepts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concepts"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Concepts</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Exception Handling</h2></header><div class=entry-content><p>예외 처리 (Exception Handling) 예외 처리(Exception Handling)는 프로그램 실행 중 발생할 수 있는 예기치 못한 상황을 관리하는 중요한 프로그래밍 개념이다.
예외 처리란 프로그램 실행 중 발생할 수 있는 예상치 못한 오류 상황에 대비하여 코드를 작성하는 것으로, 프로그램의 비정상적인 종료를 방지하고 정상적인 실행 상태를 유지하는 것을 목적으로 한다.
예외 처리의 중요성 프로그램 안정성 향상: 예외 처리를 통해 프로그램이 갑작스럽게 종료되는 것을 방지한다. 디버깅 용이성: 예외 발생 시 로그를 남겨 문제의 원인을 쉽게 파악할 수 있다. 사용자 경험 개선: 오류 발생 시 사용자에게 적절한 메시지를 제공할 수 있다. 예외 처리 방법 대부분의 프로그래밍 언어에서는 try-catch 블록을 사용하여 예외를 처리한다:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:08:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;183 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Exception Handling" href=https://buenhyden.github.io/posts/programming-languages/concepts/exception-handling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조건문 (Conditional Statements)</h2></header><div class=entry-content><p>조건문 (Conditional Statements) 프로그래밍에서 조건문(Conditional Statements)은 프로그램의 흐름을 제어하는 중요한 구조이다.
조건문은 특정 조건이 참(true)인지 거짓(false)인지에 따라 다른 코드 블록을 실행하도록 하는 프로그래밍 구조로, 이를 통해 프로그램은 다양한 상황에 대응할 수 있게 된다.
주요 조건문 종류 if 문:
가장 기본적인 조건문. 조건이 참일 때 특정 코드 블록을 실행한다. if-else 문:
조건이 참일 때와 거짓일 때 각각 다른 코드 블록을 실행한다. else if 문:
여러 조건을 순차적으로 검사할 때 사용한다. switch 문:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:08:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건문 (Conditional Statements)" href=https://buenhyden.github.io/posts/programming-languages/concepts/conditional-statements/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>반복문(Iteration)</h2></header><div class=entry-content><p>반복문(Iteration) 프로그래밍에서 반복문(Iteration)은 특정 코드 블록을 여러 번 실행하는 제어 구조이다.
반복문은 프로그램에서 같은 작업을 여러 번 수행해야 할 때 사용한다.
이를 통해 코드의 중복을 줄이고 효율적으로 작업을 처리할 수 있다.
주요 반복문 종류 for 문:
정해진 횟수만큼 반복할 때 주로 사용. 초기화, 조건, 증감식을 한 줄에 표현한다. while 문:
조건이 참인 동안 계속해서 반복한다. 반복 횟수가 정해지지 않았을 때 유용하다. do-while 문:
while 문과 비슷하지만, 최소 한 번은 실행된다. 반복문의 구성 요소 초기화: 반복문에서 사용할 변수를 초기화한다. 조건식: 반복을 계속할지 결정하는 조건을 설정한다. 반복 실행문: 조건이 참일 때 실행되는 코드 블록이다. 증감식: 반복 변수를 변경하여 언젠가 조건이 거짓이 되도록 한다. 반복문의 장점 코드 재사용: 같은 코드를 여러 번 작성하지 않아도 된다. 효율성: 대량의 데이터나 반복적인 작업을 효율적으로 처리할 수 있다. 가독성: 반복되는 작업을 간결하게 표현할 수 있다. 주의사항 무한 루프: 조건식이 항상 참이 되지 않도록 주의해야 한다. 성능: 중첩된 반복문은 성능에 영향을 줄 수 있으므로 필요한 경우에만 사용한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 15:06:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;152 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 반복문(Iteration)" href=https://buenhyden.github.io/posts/programming-languages/concepts/iteration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>재귀 (Recursion)</h2></header><div class=entry-content><p>재귀 (Recursion) 재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.
재귀 함수는 다음과 같은 두 가지 주요 부분으로 구성된다:
기본 조건 (Base Case): 재귀 호출을 멈추는 조건 재귀 호출 (Recursive Case): 함수가 자기 자신을 호출하는 부분 재귀의 작동 원리 재귀 함수가 호출될 때마다 새로운 함수의 복사본이 만들어져 실행된다.
이 과정은 기본 조건에 도달할 때까지 계속된다.
예를 들어, 팩토리얼을 계산하는 재귀 함수를 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:05:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;489 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 재귀 (Recursion)" href=https://buenhyden.github.io/posts/programming-languages/concepts/recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback Function (콜백 함수)</h2></header><div class=entry-content><p>Callback Function 프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수.
하나의 함수가 실행되는 동안, 특정 시점이나 조건이 충족되었을 때 호출될 함수를 미리 전달하는 방식.
이 개념은 동기적(synchronous) 또는 비동기적(asynchronous) 작업에서 모두 사용되며, 특히 비동기 프로그래밍에서 매우 중요하다.
간단한 예시를 통해 콜백 함수의 개념을 이해:
1 2 3 4 5 6 7 8 9 10 function greet(name, callback) { console.log('안녕하세요, ' + name + '님!'); callback(); } function sayGoodbye() { console.log('안녕히 가세요!'); } greet('홍길동', sayGoodbye); 이 예시에서 sayGoodbye 함수가 콜백 함수로 greet 함수에 전달된다. greet 함수는 인사말을 출력한 후 콜백 함수를 실행한다. 콜백 함수의 동작 원리 함수 전달: 콜백 함수는 다른 함수의 매개변수로 전달된다. 호출 시점 결정: 전달받은 함수는 호출자 함수 내부에서 특정 조건이나 작업 완료 시 호출된다. 결과 처리: 콜백 함수는 호출자 함수의 결과나 상태를 기반으로 추가 작업을 수행한다. 콜백 함수의 장점 코드의 재사용성 동일한 함수에 다른 콜백을 전달하여 다양한 동작을 구현할 수 있다. 중복 코드를 줄일 수 있다. 유연성 실행 시점에 필요한 동작을 결정할 수 있다. 프로그램의 동작을 쉽게 변경할 수 있다. 비동기 프로그래밍 지원 긴 작업을 기다리지 않고 다른 작업을 수행할 수 있다. 프로그램의 반응성을 향상시킬 수 있다. 이벤트 처리 사용자의 행동(클릭, 키보드 입력 등)에 반응하는 데 사용된다. 웹 브라우저의 이벤트 리스너가 대표적인 예시이다. 콜백 함수의 종류 동기적(Synchronous) 콜백 호출자 함수가 실행되는 동안 즉시 호출된다. 일반적으로 작업 순서가 중요할 때 사용된다. 예시: 배열 메서드(forEach, map)에서 사용되는 콜백. 1 2 3 4 const numbers = [1, 2, 3]; numbers.forEach((num) => { console.log(num); // 배열의 각 요소를 출력 }); 비동기적(Asynchronous) 콜백 호출자 함수가 실행된 후, 특정 작업이 완료되었을 때 호출된다. 주로 시간이 걸리는 작업(예: 파일 읽기, API 요청)에서 사용된다. 예시: setTimeout 또는 이벤트 리스너. 1 2 3 setTimeout(() => { console.log("3초 후에 실행됩니다."); }, 3000); 콜백 함수를 사용하는 이유 비동기 작업 처리: 시간이 걸리는 작업(API 요청, 파일 읽기 등)을 처리하는 동안 메인 프로그램 흐름을 막지 않음. 코드 유연성 증가: 특정 작업 이후 실행할 동작을 동적으로 정의 가능. 모듈화 및 재사용성 증가: 코드의 특정 동작을 분리하여 재사용 가능. 주의할 점 콜백 지옥(Callback Hell)
복잡한 비동기 작업이 중첩되어 코드 가독성이 떨어지고 유지보수가 어려워지는 현상.
해결책 Promise 사용: 비동기 작업을 체인 형태로 작성하여 가독성을 개선. Async/Await 사용: 비동기 코드를 동기 코드처럼 작성 가능. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 잘못된 방식 getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { // 콜백 지옥… }); }); }); }); // 올바른 방식 // Promise나 async/await를 사용하여 개선 async function fetchData() { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); // 더 깔끔하고 읽기 쉬운 코드 } 오류 처리
콜백 함수에서 발생하는 오류를 적절히 처리해야 한다.
오류 처리 콜백을 별도로 제공하는 것이 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 잘못된 방식 function fetchData(callback) { // 에러 처리가 없음 callback(data); } // 올바른 방식 function fetchData(callback) { try { // 데이터 처리 callback(null, data); } catch (error) { callback(error, null); } } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 실행 순서 보장
비동기 콜백의 경우 실행 순서를 신중히 고려해야 한다.
필요한 경우 콜백 체인을 사용하여 순서를 보장할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function processUserUnsafe(userId) { let userData; fetchUserData( userId, (user) => { userData = user; console.log("1. 사용자 데이터 받음:", userData); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); // userData가 설정되기 전에 실행될 수 있음 console.log("2. userData 사용:", userData); } // 4. 콜백 체인을 사용한 실행 순서 보장 function processUserSafe(userId) { fetchUserData( userId, (user) => { console.log("1. 사용자 데이터 받음:", user); validateUser(user, (validatedUser) => { console.log("2. 사용자 검증 완료:", validatedUser); updateUser(validatedUser, (updatedUser) => { console.log("3. 사용자 정보 업데이트 완료:", updatedUser); }, (error) => console.error("사용자 업데이트 실패:", error) ); }, (error) => console.error("사용자 검증 실패:", error) ); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); } 파이썬에서의 콜백 함수 예제 파이썬에서도 함수를 매개변수로 전달하여 콜백 함수를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-06 12:45:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;803 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Function (콜백 함수)" href=https://buenhyden.github.io/til/2024/10/06/callback-function/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>가비지 컬렉션 (Garbage Collection, GC)</h2></header><div class=entry-content><p>가비지 컬렉션 (Garbage Collection, GC) 프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능
주요 특징 자동 메모리 관리: 프로그래머가 명시적으로 메모리를 해제할 필요가 없다. 메모리 누수 방지: 사용하지 않는 객체를 자동으로 제거하여 메모리 누수를 예방한다. 개발 생산성 향상: 메모리 관리에 대한 부담을 줄여 개발자가 비즈니스 로직에 집중할 수 있게 한다. 실행 시간 오버헤드: 가비지 컬렉션 프로세스가 실행되는 동안 프로그램의 성능에 영향을 줄 수 있다. 기본 원리 도달 가능성(Reachability): 프로그램의 루트(예: 전역 변수, 스택의 지역 변수)로부터 참조 체인을 따라 도달할 수 있는 객체는 “살아있는” 객체로 간주된다. 표시(Mark): GC는 먼저 모든 살아있는 객체를 표시한다. 수집(Sweep): 표시되지 않은 객체들은 “가비지"로 간주되어 메모리에서 해제된다. 주요 알고리즘 참조 카운팅(Reference Counting): 각 객체에 대한 참조 수를 추적하여 참조 수가 0이 되면 해당 객체를 수집합니다. 마크-스윕(Mark-and-Sweep): 루트에서 접근 가능한 모든 객체를 마크하고, 마크되지 않은 객체를 수집합니다. 세대별 수집(Generational Collection): 객체를 새로운 객체와 오래된 객체로 분류하여 효율적으로 관리합니다. 각 언어별 가비지 컬렉션의 특징 특징 Java Python JavaScript 기본 알고리즘 세대별 GC (Generational GC) 참조 카운팅 + 세대별 GC 표시-소거 (Mark-and-Sweep) 메모리 구분 Young Generation (Eden, S0, S1), Old Generation 3세대 (young, middle, old) Heap (New Space, Old Space) GC 종류 Serial, Parallel, CMS, G1, ZGC 참조 카운팅 GC, 세대별 GC V8 엔진의 자동 GC 수동 제어 System.gc() (권장하지 않음) gc.collect() 불가능 약한 참조 지원 WeakReference, SoftReference weakref 모듈 WeakMap, WeakSet 순환 참조 처리 자동 처리 순환 참조 감지기로 처리 자동 처리 GC 일시 중지 Stop-the-World (ZGC 제외) 참조 카운팅은 즉시 수행 증분식 GC로 최소화 튜닝 옵션 JVM 파라미터로 다양한 튜닝 가능 gc 모듈로 제한적 튜닝 엔진 내부에서 자동 최적화 메모리 모니터링 JVM 도구로 상세 모니터링 가능 gc 모듈로 제한적 모니터링 개발자 도구로 제한적 모니터링 각 언어별 가비지 컬렉션 장단점 장단점 Java Python Javascript 장점 - 매우 성숙하고 최적화된 GC 알고리즘
- 다양한 GC 알고리즘 선택 가능
- 세밀한 튜닝 가능 - 참조 카운팅으로 즉시 메모리 해제
- 간단한 구현
- 예측 가능한 동작 - 완전히 자동화된 메모리 관리
- 개발자 개입 최소화
- 증분식 GC로 성능 최적화 단점 - Stop-the-World로 인한 성능 영향
- 복잡한 튜닝 필요
- 메모리 오버헤드 - 순환 참조 처리에 추가 비용
- 참조 카운팅 오버헤드
- 멀티스레딩에서의 성능 영향 - 제어 불가능
- 메모리 사용 예측 어려움
- 브라우저마다 다른 구현 Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class GCDemo { public void createObjects() { // 강한 참조 StringBuilder builder = new StringBuilder(); // 약한 참조 WeakReference&lt;StringBuilder> weakBuilder = new WeakReference&lt;>(new StringBuilder()); // System.gc()를 호출하면 GC가 실행될 수 있지만, // 보장되지는 않습니다 System.gc(); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import gc class CircularRef: def __init__(self): self.ref = None def __del__(self): print("객체가 삭제됨") # 순환 참조 생성 a = CircularRef() b = CircularRef() a.ref = b b.ref = a # 참조 카운트 확인 print(sys.getrefcount(a)) # 2 (변수 a와 b.ref) # 명시적으로 GC 실행 gc.collect() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 // 표시-소거(Mark-and-Sweep) 알고리즘의 대상이 되는 객체 let user = { name: "John" }; // 객체에 대한 참조를 제거 user = null; // WeakMap을 사용한 약한 참조 예시 const weakMap = new WeakMap(); let key = {}; weakMap.set(key, "data"); key = null; // key 객체는 GC의 대상이 됨 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 10:19:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;554 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가비지 컬렉션 (Garbage Collection, GC)" href=https://buenhyden.github.io/posts/programming-languages/concepts/garbage-collection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>인터프리터(Interpreter)</h2></header><div class=entry-content><p>인터프리터(Interpreter) 프로그래밍 언어의 소스 코드를 직접 실행하는 프로그램 또는 환경
기능과 역할 인터프리터의 주요 기능은 다음과 같다:
소스 코드 해석: 프로그래머가 작성한 코드를 한 줄씩 읽고 해석한다. 즉시 실행: 해석된 코드를 바로 실행한다. 대화형 환경 제공: 코드를 즉시 실행하고 결과를 확인할 수 있는 환경을 제공한다. 특징과 장점 즉시 실행: 코드 수정 후 바로 실행이 가능하다. 대화형 모드: 많은 인터프리터 언어는 대화형 모드를 제공한다. 플랫폼 독립성: 대부분 플랫폼에 독립적으로 실행 가능하다. 디버깅 용이성: 오류가 발생한 즉시 실행을 중지하여 디버깅이 쉽다. 작동 과정 이해하기 예를 들어, 다음과 같은 파이썬 코드가 있다고 생각해보자:
...</p></div><footer class=entry-footer><span title='2024-10-06 05:32:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;425 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인터프리터(Interpreter)" href=https://buenhyden.github.io/posts/programming-languages/concepts/interpreter/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>컴파일러(Compiler)</h2></header><div class=entry-content><p>컴파일러(Compiler) 우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램.
컴파일러의 기능과 역할 코드 최적화:
컴파일러는 우리가 작성한 코드를 더 효율적으로 실행될 수 있게 개선한다.
예를 들어: 1 result = 5 * 60 * 24 # 하루의 초 계산 이런 코드를 컴파일러는 다음과 같이 최적화할 수 있다:
1 result = 7200 # 미리 계산된 값 사용 오류 검사:
코드를 실행하기 전에 문제점을 미리 찾아준다.
마치 글을 출판하기 전에 교정을 보는 것과 비슷하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 05:27:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;795 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 컴파일러(Compiler)" href=https://buenhyden.github.io/posts/programming-languages/concepts/compiler/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)</h2></header><div class=entry-content><p>동기(Synchronous) 동기(Synchronous)는 작업들이 순차적으로 실행되며, 하나의 작업이 완료된 후에 다음 작업이 시작되는 방식이다.
“동시에 일어난다"는 의미로, 요청과 그 결과가 동시에 일어난다는 약속이다.
파일에서 데이터를 읽고 처리하는 동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 동기식 처리 예제 function processUserData() { // 1. 파일을 읽을 때까지 다음 줄로 진행하지 않음 const userData = readFileSync('user.txt'); // 2. 데이터 처리가 완료될 때까지 대기 const processedData = processData(userData); // 3. 저장이 완료될 때까지 대기 saveToDatabase(processedData); // 4. 모든 작업이 완료된 후에만 실행 console.log('작업 완료!'); } 주요 특징 순차적 실행: 코드가 작성된 순서대로 실행된다. 블로킹(Blocking): 한 작업이 완료될 때까지 다음 작업은 대기한다. 예측 가능성: 코드의 실행 흐름이 명확하고 예측 가능하다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)" href=https://buenhyden.github.io/til/2024/10/06/synchronous/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>비동기(Asynchronous)</h2></header><div class=entry-content><p>비동기(Asynchronous) 비동기(Asynchronous)는 작업들이 독립적으로 실행되며, 작업의 완료 여부와 관계없이 다음 작업이 시작될 수 있는 방식이다.
“동시에 일어나지 않는다"는 의미로, 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.
파일에서 데이터를 읽고 처리하는 비동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 비동기식 처리 예제 async function processUserData() { try { // 1. 파일을 읽는 동안 다른 작업 수행 가능 const userData = await readFile('user.txt'); // 2. 데이터 처리 중에도 다른 작업 가능 const processedData = await processData(userData); // 3. 데이터베이스 저장 중에도 다른 작업 가능 await saveToDatabase(processedData); console.log('작업 완료!'); } catch (error) { console.error('오류 발생:', error); } } // 메인 프로그램은 계속 실행됨 console.log('프로그램 시작'); processUserData(); console.log('다른 작업 진행 중…'); 주요 특징 비순차적 실행: 작업들이 독립적으로 실행될 수 있다. 논블로킹(Non-blocking): 한 작업이 다른 작업의 실행을 막지 않는다. 이벤트 기반: 작업 완료 시 이벤트나 콜백을 통해 결과를 처리한다. 동시성: 여러 작업을 동시에 처리할 수 있다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기(Asynchronous)" href=https://buenhyden.github.io/til/2024/10/06/asynchronous/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/concepts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/concepts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>