<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concepts | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/concepts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/concepts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/concepts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concepts"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Concepts</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process Vs Thread Vs Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-06 08:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/process-vs-thread-vs-coroutine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jsdoc</h2></header><div class=entry-content><p>Jsdoc JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.
정의와 개념 JavaScript 코드에 대한 설명을 위해 사용되는 주석 시스템. /** */ 형식의 주석 안에 @로 시작하는 특별한 태그를 사용하여 정보를 제공한다. 주요 특징 API 문서 자동 생성: 주석을 기반으로 HTML 형식의 문서를 생성한다. 타입 정보 제공: 함수의 매개변수, 반환값 등의 타입을 명시할 수 있다. 코드 에디터 지원: 많은 IDE에서 JSDoc을 인식하여 자동완성, 타입 체크 등을 제공한다. 주요 태그 @param: 함수 매개변수 설명 @returns: 함수 반환값 설명 @type: 변수의 타입 지정 @typedef: 사용자 정의 타입 생성 @example: 사용 예제 제공 사용 예시 1 2 3 4 5 6 7 8 9 /** * 두 수를 더하는 함수 * @param {number} a - 첫 번째 숫자 * @param {number} b - 두 번째 숫자 * @returns {number} 두 숫자의 합 */ function add(a, b) { return a + b; } 참고 및 출처 Use JSDoc: Index
...</p></div><footer class=entry-footer><span title='2024-11-21 11:41:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;147 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jsdoc" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/jsdoc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Data Transmission</h2></header><div class=entry-content><p>Data Transmission 데이터 전송 및 처리 방식은 다양한 기준에 따라 분류되며, 각 방식은 특정한 통신 환경과 요구 사항에 맞게 선택된다.
전송 방향에 따른 분류 단방향 전송 (Simplex)
데이터가 한 방향으로만 전송된다. 예: 라디오 방송, TV 방송 장점: 단순하고 효율적인 채널 사용 단점: 상호작용이 불가능 반이중 전송 (Half-Duplex)
양방향으로 데이터 전송이 가능하지만, 동시에는 불가능하다. 예: 무전기 장점: 양방향 통신 가능, 에러 감지에 유용 단점: 동시 통신 불가 전이중 전송 (Full-Duplex)
양방향으로 동시에 데이터 전송이 가능하다. 예: 전화 통화, 현대적인 컴퓨터 네트워크 장점: 실시간 양방향 통신 가능, 높은 효율성 단점: 복잡한 하드웨어 필요 비트 전송 방식에 따른 분류 직렬 전송 (Serial Transmission)
...</p></div><footer class=entry-footer><span title='2024-10-20 09:32:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;271 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Transmission" href=https://buenhyden.github.io/til/2024/10/20/data-transmission/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>스트리밍 (Streaming)</h2></header><div class=entry-content><p>스트리밍 (Streaming) 스트리밍은 인터넷을 통해 오디오, 비디오 및 기타 콘텐츠를 실시간으로 전송하고 재생하는 기술이다.
이 기술은 사용자가 콘텐츠를 완전히 다운로드하지 않고도 즉시 소비할 수 있게 해준다.
스트리밍의 작동 원리 스트리밍은 대용량 콘텐츠를 작은 데이터 조각으로 나누어 연속적으로 전송한다.
사용자의 기기는 이 데이터를 받아 실시간으로 처리하고 재생한다.
이 과정은 다음과 같이 진행된다:
콘텐츠를 작은 패킷으로 분할 패킷을 순차적으로 전송 수신 기기에서 패킷을 버퍼링하고 재생 나머지 패킷이 계속 전송되는 동안 재생 시작 스트리밍의 유형 프로그레시브 다운로드: VOD, 인터넷 강좌 등에 적합 RTSP/RTMP 스트리밍: 실시간 대화형 플랫폼에 적합 적응형 HTTP 스트리밍: 유튜브, 넷플릭스와 같은 비디오 플랫폼에 적합 스트리밍 프로토콜 스트리밍에는 다양한 프로토콜이 사용된다:
...</p></div><footer class=entry-footer><span title='2024-10-20 06:48:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;377 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스트리밍 (Streaming)" href=https://buenhyden.github.io/til/2024/10/20/streaming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-10-19 02:43:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/system-design/load-balancers/loadbalancing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>코루틴(Coroutine)</h2></header><div class=entry-content><p>코루틴(Coroutine) 코루틴(Coroutine)은 복잡한 비동기 작업을 간단하고 효율적으로 처리할 수 있게 해주는 프로그래밍 개념이다.
프로그램의 실행 흐름을 제어할 수 있는 프로그래밍 구성 요소이다.
일반적인 함수와 달리, 코루틴은 실행을 일시 중단하고 재개할 수 있으며, 여러 진입점과 종료점을 가질 수 있다.
이는 마치 대화하는 것처럼, 실행을 주고받을 수 있다는 특징이 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 # Python에서의 간단한 코루틴 예제 async def simple_coroutine(): print("코루틴 시작") await asyncio.sleep(1) # 중단점 print("1초 후 재개") await asyncio.sleep(1) # 다른 중단점 print("또 1초 후 재개") # 코루틴 실행 async def main(): await simple_coroutine() asyncio.run(main()) https://medium.com/@turxan.dunya97/simple-explanation-what-is-coroutines-in-programming-d01e0ddf6f06
...</p></div><footer class=entry-footer><span title='2024-10-05 06:52:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코루틴(Coroutine)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/coroutine/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>