<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concepts | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/concepts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/concepts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/concepts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concepts"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Concepts</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Iteration vs Recursion</h2></header><div class=entry-content><p>Iteration Vs Recursion Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration Vs Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 11:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;327 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Iteration vs Recursion" href=https://buenhyden.github.io/til/2024/10/06/iteration-vs-recursion/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process Vs Thread Vs Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-06 08:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/til/2024/10/06/process-vs-thread-vs-coroutine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/til/2024/11/23/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript vs Node.js</h2></header><div class=entry-content><p>Javascript Vs Node.js JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.
주요 특징은 다음과 같다:
객체 기반의 스크립트 언어이다. 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 이벤트 중심의 프로그래밍이 가능하다. 웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다. 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 1 2 3 4 5 6 7 8 9 10 // JavaScript 예시 // DOM 조작 document.getElementById('myButton').addEventListener('click', function() { alert('버튼이 클릭되었습니다!'); }); // 비동기 처리 fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data));**** Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:33:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;329 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript vs Node.js" href=https://buenhyden.github.io/til/2024/11/23/javascript-vs-node.js/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import Vs Require require는 Node.js에서 사용되는 CommonJS 모듈 시스템의 키워드로, 동기적으로 모듈을 로드하며 프로그램의 어느 지점에서나 호출할 수 있다. 반면에 import는 ES6에서 도입된 모듈 시스템의 키워드로, 코드 실행 전에 모듈을 미리 로드하며 파일의 시작 부분에서만 사용할 수 있다. 따라서 프로젝트의 환경과 요구 사항에 따라 적절한 키워드를 선택하여 사용하는 것이 중요하다.
Import (ES Modules) ES6(ES2015)에서 도입된 모듈 시스템으로, JavaScript의 공식 표준 모듈 시스템. 정적 임포트 방식을 사용하며, 브라우저에서 기본적으로 지원된다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 기본 가져오기 import module from './module'; // 부분 가져오기 import { function1, function2 } from './module'; // 모든 것을 객체로 가져오기 import * as moduleObject from './module'; // 이름 변경하여 가져오기 import { originalName as newName } from './module'; // 가져오기와 실행만 하기 import './module'; Require (CommonJS) Node.js에서 기본적으로 사용되는 모듈 시스템으로, 동적 임포트를 지원한다. 런타임에 모듈을 로드할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;381 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/til/2024/11/23/import-vs-require/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java Keywords</h2></header><div class=entry-content><p>Keyword 키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.
각 키워드의 특징과 주의사항:
모든 키워드는 소문자로만 작성된다. 키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다. 일부 키워드는 특정 컨텍스트에서만 의미를 가진다. 예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다. 데이터 타입 키워드 키워드 설명 예시 byte 8비트 정수형 (-128 ~ 127) byte b = 100; short 16비트 정수형 (-32,768 ~ 32,767) short s = 1000; int 32비트 정수형 int i = 10000; long 64비트 정수형 long l = 100000L; float 32비트 단정도 실수형 float f = 3.14f; double 64비트 배정도 실수형 double d = 3.14159; boolean 논리형 (true/false) boolean flag = true; char 16비트 유니코드 문자 char c = 'A'; void 반환값이 없음을 나타냄 void method() {} 제어문 키워드 키워드 설명 예시 if 조건문 시작 if (x > 0) {} else if문의 대안 경로 else {} switch 다중 분기문 시작 switch(value) {} case switch문의 각 경우 case 1: default switch문의 기본 경우 default: for 반복문 for (int i = 0; i &lt; n; i++) while 조건 기반 반복문 while (condition) do do-while 반복문 시작 do {} while(); break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 메소드에서 값 반환/종료 return value; 클래스 관련 키워드 키워드 설명 예시 class 클래스 정의 public class MyClass {} interface 인터페이스 정의 interface MyInterface {} extends 클래스/인터페이스 상속 class Child extends Parent {} implements 인터페이스 구현 class MyClass implements Interface {} enum 열거형 정의 enum Direction {NORTH, SOUTH} this 현재 인스턴스 참조 this.value = value; super 상위 클래스 참조 super.method(); new 객체 생성 new Object(); instanceof 객체 타입 검사 obj instanceof String 접근 제어 키워드 키워드 설명 예시 public 전체 접근 허용 public class Public {} private 클래스 내부만 접근 가능 private int value; protected 패키지와 자식 클래스 접근 가능 protected void method() {} default 패키지 내부만 접근 가능 int value; (키워드 생략) 제어자 키워드 키워드 설명 예시 static 클래스 레벨 멤버 정의 static int count; final 변경 불가 선언 final int MAX = 100; abstract 추상 클래스/메소드 선언 abstract class Abstract {} synchronized 스레드 동기화 synchronized void method() {} volatile 메모리 직접 접근 변수 volatile boolean flag; transient 직렬화 제외 필드 transient int temp; native 네이티브 메소드 선언 native void method(); strictfp 엄격한 부동소수점 연산 strictfp class Math {} 예외 처리 키워드 키워드 설명 예시 try 예외 발생 가능 블록 try {} catch 예외 처리 블록 catch (Exception e) {} finally 항상 실행되는 블록 finally {} throw 예외 발생 throw new Exception(); throws 예외 선언 void method() throws Exception {} assert 조건 검증 assert x > 0; 패키지 관련 키워드 키워드 설명 예시 package 패키지 선언 package com.example; import 클래스 임포트 import java.util.List; 리터럴 키워드 키워드 설명 예시 true 논리 참 값 boolean t = true; false 논리 거짓 값 boolean f = false; null 참조 없음 Object obj = null; 예약된 키워드 (미사용) 키워드 설명 const 상수 (사용되지 않음) goto 이동 (사용되지 않음) 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-29 02:56:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Java Keywords" href=https://buenhyden.github.io/posts/programming-languages/java/concepts/keywords/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Generator and Iterator</h2></header><div class=entry-content><p>Generator and Iterator 이터레이터는 값을 차례대로 반환하는 객체로, __iter__()와 __next__() 메서드를 구현한다.
제너레이터는 yield 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.
제너레이터와 이터레이터의 주요 차이점 비교 항목 이터레이터 제너레이터 정의 방식 __iter__와 __next__ 메서드를 구현하는 클래스 yield 키워드를 사용하는 함수 상태 저장 인스턴스 변수를 통해 명시적으로 상태 저장 함수의 실행 상태가 자동으로 저장 메모리 사용 모든 상태를 명시적으로 저장해야 함 필요한 값만 생성하여 메모리 효율적 구현 복잡도 상대적으로 복잡함 (여러 메서드 구현 필요) 매우 단순함 (일반 함수처럼 작성) 용도 복잡한 이터레이션 로직이 필요한 경우 간단한 순차적 데이터 생성 재사용성 클래스로 구현되어 재사용 용이 한 번 순회하면 소진됨 기능 확장성 클래스이므로 추가 메서드와 속성 정의 가능 함수 범위로 제한됨 성능 상태 관리를 위한 추가 오버헤드 존재 매우 가벼움 코드 가독성 구조화된 형태로 명확하나 장황할 수 있음 간결하고 직관적 양방향 통신 메서드를 통해 구현 가능 send() 메서드로 기본 제공 이러한 차이점들은 실제 사용에서 다음과 같은 의미를 가진다.
...</p></div><footer class=entry-footer><span title='2024-11-24 10:43:00 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;471 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Generator and Iterator" href=https://buenhyden.github.io/posts/programming-languages/python/concepts/generator-and-iterator/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python GIL</h2></header><div class=entry-content><p>GIL (Global Interpreter Lock) Source: &lt;https://medium.com/@vinayshende79/python-global-interpreter-lock-gil-explained-in-detail-abcdb206c3e3
Python 객체에 대한 접근을 제어하는 뮤텍스(mutex)로, 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 보장한다.
메모리 관리를 단순화하고 다중 스레드 환경에서 데이터의 일관성을 보장하기 위한 목적으로 도입되었다.
목적 GIL의 주요 목적은 메모리 관리를 단순화하는 것
Python은 참조 카운팅을 사용하여 가비지 컬렉션을 수행하며, GIL은 한 번에 하나의 스레드만 객체의 참조 카운트를 업데이트할 수 있도록 보장한다.
장점 메모리 관리가 단순화됩니다. 단일 스레드만이 Python 객체에 접근할 수 있으므로, 참조 계수 기반의 메모리 관리가 안전하게 동작합니다. 단일 스레드 프로그램의 성능이 향상됩니다. 락 획득/해제의 오버헤드가 없기 때문입니다. C 확장 모듈과의 통합이 용이합니다. C 라이브러리들은 대부분 스레드 안전하지 않은데, GIL이 이를 보호합니다. 단점 멀티코어 시스템에서 CPU 바운드 작업의 병렬 처리가 제한됩니다. 복잡한 멀티스레드 프로그램의 성능이 저하될 수 있습니다. 동시성 프로그래밍이 더 복잡해질 수 있습니다. 작동 방식 GIL은 Python 인터프리터에 대한 단일 잠금을 제공하여, Python 바이트코드의 실행을 위해서는 이 잠금을 획득해야 한다.
이 코드를 실행하면, CPU 바운드 작업은 GIL 때문에 순차적으로 실행되는 반면, I/O 바운드 작업은 효과적으로 병렬 처리된다. 이는 GIL이 I/O 작업 동안 다른 스레드에 제어권을 넘기기 때문.
...</p></div><footer class=entry-footer><span title='2024-11-24 08:18:00 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;646 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python GIL" href=https://buenhyden.github.io/posts/programming-languages/python/concepts/python-gil/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docstring</h2></header><div class=entry-content><p>Docstring python에서 함수, 클래스, 모듈에 대한 문서화를 위해 사용되는 문자열.
이는 코드의 가독성을 높이고 다른 개발자들이 코드를 이해하는 데 도움을 준다.
주요 특징:
큰따옴표 세 개(""") 또는 작은따옴표 세 개(’’’)로 둘러싸인 문자열입니다. 함수, 클래스, 모듈의 첫 번째 문장으로 위치합니다. __doc__ 속성을 통해 프로그램 실행 중에 접근할 수 있습니다. 내장 함수 help()를 통해 문서를 볼 수 있습니다. 기능:
코드의 목적과 동작을 설명합니다. 함수의 매개변수, 반환값, 예외 등을 문서화합니다. 모듈이나 클래스의 전반적인 기능을 설명합니다. 자동 문서 생성 도구(예: Sphinx)를 통해 API 문서를 생성할 수 있습니다. 고려해야 할 중요한 점들:
...</p></div><footer class=entry-footer><span title='2024-11-24 03:07:00 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;721 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Docstring" href=https://buenhyden.github.io/posts/programming-languages/python/concepts/docstring/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로미스(Promise)</h2></header><div class=entry-content><p>프로미스(Promise) 프로미스(Promise)는 자바스크립트에서 비동기 처리를 위해 사용되는 객체이다.
프로미스(Promise)는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체이다.
이는 비동기 처리를 동기적으로 처리할 수 있게 해주며, 콜백 함수의 단점을 보완한다.
프로미스(Promise)의 상태 프로미스(Promise)는 세 가지 상태를 가진다.
대기(Pending): 초기 상태, 비동기 처리 로직이 아직 완료되지 않은 상태 이행(Fulfilled): 비동기 처리가 성공적으로 완료되어 프로미스(Promise)가 결과 값을 반환한 상태 거부(Rejected): 비동기 처리가 실패하거나 오류가 발생한 상태 Promise 생성자와 Executor 함수의 기본 구조 프로미스(Promise)는 new Promise() 생성자를 통해 생성된다.
Promise를 생성할 때는 다음과 같은 구조를 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-21 14:54:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;979 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로미스(Promise)" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/promise/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/concepts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>