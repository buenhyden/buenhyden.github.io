<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Architecture Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Architecture Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Architecture Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Layered Pattern</h2></header><div class=entry-content><p>Layered Pattern 레이어드 패턴(Layered Pattern)은 소프트웨어 아키텍처에서 가장 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 구성 요소를 수평적 계층으로 조직화하여 각 계층이 특정 기능을 담당하도록 한다.
주요 계층의 역할과 책임 ![Layered architecture pattern](sapr_0101.png “https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html_
일반적으로 레이어드 아키텍처는 다음과 같은 4개의 표준 계층으로 구성된다:
프레젠테이션 계층 (Presentation Layer): 사용자 또는 외부 시스템과의 상호작용을 담당합니다 입력 데이터의 기본적인 유효성 검사를 수행합니다 응답 데이터를 적절한 형식으로 변환합니다 REST API, 웹 인터페이스, CLI 등의 형태로 구현될 수 있습니다 비즈니스 계층 (Business Layer): 핵심 비즈니스 로직을 구현합니다 트랜잭션 관리를 담당합니다 도메인 객체들의 상태를 조작합니다 비즈니스 규칙을 검증합니다 도메인 계층 (Domain Layer): 비즈니스 도메인의 핵심 개념을 표현합니다 도메인 객체들의 상태와 행위를 정의합니다 비즈니스 규칙을 캡슐화합니다 특정 기술에 독립적입니다 데이터 접근 계층 (Data Access Layer): 데이터의 영속성을 관리합니다 데이터베이스나 외부 시스템과의 통신을 담당합니다 CRUD 작업을 추상화합니다 데이터 매핑을 처리합니다 작은 애플리케이션의 경우 3개 계층으로, 복잡한 애플리케이션은 5개 이상의 계층으로 구성될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-21 08:26:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1000 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Layered Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/layered-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Publisher-Subscriber Pattern</h2></header><div class=entry-content><p>Publisher-Subscriber Pattern Publisher-Subscriber Pattern(게시자-구독자 패턴)은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 분산 시스템에서 비동기 통신을 구현하는 데 널리 사용된다.
이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.
이 패턴은 컴포넌트 간의 느슨한 결합을 제공하여 확장성과 유연성을 높이는 데 기여한다.
https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber
기본 개념 Publisher-Subscriber 패턴의 핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-20 11:40:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publisher-Subscriber Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event Sourcing Pattern</h2></header><div class=entry-content><p>Event Sourcing Pattern Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.
https://www.geeksforgeeks.org/event-sourcing-pattern/
주요 개념 이벤트 기반 데이터 저장
Event Sourcing은 데이터의 최종 상태만을 저장하는 대신, 모든 변경 사항을 이벤트로 기록한다.
예를 들어, 주문 시스템에서 “주문 생성”, “아이템 추가”, “주문 완료” 등의 이벤트가 순차적으로 저장된다.
이벤트 스토어
모든 이벤트는 추가 전용(append-only) 로그인 이벤트 스토어에 순차적으로 저장된다.
이 스토어는 시스템의 권위 있는 데이터 소스 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-11-20 11:17:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;697 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Sourcing Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CQRS 패턴 (Command Query Responsibility Segregation)</h2></header><div class=entry-content><p>CQRS 패턴 (Command Query Responsibility Segregation) 애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴
이 패턴은 데이터를 변경하는 작업과 데이터를 읽는 작업을 별도의 모델로 분리하여 처리한다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from dataclasses import dataclass from datetime import datetime from typing import List, Optional # 도메인 모델 @dataclass class Product: id: str name: str price: float stock: int created_at: datetime updated_at: datetime # Command 모델 (쓰기 작업) @dataclass class CreateProductCommand: name: str price: float stock: int @dataclass class UpdateProductStockCommand: product_id: str stock: int # Query 모델 (읽기 작업) @dataclass class ProductDetailsQuery: product_id: str @dataclass class ProductListQuery: page: int page_size: int # Command 핸들러 (쓰기 작업 처리) class ProductCommandHandler: def __init__(self, command_db): self.command_db = command_db def handle_create_product(self, command: CreateProductCommand) -> str: product = Product( id=generate_id(), name=command.name, price=command.price, stock=command.stock, created_at=datetime.now(), updated_at=datetime.now() ) self.command_db.save(product) # 이벤트 발행 (읽기 데이터베이스 동기화를 위함) publish_event("ProductCreated", product) return product.id def handle_update_stock(self, command: UpdateProductStockCommand): product = self.command_db.get_by_id(command.product_id) if not product: raise ValueError("Product not found") product.stock = command.stock product.updated_at = datetime.now() self.command_db.update(product) publish_event("ProductStockUpdated", product) # Query 핸들러 (읽기 작업 처리) class ProductQueryHandler: def __init__(self, query_db): self.query_db = query_db def handle_product_details(self, query: ProductDetailsQuery) -> Optional[Product]: return self.query_db.get_by_id(query.product_id) def handle_product_list(self, query: ProductListQuery) -> List[Product]: return self.query_db.get_page(query.page, query.page_size) # API 레이어 class ProductAPI: def __init__(self, command_handler: ProductCommandHandler, query_handler: ProductQueryHandler): self.command_handler = command_handler self.query_handler = query_handler def create_product(self, name: str, price: float, stock: int) -> str: command = CreateProductCommand(name=name, price=price, stock=stock) return self.command_handler.handle_create_product(command) def update_stock(self, product_id: str, stock: int): command = UpdateProductStockCommand(product_id=product_id, stock=stock) self.command_handler.handle_update_stock(command) def get_product(self, product_id: str) -> Optional[Product]: query = ProductDetailsQuery(product_id=product_id) return self.query_handler.handle_product_details(query) def list_products(self, page: int, page_size: int) -> List[Product]: query = ProductListQuery(page=page, page_size=page_size) return self.query_handler.handle_product_list(query) 주요 구성 요소 https://junuuu.tistory.com/891
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS 패턴 (Command Query Responsibility Segregation)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Repository Pattern</h2></header><div class=entry-content><p>Repository Pattern 리포지토리 패턴(Repository Pattern)은 데이터 접근 로직을 추상화하고 캡슐화하여 비즈니스 로직과 데이터 저장소 간의 의존성을 줄이는 소프트웨어 아키텍처 패턴.
이 패턴은 데이터의 저장, 검색 및 관리를 위한 일관된 인터페이스를 제공한다.
주요 개념 추상화: 데이터 접근 로직을 추상화하여 비즈니스 로직이 데이터 저장소의 구체적인 구현에 의존하지 않도록 합니다. 캡슐화: CRUD(Create, Read, Update, Delete) 작업을 캡슐화하여 데이터 접근의 복잡성을 숨깁니다. 중앙 집중화: 데이터 접근 로직을 중앙에서 관리하여 코드 중복을 줄이고 일관성을 유지합니다. 구조 ![](repository-aggregate-database-table-relationships.png “https://tech.buzzvil.com/handbook/repository/ _
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1057 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Repository Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-architecture-patterns/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/software-architecture-patterns/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>