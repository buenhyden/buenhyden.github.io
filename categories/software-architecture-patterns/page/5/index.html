<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Architecture Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Architecture Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Architecture Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Microkernel Architecture</h2></header><div class=entry-content><p>Microkernel Architecture 마이크로커널 패턴(Microkernel Pattern)은 소프트웨어 아키텍처 패턴 중 하나로, 시스템의 핵심 기능을 최소화하고 확장성과 유연성을 극대화하는 설계 방식.
이 패턴은 때로 ‘플러그인 아키텍처’라고도 불린다.
핵심 구성요소 https://www.alibabacloud.com/blog/what-is-microkernel-architecture-design_597605
마이크로커널(Core System):
시스템의 가장 기본적이고 필수적인 기능만을 포함합니다 확장 기능과 통신하기 위한 인터페이스를 제공합니다 플러그인의 생명주기를 관리합니다 이벤트나 메시지를 통해 플러그인과 통신합니다 플러그인 인터페이스:
플러그인이 구현해야 하는 표준 인터페이스를 정의합니다 커널과 플러그인 간의 계약을 명시합니다 일관된 확장 방식을 제공합니다 플러그인(Extensions):
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;898 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Microkernel Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hexagonal Architecture</h2></header><div class=entry-content><p>Hexagonal Architecture 헥사고날 아키텍처(Hexagonal Architecture)는 소프트웨어 설계 패턴 중 하나로, 애플리케이션의 핵심 비즈니스 로직을 외부 요소로부터 분리하여 유연하고 유지보수가 용이한 시스템을 구축하는 것을 목표로 한다.
이 아키텍처는 Alistair Cockburn에 의해 제안되었으며, ‘포트와 어댑터 아키텍처(Ports and Adapters Architecture)‘라고도 불린다.
핵심 원칙 의존성 방향:
모든 의존성은 도메인 계층을 향해 안쪽으로 흐른다.
도메인 계층은 외부를 전혀 알지 못하며, 포트를 통해서만 통신한다. 관심사의 분리:
각 계층은 명확한 책임을 가지며, 다른 계층의 구현 세부사항을 알지 못한다.
이는 시스템의 유지보수성과 테스트 용이성을 향상시킨다. 인터페이스 기반 설계:
포트는 인터페이스로 정의되어, 구체적인 구현체(어댑터)를 쉽게 교체할 수 있게 한다. 주요 구성 요소 ![](1682416486628.png “https://www.linkedin.com/pulse/whats-hexagonal-architecture-luis-soares-m-sc-/ _
...</p></div><footer class=entry-footer><span title='2024-09-25 08:29:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;827 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hexagonal Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Blackboard Pattern</h2></header><div class=entry-content><p>Blackboard Pattern Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴.
이 패턴은 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.
기본 개념은 실제 교실의 칠판과 매우 유사하다.
여러 전문가들이 함께 모여 칠판에 정보를 공유하고, 문제를 해결해나가는 과정을 소프트웨어 아키텍처로 구현한 것.
Blackboard 패턴은 다음과 같은 상황에서 특히 유용하다:
명확한 해결 알고리즘이 없는 복잡한 문제 여러 전문 분야의 지식이 필요한 문제 다양한 해결 접근 방식을 시도해볼 필요가 있는 경우 Blackboard 패턴은 다음과 같은 분야에서 주로 사용된다:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blackboard Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Broker Pattern</h2></header><div class=entry-content><p>Broker Pattern 이 패턴은 클라이언트와 서버 간의 직접적인 상호작용을 줄이고, 브로커라는 중개자를 통해 통신을 관리한다.
이를 통해 시스템의 유연성 및 확장성을 높이고, 다양한 서비스가 서로 원활하게 협력할 수 있도록 한다.
다음과 같은 상황에서 사용된다:
분산 시스템: 여러 컴포넌트가 서로 다른 위치에 존재하며, 원격 서비스 호출을 통해 상호작용할 필요가 있는 경우. 서비스의 캡슐화: 클라이언트가 서비스의 구체적인 구현이나 위치를 알 필요 없이 요청할 수 있도록 하여, 시스템의 복잡성을 줄인다. 동적 구성: 런타임에 컴포넌트를 추가하거나 교체할 수 있어 시스템의 유연성을 제공한다. 장점 느슨한 결합(Loose Coupling): 클라이언트와 서버가 서로를 직접 알 필요가 없어 시스템의 유연성이 증가합니다. 확장성: 새로운 서버나 서비스를 쉽게 추가할 수 있습니다. 중앙화된 관리: 보안, 로깅, 로드 밸런싱 등을 중앙에서 처리할 수 있습니다. 시스템 독립성: 다른 플랫폼이나 언어로 작성된 컴포넌트들도 브로커를 통해 통신할 수 있습니다. 실제 활용 사례 메시지 큐 시스템: Apache Kafka, RabbitMQ 등 마이크로서비스 아키텍처의 API 게이트웨이 IoT 시스템의 메시지 브로커 클라우드 서비스의 로드 밸런서 주의할 점 브로커가 단일 실패 지점(Single Point of Failure)이 될 수 있습니다. 브로커를 통한 간접 통신으로 인해 약간의 성능 오버헤드가 발생할 수 있습니다. 시스템의 복잡성이 증가할 수 있습니다. 작동 방식 서버 등록: 서버는 자신의 기능과 서비스를 브로커에 등록합니다. 서비스 요청: 클라이언트는 브로커에 특정 서비스 요청을 보냅니다. 요청 전달: 브로커는 클라이언트의 요청을 적절한 서버로 전달합니다. 응답 반환: 서버는 요청을 처리한 후 결과를 브로커에 반환하고, 브로커는 이 결과를 다시 클라이언트에게 전달합니다. 주요 구성요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;408 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Broker Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-Bus Pattern</h2></header><div class=entry-content><p>Event-Bus Pattern 소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴이다.
이 패턴은 발행-구독(Publish-Subscribe) 모델을 기반으로 하며, 컴포넌트 간의 느슨한 결합을 촉진한다.
장점 느슨한 결합: 컴포넌트 간 직접적인 의존성이 줄어들어 시스템의 유연성이 향상된다. 확장성: 새로운 컴포넌트를 쉽게 추가하거나 제거할 수 있어 시스템 확장이 용이한다. 비동기 통신: 이벤트 기반의 비동기 통신으로 시스템의 반응성과 성능이 향상된다. 단순화된 통신: 복잡한 컴포넌트 간 통신 로직을 단순화할 수 있다. 단점 복잡성 증가: 시스템 전체의 흐름을 파악하기 어려울 수 있다. 메모리 사용 증가: 모든 구독자에게 이벤트가 전달되므로 메모리 사용량이 증가할 수 있다. 디버깅의 어려움: 비동기적 특성으로 인해 문제 추적이 어려울 수 있다. 핵심 구성요소 https://medium.com/elixirlabs/event-bus-implementation-s-d2854a9fafd5 Event Bus with multiple subscribers(green arrows) and notifiers(red arrows)
...</p></div><footer class=entry-footer><span title='2024-09-25 08:28:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Bus Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-architecture-patterns/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/software-architecture-patterns/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>