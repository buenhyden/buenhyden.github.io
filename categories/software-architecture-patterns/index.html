<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Architecture Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Architecture Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Architecture Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MVC pattern vs MVVC pattern vs MVP pattern</h2></header><div class=entry-content><p>MVC Pattern vs. MVVC Pattern vs. MVP Pattern MVC, MVP, MVVM 아키텍처 패턴은 모두 관심사 분리(SoC) 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.
MVC (Model-View-Controller) ▫ 구조 구성 요소 역할 Model 데이터 저장/비즈니스 로직 처리 View UI 표시 (사용자 입력 수신) Controller 입력 처리 → Model 업데이트 → View 갱신 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스 class UserView: def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Controller: Model과 View 사이의 중재자 class UserController: def __init__(self, model, view): self.model = model self.view = view def display_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Controller → Model Model → Controller → View 특징: View가 Model 직접 참조 가능 장점: 구조 단순, 학습 곡선 낮음 단점: View-Model 강결합 → 대규모 프로젝트 시 복잡성 증가 ▫ 사용 사례 웹 프레임워크(Spring MVC, Ruby on Rails) 간단한 데스크톱 애플리케이션 MVP (Model-View-Presenter) ▫ 구조 구성 요소 역할 Model 데이터 및 비즈니스 로직 View UI 표시 (수동적, Presenter에 이벤트 전달) Presenter View-Model 중재, UI 로직 처리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # View: 사용자 인터페이스와 이벤트 처리 class UserView: def __init__(self, presenter): self.presenter = presenter def show_user(self, user_data): print(f"사용자 정보: {user_data}") # Presenter: View와 Model 사이의 중재자 class UserPresenter: def __init__(self, view, model): self.view = view self.model = model def load_user(self): user = self.model.get_user_data() self.view.show_user(user) ▫ 데이터 흐름 1 2 사용자 → View → Presenter ↔ Model Model → Presenter → View 특징: View-Model 완전 분리 장점: 테스트 용이성 ↑ (Presenter 단독 테스트 가능) 단점: View-Presenter 1:1 관계 → 코드량 증가 ▫ 사용 사례 Windows Forms, Android 앱 복잡한 UI 로직이 필요한 프로젝트 MVVM (Model-View-ViewModel) ▫ 구조 구성 요소 역할 Model 데이터 소스 관리 View UI 및 데이터 바인딩 ViewModel View 상태 추상화, 데이터 변환 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Model: 데이터와 비즈니스 로직 class UserModel: def get_user_data(self): return {"name": "홍길동", "age": 30} # ViewModel: View를 위한 Model의 데이터 변환과 상태 관리 class UserViewModel: def __init__(self, model): self.model = model self.user_data = None def fetch_user(self): self.user_data = self.model.get_user_data() # 데이터 바인딩을 통해 View가 자동으로 업데이트됨 # View: 사용자 인터페이스 class UserView: def __init__(self, view_model): self.view_model = view_model # 데이터 바인딩 설정 ▫ 데이터 흐름 1 2 사용자 → View → ViewModel ↔ Model Model → ViewModel → View (자동 갱신) 특징: 데이터 바인딩으로 자동 동기화 장점: 재사용성 ↑, 양방향 데이터 흐름 단점: 초기 설정 복잡, 과도한 추상화 가능성 ▫ 사용 사례 WPF, Angular, React, Vue.js 실시간 데이터 업데이트 필요 애플리케이션 패턴 비교 특성 MVC MVVM MVP 데이터 흐름 Controller → Model ↔ View ViewModel ↔ Model, View ↔ ViewModel Presenter → Model, View ↔ Presenter View와 Model의 관계 직접 참조 가능 완전 분리 완전 분리 중간 계층의 역할 Controller가 입력 처리 ViewModel이 상태와 데이터 변환 관리 Presenter가 View 상태와 이벤트 처리 테스트 용이성 보통 좋음 매우 좋음 코드 복잡도 낮음 높음 중간 주요 사용처 웹 애플리케이션 데스크톱/모바일 앱 복잡한 UI 애플리케이션 데이터 바인딩 수동 자동 수동 UI 의존성 높음 낮음 매우 낮음 패턴 선택 가이드 MVC: 빠른 프로토타이핑, 간단한 웹 앱 MVP: Android 앱, UI 테스트 강조 환경 MVVM: 복잡한 데이터 플로우, 재사용성 요구 시 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 01:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MVC pattern vs MVVC pattern vs MVP pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Software Architecture Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern 주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.
https://blog.bytebytego.com/p/software-architecture-patterns
패턴 이름 핵심 개념 주요 구성요소 특징 장점 단점 활용 사례 Monolithic Pattern 단일 실행 파일로 구성된 전통적인 아키텍처 - 단일 코드베이스
- 단일 데이터베이스
- 통합된 비즈니스 로직 - 모든 기능이 하나의 프로세스로 실행
- 강한 결합도
- 단순한 배포 구조 - 개발 단순성
- 쉬운 테스트
- 성능 최적화 용이 - 확장성 제한
- 유지보수 어려움
- 기술 스택 제한 - 작은 규모 애플리케이션
- 프로토타입
- 단순한 비즈니스 로직 Layered Pattern 관심사의 수직적 분리를 통한 계층화 - 프레젠테이션 계층
- 비즈니스 계층
- 데이터 계층
- 인프라 계층 - 계층간 단방향 의존성
- 관심사 분리
- 모듈화 - 유지보수성
- 테스트 용이성
- 역할 분리 명확 - 성능 오버헤드
- 불필요한 계층 통과
- 유연성 제한 - 엔터프라이즈 시스템
- 웹 애플리케이션
- 데이터 중심 애플리케이션 Client-Server Pattern 서비스 제공자와 소비자의 분리 - 클라이언트
- 서버
- 통신 프로토콜 - 중앙 집중식 리소스 관리
- 역할 분리
- 네트워크 기반 통신 - 리소스 중앙화
- 보안 통제 용이
- 유지보수 편의 - 서버 의존성
- 네트워크 지연
- 단일 실패점 - 웹 서비스
- 데이터베이스 시스템
- 네트워크 애플리케이션 Master-Slave Pattern 작업 분배와 결과 통합 - 마스터 노드
- 슬레이브 노드
- 작업 분배기 - 병렬 처리
- 중앙 제어
- 결과 취합 - 성능 향상
- 확장성
- 신뢰성 - 마스터 병목
- 복잡한 구현
- 오버헤드 - 데이터베이스 복제
- 병렬 컴퓨팅
- 분산 처리 Pipe-Filter Pattern 데이터 스트림 처리의 단계적 변환 - 파이프
- 필터
- 데이터 스트림 - 순차적 처리
- 단방향 데이터 흐름
- 모듈식 구성 - 재사용성
- 유연한 조합
- 병렬 처리 가능 - 데이터 형식 변환
- 처리 지연
- 리소스 소비 - ETL 프로세스
- 텍스트 처리
- 이미지 처리 Broker Pattern 분산 서비스의 조정 및 통신 - 브로커
- 클라이언트
- 서버
- 브릿지 - 서비스 중개
- 위치 투명성
- 상호운용성 - 확장성
- 유연성
- 재사용성 - 복잡성
- 성능 오버헤드
- 단일 실패점 - 메시지 큐
- 서비스 중개
- 분산 시스템 Peer-to-Peer Pattern 분산된 피어 간의 직접 통신 - 피어 노드
- 리소스 공유
- 검색 메커니즘 - 탈중앙화
- 자율성
- 리소스 공유 - 확장성
- 견고성
- 비용 효율성 - 보안 관리
- 일관성 유지
- 신뢰성 - 파일 공유
- 블록체인
- 협업 도구 Event-Bus Pattern 이벤트 기반 통신을 위한 중앙 버스 - 이벤트 버스
- 발행자
- 구독자
- 이벤트 핸들러 - 느슨한 결합
- 비동기 통신
- 다대다 통신 - 확장성
- 유연성
- 모듈성 - 디버깅 어려움
- 성능 병목
- 복잡성 - GUI 시스템
- 메시징 시스템
- 이벤트 처리 MVC Pattern 사용자 인터페이스와 비즈니스 로직의 분리 - 모델
- 뷰
- 컨트롤러 - 관심사 분리
- 데이터와 표현 분리
- 재사용성 - 유지보수성
- 병렬 개발
- 유연성 - 복잡성
- 오버헤드
- 학습 곡선 - 웹 애플리케이션
- 데스크톱 앱
- 모바일 앱 Microservices Pattern 독립적으로 배포 가능한 작은 서비스들의 집합 - 서비스
API 게이트웨이
- 서비스 레지스트리 - 서비스 독립성
- 분산 데이터 관리
- 자동화된 배포 - 확장성
- 기술 다양성
- 장애 격리 - 분산 복잡성
- 운영 부담
- 일관성 관리 - 대규모 시스템
- 클라우드 네이티브
- 확장 가능 서비스 Hexagonal Architecture 포트와 어댑터를 통한 외부 시스템 격리 - 도메인 코어
- 포트
- 어댑터 - 의존성 역전
- 도메인 중심
- 테스트 용이성 - 유지보수성
- 테스트 용이
- 유연성 - 복잡성
- 학습 곡선
- 초기 개발 시간 - 비즈니스 애플리케이션
- 도메인 중심 설계
- 레거시 현대화 Space-Based Architecture 메모리 내 데이터 그리드 기반 확장 - 처리 유닛
- 가상 미들웨어
- 데이터 그리드 - 선형 확장성
- 인메모리 처리
- 고가용성 - 성능
- 확장성
- 응답성 - 복잡성
- 비용
- 데이터 일관성 - 고성능 시스템
- 실시간 처리
- 대규모 트래픽 Microkernel Architecture 플러그인 기반의 확장 가능한 시스템 - 코어 시스템
- 플러그인
- 확장 포인트 - 모듈식 설계
- 확장성
- 유연성 - 커스터마이징
- 유지보수성
- 안정성 - 성능 오버헤드
- 버전 관리
- 통합 복잡성 - IDE
- 브라우저
- 플러그인 기반 시스템 CQRS 읽기와 쓰기 모델의 분리 - 명령 모델
- 쿼리 모델
- 동기화 메커니즘 - 성능 최적화
- 확장성
- 복잡성 관리 - 성능
- 확장성
- 유연성 - 복잡성
- 일관성 관리
- 학습 곡선 - 고성능 시스템
- 복잡한 도메인
- 이벤트 소싱 Domain-Driven Design 복잡한 도메인의 모델링과 설계 - 도메인 모델
- 바운디드 컨텍스트
- 애그리게잇 - 도메인 중심
- 유비쿼터스 언어
- 컨텍스트 경계 - 비즈니스 정렬
- 복잡성 관리
- 명확한 경계 - 학습 곡선
- 초기 투자
- 오버엔지니어링 - 복잡한 비즈니스
- 대규모 시스템
- 도메인 중심 시스템 Repository Pattern 데이터 접근 계층의 추상화 - 리포지토리
- 엔티티
- 데이터 매퍼 - 데이터 접근 추상화
- 영속성 로직 분리
- 테스트 용이성 - 유지보수성
- 테스트 용이
- 코드 재사용 - 추가 계층
- 복잡성
- 성능 영향 - 데이터 중심 앱
ORM 시스템
- 엔터프라이즈 앱 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-26 05:46:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/software-architecture-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>멀티 테넌시(Multi-tenancy)</h2></header><div class=entry-content><p>멀티 테넌시(Multi-tenancy) 멀티 테넌시(Multi-tenancy)는 소프트웨어 아키텍처의 한 형태로, 단일 소프트웨어 인스턴스가 여러 사용자 그룹(테넌트)에게 서비스를 제공하는 구조를 말한다. 즉, 하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.
각 테넌트는 공통 인프라를 공유하면서도 자신만의 독립된 환경을 가진 것처럼 작동한다.
주요 특징:
단일 인스턴스로 여러 사용자 그룹 서비스 데이터와 구성의 논리적 분리 각 테넌트에 대한 개별화된 사용자 경험 제공 https://www.linkedin.com/pulse/saas-architecture-right-way-sk-reddy-2ozuc/
멀티 테넌시의 유형 멀티 테넌시는 다양한 형태로 구현될 수 있다:
단일 인스턴스, 단일 데이터베이스: 모든 테넌트가 동일한 애플리케이션 인스턴스와 데이터베이스를 공유한다. 비용 효율적이지만 확장성에 제한이 있을 수 있다. 단일 인스턴스, 다중 데이터베이스: 애플리케이션 인스턴스는 공유하지만 각 테넌트가 별도의 데이터베이스를 가진다. 데이터 격리 수준이 높아진다. 다중 인스턴스, 다중 데이터베이스: 각 테넌트가 독립된 애플리케이션 인스턴스와 데이터베이스를 가진다. 가장 높은 수준의 격리를 제공하지만 비용이 증가한다. 멀티 테넌시의 장점 비용 효율성: 인프라와 리소스를 공유함으로써 개발, 유지보수, 운영 비용을 절감할 수 있다. 효율적인 리소스 관리: 여러 고객이 동일한 인프라를 공유하므로 리소스 활용도가 높아진다. 간편한 업데이트와 유지보수: 단일 인스턴스를 업데이트하면 모든 테넌트에게 동시에 적용되어 관리가 용이하다. 확장성: 사용자 수나 데이터 양이 증가할 때 쉽게 확장할 수 있다. 데이터 통합 용이성: 모든 테넌트의 데이터가 중앙 집중화되어 있어 분석과 인사이트 도출이 용이하다. 멀티 테넌시의 단점과 과제 보안과 데이터 격리: 여러 테넌트의 데이터가 공존하므로 데이터 유출 위험이 있다. 철저한 보안 조치가 필요하다. 복잡한 아키텍처: 개인화와 데이터 격리를 위해 복잡한 설계가 필요하다. 성능 관리: 한 테넌트의 과도한 리소스 사용이 다른 테넌트에게 영향을 줄 수 있다. 규정 준수: 다양한 테넌트의 데이터를 처리할 때 각종 법적 규정과 프라이버시 요구사항을 준수해야 한다. 커스터마이징의 한계: 각 테넌트별로 세부적인 커스터마이징에 제한이 있을 수 있다. 멀티 테넌시 구현 시 고려사항 데이터 모델 설계: 테넌트 간 데이터 격리를 위한 효과적인 데이터 모델 설계가 필요하다. 보안 메커니즘: 강력한 인증, 권한 부여, 암호화 등의 보안 메커니즘 구현이 중요하다. 확장성 계획: 테넌트 수와 데이터 양 증가에 대비한 확장 계획을 수립해야 한다. 성능 모니터링: 각 테넌트의 리소스 사용량을 모니터링하고 최적화하는 시스템이 필요하다. 백업 및 복구 전략: 테넌트별 데이터 백업 및 복구 전략을 수립해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 14:06:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멀티 테넌시(Multi-tenancy)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/multi-tenancy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting Pattern</h2></header><div class=entry-content><p>Rate Limiting Pattern “Rate Limiting Pattern"은 소프트웨어 아키텍처에서 서비스의 과도한 사용을 방지하고 자원을 공정하게 분배하기 위한 핵심 전략이다.
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.
Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.
주로 다음 목적을 위해 사용된다:
서비스 장애 예방: DDoS 공격, API 오용, 리소스 고갈 방지. 비용 관리: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지. 공정한 자원 분배: 특정 사용자가 시스템을 독점하지 않도록 제어. 예시:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/rate-limiting-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Publisher-Subscriber Pattern</h2></header><div class=entry-content><p>Publisher-Subscriber Pattern Publisher-Subscriber Pattern(게시자-구독자 패턴)은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 분산 시스템에서 비동기 통신을 구현하는 데 널리 사용된다.
이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.
이 패턴은 컴포넌트 간의 느슨한 결합을 제공하여 확장성과 유연성을 높이는 데 기여한다.
https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber
기본 개념 Publisher-Subscriber 패턴의 핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-27 11:40:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publisher-Subscriber Pattern" href=https://buenhyden.github.io/posts/system-design/cloud-design-patterns/messaging/publisher-subscriber/publisher-subscriber-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.
네트워크 불안정, 일시적인 서비스 중단 등 일시적인 실패 상황에서 시스템의 복원력(Resilience)을 강화하는 데 목적을 둔다.
이 패턴은 분산 시스템의 안정성을 높이는 필수 도구이지만, 남용할 경우 역효과를 낼 수 있으므로 신중한 정책 수립이 필요하다.
Retry Pattern의 핵심 개념 작동 원리
실패한 작업 자동 재시도: API 호출, 데이터베이스 접근 등 실패 가능성이 있는 작업을 정의된 정책에 따라 재시도한다. 일시적 오류 감지: 네트워크 타임아웃, HTTP 5xx 에러, 데이터베이스 연결 실패 등 일시적인 오류만 대상으로 한다. 주요 구성 요소
...</p></div><footer class=entry-footer><span title='2024-09-27 11:31:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/system-design/reliability-patterns/resiliency/retry/retry-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model-View-ViewModel Pattern</h2></header><div class=entry-content><p>Model-View-ViewModel Pattern MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.
이 패턴은 MVC(Model-View-Controller) 패턴의 발전된 형태로 볼 수 있다.
MVVM 패턴은 복잡한 UI 애플리케이션 개발에 특히 유용하며, 대규모 프로젝트에서 코드의 구조화와 관리를 용이하게 한다.
https://learn.microsoft.com/ko-kr/dotnet/architecture/maui/mvvm
MVVM의 구성 요소 MVVM 패턴은 세 가지 주요 구성 요소로 이루어져 있다:
모델(Model): 데이터와 비즈니스 로직을 담당한다. 데이터베이스나 웹 서비스와의 통신을 통해 데이터를 가져오거나 저장하는 역할을 한다. 뷰(View): 사용자 인터페이스(UI)를 담당한다. 데이터를 표시하고 사용자 입력을 받아 ViewModel에 전달한다. 버튼, 텍스트 박스 등 화면에 표시되는 모든 요소를 포함하며, 사용자와의 상호작용을 처리한다. 뷰모델(ViewModel): 뷰와 모델 사이의 중재자 역할을 한다. 뷰에서 보여지는 데이터와 이를 조작하는 메서드, 상태를 포함한다. MVVM의 핵심 개념 데이터 바인딩: MVVM의 핵심 아이디어는 뷰와 뷰모델 사이에 양방향 데이터 바인딩을 통해 자동 업데이트를 가능하게 하는 것이다. 이를 통해 뷰와 뷰모델 사이의 데이터 동기화가 자동으로 이루어진다. 명령(Command): 버튼 클릭과 같은 사용자 액션을 뷰모델에서 처리하기 위한 메커니즘이다. 뷰모델은 ICommand 인터페이스를 구현하여 뷰에서 발생하는 이벤트를 처리한다. 의존성 관리: 뷰모델을 중재자로 사용하여 뷰와 모델 사이의 의존성을 해결한다. 이로 인해 뷰와 모델의 결합도가 낮아진다. 테스트 용이성: 뷰와 모델이 분리되어 있어 각 구성 요소를 독립적으로 테스트하기 쉽다. MVVM의 장점 유지보수성 향상: UI와 비즈니스 로직이 분리되어 있어 코드의 유지보수가 용이하다. 재사용성 증가: 뷰모델은 여러 뷰에서 재사용될 수 있다. 자동 업데이트: 데이터 바인딩을 통해 뷰모델의 상태 변화가 자동으로 UI에 반영된다. 개발 효율성: 개발자는 데이터 변경에 직접 관여하지 않고, 뷰모델을 통해 데이터를 조작하고 업데이트할 수 있어 코드의 복잡성이 줄어든다. MVVM 구현 예시 다음은 간단한 카운터 애플리케이션의 MVVM 구현 예시
...</p></div><footer class=entry-footer><span title='2024-09-27 11:26:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model-View-ViewModel Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/model-view-viewmodel-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Model–view–presenter Pattern</h2></header><div class=entry-content><p>Model–view–presenter Pattern Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, 관심사 분리 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.
MVC 패턴에서 파생되었으며, 주로 Windows Forms, ASP.NET, Java Swing 애플리케이션에서 활용된다.
이 패턴은 1990년대 Taligent사에서 처음 도입되었으며, 현재까지 엔터프라이즈급 애플리케이션에서 구조적 안정성을 제공하는 핵심 아키텍처로 자리잡았다. UI 복잡도가 높은 프로젝트에서 체계적인 관리를 원한다면 MVP 구현을 적극 고려해볼 만하다.
https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/
핵심 구성 요소 Model: 데이터 저장/관리 및 비즈니스 로직 처리 담당. 데이터베이스 연동, API 통신, 캐싱 기능 수행. UI와 독립적으로 동작하여 재사용성 향상. View: 사용자 인터페이스 표시 및 입력 이벤트 전달. 수동적(passive)으로 Presenter에 이벤트 전송. 데이터 표시 형식만 관리(예: 텍스트 박스 값 표시). Presenter: Model과 View의 중재자 역할. 사용자 입력 처리 → Model 업데이트 → 변경 사항 View 반영. 복잡한 UI 로직 캡슐화로 테스트 용이성 증대. 작동 메커니즘 사용자가 View와 상호작용하여 이벤트를 발생시킨다(예: 로그인). View → Presenter에 이벤트 전달 Presenter가 Model에서 데이터 검증/처리 처리 결과를 View에 반영(예: “로그인 성공” 메시지 표시) 주요 장점 유지보수성 향상:
...</p></div><footer class=entry-footer><span title='2024-09-27 09:10:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model–view–presenter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/model-view-controller/modelviewpresenter-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/master-slave-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pipe-Filter Pattern</h2></header><div class=entry-content><p>Pipe-Filter Pattern 파이프-필터 패턴(Pipe-Filter Pattern)은 데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 복잡한 처리 과정을 독립적인 단계로 나누어 모듈화하고, 이들을 순차적으로 연결하여 데이터를 처리한다.
주요 구성 요소 필터(Filter):
단일 작업을 수행하는 처리 컴포넌트입니다 입력을 받아 처리하고 출력을 생성합니다 독립적으로 동작하며 다른 필터에 대해 알지 못합니다 재사용이 가능하고 조합할 수 있어야 합니다 파이프(Pipe):
필터 간의 데이터 전달을 담당합니다 데이터 버퍼링과 동기화를 처리합니다 필터들을 느슨하게 결합시킵니다 대개 큐나 스트림으로 구현됩니다 파이프라인(Pipeline):
...</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-Filter Pattern" href=https://buenhyden.github.io/posts/system-design/cloud-design-patterns/messaging/pipes-and-filters/pipe-filter-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/software-architecture-patterns/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>