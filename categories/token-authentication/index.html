<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Token Authentication | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/token-authentication/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/token-authentication/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/token-authentication/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/token-authentication/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Token Authentication"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Token Authentication"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Token Authentication</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-saml/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. JWT</h2></header><div class=entry-content><p>Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.
기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. JWT" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-jwt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OAuth</h2></header><div class=entry-content><p>Token Authentication vs. OAuth 2.0 토큰 인증(Token Authentication)과 OAuth 2.0은 모두 사용자 인증 및 권한 부여를 처리하는 기술이지만, 목적과 구현 방식에 있어 중요한 차이점을 가지고 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자가 자격 증명(일반적으로 사용자 이름과 비밀번호)을 한 번 제공한 후, 서버가 생성한 토큰을 사용하여 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 토큰 인증의 핵심 아이디어는 사용자의 자격 증명을 한 번만 확인한 후, 서버가 서명된 토큰을 발급하여 클라이언트가 이 토큰을 사용해 자신을 인증하도록 하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OAuth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-oauth-20/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OpenID Connect</h2></header><div class=entry-content><p>Token Authentication vs. OpenID Connect 현대 웹과 애플리케이션의 보안 생태계에서 인증과 권한 부여는 필수적인 요소이다. 토큰 인증(Token Authentication)과 OpenID Connect(OIDC)는 모두 이 영역에서 중요한 역할을 하지만, 목적과 기능 면에서 상당한 차이가 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 및 작동 원리 토큰 인증의 핵심 아이디어는 사용자가 로그인하면 서버가 서명된 토큰을 발급하고, 이후 모든 요청에 이 토큰을 포함시켜 사용자를 식별하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-openid-connect/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Cookie-Based Auth 토큰 인증(Token Authentication) 토큰 인증은 서버가 사용자의 인증 정보를 확인한 후 서명된 토큰을 발급하고, 클라이언트가 이 토큰을 이후의 요청에 포함시켜 자신을 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
작동 방식 사용자가 자격 증명(사용자 이름/비밀번호)을 서버에 제출한다. 서버는 자격 증명을 검증하고, 사용자 식별자와 권한 정보를 포함한 토큰을 생성한다. 서버는 비밀 키로 토큰에 서명하여 클라이언트에게 반환한다. 클라이언트는 이 토큰을 저장하고(주로 로컬 스토리지, 세션 스토리지 또는 메모리에 저장), 이후 요청의 Authorization 헤더에 포함시킨다. 서버는 토큰의 서명을 검증하고, 포함된 정보를 기반으로 사용자를 인증한다. 특징 무상태(Stateless): 서버는 클라이언트 상태 정보를 저장하지 않는다. 확장성: 여러 서버 간에 인증 정보를 공유할 필요가 없다. 플랫폼 독립적: 모바일 앱, SPA, API 등 다양한 클라이언트에서 사용 가능하다. 보안: 토큰에 서명을 통해 변조를 방지한다. 만료 시간 설정 가능: 토큰에 만료 시간을 포함할 수 있다. 쿠키 기반 인증(Cookie-Based Authentication) 쿠키 기반 인증은 서버가 사용자 인증 후 세션 ID를 포함한 쿠키를 클라이언트에 전송하고, 클라이언트가 이 쿠키를 모든 요청에 자동으로 포함시켜 인증하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:21:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-cookie-based-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Session-based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Session-based Auth 세션 기반 인증(Session-based Authentication) 세션 기반 인증은 전통적인 인증 방식으로, 서버가 사용자의 로그인 상태를 세션으로 유지하는 방식이다.
작동 원리 인증 과정: 사용자가 자격 증명(사용자 이름/비밀번호)을 제출한다. 서버는 자격 증명을 검증하고, 유효한 경우 고유한 세션 ID를 생성한다. 서버는 세션 ID와 관련 사용자 정보를 서버 측 저장소(메모리, 데이터베이스, 캐시 등)에 저장한다. 서버는 세션 ID를 클라이언트에게 쿠키로 전송한다. 클라이언트는 이후 요청 시 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키의 세션 ID를 확인하여 사용자를 식별한다. 세션 수명 주기: 세션은 사용자가 로그인할 때 생성된다. 세션은 일정 시간이 지나면 만료된다(서버 설정에 따라 다름). 사용자가 로그아웃하면 세션이 명시적으로 파기된다. 서버는 세션의 유효성과 만료를 관리한다. 주요 특징 상태 유지(Stateful): 서버가 세션 정보를 저장하고 관리한다. 쿠키 기반: 주로 HTTP 쿠키를 통해 세션 ID를 전달한다. 서버 측 저장소: 세션 데이터가 서버에 저장된다. 간단한 구현: 대부분의 웹 프레임워크에서 기본적으로 지원한다. 명시적인 세션 관리: 서버가 세션 생성, 검증, 만료, 파기를 제어한다. 토큰 인증(Token Authentication) 토큰 인증은 클라이언트에게 서명된 토큰을 발급하여 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:45:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Session-based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-session-based-auth/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>