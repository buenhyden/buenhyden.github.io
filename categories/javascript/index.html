<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/javascript/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/javascript/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/javascript/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Javascript</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ECMAScript</h2></header><div class=entry-content><p>ECMAScript ECMAScript는 자바스크립트의 표준 규격으로, Ecma International이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.
1997년 처음 표준화되었으며, 자바스크립트의 핵심 문법과 기능을 규정한다.
ECMAScript는 ECMA 인터내셔널(ECMA International)에서 제정한 스크립트 프로그래밍 언어의 표준 사양이다.
이 표준은 다양한 스크립트 언어의 상호 운용성을 보장하기 위해 만들어졌으며, JavaScript, JScript, ActionScript 등이 ECMAScript 표준을 준수한다.
ECMAScript는 1997년에 첫 번째 버전이 발표된 이후 지속적으로 발전해 왔다.
주요 버전으로는 2015년에 발표된 ECMAScript 6(ES6), 2016년의 ECMAScript 2016(ES7), 2017년의 ECMAScript 2017(ES8) 등이 있으며, 각 버전마다 새로운 기능과 개선 사항이 추가되었다.
...</p></div><footer class=entry-footer><span title='2024-12-04 17:43:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ECMAScript" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript-core/language-fundamentals/es6+/ecmascript/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript vs. Python</h2></header><div class=entry-content><p>Javascript vs. Python JavaScript와 Python은 현대 프로그래밍 세계에서 가장 인기 있는 두 언어이다.
두 언어 모두 높은 수준의 프로그래밍 언어이지만, 설계 철학, 사용 사례, 문법 등에서 중요한 차이점이 있다.
JavaScript와 Python은 각각 고유한 강점과 약점을 가진 강력한 프로그래밍 언어이다.
JavaScript는 웹 개발에서 독보적인 위치를 차지하고 있으며, 비동기 프로그래밍 모델과 빠른 실행 속도가 특징이다. Python은 가독성이 뛰어나고 데이터 과학, 기계 학습, 자동화 분야에서 뛰어난 라이브러리 지원을 제공한다.
역사와 배경 JavaScript JavaScript는 1995년 Netscape의 Brendan Eich에 의해 웹 브라우저용 스크립팅 언어로 개발되었다.
처음에는 ‘Mocha’라고 불렸으며, 나중에 ‘LiveScript’로 이름이 바뀌었고, 마지막으로 마케팅 목적으로 ‘JavaScript’라는 이름이 되었다 (Java와의 관련성은 거의 없다).
JavaScript는 웹 페이지에 상호작용성을 추가하기 위해 만들어졌으며, 시간이 지남에 따라 Node.js와 같은 플랫폼 덕분에 서버 측 개발로 확장되었다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:24:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript vs. Python" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript-core/javascript-vs-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback vs. Promise vs. Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript-core/asynchronous-programming/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Javascript Engines</h2></header><div class=entry-content><p>Javascript Engines JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램이다.
웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.
JavaScript는 원래 인터프리터 언어로 설계되었지만, 현대의 JavaScript 엔진들은 성능 향상을 위해 다양한 최적화 기술을 사용한다.
JavaScript 엔진의 주요 역할:
JavaScript 코드를 읽고 구문 분석(파싱) 코드를 기계어 또는 중간 표현으로 변환 코드 실행 메모리 관리 (가비지 컬렉션 포함) 최적화 수행 JavaScript 엔진은 현대 웹의 핵심 구성 요소로, 웹 브라우저와 서버 측 애플리케이션 모두에서 JavaScript 코드를 실행하는 데 필수적이다. Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore와 같은 주요 엔진들은 계속해서 발전하며, 성능을 향상시키고 새로운 언어 기능을 지원하고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-24 09:46:00 +0000 UTC'>February 24, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript Engines" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript-core/language-fundamentals/javascript-engines/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BunJS vs. NodeJS</h2></header><div class=entry-content><p>BunJS vs. NodeJS JavaScript는 원래 웹 브라우저에서만 실행되는 언어였지만, 서버 사이드 런타임의 등장으로 백엔드 개발에도 널리 사용되고 있다.
Node.js는 오랫동안 서버 사이드 JavaScript의 표준이었으나, Bun이라는 새로운 런타임이 등장하여 JavaScript 생태계에 변화를 가져오고 있다. 각기 다른 엔진과 설계 철학을 기반으로 개발되어 다양한 차이점을 보인다.
Node.js와 Bun은 각각 고유한 강점과 약점을 가진 JavaScript 런타임이다.
Node.js는 성숙한 생태계, 광범위한 호환성, 검증된 안정성을 제공하는 반면, Bun은 뛰어난 성능, 개선된 개발자 경험, 통합 도구를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:43:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BunJS vs. NodeJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/runtime-environments/bunjs/bunjs-vs-nodejs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Biome</h2></header><div class=entry-content><p>Biome Biome은 JavaScript, TypeScript, JSX, TSX, JSON, CSS, GraphQL 등 다양한 웹 개발 언어를 위한 빠른 포매터이자 린터이다.
Rust로 작성되어 높은 성능을 자랑하며, Prettier와 97% 호환성을 제공한다.
주요 기능 코드 포매팅(Formatting)
일관된 코드 스타일을 자동으로 적용한다. 들여쓰기, 줄 바꿈, 공백 처리 등을 자동으로 조정한다. Prettier와 유사한 결과물을 생성하지만 훨씬 빠른 속도를 보여준다. 린팅(Linting)
코드의 잠재적 문제를 미리 발견한다. 보안 취약점, 성능 이슈, 코드 스타일 위반 등을 검사한다. ESLint의 대부분의 규칙을 지원하면서도 더 빠른 처리 속도를 제공한다. 구문 분석(Parser)
...</p></div><footer class=entry-footer><span title='2024-11-21 15:19:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Biome" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/tooling-and-ecosystem/linter-and-formatter/biome/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>eslint</h2></header><div class=entry-content><p>Eslint 2013년 Nicholas C. Zakas가 만든 JavaScript 코드 분석 도구로, 코드의 품질을 향상시키고 잠재적인 문제를 미리 발견하는 것이 주요 목적이다.
정적 코드 분석을 통해 문법 오류부터 코딩 스타일까지 다양한 측면을 검사할 수 있다.
2023년 11월 3일 금요일에 릴리즈된 ESLint 8.53.0 버전에서 포맷팅 규칙이 공식적으로 폐기됨. 포맷팅 규칙은 띄어쓰기, 세미콜론, 문자열 형식 등을 아우르는 코드 컨벤션을 강화시켜 주는 규칙을 의미한다.
주요 특징 규칙 시스템
ESLint는 매우 유연한 규칙 시스템을 가지고 있다. 각 규칙은 세 가지 수준으로 설정할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-21 15:15:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to eslint" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/tooling-and-ecosystem/linter-and-formatter/eslint/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>prettier</h2></header><div class=entry-content><p>Prettier Prettier는 2017년에 출시된 “독선적인(Opinionated)” 코드 포매터.
“독선적"이라는 의미는 코드 스타일에 대한 대부분의 결정을 Prettier가 자체적으로 내린다는 뜻.
이는 개발자들 사이의 코드 스타일 논쟁을 줄이고, 일관된 코드베이스를 유지하는 데 큰 도움을 준다.
주요 특징과 장점 광범위한 언어 지원
Prettier는 다음과 같은 다양한 언어와 파일 형식을 지원한다:
JavaScript/TypeScript JSX/TSX CSS/SCSS/Less HTML JSON Markdown YAML GraphQL 최소한의 설정
Prettier는 설정 옵션을 의도적으로 제한적으로 제공한다. 이는 다음과 같은 이점이 있다:
팀 내 코드 스타일 논쟁 감소 설정 파일 관리의 단순화 프로젝트 간 일관성 유지 용이 자동 코드 재정렬
Prettier는 AST(추상 구문 트리)를 사용하여 코드를 완전히 재구성한다:
...</p></div><footer class=entry-footer><span title='2024-11-21 15:15:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to prettier" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/tooling-and-ecosystem/linter-and-formatter/prettier/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>jsdoc</h2></header><div class=entry-content><p>Jsdoc JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.
정의와 개념 JavaScript 코드에 대한 설명을 위해 사용되는 주석 시스템. /** */ 형식의 주석 안에 @로 시작하는 특별한 태그를 사용하여 정보를 제공한다. 주요 특징 API 문서 자동 생성: 주석을 기반으로 HTML 형식의 문서를 생성한다. 타입 정보 제공: 함수의 매개변수, 반환값 등의 타입을 명시할 수 있다. 코드 에디터 지원: 많은 IDE에서 JSDoc을 인식하여 자동완성, 타입 체크 등을 제공한다. 주요 태그 @param: 함수 매개변수 설명 @returns: 함수 반환값 설명 @type: 변수의 타입 지정 @typedef: 사용자 정의 타입 생성 @example: 사용 예제 제공 사용 예시 1 2 3 4 5 6 7 8 9 /** * 두 수를 더하는 함수 * @param {number} a - 첫 번째 숫자 * @param {number} b - 두 번째 숫자 * @returns {number} 두 숫자의 합 */ function add(a, b) { return a + b; } 참고 및 출처 Use JSDoc: Index
...</p></div><footer class=entry-footer><span title='2024-11-21 11:41:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jsdoc" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript-core/documentation/jsdoc/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>