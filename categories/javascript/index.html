<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/javascript/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/javascript/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/javascript/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Javascript</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2025-01-17 09:07:00 +0000 UTC'>January 17, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/til/2025/01/17/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VueJS vs ReactJS vs NextJS</h2></header><div class=entry-content><p>VueJS Vs ReactJS Vs NextJS VueJS, ReactJS, NextJS는 모두 현대적인 웹 애플리케이션을 개발하기 위한 JavaScript 기반의 프레임워크 및 라이브러리로, 각각 고유한 특징과 장단점을 가지고 있으며, 다양한 웹 개발 시나리오에 사용된다.
구분 Vue.js React.js Next.js 기본 정의 점진적이고 직관적인 JavaScript 프레임워크 유연한 JavaScript UI 라이브러리 React 기반 풀스택 웹 프레임워크 개발사 및 출시 2014년, Evan You가 개발 2013년, Facebook(현 Meta) 개발 2016년, Vercel이 개발 핵심 철학 점진적 도입이 가능한 유연한 프레임워크 선언적 UI 개발과 컴포넌트 기반 구조 React의 장점을 서버 사이드와 결합 기술적 특징 - 반응형 데이터 바인딩
- 양방향 데이터 흐름
- 컴포넌트 기반 개발 - Virtual DOM
- 단방향 데이터 흐름
JSX 문법 - SSR/SSG 지원
- 파일 기반 라우팅
- 자동 코드 분할 상태 관리 Vuex, Pinia (공식 상태 관리 도구) Redux, Context API (커뮤니티 기반) React 상태 관리 + 서버 상태 성능 최적화 - 작은 번들 크기
- 효율적인 반응형 시스템 - Virtual DOM 기반 최적화
- 메모이제이션 - 자동 이미지 최적화
- 경로 기반 코드 분할 사용 시나리오 - 중소규모 애플리케이션
- 점진적 마이그레이션
- 빠른 개발 필요 시 - 대규모 SPA
- 복잡한 UI 개발
- 커스텀 솔루션 필요 시 - SEO 중심 프로젝트
- 풀스택 애플리케이션
- 엔터프라이즈급 개발 학습 용이성 매우 낮은 진입 장벽, HTML 친화적 중간 수준, JavaScript 숙련도 필요 높은 수준, React 지식 필수 생태계 특성 공식 도구 중심의 통합된 생태계 거대하고 다양한 커뮤니티 생태계 React 생태계 + 서버 사이드 도구 개발 도구 Vue CLI, Vue DevTools Create React App, React DevTools 내장 빌드 시스템, 분석 도구 배포 특성 단순한 정적 파일 배포 가능 정적 파일 기반 배포 서버 필요, Vercel 최적화 프로젝트 확장성 중간 수준의 모듈식 확장 높은 자유도의 확장성 풀스택 확장 용이 이 세 기술은 각각의 고유한 장점과 사용 시나리오를 가지고 있다.
Vue.js는 빠른 학습과 개발이 가능하고, React.js는 유연하고 강력한 UI 개발을 지원하며, Next.js는 현대적인 웹 애플리케이션의 완벽한 솔루션을 제공한다.
프로젝트의 요구사항과 팀의 기술적 배경에 따라 적절한 선택을 하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 04:51:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VueJS vs ReactJS vs NextJS" href=https://buenhyden.github.io/til/2024/11/17/vuejs-vs-reactjs-vs-nextjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Karma</h2></header><div class=entry-content><p>Karma Karma는 모든 브라우저에서 JavaScript 코드를 테스트할 수 있게 해주는 테스트 러너이다.
Google의 AngularJS 팀이 개발했으며, 특히 브라우저 기반의 자동화된 테스트 실행에 특화되어 있다.
여러 브라우저에서 동시에 테스트를 실행하고, 실시간으로 결과를 확인할 수 있다는 점이 큰 특징이다.
정의와 목적 JavaScript 코드를 실제 브라우저에서 테스트할 수 있게 해주는 도구 개발자에게 생산적인 테스팅 환경을 제공하는 것이 주요 목적 설정과 기본 구조 Karma의 설정은 karma.conf.js 파일을 통해 이루어진다.
기본적인 설정 파일은 다음과 같은 구조를 가진다:
...</p></div><footer class=entry-footer><span title='2025-01-04 06:17:00 +0000 UTC'>January 4, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;541 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Karma" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/karma/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NextJS</h2></header><div class=entry-content><p>NextJS NextJS는 React 기반의 풀스택 웹 프레임워크로, React의 장점을 모두 활용하면서도, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)과 같은 고급 기능들을 손쉽게 구현할 수 있게 해준다.
Vercel이라는 회사에서 개발하고 있으며, production-ready 프레임워크로서 많은 대기업들이 사용하고 있다.
주요 특징과 기능을 자세히 살펴보자:
React 기반: React의 컴포넌트 기반 아키텍처를 활용한다.
정적 사이트 생성(SSG): 빌드 시 정적 페이지를 생성하여 더 빠른 로딩 속도를 제공한다.
자동 코드 분할: 페이지별로 필요한 JavaScript만 로드하여 성능을 최적화한다.
내장 CSS 지원: CSS 모듈과 styled-components를 지원한다.
...</p></div><footer class=entry-footer><span title='2024-12-24 11:42:00 +0000 UTC'>December 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;466 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NextJS" href=https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/nextjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VueJS</h2></header><div class=entry-content><p>VueJS Vue.js는 사용자 인터페이스를 구축하기 위한 진보적이고 가벼운 JavaScript 프레임워크이다.
2014년 Evan You가 개발한 이 프레임워크는 현대 웹 개발의 주요 도구 중 하나로 자리 잡았다.
또한, 점진적으로 채택할 수 있는 프레임워크라는 특징이 있다. 이는 기존 프로젝트에 Vue를 부분적으로 도입할 수 있다는 의미로, 전체 애플리케이션을 다시 작성하지 않고도 Vue의 이점을 활용할 수 있다.
기본 개념과 특징 컴포넌트 기반 아키텍처: Vue.js는 재사용 가능한 컴포넌트를 사용하여 UI를 구축한다. 이를 통해 코드의 재사용성과 유지보수성이 향상된다.
...</p></div><footer class=entry-footer><span title='2024-12-24 04:48:00 +0000 UTC'>December 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VueJS" href=https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/vuejs/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/javascript/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>