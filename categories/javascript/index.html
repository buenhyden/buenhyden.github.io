<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/javascript/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/javascript/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/javascript/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/javascript/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Javascript</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VueJS vs ReactJS vs NextJS</h2></header><div class=entry-content><p>VueJS Vs ReactJS Vs NextJS VueJS, ReactJS, NextJS는 모두 현대적인 웹 애플리케이션을 개발하기 위한 JavaScript 기반의 프레임워크 및 라이브러리로, 각각 고유한 특징과 장단점을 가지고 있으며, 다양한 웹 개발 시나리오에 사용된다.
구분 Vue.js React.js Next.js 기본 정의 점진적이고 직관적인 JavaScript 프레임워크 유연한 JavaScript UI 라이브러리 React 기반 풀스택 웹 프레임워크 개발사 및 출시 2014년, Evan You가 개발 2013년, Facebook(현 Meta) 개발 2016년, Vercel이 개발 핵심 철학 점진적 도입이 가능한 유연한 프레임워크 선언적 UI 개발과 컴포넌트 기반 구조 React의 장점을 서버 사이드와 결합 기술적 특징 - 반응형 데이터 바인딩
- 양방향 데이터 흐름
- 컴포넌트 기반 개발 - Virtual DOM
- 단방향 데이터 흐름
JSX 문법 - SSR/SSG 지원
- 파일 기반 라우팅
- 자동 코드 분할 상태 관리 Vuex, Pinia (공식 상태 관리 도구) Redux, Context API (커뮤니티 기반) React 상태 관리 + 서버 상태 성능 최적화 - 작은 번들 크기
- 효율적인 반응형 시스템 - Virtual DOM 기반 최적화
- 메모이제이션 - 자동 이미지 최적화
- 경로 기반 코드 분할 사용 시나리오 - 중소규모 애플리케이션
- 점진적 마이그레이션
- 빠른 개발 필요 시 - 대규모 SPA
- 복잡한 UI 개발
- 커스텀 솔루션 필요 시 - SEO 중심 프로젝트
- 풀스택 애플리케이션
- 엔터프라이즈급 개발 학습 용이성 매우 낮은 진입 장벽, HTML 친화적 중간 수준, JavaScript 숙련도 필요 높은 수준, React 지식 필수 생태계 특성 공식 도구 중심의 통합된 생태계 거대하고 다양한 커뮤니티 생태계 React 생태계 + 서버 사이드 도구 개발 도구 Vue CLI, Vue DevTools Create React App, React DevTools 내장 빌드 시스템, 분석 도구 배포 특성 단순한 정적 파일 배포 가능 정적 파일 기반 배포 서버 필요, Vercel 최적화 프로젝트 확장성 중간 수준의 모듈식 확장 높은 자유도의 확장성 풀스택 확장 용이 이 세 기술은 각각의 고유한 장점과 사용 시나리오를 가지고 있다.
Vue.js는 빠른 학습과 개발이 가능하고, React.js는 유연하고 강력한 UI 개발을 지원하며, Next.js는 현대적인 웹 애플리케이션의 완벽한 솔루션을 제공한다.
프로젝트의 요구사항과 팀의 기술적 배경에 따라 적절한 선택을 하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-22 04:51:00 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VueJS vs ReactJS vs NextJS" href=https://buenhyden.github.io/til/2024/11/22/vuejs-vs-reactjs-vs-nextjs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-08 09:07:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/til/2024/11/08/callback-vs-promise-vs-async-await/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NodeJS</h2></header><div class=entry-content><p>NodeJS Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경
서버 사이드에서 JavaScript를 실행할 수 있게 해주는 플랫폼으로, 웹 서버 구축부터 네트워크 프로그래밍, 일반적인 서버 사이드 프로그래밍에 이르기까지 다양한 용도로 사용된다.
런타임 환경(Runtime Environment)
프로그램이 실행되는 동안 프로그램을 위한 ‘무대’를 제공하는 시스템.
이를 연극에 비유해보면, 런타임 환경은 배우(프로그램)가 공연할 수 있는 무대, 조명, 음향 시스템 등 모든 필요한 설비를 제공하는 극장과 같다.
주요 구성 요소
메모리 관리 런타임 환경은 프로그램이 사용할 메모리를 할당하고 관리. 기본 라이브러리 제공 런타임 환경은 프로그램이 필요로 하는 기본적인 기능들을 제공. 에러 처리 프로그램 실행 중 발생하는 오류를 감지하고 관리. 하드웨어 및 운영체제와의 상호작용 프로그램과 컴퓨터 시스템 사이의 중개자 역할. 중요성
...</p></div><footer class=entry-footer><span title='2024-11-08 04:45:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;859 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS" href=https://buenhyden.github.io/til/2024/11/08/nodejs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Cypress</h2></header><div class=entry-content><p>Cypress Cypress는 JavaScript 기반의 강력한 프론트엔드 테스팅 프레임워크.
웹 애플리케이션의 엔드투엔드(E2E) 테스트를 위해 설계되었다.
주요 특징 브라우저 내 실행: Cypress는 애플리케이션과 동일한 실행 루프에서 작동하여 더 빠르고 안정적인 테스트를 가능하게 한다. 자동 대기: 요소가 나타나거나 애니메이션이 완료될 때까지 자동으로 기다려 별도의 대기 시간 설정이 필요 없다. 실시간 리로드: 테스트 파일을 저장하면 자동으로 테스트를 다시 실행한다. 디버깅 용이성: 시간 여행 디버깅, 스냅샷 기능 등을 통해 테스트 실패 원인을 쉽게 파악할 수 있다. 네트워크 트래픽 제어: 웹 트래픽을 읽고 수정할 수 있어 다양한 시나리오 테스트가 가능하다. 장점 속도와 안정성: 브라우저 내에서 직접 실행되어 빠르고 안정적인 테스트가 가능하다. 사용 편의성: 직관적인 API와 풍부한 문서를 제공하여 쉽게 학습하고 사용할 수 있다. 크로스 브라우저 테스팅: Chrome, Firefox, Edge 등 다양한 브라우저에서 테스트 가능하다. 실시간 디버깅: 테스트 실행 중 실시간으로 문제를 식별하고 디버깅할 수 있다. CI/CD 통합: 지속적 통합 및 배포 파이프라인과 쉽게 통합된다. 잠재적 한계 JavaScript/Node.js 생태계에 최적화 크로스 브라우저 지원이 제한적 모바일 웹 테스트에는 다소 제한적 사용 방법 설치: npm을 통해 Cypress를 설치한다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:53:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cypress" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/cypress/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Jest</h2></header><div class=entry-content><p>Jest Facebook에서 개발한 인기 있는 JavaScript 테스팅 프레임워크로, JavaScript 코드의 단위 테스트(Unit Test)를 위해 설계되었다.
주로 React 애플리케이션과 함께 사용되지만, Vue, Angular, Node.js 등 다양한 JavaScript 프로젝트에서도 널리 사용된다.
주요 특징 간단한 설정: 추가 설정 없이 바로 사용 가능한 “제로 구성” 철학을 따른다. 빠른 실행: 병렬 처리를 통해 테스트를 빠르게 실행한다. 모의(Mock) 기능: 복잡한 의존성을 가진 코드도 쉽게 테스트할 수 있다. 코드 커버리지: 내장된 코드 커버리지 도구를 제공한다. 스냅샷 테스팅: UI 컴포넌트의 변경사항을 쉽게 추적할 수 있다. 장점 통합된 솔루션: 테스트 러너, 단언 라이브러리, 모의 기능을 모두 제공한다. 쉬운 사용법: 직관적인 API로 테스트 작성이 용이하다. 풍부한 매처(Matcher) 함수: 다양한 비교 함수를 제공한다. 활발한 커뮤니티: 지속적인 업데이트와 지원을 받을 수 있다. 단점 및 한계 브라우저 환경 테스트의 제한: JSDOM을 사용하여 브라우저 환경을 시뮬레이션하지만, 실제 브라우저와는 차이가 있다. 학습 곡선: 고급 기능을 사용하기 위해서는 추가적인 학습이 필요할 수 있다. 설정의 복잡성: 대규모 프로젝트에서는 설정이 복잡해질 수 있다. 사용 방법 설치
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;446 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Jest" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/jest/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MochaJS</h2></header><div class=entry-content><p>MochaJS Mocha.js는 Node.js와 브라우저 환경 모두에서 동작하는 유연하고 강력한 JavaScript 코드의 단위 테스트, 통합 테스트 등을 위한 JavaScript 테스팅 프레임워크.
2011년 TJ Holowaychuk에 의해 개발되었으며, 개발자들에게 테스트 작성의 자유와 유연성을 제공한다.
주요 특징 유연한 테스트 스타일
Mocha는 다양한 어설션(assertion) 라이브러리와 함께 사용할 수 있어, 개발자의 선호에 따라 테스트 스타일을 커스터마이징할 수 있다.
대표적으로 Chai, Should.js, Expect.js 등의 라이브러리와 호환된다.
비동기 테스트 지원
비동기 코드 테스트에 특화되어 있으며, Promise, async/await, 콜백 등 다양한 비동기 패턴을 쉽게 테스트할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;566 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MochaJS" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/mochajs/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Playwright</h2></header><div class=entry-content><p>Playwright Playwright는 Microsoft에서 개발한 현대적이고 강력한 웹 자동화 및 테스팅 라이브러리.
크로스 브라우저, 크로스 플랫폼 웹 테스팅을 위해 설계되었으며, Chromium, Firefox, WebKit을 포함한 주요 브라우저들을 단일 API로 제어할 수 있다.
안정적이고 신뢰할 수 있는 E2E 테스트 환경을 제공하며, 복잡한 애플리케이션에서도 안정적으로 동작한다.
주요 특징 다중 브라우저 지원
Playwright는 다음 브라우저들을 완벽하게 지원한다:
Google Chrome Microsoft Edge Mozilla Firefox Apple Safari (WebKit)
이는 개발자들이 여러 브라우저에서 일관된 테스트를 수행할 수 있게 해준다. 최신 웹 기술 대응
현대 웹 애플리케이션의 복잡한 시나리오를 처리할 수 있는 고급 기능 제공:
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Playwright" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/playwright/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Puppeteer</h2></header><div class=entry-content><p>Puppeteer Puppeteer는 Google에서 개발한 Node.js 라이브러리로, 프로그래밍을 통해 Chrome 또는 Chromium 브라우저를 제어할 수 있게 해주는 고급 웹 자동화 도구.
기본적으로 헤드리스 모드로 실행되지만, 필요에 따라 전체 브라우저 인터페이스를 표시할 수도 있다.
Puppeteer는 브라우저 자동화의 복잡성을 추상화하여 개발자가 더 쉽고 효율적으로 웹 상호작용을 프로그래밍할 수 있도록 설계되었다.
브라우저의 모든 기능을 프로그래밍적으로 제어할 수 있게 함으로써, 테스팅, 웹 스크래핑, PDF 생성 등 다양한 use case를 지원한다.
주요 특징 포괄적인 브라우저 제어:
Puppeteer는 다음과 같은 고급 브라우저 제어 기능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;515 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Puppeteer" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/puppeteer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>winston</h2></header><div class=entry-content><p>Winston Winston은 Node.js 애플리케이션을 위한 다목적 로깅 라이브러리.
Winston의 주요 특징 다중 전송(Transport) 지원: 로그를 콘솔, 파일, 데이터베이스 등 여러 곳에 동시에 저장할 수 있다. 로그 레벨: error, warn, info, verbose, debug, silly 등 다양한 로그 레벨을 제공한다. 유연한 포맷팅: JSON, 일반 텍스트 등 다양한 형식으로 로그를 출력할 수 있다. 비동기 로깅: 로그 작성이 애플리케이션의 성능에 영향을 미치지 않도록 비동기적으로 처리한다. Winston의 장점 유연성: 다양한 로깅 요구사항을 쉽게 충족시킬 수 있다. 확장성: 커스텀 전송 방식을 만들어 사용할 수 있다. 성능: 비동기 로깅으로 애플리케이션 성능에 미치는 영향을 최소화한다. Winston 시작하기: 단계별 안내 🧭 1. 설치하기 터미널에서 다음 명령어를 실행하세요:
...</p></div><footer class=entry-footer><span title='2024-11-06 15:53:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;363 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to winston" href=https://buenhyden.github.io/posts/programming-languages/javascript/package/winston/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>pino</h2></header><div class=entry-content><p>Pino Node.js를 위한 매우 빠르고 가벼운 로깅 라이브러리.
“pine(소나무)“에서 이름을 따왔으며, 성능과 간결함에 중점을 둔 라이브러리.
Pino의 주요 특징 빠른 속도: Pino는 다른 로깅 라이브러리보다 약 5배 정도 빠르다. 낮은 오버헤드: 최소한의 리소스를 사용하여 애플리케이션의 성능에 미치는 영향을 줄인다. JSON 형식: 로그를 JSON 형식으로 출력하여 쉽게 파싱하고 분석할 수 있다. 비동기 로깅: 로그 작성이 애플리케이션의 주 실행을 방해하지 않는다. 다양한 로그 레벨: fatal, error, warn, info, debug, trace 등 여러 레벨의 로그를 지원한다. Pino의 장점 성능: 빠른 속도로 애플리케이션의 성능을 크게 저하시키지 않는다. 구조화된 로깅: JSON 형식으로 로그를 쉽게 분석할 수 있다. 확장성: 다양한 플러그인과 통합이 가능하다. Pino 시작하기: 실습 중심 가이드 1. 설치하기 터미널에서 다음 명령어를 실행한다:
...</p></div><footer class=entry-footer><span title='2024-11-06 15:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;341 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pino" href=https://buenhyden.github.io/posts/programming-languages/javascript/package/pino/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/javascript/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>