<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend Development | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/backend-development/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/backend-development/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/backend-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/backend-development/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend Development"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend Development"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Backend Development</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Search Engines</h2></header><div class=entry-content><p>Search Engine Search engines는 인터넷과 데이터베이스에 저장된 정보를 검색하고 사용자에게 관련 결과를 제공하는 소프트웨어 시스템이다. 이들은 현대 디지털 환경에서 필수적인 도구로, 정보를 효율적으로 찾고, 분석하며, 정리하는 데 도움을 준다. Google, Bing, Yahoo와 같은 대중적인 웹 검색 엔진뿐만 아니라 Elasticsearch와 같은 특화된 검색 엔진도 존재한다.
검색 엔진은 현대 데이터 관리 생태계의 핵심 구성 요소로서, 방대한 양의 정보에서 필요한 데이터를 효율적으로 찾아내는 특화된 시스템이다. 단순한 키워드 매칭을 넘어서, 오늘날의 검색 엔진은 복잡한 데이터 분석과 실시간 처리를 위한 고도화된 기술을 구현하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-21 05:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Search Engines" href=https://buenhyden.github.io/posts/software-engineering/application-development/search-and-discovery/search-engine/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Backpressure</h2></header><div class=entry-content><p>Backpressure Backpressure는 데이터 처리 시스템에서 수신 측이 송신 측에게 자신의 처리 용량을 알려 데이터 흐름을 제어하는 메커니즘이다. 이는 시스템이 과부하 없이 안정적으로 작동하도록 하며, 특히 분산 시스템이나 대규모 데이터 스트리밍 환경에서 필수적이다.
백프레셔의 기본 개념과 원리 백프레셔는 수신 구성 요소가 송신 구성 요소에게 데이터 처리 능력을 신호로 알려주는 흐름 제어 메커니즘이다. 이름의 유래는 파이프나 유체 시스템에서 역압력(back pressure)이 발생하는 물리적 현상에서 왔다.
핵심 원리 수신측 제어: 데이터를 수신하는 시스템이 처리 가능한 양을 송신 시스템에 알림 피드백 루프: 송신측과 수신측 사이의 지속적인 커뮤니케이션 자기 조절: 시스템이 자체적으로 처리 속도를 조절하는 메커니즘 물리적 아날로그 물리적 시스템에서의 백프레셔 개념을 이해하면 소프트웨어에서의 적용이 더 명확해진다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:16:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backpressure" href=https://buenhyden.github.io/posts/software-engineering/application-development/integration-and-migration/migration-strategies/backpressure/backpressure/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain Name</h2></header><div class=entry-content><p>Domain Name 도메인 이름은 인터넷의 기본 구성 요소로, 특히 API 디자인과 웹 서비스 개발에서 중요한 역할을 한다.
도메인 이름의 기본 개념 도메인 이름이란? 도메인 이름은 인터넷에서 특정 위치를 식별하는 사람이 읽을 수 있는 주소이다. 컴퓨터가 서로 통신할 때 사용하는 숫자로 된 IP 주소(예: 192.168.1.1) 대신, 사람이 기억하고 입력하기 쉬운 텍스트 형식(예: example.com)을 제공한다.
도메인 이름의 주요 목적은 다음과 같다:
기억하기 쉬운 웹 주소 제공 브랜드 아이덴티티 확립 웹사이트와 서비스에 대한 접근성 향상 IP 주소가 변경되더라도 일관된 접근점 유지 도메인 이름 시스템(DNS)과의 관계 도메인 이름 시스템(DNS)은 도메인 이름을 IP 주소로 변환하는 인터넷의 전화번호부와 같은 역할을 한다. 사용자가 브라우저에 도메인 이름을 입력하면, DNS는 해당 도메인 이름과 연결된 IP 주소를 찾아 사용자를 올바른 서버로 연결한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Name" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/domain-name/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hosting</h2></header><div class=entry-content><p>Hosting 호스팅은 API 설계와 배포에 있어 핵심적인 요소이다. 잘 설계된 API 도 적절한 호스팅 환경이 없다면 사용자에게 안정적으로 서비스를 제공할 수 없다.
호스팅의 기본 개념 호스팅이란 무엇인가? 호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다. API 호스팅은 API 가 24 시간 내내 접근 가능하고, 안정적으로 요청을 처리하며, 적절한 보안과 성능을 유지할 수 있도록 한다.
호스팅 서비스는 다음과 같은 기본 요소를 제공한다:
...</p></div><footer class=entry-footer><span title='2025-03-31 23:50:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;55 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hosting" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/hosting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Optimize API Response</h2></header><div class=entry-content><p>Optimize API Response API 응답 최적화는 현대 웹 애플리케이션의 성능, 사용자 경험 및 자원 효율성을 크게 향상시키는 핵심 요소이다.
Enforcing Reasonable Payload Size Limits 페이로드 크기는 API 성능에 직접적인 영향을 미친다. 대용량 데이터 전송은 네트워크 대역폭을 소모하고 서버 처리 시간을 증가시킨다.
페이로드 제한의 중요성 네트워크 효율성: 작은 페이로드는 더 빠른 전송 시간을 의미한다. 연구에 따르면 모바일 환경에서 5MB 이상의 페이로드는 평균 응답 시간을 3-4초 증가시킨다. 서버 리소스 관리: 대형 페이로드를 처리할 때 서버의 메모리 사용량이 급증할 수 있다. 이는 특히 동시 요청이 많을 때 서버 과부하로 이어질 수 있다. 데이터베이스 효율성: 대형 데이터를 저장하고 검색하는 것은 데이터베이스 성능에 부담을 준다. 구현 전략 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Express.js에서 페이로드 크기 제한 설정 예제 const express = require('express'); const app = express(); // JSON 페이로드 크기를 1MB로 제한 app.use(express.json({ limit: '1mb' })); // 폼 데이터 크기를 5MB로 제한 app.use(express.urlencoded({ extended: true, limit: '5mb' })); // 특정 라우트에 대해 다른 제한 적용 app.post('/upload-profile-image', express.json({ limit: '2mb' }), (req, res) => { // 프로필 이미지 처리 로직 }); 모범 사례 컨텐츠 유형별 제한: 이미지, 비디오, 텍스트 데이터에 대해 각기 다른 제한을 설정한다. 클라이언트 측 검증: 서버에 보내기 전에 클라이언트에서 파일 크기를 확인한다. 점진적 업로드: 대용량 파일은 청크(chunk) 단위로 분할하여 전송한다. 압축 권장: 가능한 경우 클라이언트 측에서 데이터 압축을 권장한다. Enabling Compression for Responses 데이터 압축은 전송되는 바이트 수를 감소시켜 네트워크 대역폭을 절약하고 응답 시간을 단축시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:39:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Optimize API Response" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-performance/optimize-api-response/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asynchronism</h2></header><div class=entry-content><p>Asynchronism 백엔드 시스템의 성능을 최적화하는 것은 현대 애플리케이션 개발에서 핵심적인 과제이다. 특히 비동기 처리(Asynchronism)는 시스템의 응답성과 확장성을 크게 향상시킬 수 있는 강력한 패러다임이다.
Offloading Heavy Tasks to Background Jobs or Queues 기본 개념 백그라운드 작업 처리는 시간이 오래 걸리거나 리소스를 많이 소모하는 작업을 주 실행 스레드에서 분리하여 별도의 프로세스나 스레드에서 비동기적으로 실행하는 기법이다. 이를 통해 사용자 요청에 대한 응답 시간을 크게 개선할 수 있다.
구현 방법 작업 큐 시스템 활용 작업 큐 시스템은 백그라운드 작업 처리의 가장 일반적인 구현 방법이다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:32:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asynchronism" href=https://buenhyden.github.io/posts/software-engineering/application-development/backend-development/backend-performance/asynchronism/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Lifecycle Management</h2></header><div class=entry-content><p>API Lifecycle Management API 라이프사이클 관리는 API의 계획 단계부터 폐기 단계까지 전체 수명주기를 체계적으로 관리하는 프로세스이다. 이는 조직이 API를 효과적으로 설계, 개발, 배포, 유지보수하고 궁극적으로 폐기하는 방법을 정의한다.
API 라이프사이클의 주요 단계 계획 및 전략 수립 (Planning & Strategy)
API 라이프사이클은 명확한 비즈니스 목표와 전략적 계획에서 시작한다.
비즈니스 요구사항 정의: API가 해결해야 할 비즈니스 문제와 목표를 식별한다. 대상 사용자 분석: 내부 개발자, 파트너, 또는 외부 개발자 등 API의 주요 사용자를 파악한다. API 설계 방향 결정: REST, GraphQL, gRPC 등 적절한 API 아키텍처 스타일을 선택한다. 핵심 성능 지표(KPI) 설정: API 성공을 측정할 지표를 정의한다. 설계 및 개발 (Design & Development)
이 단계에서는 API의 실제 인터페이스와 기능을 설계하고 구현한다.
...</p></div><footer class=entry-footer><span title='2025-02-02 03:24:00 +0000 UTC'>February 2, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Lifecycle Management" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-fundamentals/api-lifecycle-management/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h2></header><div class=entry-content><p>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.
기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성
• 우수한 확장성
• 효율적인 로드밸런싱
• 실시간 데이터 동기화 • 구현이 상대적으로 간단
• 비용 효율적
• 지리적 분산 용이
• 읽기 성능 향상 단점 • 구현 비용이 높음
• 복잡한 구성
• 네트워크 대역폭 필요
• 관리 어려움 • 데이터 일관성 보장 어려움
• 쓰기 성능 향상 제한적
• 마스터 노드 병목 현상
• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리
• 실시간 데이터 처리
• 무중단 서비스 필요
• 대규모 동시 접속 처리 • 데이터 백업
• 읽기 작업이 많은 서비스
• 지역별 서비스 제공
• 재해 복구 대비 산업 분야 • 금융 거래 시스템
• 통신 서비스
• 대형 전자상거래
• 실시간 예약 시스템 • 콘텐츠 제공 서비스
• 분석 리포팅 시스템
• 글로벌 서비스
• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요
• 낮은 지연시간 필수
• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능
• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요
• 동일한 사양의 노드 권장
• 충분한 메모리 • 마스터 노드 성능 중요
• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요
• 모니터링 시스템 필수
• 정기적인 유지보수 • 상대적으로 간단한 관리
• 백업 정책 중요
• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-25 15:42:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)" href=https://buenhyden.github.io/posts/database-systems-and-data-management/scaling-databases/database-clustering-and-replication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Backend Architecture</h2></header><div class=entry-content><p>Backend Architecture 백엔드 아키텍처는 사용자에게 보이지 않는 서버 측 컴포넌트, 인프라, 프로세스를 체계적으로 설계하는 것을 의미한다. 데이터 처리, 비즈니스 로직 실행, 데이터베이스 상호작용, 보안 관리, 외부 시스템 연동 등 애플리케이션의 핵심 기능을 담당한다.
확장성, 안정성, 성능을 보장하는 것이 목적이며, 이를 위해 다양한 패턴(모놀리식, 마이크로서비스, 서버리스 등)을 기반으로 구축된다.
2025년 현재는 클라우드 네이티브 기술, AI 통합, 서버리스 아키텍처가 주요 트렌드로 부상했다.
목적 백엔드 아키텍처의 주요 목적은 다음과 같다:
데이터 무결성 보장: 중앙 집중식 데이터 관리를 통해 일관성 있는 데이터 처리 비즈니스 로직 캡슐화: 핵심 비즈니스 규칙과 프로세스의 안전한 구현 확장성 제공: 사용자 수와 데이터 양이 증가해도 안정적인 서비스 제공 보안 강화: 데이터와 리소스에 대한 접근 제어 및 보호 성능 최적화: 효율적인 리소스 사용과 응답 시간 개선 유지보수성 향상: 코드 모듈화와 분리를 통한 개발 및 유지보수 효율성 증대 특징 백엔드 아키텍처의 주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend Architecture" href=https://buenhyden.github.io/posts/architecture-and-system-design/backend-architecture/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>