<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Algorithm on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.143.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Oct 2024 12:33:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</link>
      <pubDate>Mon, 14 Oct 2024 08:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/</guid>
      <description>문제를 해결하거나 특정 작업을 수행하기 위한 명확하고 단계적인 절차</description>
    </item>
    <item>
      <title>보간 검색 (Interpolation Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</link>
      <pubDate>Tue, 15 Oct 2024 12:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</guid>
      <description>&lt;h2 id=&#34;보간-검색-interpolation-search&#34;&gt;보간 검색 (Interpolation Search)&lt;/h2&gt;
&lt;p&gt;보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.&lt;br&gt;
이진 탐색(Binary Search)과 유사하지만, &lt;strong&gt;데이터 분포를 고려해 탐색 위치를 예측&lt;/strong&gt;함으로써 평균적으로 더 빠른 성능을 보인다. 특히 &lt;strong&gt;균등한 데이터 분포&lt;/strong&gt;에서 효과적이다.&lt;/p&gt;
&lt;p&gt;보간 검색은 &lt;strong&gt;데이터 특성에 민감&lt;/strong&gt;하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.&lt;br&gt;
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;데이터 균등성 가정&lt;/strong&gt;: 배열의 값이 &lt;strong&gt;선형적으로 분포&lt;/strong&gt;되어 있다고 가정한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;예측 위치 계산&lt;/strong&gt;: 탐색 위치를 다음 공식으로 계산한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</guid>
      <description>&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;p&gt;버블 정렬(Bubble Sort)은 &lt;strong&gt;인접한 요소를 반복적으로 비교하고 교환&lt;/strong&gt;하여 정렬하는 간단한 알고리즘이다.&lt;br&gt;
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, &lt;strong&gt;구현이 쉽지만 성능이 낮은&lt;/strong&gt; 특징을 가진다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Bubble Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Bubble-sort.webp&#34;&gt;&lt;figcaption&gt;https://www.wscubetech.com/resources/dsa/bubble-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비교&lt;/strong&gt;: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(&lt;code&gt;arr[i]&lt;/code&gt;와 &lt;code&gt;arr[i+1]&lt;/code&gt;)를 비교한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;교환&lt;/strong&gt;: 순서가 잘못된 경우(&lt;code&gt;arr[i] &amp;gt; arr[i+1]&lt;/code&gt;) 두 요소의 위치를 교환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;패스 완료&lt;/strong&gt;: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</guid>
      <description>&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;병합 정렬(Merge Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 방식을 사용하는 비교 기반 정렬 알고리즘이다.&lt;br&gt;
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.&lt;/p&gt;
&lt;p&gt;병합 정렬은 &lt;strong&gt;데이터 무결성과 안정성이 중요한 시스템&lt;/strong&gt;(예: 금융 거래 로그)에서 선호된다.&lt;br&gt;
현대 프로그래밍 언어의 표준 라이브러리(예: Python &lt;code&gt;sorted()&lt;/code&gt;, Java &lt;code&gt;Collections.sort()&lt;/code&gt;)에서도 하이브리드 방식으로 병합 정렬을 활용한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Merge Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/merge-sort-example_0.png&#34;&gt;&lt;figcaption&gt;https://www.programiz.com/dsa/merge-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</guid>
      <description>&lt;h2 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h2&gt;
&lt;p&gt;삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.&lt;br&gt;
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.&lt;/p&gt;
&lt;p&gt;삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.&lt;br&gt;
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Insertion Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Insertion-sorting.png&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/insertion-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;삽입-정렬의-작동-원리&#34;&gt;&lt;strong&gt;삽입 정렬의 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기화&lt;/strong&gt;: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;요소 선택&lt;/strong&gt;: 정렬되지 않은 부분에서 요소를 선택한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비교 및 이동&lt;/strong&gt;: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;삽입&lt;/strong&gt;: 찾은 위치에 요소를 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: 배열 &lt;code&gt;[5, 2, 4, 6, 1, 3]&lt;/code&gt;의 정렬 과정&lt;/p&gt;</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</guid>
      <description>&lt;h2 id=&#34;선택-정렬-selection-sort&#34;&gt;선택 정렬 (Selection Sort)&lt;/h2&gt;
&lt;p&gt;선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, &lt;strong&gt;작은 데이터 세트에서 효율적&lt;/strong&gt;이며 &lt;strong&gt;메모리 사용이 최소화&lt;/strong&gt;되는 특징을 갖는다.&lt;br&gt;
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 &lt;strong&gt;정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치&lt;/strong&gt;하는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;선택 정렬은 &lt;strong&gt;알고리즘의 기본 원리를 이해&lt;/strong&gt;하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Selection Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Selection-sort.png&#34;&gt;&lt;figcaption&gt;https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기화&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.&lt;/li&gt;
&lt;li&gt;초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;최솟값 탐색&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</guid>
      <description>&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;p&gt;퀵 정렬(Quick Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 전략을 사용하는 고성능 정렬 알고리즘이다. 1960년 Tony Hoare가 개발했으며, 평균적으로 **O(n log n)**의 시간 복잡도를 가지며 대규모 데이터셋 처리에 효율적이다.&lt;/p&gt;
&lt;p&gt;퀵 정렬은 &lt;strong&gt;실시간 시스템&lt;/strong&gt;과 &lt;strong&gt;고성능 컴퓨팅&lt;/strong&gt;에서 널리 사용되며, 알고리즘 최적화의 핵심 사례로 연구된다.&lt;br&gt;
피벗 선택 전략과 하이브리드 기법을 적용하면 현대 애플리케이션에서도 뛰어난 성능을 발휘한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Quick Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Heap-Sort-Recursive-Illustration.webp&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/quick-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;기본-원리&#34;&gt;기본 원리&lt;/h3&gt;
&lt;h4 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;피벗(Pivot) 선택&lt;/strong&gt;: 배열에서 하나의 요소를 선택한다. 피벗 선택 방법은 성능에 큰 영향을 미칩니다(예: 첫 번째/중간/랜덤 요소 또는 중앙값).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분할(Partitioning)&lt;/strong&gt;: 피벗을 기준으로 배열을 두 부분으로 나눈다. 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재귀적 정렬&lt;/strong&gt;: 분할된 서브 배열에 대해 동일한 과정을 재귀적으로 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;분할-과정-예시&#34;&gt;분할 과정 예시&lt;/h4&gt;
&lt;p&gt;배열 &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;에서 피벗을 중간 값인 &lt;code&gt;4&lt;/code&gt;로 선택:&lt;/p&gt;</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</guid>
      <description>&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;p&gt;힙 정렬(Heap Sort)은 &lt;strong&gt;이진 힙(binary heap)&lt;/strong&gt; 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.&lt;br&gt;
1964년 J. W. J. Williams가 개발한 이 알고리즘은 **최악, 평균, 최선의 경우 모두 O(n log n)**의 시간 복잡도를 보장하며, **메모리 효율성(O(1))**이 뛰어난 특징을 가진다.&lt;br&gt;
주로 대규모 데이터셋 처리와 안정적인 성능이 요구되는 시스템에서 활용된다.&lt;/p&gt;
&lt;p&gt;힙 정렬은 &lt;strong&gt;성능 예측이 중요한 시스템&lt;/strong&gt;에서 특히 유용하다. 최근에는 하이브리드 알고리즘(예: Introsort)에서 퀵 정렬의 최악 경우를 방지하기 위해 힙 정렬을 부분적으로 활용하기도 한다.&lt;br&gt;
데이터 특성과 시스템 요구사항에 따라 적절한 정렬 방식을 선택하는 것이 핵심이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>깊이 우선 탐색 (Depth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</guid>
      <description>그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.</description>
    </item>
    <item>
      <title>너비 우선 탐색 (Breadth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</guid>
      <description>BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘</description>
    </item>
    <item>
      <title>이진 검색 (Binary Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</guid>
      <description>리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다</description>
    </item>
    <item>
      <title>해시 검색 (Hash Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</guid>
      <description>해시 검색은 키(key)를 해시 함수(hash function)에 통과시켜 얻은 해시 값(hash value)을 인덱스로 사용하여 데이터에 직접 접근하는 방식.</description>
    </item>
    <item>
      <title>순차 검색 (Sequential Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</guid>
      <description>순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법으로 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.</description>
    </item>
    <item>
      <title>암호화 알고리즘 (Encryption Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/encryption-algorithms/</guid>
      <description>데이터를 안전하게 보호하기 위해 사용되는 수학적 방법</description>
    </item>
    <item>
      <title>머신러닝 알고리즘 (Machine Learning Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 07:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/machine-learning-algorithms/</guid>
      <description>컴퓨터가 명시적인 프로그래밍 없이 데이터로부터 패턴을 학습하고 예측이나 의사결정을 수행할 수 있게 하는 알고리즘</description>
    </item>
    <item>
      <title>최적화 알고리즘 (Optimization Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/optimization-algorithms/</guid>
      <description>주어진 문제에 대해 가장 효율적이거나 최적의 해결책을 찾기 위해 사용되는 방법론</description>
    </item>
    <item>
      <title>기하 알고리즘 (Geometric Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/geometric-algorithms/</guid>
      <description>2차원, 3차원 또는 더 높은 차원의 공간에 존재하는 점, 선, 다각형, 원 등의 기하학적 객체를 다루는 알고리즘</description>
    </item>
    <item>
      <title>문자열 알고리즘 (String Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/string-algorithms/</guid>
      <description>문자열 알고리즘은 텍스트 데이터를 처리하고 분석하는 알고리즘의 집합</description>
    </item>
    <item>
      <title>수치 알고리즘 (Numerical Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/numerical-algorithms/</guid>
      <description>수치해석학의 일부로, 복잡한 수학적 문제를 컴퓨터를 이용해 수치적으로 근사해서 해결하는 알고리즘</description>
    </item>
    <item>
      <title>그리디 알고리즘 (Greedy Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 02:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/greedy-algorithms/</guid>
      <description>&amp;#34;탐욕적&amp;#34; 또는 &amp;#34;욕심쟁이&amp;#34; 알고리즘이라고도 불리며, 현재 상황에서 가장 최적의 선택을 하는 방식으로 문제를 해결하는 알고리즘</description>
    </item>
    <item>
      <title>검색 알고리즘 (Searching Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/</guid>
      <description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</description>
    </item>
    <item>
      <title>그래프 알고리즘 (Graph Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/graph-algorithms/</guid>
      <description>네트워크, 경로 찾기, 최적화 등 다양한 실제 문제를 해결하는 데 사용되는 중요한 알고리즘</description>
    </item>
    <item>
      <title>정렬 알고리즘 (Sorting Algorithms)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/</link>
      <pubDate>Mon, 14 Oct 2024 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/</guid>
      <description>정렬 알고리즘은 데이터를 특정 순서로 배열하는 알고리즘으로, 컴퓨터 과학에서 매우 중요한 역할을 한다.</description>
    </item>
  </channel>
</rss>
