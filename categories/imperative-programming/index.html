<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Imperative Programming | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/imperative-programming/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/imperative-programming/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/imperative-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/imperative-programming/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Imperative Programming"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Imperative Programming"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Imperative Programming</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interface vs Abstract class</h2></header><div class=entry-content><p>Interface vs. Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.
모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.
이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.
추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.
일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 05:39:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interface vs Abstract class" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/object-oriented-programming/paradigm-features/interface-vs-abstract-class/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)</h2></header><div class=entry-content><p>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming) 명령형 프로그래밍과 선언적 프로그래밍은 소프트웨어 개발에서 가장 기본적인 두 가지 프로그래밍 패러다임이다.
이들은 문제를 해결하는 접근 방식과 코드 작성 철학에서 근본적인 차이를 보인다.
명령형 프로그래밍과 선언적 프로그래밍은 서로 배타적이지 않으며, 각각 고유한 장점과 적합한 사용 사례가 있다.
현대 소프트웨어 개발에서는 두 패러다임을 상황에 맞게 적절히 조합하여 사용하는 것이 일반적이다.
명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다. 개발자로서 두 패러다임 모두를 이해하고 적절히 활용할 수 있다면, 다양한 문제 영역에서 효과적인 솔루션을 구축할 수 있을 것이다.
...</p></div><footer class=entry-footer><span title='2025-02-09 12:38:00 +0000 UTC'>February 9, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/imperative-programming/imperative-programming-vs-declarative-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Access Modifiers</h2></header><div class=entry-content><p>Access Modifiers 객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다. 이를 통해 캡슐화를 구현하고 코드의 안정성과 유지보수성을 향상시킬 수 있다.
접근 제어자를 적절히 사용하면 객체지향 프로그래밍의 핵심 원칙인 캡슐화를 효과적으로 구현할 수 있으며, 이는 코드의 품질과 유지보수성을 크게 향상시킨다.
접근 제어자의 종류 public
가장 넓은 접근 범위를 가진다. 어떤 클래스에서든 접근이 가능하다. 모든 패키지의 모든 클래스에서 이 요소에 접근할 수 있다. 1 2 3 4 5 6 class BankAccount: def __init__(self): self.account_number = "123-456-789" # public 변수 def get_balance(self): # public 메서드 return self.balance protected
...</p></div><footer class=entry-footer><span title='2024-09-23 04:49:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Modifiers" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/object-oriented-programming/components/access-modifiers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/object-oriented-programming/components/class/class-and-instance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding)과 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩(Overriding)과 오버로딩(Overloading) 기본 개념 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 정의 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것 같은 클래스 내에서 동일한 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것 목적 상속 관계에서 메서드의 구현을 변경하기 위해 사용 비슷한 기능을 하는 메서드를 하나의 이름으로 여러 가지 방식으로 사용하기 위해 사용 다형성 유형 런타임 다형성 (동적 바인딩) 컴파일 타임 다형성 (정적 바인딩) 핵심 특징 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 이름 반드시 동일해야 함 반드시 동일해야 함 매개변수 부모 메서드와 동일해야 함 타입이나 개수가 달라야 함 반환 타입 부모 메서드와 동일하거나 공변 반환 타입이어야 함 다를 수 있음 접근 제어자 부모 메서드보다 더 제한적일 수 없음 자유롭게 지정 가능 예외 처리 부모 메서드보다 더 큰 범위의 예외를 던질 수 없음 자유롭게 지정 가능 코드 예시 비교 오버라이딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 부모 클래스 class Animal { public void makeSound() { System.out.println("동물이 소리를 냅니다"); } } // 자식 클래스 class Dog extends Animal { @Override // 오버라이딩 명시 public void makeSound() { System.out.println("멍멍!"); } } class Cat extends Animal { @Override public void makeSound() { System.out.println("야옹!"); } } 오버로딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculator { // 정수 덧셈 public int add(int a, int b) { return a + b; } // 실수 덧셈 public double add(double a, double b) { return a + b; } // 세 정수의 덧셈 public int add(int a, int b, int c) { return a + b + c; } // 배열의 덧셈 public int add(int[] numbers) { int sum = 0; for (int num : numbers) { sum += num; } return sum; } } 실행 시점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 결정 시점 런타임에 결정 컴파일 타임에 결정 바인딩 동적 바인딩 정적 바인딩 성능 영향 약간의 오버헤드 발생 가능 오버헤드 없음 사용 목적 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 주요 용도 • 부모 클래스 메서드의 동작 변경
• 다형성 구현
• 특화된 기능 구현 • 메서드 이름의 재사용
• 다양한 매개변수 처리
• 코드의 간결성 향상 활용 상황 • 추상 메서드 구현
• 인터페이스 구현
• 상속받은 메서드 수정 • 생성자 다중 정의
• 유틸리티 메서드 구현
• API 설계 제약사항 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 제약 • final 메서드는 오버라이드 불가
• private 메서드는 오버라이드 불가
• static 메서드는 오버라이드 불가 • 매개변수만 다르면 됨
• 반환 타입만 다른 것은 불가
• 접근 제어자 제약 없음 상속 관계 반드시 상속 관계가 있어야 함 상속 관계 불필요 기타 제약 • 부모의 메서드보다 접근성을 좁힐 수 없음
• 부모보다 더 큰 예외 선언 불가 • 매개변수 순서만 다른 경우 주의 필요
• 모호한 호출 가능성 주의 장단점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 장점 • 다형성 구현 가능
• 코드 재사용성 향상
• 유연한 설계 가능 • 직관적인 메서드명 사용
• 코드 가독성 향상
• API 사용 편의성 증가 단점 • 런타임 오버헤드
• 복잡한 상속 관계시 추적 어려움
• 잘못 사용시 부모 클래스 동작 훼손 • 과도한 사용시 복잡도 증가
• 타입 변환 오류 가능성
• 모호한 메서드 호출 가능성 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 04:56:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding)과 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/programming-languages/programming-paradigms/object-oriented-programming/overriding-and-overloading/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>