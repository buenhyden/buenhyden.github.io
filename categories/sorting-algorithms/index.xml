<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sorting Algorithms on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/sorting-algorithms/</link>
    <description>Recent content in Sorting Algorithms on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.143.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Oct 2024 08:38:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/sorting-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</guid>
      <description>&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;p&gt;버블 정렬(Bubble Sort)은 &lt;strong&gt;인접한 요소를 반복적으로 비교하고 교환&lt;/strong&gt;하여 정렬하는 간단한 알고리즘이다.&lt;br&gt;
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, &lt;strong&gt;구현이 쉽지만 성능이 낮은&lt;/strong&gt; 특징을 가진다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Bubble Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Bubble-sort.webp&#34;&gt;&lt;figcaption&gt;https://www.wscubetech.com/resources/dsa/bubble-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비교&lt;/strong&gt;: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(&lt;code&gt;arr[i]&lt;/code&gt;와 &lt;code&gt;arr[i+1]&lt;/code&gt;)를 비교한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;교환&lt;/strong&gt;: 순서가 잘못된 경우(&lt;code&gt;arr[i] &amp;gt; arr[i+1]&lt;/code&gt;) 두 요소의 위치를 교환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;패스 완료&lt;/strong&gt;: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</guid>
      <description>&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;p&gt;병합 정렬(Merge Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 방식을 사용하는 비교 기반 정렬 알고리즘이다.&lt;br&gt;
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.&lt;/p&gt;
&lt;p&gt;병합 정렬은 &lt;strong&gt;데이터 무결성과 안정성이 중요한 시스템&lt;/strong&gt;(예: 금융 거래 로그)에서 선호된다.&lt;br&gt;
현대 프로그래밍 언어의 표준 라이브러리(예: Python &lt;code&gt;sorted()&lt;/code&gt;, Java &lt;code&gt;Collections.sort()&lt;/code&gt;)에서도 하이브리드 방식으로 병합 정렬을 활용한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Merge Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/merge-sort-example_0.png&#34;&gt;&lt;figcaption&gt;https://www.programiz.com/dsa/merge-sort&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</guid>
      <description>&lt;h2 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h2&gt;
&lt;p&gt;삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.&lt;br&gt;
이 알고리즘은 작은 데이터셋이나 이미 부분적으로 정렬된 배열에서 특히 효율적이다.&lt;/p&gt;
&lt;p&gt;삽입 정렬은 알고리즘의 기본 원리를 이해하는 데 유용하며, 특정 조건에서 여전히 실용적으로 사용된다.&lt;br&gt;
그러나 데이터 크기와 상태에 따라 적절한 알고리즘을 선택하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Insertion Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Insertion-sorting.png&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/insertion-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;삽입-정렬의-작동-원리&#34;&gt;&lt;strong&gt;삽입 정렬의 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기화&lt;/strong&gt;: 배열의 두 번째 요소부터 시작한다. 첫 번째 요소는 이미 정렬된 부분으로 간주한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;요소 선택&lt;/strong&gt;: 정렬되지 않은 부분에서 요소를 선택한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비교 및 이동&lt;/strong&gt;: 선택한 요소를 정렬된 부분의 요소들과 비교하여 적절한 위치를 찾는다. 이 과정에서 더 큰 요소는 오른쪽으로 한 칸씩 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;삽입&lt;/strong&gt;: 찾은 위치에 요소를 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;반복&lt;/strong&gt;: 정렬되지 않은 모든 요소가 처리될 때까지 2~4단계를 반복한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;: 배열 &lt;code&gt;[5, 2, 4, 6, 1, 3]&lt;/code&gt;의 정렬 과정&lt;/p&gt;</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</guid>
      <description>&lt;h2 id=&#34;선택-정렬-selection-sort&#34;&gt;선택 정렬 (Selection Sort)&lt;/h2&gt;
&lt;p&gt;선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, &lt;strong&gt;작은 데이터 세트에서 효율적&lt;/strong&gt;이며 &lt;strong&gt;메모리 사용이 최소화&lt;/strong&gt;되는 특징을 갖는다.&lt;br&gt;
전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 &lt;strong&gt;정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치&lt;/strong&gt;하는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;선택 정렬은 &lt;strong&gt;알고리즘의 기본 원리를 이해&lt;/strong&gt;하는 데 유용하지만, 실제 애플리케이션에서는 더 효율적인 알고리즘이 주로 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Selection Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Selection-sort.png&#34;&gt;&lt;figcaption&gt;https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;알고리즘-작동-원리&#34;&gt;&lt;strong&gt;알고리즘 작동 원리&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기화&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;배열을 **정렬된 영역(왼쪽)**과 **정렬되지 않은 영역(오른쪽)**으로 분할한다.&lt;/li&gt;
&lt;li&gt;초기 정렬된 영역은 비어 있고, 정렬되지 않은 영역은 전체 배열이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;최솟값 탐색&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</guid>
      <description>&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;p&gt;퀵 정렬(Quick Sort)은 &lt;strong&gt;분할 정복(divide and conquer)&lt;/strong&gt; 전략을 사용하는 고성능 정렬 알고리즘이다. 1960년 Tony Hoare가 개발했으며, 평균적으로 **O(n log n)**의 시간 복잡도를 가지며 대규모 데이터셋 처리에 효율적이다.&lt;/p&gt;
&lt;p&gt;퀵 정렬은 &lt;strong&gt;실시간 시스템&lt;/strong&gt;과 &lt;strong&gt;고성능 컴퓨팅&lt;/strong&gt;에서 널리 사용되며, 알고리즘 최적화의 핵심 사례로 연구된다.&lt;br&gt;
피벗 선택 전략과 하이브리드 기법을 적용하면 현대 애플리케이션에서도 뛰어난 성능을 발휘한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Quick Sort&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/Heap-Sort-Recursive-Illustration.webp&#34;&gt;&lt;figcaption&gt;https://www.geeksforgeeks.org/quick-sort-algorithm/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;기본-원리&#34;&gt;기본 원리&lt;/h3&gt;
&lt;h4 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;피벗(Pivot) 선택&lt;/strong&gt;: 배열에서 하나의 요소를 선택한다. 피벗 선택 방법은 성능에 큰 영향을 미칩니다(예: 첫 번째/중간/랜덤 요소 또는 중앙값).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분할(Partitioning)&lt;/strong&gt;: 피벗을 기준으로 배열을 두 부분으로 나눈다. 피벗보다 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재귀적 정렬&lt;/strong&gt;: 분할된 서브 배열에 대해 동일한 과정을 재귀적으로 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;분할-과정-예시&#34;&gt;분할 과정 예시&lt;/h4&gt;
&lt;p&gt;배열 &lt;code&gt;[5, 3, 8, 4, 2]&lt;/code&gt;에서 피벗을 중간 값인 &lt;code&gt;4&lt;/code&gt;로 선택:&lt;/p&gt;</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</guid>
      <description>&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;p&gt;힙 정렬(Heap Sort)은 &lt;strong&gt;이진 힙(binary heap)&lt;/strong&gt; 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.&lt;br&gt;
1964년 J. W. J. Williams가 개발한 이 알고리즘은 **최악, 평균, 최선의 경우 모두 O(n log n)**의 시간 복잡도를 보장하며, **메모리 효율성(O(1))**이 뛰어난 특징을 가진다.&lt;br&gt;
주로 대규모 데이터셋 처리와 안정적인 성능이 요구되는 시스템에서 활용된다.&lt;/p&gt;
&lt;p&gt;힙 정렬은 &lt;strong&gt;성능 예측이 중요한 시스템&lt;/strong&gt;에서 특히 유용하다. 최근에는 하이브리드 알고리즘(예: Introsort)에서 퀵 정렬의 최악 경우를 방지하기 위해 힙 정렬을 부분적으로 활용하기도 한다.&lt;br&gt;
데이터 특성과 시스템 요구사항에 따라 적절한 정렬 방식을 선택하는 것이 핵심이다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
