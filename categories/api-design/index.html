<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API Design | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/api-design/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/api-design/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/api-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/api-design/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API Design"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API Design"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>API Design</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Synchronous vs Asynchronous APIs</h2></header><div class=entry-content><p>Synchronous vs. Asynchronous APIs API 설계에서 동기식(Synchronous)과 비동기식(Asynchronous) 패턴 중 어떤 것을 선택할지는 시스템 아키텍처와 사용자 경험에 중대한 영향을 미치는 결정이다. 각 패턴은 고유한 장단점을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
동기식 API(Synchronous API) 동기식 API는 클라이언트가 요청을 보내고 서버의 응답을 받을 때까지 대기하는 방식으로 작동한다. 이는 요청-응답 주기가 완료될 때까지 클라이언트가 다른 작업을 수행하지 않는 “차단(blocking)” 방식을 의미한다.
동기식 API의 작동 원리 동기식 API의 기본 흐름은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-06 00:57:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous vs Asynchronous APIs" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-integration-patterns/synchronous-vs-asynchronous-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HTTP basic authentication</h2></header><div class=entry-content><p>HTTP basic authentication 기본 인증(Basic Authentication)은 웹 애플리케이션과 API에서 사용되는 가장 단순하고 오래된 HTTP 인증 방식 중 하나이다. 이 인증 방식은 1996년에 발표된 HTTP/1.0 명세의 일부로 처음 소개되었으며, 현재까지도 많은 시스템에서 활용되고 있다. 간단한 구조와 광범위한 지원으로 인해 여전히 중요한 인증 메커니즘으로 남아 있다.
기본 인증의 작동 원리 기본 인증은 매우 직관적인 프로세스를 따른다:
요청 시도: 클라이언트가 보호된 리소스에 접근을 시도한다.
인증 요구: 서버는 리소스가 보호되어 있음을 인식하고 상태 코드 401 (Unauthorized)와 함께 응답한다. 이 응답에는 다음과 같은 헤더가 포함된다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:01:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HTTP basic authentication" href=https://buenhyden.github.io/posts/backend-development/authentication-and-authorization/authentication-methods/http-basic-authentication/basic-authentication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Contract Testing</h2></header><div class=entry-content><p>Contract Testing 계약 테스트(Contract Testing)는 서비스 간 상호작용이 명시된 계약을 준수하는지 확인하는 테스트 방법론이다. 현대적인 소프트웨어 아키텍처, 특히 마이크로서비스 환경에서 매우 중요한 역할을 한다.
계약의 정의 API 계약은 서비스 제공자(Provider)와 소비자(Consumer) 간의 “약속"으로 볼 수 있다.
이 계약은 다음과 같은 요소를 포함한다:
API 엔드포인트 및 경로 요청 및 응답 형식(JSON, XML 등) 데이터 구조 및 필드 정의 상태 코드 및 오류 처리 방식 인증 및 권한 부여 요구사항 계약 테스트의 필요성 마이크로서비스 아키텍처에서는 수십, 수백 개의 서비스가 서로 상호작용한다.
...</p></div><footer class=entry-footer><span title='2025-03-10 02:52:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Contract Testing" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-lifecycle-management/testing/contract-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Load Testing</h2></header><div class=entry-content><p>Load Testing API 부하 테스트는 API가 예상된 사용자 부하와 그 이상의 상황에서 어떻게 동작하는지 검증하는 중요한 성능 테스트 유형이다.
API 부하 테스트의 기본 개념 부하 테스트란 무엇인가? 부하 테스트는 시스템에 점진적으로 부하를 증가시키면서 그 동작을, 분석하는 성능 테스트의 한 유형이다. API 부하 테스트는 특히 API가 다양한 부하 조건에서 어떻게 동작하는지 검증하는 데 초점을 맞춘다.
이런 테스트를 통해 다음과 같은 중요한 정보를 얻을 수 있다:
API의 최대 처리 용량(초당 요청 수) 응답 시간과 부하 간의 관계 병목 현상이 발생하는 지점 시스템의 안정성과 확장성 자원 사용률(CPU, 메모리, 네트워크 등) 다른 성능 테스트 유형과의 비교 부하 테스트는 다른 성능 테스트 유형과 목적과 접근 방식에서 차이가 있다:
...</p></div><footer class=entry-footer><span title='2025-03-10 02:52:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Testing" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-lifecycle-management/testing/load-testing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Pagination</h2></header><div class=entry-content><p>Pagination API 설계에서 페이지네이션은 대량의 데이터를 효율적으로 전송하고 관리하기 위한 핵심 요소이다. 페이지네이션을 통해 서버는 데이터를 작은 “페이지” 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.
페이지네이션의 필요성과 중요성 페이지네이션이 필요한 주요 이유는 다음과 같다:
성능 최적화
대규모 데이터셋을 한 번에 전송하면 여러 문제가 발생한다:
서버 부하 증가: 대량의 레코드를 검색하고 직렬화하는 과정은 서버 리소스를 많이 소모한다. 네트워크 부하: 대용량 응답은 네트워크 대역폭을 많이 사용하며, 특히 모바일 환경에서 문제가 된다. 응답 지연: 큰 데이터셋을 처리하는 데 시간이 오래 걸려 사용자 경험이 저하된다. 메모리 사용량: 클라이언트와 서버 모두 대량의 데이터를 메모리에 로드해야 한다. 사용자 경험 향상
페이지네이션은 사용자 인터페이스와 경험을 개선한다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pagination" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-performance/pagination/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>URI Design</h2></header><div class=entry-content><p>URI Design URI(Uniform Resource Identifier) 디자인은 API 설계의 근본적인 요소로, 개발자 경험과 API의 사용성, 유지보수성에 직접적인 영향을 미친다. 잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.
URI의 기본 개념과 구조 URI는 인터넷에서 특정 리소스를 고유하게 식별하는 문자열이다. API 설계에서 URI는 클라이언트가 서버의 리소스와 상호 작용하는 진입점 역할을 한다.
URI의 구성 요소 URI의 주요 구성 요소를 이해하는 것은 효과적인 디자인의 시작점이다:
1 2 3 4 https://api.example.com:8080/v1/customers/42/orders?status=pending#summary \___/ \______________/\__/\_________________/ \____________/ \______/ | | | | | | scheme authority port path query fragment 스킴(Scheme): URI가 사용하는 프로토콜(https, http 등) 권한(Authority): 서비스의 도메인 이름 또는 IP 주소 포트(Port): 서비스가 수신 대기하는 네트워크 포트(종종 생략됨) 경로(Path): 리소스의 위치를 계층적으로 나타내는 문자열 쿼리(Query): 리소스에 대한 추가 매개변수(필터링, 정렬 등) 프래그먼트(Fragment): 리소스 내의 특정 부분을 가리키는 식별자(일반적으로 API에서 덜 사용됨) URI vs. URL vs. URN URI 개념을 정확히 이해하기 위해서는 관련 용어의 차이점을 아는 것이 중요하다:
...</p></div><footer class=entry-footer><span title='2025-02-27 02:50:00 +0000 UTC'>February 27, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to URI Design" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-fundamentals/uri-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Types of Real-time APIs</h2></header><div class=entry-content><p>Types of Real-time APIs Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다. 이는 사용자 경험을 향상시키고, 데이터 정확성과 응답성을 높이는 데 중요한 역할을 한다.
Real-time API의 주요 유형 WebSocket API 특징: 단일 TCP 연결을 통해 양방향 통신을 지원. 클라이언트와 서버가 모두 데이터를 주고받을 수 있음. 낮은 지연 시간과 효율적인 데이터 전송 가능. 사용 사례: 채팅 애플리케이션, 온라인 게임, 협업 도구. Server-Sent Events (SSE) API 특징: HTTP 기반 단방향 통신(서버 → 클라이언트). 지속적인 연결 유지 및 자동 재연결 지원. 텍스트 기반 데이터 전송(UTF-8). 사용 사례: 실시간 알림, 뉴스 피드, 주식 가격 업데이트. Streaming API 특징: 서버에서 클라이언트로 지속적인 데이터 스트림 제공. 대규모 데이터 처리에 적합(예: 비디오, 오디오 스트리밍). WebSocket 또는 SSE를 기반으로 구현 가능. 사용 사례: 라이브 비디오 스트리밍, 소셜 미디어 피드, IoT 센서 데이터. Pub/Sub API 특징: Publish-Subscribe 패턴 기반. 발행자(Publisher)가 특정 주제(Topic)에 메시지를 게시하면 구독자(Subscriber)가 이를 수신. 데이터 생산자와 소비자를 분리하여 확장성과 효율성 제공. 사용 사례: 메시징 시스템(Kafka, PubNub), IoT 장치 간 통신. Push API 특징: 서버에서 클라이언트로 푸시 알림 전송. 클라이언트가 활성화되지 않아도 메시지 수신 가능. 모바일 애플리케이션에서 주로 사용됨. 사용 사례: 모바일 푸시 알림(Firebase Cloud Messaging), 이메일 알림. Event-Driven API 특징: 이벤트 중심 설계로 상태 변화나 특정 이벤트 발생 시 데이터를 전달. 이벤트 구독 및 처리에 최적화됨. 사용 사례: IoT 애플리케이션, 실시간 모니터링 시스템. Real-Time API 기술 비교 기본 특성 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 통신 방향 양방향(전이중) 단방향(서버→클라이언트) 단방향/양방향 가능 다방향(다대다) 단방향(서버→클라이언트) 이벤트 기반 프로토콜 WS/WSS HTTP/HTTPS HTTP/HTTPS 다양(MQTT, AMQP 등) HTTP/HTTPS 다양 연결 유지 지속 연결 지속 연결 지속 연결 지속/비지속 가능 비연결성 이벤트 발생 시 자동 재연결 수동 구현 필요 내장 지원 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 구현에 따라 다름 메시지 포맷 텍스트/바이너리 텍스트(UTF-8) 다양(JSON, XML 등) 다양 JSON 다양 데이터 크기 프레임 크기 제한 제한 없음 청크 단위 전송 일반적으로 작은 메시지 작은 메시지 이벤트 크기 기술적 특성 및 구현 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 연결 설정 HTTP 업그레이드 후 WS 프로토콜 일반 HTTP 연결 HTTP 연결 다양한 연결 방식 서비스 워커 등록 이벤트 리스너 등록 클라이언트 API WebSocket EventSource HTTP/Fetch 라이브러리별 다양 Push API, Service Worker 이벤트 리스너 서버 구현 WebSocket 서버 필요 일반 HTTP 서버 일반 HTTP 서버 메시지 브로커 서버 푸시 서비스 이벤트 처리 시스템 확장성 연결 유지 부담 상대적으로 가벼움 리소스 집약적 높은 확장성 높은 확장성 높은 확장성 헤더 오버헤드 낮음(최초 연결 후) 중간 중간 낮음 중간 구현에 따라 다름 통합 난이도 중간 쉬움 중간 중간~어려움 어려움 중간~어려움 활용 사례 및 지원 비교 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 즉시성 매우 높음 높음 중간~높음 중간~높음 중간 중간~높음 브라우저 지원 대부분 지원 대부분 지원(IE 제외) 모두 지원 라이브러리 필요 대부분 지원 구현에 따라 다름 보안 고려사항 WSS 필수, 인증 필요 HTTPS 권장, 인증 필요 HTTPS 권장, 인증 필요 인증/권한 관리 중요 인증 키/토큰 관리 이벤트 검증 중요 리소스 사용량 중간~높음 낮음~중간 중간~높음 중간 낮음 중간 최적 사용 사례 채팅, 게임, 협업 도구 알림, 뉴스 피드, 실시간 데이터 대용량 데이터 전송 분산 메시징, IoT 알림, 백그라운드 메시지 마이크로서비스, 이벤트 기록 성능 및 구현 고려사항 특성 WebSocket SSE (Server-Sent Events) Streaming API Pub/Sub API Push API Event-Driven API 지연 시간 매우 낮음(~100ms) 낮음(~500ms) 중간(~1s) 중간 높음(몇 초~몇 분) 구현에 따라 다름 처리량 높음 중간 매우 높음 매우 높음 낮음 구현에 따라 다름 배터리 영향 중간~높음 낮음~중간 중간~높음 구현에 따라 다름 낮음(백그라운드) 구현에 따라 다름 방화벽 통과 일부 제한 가능 대부분 허용 대부분 허용 혼합 대부분 허용 구현에 따라 다름 저대역폭 환경 적합하지 않음 적합함 적합하지 않음 구현에 따라 다름 적합함 구현에 따라 다름 오프라인 지원 미지원 미지원 미지원 일부 지원 가능 지원(백그라운드) 일부 지원 가능 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2025-02-15 01:56:00 +0000 UTC'>February 15, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Real-time APIs" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/real-time-apis/types-of-real-time-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Error Handling and Retries</h2></header><div class=entry-content><p>Error Handling and Retries 현대 소프트웨어 아키텍처에서 API는 중추적인 역할을 담당하며, 다양한 시스템 간의 원활한 통신을 가능하게 한다. 그러나 네트워크 불안정성, 서버 과부하, 일시적인 서비스 중단 등 다양한 이유로 API 호출은 항상 성공적으로 완료되지 않을 수 있다. 따라서 효과적인 오류 처리와 재시도 메커니즘은 안정적인 API 설계의 핵심 요소이다.
API 오류 처리의 중요성 오류 처리가 중요한 이유 효과적인 오류 처리는 다음과 같은 여러 이유로 중요하다:
사용자 경험 향상: 명확한 오류 메시지는 사용자가 문제를 이해하고 해결할 수 있게 도와준다. 디버깅 용이성: 상세한 오류 정보는 개발자가 문제를 신속하게 식별하고 해결하는 데 도움이 된다. 시스템 안정성: 적절한 오류 처리는 예기치 않은 상황에서도 애플리케이션이 계속 작동할 수 있게 한다. 보안 강화: 오류 처리는 민감한 정보 노출을 방지하고 잠재적인 공격 벡터를 감소시킨다. API 사용성: 일관되고 예측 가능한 오류 응답은 API의 사용성을 크게 향상시킨다. 부적절한 오류 처리의 결과 오류 처리가 제대로 구현되지 않으면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2025-02-13 01:31:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Error Handling and Retries" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-performance/error-handling-and-retries/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Performance Metrics</h2></header><div class=entry-content><p>Performance Metrics API 성능 메트릭스는 API의 효율성, 안정성, 그리고 전반적인 품질을 측정하는 중요한 지표이다. 이러한 메트릭스를 이해하고 모니터링함으로써, 개발자와 시스템 관리자는 사용자 경험을 개선하고 시스템 리소스를 최적화할 수 있다.
API 성능 메트릭스의 중요성 API 성능은 애플리케이션의 전반적인 사용자 경험과 비즈니스 성과에 직접적인 영향을 미친다.
성능이 좋지 않은 API는 다음과 같은 문제를 일으킬 수 있다:
사용자 경험 저하: 느린 응답 시간은 최종 사용자의 불만족으로 이어진다. 시스템 신뢰성 감소: 잦은 오류나 장애는 시스템에 대한 신뢰를 떨어뜨린다. 비용 증가: 비효율적인 리소스 사용은 인프라 비용을 증가시킨다. 확장성 제한: 성능 병목 현상은 시스템의 확장을 어렵게 만든다. 따라서 API 설계 단계부터 성능 메트릭스를 고려하는 것이 중요하며, 지속적인 모니터링과 최적화가 필요하다.
...</p></div><footer class=entry-footer><span title='2025-02-13 01:28:00 +0000 UTC'>February 13, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Performance Metrics" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-lifecycle-management/monitoring-and-analytics/performance-metrics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DAC</h2></header><div class=entry-content><p>재량적 접근 제어(Discretionary Access Control, DAC) 재량적 접근 제어는 리소스의 소유자가 해당 리소스에 대한다른 사용자들의 접근 권한을 직접 제어할 수 있는 접근 제어 방식.
이는 우리가 일상적으로 사용하는 컴퓨터의 파일 시스템과 매우 유사한 방식으로 작동한다.
예를 들어, 여러분이 문서를 만들면 해당 문서의 소유자가 되어 다른 사람들에게 읽기, 쓰기, 또는 실행 권한을 부여할 수 있다.
개인용 컴퓨터나 작은 규모의 조직에서 사용되며, 높은 수준의 보안이 요구되는 환경에서는 다른 접근 제어 방식과 함께 사용되는 것이 일반적이다.
예를 들어, 기업 환경에서는 DAC와 함께 역할 기반 접근 제어(RBAC)나 강제적 접근 제어(MAC)를 함께 사용하여 보안을 강화하는 경우가 많다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DAC" href=https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/dac/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/api-design/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>