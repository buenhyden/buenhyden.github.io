<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Design Principles on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/design-principles/</link>
    <description>Recent content in Design Principles on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.154.4</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 05:43:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/design-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/</guid>
      <description>SOLID 는 객체지향 설계의 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 으로, 소프트웨어의 유지보수성과 확장성을 높이고 코드의 품질을 개선한다. 각 원칙은 단일 책임, 확장성, 대체 가능성, 인터페이스 분리, 의존성 역전을 강조한다.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/</guid>
      <description>SOLID 는 객체지향 설계의 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 으로, 소프트웨어의 유지보수성과 확장성을 높이고 코드의 품질을 개선한다. 각 원칙은 단일 책임, 확장성, 대체 가능성, 인터페이스 분리, 의존성 역전을 강조한다.</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>DRY Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/dry/</link>
      <pubDate>Mon, 23 Sep 2024 00:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/dry/</guid>
      <description>DRY 원칙은 &amp;#34; 모든 지식이나 로직은 시스템 내에서 단일하고 명확하며 권위 있는 표현을 가져야 한다 &amp;#34; 는 소프트웨어 개발 원칙이다. 코드 중복을 제거하여 유지보수성과 일관성을 향상시키고, 오류 발생 가능성을 줄이며, 개발 효율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>YAGNI Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/</link>
      <pubDate>Mon, 23 Sep 2024 00:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/yagni/</guid>
      <description>YAGNI 는 &amp;#34;You Ain&amp;#39;t Gonna Need It&amp;#34; 의 약어로, 실제로 필요하지 않은 기능은 구현하지 말라는 소프트웨어 개발 원칙이다. 이 원칙은 개발 시간을 절약하고 코드의 복잡성을 줄이며, 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>Law of Demeter</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/law-of-demeter/</link>
      <pubDate>Tue, 04 Feb 2025 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/law-of-demeter/</guid>
      <description>Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 &amp;#39; 최소 지식의 원칙 &amp;#39; 이다.</description>
    </item>
    <item>
      <title>Inversion of Control</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/</link>
      <pubDate>Tue, 03 Jun 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/</guid>
      <description>Inversion of Control(제어의 역전) 은 소프트웨어 구성 요소 간 결합도를 낮추고, 제어 흐름을 외부 프레임워크나 컨테이너에 위임함으로써 유연성, 확장성, 테스트 용이성을 높이는 설계 원칙이다. 주로 의존성 주입 (Dependency Injection) 등으로 구현되며, 모듈화와 유지보수성 향상에 핵심적 역할을 한다.</description>
    </item>
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/dip/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/dip/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Dependency Inversion Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/dip/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/dip/</guid>
      <description>**Dependency Inversion Principle**(의존성 역전 원칙)은 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화 (인터페이스)에 의존해야 한다는 원칙이다. 추상화는 세부사항에 의존하지 않으며, 세부사항이 추상화에 의존해야 한다. 이를 통해 모듈 간의 결합도를 낮추고 유연하고 확장 가능한 코드를 작성할 수 있다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/isp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/isp/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Interface Segregation Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/isp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/isp/</guid>
      <description>인터페이스 분리 원칙 (ISP) 은 클라이언트가 사용하지 않는 메서드에 의존하거나 구현을 강요받지 않도록, 인터페이스를 작고 구체적으로 분리하는 설계 원칙이다. 이를 통해 결합도를 낮추고, 유지보수성과 확장성, 테스트 용이성을 높인다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/lsp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/lsp/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Liskov Substitution Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/lsp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/lsp/</guid>
      <description>Liskov Substitution Principle(리스코프 치환 원칙, LSP)은 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 동작과 정확성이 변하지 않아야 한다는 원칙이다. 이는 상속과 다형성에서 하위 클래스가 상위 클래스의 계약과 기대를 반드시 준수해야 함을 의미하며, 안정적이고 확장 가능한 설계를 가능하게 한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/ocp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/ocp/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Open/Closed Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/ocp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/ocp/</guid>
      <description>Open/Closed Principle 은 소프트웨어 구성 요소가 **확장에는 열려 (Open)** 있고, **수정에는 닫혀 (Closed)** 있어야 한다는 설계 원칙으로, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 유연한 구조를 지향한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/srp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/solid/srp/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>Single Responsibility Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/srp/</link>
      <pubDate>Tue, 03 Jun 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-principles/solid-principles/srp/</guid>
      <description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>Convention over Configuration</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/convention-over-configuration/</link>
      <pubDate>Sat, 31 May 2025 07:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/convention-over-configuration/</guid>
      <description>Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다.</description>
    </item>
    <item>
      <title>GRASP</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/</link>
      <pubDate>Fri, 30 May 2025 12:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/</guid>
      <description>GRASP 는 객체지향 설계에서 객체와 클래스에 책임을 효과적으로 할당하기 위한 9 가지 실용적 설계 원칙의 집합이다.  Information Expert, Creator, Controller, Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations 로 구성되어 있으며 각 원칙은 객체의 역할, 책임, 협력, 결합도, 응집도 등 시스템의 구조적 품질을 높이기 위해 사용된다.</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
    <item>
      <title>Program Against Abstractions</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/program-against-abstractions/</guid>
      <description>Program Against Abstractions 는 소프트웨어 설계에서 구체 구현이 아닌 추상화 (인터페이스, 추상 클래스) 에 의존해 프로그래밍하는 원칙이다. 이를 통해 시스템의 유연성과 확장성, 유지보수성을 높이고, 코드 변경 시 영향 범위를 최소화할 수 있다.</description>
    </item>
    <item>
      <title>Composition Over Inheritance</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/composition-over-inheritance/</link>
      <pubDate>Tue, 04 Feb 2025 14:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/composition-over-inheritance/</guid>
      <description>&amp;#34;Composition Over Inheritance&amp;#34; 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 &amp;#34;is-a&amp;#34; 관계보다 &amp;#34;has-a&amp;#34; 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.</description>
    </item>
    <item>
      <title>Encapsulate What Varies</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/encapsulate-what-varies/</link>
      <pubDate>Tue, 04 Feb 2025 14:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/encapsulate-what-varies/</guid>
      <description>Encapsulate What Varies(변하는 것을 캡슐화하라) 는 시스템에서 자주 변경되거나 확장될 가능성이 있는 부분을 별도의 모듈, 클래스, 인터페이스 등으로 분리해 관리하는 설계 원칙이다. 이를 통해 코드의 유연성, 유지보수성, 확장성을 효과적으로 높일 수 있다.</description>
    </item>
    <item>
      <title>KISS Principle</title>
      <link>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/kiss/</link>
      <pubDate>Mon, 23 Sep 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/kiss/</guid>
      <description>KISS(Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 불필요한 복잡성을 피하고, 가능한 한 단순하게 설계·구현하라는 설계 원칙이다. 이를 통해 코드의 가독성, 유지보수성, 확장성을 높이고, 오류 발생 가능성을 줄일 수 있다.</description>
    </item>
  </channel>
</rss>
