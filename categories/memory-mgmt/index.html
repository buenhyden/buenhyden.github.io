<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory Mgmt | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/memory-mgmt/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/memory-mgmt/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/memory-mgmt/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/memory-mgmt/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Memory Mgmt"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Memory Mgmt"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Memory Mgmt</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Paging vs Segmentation</h2></header><div class=entry-content><p>Paging Vs Segmentation Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.
Paging:
프로세스의 주소 공간을 고정 크기의 페이지로 나누어 관리한다. 물리적 메모리를 같은 크기의 프레임으로 나눈다. 외부 단편화 문제를 해결하고 메모리 할당을 단순화한다. Segmentation:
프로세스를 논리적 단위인 세그먼트로 나누어 관리한다. 각 세그먼트의 크기는 가변적이다. 프로그램의 논리적 구조를 반영하여 메모리를 관리한다. Paging과 Segmentation 비교 특성 Paging Segmentation 분할 단위 고정 크기 페이지 가변 크기 세그먼트 주소 변환 페이지 테이블 사용 세그먼트 테이블 사용 외부 단편화 없음 발생 가능 내부 단편화 발생 가능 거의 없음 메모리 활용 효율적 유연함 구현 복잡도 상대적으로 간단 복잡함 공유와 보호 페이지 단위 세그먼트 단위 사용자 관점 투명함 프로그램 구조 반영 할당/해제 속도 빠름 상대적으로 느림 테이블 크기 큼 작음 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-16 08:24:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;114 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Paging vs Segmentation" href=https://buenhyden.github.io/til/2025/01/16/paging-vs-segmentation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>가상 메모리 (Virtual Memory)</h2></header><div class=entry-content><p>가상 메모리 (Virtual Memory) 가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.
실제 물리적 메모리(RAM)의 크기에 관계없이 프로그램이 사용할 수 있는 메모리 공간을 확장하며, 프로그램의 주소 공간을 실제 메모리에서 분리하여 가상 주소 공간을 제공한다.
가상 메모리가 필요한 이유:
메모리 제약 극복
프로그램의 크기가 실제 물리적 메모리보다 클 수 있다.
예를 들어 16GB RAM을 가진 컴퓨터에서 20GB가 필요한 프로그램을 실행할 수 있게 된다. 메모리 보호
각 프로세스는 자신만의 가상 주소 공간을 가지므로, 다른 프로세스의 메모리에 접근할 수 없다. 메모리 효율성
실제로 사용되는 부분만 물리적 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있다. Source: https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1121 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가상 메모리 (Virtual Memory)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>세그먼테이션 (Segmentation)</h2></header><div class=entry-content><p>세그먼테이션 (Segmentation) 세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.
세그먼테이션의 기본 개념을 이해하기 위해, 먼저 프로그램의 구조를 생각해보자.
일반적인 프로그램은 코드 영역, 데이터 영역, 스택 영역 등 서로 다른 목적을 가진 영역들로 구성된다.
세그먼테이션은 이러한 논리적 단위들을 각각의 세그먼트로 관리한다.
Source: https://www.geeksforgeeks.org/segmentation-in-operating-system/
세그먼테이션의 주요 구성 요소와 작동 방식 세그먼트 테이블(Segment Table):
1 2 3 4 5 6 7 8 9 10 struct SegmentTableEntry { uint32_t base; // 세그먼트의 시작 주소 uint32_t limit; // 세그먼트의 크기 bool present; // 메모리 존재 여부 struct { bool read; // 읽기 권한 bool write; // 쓰기 권한 bool execute; // 실행 권한 } protection; }; 주소 변환 과정:
논리적 주소는 다음과 같이 구성된다:
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;314 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 세그먼테이션 (Segmentation)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>페이징 (Paging)</h2></header><div class=entry-content><p>페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.
이는 두 가지 큰 문제를 발생시켰다:
큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.
이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.
Source: https://www.geeksforgeeks.org/paging-in-operating-system/
페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페이징 (Paging)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>메모리 보호와 안전 (Memory Protection and Safety)</h2></header><div class=entry-content><p>메모리 보호와 안전 (Memory Protection and Safety) 메모리 보호와 안전은 현대 컴퓨터 시스템에서 매우 중요한 요소이다.
메모리 보호는 컴퓨터 시스템에서 프로세스가 허가되지 않은 메모리 영역에 접근하는 것을 방지하는 메커니즘이다.
주요 목적은 다음과 같다:
프로세스 간 격리 유지 운영 체제 커널 보호 버그나 악성 소프트웨어로부터 시스템 보호 메모리 보호 기술 하드웨어 기반 보호 메모리 관리 장치 (MMU): 가상 주소를 물리적 주소로 변환하고 접근 권한을 확인한다. 보호 키: 메모리 영역에 키를 할당하여 접근을 제어한다. 보호 링: 권한 수준에 따라 메모리 접근을 제어한다. 세그먼테이션: 메모리를 논리적 세그먼트로 나누어 보호한다. 소프트웨어 기반 보호 가상 메모리: 각 프로세스에 독립적인 주소 공간을 제공한다. 주소 공간 레이아웃 랜덤화 (ASLR): 메모리 주소를 무작위화하여 공격을 어렵게 한다. 데이터 실행 방지 (DEP): 데이터 영역에서 코드 실행을 방지한다. 메모리 안전성 (Memory Safety) 메모리 안전성은 프로그램이 할당된 메모리 범위 내에서만 작동하도록 보장하는 개념이다.
...</p></div><footer class=entry-footer><span title='2024-12-19 08:06:00 +0000 UTC'>December 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;265 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 보호와 안전 (Memory Protection and Safety)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-protection-and-safety/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/memory-mgmt/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>