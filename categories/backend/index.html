<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>마이그레이션 (Migration)</h2></header><div class=entry-content><p>마이그레이션 (Migration) 마이그레이션(Migration)은 IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정을 의미한다.
마이그레이션은 기존 시스템 환경에서 새로운 환경으로 전환하는 것을 의미한다.
주요 목적은 비즈니스 선진화와 비용 절감, 시스템 성능 향상, 보안 강화 등이다.
마이그레이션의 유형 데이터 마이그레이션: 데이터를 한 스토리지에서 다른 스토리지로 이동. 애플리케이션 마이그레이션: 소프트웨어를 새로운 환경으로 이동. 클라우드 마이그레이션: 온프레미스에서 클라우드로, 또는 클라우드 간 이동. 비즈니스 프로세스 마이그레이션: 비즈니스 운영 방식 최적화를 위한 이동. 마이그레이션 전략 (6R) Rehost (리호스팅): 애플리케이션 구조 변경 없이 클라우드로 전환 Replatform (리플랫폼): 클라우드 환경의 일부 서비스를 활용하여 전환 Refactor (리팩터): 클라우드 환경에 적합하게 애플리케이션 구조 변경 Repurchase (리퍼체이스): 기존 시스템을 SaaS로 대체 Retire (리타이어): 기존 시스템 폐기 Retain (리테인): 현 상태 유지 마이그레이션 과정 계획: 요구사항 분석, 목표 설정, 전략 수립 실행: 데이터 또는 시스템 이전 검증: 이전된 데이터나 시스템의 정확성 및 성능 확인 주의사항 데이터 손실 위험: 마이그레이션 중 데이터 손실 가능성 고려 보안: 데이터 암호화 및 보안 조치 필요 호환성: 새 환경과의 호환성 확인 성능: 마이그레이션 후 성능 저하 가능성 고려 비용: 예상치 못한 추가 비용 발생 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-19 15:05:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;174 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 마이그레이션 (Migration)" href=https://buenhyden.github.io/posts/backend/scalability/migration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</h2></header><div class=entry-content><p>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.
GraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:08:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC" href=https://buenhyden.github.io/posts/backend/api-design/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Webhook vs Server-Sent Events</h2></header><div class=entry-content><p>Webhook Vs Server-Sent Events Webhook과 Server-Sent Events(SSE)는 실시간 데이터 전송을 위한 웹 기술이다.
Webhook은 특정 이벤트가 발생했을 때 HTTP POST 요청을 통해 다른 애플리케이션에 실시간으로 데이터를 전송하는 방식으로, 애플리케이션 간 실시간 통신을 가능하게 하며, 이벤트 기반 업데이트를 제공한다.
Server-Sent Events (SSE)은 서버에서 클라이언트로 단방향 실시간 데이터 스트림을 제공하는 기술로, 서버가 클라이언트에게 지속적으로 업데이트를 푸시할 수 있게 한다.
두 기술 모두 실시간 데이터 전송을 위해 사용되지만, 각각의 특성에 따라 적절한 상황에서 선택하여 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:04:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;180 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Webhook vs Server-Sent Events" href=https://buenhyden.github.io/posts/backend/api-design/webhook-vs-server-sent-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Connection Pool</h2></header><div class=entry-content><p>Connection Pool Connection pool(연결 풀)은 데이터베이스 연결을 효율적으로 관리하기 위한 기술이다.
이 기술은 애플리케이션의 성능을 향상시키고 리소스 사용을 최적화하는 데 중요한 역할을 한다.
Connection pool은 데이터베이스 연결을 재사용 가능한 형태로 캐시하는 메커니즘이다.
이는 애플리케이션이 데이터베이스에 연결할 때마다 새로운 연결을 생성하는 대신, 미리 생성된 연결을 사용할 수 있게 해준다.
Connection pool은 현대 데이터베이스 애플리케이션에서 필수적인 기술로, 적절히 구현 및 설정될 경우 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있다.
https://medium.com/@sujoy.swe/database-connection-pool-647843dd250b
Connection Pool의 작동 원리 초기화: 애플리케이션 시작 시 미리 정해진 수의 데이터베이스 연결을 생성하여 풀에 저장한다. 연결 요청: 클라이언트가 데이터베이스 작업을 요청하면, 풀에서 사용 가능한 연결을 가져온다. 연결 사용: 클라이언트는 가져온 연결을 사용하여 데이터베이스 작업을 수행한다. 연결 반환: 작업이 완료되면 연결은 풀로 다시 반환된다. 연결 관리: 풀은 연결의 수명주기를 관리하며, 필요에 따라 새로운 연결을 생성하거나 오래된 연결을 제거한다. Connection Pool의 주요 설정 파라미터 초기 연결 수 (initialSize):
...</p></div><footer class=entry-footer><span title='2024-10-25 06:35:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2973 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Connection Pool" href=https://buenhyden.github.io/posts/databases/connection-pool/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) and Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) and Web Server 비교 항목 Web Application Server (WAS) Web Server 기본 개념 동적 컨텐츠를 처리하고 생성하는 미들웨어로, 애플리케이션의 로직을 실행하고 데이터베이스와 상호작용 클라이언트의 HTTP 요청을 처리하고 정적 컨텐츠(HTML, 이미지 등)를 제공하는 서버 주요 기능 - 동적 컨텐츠 생성
- 비즈니스 로직 처리
- 데이터베이스 연동
- 트랜잭션 관리
- 세션 관리 - 정적 파일 제공
- 리버스 프록시
- 로드 밸런싱
- 캐싱
- 보안 설정 처리 방식 요청을 받아 서버 내부에서 프로그램을 실행하고 결과를 동적으로 생성하여 응답 클라이언트 요청에 대해 이미 존재하는 정적 파일을 직접 전송 리소스 사용 CPU와 메모리를 많이 사용하며, 동적 처리로 인한 부하가 높음 상대적으로 적은 리소스를 사용하며, 정적 파일 처리에 최적화 성능 특성 - 동적 처리로 인한 지연 발생
- 복잡한 연산 가능
- 상대적으로 느린 응답 시간 - 빠른 응답 속도
- 높은 동시성 처리
- 단순한 요청 처리에 최적화 확장성 - 수직적/수평적 확장 가능
- 로드 밸런싱 필요
- 세션 클러스터링 고려 필요 - 쉬운 수평적 확장
- 단순한 로드 밸런싱
- 상태를 유지하지 않음 보안 - 애플리케이션 레벨 보안
- 인증/인가 처리
SQL 인젝션 방어
XSS 방어 - 네트워크 레벨 보안
SSL/TLS 처리
DDoS 방어
IP 기반 접근 제어 대표적 제품 - Apache Tomcat
JBoss/WildFly
WebLogic
WebSphere - Apache HTTP Server
Nginx
IIS
LiteSpeed 사용 사례 - 전자상거래 시스템
- 온라인 뱅킹
CRM 시스템
ERP 시스템 - 기업 웹사이트
- 블로그
- 포트폴리오 사이트
- 정적 문서 호스팅 프로그래밍 지원 Java, Python, PHP,.NET 등 다양한 프로그래밍 언어와 프레임워크 지원 제한된 스크립팅 기능만 제공 (주로 설정 파일을 통한 제어) 세션 관리 세션 생성, 유지, 만료 처리 등 복잡한 세션 관리 기능 제공 세션 관리 기능 없음 데이터베이스 연동 데이터베이스 커넥션 풀 관리 및 트랜잭션 처리 데이터베이스 연동 기능 없음 모니터링 - 애플리케이션 성능 모니터링
- 메모리 사용량
- 쓰레드 상태
DB 커넥션 상태 - HTTP 요청/응답 모니터링
- 네트워크 트래픽
- 리소스 사용량 장애 대응 - 애플리케이션 레벨 장애 복구
- 트랜잭션 롤백
- 세션 복구 - 서버 레벨 장애 복구
- 정적 파일 백업
- 서버 이중화 구성 복잡도 복잡한 설정과 최적화 필요 상대적으로 단순한 설정 운영 비용 높은 하드웨어 요구사항과 관리 비용 상대적으로 낮은 운영 비용 캐싱 메커니즘 - 동적 컨텐츠 캐싱
- 데이터베이스 쿼리 캐싱
- 세션 데이터 캐싱 - 정적 파일 캐싱
HTTP 응답 캐싱
- 리버스 프록시 캐싱 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;378 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) and Web Server" href=https://buenhyden.github.io/posts/backend/web-application-server/web-application-server-and-web-server/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Message Queue vs Message Broker vs Event Broker</h2></header><div class=entry-content><p>Message Queue Vs Message Broker Vs Event Broker Message Queue, Message Broker, Event Broker의 주요 특징을 비교한 표는 다음과 같습니다:
특성 Message Queue Message Broker Event Broker 주요 기능 메시지 저장 및 전달 메시지 라우팅, 변환, 저장 이벤트 라우팅, 스트리밍, 저장 통신 모델 주로 점대점(Point-to-Point) 점대점 및 발행-구독(Pub/Sub) 주로 발행-구독(Pub/Sub) 메시지 보존 소비 후 일반적으로 삭제 구성에 따라 다름 장기간 보존 가능 확장성 제한적 중간 높음 복잡성 낮음 중간 높음 주요 사용 사례 작업 큐잉, 비동기 처리 시스템 통합, 프로토콜 변환 실시간 데이터 스트리밍, 이벤트 소싱 메시지 순서 보장 일반적으로 보장 보장 가능 재생 기능 제한적 구성에 따라 다름 일반적으로 지원 프로토콜 지원 제한적 다양한 프로토콜 지원 다양한 프로토콜 지원 대표적 제품 RabbitMQ, Redis Apache Kafka, RabbitMQ Apache Kafka, Amazon Kinesis Message Queue Vs Message Broker Message Queue와 Message Broker를 비교 분석한 표는 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-10-22 07:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;760 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue vs Message Broker vs Event Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue-vs-message-broker-vs-event-broker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>inverted index</h2></header><div class=entry-content><p>inverted index 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-02 05:07:00 +0000 UTC'>January 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to inverted index" href=https://buenhyden.github.io/posts/backend/search-engines/inverted-index/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>URL, Query & Path Parameters</h2></header><div class=entry-content><p>URL, Query & Path Parameters 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-18 16:29:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to URL, Query & Path Parameters" href=https://buenhyden.github.io/posts/backend/api-design/url-and-parameters/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Content Negotiation</h2></header><div class=entry-content><p>Content Negotiation 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-18 16:28:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Content Negotiation" href=https://buenhyden.github.io/posts/backend/api-design/content-negotiation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Content Security Policy</h2></header><div class=entry-content><p>Content Security Policy (CSP) 웹 애플리케이션의 보안을 강화하기 위한 중요한 보안 메커니즘
개념과 목적:
웹 애플리케이션에서 콘텐츠 주입 공격(XSS, 클릭재킹 등)을 방지하기 위한 보안 표준 웹사이트 소유자가 리소스 로딩을 제어할 수 있게 해주는 추가적인 보안 계층 브라우저가 신뢰할 수 있는 콘텐츠 소스를 명시적으로 선언 주요 특징:
HTTP 응답 헤더를 통해 구현 브라우저 레벨에서 정책 강제 화이트리스트 기반의 콘텐츠 제어 위반 사항에 대한 보고 메커니즘 제공 CSP 구현 방법 HTTP 헤더를 통한 구현 1 Content-Security-Policy: default-src 'self'; img-src *; script-src 'self' trusted-scripts.com; HTML 메타 태그를 통한 구현 1 2 &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src *; script-src 'self' trusted-scripts.com;"> CSP 주요 디렉티브 CSP는 다양한 리소스 유형별로 정책을 설정할 수 있습니다:
...</p></div><footer class=entry-footer><span title='2024-11-09 19:58:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;365 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Content Security Policy" href=https://buenhyden.github.io/posts/backend/web-security/content-security-policy/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/categories/backend/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>