<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/backend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/backend/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/backend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Backend</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DNS</h2></header><div class=entry-content><p>DNS DNS(Domain Name System)는 인터넷의 전화번호부와 같은 역할을 한다. 사람이 읽고 이해할 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(예: 192.0.2.1)로 변환해주는 시스템이다. 이 변환 과정은 사용자가 인터넷에서 웹사이트나 API에 접근할 때 필수적인 단계이다.
DNS의 작동 방식 DNS 변환 과정은 여러 단계로 이루어지는 분산 시스템이다.
이 과정을 “DNS 조회” 또는 “DNS 해석"이라고 부른다.
DNS 조회 과정 사용자 입력: 사용자가 브라우저에 도메인 이름(api.example.com)을 입력한다. 로컬 DNS 캐시 확인: 브라우저와 운영체제는 먼저 자체 캐시를 확인하여 최근에 방문한 도메인의 IP 주소를 찾는다. 리커시브 DNS 서버 질의: 캐시에서 찾지 못하면, 요청은 일반적으로 ISP(인터넷 서비스 제공업체)가 제공하는 리커시브 DNS 서버로 전달된다. 루트 DNS 서버 질의: 리커시브 서버는 전 세계에 분산된 루트 DNS 서버에 질의한다. 루트 서버는 최상위 도메인(TLD) 서버의 위치를 알려준다. TLD DNS 서버 질의: 리커시브 서버는 TLD 서버(예:.com,.org,.net)에 질의하여 해당 도메인의 권한 있는 네임서버의 위치를 알아낸다. 권한 있는 네임서버 질의: 리커시브 서버는 권한 있는 네임서버에 도메인 이름에 대한 IP 주소를 요청한다. 응답 반환: IP 주소는 리커시브 서버를 통해 사용자의 컴퓨터로 반환된다. 이 정보는 일정 기간 동안 캐시된다. 연결 설정: 브라우저는 이제 해당 IP 주소를 사용하여 웹 서버 또는 API 서버에 연결한다. DNS 데이터 구조 DNS는 계층적 분산 데이터베이스로 구성되어 있다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DNS" href=https://buenhyden.github.io/posts/computer-science/networking-knowledge/fundamentals/internet/dns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Domain Name</h2></header><div class=entry-content><p>Domain Name 도메인 이름은 인터넷의 기본 구성 요소로, 특히 API 디자인과 웹 서비스 개발에서 중요한 역할을 한다.
도메인 이름의 기본 개념 도메인 이름이란? 도메인 이름은 인터넷에서 특정 위치를 식별하는 사람이 읽을 수 있는 주소이다. 컴퓨터가 서로 통신할 때 사용하는 숫자로 된 IP 주소(예: 192.168.1.1) 대신, 사람이 기억하고 입력하기 쉬운 텍스트 형식(예: example.com)을 제공한다.
도메인 이름의 주요 목적은 다음과 같다:
기억하기 쉬운 웹 주소 제공 브랜드 아이덴티티 확립 웹사이트와 서비스에 대한 접근성 향상 IP 주소가 변경되더라도 일관된 접근점 유지 도메인 이름 시스템(DNS)과의 관계 도메인 이름 시스템(DNS)은 도메인 이름을 IP 주소로 변환하는 인터넷의 전화번호부와 같은 역할을 한다. 사용자가 브라우저에 도메인 이름을 입력하면, DNS는 해당 도메인 이름과 연결된 IP 주소를 찾아 사용자를 올바른 서버로 연결한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Name" href=https://buenhyden.github.io/posts/computer-science/networking-knowledge/fundamentals/internet/domain-name/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hosting</h2></header><div class=entry-content><p>Hosting 호스팅은 API 설계와 배포에 있어 핵심적인 요소이다. 잘 설계된 API도 적절한 호스팅 환경이 없다면 사용자에게 안정적으로 서비스를 제공할 수 없다.
호스팅의 기본 개념 호스팅이란 무엇인가? 호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다. API 호스팅은 API가 24시간 내내 접근 가능하고, 안정적으로 요청을 처리하며, 적절한 보안과 성능을 유지할 수 있도록 한다.
호스팅 서비스는 다음과 같은 기본 요소를 제공한다:
서버 인프라(물리적 또는 가상 서버) 네트워크 연결 저장 공간 처리 능력(CPU, 메모리) 보안 장치 관리 도구 웹 서버의 역할 호스팅의 핵심에는 웹 서버가 있다.
...</p></div><footer class=entry-footer><span title='2025-03-31 23:50:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hosting" href=https://buenhyden.github.io/posts/computer-science/networking-knowledge/fundamentals/internet/hosting/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>API Integration Patterns</h2></header><div class=entry-content><p>API Integration Patterns API 통합 패턴은 다양한 시스템, 서비스, 애플리케이션이 효과적으로 통신하고 상호작용할 수 있도록 하는 설계 접근법이다. 이러한 패턴들은 복잡한 시스템 간의 통합 과정에서 발생하는 문제를 해결하고, 확장 가능하며 유지보수가 용이한 아키텍처를 구축하는 데 도움이 된다.
API 통합의 기본 개념 API 통합은 서로 다른 소프트웨어 시스템이 함께 작동할 수 있도록 연결하는 과정이다. 현대 기업 환경에서는 수많은 애플리케이션, 서비스, 데이터베이스가 존재하며, 이들 간의 원활한 정보 교환이 필수적이다. API 통합을 통해 이러한 시스템들은 서로의 기능을 활용하고 데이터를 공유할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-06 13:00:00 +0000 UTC'>March 6, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Integration Patterns" href=https://buenhyden.github.io/posts/backend/backend-architecture/api-design-architecture/api-integration-patterns/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Optimize API Response</h2></header><div class=entry-content><p>Optimize API Response API 응답 최적화는 현대 웹 애플리케이션의 성능, 사용자 경험 및 자원 효율성을 크게 향상시키는 핵심 요소이다.
Enforcing Reasonable Payload Size Limits 페이로드 크기는 API 성능에 직접적인 영향을 미친다. 대용량 데이터 전송은 네트워크 대역폭을 소모하고 서버 처리 시간을 증가시킨다.
페이로드 제한의 중요성 네트워크 효율성: 작은 페이로드는 더 빠른 전송 시간을 의미한다. 연구에 따르면 모바일 환경에서 5MB 이상의 페이로드는 평균 응답 시간을 3-4초 증가시킨다. 서버 리소스 관리: 대형 페이로드를 처리할 때 서버의 메모리 사용량이 급증할 수 있다. 이는 특히 동시 요청이 많을 때 서버 과부하로 이어질 수 있다. 데이터베이스 효율성: 대형 데이터를 저장하고 검색하는 것은 데이터베이스 성능에 부담을 준다. 구현 전략 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Express.js에서 페이로드 크기 제한 설정 예제 const express = require('express'); const app = express(); // JSON 페이로드 크기를 1MB로 제한 app.use(express.json({ limit: '1mb' })); // 폼 데이터 크기를 5MB로 제한 app.use(express.urlencoded({ extended: true, limit: '5mb' })); // 특정 라우트에 대해 다른 제한 적용 app.post('/upload-profile-image', express.json({ limit: '2mb' }), (req, res) => { // 프로필 이미지 처리 로직 }); 모범 사례 컨텐츠 유형별 제한: 이미지, 비디오, 텍스트 데이터에 대해 각기 다른 제한을 설정한다. 클라이언트 측 검증: 서버에 보내기 전에 클라이언트에서 파일 크기를 확인한다. 점진적 업로드: 대용량 파일은 청크(chunk) 단위로 분할하여 전송한다. 압축 권장: 가능한 경우 클라이언트 측에서 데이터 압축을 권장한다. Enabling Compression for Responses 데이터 압축은 전송되는 바이트 수를 감소시켜 네트워크 대역폭을 절약하고 응답 시간을 단축시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:39:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Optimize API Response" href=https://buenhyden.github.io/posts/backend/api-design/api-lifecycle-management/performance-management/optimize-api-response/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asynchronism</h2></header><div class=entry-content><p>Asynchronism 백엔드 시스템의 성능을 최적화하는 것은 현대 애플리케이션 개발에서 핵심적인 과제이다. 특히 비동기 처리(Asynchronism)는 시스템의 응답성과 확장성을 크게 향상시킬 수 있는 강력한 패러다임이다.
Offloading Heavy Tasks to Background Jobs or Queues 기본 개념 백그라운드 작업 처리는 시간이 오래 걸리거나 리소스를 많이 소모하는 작업을 주 실행 스레드에서 분리하여 별도의 프로세스나 스레드에서 비동기적으로 실행하는 기법이다. 이를 통해 사용자 요청에 대한 응답 시간을 크게 개선할 수 있다.
구현 방법 작업 큐 시스템 활용 작업 큐 시스템은 백그라운드 작업 처리의 가장 일반적인 구현 방법이다.
...</p></div><footer class=entry-footer><span title='2025-02-12 01:32:00 +0000 UTC'>February 12, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asynchronism" href=https://buenhyden.github.io/posts/backend/performance-optimization/asynchronous-processing/asynchronism/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h2></header><div class=entry-content><p>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.
기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성
• 우수한 확장성
• 효율적인 로드밸런싱
• 실시간 데이터 동기화 • 구현이 상대적으로 간단
• 비용 효율적
• 지리적 분산 용이
• 읽기 성능 향상 단점 • 구현 비용이 높음
• 복잡한 구성
• 네트워크 대역폭 필요
• 관리 어려움 • 데이터 일관성 보장 어려움
• 쓰기 성능 향상 제한적
• 마스터 노드 병목 현상
• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리
• 실시간 데이터 처리
• 무중단 서비스 필요
• 대규모 동시 접속 처리 • 데이터 백업
• 읽기 작업이 많은 서비스
• 지역별 서비스 제공
• 재해 복구 대비 산업 분야 • 금융 거래 시스템
• 통신 서비스
• 대형 전자상거래
• 실시간 예약 시스템 • 콘텐츠 제공 서비스
• 분석 리포팅 시스템
• 글로벌 서비스
• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요
• 낮은 지연시간 필수
• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능
• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요
• 동일한 사양의 노드 권장
• 충분한 메모리 • 마스터 노드 성능 중요
• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요
• 모니터링 시스템 필수
• 정기적인 유지보수 • 상대적으로 간단한 관리
• 백업 정책 중요
• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-25 15:42:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)" href=https://buenhyden.github.io/posts/backend/databases/scaling-databases/database-clustering-and-replication/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Metric</h2></header><div class=entry-content><p>Metric Metric는 시스템의 상태와 성능을 수치화하여 측정하는 중요한 관측 도구이다.
Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값이다.
예를 들어, 웹 서버의 응답 시간, CPU 사용률, 메모리 사용량 등이 Metric가 될 수 있다.
장점 효율적인 저장: 숫자 데이터는 저장 공간을 적게 차지한다. 빠른 쿼리: 시계열 데이터베이스를 사용하여 빠른 검색과 분석이 가능하다. 장기 추세 분석: 오랜 기간 동안의 데이터를 저장하고 분석할 수 있다. 시각화 용이성: 그래프나 대시보드로 쉽게 표현할 수 있다. 단점 초기 설정에 시간과 노력이 필요하다 너무 많은 Metric는 오히려 혼란을 줄 수 있다 저장 공간과 처리 리소스가 필요하다 Metric의 중요성 성능 모니터링: 시스템의 전반적인 성능을 지속적으로 모니터링할 수 있다. 문제 감지: 비정상적인 패턴이나 임계값 초과를 빠르게 감지할 수 있다. 용량 계획: 리소스 사용량 추세를 분석하여 미래의 용량을 계획할 수 있다. 최적화: 성능 병목 현상을 식별하고 최적화할 수 있는 기회를 제공한다. Metric의 구성 요소 일반적인 Metric는 다음 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metric" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/metrics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Trace</h2></header><div class=entry-content><p>Trace Trace는 분산 시스템에서 요청의 흐름을 추적하고 시각화하는 데 사용된다.
Trace는 분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것이다.
각 Trace는 하나 이상의 span으로 구성되며, 첫 번째 span은 root span이라고 한다.
Trace의 목적 분산 시스템에서의 요청 흐름 이해 성능 병목 지점 식별 서비스 간 의존성 파악 오류 및 지연의 근본 원인 분석 Trace의 구성 요소 트레이스는 다음과 같은 구성 요소들로 이루어진다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 트레이스 시작 Span rootSpan = tracer.spanBuilder("checkout-process") .setSpanKind(SpanKind.SERVER) .startSpan(); try (Scope scope = rootSpan.makeCurrent()) { // 자식 스팬 생성 Span paymentSpan = tracer.spanBuilder("process-payment") .setParent(Context.current().with(rootSpan)) .startSpan(); try { processPayment(); paymentSpan.setStatus(StatusCode.OK); } catch (Exception e) { paymentSpan.setStatus(StatusCode.ERROR, e.getMessage()); throw e; } finally { paymentSpan.end(); } } finally { rootSpan.end(); } 트레이스 구성의 핵심 요소들:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trace" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/tracing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log</h2></header><div class=entry-content><p>Log Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.
문제가 발생했을 때 무슨 일이 있었는지 추적할 수 있게 해주며, 시스템의 동작을 이해하는 데 필수적인 정보를 제공한다.
로그 구조를 설계할 때는 다음과 같은 원칙들을 고려해야 한다:
일관성(Consistency): 모든 로그 항목은 동일한 구조와 형식을 따라야 한다. 이는 로그 파싱과 분석을 용이하게 만든다. 검색 가능성(Searchability): 주요 필드들은 쉽게 검색하고 필터링할 수 있는 형태여야 한다. 확장성(Extensibility): 새로운 정보를 추가할 필요가 생겼을 때 기존 구조를 해치지 않고 확장할 수 있어야 한다. 상세도 조절(Verbosity Control): 로그 레벨을 통해 필요한 상세도를 조절할 수 있어야 한다. 로그 구조를 효과적으로 설계하면 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/logging/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>