<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structural Design Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/structural-design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/structural-design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/structural-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/structural-design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Structural Design Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Structural Design Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Structural Design Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Flyweight Pattern</h2></header><div class=entry-content><p>Flyweight Pattern Flyweight 패턴은 구조적 디자인 패턴 중 하나로, 객체를 공유하여 메모리 사용을 최소화하는 패턴이다.
플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.
간단히 말하면 캐시(Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성(extrinsic)과 변하지 않는 속성(intrinsic)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.
Flyweight 패턴의 주요 구성 요소 Flyweight: 경량 객체를 묶는 인터페이스. ConcreteFlyweight: 공유 가능하여 재사용되는 객체로, intrinsic state를 포함한다. UnsahredConcreteFlyweight: 공유 불가능한 객체로, extrinsic state를 포함한다. FlyweightFactory: 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스. Client: FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다. Flyweight 패턴의 동작 방식 FlyweightFactory는 Flyweight 객체들을 생성하고 관리한다. GetFlyweight() 메서드는 팩토리 메서드 역할을 한다. 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다. Flyweight 패턴의 장점 많은 객체를 만들 때 성능을 향상시킬 수 있다. 많은 객체를 만들 때 메모리를 줄일 수 있다. 메모리 절약: 대규모 객체 시스템에서 상당한 메모리 절감 효과를 얻을 수 있다. 중복 최소화: 공유를 통해 객체의 중복 생성을 방지한다. Flyweight 패턴의 단점 특정 인스턴스를 다르게 처리하는 것이 힘들어진다. 코드 복잡성 증가: 객체를 공유하는 방식은 구현을 복잡하게 만들 수 있다. 런타임 비용: 객체 상태를 관리하는 데 런타임 비용이 발생할 수 있다. Flyweight 패턴의 사용 시기 대량의 작은 객체를 생성해야 할 때 유용하다. 객체의 상태를 자주 변하는 속성(Extrinsic)과 변하지 않는 속성(Intrinsic)으로 분리할 수 있을 때 적합하다. 공통된 내재 상태를 공유함으로써 메모리 사용을 줄일 수 있을 때 사용한다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Dict # Flyweight 클래스: 공유될 객체의 내부 상태를 정의 class CharacterStyle: def __init__(self, font_name: str, font_size: int, bold: bool): self.font_name = font_name self.font_size = font_size self.bold = bold def render(self, char: str, position: tuple) -> None: print(f"Rendering '{char}' at {position} with {self.font_name}, " f"size {self.font_size}, {'bold' if self.bold else 'normal'}") # Flyweight 팩토리: Flyweight 객체들을 관리하고 공유 class CharacterStyleFactory: def __init__(self): self._styles: Dict[str, CharacterStyle] = {} def get_style(self, font_name: str, font_size: int, bold: bool) -> CharacterStyle: # 스타일을 식별하기 위한 키 생성 key = f"{font_name}-{font_size}-{bold}" # 스타일이 존재하지 않으면 새로 생성 if key not in self._styles: self._styles[key] = CharacterStyle(font_name, font_size, bold) print(f"Creating new style: {key}") return self._styles[key] def get_style_count(self) -> int: return len(self._styles) # 문자 객체: Flyweight를 사용하는 클래스 class Character: def __init__(self, char: str, style: CharacterStyle, position: tuple): self.char = char # 외부 상태 (extrinsic state) self.style = style # 공유 상태 (intrinsic state) self.position = position # 외부 상태 def render(self) -> None: self.style.render(self.char, self.position) 실제 사용 예시
...</p></div><footer class=entry-footer><span title='2024-09-25 08:25:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;776 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flyweight Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/flyweight-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Composite Pattern</h2></header><div class=entry-content><p>Composite Pattern Composite Pattern은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴이다.
Composite Pattern은 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층 구조를 만든다. 이 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 동일하게 다룰 수 있다.
Composite Pattern은 복잡한 트리 구조를 간단하게 다룰 수 있게 해주는 강력한 도구이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 요구사항과 구조를 고려하여 적절히 사용해야 한다.
주요 구성 요소 Composite Pattern은 다음과 같은 주요 구성 요소로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:24:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;718 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composite Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/composite-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Bridge Pattern</h2></header><div class=entry-content><p>Bridge Pattern 복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴
TV 제조사가 다양하고(구현), 리모컨의 종류도 다양(추상화)하지만, 이들은 서로 독립적으로 발전하면서도 함께 잘 동작할 수 있다.
특징 추상화와 구현을 두 개의 독립적인 클래스 계층으로 분리합니다. 구현부에 대한 참조를 통해 추상화와 구현을 연결합니다. 런타임에 구현을 교체할 수 있는 유연성을 제공합니다. 사용사례 그래픽 시스템에서 다양한 플랫폼(Windows, macOS, Linux)에서 동작하는 다양한 도형(원, 사각형, 삼각형)을 그려야 할 때 여러 데이터베이스 시스템과 연동되는 다양한 타입의 로깅 시스템을 구현할 때 다양한 디바이스에서 실행되는 여러 종류의 사용자 인터페이스를 개발할 때 여러 종류의 메시지(이메일, SMS, 푸시알림)를 다양한 포맷(HTML, 텍스트, JSON)으로 전송해야 할 때 장점 추상화와 구현의 분리로 인한 높은 유연성과 확장성을 제공합니다. 새로운 추상화나 구현을 추가할 때 기존 코드를 수정하지 않아도 됩니다. 각 계층이 독립적으로 발전할 수 있어 시스템의 진화가 용이합니다. 구현 세부사항을 클라이언트로부터 숨길 수 있습니다. 단점 추상화와 구현 사이에 간접 계층이 추가되어 복잡도가 증가할 수 있습니다. 설계 초기에 브리지 패턴을 적용하지 않으면 나중에 리팩터링하기 어려울 수 있습니다. 작은 규모의 시스템에서는 오버엔지니어링이 될 수 있습니다. 주의사항 및 고려사항 브리지 패턴을 적용하기 전에 시스템이 정말로 이러한 유연성을 필요로 하는지 검토해야 합니다. 추상화와 구현 계층 사이의 의존성을 최소화하도록 인터페이스를 설계해야 합니다. 각 계층의 책임 범위를 명확히 정의하고, 단일 책임 원칙을 지키도록 해야 합니다. 성능에 민감한 시스템에서는 추가되는 간접 계층으로 인한 오버헤드를 고려해야 합니다. 브리지 패턴은 초기 설계 단계에서 적용하는 것이 가장 효과적입니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod # Implementation interface class MessageSender(ABC): @abstractmethod def send(self, message: str, recipient: str) -> bool: pass # Concrete implementations class EmailSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending email to {recipient}") print(f"Email content: {message}") return True class SMSSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending SMS to {recipient}") print(f"SMS content: {message}") return True class PushNotificationSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending push notification to device {recipient}") print(f"Notification content: {message}") return True # Abstraction class Message(ABC): def __init__(self, sender: MessageSender): self.sender = sender @abstractmethod def send(self, recipient: str) -> bool: pass # Refined Abstractions class SimpleMessage(Message): def __init__(self, sender: MessageSender, content: str): super().__init__(sender) self.content = content def send(self, recipient: str) -> bool: return self.sender.send(self.content, recipient) class HTMLMessage(Message): def __init__(self, sender: MessageSender, html_content: str): super().__init__(sender) self.html_content = html_content def send(self, recipient: str) -> bool: formatted_content = f"&lt;html>&lt;body>{self.html_content}&lt;/body>&lt;/html>" return self.sender.send(formatted_content, recipient) class EncryptedMessage(Message): def __init__(self, sender: MessageSender, content: str, encryption_key: str): super().__init__(sender) self.content = content self.encryption_key = encryption_key def send(self, recipient: str) -> bool: # Simulate encryption encrypted_content = f"ENCRYPTED[{self.content}] WITH KEY {self.encryption_key}" return self.sender.send(encrypted_content, recipient) # Message Factory for convenience class MessageFactory: @staticmethod def create_simple_message(sender: MessageSender, content: str) -> SimpleMessage: return SimpleMessage(sender, content) @staticmethod def create_html_message(sender: MessageSender, html_content: str) -> HTMLMessage: return HTMLMessage(sender, html_content) @staticmethod def create_encrypted_message( sender: MessageSender, content: str, key: str ) -> EncryptedMessage: return EncryptedMessage(sender, content, key) # Usage example if __name__ == "__main__": # Create senders email_sender = EmailSender() sms_sender = SMSSender() push_sender = PushNotificationSender() # Create message factory factory = MessageFactory() # Create and send different types of messages using different senders simple_email = factory.create_simple_message( email_sender, "Hello from Python!" ) simple_email.send("user@example.com") html_email = factory.create_html_message( email_sender, "&lt;h1>Hello&lt;/h1>&lt;p>This is HTML email&lt;/p>" ) html_email.send("user@example.com") encrypted_sms = factory.create_encrypted_message( sms_sender, "Secret message", "encryption_key_123" ) encrypted_sms.send("+1234567890") simple_push = factory.create_simple_message( push_sender, "New notification!" ) simple_push.send("device_token_123") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // Implementation interface class LogStorage { save(logEntry) { throw new Error('save method must be implemented'); } retrieve(id) { throw new Error('retrieve method must be implemented'); } } // Concrete implementations class FileLogStorage extends LogStorage { constructor(filepath) { super(); this.filepath = filepath; this.logs = new Map(); console.log(`Initializing File Storage at ${filepath}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to file: ${this.filepath}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class DatabaseLogStorage extends LogStorage { constructor(connectionString) { super(); this.connectionString = connectionString; this.logs = new Map(); console.log(`Connecting to database: ${connectionString}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to database: ${this.connectionString}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class CloudLogStorage extends LogStorage { constructor(cloudProvider, region) { super(); this.cloudProvider = cloudProvider; this.region = region; this.logs = new Map(); console.log(`Connecting to ${cloudProvider} in ${region}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to ${this.cloudProvider} cloud storage in ${this.region}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } // Abstraction class Logger { constructor(storage) { this.storage = storage; } log(message) { throw new Error('log method must be implemented'); } getLog(id) { return this.storage.retrieve(id); } } // Refined Abstractions class SimpleLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO' }; return this.storage.save(entry); } } class DetailedLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO', processId: process.pid, hostname: require('os').hostname(), memory: process.memoryUsage() }; return this.storage.save(entry); } } class SecurityLogger extends Logger { constructor(storage, encryptionKey) { super(storage); this.encryptionKey = encryptionKey; } log(message) { const entry = { timestamp: new Date().toISOString(), message: this.encrypt(message), level: 'SECURE', encryptionVersion: '1.0' }; return this.storage.save(entry); } encrypt(message) { // Simulate encryption return `ENCRYPTED[${message}] WITH KEY ${this.encryptionKey}`; } } // Usage example // Create different storage implementations const fileStorage = new FileLogStorage('/var/log/app.log'); const dbStorage = new DatabaseLogStorage('mongodb://localhost:27017/logs'); const cloudStorage = new CloudLogStorage('AWS', 'us-east-1'); // Create different types of loggers with different storage backends const simpleFileLogger = new SimpleLogger(fileStorage); const detailedDbLogger = new DetailedLogger(dbStorage); const secureCloudLogger = new SecurityLogger(cloudStorage, 'secret-key-123'); // Use the loggers const fileLogId = simpleFileLogger.log('Simple file log message'); console.log('Retrieved file log:', simpleFileLogger.getLog(fileLogId)); const dbLogId = detailedDbLogger.log('Detailed database log message'); console.log('Retrieved database log:', detailedDbLogger.getLog(dbLogId)); const cloudLogId = secureCloudLogger.log('Secure cloud log message'); console.log('Retrieved cloud log:', secureCloudLogger.getLog(cloudLogId)); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bridge Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/bridge-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Decorator Pattern</h2></header><div class=entry-content><p>Decorator Pattern 객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴
“래퍼(wrapper)” 개념으로 각 데코레이터는 원본 객체를 감싸면서 추가 기능을 제공한다.
여러 데코레이터를 겹겹이 쌓을 수 있으며, 각 계층은 이전 계층의 기능을 확장한다.
특징 기존 객체의 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 상속 대신 구성(composition)을 사용하여 객체의 기능을 확장합니다. 객체를 여러 데코레이터로 감싸 기능을 조합할 수 있습니다. 사용사례 파일 입출력 시스템에서 압축, 암호화, 버퍼링 등의 기능을 조합할 때 웹 서비스에서 로깅, 캐싱, 인증 등의 기능을 동적으로 추가할 때 GUI 컴포넌트에 테두리, 스크롤바, 색상 등의 시각적 요소를 조합할 때 게임 캐릭터에 아이템, 버프, 상태 효과 등을 적용할 때 장점 객체의 기능을 동적으로 확장할 수 있어 매우 유연합니다. 단일 책임 원칙을 지키면서 기능을 조합할 수 있습니다. 상속을 통한 확장보다 더 유연한 방식을 제공합니다. 런타임에 객체의 행동을 변경할 수 있습니다. 단점 데코레이터를 너무 많이 사용하면 코드가 복잡해질 수 있습니다. 데코레이터들의 순서가 결과에 영향을 미칠 수 있어 주의가 필요합니다. 작은 객체들이 많이 생성되어 코드를 이해하기 어려울 수 있습니다. 주의사항 및 고려사항 데코레이터의 순서를 신중하게 고려해야 합니다. 예를 들어, 텍스트 처리에서 HTML 이스케이프를 마크다운 변환 전에 하면 원하는 결과를 얻을 수 없습니다. 데코레이터 체인이 너무 길어지지 않도록 주의해야 합니다. 필요한 경우 자주 사용되는 조합을 별도의 클래스로 만드는 것을 고려하세요. 데코레이터들 간의 상호작용을 고려해야 합니다. 한 데코레이터의 출력이 다른 데코레이터의 입력으로 적절한지 확인해야 합니다. 성능에 민감한 상황에서는 데코레이터 체인으로 인한 오버헤드를 고려해야 합니다. 디버깅이 어려울 수 있으므로, 로깅이나 모니터링 기능을 추가하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 from abc import ABC, abstractmethod from typing import List # Component interface class Coffee(ABC): """Base Coffee interface""" @abstractmethod def get_cost(self) -> float: pass @abstractmethod def get_ingredients(self) -> List[str]: pass @abstractmethod def get_description(self) -> str: pass # Concrete component class SimpleCoffee(Coffee): """Basic coffee implementation""" def get_cost(self) -> float: return 2.0 def get_ingredients(self) -> List[str]: return ["Coffee"] def get_description(self) -> str: return "Simple coffee" # Base decorator class CoffeeDecorator(Coffee): """Base decorator class""" def __init__(self, coffee: Coffee): self._coffee = coffee def get_cost(self) -> float: return self._coffee.get_cost() def get_ingredients(self) -> List[str]: return self._coffee.get_ingredients() def get_description(self) -> str: return self._coffee.get_description() # Concrete decorators class MilkDecorator(CoffeeDecorator): """Adds milk to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.5 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Milk"] def get_description(self) -> str: return f"{super().get_description()}, with steamed milk" class WhipDecorator(CoffeeDecorator): """Adds whipped cream to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.7 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Whipped Cream"] def get_description(self) -> str: return f"{super().get_description()}, topped with whipped cream" class CaramelDecorator(CoffeeDecorator): """Adds caramel to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.6 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Caramel"] def get_description(self) -> str: return f"{super().get_description()}, drizzled with caramel" class ExtraShotDecorator(CoffeeDecorator): """Adds an extra shot of espresso""" def get_cost(self) -> float: return super().get_cost() + 1.0 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Extra Espresso Shot"] def get_description(self) -> str: return f"{super().get_description()}, with an extra shot" # Order management class CoffeeOrder: """Manages coffee orders and provides order summary""" def __init__(self): self.coffee = None def create_order(self) -> None: """Creates a new coffee order starting with simple coffee""" self.coffee = SimpleCoffee() def add_milk(self) -> None: self.coffee = MilkDecorator(self.coffee) def add_whip(self) -> None: self.coffee = WhipDecorator(self.coffee) def add_caramel(self) -> None: self.coffee = CaramelDecorator(self.coffee) def add_extra_shot(self) -> None: self.coffee = ExtraShotDecorator(self.coffee) def get_order_summary(self) -> str: """Generates a summary of the current order""" return f""" Order Summary: Description: {self.coffee.get_description()} Ingredients: {', '.join(self.coffee.get_ingredients())} Total Cost: ${self.coffee.get_cost():f} """ # Usage example if __name__ == "__main__": # Create a new order order = CoffeeOrder() order.create_order() # Customize the coffee with various additions order.add_milk() order.add_extra_shot() order.add_whip() order.add_caramel() # Print the order summary print(order.get_order_summary()) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // Component interface class TextProcessor { constructor() { if (this.constructor === TextProcessor) { throw new Error("Abstract class cannot be instantiated"); } } process(text) { throw new Error("Method 'process' must be implemented"); } } // Concrete component class SimpleTextProcessor extends TextProcessor { process(text) { return text; } } // Base decorator class TextProcessorDecorator extends TextProcessor { constructor(processor) { super(); this._processor = processor; } process(text) { return this._processor.process(text); } } // Concrete decorators class CapitalizeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.toUpperCase(); } } class TrimDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.trim(); } } class HTMLEscapeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/&/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/>/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); } } class MarkdownToHTMLDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/\*\*(.*?)\*\*/g, '&lt;strong>$1&lt;/strong>') .replace(/\*(.*?)\*/g, '&lt;em>$1&lt;/em>') .replace(/\[(.*?)\]\((.*?)\)/g, '&lt;a href="$2">$1&lt;/a>') .replace(/^# (.*$)/gm, '&lt;h1>$1&lt;/h1>') .replace(/^## (.*$)/gm, '&lt;h2>$1&lt;/h2>'); } } class ValidationDecorator extends TextProcessorDecorator { constructor(processor, maxLength = 1000) { super(processor); this.maxLength = maxLength; } process(text) { if (!text) { throw new Error("Text cannot be empty"); } if (text.length > this.maxLength) { throw new Error(`Text length exceeds maximum limit of ${this.maxLength} characters`); } return this._processor.process(text); } } // Text processing manager class TextProcessingManager { constructor() { this.processor = new SimpleTextProcessor(); this.history = []; } addCapitalization() { this.processor = new CapitalizeDecorator(this.processor); return this; } addTrimming() { this.processor = new TrimDecorator(this.processor); return this; } addHTMLEscaping() { this.processor = new HTMLEscapeDecorator(this.processor); return this; } addMarkdownProcessing() { this.processor = new MarkdownToHTMLDecorator(this.processor); return this; } addValidation(maxLength) { this.processor = new ValidationDecorator(this.processor, maxLength); return this; } process(text) { const result = this.processor.process(text); this.history.push({ input: text, output: result, timestamp: new Date() }); return result; } getProcessingHistory() { return this.history; } } // Usage example const manager = new TextProcessingManager(); // Configure text processing chain manager .addValidation(2000) .addTrimming() .addMarkdownProcessing() .addHTMLEscaping(); // Process some text try { const input = ` # Welcome to Text Processing This is a **bold** and *italic* text example. [Click here](https://example.com) to learn more. `; const result = manager.process(input); console.log("Processed text:"); console.log(result); console.log("\nProcessing history:"); console.log(manager.getProcessingHistory()); } catch (error) { console.error("Error processing text:", error.message); } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1240 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decorator Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/decorator-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Facade Pattern</h2></header><div class=entry-content><p>Facade Pattern 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조적 디자인 패턴
TV, 오디오, 조명 등 복잡한 홈시어터 시스템이 있을 때, 리모컨 하나로 이 모든 것을 간단히 제어할 수 있게 해주는 것처럼, 퍼사드 패턴은 복잡한 시스템을 간단한 인터페이스로 감싸주는 패턴
특징 복잡한 서브시스템을 감싸는 단순한 인터페이스를 제공합니다. 클라이언트와 서브시스템 간의 결합도를 낮춥니다. 고수준 인터페이스를 정의하여 서브시스템을 더 쉽게 사용할 수 있게 합니다. 사용사례 복잡한 라이브러리나 프레임워크를 간단하게 사용해야 할 때 레거시 코드를 새로운 인터페이스로 감싸야 할 때 서브시스템을 계층화할 때 장점 결합도 감소: 클라이언트는 복잡한 서브시스템 대신 Facade와만 상호작용하므로, 시스템 간의 결합도가 낮아집니다. 코드 가독성 향상: 복잡한 로직을 Facade 뒤로 숨김으로써 클라이언트 코드가 더 깔끔하고 이해하기 쉬워집니다. 유지보수성 증가: 서브시스템의 변경이 Facade 내부에 국한되므로, 클라이언트 코드를 수정할 필요가 없어집니다. 계층화된 구조: 복잡한 시스템을 계층화하여 관리할 수 있게 해줍니다. 단점 Facade 클래스가 과도한 책임을 지게 될 수 있습니다. 성능 저하가 발생할 수 있습니다. 서브시스템의 모든 기능을 사용할 수 없을 수 있습니다. 주의사항 및 고려사항 인터페이스 설계: Facade의 인터페이스는 가능한 한 단순하고 직관적이어야 합니다. 위 예제에서처럼 복잡한 프로세스를 하나의 메서드로 단순화하는 것이 좋습니다. 의존성 관리: Facade는 서브시스템 컴포넌트들과의 의존성을 잘 관리해야 합니다. 필요한 경우 의존성 주입을 사용하여 유연성을 확보할 수 있습니다. 테스트 용이성: Facade 패턴을 사용하면 복잡한 시스템을 테스트하기가 더 쉬워집니다. 단일 진입점을 통해 전체 시스템을 테스트할 수 있기 때문입니다. 확장성: 시스템이 발전함에 따라 새로운 기능을 추가해야 할 수 있습니다. Facade는 이러한 변화를 수용할 수 있도록 설계되어야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 복잡한 서브시스템 클래스들 class VideoFile: def __init__(self, filename): self.filename = filename self.codec = self.detect_codec() def detect_codec(self): return self.filename.split(".")[1] class CompressionCodec: def __init__(self, type): self.type = type class MPEG4CompressionCodec(CompressionCodec): def __init__(self): super().__init__("mp4") class OGGCompressionCodec(CompressionCodec): def __init__(self): super().__init__("ogg") class CodecFactory: @staticmethod def extract_codec(file): type = file.codec if type == "mp4": return MPEG4CompressionCodec() else: return OGGCompressionCodec() class BitrateReader: @staticmethod def read(filename, codec): print(f"BitrateReader: reading file {filename} with codec {codec.type}") return f"video_data_{filename}" @staticmethod def convert(buffer, codec): print(f"BitrateReader: writing file with codec {codec.type}") return f"converted_data_{buffer}" # Facade 클래스 class VideoConverter: def convert(self, filename, target_format): video_file = VideoFile(filename) source_codec = CodecFactory.extract_codec(video_file) if target_format == "mp4": destination_codec = MPEG4CompressionCodec() else: destination_codec = OGGCompressionCodec() buffer = BitrateReader.read(filename, source_codec) result = BitrateReader.convert(buffer, destination_codec) return result # 클라이언트 코드 def main(): converter = VideoConverter() mp4 = converter.convert("funny-cats.ogg", "mp4") print(f"VideoConverter: conversion completed -> {mp4}") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 복잡한 서브시스템 클래스들 class VideoFile { constructor(filename) { this.filename = filename; this.codec = this.detectCodec(); } detectCodec() { return this.filename.split(".")[1]; } } class CompressionCodec { constructor(type) { this.type = type; } } class MPEG4CompressionCodec extends CompressionCodec { constructor() { super("mp4"); } } class OGGCompressionCodec extends CompressionCodec { constructor() { super("ogg"); } } class CodecFactory { static extractCodec(file) { const type = file.codec; if (type === "mp4") { return new MPEG4CompressionCodec(); } return new OGGCompressionCodec(); } } class BitrateReader { static read(filename, codec) { console.log(`BitrateReader: reading file ${filename} with codec ${codec.type}`); return `video_data_${filename}`; } static convert(buffer, codec) { console.log(`BitrateReader: writing file with codec ${codec.type}`); return `converted_data_${buffer}`; } } // Facade 클래스 class VideoConverter { convert(filename, targetFormat) { const videoFile = new VideoFile(filename); const sourceCodec = CodecFactory.extractCodec(videoFile); const destinationCodec = targetFormat === "mp4" ? new MPEG4CompressionCodec() : new OGGCompressionCodec(); const buffer = BitrateReader.read(filename, sourceCodec); const result = BitrateReader.convert(buffer, destinationCodec); return result; } } // 클라이언트 코드 function main() { const converter = new VideoConverter(); const mp4 = converter.convert("funny-cats.ogg", "mp4"); console.log(`VideoConverter: conversion completed -> ${mp4}`); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;684 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Facade Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/facade-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Proxy Pattern</h2></header><div class=entry-content><p>Proxy Pattern 객체에 대한 접근을 제어하기 위한 대리인(또는 대변인) 역할을 하는 객체를 제공하는 구조적 디자인 패턴
특징 실제 객체를 대신하여 그 객체에 대한 접근을 제어하는 대리 객체를 제공합니다. 프록시는 실제 객체와 동일한 인터페이스를 가지며, 클라이언트는 프록시를 통해 실제 객체에 접근합니다. 객체에 대한 접근을 제어하고 추가적인 기능을 제공할 수 있습니다. 사용사례 가상 프록시 (Virtual Proxy): 무거운 객체의 생성을 필요한 시점까지 지연시킵니다. 예를 들어, 고해상도 이미지를 로딩할 때 처음에는 저해상도 이미지를 보여주고, 실제로 필요할 때 고해상도 이미지를 로딩하는 방식입니다. 보호 프록시 (Protection Proxy): 객체에 대한 접근 권한을 제어합니다. 사용자의 권한에 따라 특정 메서드의 호출을 허용하거나 거부할 수 있습니다. 캐싱 프록시 (Caching Proxy): 비용이 많이 드는 작업의 결과를 캐시하고, 동일한 요청이 올 경우 캐시된 결과를 반환합니다. 로깅 프록시 (Logging Proxy): 메서드 호출과 매개변수들을 기록하여 로깅이나 디버깅에 활용합니다. 장점 보안 강화: 클라이언트가 직접 중요한 객체에 접근하는 것을 제어할 수 있습니다. 성능 최적화: 무거운 객체의 생성을 지연시키거나 결과를 캐싱함으로써 시스템의 성능을 향상시킬 수 있습니다. 로깅과 모니터링: 객체에 대한 접근을 감시하고 로깅할 수 있어 디버깅과 모니터링이 용이해집니다. 코드 분리: 부가적인 기능을 프록시에 구현함으로써 실제 객체는 자신의 핵심 기능에만 집중할 수 있습니다. 단점 코드의 복잡성이 증가할 수 있습니다. 프록시 객체로 인해 응답 시간이 늘어날 수 있습니다. 주의사항 및 고려사항 인터페이스 설계: 프록시와 실제 객체는 동일한 인터페이스를 구현해야 합니다. 이를 통해 클라이언트는 프록시와 실제 객체를 구분할 필요가 없습니다. 적절한 프록시 유형 선택: 사용 사례에 맞는 프록시 유형을 선택해야 합니다. 예를 들어, 보안이 중요하다면 보호 프록시를, 성능이 중요하다면 캐싱 프록시를 사용할 수 있습니다. 리소스 관리: 특히 캐싱 프록시를 사용할 때는 메모리 사용량을 고려해야 합니다. 캐시 크기를 제한하거나 오래된 항목을 제거하는 정책을 구현할 필요가 있을 수 있습니다. 스레드 안전성: 여러 스레드가 동시에 프록시에 접근할 수 있는 경우, 적절한 동기화 메커니즘을 구현해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from abc import ABC, abstractmethod from time import sleep # 추상 인터페이스 class YoutubeVideo(ABC): @abstractmethod def play(self) -> None: pass # 실제 비디오 객체 (무거운 리소스) class RealYoutubeVideo(YoutubeVideo): def __init__(self, video_id: str): self.video_id = video_id # 실제 초기화 과정을 시뮬레이션 self._load_video_from_server() def _load_video_from_server(self) -> None: print(f"Loading video {self.video_id} from YouTube servers…") sleep(2) # 네트워크 지연 시뮬레이션 print("Video loaded successfully") def play(self) -> None: print(f"Playing video {self.video_id}") # 프록시 객체 class YoutubeVideoProxy(YoutubeVideo): def __init__(self, video_id: str): self.video_id = video_id self._real_video = None self._access_count = 0 self._cache = {} def play(self) -> None: # 접근 로깅 self._access_count += 1 print(f"Access count for video {self.video_id}: {self._access_count}") # 지연 초기화 if self._real_video is None: print("Loading video on first access…") self._real_video = RealYoutubeVideo(self.video_id) # 실제 객체의 메서드 호출 self._real_video.play() def get_video_info(self) -> dict: # 캐싱 예시 if 'info' not in self._cache: print("Fetching video info from server…") sleep(1) # 네트워크 요청 시뮬레이션 self._cache['info'] = { 'title': f'Video {self.video_id}', 'duration': '10:00', 'likes': 1000 } return self._cache['info'] # 클라이언트 코드 def main(): # 프록시를 통한 비디오 접근 video = YoutubeVideoProxy("ABC123") # 비디오 정보 조회 (캐시 사용) print("First info request:") print(video.get_video_info()) print("\nSecond info request (cached):") print(video.get_video_info()) # 비디오 재생 (지연 초기화) print("\nFirst play request:") video.play() print("\nSecond play request:") video.play() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // 인터페이스 역할을 하는 추상 클래스 class YoutubeVideo { play() { throw new Error('play method must be implemented'); } } // 실제 비디오 객체 (무거운 리소스) class RealYoutubeVideo extends YoutubeVideo { constructor(videoId) { super(); this.videoId = videoId; this._loadVideoFromServer(); } _loadVideoFromServer() { console.log(`Loading video ${this.videoId} from YouTube servers…`); // 네트워크 지연 시뮬레이션 const startTime = Date.now(); while (Date.now() - startTime &lt; 2000) {} console.log('Video loaded successfully'); } play() { console.log(`Playing video ${this.videoId}`); } } // 프록시 객체 class YoutubeVideoProxy extends YoutubeVideo { constructor(videoId) { super(); this.videoId = videoId; this._realVideo = null; this._accessCount = 0; this._cache = new Map(); } play() { // 접근 로깅 this._accessCount++; console.log(`Access count for video ${this.videoId}: ${this._accessCount}`); // 지연 초기화 if (!this._realVideo) { console.log('Loading video on first access…'); this._realVideo = new RealYoutubeVideo(this.videoId); } // 실제 객체의 메서드 호출 this._realVideo.play(); } getVideoInfo() { // 캐싱 예시 if (!this._cache.has('info')) { console.log('Fetching video info from server…'); // 네트워크 요청 시뮬레이션 const startTime = Date.now(); while (Date.now() - startTime &lt; 1000) {} this._cache.set('info', { title: `Video ${this.videoId}`, duration: '10:00', likes: 1000 }); } return this._cache.get('info'); } } // 클라이언트 코드 function main() { // 프록시를 통한 비디오 접근 const video = new YoutubeVideoProxy('ABC123'); // 비디오 정보 조회 (캐시 사용) console.log('First info request:'); console.log(video.getVideoInfo()); console.log('\nSecond info request (cached):'); console.log(video.getVideoInfo()); // 비디오 재생 (지연 초기화) console.log('\nFirst play request:'); video.play(); console.log('\nSecond play request:'); video.play(); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;871 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Proxy Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/proxy-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adapter Pattern</h2></header><div class=entry-content><p>Adapter Pattern 호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있도록 하는 구조적 디자인 패턴
한국의 220V 전기 제품을 미국에서 사용하기 위해 변환 어댑터를 사용하듯이, 소프트웨어에서도 호환되지 않는 인터페이스들을 함께 작동하도록 만들어주는 것이 어댑터 패턴의 핵심
특징 기존 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환합니다. 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 협력할 수 있게 합니다. ‘Wrapper’라고도 불립니다. 사용사례 레거시 시스템과 새로운 시스템을 통합할 때 서드파티 라이브러리를 사용할 때 기존 코드의 수정을 최소화하고 싶은 경우 여러 데이터 포맷을 처리해야 하는 경우 외부 API를 내부 시스템에 통합할 때 장점 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있습니다 단일 책임 원칙을 지키면서 코드의 재사용성을 높일 수 있습니다 클래스 간의 결합도를 낮출 수 있습니다 기존 코드와 새로운 코드를 깔끔하게 분리할 수 있습니다 단점 새로운 클래스와 인터페이스가 추가되어 복잡도가 증가할 수 있습니다 때로는 많은 어댑터 클래스를 작성해야 할 수 있습니다 모든 요청이 어댑터를 통과해야 하므로 약간의 오버헤드가 발생할 수 있습니다 주의사항 및 고려사항 어댑터의 책임 범위를 명확히 해야 합니다. 어댑터는 단순히 인터페이스를 변환하는 역할만 해야 하며, 비즈니스 로직을 포함해서는 안 됩니다. 어댑터 패턴을 적용하기 전에 정말로 필요한지 검토해야 합니다. 때로는 기존 코드를 리팩터링하는 것이 더 나은 해결책일 수 있습니다. 어댑터가 처리하는 데이터 변환 과정에서 발생할 수 있는 예외 상황들을 적절히 처리해야 합니다. 양방향 어댑터를 만들 때는 순환 참조가 발생하지 않도록 주의해야 합니다. 성능에 민감한 부분에서는 어댑터로 인한 추가적인 메서드 호출이 성능에 영향을 미칠 수 있음을 고려해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod from typing import Dict # Target Interface class PaymentProcessor(ABC): @abstractmethod def process_payment(self, amount: float) -> bool: pass @abstractmethod def refund_payment(self, amount: float) -> bool: pass # Existing payment system (Adaptee) class StripePaymentSystem: def __init__(self, api_key: str): self.api_key = api_key def create_charge(self, amount: float, currency: str = "USD") -> Dict: # Simulate Stripe API call print(f"Stripe: Charging ${amount} using API key {self.api_key}") return {"success": True, "transaction_id": "str_123", "amount": amount} def create_refund(self, transaction_id: str) -> Dict: # Simulate Stripe API call print(f"Stripe: Refunding transaction {transaction_id}") return {"success": True, "refund_id": "ref_123"} # Another existing payment system (Adaptee) class PayPalAPI: def __init__(self, client_id: str): self.client_id = client_id def submit_payment(self, amount: float) -> Dict: # Simulate PayPal API call print(f"PayPal: Processing payment of ${amount} with client ID {self.client_id}") return {"status": "SUCCESS", "payment_id": "PAY123"} def reverse_payment(self, payment_id: str) -> Dict: # Simulate PayPal API call print(f"PayPal: Reversing payment {payment_id}") return {"status": "SUCCESS"} # Adapter for Stripe class StripeAdapter(PaymentProcessor): def __init__(self, stripe_processor: StripePaymentSystem): self.stripe = stripe_processor self.transaction_records = {} def process_payment(self, amount: float) -> bool: result = self.stripe.create_charge(amount) if result["success"]: self.transaction_records[amount] = result["transaction_id"] return True return False def refund_payment(self, amount: float) -> bool: transaction_id = self.transaction_records.get(amount) if not transaction_id: return False result = self.stripe.create_refund(transaction_id) return result["success"] # Adapter for PayPal class PayPalAdapter(PaymentProcessor): def __init__(self, paypal_processor: PayPalAPI): self.paypal = paypal_processor self.payment_records = {} def process_payment(self, amount: float) -> bool: result = self.paypal.submit_payment(amount) if result["status"] == "SUCCESS": self.payment_records[amount] = result["payment_id"] return True return False def refund_payment(self, amount: float) -> bool: payment_id = self.payment_records.get(amount) if not payment_id: return False result = self.paypal.reverse_payment(payment_id) return result["status"] == "SUCCESS" # Client code def process_order(processor: PaymentProcessor, amount: float): """Process an order using any payment processor""" if processor.process_payment(amount): print(f"Successfully processed payment of ${amount}") return True print(f"Failed to process payment of ${amount}") return False # Usage example if __name__ == "__main__": # Create payment processors stripe_processor = StripePaymentSystem(api_key="sk_test_123") paypal_processor = PayPalAPI(client_id="client_123") # Create adapters stripe_adapter = StripeAdapter(stripe_processor) paypal_adapter = PayPalAdapter(paypal_processor) # Process payments using different processors process_order(stripe_adapter, 100.00) process_order(paypal_adapter, 50.00) # Test refunds stripe_adapter.refund_payment(100.00) paypal_adapter.refund_payment(50.00) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 // Target interface (what the client expects) class DataAnalyzer { analyze(data) { throw new Error('analyze method must be implemented'); } getReport() { throw new Error('getReport method must be implemented'); } } // Existing CSV data processor (Adaptee) class CSVProcessor { constructor() { this.data = null; } loadCSV(csvData) { // Simulate processing CSV data console.log('Processing CSV data…'); this.data = csvData.split('\n').map(row => row.split(',')); return true; } generateStats() { if (!this.data) return null; // Simulate generating statistics return { rowCount: this.data.length, columnCount: this.data[0].length, format: 'CSV' }; } } // Existing JSON data processor (Adaptee) class JSONProcessor { constructor() { this.jsonData = null; } parseJSON(jsonString) { // Simulate parsing JSON data console.log('Parsing JSON data…'); this.jsonData = JSON.parse(jsonString); return { success: true, timestamp: new Date() }; } calculateMetrics() { if (!this.jsonData) return null; // Simulate calculating metrics return { size: JSON.stringify(this.jsonData).length, type: 'JSON', keys: Object.keys(this.jsonData) }; } } // Adapter for CSV Processor class CSVAdapter extends DataAnalyzer { constructor(csvProcessor) { super(); this.processor = csvProcessor; this.analysis = null; } analyze(data) { const success = this.processor.loadCSV(data); if (success) { this.analysis = this.processor.generateStats(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'CSV Analysis', entries: this.analysis.rowCount, fields: this.analysis.columnCount, format: this.analysis.format, timestamp: new Date() }; } } // Adapter for JSON Processor class JSONAdapter extends DataAnalyzer { constructor(jsonProcessor) { super(); this.processor = jsonProcessor; this.analysis = null; } analyze(data) { const result = this.processor.parseJSON(data); if (result.success) { this.analysis = this.processor.calculateMetrics(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'JSON Analysis', dataSize: this.analysis.size, format: this.analysis.type, availableFields: this.analysis.keys, timestamp: new Date() }; } } // Client code class DataAnalysisService { constructor(analyzer) { this.analyzer = analyzer; } processData(data) { if (this.analyzer.analyze(data)) { const report = this.analyzer.getReport(); console.log('Analysis Report:', report); return report; } console.log('Analysis failed'); return null; } } // Usage example const csvData = 'name,age,city\nJohn,New York\nJane,Boston'; const jsonData = JSON.stringify({ users: [ { name: 'John', age: 30, city: 'New York' }, { name: 'Jane', age: 25, city: 'Boston' } ] }); // Create processors and adapters const csvProcessor = new CSVProcessor(); const jsonProcessor = new JSONProcessor(); const csvAdapter = new CSVAdapter(csvProcessor); const jsonAdapter = new JSONAdapter(jsonProcessor); // Analyze both types of data using the same interface const analysisService = new DataAnalysisService(csvAdapter); analysisService.processData(csvData); const jsonAnalysisService = new DataAnalysisService(jsonAdapter); jsonAnalysisService.processData(jsonData); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:13:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1216 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adapter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/adapter-pattern/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>