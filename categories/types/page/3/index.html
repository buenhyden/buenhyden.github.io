<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/types/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/types/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/types/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Types</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Long Polling</h2></header><div class=entry-content><p>Long Polling Long polling은 전통적인 short polling의 한계를 극복하기 위해 발전된 웹 통신 기법으로, 실시간에 가까운 데이터 전송을 가능하게 한다. 이 기술은 특히 웹소켓(WebSocket)이 등장하기 전에 실시간 웹 애플리케이션 구현에 널리 사용되었다.
Long polling은 WebSockets의 대중화 이전에 실시간 웹 애플리케이션의 핵심 기술이었으며, 오늘날에도 특정 상황에서 유용한 접근 방식이다. 특히 WebSockets 지원이 제한된 환경이나, 단순한 실시간 요구사항을 가진 애플리케이션에서 여전히 가치 있는 솔루션이다.
최신 웹 애플리케이션에서는 WebSockets가 선호되는 경향이 있지만, Long polling은 폴백(fallback) 메커니즘으로 구현되어 WebSockets를 지원하지 않는 환경에서도 실시간에 가까운 경험을 제공할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:44:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Long Polling" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-patterns-and-integration/communication-patterns/hybrid-communication/webhooks-vs-polling/polling/types/long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Octree</h2></header><div class=entry-content><p>Octree Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.
각 노드는 공간의 한 영역을 나타내며, 필요에 따라 더 작은 영역으로 세분화된다.
![Octree](Octree2.png “https://ko.wikipedia.org/wiki/%ED%8C%94%EC%A7%84%ED%8A%B8%EB%A6%AC#/media/%ED%8C%8C%EC%9D%BC:Octree2.png)
특징 계층적 구조: 공간을 재귀적으로 분할하여 계층적으로 표현한다. 적응적 해상도: 필요한 영역만 세밀하게 분할하여 효율적인 공간 표현이 가능하다. 8분할: 각 노드는 최대 8개의 자식 노드를 가질 수 있다. 장점 효율적인 공간 표현: 복잡한 3차원 구조를 효율적으로 표현할 수 있다. 빠른 검색: 계층 구조를 활용하여 특정 영역의 빠른 검색이 가능하다. 메모리 효율성: 균일하지 않은 데이터 분포에 대해 메모리를 효율적으로 사용한다. 단점 구현 복잡성: 구현과 관리가 상대적으로 복잡할 수 있다. 메모리 오버헤드: 트리 구조로 인한 추가적인 메모리 사용이 발생할 수 있다. 불균형 가능성: 데이터 분포에 따라 트리가 불균형해질 수 있다. 응용 3D 컴퓨터 그래픽스: 3D 모델링, 렌더링, 충돌 감지 등에 사용된다. 로보틱스: 3D 환경 매핑 및 경로 계획에 활용된다. 게임 개발: 3D 게임 월드의 효율적인 표현과 관리에 사용된다. 과학 시뮬레이션: 대규모 3D 시뮬레이션에서 공간 데이터 관리에 활용된다. 동작 원리 초기화: 전체 3D 공간을 포함하는 루트 노드로 시작한다. 분할: 필요에 따라 각 노드를 8개의 자식 노드로 분할한다. 데이터 할당: 각 노드에 해당 영역의 데이터를 할당한다. 재귀적 분할: 특정 조건(예: 데이터 밀도, 깊이 제한)을 만족할 때까지 2-3 과정을 반복한다. 구성 요소 노드: 3D 공간의 한 영역을 나타내며, 데이터와 자식 노드에 대한 참조를 포함한다. 루트 노드: 전체 3D 공간을 나타내는 최상위 노드이다. 내부 노드: 8개의 자식 노드를 가질 수 있는 중간 노드이다. 리프 노드: 더 이상 분할되지 않는 최하위 노드로, 실제 데이터를 저장한다. 구현 방식 Octree의 기본적인 구현은 재귀적인 트리 구조를 사용한다.
다음은 Python을 사용한 간단한 Octree 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:57:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Octree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/spatial-trees/quad-octrees/octree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BK-tree</h2></header><div class=entry-content><p>BK-tree BK-Tree(Burkhard-Keller Tree)는 메트릭 공간(metric space)에서 효율적인 근사 검색을 위해 설계된 트리 기반 데이터 구조이다.
주로 레벤슈타인 거리(Levenshtein Distance)를 활용한 문자열 유사성 검색, 맞춤법 검사, DNA 시퀀스 분석에 활용된다.
BK-Tree는 유사성 검색이 필요한 분야에서 여전히 유효하나, 최근에는 SymSpell 등 더 빠른 알고리즘도 등장했다.
그러나 이론적 우아함과 구현 용이성으로 교육 및 소규모 시스템에서 널리 사용된다.
BK-트리의 주요 특징 메트릭 공간에서의 효율적인 검색: BK-트리는 요소 간의 거리를 기반으로 데이터를 구성하여, 특정 요소와 유사한 요소를 빠르게 찾을 수 있다. 이산 메트릭 사용: 주로 레벤슈타인 거리(편집 거리)와 같은 이산 메트릭을 사용하여 문자열 간의 유사성을 측정한다. BK-트리의 구조 및 동작 원리 노드 구성: 각 노드는 하나의 요소를 저장하며, 자식 노드는 부모 노드와의 거리(d)를 기준으로 분류된다. 삽입: 새로운 요소를 삽입할 때, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 계산된 거리에 해당하는 자식 노드가 없으면 해당 위치에 새로운 노드를 추가하고, 있으면 해당 자식 노드로 이동하여 동일한 과정을 반복한다. 검색: 특정 요소와 유사한 요소를 찾기 위해, 루트 노드부터 시작하여 현재 노드와의 거리를 계산한다. 이 거리가 설정한 임계값 이하인 경우 해당 노드를 결과에 추가하고, 자식 노드들 중 현재 거리와 임계값의 차이 범위 내에 있는 노드들만 재귀적으로 탐색한다. BK-트리의 예시 단어 집합 {“book”, “books”, “cake”, “boo”, “boon”, “cook”, “cape”, “cart”}가 있을 때, 레벤슈타인 거리를 사용하여 BK-트리를 구성하면 다음과 같은 구조가 될 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BK-tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/spatial-trees/bk-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>BSP Tree</h2></header><div class=entry-content><p>BSP Tree (Binary Space Partitioning Tree) BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것이다. 이 과정에서 생성되는 트리를 BSP 트리라고 한다.
https://www.researchgate.net/figure/Constructing-a-bsp-tree_fig1_238973971
특징 이진 트리 구조: 각 노드는 최대 두 개의 자식 노드를 가진다. 재귀적 분할: 공간을 계속해서 두 부분으로 나누어 표현한다. 볼록 집합: 분할된 각 공간은 볼록 집합(convex set)의 형태를 가진다. 계층적 구조: 공간을 계층적으로 표현할 수 있다. 장점 효율적인 렌더링: 3D 그래픽에서 렌더링 속도를 향상시킬 수 있다. 공간 분할: 복잡한 3D 공간을 효과적으로 표현할 수 있다. 충돌 감지: 게임이나 시뮬레이션에서 충돌 감지에 유용하다. 가시성 결정: 어떤 객체가 보이는지 빠르게 결정할 수 있다. 단점 전처리 시간: 초기 트리 구성에 많은 시간이 소요될 수 있다. 메모리 사용: 복잡한 공간의 경우 많은 메모리를 사용할 수 있다. 동적 환경에서의 한계: 자주 변하는 환경에서는 효율성이 떨어질 수 있다. 응용 3D 컴퓨터 그래픽스: 렌더링 최적화에 사용된다. 컴퓨터 게임: 특히 1인칭 슈팅 게임에서 널리 사용된다. CAD 시스템: 조립식 입체 기하학(CSG)에 활용된다. 로봇 공학: 충돌 감지 등에 사용된다. 동작 원리 분할 평면 선택: 공간을 분할할 평면을 선택한다. 공간 분할: 선택된 평면을 기준으로 공간을 두 부분으로 나눈다. 재귀적 분할: 각 부분에 대해 1, 2 과정을 반복한다. 종료 조건: 정해진 깊이에 도달하거나 더 이상 분할이 필요 없을 때 종료한다. 구성 요소 노드: 공간을 표현하는 기본 단위. 분할 평면: 각 노드에서 공간을 나누는 기준이 되는 평면. 왼쪽/오른쪽 자식 노드: 분할된 공간을 표현하는 하위 노드. 리프 노드: 더 이상 분할되지 않는 최종 공간을 나타내는 노드. 구현 방식 다음은 Python을 사용한 간단한 BSP Tree 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BSP Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/spatial-trees/bsp-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Merkle Tree</h2></header><div class=entry-content><p>Merkle Tree 머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.
블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.
머클 트리는 분산 환경의 신뢰 문제를 해결하는 핵심 도구로, 블록체인의 성공을 가능케 한 기술이다.
데이터의 안전한 공유와 검증이 필요한 모든 시스템에서 그 가치를 발휘한다.
계층적 해시 구조 Leaf Node: 원본 데이터(트랜잭션, 파일 청크 등)의 해시 값으로 구성 (예: SHA-256). Non-Leaf Node: 자식 노드 두 개의 해시 값을 결합한 후 다시 해시화. Merkle Root: 최상위 노드의 해시 값으로 전체 데이터 집합을 대표. 예시: 4개 트랜잭션(A, B, C, D)의 머클 트리 구성
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Merkle Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/special-purpose/merkle-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Quad Tree</h2></header><div class=entry-content><p>Quad Tree Quad Tree는 2차원 공간을 재귀적으로 4개의 영역으로 분할하여 표현하는 트리 기반의 데이터 구조로, 각 노드가 정확히 4개의 자식 노드를 갖는 트리 구조이다.
2차원 공간을 표현하고 관리하는 데 효율적이며, 특히 공간 데이터를 계층적으로 구성하는 데 사용된다.
https://www.researchgate.net/figure/An-Illustration-of-quad-tree-data-structure_fig1_280621405
특징 계층적 구조: 공간을 재귀적으로 4등분하여 표현한다. 적응적 분할: 필요에 따라 특정 영역을 더 세밀하게 분할할 수 있다. 공간 효율성: 데이터 분포에 따라 효율적으로 공간을 분할한다. 장점 효율적인 공간 검색: 특정 영역의 데이터를 빠르게 검색할 수 있다. 메모리 효율성: 데이터 밀도에 따라 적응적으로 메모리를 사용한다. 동적 갱신: 데이터의 삽입과 삭제가 비교적 용이하다. 단점 불균형 가능성: 데이터 분포에 따라 트리가 불균형해질 수 있다. 구현 복잡성: 기본적인 트리 구조보다 구현이 복잡할 수 있다. 메모리 오버헤드: 데이터가 적을 때는 오히려 메모리 사용이 비효율적일 수 있다. 응용 컴퓨터 그래픽스: 충돌 감지, 가시성 결정 등에 사용된다. 이미지 처리: 이미지 압축, 영역 분할 등에 활용된다. 지리 정보 시스템(GIS): 공간 데이터 인덱싱에 사용된다. 게임 개발: 게임 월드의 효율적인 관리와 렌더링에 활용된다. 동작 원리 초기화: 전체 2D 공간을 포함하는 루트 노드로 시작한다. 분할: 특정 조건(예: 데이터 수, 깊이 제한)에 따라 노드를 4개의 자식 노드로 분할한다. 데이터 할당: 각 데이터를 해당하는 영역의 노드에 할당한다. 검색: 트리를 순회하며 원하는 영역 또는 조건에 맞는 데이터를 검색한다. 구성 요소 노드: 공간의 한 영역을 나타내며, 데이터와 자식 노드에 대한 참조를 포함한다. 경계: 각 노드가 나타내는 2D 공간의 경계를 정의한다. 데이터: 각 노드에 저장되는 실제 데이터 또는 데이터에 대한 참조이다. 구현 방식 다음은 Python을 사용한 간단한 Quad Tree 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Quad Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/spatial-trees/quad-octrees/quad-tree/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rope</h2></header><div class=entry-content><p>Rope Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조로, 각 리프 노드(끝 노드)는 문자열과 길이(“weight"라고도 함)를 저장하고, 트리의 상위 노드들은 왼쪽 서브트리의 모든 리프 노드 길이의 합을 저장한다.
https://www.geeksforgeeks.org/ropes-data-structure-fast-string-concatenation/
특징 트리 구조: Rope는 이진 트리 형태를 가진다. 분할 저장: 큰 문자열을 작은 조각으로 나누어 저장한다. 가중치: 각 노드는 왼쪽 서브트리의 문자열 길이를 저장한다. 불변성: 일반적으로 Rope의 노드들은 불변(immutable) 객체로 취급된다. 장점 효율적인 연산: 문자열 연결, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있다. 메모리 효율성: 대규모 문자열 조작 시 추가 메모리 사용이 적다. 지속성: 비파괴적 연산을 사용하면 여러 단계의 실행 취소를 쉽게 지원할 수 있다. 단점 복잡성: 구조가 복잡하여 구현과 관리가 어려울 수 있다. 오버헤드: 작은 문자열에 대해서는 일반 문자열보다 성능이 떨어질 수 있다. 메모리 사용: 부모 노드 저장을 위해 추가 메모리가 필요하다. 응용 텍스트 에디터: Sublime Text 등의 텍스트 에디터에서 대용량 텍스트 처리에 사용된다. 이메일 시스템: Gmail과 같은 이메일 시스템에서 메시지 처리에 활용된다. 프로그래밍 환경: Cedar 프로그래밍 환경에서 사용된다. 동작 원리 문자열 분할: 큰 문자열을 작은 조각으로 나누어 트리의 리프 노드에 저장한다. 트리 구성: 리프 노드들을 이진 트리 형태로 구성한다. 가중치 계산: 각 내부 노드는 왼쪽 서브트리의 문자열 길이 합을 저장한다. 연산 수행: 트리 구조를 활용하여 효율적인 문자열 연산을 수행한다. 구성 요소 리프 노드: 실제 문자열 조각과 그 길이를 저장한다. 내부 노드: 왼쪽 서브트리의 길이(가중치)를 저장한다. 루트 노드: 전체 Rope의 시작점이다. 링크: 노드 간의 연결을 나타낸다. 구현 방식 Rope의 기본적인 구현은 이진 트리를 기반으로 한다.
다음은 Python을 사용한 간단한 Rope 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-11 08:04:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rope" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/special-purpose/rope/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>디스조인트 셋 (Disjoint-Set)</h2></header><div class=entry-content><p>디스조인트 셋 (Disjoint-Set) 디스조인트 셋은 서로 겹치지 않는(disjoint) 부분 집합들로 나누어진 요소들의 집합을 표현하고 조작하는 데이터 구조이다.
각 부분 집합은 대표 요소(representative)를 가지며, 이를 통해 집합을 식별한다.
특징 동적 집합 관리: 요소들을 동적으로 그룹화하고 관리할 수 있다. 빠른 연산: Union과 Find 연산을 매우 효율적으로 수행한다. 경로 압축과 랭크 최적화: 트리 구조를 최적화하여 성능을 향상시킨다. 장점 효율성: 거의 상수 시간에 가까운 연산 복잡도를 제공한다. 간단한 구현: 기본 개념이 직관적이고 구현이 비교적 간단하다. 메모리 효율성: 추가적인 데이터 구조 없이 요소들의 관계를 표현한다. 단점 제한된 기능: 주로 Union과 Find 연산에 특화되어 있어 다른 복잡한 연산은 지원하지 않는다. 초기 설정 비용: 모든 요소에 대해 초기 집합을 생성해야 한다. 응용 Kruskal의 최소 신장 트리 알고리즘 사이클 검출 알고리즘 네트워크의 연결성 확인 이미지 세그멘테이션 동작 원리 디스조인트 셋은 트리 구조를 사용하여 집합을 표현한다.
각 트리의 루트 노드가 해당 집합의 대표 요소가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-11 07:07:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 디스조인트 셋 (Disjoint-Set)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/union-find/disjoint-set/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/architecture-types/von-neumann-vs-harvard/harvard-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Von Neumann architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.
Source: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/
특징 순차적 실행:
명령어를 메모리에서 한 번에 하나씩 순차적으로 가져와 실행 레지스터:
프로그램 카운터 (PC): 다음 실행할 명령어의 주소 저장 명령어 레지스터 (CIR): 현재 실행 중인 명령어 저장 메모리 주소 레지스터 (MAR): 접근할 메모리 주소 저장 메모리 데이터 레지스터 (MDR): 메모리와 주고받는 데이터 저장 누산기 (Accumulator): 연산 결과 임시 저장 버스 시스템:
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/architecture-types/von-neumann-vs-harvard/von-neumann-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/types/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>