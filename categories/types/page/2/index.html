<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/types/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/types/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/types/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Types</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/backend-development/databases/nosql/key-value/redis%EC%99%80-valkey/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adaptive Polling</h2></header><div class=entry-content><p>Adaptive Polling 어댑티브 폴링은 데이터 수집이나 시스템 모니터링 과정에서 폴링(polling) 주기를 상황과 필요에 따라 동적으로 조절하는 기술이다. 전통적인 고정 주기 폴링과 달리, 시스템의 상태와 환경 변화에 따라 폴링 빈도를 지능적으로 조절함으로써 리소스 사용 효율성을 극대화한다.
작동 원리 어댑티브 폴링은 다음과 같은 핵심 메커니즘을 기반으로 작동한다:
상태 감지(State Detection): 시스템은 현재 상태, 데이터 변화율, 이벤트 발생 빈도 등을 지속적으로 모니터링한다. 알고리즘 기반 의사결정(Algorithm-based Decision Making): 수집된 정보를 바탕으로 최적의 폴링 주기를 결정하는 알고리즘을 실행한다. 동적 조정(Dynamic Adjustment): 폴링 주기는 실시간으로 조정되며, 시스템 활동이 활발할 때는 주기가 짧아지고 비활성 상태에서는 주기가 길어진다. 예를 들어, 네트워크 트래픽이 갑자기 증가하면 시스템은 폴링 빈도를 높여 상황을 더 세밀하게 모니터링하고, 트래픽이 안정되면 폴링 빈도를 낮추어 리소스를 절약한다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adaptive Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-integration-patterns/webhooks-vs-polling/polling/types/adaptive-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Smart Polling</h2></header><div class=entry-content><p>Smart Polling 스마트 폴링은 시스템이 데이터를 효율적으로 수집하고 모니터링하는 첨단 기술로, 전통적인 폴링 방식의 한계를 극복하기 위해 발전되었다. 이 기술은 폴링 과정에 지능적 의사결정 요소를 통합하여 리소스 사용 최적화와 시스템 성능 향상을 동시에 추구한다.
스마트 폴링의 기본 개념 스마트 폴링은 단순히 일정 주기로 데이터를 확인하는 전통적인 폴링과 달리, 다양한 컨텍스트 정보와 알고리즘을 활용하여 ‘언제’, ‘무엇을’, ‘어떻게’ 폴링할지 지능적으로 결정한다.
이는 다음과 같은 핵심 원칙에 기반한다:
컨텍스트 인식(Context Awareness): 시스템 상태, 네트워크 조건, 사용자 행동 패턴 등의 컨텍스트 정보를 고려한다. 적응형 의사결정(Adaptive Decision Making): 수집된 데이터와 상황에 따라 폴링 전략을 실시간으로 조정한다. 우선순위 기반 처리(Priority-based Processing): 중요도에 따라 데이터 수집 우선순위를 설정한다. 리소스 최적화(Resource Optimization): 필요한 정보만 필요한 시점에 수집하여 시스템 리소스를 효율적으로 사용한다. 스마트 폴링의 주요 기술 요소 이벤트 기반 폴링(Event-driven Polling) 특정 조건이나 트리거가 발생할 때만 폴링을 수행하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Smart Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-integration-patterns/webhooks-vs-polling/polling/types/smart-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>UTF-8</h2></header><div class=entry-content><p>UTF-8 UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.
역사적 배경과 개발 동기 문자 인코딩의 역사적 진화 컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.
...</p></div><footer class=entry-footer><span title='2025-03-12 13:16:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UTF-8" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Web Socket vs. Long Polling</h2></header><div class=entry-content><p>Web Socket vs. Long Polling 실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.
기본 개념 WebSocket WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-03-09 02:31:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Socket vs. Long Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/websocket/web-socket-vs-long-polling/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Server-sent Events vs. Websocket</h2></header><div class=entry-content><p>Server-sent Events vs. Websocket 웹 애플리케이션이 점점 더 실시간적이고 동적으로 발전함에 따라, 서버와 클라이언트 간의 효율적인 통신 방식이 중요해졌다. 전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다. 두 기술 모두 실시간 통신을 가능하게 하지만, 그 작동 원리와 적합한 사용 사례에는 중요한 차이가 있다.
서버 전송 이벤트(SSE) 개념과 작동 원리 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트 브라우저로 데이터를 단방향으로 스트리밍하는 웹 기술이다. HTML5 표준의 일부로, EventSource API를 통해 구현된다. SSE는 기존 HTTP 프로토콜을 활용하며, 특별한 프로토콜 전환 없이 서버에서 클라이언트로의 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-03 05:41:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-sent Events vs. Websocket" href=https://buenhyden.github.io/posts/backend-development/api-design-and-development/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Streaming APIs</h2></header><div class=entry-content><p>Streaming APIs 스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다. 전통적인 RESTful API가 요청-응답 패턴을 기반으로 하는 반면, 스트리밍 API는 지속적인 연결을 통해 실시간 데이터를 제공한다. 이러한 접근 방식은 데이터가 생성되는 즉시 클라이언트에게 전달할 수 있어 실시간성이 중요한 애플리케이션에 적합하다.
스트리밍 API의 기본 원리는 클라이언트와 서버 간에 한 번 연결을 수립한 후, 서버가 필요에 따라 데이터를 푸시하는 방식으로 동작하다. 이는 폴링(polling) 방식의 단점인 불필요한 요청과 네트워크 오버헤드를 극복할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:41:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming APIs" href=https://buenhyden.github.io/posts/backend-development/backend-fundamentals/backend-basics/request-response-cycle/streaming/streaming-apis/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/types/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/types/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>