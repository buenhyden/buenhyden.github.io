<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Data Structure</title><link>https://buenhyden.github.io/categories/data-structure/</link><description>Recent content in Data Structure on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 08 Jan 2025 15:40:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/categories/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structure</title><link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</link><pubDate>Sun, 27 Oct 2024 06:25:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/</guid><description>
&lt;h2>Data Structure&lt;/h2>&lt;p>데이터를 체계적으로 구성하고 저장하며, 효율적으로 처리하기 위한 방법을 제공한다.&lt;br>
 프로그래밍에서 데이터를 다루는 기본적인 도구로, 효율적인 알고리즘 설계와 문제 해결의 핵심 요소이다.&lt;/p>
&lt;h3>주요 특징&lt;/h3>&lt;ol>
&lt;li>&lt;strong>효율성&lt;/strong>: 데이터를 효율적으로 저장하고 검색하여 프로그램의 성능을 향상시킨다.&lt;/li>
&lt;li>&lt;strong>확장성&lt;/strong>: 데이터 양이 증가해도 적절히 설계된 데이터 구조는 확장성을 제공한다.&lt;/li>
&lt;li>&lt;strong>유지보수성&lt;/strong>: 체계적인 데이터 구조는 코드 유지보수와 이해를 용이하게 만든다.&lt;/li>
&lt;li>&lt;strong>추상화&lt;/strong>: 데이터 구조는 추상 데이터 타입(ADT)을 구현하여 내부 동작을 숨기고, 사용자는 인터페이스만 활용한다.&lt;/li>
&lt;/ol>
&lt;h3>데이터 구조&lt;/h3>&lt;p>
&lt;figure class="image-figure">
&lt;img src="https://buenhyden.github.io/posts/Data%20Structure%20and%20Algorithm/Data%20Structure/e1aca977880d4dce83f295c00.svg"
alt="Types of Data Structure"
loading="lazy" />
&lt;/figure>&lt;br>
_Source: &lt;a href="https://www.designgurus.io/course-play/grokking-data-structures-for-coding-interviews/doc/types-of-data-structures" target="_blank" rel="noopener">https://www.designgurus.io/course-play/grokking-data-structures-for-coding-interviews/doc/types-of-data-structures&lt;/a> _&lt;/p>
&lt;h4>기본 데이터 구조&lt;/h4>&lt;h5>선형 데이터 구조&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>배열 (Array)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 연속된 메모리 공간&lt;br>• 인덱스로 직접 접근&lt;br>• 고정된 크기&lt;br>• 캐시 지역성 우수&lt;/td>
&lt;td>• 순차적 데이터 저장&lt;br>• 빈번한 읽기 작업&lt;br>• 크기가 고정된 데이터&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동적 배열 (Dynamic Array)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 크기 자동 조정&lt;br>• 여유 공간 유지&lt;br>• 재할당 비용 발생&lt;br>• 배열의 장점 유지&lt;/td>
&lt;td>• 가변 크기 데이터&lt;br>• 스택 구현&lt;br>• 버퍼 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>연결 리스트 (Linked List)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 동적 메모리 할당&lt;br>• 불연속 메모리&lt;br>• 포인터로 연결&lt;br>• 유연한 크기 조정&lt;/td>
&lt;td>• 빈번한 삽입/삭제&lt;br>• 메모리 효율성 중요&lt;br>• 스택/큐 구현&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>스택 (Stack)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• LIFO 구조&lt;br>• 제한된 접근&lt;br>• 간단한 구현&lt;br>• 함수 호출 관리&lt;/td>
&lt;td>• 함수 호출 스택&lt;br>• 실행 취소&lt;br>• 괄호 검사&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>큐 (Queue)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• FIFO 구조&lt;br>• 순차적 처리&lt;br>• 대기열 관리&lt;br>• 버퍼링 지원&lt;/td>
&lt;td>• 작업 스케줄링&lt;br>• 버퍼 관리&lt;br>• BFS 구현&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>비선형 데이터 구조&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>이진 트리 (Binary Tree)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 계층적 구조&lt;br>• 최대 2개 자식&lt;br>• 재귀적 속성&lt;br>• 트리 순회 용이&lt;/td>
&lt;td>• 계층 데이터&lt;br>• 수식 표현&lt;br>• 결정 트리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이진 검색 트리 (BST)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 정렬된 트리&lt;br>• 중위 순회로 정렬&lt;br>• 불균형 가능&lt;br>• 검색 최적화&lt;/td>
&lt;td>• 정렬된 데이터&lt;br>• 범위 검색&lt;br>• 데이터베이스 인덱스&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>힙 (Heap)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>• 완전 이진 트리&lt;br>• 우선순위 관리&lt;br>• 부모-자식 관계&lt;br>• 효율적인 최댓값/최솟값&lt;/td>
&lt;td>• 우선순위 큐&lt;br>• 힙 정렬&lt;br>• 작업 스케줄링&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4>고급 데이터 구조&lt;/h4>&lt;h5>해시 기반 구조&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>해시 테이블&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>O(1) 평균&lt;/td>
&lt;td>• 키-값 쌍&lt;br>• 해시 함수 사용&lt;br>• 충돌 해결 필요&lt;br>• 동적 크기 조정&lt;/td>
&lt;td>• 캐싱&lt;br>• 데이터베이스 인덱싱&lt;br>• 심볼 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>블룸 필터&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(k)&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(k)&lt;/td>
&lt;td>• 확률적 자료구조&lt;br>• 공간 효율적&lt;br>• 거짓 양성 가능&lt;br>• 삭제 불가&lt;/td>
&lt;td>• 중복 검사&lt;br>• 캐시 필터링&lt;br>• 스펠링 체크&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>균형 트리&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>AVL 트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 엄격한 균형&lt;br>• 자동 재조정&lt;br>• 높이 차이 ≤1&lt;br>• 빈번한 회전&lt;/td>
&lt;td>• 안정적 성능 필요&lt;br>• 데이터베이스&lt;br>• 메모리 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>레드-블랙 트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 느슨한 균형&lt;br>• 컬러 속성&lt;br>• 적은 회전&lt;br>• 실용적 성능&lt;/td>
&lt;td>• 파일 시스템&lt;br>• 프로세스 스케줄링&lt;br>• STL 구현&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B-트리&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>O(log n)&lt;/td>
&lt;td>• 다중 경로&lt;br>• 디스크 최적화&lt;br>• 노드당 많은 키&lt;br>• 높이 균형&lt;/td>
&lt;td>• 데이터베이스&lt;br>• 파일 시스템&lt;br>• 외부 메모리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>특수 목적 구조&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>접근&lt;/th>
&lt;th>삽입&lt;/th>
&lt;th>삭제&lt;/th>
&lt;th>검색&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>주요 사용 사례&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>트라이 (Trie)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>O(m)&lt;/td>
&lt;td>• 문자열 특화&lt;br>• 접두사 검색&lt;br>• 공간 집약적&lt;br>• 효율적 검색&lt;/td>
&lt;td>• 자동 완성&lt;br>• 사전&lt;br>• 라우팅 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>그래프&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;td>O(V+E)&lt;/td>
&lt;td>• 노드와 엣지&lt;br>• 다양한 표현&lt;br>• 복잡한 관계&lt;br>• 순환 가능&lt;/td>
&lt;td>• 소셜 네트워크&lt;br>• 네비게이션&lt;br>• 네트워크 토폴로지&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>디스조인트 셋&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>-&lt;/td>
&lt;td>O(α(n))&lt;/td>
&lt;td>• 집합 관리&lt;br>• 경로 압축&lt;br>• 유니온-파인드&lt;br>• 거의 상수 시간&lt;/td>
&lt;td>• 크루스칼 알고리즘&lt;br>• 연결성 확인&lt;br>• 클러스터링&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>[m: 문자열 길이, V: 정점 수, E: 간선 수, α(n): 애커만 함수의 역함수]&lt;/p>
&lt;h3>데이터 구조의 선택 기준&lt;/h3>&lt;p>다음과 같은 요소들을 고려하여 결정된다.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>데이터 접근 패턴&lt;/p>
&lt;ul>
&lt;li>배열은 인덱스를 통한 빠른 접근이 가능하지만 삽입과 삭제가 어렵다.&lt;/li>
&lt;li>링크드 리스트는 삽입과 삭제가 용이하지만 데이터 접근 속도가 느릴 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>시간 복잡도와 공간 복잡도&lt;/p>
&lt;ul>
&lt;li>해시 테이블은 평균적으로 O(1)의 시간 복잡도를 가지지만, 최악의 경우 O(n)이 될 수 있다.&lt;/li>
&lt;li>이진 검색 트리는 평균적으로 O(log n)의 검색, 삽입, 삭제 시간이 소요된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터의 크기와 형태&lt;/p>
&lt;ul>
&lt;li>대용량 데이터를 처리해야 하는 경우, 배열과 같은 연속된 메모리 공간을 요구하는 자료 구조는 부적합할 수 있다.&lt;/li>
&lt;li>트리나 그래프는 복잡한 데이터 구조를 나타내는 데 유리하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>특정 연산의 빈도&lt;/p>
&lt;ul>
&lt;li>큐나 스택은 삽입과 삭제가 빈번한 경우에 적합하다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동시성 제어&lt;/p>
&lt;ul>
&lt;li>멀티스레드 환경에서는 스레드 안전성을 제공하는 자료 구조를 선택해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>사용 용이성 및 유지보수&lt;/p>
&lt;ul>
&lt;li>간단한 자료 구조를 선호하는 것이 유지 보수 측면에서 유리할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>응용 프로그램의 요구 사항&lt;/p>
&lt;ul>
&lt;li>각 응용 프로그램의 고유한 요구 사항과 제약 조건에 맞는 최적의 자료 구조를 선택해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>자료의 처리 시간과 활용 빈도&lt;/p>
&lt;ul>
&lt;li>자료의 처리 시간, 크기, 활용 빈도, 갱신 정도를 고려해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>알고리즘과의 조화&lt;/p>
&lt;ul>
&lt;li>특정 자료 구조를 사용하는 것이 특정 알고리즘을 구현하기에 적합한 경우가 있으므로, 이 두 가지를 조화롭게 고려해야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이러한 기준들을 종합적으로 고려하여 문제 해결에 가장 적합한 데이터 구조를 선택해야 한다.&lt;br>
효율적인 데이터 구조 선택은 알고리즘의 성능을 최적화하고 전반적인 프로그램의 효율성을 높이는 데 중요한 역할을 한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Concurrent Data Structure</title><link>https://buenhyden.github.io/til/2025/01/concurrent-data-structure/</link><pubDate>Mon, 06 Jan 2025 12:55:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2025/01/concurrent-data-structure/</guid><description>
&lt;h2>Concurrent Data Structure&lt;/h2>&lt;p>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조이다.&lt;br>
전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.&lt;br>
Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계된 데이터 구조입니다.&lt;/p>
&lt;p>Concurrent Data Structure는 일반적으로 다음과 같은 방식으로 구현된다:&lt;/p>
&lt;ul>
&lt;li>세밀한 락(fine-grained locking) 사용&lt;/li>
&lt;li>락 없는(lock-free) 알고리즘&lt;/li>
&lt;li>대기 없는(wait-free) 알고리즘&lt;/li>
&lt;li>지연된 삭제와 메모리 재사용 기법&lt;/li>
&lt;/ul>
&lt;p>이러한 구조는 고성능 멀티스레드 시스템, 데이터베이스, 운영체제, 네트워크 스택 등 다양한 분야에서 활용된다.&lt;/p>
&lt;h3>주요 특징&lt;/h3>&lt;ol>
&lt;li>스레드 안전성: 여러 스레드가 동시에 접근해도 데이터의 일관성을 유지한다.&lt;/li>
&lt;li>높은 동시성: 여러 스레드가 동시에 작업을 수행할 수 있어 성능이 향상된다.&lt;/li>
&lt;li>락 최소화: 전체 구조에 대한 락 대신 세밀한 락이나 락 없는 기법을 사용한다.&lt;/li>
&lt;li>확장성: 스레드 수가 증가해도 성능 저하가 적다.&lt;/li>
&lt;li>원자적 연산: Compare-And-Swap(CAS)과 같은 원자적 연산을 활용한다.&lt;/li>
&lt;/ol>
&lt;h3>Concurrent Data Structure 패턴 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Concurrent HashMap&lt;/th>
&lt;th>Concurrent Skip List&lt;/th>
&lt;th>Lock-free Queue&lt;/th>
&lt;th>Lock-free Stack&lt;/th>
&lt;th>Read-Copy-Update (RCU) List&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>개념&lt;/td>
&lt;td>동시에 여러 스레드가 접근 가능한 해시 기반 맵&lt;/td>
&lt;td>동시성을 지원하는 계층화된 정렬 리스트&lt;/td>
&lt;td>락 없이 동시 접근 가능한 FIFO 큐&lt;/td>
&lt;td>락 없이 동시 접근 가능한 LIFO 스택&lt;/td>
&lt;td>읽기에 최적화된 동시성 리스트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동기화 방식&lt;/td>
&lt;td>세그먼트 락 또는 CAS&lt;/td>
&lt;td>CAS 기반&lt;/td>
&lt;td>CAS 기반&lt;/td>
&lt;td>CAS 기반&lt;/td>
&lt;td>읽기는 락 없음, 쓰기는 RCU 메커니즘&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 용도&lt;/td>
&lt;td>동시성 캐시, 공유 데이터 저장&lt;/td>
&lt;td>정렬된 데이터의 동시 접근&lt;/td>
&lt;td>작업 큐, 버퍼&lt;/td>
&lt;td>후입선출 데이터 관리&lt;/td>
&lt;td>읽기가 빈번한 데이터 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>성능 특성&lt;/td>
&lt;td>읽기/쓰기 균형&lt;/td>
&lt;td>로그 시간 복잡도 연산&lt;/td>
&lt;td>높은 처리량&lt;/td>
&lt;td>빠른 푸시/팝 연산&lt;/td>
&lt;td>매우 빠른 읽기, 느린 쓰기&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>장점&lt;/td>
&lt;td>높은 동시성, 확장성&lt;/td>
&lt;td>효율적인 검색과 삽입&lt;/td>
&lt;td>높은 동시성, 데드락 없음&lt;/td>
&lt;td>단순한 구현, 높은 동시성&lt;/td>
&lt;td>락 없는 읽기, 높은 확장성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>단점&lt;/td>
&lt;td>메모리 사용량 증가&lt;/td>
&lt;td>구현 복잡도 높음&lt;/td>
&lt;td>ABA 문제 가능성&lt;/td>
&lt;td>ABA 문제, 제한된 확장성&lt;/td>
&lt;td>복잡한 메모리 관리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>중간~높음&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>높음 (여러 버전 유지)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 방식&lt;/td>
&lt;td>버킷 배열, 연결 리스트/트리&lt;/td>
&lt;td>계층화된 연결 리스트&lt;/td>
&lt;td>연결 리스트, 원자적 포인터&lt;/td>
&lt;td>연결 리스트, 원자적 포인터&lt;/td>
&lt;td>버전 관리된 연결 리스트&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>특징&lt;/td>
&lt;td>동적 크기 조정&lt;/td>
&lt;td>확률적 밸런싱&lt;/td>
&lt;td>대기 없는 연산&lt;/td>
&lt;td>단순한 구조&lt;/td>
&lt;td>읽기 최적화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡도&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>중간&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>확장성&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;td>좋음&lt;/td>
&lt;td>좋음&lt;/td>
&lt;td>제한적&lt;/td>
&lt;td>매우 좋음 (읽기)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ABA 문제&lt;/td>
&lt;td>해결됨&lt;/td>
&lt;td>해결 필요&lt;/td>
&lt;td>해결 필요&lt;/td>
&lt;td>해결 필요&lt;/td>
&lt;td>해결됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>순서 보장&lt;/td>
&lt;td>보장 안 됨&lt;/td>
&lt;td>정렬 순서 보장&lt;/td>
&lt;td>FIFO 보장&lt;/td>
&lt;td>LIFO 보장&lt;/td>
&lt;td>보장 안 됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 사례&lt;/td>
&lt;td>데이터베이스, 캐시 시스템&lt;/td>
&lt;td>정렬된 데이터 관리&lt;/td>
&lt;td>작업 스케줄링, 이벤트 처리&lt;/td>
&lt;td>메모리 할당자, 스택 추적&lt;/td>
&lt;td>운영체제 커널, 네트워크 스택&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Suffix Array vs Suffix Tree vs Trie</title><link>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie/</link><pubDate>Wed, 08 Jan 2025 15:40:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2025/01/suffix-array-vs-suffix-tree-vs-trie/</guid><description>
&lt;h2>Suffix Array Vs Suffix Tree Vs Trie&lt;/h2>&lt;p>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Suffix Array&lt;/th>
&lt;th>Suffix Tree&lt;/th>
&lt;th>Trie&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>기본 구조&lt;/strong>&lt;/td>
&lt;td>모든 접미사를 정렬하여 저장하는 1차원 배열&lt;/td>
&lt;td>모든 접미사를 트리 형태로 저장하는 압축된 트리 구조&lt;/td>
&lt;td>문자열을 문자 단위로 저장하는 트리 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>메모리 효율성&lt;/strong>&lt;/td>
&lt;td>O(n), 매우 효율적&lt;/td>
&lt;td>O(n), 하지만 실제로는 4n 정도로 큼&lt;/td>
&lt;td>O(ALPHABET_SIZE &lt;em>key_length&lt;/em> n), 매우 큼&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>구축 시간&lt;/strong>&lt;/td>
&lt;td>O(n log n)&lt;/td>
&lt;td>O(n) (Ukkonen&amp;rsquo;s Algorithm 사용 시)&lt;/td>
&lt;td>O(n * key_length)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>검색 시간&lt;/strong>&lt;/td>
&lt;td>O(m log n + occ), m은 패턴 길이&lt;/td>
&lt;td>O(m + occ), m은 패턴 길이&lt;/td>
&lt;td>O(m), m은 검색할 문자열 길이&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>구현 난이도&lt;/strong>&lt;/td>
&lt;td>비교적 간단&lt;/td>
&lt;td>매우 복잡&lt;/td>
&lt;td>비교적 간단&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>LCP 계산&lt;/strong>&lt;/td>
&lt;td>추가 배열 필요&lt;/td>
&lt;td>트리 구조에서 직접 계산 가능&lt;/td>
&lt;td>해당 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>패턴 매칭&lt;/strong>&lt;/td>
&lt;td>이진 검색 이용&lt;/td>
&lt;td>트리 순회로 직접 검색&lt;/td>
&lt;td>트리 순회로 직접 검색&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>공간 지역성&lt;/strong>&lt;/td>
&lt;td>매우 좋음 (연속된 메모리)&lt;/td>
&lt;td>보통 (포인터로 인한 흩어짐)&lt;/td>
&lt;td>나쁨 (노드가 메모리에 흩어짐)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>주요 응용&lt;/strong>&lt;/td>
&lt;td>텍스트 검색, DNA 분석&lt;/td>
&lt;td>문자열 처리, 바이오인포매틱스&lt;/td>
&lt;td>사전 구현, 자동 완성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>동적 업데이트&lt;/strong>&lt;/td>
&lt;td>어려움&lt;/td>
&lt;td>가능하나 복잡&lt;/td>
&lt;td>쉬움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>접두사 검색&lt;/strong>&lt;/td>
&lt;td>어려움&lt;/td>
&lt;td>가능하나 비효율적&lt;/td>
&lt;td>매우 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>최장 공통 접두사&lt;/strong>&lt;/td>
&lt;td>추가 작업 필요&lt;/td>
&lt;td>직접 계산 가능&lt;/td>
&lt;td>직접 계산 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>최장 공통 부분 문자열&lt;/strong>&lt;/td>
&lt;td>LCP 배열 필요&lt;/td>
&lt;td>직접 계산 가능&lt;/td>
&lt;td>부적합&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>압축 가능성&lt;/strong>&lt;/td>
&lt;td>제한적&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;td>있음 (압축 트라이)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>캐시 성능&lt;/strong>&lt;/td>
&lt;td>매우 좋음&lt;/td>
&lt;td>보통&lt;/td>
&lt;td>나쁨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>실제 사용 사례&lt;/strong>&lt;/td>
&lt;td>대용량 문자열 검색 시스템&lt;/td>
&lt;td>생물정보학, 문자열 처리&lt;/td>
&lt;td>자동 완성, 사전 검색&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>추가적인 중요 고려사항:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>메모리 사용 패턴:&lt;/p>
&lt;ul>
&lt;li>Suffix Array: 연속된 메모리 공간 사용으로 캐시 효율성 높음&lt;/li>
&lt;li>Suffix Tree: 포인터 기반 구조로 메모리 사용이 분산됨&lt;/li>
&lt;li>Trie: 노드별 메모리 할당으로 가장 분산된 사용 패턴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 트레이드오프:&lt;/p>
&lt;ul>
&lt;li>Suffix Array: 공간 효율성 vs 검색 속도&lt;/li>
&lt;li>Suffix Tree: 구현 복잡성 vs 기능성&lt;/li>
&lt;li>Trie: 메모리 사용량 vs 검색 단순성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>적합한 사용 시나리오:&lt;/p>
&lt;ul>
&lt;li>Suffix Array: 메모리 제약이 있는 대규모 문자열 처리&lt;/li>
&lt;li>Suffix Tree: 복잡한 문자열 처리가 필요한 고성능 응용&lt;/li>
&lt;li>Trie: 접두사 기반 검색이 중요한 응용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Linear Data Structure vs Non-Linear Data Structure</title><link>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</link><pubDate>Wed, 06 Nov 2024 11:00:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/linear-data-structure-vs-non-linear-data-structure/</guid><description>
&lt;h2>Linear Data Structure Vs Non-Linear Data Structure&lt;/h2>&lt;p>데이터 구조는 크게 Linear Data Structure와 Non-Linear Data Structure로 나눌 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>측면&lt;/th>
&lt;th>Linear Data Structure&lt;/th>
&lt;th>Non-Linear Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>데이터 요소가 순차적 또는 선형적으로 배열된 구조&lt;/td>
&lt;td>데이터 요소가 순차적이거나 선형적으로 배열되지 않은 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조&lt;/td>
&lt;td>단일 레벨 구조&lt;/td>
&lt;td>다중 레벨 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 관계&lt;/td>
&lt;td>요소 간 1:1 관계&lt;/td>
&lt;td>요소 간 1:N 또는 N:N 관계&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>순회&lt;/td>
&lt;td>단일 실행으로 모든 요소 순회 가능&lt;/td>
&lt;td>단일 실행으로 모든 요소 순회 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현 복잡성&lt;/td>
&lt;td>구현이 상대적으로 간단&lt;/td>
&lt;td>구현이 상대적으로 복잡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 사용&lt;/td>
&lt;td>메모리 사용이 덜 효율적&lt;/td>
&lt;td>메모리 사용이 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>시간 복잡도&lt;/td>
&lt;td>입력 크기에 따라 증가&lt;/td>
&lt;td>특정 작업에서 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>데이터 접근&lt;/td>
&lt;td>순차적 접근&lt;/td>
&lt;td>계층적 또는 네트워크 기반 접근&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>삽입/삭제&lt;/td>
&lt;td>상대적으로 간단&lt;/td>
&lt;td>더 복잡하지만 유연함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>응용 분야&lt;/td>
&lt;td>간단한 데이터 저장 및 처리&lt;/td>
&lt;td>복잡한 관계 표현, AI, 이미지 처리 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예시&lt;/td>
&lt;td>배열, 연결 리스트, 스택, 큐&lt;/td>
&lt;td>트리, 그래프, 해시 테이블, 힙&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>공통점:&lt;/p>
&lt;ol>
&lt;li>둘 다 데이터를 구조화하고 관리하는 방법을 제공한다.&lt;/li>
&lt;li>특정 작업에 대해 효율적인 알고리즘을 지원한다.&lt;/li>
&lt;li>데이터의 삽입, 삭제, 검색 연산을 수행할 수 있다.&lt;/li>
&lt;/ol>
&lt;p>주요 차이점:&lt;/p>
&lt;ol>
&lt;li>데이터 배열 방식 (순차적 vs 계층적/네트워크)&lt;/li>
&lt;li>구현 복잡도 (간단 vs 복잡)&lt;/li>
&lt;li>메모리 효율성 (덜 효율적 vs 더 효율적)&lt;/li>
&lt;li>데이터 관계 표현 (1:1 vs 1:N 또는 N:N)&lt;/li>
&lt;li>응용 분야 (간단한 데이터 처리 vs 복잡한 관계 표현)&lt;/li>
&lt;/ol>
&lt;h3>선형 데이터 구조 (Linear Data Structure) 유형&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구조&lt;/th>
&lt;th>정의&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>주요 연산&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Array&lt;/td>
&lt;td>연속된 메모리 위치에 동일한 유형의 요소를 저장하는 구조&lt;/td>
&lt;td>- 고정 크기&lt;br>- 인덱스로 접근&lt;/td>
&lt;td>- 빠른 접근 시간 O(1)&lt;br>- 메모리 효율적&lt;/td>
&lt;td>- 크기 변경 어려움&lt;br>- 삽입/삭제 비효율적&lt;/td>
&lt;td>접근, 검색, 삽입, 삭제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linked List&lt;/td>
&lt;td>노드가 데이터와 다음 노드 참조를 포함하는 연결 구조&lt;/td>
&lt;td>- 동적 크기&lt;br>- 비연속 메모리&lt;/td>
&lt;td>- 삽입/삭제 효율적&lt;br>- 유연한 크기&lt;/td>
&lt;td>- 임의 접근 어려움&lt;br>- 추가 메모리 필요&lt;/td>
&lt;td>삽입, 삭제, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stack&lt;/td>
&lt;td>LIFO(Last-In-First-Out) 원칙을 따르는 구조&lt;/td>
&lt;td>- 한쪽 끝에서만 연산&lt;br>- 후입선출&lt;/td>
&lt;td>- 간단한 구현&lt;br>- 역추적에 유용&lt;/td>
&lt;td>- 제한된 데이터 접근&lt;/td>
&lt;td>push, pop, peek&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue&lt;/td>
&lt;td>FIFO(First-In-First-Out) 원칙을 따르는 구조&lt;/td>
&lt;td>- 양쪽 끝에서 연산&lt;br>- 선입선출&lt;/td>
&lt;td>- 순서 보존&lt;br>- 버퍼링에 유용&lt;/td>
&lt;td>- 중간 데이터 접근 어려움&lt;/td>
&lt;td>enqueue, dequeue&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deque&lt;/td>
&lt;td>양쪽 끝에서 삽입과 삭제가 가능한 구조&lt;/td>
&lt;td>- 양방향 연산&lt;br>- 스택과 큐 기능 결합&lt;/td>
&lt;td>- 유연한 데이터 처리&lt;br>- 다양한 알고리즘 지원&lt;/td>
&lt;td>- 구현 복잡성&lt;/td>
&lt;td>pushFront, pushBack, popFront, popBack&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3>비선형 데이터 구조 (Non-Linear Data Structure) 유형&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구조&lt;/th>
&lt;th>정의&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>장점&lt;/th>
&lt;th>단점&lt;/th>
&lt;th>주요 연산&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Graph&lt;/td>
&lt;td>노드(정점)와 엣지(간선)로 구성된 비선형 데이터 구조&lt;/td>
&lt;td>- 계층적 또는 네트워크 관계 표현&lt;br>- 방향성 있는/없는 그래프로 구분&lt;/td>
&lt;td>- 복잡한 관계 모델링&lt;br>- 효율적인 경로 탐색&lt;/td>
&lt;td>- 구현 복잡성&lt;br>- 메모리 사용량 큼&lt;/td>
&lt;td>삽입, 삭제, 탐색, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hash-based Structure&lt;/td>
&lt;td>키를 값에 매핑하는 데이터 구조&lt;/td>
&lt;td>- 해시 함수 사용&lt;br>- 충돌 해결 메커니즘 필요&lt;/td>
&lt;td>- 빠른 검색, 삽입, 삭제 (평균 O(1))&lt;br>- 효율적인 데이터 관리&lt;/td>
&lt;td>- 최악의 경우 성능 저하&lt;br>- 순서 정보 손실&lt;/td>
&lt;td>삽입, 검색, 삭제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tree&lt;/td>
&lt;td>계층적 구조를 가진 노드들의 집합&lt;/td>
&lt;td>- 루트 노드와 자식 노드로 구성&lt;br>- 사이클 없음&lt;/td>
&lt;td>- 계층적 데이터 표현&lt;br>- 효율적인 검색&lt;/td>
&lt;td>- 불균형 시 성능 저하&lt;br>- 구현 복잡성&lt;/td>
&lt;td>삽입, 삭제, 검색, 순회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Heap&lt;/td>
&lt;td>완전 이진 트리 기반의 특수한 트리 구조&lt;/td>
&lt;td>- 최대 힙 또는 최소 힙&lt;br>- 부모-자식 간 대소 관계 유지&lt;/td>
&lt;td>- 최대/최소값 빠른 접근&lt;br>- 우선순위 큐 구현에 효과적&lt;/td>
&lt;td>- 임의 노드 접근 어려움&lt;br>- 중간값 찾기 비효율적&lt;/td>
&lt;td>삽입, 삭제, 힙 정렬&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Hash-based data structure가 Non-linear data structure로 분류되는 근거&lt;/p>
&lt;ol>
&lt;li>고유한 접근 방식: Hash-based 구조는 해시 함수를 사용하여 데이터를 저장하고 검색한다. 이는 다른 non-linear 구조와는 다른 독특한 접근 방식이다.&lt;/li>
&lt;li>성능 특성: Hash-based 구조는 평균적으로 O(1)의 시간 복잡도로 삽입, 검색, 삭제 연산을 수행할 수 있어, 다른 non-linear 구조와 구별된다.&lt;/li>
&lt;li>다양한 응용: Hash-based 구조는 associative arrays, 데이터베이스 인덱싱, 캐시, 집합 등 다양한 응용 분야에서 사용된다.&lt;/li>
&lt;li>충돌 해결 메커니즘: Hash-based 구조는 충돌 해결을 위한 고유한 메커니즘(예: separate chaining, linear probing)을 가지고 있어, 다른 non-linear 구조와 구별된다.&lt;/li>
&lt;li>공간-시간 트레이드오프: Hash-based 구조는 메모리 사용과 연산 속도 사이의 특별한 균형을 제공한다.&lt;/li>
&lt;li>확률적 성능: Hash-based 구조의 성능은 해시 함수의 품질과 충돌 해결 방법에 따라 확률적으로 결정되며, 이는 다른 non-linear 구조와 다른 특성이다.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item><item><title>Primitive data structure vs Non-Primitive data structure</title><link>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</link><pubDate>Wed, 06 Nov 2024 08:39:00 +0000</pubDate><guid>https://buenhyden.github.io/til/2024/11/primitive-data-structure-vs-non-primitive-data-structure/</guid><description>
&lt;h2>Primitive Data Structure Vs Non-Primitive Data Structure&lt;/h2>&lt;h3>Primitive Data Structure&lt;/h3>&lt;p>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.&lt;br>
이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.&lt;/p>
&lt;h4>주요 특징&lt;/h4>&lt;ol>
&lt;li>&lt;strong>단순성&lt;/strong>: 가장 기본적이고 이해하기 쉬운 데이터 타입이다.&lt;/li>
&lt;li>&lt;strong>고정 크기&lt;/strong>: 일반적으로 고정된 메모리 크기를 가진다.&lt;/li>
&lt;li>&lt;strong>효율성&lt;/strong>: 메모리 사용과 접근 시간 측면에서 매우 효율적이다.&lt;/li>
&lt;li>&lt;strong>직접 표현&lt;/strong>: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다.&lt;/li>
&lt;li>&lt;strong>값 의미론&lt;/strong>: 변수에 실제 값이 직접 저장된다.&lt;/li>
&lt;li>&lt;strong>스택 할당&lt;/strong>: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다.&lt;/li>
&lt;/ol>
&lt;p>주요 primitive data structure들을 비교 분석하여 정리한 표:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 타입&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>비트 수&lt;/th>
&lt;th>값 범위&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>Java&lt;/th>
&lt;th>JavaScript&lt;/th>
&lt;th>Python&lt;/th>
&lt;th>Go&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Boolean&lt;/td>
&lt;td>참/거짓 값을 나타내는 논리 데이터 타입&lt;/td>
&lt;td>1 비트 또는 1 바이트&lt;/td>
&lt;td>true/false&lt;/td>
&lt;td>조건문과 논리 연산에 사용&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>bool&lt;/td>
&lt;td>bool&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Character&lt;/td>
&lt;td>단일 문자를 나타내는 데이터 타입&lt;/td>
&lt;td>16 비트 (Java), 8 비트 (대부분)&lt;/td>
&lt;td>U+0000 ~ U+FFFF (Java)&lt;/td>
&lt;td>문자 인코딩에 따라 다름&lt;/td>
&lt;td>char&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>byte (uint8)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>String&lt;/td>
&lt;td>문자열을 나타내는 데이터 타입&lt;/td>
&lt;td>가변&lt;/td>
&lt;td>제한 없음 (메모리 한계까지)&lt;/td>
&lt;td>불변(Java, Python), 가변(JavaScript)&lt;/td>
&lt;td>String&lt;/td>
&lt;td>String&lt;/td>
&lt;td>str&lt;/td>
&lt;td>string&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Half Precision)&lt;/td>
&lt;td>16비트 부동 소수점&lt;/td>
&lt;td>16 비트&lt;/td>
&lt;td>±6.10 × 10^−5 ~ ±6.55 × 10^4&lt;/td>
&lt;td>정밀도 낮음, 저장 공간 절약&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>float16 (패키지)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Single Precision)&lt;/td>
&lt;td>32비트 부동 소수점&lt;/td>
&lt;td>32 비트&lt;/td>
&lt;td>±1.18 × 10^−38 ~ ±3.4 × 10^38&lt;/td>
&lt;td>일반적인 실수 계산에 사용&lt;/td>
&lt;td>float&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>float&lt;/td>
&lt;td>float32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Double Precision)&lt;/td>
&lt;td>64비트 부동 소수점&lt;/td>
&lt;td>64 비트&lt;/td>
&lt;td>±2.23 × 10^−308 ~ ±1.80 × 10^308&lt;/td>
&lt;td>높은 정밀도 필요 시 사용&lt;/td>
&lt;td>double&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>float&lt;/td>
&lt;td>float64&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Float (Quadruple Precision)&lt;/td>
&lt;td>128비트 부동 소수점&lt;/td>
&lt;td>128 비트&lt;/td>
&lt;td>±3.36 × 10^−4932 ~ ±1.18 × 10^4932&lt;/td>
&lt;td>매우 높은 정밀도, 특수 용도&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Decimal (모듈)&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Byte)&lt;/td>
&lt;td>8비트 정수&lt;/td>
&lt;td>8 비트&lt;/td>
&lt;td>-128 ~ 127&lt;/td>
&lt;td>작은 범위의 정수에 사용&lt;/td>
&lt;td>byte&lt;/td>
&lt;td>-&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Short)&lt;/td>
&lt;td>16비트 정수&lt;/td>
&lt;td>16 비트&lt;/td>
&lt;td>-32,768 ~ 32,767&lt;/td>
&lt;td>중간 범위의 정수에 사용&lt;/td>
&lt;td>short&lt;/td>
&lt;td>-&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Int)&lt;/td>
&lt;td>32비트 정수&lt;/td>
&lt;td>32 비트&lt;/td>
&lt;td>-2^31 ~ 2^31 - 1&lt;/td>
&lt;td>가장 일반적으로 사용되는 정수 타입&lt;/td>
&lt;td>int&lt;/td>
&lt;td>Number&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Integer (Long)&lt;/td>
&lt;td>64비트 정수&lt;/td>
&lt;td>64 비트&lt;/td>
&lt;td>-2^63 ~ 2^63 - 1&lt;/td>
&lt;td>매우 큰 정수 값에 사용&lt;/td>
&lt;td>long&lt;/td>
&lt;td>BigInt&lt;/td>
&lt;td>int&lt;/td>
&lt;td>int64&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>사용법:&lt;/p>
&lt;ul>
&lt;li>Java:
&lt;ul>
&lt;li>Boolean: &lt;code>boolean b = true;&lt;/code>&lt;/li>
&lt;li>Character: &lt;code>char c = 'A';&lt;/code>&lt;/li>
&lt;li>String: &lt;code>String s = &amp;quot;Hello&amp;quot;;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>float f = 3.14f;&lt;/code> &lt;code>double d = 3.14;&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>byte b = 100;&lt;/code> &lt;code>short s = 1000;&lt;/code> &lt;code>int i = 10000;&lt;/code> &lt;code>long l = 1000000L;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JavaScript:
&lt;ul>
&lt;li>Boolean: &lt;code>let b = true;&lt;/code>&lt;/li>
&lt;li>String: &lt;code>let s = &amp;quot;Hello&amp;quot;;&lt;/code>&lt;/li>
&lt;li>Number: &lt;code>let n = 3.14;&lt;/code> (모든 숫자는 64비트 부동 소수점)&lt;/li>
&lt;li>BigInt: &lt;code>let bi = 1234567890123456789n;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python:
&lt;ul>
&lt;li>Boolean: &lt;code>b = True&lt;/code>&lt;/li>
&lt;li>String: &lt;code>s = &amp;quot;Hello&amp;quot;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>f = 3.14&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>i = 10000&lt;/code> (자동으로 크기 조정)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go:
&lt;ul>
&lt;li>Boolean: &lt;code>var b bool = true&lt;/code>&lt;/li>
&lt;li>String: &lt;code>var s string = &amp;quot;Hello&amp;quot;&lt;/code>&lt;/li>
&lt;li>Float: &lt;code>var f float32 = 3.14&lt;/code> &lt;code>var d float64 = 3.14&lt;/code>&lt;/li>
&lt;li>Integer: &lt;code>var i int = 10000&lt;/code> &lt;code>var l int64 = 1000000&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>각 언어별 특징:&lt;/p>
&lt;ul>
&lt;li>Java: 가장 세분화된 데이터 타입 지원&lt;/li>
&lt;li>JavaScript: 동적 타입 언어로, 대부분의 숫자를 Number로 처리&lt;/li>
&lt;li>Python: 동적 타입 언어로, 정수와 부동소수점을 자동으로 처리&lt;/li>
&lt;li>Go: 정적 타입 언어로, 명시적인 타입 선언 필요&lt;/li>
&lt;/ul>
&lt;h3>Non-Primitive Data Structure&lt;/h3>&lt;p>Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다. 이는 프로그래밍 언어에서 기본적으로 제공하는 원시 자료형을 조합하여 만든 사용자 정의 자료구조라고도 볼 수 있다.&lt;/p>
&lt;h4>주요 특징&lt;/h4>&lt;ol>
&lt;li>&lt;strong>복합성&lt;/strong>: 여러 원시 자료형을 조합하여 만들어진 복합적인 구조를 가진다.&lt;/li>
&lt;li>&lt;strong>유연성&lt;/strong>: 데이터의 저장, 접근, 수정이 더 유연하게 이루어질 수 있다.&lt;/li>
&lt;li>&lt;strong>동적 크기&lt;/strong>: 대부분의 비원시 자료구조는 크기가 동적으로 변할 수 있다.&lt;/li>
&lt;li>&lt;strong>참조 타입&lt;/strong>: 변수에 값 대신 메모리 주소를 저장한다.&lt;/li>
&lt;/ol>
&lt;h4>분류&lt;/h4>&lt;p>Non-primitive data structure는 크게 두 가지로 분류된다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>Linear Data Structure&lt;/th>
&lt;th>Non-Linear Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>데이터 요소가 순차적으로 배열되어 각 요소가 이전 및 다음 요소와 연결된 구조&lt;/td>
&lt;td>데이터 요소가 계층적으로 구성되어 여러 경로로 연결될 수 있는 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>특징&lt;/td>
&lt;td>- 단일 레벨 구조&lt;br>- 한 번의 실행으로 모든 요소 순회 가능&lt;br>- 구현이 상대적으로 간단&lt;br>- 메모리 사용이 덜 효율적&lt;/td>
&lt;td>- 다중 레벨 구조&lt;br>- 한 번의 실행으로 모든 요소 순회 불가&lt;br>- 구현이 상대적으로 복잡&lt;br>- 메모리 사용이 더 효율적&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 유형&lt;/td>
&lt;td>Array, Linked List, Stack, Queue, Deque&lt;/td>
&lt;td>Graph, Hash-based Structure, Tree, Heap&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5>각 데이터 구조의 특징과 주요 프로그래밍 언어에서의 지원 여부 및 사용법&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>데이터 구조&lt;/th>
&lt;th>유형&lt;/th>
&lt;th>특징&lt;/th>
&lt;th>Java&lt;/th>
&lt;th>JavaScript&lt;/th>
&lt;th>Python&lt;/th>
&lt;th>Go&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Array&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>연속된 메모리 위치에 요소 저장, 인덱스로 빠른 접근 가능&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;td>기본 지원 (List)&lt;/td>
&lt;td>기본 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Linked List&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>노드가 다음 노드를 가리키는 구조, 삽입/삭제 효율적&lt;/td>
&lt;td>java.util.LinkedList&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Stack&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>LIFO 원칙, 푸시/팝 연산&lt;/td>
&lt;td>java.util.Stack&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>리스트로 구현 가능&lt;/td>
&lt;td>슬라이스로 구현 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>FIFO 원칙, 인큐/디큐 연산&lt;/td>
&lt;td>java.util.Queue&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>queue 모듈&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Deque&lt;/td>
&lt;td>Linear&lt;/td>
&lt;td>양쪽 끝에서 삽입/삭제 가능&lt;/td>
&lt;td>java.util.Deque&lt;/td>
&lt;td>배열로 구현 가능&lt;/td>
&lt;td>collections.deque&lt;/td>
&lt;td>container/list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Graph&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>노드와 엣지로 구성, 복잡한 관계 표현&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>라이브러리 필요&lt;/td>
&lt;td>networkx 라이브러리&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hash-based Structure&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>키-값 쌍으로 데이터 저장, 빠른 검색&lt;/td>
&lt;td>java.util.HashMap&lt;/td>
&lt;td>Object, Map&lt;/td>
&lt;td>dict&lt;/td>
&lt;td>map&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tree&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>계층적 구조, 루트와 자식 노드로 구성&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Heap&lt;/td>
&lt;td>Non-Linear&lt;/td>
&lt;td>완전 이진 트리 기반, 최대/최소 값 빠른 접근&lt;/td>
&lt;td>java.util.PriorityQueue&lt;/td>
&lt;td>사용자 정의 필요&lt;/td>
&lt;td>heapq 모듈&lt;/td>
&lt;td>container/heap&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>각 언어별 특징:&lt;/p>
&lt;ul>
&lt;li>Java: 대부분의 데이터 구조를 기본적으로 지원하거나 java.util 패키지를 통해 제공한다.&lt;/li>
&lt;li>JavaScript: 배열과 객체를 기본으로 제공하며, 다른 구조는 사용자 정의나 라이브러리를 통해 구현해야 한다.&lt;/li>
&lt;li>Python: 리스트, 딕셔너리, 세트 등 다양한 데이터 구조를 기본으로 제공하며, 추가 모듈을 통해 더 많은 구조를 지원한다.&lt;/li>
&lt;li>Go: 배열, 슬라이스, 맵을 기본으로 제공하며, container 패키지를 통해 list, heap 등을 지원한다.&lt;/li>
&lt;/ul>
&lt;p>이 데이터 구조들은 각각의 특성에 따라 다양한 상황에서 효율적으로 사용될 수 있으며, 프로그래밍 언어별로 지원 방식이 다르므로 적절한 선택이 중요하다.&lt;/p>
&lt;h3>Primitive Data Structure Vs Non-Primitive Data Structure 비교&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>특성&lt;/th>
&lt;th>Primitive Data Structure&lt;/th>
&lt;th>Non-Primitive Data Structure&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>정의&lt;/td>
&lt;td>프로그래밍 언어에 내장된 기본 데이터 타입&lt;/td>
&lt;td>기본 데이터 타입을 사용하여 구축된 복잡한 데이터 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예시&lt;/td>
&lt;td>정수, 실수, 문자, 불리언&lt;/td>
&lt;td>배열, 연결 리스트, 스택, 큐, 트리, 그래프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>크기&lt;/td>
&lt;td>고정 크기&lt;/td>
&lt;td>동적 크기 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>복잡성&lt;/td>
&lt;td>단순함&lt;/td>
&lt;td>복잡함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>메모리 효율성&lt;/td>
&lt;td>높음&lt;/td>
&lt;td>상대적으로 낮음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구현&lt;/td>
&lt;td>언어에 내장됨&lt;/td>
&lt;td>사용자 정의 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>NULL 값&lt;/td>
&lt;td>일반적으로 허용하지 않음&lt;/td>
&lt;td>허용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>연산&lt;/td>
&lt;td>기본 연산만 지원&lt;/td>
&lt;td>복잡한 연산 및 메서드 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>추상화 수준&lt;/td>
&lt;td>낮음&lt;/td>
&lt;td>높음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 목적&lt;/td>
&lt;td>단순한 데이터 표현&lt;/td>
&lt;td>복잡한 데이터 관계 및 구조 표현&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>공통점:&lt;/p>
&lt;ol>
&lt;li>둘 다 데이터를 저장하고 관리하는 데 사용된다.&lt;/li>
&lt;li>프로그래밍에서 중요한 역할을 한다.&lt;/li>
&lt;li>특정 연산과 조작이 가능하다.&lt;/li>
&lt;/ol>
&lt;p>차이점:&lt;/p>
&lt;ol>
&lt;li>복잡성: Primitive는 단순하고, Non-Primitive는 복잡하다.&lt;/li>
&lt;li>크기: Primitive는 고정 크기, Non-Primitive는 동적 크기가 가능하다.&lt;/li>
&lt;li>구현: Primitive는 언어에 내장되어 있고, Non-Primitive는 사용자가 정의할 수 있다.&lt;/li>
&lt;li>유연성: Non-Primitive는 더 유연하고 다양한 데이터 관계를 표현할 수 있다.&lt;/li>
&lt;li>메모리 사용: Primitive가 일반적으로 더 효율적이다.&lt;/li>
&lt;li>기능: Non-Primitive는 더 복잡한 연산과 메서드를 제공한다.&lt;/li>
&lt;/ol>
&lt;p>Primitive data structure는 기본적이고 효율적인 데이터 표현에 사용되며, Non-Primitive data structure는 복잡한 데이터 관계와 구조를 표현하는 데 사용된다.
프로그래밍에서는 두 유형을 적절히 조합하여 효율적이고 강력한 애플리케이션을 구축한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;/h2></description></item></channel></rss>