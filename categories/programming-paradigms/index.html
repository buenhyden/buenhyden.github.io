<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming Paradigms | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/programming-paradigms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/programming-paradigms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/programming-paradigms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/programming-paradigms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Programming Paradigms"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Programming Paradigms"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Programming Paradigms</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)</h2></header><div class=entry-content><p>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming) 명령형 프로그래밍과 선언적 프로그래밍은 소프트웨어 개발에서 가장 기본적인 두 가지 프로그래밍 패러다임이다.
이들은 문제를 해결하는 접근 방식과 코드 작성 철학에서 근본적인 차이를 보인다.
명령형 프로그래밍과 선언적 프로그래밍은 서로 배타적이지 않으며, 각각 고유한 장점과 적합한 사용 사례가 있다.
현대 소프트웨어 개발에서는 두 패러다임을 상황에 맞게 적절히 조합하여 사용하는 것이 일반적이다.
명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다. 개발자로서 두 패러다임 모두를 이해하고 적절히 활용할 수 있다면, 다양한 문제 영역에서 효과적인 솔루션을 구축할 수 있을 것이다.
...</p></div><footer class=entry-footer><span title='2025-02-09 12:38:00 +0000 UTC'>February 9, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/imperative-programming-vs-declarative-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>다형성 (Polymorphism)</h2></header><div class=entry-content><p>다형성 (Polymorphism) 1. 주제의 분류 분석 조사한 내용을 바탕으로 " 다형성 (Polymorphism)" 의 분류를 분석하면:
제시된 분류: “Computer Science and Engineering” > “System and Software Architecture” > “Principles” > “Programming Paradigms” > “Object-Oriented Programming” > “Primary Principles”
분석 결과: 이 분류는 부분적으로 적절하지만 개선이 필요합니다.
근거:
적절한 부분: 다형성은 확실히 객체지향 프로그래밍의 핵심 원칙 중 하나입니다 개선이 필요한 부분: 다형성은 객체지향 프로그래밍에만 국한되지 않고, 함수형 프로그래밍, 타입 이론 등 더 넓은 프로그래밍 패러다임에서 사용됩니다 개선된 분류 제안: “Computer Science and Engineering” > “Programming Language Theory” > “Type Systems” > “Polymorphism” 또는 “Computer Science and Engineering” > “Programming Paradigms” > “Language Features” > “Polymorphism”
...</p></div><footer class=entry-footer><span title='2024-09-22 10:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다형성 (Polymorphism)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/polymorphism/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>상속 (Inheritance)</h2></header><div class=entry-content><p>상속 (Inheritance) 먼저 " 상속 (Inheritance)" 이라는 주제에 대해 체계적으로 조사하겠습니다.이제 상속의 다양한 유형과 구현 방법에 대해 추가로 조사하겠습니다.이제 상속의 메커니즘 방법론에 대해 더 조사하겠습니다.추가적으로 상속의 장단점과 설계 원칙에 대해 조사하겠습니다.이제 상속의 활용 사례와 실제 구현 예시에 대해 조사하겠습니다.이제 충분한 정보를 수집했으니 체계적으로 정리하겠습니다.
1. 주제 분류 적절성 분석 제시된 분류 “Computer Science and Engineering” > “System and Software Architecture” > “Principles” > “Programming Paradigms” > “Object-Oriented Programming” > “Primary Principles” 는 적절합니다.
...</p></div><footer class=entry-footer><span title='2024-09-22 10:10:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상속 (Inheritance)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/inheritance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>추상화 (Abstraction)</h2></header><div class=entry-content><p>추상화 (Abstraction) 추상화 (Abstraction) 는 복잡한 현실 세계를 간결하고 명확하게 단순화시키는 과정으로, 컴퓨터 과학과 소프트웨어 공학의 핵심 개념이다. 하위 세부사항을 숨기고 상위 수준에서 문제를 다룰 수 있게 하여 시스템의 복잡성을 효과적으로 관리한다.
데이터 추상화와 제어 추상화를 통해 구현 세부 사항을 숨기고, 인터페이스를 통해 필요한 기능만을 노출함으로써 모듈화와 유지보수성을 향상시킨다.
객체지향 프로그래밍의 핵심으로 추상 클래스, 인터페이스, 템플릿 메서드 패턴 등 다양한 기법을 통해 복잡한 시스템을 계층적으로 설계하고, 모듈화와 재사용성을 강화한다. 적절한 추상화 수준을 유지하면 유지보수성과 확장성이 향상되지만, 과도한 추상화는 오히려 복잡성과 성능 저하를 초래할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-22 06:46:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 추상화 (Abstraction)" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/abstraction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Encapsulation</h2></header><div class=entry-content><p>캡슐화 (Encapsulation) 1. 주제의 분류 적절성 평가 캡슐화 (Encapsulation) 는 객체지향 프로그래밍 (Object-Oriented Programming, OOP) 의 4 대 핵심 원리 중 하나로, 복잡한 시스템을 단순화하고 구현 세부사항을 숨겨 인터페이스 중심의 설계를 가능하게 합니다. 이는 소프트웨어 아키텍처의 설계 원칙과 프로그래밍 패러다임 분류에 부합하며, 객체지향 프로그래밍 내에서 필수적인 개념이기 때문에 “Computer Science and Engineering > System and Software Architecture > Principles > Programming Paradigms > Object-Oriented Programming > Primary Principles” 분류는 매우 적절합니다.
...</p></div><footer class=entry-footer><span title='2024-09-22 02:26:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encapsulation" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-paradigms/imperative-paradigms/object-oriented-programming/primary-principles/encapsulation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>