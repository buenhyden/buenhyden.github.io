<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Complexity Classes | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/complexity-classes/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/complexity-classes/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/complexity-classes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/complexity-classes/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Complexity Classes"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Complexity Classes"><meta name=twitter:description content="기록하고 기억하고 활용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Complexity Classes</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/computational-models/deterministic-vs-nondeterministic-computation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Non-deterministic Polynomial Time vs. Polynomial Time</h2></header><div class=entry-content><p>Non-deterministic Polynomial Time vs. Polynomial Time 계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.
이 두 클래스는 컴퓨터 과학의 발전 방향을 결정했으며, 현대 암호학과 알고리즘 설계의 이론적 토대를 형성했다.
P와 NP 클래스의 구분은 계산 복잡도 이론의 근간을 이루며, 어떤 문제가 효율적으로 해결 가능한지에 대한 근본적인 이해를 제공한다.
P 클래스 문제는 표준 컴퓨터로 효율적으로 해결할 수 있지만, NP 클래스의 많은 문제들(특히 NP-완전 문제들)은 현재 알려진 알고리즘으로는 효율적으로 해결할 수 없다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:03:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Non-deterministic Polynomial Time vs. Polynomial Time" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>NP-Hard vs. NP-Complete</h2></header><div class=entry-content><p>NP-Hard vs. NP-Complete 계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.
이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.
NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.
핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:02:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NP-Hard vs. NP-Complete" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>환원 가능성 (Reducibility)</h2></header><div class=entry-content><p>환원 가능성 (Reducibility) 환원 가능성(Reducibility)은 이론 컴퓨터 과학, 특히 계산 복잡도 이론에서 핵심적인 개념으로, 문제들 간의 상대적 난이도를 비교하고 분류하는 강력한 도구이다.
환원 가능성은 계산 복잡도 이론의 핵심 개념으로, 문제들 간의 상대적 난이도를 이해하는 데 필수적인 도구이다.
이는 NP-완전성 증명, 알고리즘 설계, 복잡도 클래스 구조화 등 다양한 이론적, 실용적 목적으로 활용된다.
환원 가능성의 연구는 여전히 활발하게 진행 중이며, 양자 계산, 평균 케이스 복잡도, 매개변수화된 복잡도 등 새로운 계산 모델과 복잡도 측정 방식에 맞춰 계속 발전하고 있다. 이러한 개념의 이해는 컴퓨터 과학의 근본적인 질문인 “어떤 문제가 효율적으로 해결 가능한가?“에 대한 통찰을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 12:03:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 환원 가능성 (Reducibility)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>