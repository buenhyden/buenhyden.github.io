<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hyunyoun's Blog – Specification-Based Test</title><link>https://buenhyden.github.io/categories/specification-based-test/</link><description>Recent content in Specification-Based Test on hyunyoun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 12 Dec 2024 17:11:00 +0000</lastBuildDate><atom:link href="https://buenhyden.github.io/categories/specification-based-test/index.xml" rel="self" type="application/rss+xml"/><item><title>Use Case Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/use-case-testing/</link><pubDate>Thu, 12 Dec 2024 17:11:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/use-case-testing/</guid><description>
&lt;h2>유즈케이스 테스팅 (Use Case Testing))&lt;span class="hx-absolute -hx-mt-20" id="유즈케이스-테스팅-use-case-testing">&lt;/span>
&lt;a href="#%ec%9c%a0%ec%a6%88%ec%bc%80%ec%9d%b4%ec%8a%a4-%ed%85%8c%ec%8a%a4%ed%8c%85-use-case-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>유즈케이스 테스팅은 유즈케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화하는 블랙박스 테스트 설계 기법이다.&lt;br>
이 방법은 액터와 시스템 간의 상호작용을 표현하고, 그 결과를 사용자에게 전달하는 과정을 테스트한다.&lt;/p>
&lt;p>실제 예시를 통해 구체적으로 살펴보자.&lt;br>
온라인 쇼핑몰의 상품 주문 기능에 대한 유즈케이스 테스팅을 설계한다고 가정해보면:&lt;/p>
&lt;p>기본 흐름(Basic Flow):&lt;/p>
&lt;ol>
&lt;li>사용자가 상품을 장바구니에 추가한다&lt;/li>
&lt;li>시스템이 장바구니 내용을 표시한다&lt;/li>
&lt;li>사용자가 주문하기 버튼을 클릭한다&lt;/li>
&lt;li>시스템이 배송 정보 입력 폼을 표시한다&lt;/li>
&lt;li>사용자가 배송 정보를 입력한다&lt;/li>
&lt;li>시스템이 결제 수단 선택 화면을 표시한다&lt;/li>
&lt;li>사용자가 결제 수단을 선택하고 결제한다&lt;/li>
&lt;li>시스템이 주문 완료 화면을 표시한다&lt;/li>
&lt;/ol>
&lt;p>대체 흐름(Alternative Flows):&lt;/p>
&lt;ul>
&lt;li>장바구니가 비어있는 경우&lt;/li>
&lt;li>배송 정보가 불완전한 경우&lt;/li>
&lt;li>결제가 실패한 경우&lt;/li>
&lt;/ul>
&lt;p>예외 흐름(Exception Flows):&lt;/p>
&lt;ul>
&lt;li>시스템 오류 발생 시&lt;/li>
&lt;li>네트워크 연결 끊김 시&lt;/li>
&lt;li>세션 만료 시&lt;/li>
&lt;/ul>
&lt;p>유즈케이스 테스팅의 단계별 수행 과정을 살펴보자:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>유즈케이스 분석 단계&lt;br>
먼저 테스트할 유즈케이스의 모든 구성 요소를 파악한다:&lt;/p>
&lt;ul>
&lt;li>선행 조건(예: 로그인된 상태여야 함)&lt;/li>
&lt;li>사용자 액션과 시스템 응답&lt;/li>
&lt;li>대체 흐름과 예외 상황&lt;/li>
&lt;li>후행 조건(예: 주문 정보가 데이터베이스에 저장되어야 함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 시나리오 도출 단계&lt;br>
각 흐름별로 구체적인 테스트 시나리오를 작성한다.&lt;br>
기본 흐름뿐만 아니라 모든 대체 흐름과 예외 흐름에 대해서도 시나리오를 만든다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>테스트 케이스 설계 단계&lt;br>
각 시나리오를 구체적인 테스트 케이스로 변환한다.&lt;br>
테스트 케이스에는 다음 내용이 포함된다:&lt;/p>
&lt;ul>
&lt;li>테스트 목적&lt;/li>
&lt;li>선행 조건&lt;/li>
&lt;li>테스트 데이터&lt;/li>
&lt;li>테스트 단계&lt;/li>
&lt;li>예상 결과&lt;/li>
&lt;li>판단 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 실행 준비 단계&lt;br>
테스트 환경을 설정하고 필요한 테스트 데이터를 준비한다:&lt;/p>
&lt;ul>
&lt;li>테스트 계정 생성&lt;/li>
&lt;li>테스트용 상품 데이터 설정&lt;/li>
&lt;li>결제 시스템 테스트 모드 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 실행 및 결과 검증 단계&lt;br>
준비된 테스트 케이스를 실행하고 결과를 검증한다:&lt;/p>
&lt;ul>
&lt;li>각 단계의 실행 결과 기록&lt;/li>
&lt;li>예상 결과와의 비교&lt;/li>
&lt;li>발견된 문제점 문서화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>프로세스 흐름 중심: 기본 흐름과 대체 흐름을 포함한 전체 프로세스를 테스트한다.&lt;/li>
&lt;li>사용자 중심 접근: 실제 사용자의 관점에서 시스템을 검증한다.&lt;/li>
&lt;li>시나리오 기반: 유즈케이스 상세(description)를 바탕으로 테스트 시나리오를 구성한다.&lt;/li>
&lt;li>다양한 테스트 레벨 적용: 컴포넌트(단위) 레벨과 시스템 레벨에서 모두 적용 가능하다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>실제 사용 환경에서의 결함 발견: 시스템이 실제로 사용되는 프로세스 흐름에서 결함을 효과적으로 찾아낼 수 있다.&lt;/li>
&lt;li>인수 테스트에 유용: 고객이나 사용자 그룹이 참여하는 인수 테스트 설계에 특히 효과적이다.&lt;/li>
&lt;li>통합 결함 식별: 통합 테스트 단계에서 컴포넌트 간 상호작용 문제를 찾는 데 도움이 된다.&lt;/li>
&lt;/ol>
&lt;h3>테스트 프로세스&lt;span class="hx-absolute -hx-mt-20" id="테스트-프로세스">&lt;/span>
&lt;a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>테스트 시나리오 구성: 어떤 흐름을 테스트할지 결정한다.&lt;/li>
&lt;li>필수 상황 선택: 유즈케이스 상세에서 테스트에 필요한 핵심 상황을 식별한다.&lt;/li>
&lt;li>상황 분류: 입력값, 출력값, 상황 처리 등으로 테스트 요소를 분류한다.&lt;/li>
&lt;li>ID 부여: 각 테스트 상황에 고유 ID를 할당한다.&lt;/li>
&lt;li>값 결정: 각 상황에 대해 가능한 값(유효/무효, 상한/하한 등)을 정의한다.&lt;/li>
&lt;/ol>
&lt;h3>테스트 레벨&lt;span class="hx-absolute -hx-mt-20" id="테스트-레벨">&lt;/span>
&lt;a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%a0%88%eb%b2%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>컴포넌트(단위) 레벨: 개별 유즈케이스를 독립적으로 테스트한다.&lt;/li>
&lt;li>시스템 레벨: 유즈케이스 간의 상호작용을 테스트한다. 활동 기반, 전이 기반, 경로 기반 커버리지 등의 방법을 사용할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>효과적인 유즈케이스 테스팅을 위한 고급 전략&lt;span class="hx-absolute -hx-mt-20" id="효과적인-유즈케이스-테스팅을-위한-고급-전략">&lt;/span>
&lt;a href="#%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9d%b8-%ec%9c%a0%ec%a6%88%ec%bc%80%ec%9d%b4%ec%8a%a4-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%84-%ec%9c%84%ed%95%9c-%ea%b3%a0%ea%b8%89-%ec%a0%84%eb%9e%b5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>
&lt;p>경계값 분석 통합&lt;br>
각 입력 필드에 대해 경계값 테스트를 수행한다. 예를 들어, 주문 수량의 최소값과 최대값을 테스트한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>상태 전이 고려&lt;br>
시스템의 상태 변화를 추적하면서 테스트한다. 예를 들어, 주문 상태가 &amp;lsquo;결제 대기&amp;rsquo; → &amp;lsquo;결제 완료&amp;rsquo; → &amp;lsquo;배송 중&amp;rsquo;으로 올바르게 변경되는지 확인한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터 일관성 검증&lt;br>
전체 프로세스 수행 후 데이터가 올바르게 저장되고 처리되었는지 확인한다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>이러한 유즈케이스 테스팅은 현대의 복잡한 소프트웨어 시스템을 체계적으로 검증하는 데 매우 효과적인 방법이다. 특히 업무 프로세스가 복잡하거나 여러 시스템이 연계되어 있는 엔터프라이즈 애플리케이션 테스팅에서 큰 가치를 발휘한다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Boundary Value Analysis</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/boundary-value-analysis/</link><pubDate>Thu, 12 Dec 2024 09:58:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/boundary-value-analysis/</guid><description>
&lt;h2>경계값 분석 (Boundary Value Analysis, BVA)&lt;span class="hx-absolute -hx-mt-20" id="경계값-분석-boundary-value-analysis-bva">&lt;/span>
&lt;a href="#%ea%b2%bd%ea%b3%84%ea%b0%92-%eb%b6%84%ec%84%9d-boundary-value-analysis-bva" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>경계값 분석은 입력 또는 출력 범위의 경계 근처에서 결함이 발생할 가능성이 높다는 경험적 관찰에 기반한 테스트 기법.&lt;br>
프로그래머들이 흔히 &amp;ldquo;off-by-one&amp;rdquo; 오류를 범하거나 경계 조건을 잘못 처리하는 경향이 있기 때문에, 이러한 경계값을 집중적으로 테스트하는 것이 효과적이다.&lt;/p>
&lt;p>예를 들어, 어떤 시스템이 1에서 100 사이의 숫자만 받아들인다고 가정해보자.&lt;br>
이때 0, 1, 2와 99, 100, 101 같은 경계값들을 테스트하는 것이 중요하다.&lt;br>
왜냐하면 이러한 값들에서 시스템이 올바르게 작동하지 않을 가능성이 높기 때문이다.&lt;/p>
&lt;h3>경계값 분석의 주요 원칙&lt;span class="hx-absolute -hx-mt-20" id="경계값-분석의-주요-원칙">&lt;/span>
&lt;a href="#%ea%b2%bd%ea%b3%84%ea%b0%92-%eb%b6%84%ec%84%9d%ec%9d%98-%ec%a3%bc%ec%9a%94-%ec%9b%90%ec%b9%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>경계값 분석에는 다음과 같은 핵심 원칙들이 있다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>최소값과 최대값 테스트:&lt;br>
유효 범위의 최소값과 최대값을 반드시 테스트한다.&lt;br>
예를 들어, 1-100 범위라면 1과 100을 테스트한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>경계 근처의 값 테스트:&lt;br>
경계값 바로 안쪽과 바깥쪽의 값을 테스트한다.&lt;br>
1-100 범위의 경우:&lt;/p>
&lt;ul>
&lt;li>최소값 경계: 0, 1, 2&lt;/li>
&lt;li>최대값 경계: 99, 100, 101&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>대표적인 경계값 상황들&lt;span class="hx-absolute -hx-mt-20" id="대표적인-경계값-상황들">&lt;/span>
&lt;a href="#%eb%8c%80%ed%91%9c%ec%a0%81%ec%9d%b8-%ea%b2%bd%ea%b3%84%ea%b0%92-%ec%83%81%ed%99%a9%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>날짜와 시간:&lt;/p>
&lt;ul>
&lt;li>윤년/평년 전환 (2월 28일, 29일)&lt;/li>
&lt;li>월말/월초 전환 (31일, 1일)&lt;/li>
&lt;li>자정 전후 (23:59:59, 00:00:00)&lt;/li>
&lt;/ul>
&lt;p>수치 데이터:&lt;/p>
&lt;ul>
&lt;li>정수 자료형의 최대/최소값&lt;/li>
&lt;li>부동소수점 정밀도 한계&lt;/li>
&lt;li>배열의 첫 번째/마지막 요소&lt;/li>
&lt;/ul>
&lt;p>문자열 처리:&lt;/p>
&lt;ul>
&lt;li>빈 문자열&lt;/li>
&lt;li>최대 길이 문자열&lt;/li>
&lt;li>특수문자가 포함된 경계&lt;/li>
&lt;/ul>
&lt;h3>실제 적용 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-적용-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%a0%81%ec%9a%a9-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>학생 성적 처리 시스템을 예로 들어보자다:&lt;/p>
&lt;p>점수 범위: 0-100점&lt;br>
등급 기준:&lt;/p>
&lt;ul>
&lt;li>A: 90-100&lt;/li>
&lt;li>B: 80-89&lt;/li>
&lt;li>C: 70-79&lt;/li>
&lt;li>D: 60-69&lt;/li>
&lt;li>F: 0-59&lt;/li>
&lt;/ul>
&lt;p>이 시스템의 경계값 테스트 케이스는 다음과 같이 설계할 수 있다:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>테스트 케이스 세트:
1. 최저 경계
- 입력값: -1 (유효하지 않은 값)
- 입력값: 0 (최소 유효값)
- 입력값: 1 (최소값 바로 위)
2. 등급 경계
- 입력값: 59, 60, 61 (F/D 경계)
- 입력값: 69, 70, 71 (D/C 경계)
- 입력값: 79, 80, 81 (C/B 경계)
- 입력값: 89, 90, 91 (B/A 경계)
3. 최고 경계
- 입력값: 99 (최대값 바로 아래)
- 입력값: 100 (최대 유효값)
- 입력값: 101 (유효하지 않은 값)&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;h3>효과적인 경계값 분석을 위한 지침&lt;span class="hx-absolute -hx-mt-20" id="효과적인-경계값-분석을-위한-지침">&lt;/span>
&lt;a href="#%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9d%b8-%ea%b2%bd%ea%b3%84%ea%b0%92-%eb%b6%84%ec%84%9d%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%a7%80%ec%b9%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>테스트 범위 결정:&lt;br>
입력값뿐만 아니라 출력값의 경계도 고려한.&lt;br>
예를 들어, 화면에 표시되는 데이터의 크기나 형식에 대한 경계값도 테스트한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터 타입 고려:&lt;br>
각 데이터 타입별로 특별히 고려해야 할 경계값들이 있다:&lt;/p>
&lt;ul>
&lt;li>정수형: 최대/최소값, 부호 전환점&lt;/li>
&lt;li>실수형: 정밀도 한계, 반올림/올림/내림 경계&lt;/li>
&lt;li>문자열: 길이 제한, 인코딩 경계&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>복합 경계값:&lt;br>
여러 조건이 결합된 경우, 각 조건의 경계값들을 조합하여 테스트한다.&lt;br>
예를 들어:&lt;/p>
&lt;ul>
&lt;li>날짜와 시간이 결합된 경우&lt;/li>
&lt;li>다중 범위 조건이 있는 경우&lt;/li>
&lt;li>여러 입력 필드가 서로 연관된 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>모든 테스트 레벨, 테스트 형태, 테스트 분류에 적용 가능하다.&lt;/li>
&lt;li>결함 발견율이 높고 적용하기 쉬운 장점이 있어 가장 많이 사용되는 테스트 기법 중 하나이다.&lt;/li>
&lt;li>경계값을 명시한 자세한 명세서가 있을 경우 적용하기가 수월하다.&lt;/li>
&lt;/ul>
&lt;h3>경계값 분석의 종류&lt;span class="hx-absolute -hx-mt-20" id="경계값-분석의-종류">&lt;/span>
&lt;a href="#%ea%b2%bd%ea%b3%84%ea%b0%92-%eb%b6%84%ec%84%9d%ec%9d%98-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>Boundary Value Analysis: 입력 범위의 경계값과 그 주변 값을 중점적으로 테스트하는 기법.&lt;br>
특징:&lt;br>
- 입력 도메인의 최소값, 최대값, 그리고 그 주변 값을 테스트한다.&lt;br>
- 유효한 입력 범위 내의 값들만 테스트한다.&lt;br>
- 많은 오류가 경계값 근처에서 발생한다는 경험에 기반한다.&lt;br>
예시1: 연령 입력 필드(유효 범위: 18-65세)에 대한 테스트 케이스.&lt;/p>
&lt;ul>
&lt;li>테스트 케이스:
&lt;ul>
&lt;li>17세 (최소값 미만)&lt;/li>
&lt;li>18세 (최소값)&lt;/li>
&lt;li>19세 (최소값 초과)&lt;/li>
&lt;li>64세 (최대값 미만)&lt;/li>
&lt;li>65세 (최대값)&lt;/li>
&lt;li>66세 (최대값 초과)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Robustness Testing: 유효하지 않은 입력값과 예상치 못한 상황에 대한 시스템의 대응을 테스트하는 기법.&lt;br>
특징:&lt;br>
- 유효한 입력 범위를 벗어난 값들도 테스트한다.&lt;br>
- 시스템의 안정성과 오류 처리 능력을 평가한다.&lt;br>
예시: 연령 입력 필드(유효 범위: 18-65세)에 대한 테스트 케이스.&lt;/p>
&lt;ul>
&lt;li>테스트 케이스:
&lt;ul>
&lt;li>-1세 (음수 값)&lt;/li>
&lt;li>0세 (최소값보다 작은 유효하지 않은 값)&lt;/li>
&lt;li>100세 (최대값보다 큰 유효하지 않은 값)&lt;/li>
&lt;li>&amp;ldquo;ABC&amp;rdquo; (문자열 입력)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Worst-Case Testing: 시스템이 처리할 수 있는 극단적인 상황을 테스트하는 기법.&lt;br>
특징:&lt;br>
- 여러 입력 변수의 극단적인 값 조합을 사용한다.&lt;br>
- 시스템의 한계를 테스트한다.&lt;br>
예시1: 사용자 등록 시스템에서의 Worst-Case Testing.&lt;/p>
&lt;ul>
&lt;li>테스트 케이스:
&lt;ul>
&lt;li>이름: 최대 허용 길이의 문자열&lt;/li>
&lt;li>나이: 시스템이 허용하는 최대 나이 (예: 120세)&lt;/li>
&lt;li>이메일: 최대 길이의 유효한 이메일 주소&lt;/li>
&lt;li>비밀번호: 최대 허용 길이의 복잡한 문자열&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Robust worst-case Testing: Worst-Case Testing과 Robustness Testing을 결합한 기법.&lt;br>
특징:&lt;br>
- 극단적인 유효값과 유효하지 않은 값을 모두 테스트한다.&lt;br>
- 가장 포괄적인 경계값 테스팅 방법이다.&lt;br>
예시1: 사용자 등록 시스템에서의 Robust worst-case Testing.&lt;/p>
&lt;ul>
&lt;li>테스트 케이스:
&lt;ul>
&lt;li>이름: 빈 문자열 또는 특수 문자만으로 구성된 최대 길이 문자열&lt;/li>
&lt;li>나이: -1, 0, 최대 허용 나이보다 큰 값 (예: 150세)&lt;/li>
&lt;li>이메일: 유효하지 않은 최대 길이 문자열&lt;/li>
&lt;li>비밀번호: 빈 문자열 또는 시스템 제한을 초과하는 길이의 문자열&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>결함 발견 효율성이 높다&lt;/li>
&lt;li>테스트 케이스 수를 체계적으로 줄일 수 있다&lt;/li>
&lt;li>구현 오류를 효과적으로 찾아낼 수 있다&lt;/li>
&lt;/ul>
&lt;h3>한계&lt;span class="hx-absolute -hx-mt-20" id="한계">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>모든 가능한 결함을 찾아내지는 못한다&lt;/li>
&lt;li>복잡한 로직의 경우 경계값 정의가 어려울 수 있다&lt;/li>
&lt;li>여러 변수가 결합된 경우 테스트 케이스가 급증할 수 있다&lt;/li>
&lt;/ul>
&lt;h3>자동화 및 도구 활용&lt;span class="hx-absolute -hx-mt-20" id="자동화-및-도구-활용">&lt;/span>
&lt;a href="#%ec%9e%90%eb%8f%99%ed%99%94-%eb%b0%8f-%eb%8f%84%ea%b5%ac-%ed%99%9c%ec%9a%a9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>경계값 분석을 자동화하기 위한 방법들:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>테스트 데이터 생성기:&lt;/p>
&lt;ul>
&lt;li>정의된 범위에 대한 경계값을 자동으로 생성&lt;/li>
&lt;li>다양한 데이터 타입에 대한 경계값 생성 지원&lt;/li>
&lt;li>랜덤 테스트와의 결합 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 프레임워크:&lt;/p>
&lt;ul>
&lt;li>경계값 테스트를 위한 특별한 어노테이션이나 기능 제공&lt;/li>
&lt;li>테스트 결과의 자동 검증&lt;/li>
&lt;li>테스트 커버리지 측정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Cause-Effect Graphing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/cause-effect-graphing/</link><pubDate>Thu, 12 Dec 2024 09:58:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/cause-effect-graphing/</guid><description>
&lt;h2>원인-결과 그래프 검사(Cause-Effect Graph Testing)&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프-검사cause-effect-graph-testing">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%82%accause-effect-graph-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>원인-결과 그래프 검사(Cause-Effect Graph Testing)는 블랙박스 테스트 기법 중 하나로, 입력 조건(원인)과 출력 결과(결과) 사이의 관계를 체계적으로 분석하고 모델링하여 효과적인 테스트 케이스를 도출하는 방법.&lt;/p>
&lt;p>원인-결과 그래프 검사는 입력 데이터 간의 관계와 출력에 미치는 영향을 그래프로 표현하여 분석하는 기법.&lt;br>
이 방법은 여러 입력 조건을 결합해서 하나 이상의 결과를 얻는 것으로, 복잡한 입력 환경을 고려할 수 있는 장점이 있다.&lt;/p>
&lt;h3>원인-결과 그래프 검사의 목적&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프-검사의-목적">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%82%ac%ec%9d%98-%eb%aa%a9%ec%a0%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 입력 값들 간의 관계를 체계적으로 분석&lt;/li>
&lt;li>입력 조건에 따른 출력의 적절성 확인&lt;/li>
&lt;li>효율성이 높은 테스트 케이스 선정&lt;/li>
&lt;/ol>
&lt;h3>원인-결과 그래프 검사의 절차&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프-검사의-절차">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%82%ac%ec%9d%98-%ec%a0%88%ec%b0%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>원인과 결과 식별&lt;/strong>: 요구사항 명세서, 설계서, 프로그램에서 원인(입력 조건)과 결과(출력 조건)를 찾아 식별한다.&lt;/li>
&lt;li>&lt;strong>그래프 작성&lt;/strong>: 원인과 결과를 연결하는 boolean 그래프를 작성한다. 이 그래프는 AND, OR, NOT 같은 boolean 연산자를 사용하여 원인과 결과 간의 논리적 관계를 표현한다.&lt;/li>
&lt;li>&lt;strong>제약 조건 표시&lt;/strong>: 불가능한 원인 조합 또는 결과 조합을 나타내는 제약(constraints)을 그래프에 표시한다.&lt;/li>
&lt;li>&lt;strong>의사결정 테이블 작성&lt;/strong>: 원인-결과 그래프를 의사결정 테이블(decision table)로 변환한다.&lt;/li>
&lt;li>&lt;strong>테스트 케이스 도출&lt;/strong>: 의사결정 테이블의 각 열을 테스트 케이스로 변환한다.&lt;/li>
&lt;/ol>
&lt;h3>그래프의 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="그래프의-구성-요소">&lt;/span>
&lt;a href="#%ea%b7%b8%eb%9e%98%ed%94%84%ec%9d%98-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>원인-결과 그래프는 다음과 같은 기본 요소들로 구성된다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>원인(Causes): 시스템에 대한 입력 조건을 나타낸다. 예를 들어, 로그인 시스템에서 &amp;lsquo;사용자 ID 입력&amp;rsquo;, &amp;lsquo;비밀번호 입력&amp;rsquo; 등이 원인이 될 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>결과(Effects): 시스템의 출력이나 반응을 나타낸다. &amp;lsquo;로그인 성공&amp;rsquo;, &amp;lsquo;에러 메시지 표시&amp;rsquo; 등이 결과의 예시이다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>논리 연산자: 원인과 결과를 연결하는 논리적 관계를 표현한다:&lt;/p>
&lt;ul>
&lt;li>AND: 모든 조건이 만족되어야 함&lt;/li>
&lt;li>OR: 하나 이상의 조건이 만족되면 됨&lt;/li>
&lt;li>NOT: 조건의 부정&lt;/li>
&lt;li>XOR: 상호 배타적 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>제약 조건: 원인들 사이의 관계를 제한하는 조건:&lt;/p>
&lt;ul>
&lt;li>배타(E): 동시에 발생할 수 없는 조건&lt;/li>
&lt;li>포함(I): 한 조건이 다른 조건을 필요로 함&lt;/li>
&lt;li>단일(O): 여러 조건 중 하나만 발생 가능&lt;/li>
&lt;li>필수(R): 반드시 발생해야 하는 조건&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>원인-결과 그래프의 표기법&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프의-표기법">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84%ec%9d%98-%ed%91%9c%ea%b8%b0%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>노드&lt;/strong>: 원인(입력 조건)은 그래프의 좌측에, 결과(출력 조건)는 우측에 위치시킨다. 각 노드는 1(참 또는 있음)과 0(거짓 또는 없음)의 두 가지 상태를 가진다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>연산자&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>IDENTITY: 원인과 결과가 동일한 상태를 가짐을 나타낸다.&lt;/li>
&lt;li>AND: 여러 원인이 모두 참일 때 결과가 참임을 나타내다.&lt;/li>
&lt;li>OR: 하나 이상의 원인이 참일 때 결과가 참임을 나타낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>제약 심볼&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>R 제약: 한 원인이 참이면 다른 원인도 반드시 참이어야 함을 나타낸다.&lt;/li>
&lt;li>E 제약: 많아야 1개의 원인이 참일 수 있음을 나타낸다.&lt;/li>
&lt;li>O 제약: 정확히 1개의 원인만 참이어야 함을 나타낸다.&lt;/li>
&lt;li>M(Mask): 한 결과가 참이면 다른 결과는 강제로 거짓이 됨을 나타낸다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>원인-결과 그래프 검사의 장점&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프-검사의-장점">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%82%ac%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>입력 조건과 출력 결과 간의 관계를 시각적으로 표현하여 이해하기 쉽다.&lt;/li>
&lt;li>복잡한 입력 환경을 체계적으로 분석할 수 있다.&lt;/li>
&lt;li>효율적인 테스트 케이스를 도출할 수 있어 테스트의 품질을 향상시킬 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>원인-결과 그래프 검사의 한계&lt;span class="hx-absolute -hx-mt-20" id="원인-결과-그래프-검사의-한계">&lt;/span>
&lt;a href="#%ec%9b%90%ec%9d%b8-%ea%b2%b0%ea%b3%bc-%ea%b7%b8%eb%9e%98%ed%94%84-%ea%b2%80%ec%82%ac%ec%9d%98-%ed%95%9c%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>대규모 시스템에서는 그래프가 복잡해질 수 있어 적용이 어려울 수 있다.&lt;/li>
&lt;li>테스트 설계자의 경험과 지식에 따라 그래프의 품질이 달라질 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>예시&lt;span class="hx-absolute -hx-mt-20" id="예시">&lt;/span>
&lt;a href="#%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>로그인 시스템에 대한 원인-결과 그래프 검사를 예로 들어보자.&lt;/p>
&lt;p>원인(입력 조건):&lt;/p>
&lt;ul>
&lt;li>C1: 아이디 입력됨&lt;/li>
&lt;li>C2: 아이디가 DB에 존재&lt;/li>
&lt;li>C3: 비밀번호 입력됨&lt;/li>
&lt;li>C4: 비밀번호가 일치&lt;/li>
&lt;/ul>
&lt;p>결과(출력 조건):&lt;/p>
&lt;ul>
&lt;li>E1: 로그인 성공&lt;/li>
&lt;li>E2: &amp;ldquo;아이디를 입력하세요&amp;rdquo; 메시지&lt;/li>
&lt;li>E3: &amp;ldquo;존재하지 않는 아이디입니다&amp;rdquo; 메시지&lt;/li>
&lt;li>E4: &amp;ldquo;비밀번호를 입력하세요&amp;rdquo; 메시지&lt;/li>
&lt;li>E5: &amp;ldquo;비밀번호가 일치하지 않습니다&amp;rdquo; 메시지&lt;/li>
&lt;/ul>
&lt;p>논리적 관계의 예:&lt;/p>
&lt;ul>
&lt;li>로그인 성공(E1)이 되려면: 아이디 입력(C1) AND 아이디 존재(C2) AND 비밀번호 입력(C3) AND 비밀번호 일치(C4)&lt;/li>
&lt;li>&amp;ldquo;아이디를 입력하세요&amp;rdquo;(E2) 메시지는: NOT 아이디 입력(C1)&lt;/li>
&lt;li>&amp;ldquo;존재하지 않는 아이디입니다&amp;rdquo;(E3) 메시지는: 아이디 입력(C1) AND NOT 아이디 존재(C2)&lt;/li>
&lt;/ul>
&lt;p>제약조건의 예:&lt;/p>
&lt;ul>
&lt;li>비밀번호가 일치(C4)하려면 반드시 비밀번호가 입력(C3)되어야 함&lt;/li>
&lt;li>아이디가 존재(C2)하려면 반드시 아이디가 입력(C1)되어야 함&lt;/li>
&lt;/ul>
&lt;p>이러한 관계를 그래프로 표현하면 다음과 같은 테스트 케이스를 도출할 수 있다:&lt;/p>
&lt;p>테스트 케이스 1: 아이디 미입력&lt;/p>
&lt;ul>
&lt;li>입력: 아이디 입력하지 않음&lt;/li>
&lt;li>예상 결과: &amp;ldquo;아이디를 입력하세요&amp;rdquo; 메시지 출력&lt;/li>
&lt;/ul>
&lt;p>테스트 케이스 2: 존재하지 않는 아이디&lt;/p>
&lt;ul>
&lt;li>입력: 존재하지 않는 아이디 입력&lt;/li>
&lt;li>예상 결과: &amp;ldquo;존재하지 않는 아이디입니다&amp;rdquo; 메시지 출력&lt;/li>
&lt;/ul>
&lt;p>테스트 케이스 3: 비밀번호 미입력&lt;/p>
&lt;ul>
&lt;li>입력: 올바른 아이디 입력, 비밀번호 미입력&lt;/li>
&lt;li>예상 결과: &amp;ldquo;비밀번호를 입력하세요&amp;rdquo; 메시지 출력&lt;/li>
&lt;/ul>
&lt;p>테스트 케이스 4: 비밀번호 불일치&lt;/p>
&lt;ul>
&lt;li>입력: 올바른 아이디, 잘못된 비밀번호 입력&lt;/li>
&lt;li>예상 결과: &amp;ldquo;비밀번호가 일치하지 않습니다&amp;rdquo; 메시지 출력&lt;/li>
&lt;/ul>
&lt;p>테스트 케이스 5: 로그인 성공&lt;/p>
&lt;ul>
&lt;li>입력: 올바른 아이디와 비밀번호 입력&lt;/li>
&lt;li>예상 결과: 로그인 성공&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Decision Table Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/decision-table-testing/</link><pubDate>Thu, 12 Dec 2024 09:58:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/decision-table-testing/</guid><description>
&lt;h2>결정 테이블 테스팅 (Decision Table Testing)&lt;span class="hx-absolute -hx-mt-20" id="결정-테이블-테스팅-decision-table-testing">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95-%ed%85%8c%ec%9d%b4%eb%b8%94-%ed%85%8c%ec%8a%a4%ed%8c%85-decision-table-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>결정 테이블 테스팅은 복잡한 비즈니스 로직이나 시스템의 동작을 테스트하기 위한 체계적인 방법.&lt;br>
여러 조건(conditions)과 그에 따른 행동(actions)의 모든 가능한 조합을 표 형태로 정리하여 테스트 케이스를 도출하는 기법.&lt;/p>
&lt;p>예를 들어, 온라인 쇼핑몰의 할인 정책을 테스트한다고 생각해보자.&lt;br>
회원 등급(일반/VIP), 구매 금액(5만원 이상/미만), 프로모션 코드 사용 여부에 따라 다른 할인율이 적용된다면, 이러한 여러 조건의 조합을 결정 테이블로 정리하여 체계적으로 테스트할 수 있다.&lt;/p>
&lt;h3>결정 테이블의 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="결정-테이블의-구성-요소">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%9d%98-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>결정 테이블은 네 가지 주요 부분으로 구성된다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>조건 스텁(Condition Stub):&lt;br>
테스트 대상 시스템에 영향을 미치는 조건들을 나열한다.&lt;br>
예를 들어:&lt;/p>
&lt;ul>
&lt;li>회원 등급&lt;/li>
&lt;li>구매 금액&lt;/li>
&lt;li>프로모션 코드 사용 여부&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>조건 항목(Condition Entries):&lt;br>
각 조건에 대한 가능한 값들을 표시합니다. 보통 &amp;lsquo;Y/N&amp;rsquo; 또는 &amp;lsquo;T/F&amp;rsquo;로 표현한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>행동 스텁(Action Stub):&lt;br>
시스템이 취할 수 있는 행동들을 나열한다.&lt;br>
예를 들어:&lt;/p>
&lt;ul>
&lt;li>할인율 적용&lt;/li>
&lt;li>포인트 적립&lt;/li>
&lt;li>무료 배송 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>행동 항목(Action Entries):&lt;br>
각각의 조건 조합에 대해 시스템이 취해야 할 행동을 표시한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>결정 테이블 작성 과정&lt;span class="hx-absolute -hx-mt-20" id="결정-테이블-작성-과정">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95-%ed%85%8c%ec%9d%b4%eb%b8%94-%ec%9e%91%ec%84%b1-%ea%b3%bc%ec%a0%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>조건 식별:&lt;br>
먼저 시스템에 영향을 미치는 모든 조건들을 식별한다. 이는 요구사항 문서나 시스템 명세를 바탕으로 한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>행동 식별:&lt;br>
시스템이 취할 수 있는 모든 가능한 행동들을 식별한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>규칙 작성:&lt;br>
조건들의 모든 가능한 조합과 그에 따른 행동을 표로 정리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>테이블 단순화:&lt;br>
불가능하거나 의미 없는 조합을 제거하여 테이블을 최적화한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>예시&lt;span class="hx-absolute -hx-mt-20" id="예시">&lt;/span>
&lt;a href="#%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>온라인 쇼핑몰 할인 정책 테스트&lt;/p>
&lt;p>조건:&lt;/p>
&lt;ul>
&lt;li>C1: 회원 등급 (VIP/일반)&lt;/li>
&lt;li>C2: 구매 금액 (5만원 이상/미만)&lt;/li>
&lt;li>C3: 프로모션 코드 사용 (예/아니오)&lt;/li>
&lt;/ul>
&lt;p>행동:&lt;/p>
&lt;ul>
&lt;li>A1: 10% 할인&lt;/li>
&lt;li>A2: 5% 할인&lt;/li>
&lt;li>A3: 추가 2% 할인&lt;/li>
&lt;li>A4: 무료 배송&lt;/li>
&lt;/ul>
&lt;p>이를 결정 테이블로 표현하면:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>| 규칙 번호 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| ------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| C1: VIP | Y | Y | Y | Y | N | N | N | N |
| C2: 5만원↑ | Y | Y | N | N | Y | Y | N | N |
| C3: 프로모션 | Y | N | Y | N | Y | N | Y | N |
| ------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| A1: 10% 할인 | X | X | | | | | |
| A2: 5% 할인 | | | X | X | X | X | |
| A3: 2% 추가 | X | | X | | X | | X |
| A4: 무료배송 | X | X | | | X | X | |&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>테스트 케이스 도출&lt;/p>
&lt;p>결정 테이블에서 각 규칙(열)은 하나의 테스트 케이스가 된다.
예를 들어:&lt;/p>
&lt;p>테스트 케이스 1:&lt;/p>
&lt;ul>
&lt;li>입력: VIP 회원이 5만원 이상 구매하고 프로모션 코드 사용&lt;/li>
&lt;li>기대 결과: 10% 할인 + 2% 추가 할인 + 무료 배송&lt;/li>
&lt;/ul>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 비즈니스 규칙을 문서화하는 데 사용된다.&lt;/li>
&lt;li>시스템의 조건과 동작(Actions)을 식별한다.&lt;/li>
&lt;li>입력 조건과 동작은 주로 참(True)과 거짓(False)으로 표현된다.&lt;/li>
&lt;li>각 열(컬럼)은 하나의 비즈니스 규칙과 대응관계를 가진다.&lt;/li>
&lt;/ol>
&lt;h3>결정 테이블 테스팅의 장점&lt;span class="hx-absolute -hx-mt-20" id="결정-테이블-테스팅의-장점">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95-%ed%85%8c%ec%9d%b4%eb%b8%94-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>체계성:
모든 가능한 조건 조합을 빠짐없이 테스트할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>명확성:
테스트 조건과 기대 결과가 명확하게 정의된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>효율성:
중복되거나 불필요한 테스트 케이스를 쉽게 식별하고 제거할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>유지보수성:
조건이나 행동이 변경될 때 테스트 케이스를 쉽게 업데이트할 수 있다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>결정 테이블 테스팅의 제한사항과 해결 방안&lt;span class="hx-absolute -hx-mt-20" id="결정-테이블-테스팅의-제한사항과-해결-방안">&lt;/span>
&lt;a href="#%ea%b2%b0%ec%a0%95-%ed%85%8c%ec%9d%b4%eb%b8%94-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%98-%ec%a0%9c%ed%95%9c%ec%82%ac%ed%95%ad%ea%b3%bc-%ed%95%b4%ea%b2%b0-%eb%b0%a9%ec%95%88" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>테이블 크기 증가:
조건이 많아지면 테이블이 기하급수적으로 커질 수 있다.
해결방안:&lt;/p>
&lt;ul>
&lt;li>조건 그룹화&lt;/li>
&lt;li>동등 분할&lt;/li>
&lt;li>우선순위가 높은 조합만 선택&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>동적 조건 처리:
시간에 따라 변하는 조건을 표현하기 어렵다.
해결방안:&lt;/p>
&lt;ul>
&lt;li>상태 전이 테스팅과 결합&lt;/li>
&lt;li>시나리오 기반 테스트 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>복잡한 의존관계:
조건들 간의 복잡한 의존관계를 표현하기 어려울 수 있다.
해결방안:&lt;/p>
&lt;ul>
&lt;li>계층적 결정 테이블 사용&lt;/li>
&lt;li>의존관계를 명시적으로 문서화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>State Transition Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/state-transition-testing/</link><pubDate>Thu, 12 Dec 2024 09:58:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/state-transition-testing/</guid><description>
&lt;h2>상태 전이 테스팅(State Transition Testing)&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스팅state-transition-testing">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8c%85state-transition-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>상태 전이 테스트는 시스템이나 객체의 상태 변화를 모델링하고, 이벤트에 따른 상태 전이와 그 결과를 검증하는 기법이다.&lt;br>
이 방법은 시스템의 현재 상황(Conditions)과 이전 이력(History)을 반영하는 상태(States) 및 그 변화(Transition)에 따라 시스템이 어떻게 동작하는지를 테스트한다.&lt;/p>
&lt;h3>상태 전이 테스트의 목적&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스트의-목적">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%eb%aa%a9%ec%a0%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>시스템의 모든 가능한 상태와 전이를 식별하고 테스트&lt;/li>
&lt;li>유효한 상태 전이뿐만 아니라 유효하지 않은 전이도 테스트&lt;/li>
&lt;li>상태 변화에 따른 시스템의 반응과 출력을 검증&lt;/li>
&lt;/ol>
&lt;h3>상태 전이 테스트의 주요 구성 요소&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스트의-주요-구성-요소">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>시스템의 상태 전이를 테스트하기 위해서는 다음 요소들을 이해하고 정의해야 한다:&lt;/p>
&lt;ol>
&lt;li>상태(States): 시스템이 특정 시점에 가질 수 있는 조건이나 상황을 의미한다. 예를 들어, 로그인 시스템의 경우 &amp;lsquo;로그아웃 상태&amp;rsquo;, &amp;lsquo;로그인 상태&amp;rsquo;, &amp;lsquo;잠금 상태&amp;rsquo; 등이 있을 수 있다.&lt;/li>
&lt;li>이벤트(Events): 상태 변화를 촉발하는 트리거를 말한다. &amp;lsquo;로그인 버튼 클릭&amp;rsquo;, &amp;lsquo;비밀번호 입력&amp;rsquo;, &amp;lsquo;시간 초과&amp;rsquo; 등이 이벤트의 예시이다.&lt;/li>
&lt;li>전이(Transitions): 한 상태에서 다른 상태로의 변화를 의미한다. 이는 특정 이벤트에 의해 발생하며, 조건이 충족되어야 실행된다.&lt;/li>
&lt;li>액션(Actions): 전이가 발생할 때 실행되는 동작이다. &amp;lsquo;에러 메시지 표시&amp;rsquo;, &amp;lsquo;데이터 저장&amp;rsquo;, &amp;lsquo;화면 갱신&amp;rsquo; 등이 여기에 해당한다.&lt;/li>
&lt;/ol>
&lt;h3>상태 전이 테스트 설계 방법&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스트-설계-방법">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%84%a4%ea%b3%84-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>상태 전이 다이어그램 작성&lt;/strong>: 시스템의 모든 상태와 상태 간 전이를 표현하는 다이어그램을 작성한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>상태-이벤트 테이블 구성&lt;/strong>: 상태 전이 다이어그램을 바탕으로 모든 상태와 이벤트의 관계를 테이블로 정리한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>전이 트리 구성&lt;/strong>: 상태-이벤트 테이블을 기반으로 상태가 전이되는 경로를 트리 형태로 표현한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>테스트 케이스 도출&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>유효 테스트 케이스: 정상적인 상태 전이를 검증하는 케이스&lt;/li>
&lt;li>무효 테스트 케이스: 유효하지 않은 상태 전이를 검증하는 케이스&lt;/li>
&lt;li>가드 조건 테스트 케이스: 상태 전이에 조건이 있는 경우, 해당 조건을 검증하는 케이스&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>테스트 프로시저 구성&lt;/strong>: 테스트 케이스를 실행 순서에 따라 나열하여 테스트 프로시저를 작성한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>실제 적용 예시&lt;span class="hx-absolute -hx-mt-20" id="실제-적용-예시">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ec%a0%81%ec%9a%a9-%ec%98%88%ec%8b%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>자동판매기의 상태 전이 테스트를 예로 들어보자:&lt;/p>
&lt;p>상태:&lt;/p>
&lt;ul>
&lt;li>대기 상태&lt;/li>
&lt;li>금액 입력 상태&lt;/li>
&lt;li>제품 선택 상태&lt;/li>
&lt;li>제품 배출 상태&lt;/li>
&lt;li>거스름돈 반환 상태&lt;/li>
&lt;/ul>
&lt;p>테스트 시나리오:&lt;/p>
&lt;ol>
&lt;li>정상 흐름: 대기 → 금액 입력 → 제품 선택 → 제품 배출 → 거스름돈 반환 → 대기&lt;/li>
&lt;li>예외 상황:
&lt;ul>
&lt;li>잘못된 금액 투입&lt;/li>
&lt;li>재고 없는 제품 선택&lt;/li>
&lt;li>거스름돈 부족 상황&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>테스트 수행 전략&lt;span class="hx-absolute -hx-mt-20" id="테스트-수행-전략">&lt;/span>
&lt;a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%88%98%ed%96%89-%ec%a0%84%eb%9e%b5" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>상태 전이 테스트는 다음과 같은 전략을 통해 수행된다:&lt;/p>
&lt;ol>
&lt;li>0-스위치 커버리지: 모든 상태를 최소한 한 번씩 방문하는 테스트.&lt;/li>
&lt;li>1-스위치 커버리지: 모든 전이를 최소한 한 번씩 수행하는 테스트.&lt;/li>
&lt;li>라운드-트립 커버리지: 시작 상태로 돌아오는 순환 경로를 테스트.&lt;/li>
&lt;li>N-스위치 커버리지: N개의 연속된 전이를 포함하는 경로를 테스트.&lt;/li>
&lt;/ol>
&lt;h3>테스트 결과 분석 및 문서화&lt;span class="hx-absolute -hx-mt-20" id="테스트-결과-분석-및-문서화">&lt;/span>
&lt;a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ea%b2%b0%ea%b3%bc-%eb%b6%84%ec%84%9d-%eb%b0%8f-%eb%ac%b8%ec%84%9c%ed%99%94" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>테스트 수행 후에는 다음 사항들을 철저히 분석하고 문서화해야 한다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>발견된 결함:&lt;/p>
&lt;ul>
&lt;li>잘못된 상태 전이&lt;/li>
&lt;li>누락된 상태 처리&lt;/li>
&lt;li>예외 상황 처리 미흡&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 커버리지:&lt;/p>
&lt;ul>
&lt;li>방문한 상태의 비율&lt;/li>
&lt;li>수행된 전이의 비율&lt;/li>
&lt;li>테스트되지 않은 경로&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>개선 제안:&lt;/p>
&lt;ul>
&lt;li>발견된 문제점에 대한 해결 방안&lt;/li>
&lt;li>추가 테스트 필요 영역&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>상태 전이 테스트의 장점&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스트의-장점">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 시스템의 동작을 체계적으로 모델링하고 테스트할 수 있다.&lt;/li>
&lt;li>누락되거나 잘못된 상태 전이를 효과적으로 발견할 수 있다.&lt;/li>
&lt;li>시스템의 동작을 사용자 관점에서 검증할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>상태 전이 테스트의 적용 분야&lt;span class="hx-absolute -hx-mt-20" id="상태-전이-테스트의-적용-분야">&lt;/span>
&lt;a href="#%ec%83%81%ed%83%9c-%ec%a0%84%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%a0%81%ec%9a%a9-%eb%b6%84%ec%95%bc" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>임베디드 소프트웨어 시스템&lt;/li>
&lt;li>자동화가 필요한 기술 분야&lt;/li>
&lt;li>비즈니스 객체 모델링&lt;/li>
&lt;li>인터넷 애플리케이션의 화면 흐름 테스트&lt;/li>
&lt;li>워크플로우 기반 시스템:
&lt;ul>
&lt;li>문서 관리 시스템&lt;/li>
&lt;li>결재 시스템&lt;/li>
&lt;li>주문 처리 시스템&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용자 인터페이스:
&lt;ul>
&lt;li>로그인 시스템&lt;/li>
&lt;li>회원가입 프로세스&lt;/li>
&lt;li>온라인 쇼핑 카트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주의사항&lt;span class="hx-absolute -hx-mt-20" id="주의사항">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>상태 전이 다이어그램이 복잡해질 경우 테스트 설계와 실행이 어려워질 수 있다.&lt;/li>
&lt;li>모든 가능한 상태와 전이를 식별하고 테스트하는 것이 중요하므로, 시스템에 대한 깊은 이해가 필요하다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>비교 검사(Comparison Testing)</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/comparison-testing/</link><pubDate>Thu, 12 Dec 2024 00:13:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/comparison-testing/</guid><description>
&lt;h2>비교 검사(Comparison Testing)&lt;span class="hx-absolute -hx-mt-20" id="비교-검사comparison-testing">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%accomparison-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>비교 검사는 블랙박스 테스팅 기법 중 하나로, 동일한 기능을 수행하는 여러 버전의 소프트웨어나 시스템을 비교하여 테스트하는 방법.&lt;/p>
&lt;p>비교 검사는 동일한 입력값을 여러 버전의 소프트웨어에 제공하고, 그 출력값을 비교하는 방식으로 진행된다.&lt;br>
예를 들어, 새로운 버전의 소프트웨어와 이전 버전의 소프트웨어에 같은 입력을 주고 결과를 비교하여 일관성을 검증한다.&lt;/p>
&lt;p>비교 검사는 특히 다음과 같은 상황에서 효과적이다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>중요한 시스템 업그레이드 시:&lt;/p>
&lt;ul>
&lt;li>새로운 버전이 기존 기능을 정확히 수행하는지 확인&lt;/li>
&lt;li>예상치 못한 부작용 발견&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>호환성 검증 시:&lt;/p>
&lt;ul>
&lt;li>다양한 플랫폼이나 환경에서의 동작 비교&lt;/li>
&lt;li>크로스 플랫폼 애플리케이션 테스트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>성능 최적화 검증 시:&lt;/p>
&lt;ul>
&lt;li>성능 개선 전후의 비교&lt;/li>
&lt;li>리소스 사용량, 응답 시간 등의 측정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>비교 검사의 목적&lt;span class="hx-absolute -hx-mt-20" id="비교-검사의-목적">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac%ec%9d%98-%eb%aa%a9%ec%a0%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>일관성 확인&lt;/strong>: 여러 버전 간의 출력 결과가 일관되는지 확인한다.&lt;/li>
&lt;li>&lt;strong>버그 식별&lt;/strong>: 특정 버전에서만 발생하는 문제를 식별할 수 있다.&lt;/li>
&lt;li>&lt;strong>성능 평가&lt;/strong>: 다른 버전 간의 성능 차이를 비교할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>비교 검사의 특징&lt;span class="hx-absolute -hx-mt-20" id="비교-검사의-특징">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac%ec%9d%98-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>여러 버전 비교&lt;/strong>: 동일한 기능을 수행하는 여러 버전의 프로그램을 대상으로 한다.&lt;/li>
&lt;li>&lt;strong>동일 입력 사용&lt;/strong>: 모든 버전에 동일한 테스트 데이터를 입력한다.&lt;/li>
&lt;li>&lt;strong>결과 비교&lt;/strong>: 각 버전에서 출력된 결과를 서로 비교한다.&lt;/li>
&lt;/ol>
&lt;h3>비교 검사의 주요 유형&lt;span class="hx-absolute -hx-mt-20" id="비교-검사의-주요-유형">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac%ec%9d%98-%ec%a3%bc%ec%9a%94-%ec%9c%a0%ed%98%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>백투백 테스팅(Back-to-Back Testing):&lt;/p>
&lt;ul>
&lt;li>동일한 사양으로 독립적으로 개발된 두 개 이상의 프로그램을 비교&lt;/li>
&lt;li>같은 입력에 대해 서로 다른 결과가 나오면 상세 분석을 수행&lt;/li>
&lt;li>예시: 두 개의 독립적인 개발팀이 만든 계산기 프로그램을 비교하여 결과의 정확성 검증&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>버전 간 비교 테스팅:&lt;/p>
&lt;ul>
&lt;li>소프트웨어의 이전 버전과 새로운 버전을 비교&lt;/li>
&lt;li>업그레이드나 패치 후의 기능 정상 작동 여부 확인&lt;/li>
&lt;li>예시: 워드프로세서의 새 버전이 이전 버전의 모든 기능을 정상적으로 수행하는지 검증&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>비교 검사의 장점&lt;span class="hx-absolute -hx-mt-20" id="비교-검사의-장점">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac%ec%9d%98-%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>신뢰성 향상:&lt;/p>
&lt;ul>
&lt;li>여러 버전이나 구현체를 비교함으로써 결과의 신뢰성을 높일 수 있다&lt;/li>
&lt;li>한 버전에서만 발생하는 오류를 쉽게 발견할 수 있다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>효율적인 결함 탐지:&lt;/p>
&lt;ul>
&lt;li>이미 검증된 버전과의 비교를 통해 새로운 버전의 결함을 빠르게 찾아낼 수 있다&lt;/li>
&lt;li>회귀 테스팅(Regression Testing)과 결합하여 더욱 효과적인 테스팅이 가능하다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>객관적인 평가:&lt;/p>
&lt;ul>
&lt;li>동일한 입력에 대한 여러 결과를 비교함으로써 객관적인 평가가 가능하다&lt;/li>
&lt;li>성능, 정확성, 일관성 등 다양한 측면에서의 평가가 가능하다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>비교 검사 수행 절차&lt;span class="hx-absolute -hx-mt-20" id="비교-검사-수행-절차">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac-%ec%88%98%ed%96%89-%ec%a0%88%ec%b0%a8" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>테스트 계획 수립:&lt;/p>
&lt;ul>
&lt;li>비교할 버전/시스템 선정&lt;/li>
&lt;li>테스트 범위와 기준 정의&lt;/li>
&lt;li>입력 데이터 세트 준비&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 실행:&lt;/p>
&lt;ul>
&lt;li>동일한 입력 데이터를 각 버전에 적용&lt;/li>
&lt;li>결과값 수집 및 기록&lt;/li>
&lt;li>실행 환경의 동일성 유지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>결과 분석:&lt;/p>
&lt;ul>
&lt;li>출력값 비교 및 차이점 식별&lt;/li>
&lt;li>차이가 발생한 경우 원인 분석&lt;/li>
&lt;li>문제점 기록 및 보고서 작성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>비교 검사 수행 시 주의사항&lt;span class="hx-absolute -hx-mt-20" id="비교-검사-수행-시-주의사항">&lt;/span>
&lt;a href="#%eb%b9%84%ea%b5%90-%ea%b2%80%ec%82%ac-%ec%88%98%ed%96%89-%ec%8b%9c-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>환경의 통일성:&lt;/p>
&lt;ul>
&lt;li>테스트 환경을 최대한 동일하게 유지해야 정확한 비교가 가능하다&lt;/li>
&lt;li>하드웨어, 운영체제, 네트워크 환경 등을 고려해야 한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터의 대표성:&lt;/p>
&lt;ul>
&lt;li>테스트 데이터는 실제 사용 사례를 잘 반영해야 한다&lt;/li>
&lt;li>경계값, 예외 케이스 등 다양한 상황을 포함해야 한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>결과 해석의 신중성:&lt;/p>
&lt;ul>
&lt;li>차이가 발생했을 때 반드시 버그라고 단정 짓지 않아야 한다&lt;/li>
&lt;li>의도된 변경사항일 수 있으므로 사양을 꼼꼼히 확인해야 한다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Requirements-based Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/requirements-based-testing/</link><pubDate>Wed, 11 Dec 2024 10:02:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/requirements-based-testing/</guid><description>
&lt;h2>요구사항 기반 테스팅 (Requirements-based Testing)&lt;span class="hx-absolute -hx-mt-20" id="요구사항-기반-테스팅-requirements-based-testing">&lt;/span>
&lt;a href="#%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad-%ea%b8%b0%eb%b0%98-%ed%85%8c%ec%8a%a4%ed%8c%85-requirements-based-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>요구사항 기반 테스팅은 소프트웨어 요구사항 명세서(SRS)에 명시된 기능적, 비기능적 요구사항을 검증하는 테스트 기법이다.&lt;br>
이 방법은 개발된 소프트웨어가 사용자와 개발 조직 간의 공식 합의에 따른 기능을 정확히 수행하는지 확인하는 것을 목표로 한다.&lt;/p>
&lt;p>실제 예시를 통해 더 구체적으로 살펴보자.&lt;br>
온라인 쇼핑몰의 로그인 기능에 대한 요구사항이 있다고 가정해보자:&lt;br>
&lt;code>&amp;quot;사용자는 이메일과 비밀번호로 로그인할 수 있어야 한다. 이메일은 올바른 형식이어야 하며, 비밀번호는 최소 8자 이상이어야 한다. 로그인 실패 시 적절한 오류 메시지를 표시해야 한다.&amp;quot;&lt;/code>&lt;/p>
&lt;p>이러한 요구사항을 기반으로 테스트를 설계하고 수행하는 과정을 단계별로 살펴보면:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>요구사항 분석 단계&lt;br>
먼저 요구사항을 세세하게 분석한다.&lt;br>
위의 예시에서 다음과 같은 핵심 요소들을 도출할 수 있다:&lt;/p>
&lt;ul>
&lt;li>이메일 형식 검증&lt;/li>
&lt;li>비밀번호 길이 검증&lt;/li>
&lt;li>로그인 성공/실패 처리&lt;/li>
&lt;li>오류 메시지 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 케이스 도출 단계&lt;br>
각 요구사항 요소별로 테스트 케이스를 작성한다.&lt;br>
예를 들어:&lt;/p>
&lt;ul>
&lt;li>올바른 이메일 형식으로 로그인 시도&lt;/li>
&lt;li>잘못된 이메일 형식으로 로그인 시도&lt;/li>
&lt;li>8자 미만의 비밀번호로 로그인 시도&lt;/li>
&lt;li>올바른 자격증명으로 로그인 시도&lt;/li>
&lt;li>잘못된 자격증명으로 로그인 시도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 설계 단계&lt;br>
각 테스트 케이스에 대해 구체적인 테스트 시나리오를 작성한다.&lt;br>
여기에는 테스트 데이터, 실행 조건, 예상 결과 등이 포함된다.&lt;br>
예를 들어: 입력값: &lt;code>test@example.com&lt;/code> / &lt;code>password123&lt;/code> 예상 결과: 로그인 성공, 메인 페이지로 이동&lt;/p>
&lt;/li>
&lt;li>
&lt;p>테스트 실행 단계&lt;br>
설계된 테스트 케이스를 실제로 실행하고 결과를 기록한다.&lt;br>
이때 요구사항과 실제 동작이 일치하는지 꼼꼼히 확인한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>결과 분석 및 보고&lt;br>
단계 테스트 결과를 분석하고, 요구사항 충족 여부를 평가한다.&lt;br>
발견된 불일치나 문제점을 문서화하고 보고한다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>요구사항 중심: 테스트 케이스는 시스템의 문서화된 요구사항에서 직접 도출된다.&lt;/li>
&lt;li>포괄적 검증: 각 요구사항에 대해 최소한 하나 이상의 테스트 케이스가 생성되어 모든 요구사항이 검증되도록 보장한다.&lt;/li>
&lt;li>블랙박스 테스팅: 일반적으로 시스템의 내부 구조를 고려하지 않고 입력과 출력만을 바탕으로 테스트를 수행한다.&lt;/li>
&lt;li>추적성: 요구사항과 테스트 케이스 간의 명확한 매핑을 통해 추적성을 제공한다.&lt;/li>
&lt;/ol>
&lt;h3>프로세스&lt;span class="hx-absolute -hx-mt-20" id="프로세스">&lt;/span>
&lt;a href="#%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>요구사항 이해: 프로젝트의 기능적, 비기능적 요구사항을 철저히 검토하고 이해한다.&lt;/li>
&lt;li>테스트 케이스 생성: 이해된 요구사항에 기반하여 테스트 케이스를 설계한다.&lt;/li>
&lt;li>요구사항 매핑: 생성된 테스트 케이스를 원래의 요구사항에 매핑한다.&lt;/li>
&lt;li>테스트 실행: 설계된 테스트 케이스를 실행하고 결과를 분석한다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>포괄적인 테스트 범위: 모든 요구사항이 테스트되도록 보장한다.&lt;/li>
&lt;li>조기 결함 발견: 개발 프로세스 초기에 결함을 식별할 수 있다.&lt;/li>
&lt;li>요구사항 명확화: 테스트 과정에서 모호한 요구사항을 식별하고 명확히 할 수 있다.&lt;/li>
&lt;li>개발 및 테스트 팀 간 협력 강화: 요구사항을 중심으로 팀 간 의사소통이 개선된다.&lt;/li>
&lt;/ol>
&lt;h3>한계점&lt;span class="hx-absolute -hx-mt-20" id="한계점">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>요구사항 품질 의존성: 테스트의 효과성이 요구사항 문서의 품질에 크게 의존한다.&lt;/li>
&lt;li>예상치 못한 시나리오 누락: 문서화되지 않은 요구사항이나 예외 상황을 놓칠 수 있다.&lt;/li>
&lt;li>시간 소요: 모든 요구사항에 대한 테스트 케이스 설계와 실행에 상당한 시간이 필요할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>요구사항 기반 테스팅을 더욱 효과적으로 수행하기 위한 방법들&lt;span class="hx-absolute -hx-mt-20" id="요구사항-기반-테스팅을-더욱-효과적으로-수행하기-위한-방법들">&lt;/span>
&lt;a href="#%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad-%ea%b8%b0%eb%b0%98-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%84-%eb%8d%94%ec%9a%b1-%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9c%bc%eb%a1%9c-%ec%88%98%ed%96%89%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-%eb%b0%a9%eb%b2%95%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>요구사항 리뷰 참여
테스트 팀이 초기 요구사항 리뷰 단계부터 참여하여, 테스트 관점에서 요구사항의 명확성과 테스트 가능성을 검토한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>추적성 매트릭스 활용
요구사항과 테스트 케이스 간의 매핑을 명확히 하여, 모든 요구사항이 적절히 테스트되는지 추적한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>자동화 도구 활용
반복적인 테스트는 자동화하여 효율성을 높인다.
특히 회귀 테스트에서 유용하다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>실제 현장에서 요구사항 기반 테스팅을 적용할 때의 팁&lt;span class="hx-absolute -hx-mt-20" id="실제-현장에서-요구사항-기반-테스팅을-적용할-때의-팁">&lt;/span>
&lt;a href="#%ec%8b%a4%ec%a0%9c-%ed%98%84%ec%9e%a5%ec%97%90%ec%84%9c-%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad-%ea%b8%b0%eb%b0%98-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%84-%ec%a0%81%ec%9a%a9%ed%95%a0-%eb%95%8c%ec%9d%98-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>우선순위 설정
모든 요구사항을 동일한 수준으로 테스트할 수는 없으므로, 중요도와 위험도를 고려하여 우선순위를 설정한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>경계값 분석
요구사항에 명시된 조건들의 경계값을 집중적으로 테스트한다. 예를 들어, 비밀번호 길이가 8자인 경우, 7자와 8자, 9자의 케이스를 모두 테스트합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>네거티브 테스트 포함
요구사항을 만족하지 않는 상황에서의 시스템 동작도 테스트한다. 이는 시스템의 견고성을 높이는 데 중요하다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>이러한 요구사항 기반 테스팅은 소프트웨어 품질 보증의 기본이 되는 중요한 접근법이다. 특히 명확한 요구사항이 존재하는 프로젝트에서 매우 효과적이며, 다른 테스트 기법들과 보완적으로 사용될 때 최상의 결과를 얻을 수 있다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Metamorphic Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/metamorphic-testing/</link><pubDate>Wed, 11 Dec 2024 10:01:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/metamorphic-testing/</guid><description>
&lt;h2>메타모픽 테스팅 (Metamorphic Testing, MT)&lt;span class="hx-absolute -hx-mt-20" id="메타모픽-테스팅-metamorphic-testing-mt">&lt;/span>
&lt;a href="#%eb%a9%94%ed%83%80%eb%aa%a8%ed%94%bd-%ed%85%8c%ec%8a%a4%ed%8c%85-metamorphic-testing-mt" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>소프트웨어 테스트에서 &amp;ldquo;오라클 문제&amp;rdquo;(테스트 결과의 정확성을 판단하기 어려운 상황)를 해결하기 위해 개발된 방법으로,&lt;br>
메타모픽 테스팅은 소프트웨어의 의도된 기능에 대한 필수적인 속성인 메타모픽 관계(Metamorphic Relations, MRs)를 활용하여 테스트를 수행한다.&lt;br>
이 방법은 정확한 출력값을 알지 못해도 테스트가 가능하다는 점에서 특징적이다.&lt;/p>
&lt;p>메타모픽 테스팅의 핵심 원리는 입력값들 사이의 관계와 그에 따른 출력값들 사이의 관계를 활용하는 것이다.&lt;br>
예를 들어, 어떤 숫자에 2를 곱한 값과 원래 숫자의 제곱을 비교한다고 생각해보자.&lt;br>
입력값이 3일 때, 3 × 2 = 6이고 3² = 9이다.&lt;br>
여기서 우리는 &amp;ldquo;어떤 숫자에 2를 곱한 값은 항상 그 숫자의 제곱보다 작다&amp;quot;라는 메타모픽 관계를 발견할 수 있다.&lt;/p>
&lt;p>실제 적용 예시를 통해 더 자세히 살펴보자:&lt;/p>
&lt;p>검색 엔진 테스트의 경우:&lt;/p>
&lt;ul>
&lt;li>원래 검색어: &amp;ldquo;강아지 훈련&amp;rdquo;&lt;/li>
&lt;li>변형된 검색어: &amp;ldquo;강아지 훈련 방법&amp;rdquo;&lt;br>
메타모픽 관계: 두 번째 검색 결과는 첫 번째 검색 결과의 부분집합이어야 한다.&lt;/li>
&lt;/ul>
&lt;p>정렬 알고리즘 테스트의 경우:&lt;/p>
&lt;ul>
&lt;li>원래 입력: [4, 2, 7, 1]&lt;/li>
&lt;li>변형된 입력: [4, 2, 7, 1, 4]&lt;br>
메타모픽 관계: 두 번째 정렬 결과는 첫 번째 정렬 결과에 4가 한 번 더 추가된 형태여야 한다.&lt;/li>
&lt;/ul>
&lt;h2>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>속성 기반 테스팅: 입력과 출력 간의 관계가 아닌 입력들 간의 일반적인 관계를 기반으로 시스템 기능을 설명한다.&lt;/li>
&lt;li>다중 실행: 소프트웨어의 여러 실행 결과를 비교하여 테스트한다.&lt;/li>
&lt;li>오라클 문제 해결: 예상 출력을 정확히 알지 못해도 테스트가 가능하다.&lt;/li>
&lt;li>테스트 케이스 생성: MRs를 통해 소스 테스트 케이스로부터 후속 테스트 케이스를 자동으로 생성할 수 있다.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;dl>
&lt;dt>&amp;ldquo;오라클 문제&amp;rdquo;&lt;/dt>
&lt;dd>테스트 결과의 정확성을 판단하기 어려운 상황&lt;/dd>
&lt;/dl>
&lt;/blockquote>
&lt;h3>메타모픽 테스팅의 수행 단계&lt;span class="hx-absolute -hx-mt-20" id="메타모픽-테스팅의-수행-단계">&lt;/span>
&lt;a href="#%eb%a9%94%ed%83%80%eb%aa%a8%ed%94%bd-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%9d%98-%ec%88%98%ed%96%89-%eb%8b%a8%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>메타모픽 관계 식별&lt;br>
테스트 대상 시스템에서 성립해야 하는 메타모픽 관계를 찾는다.&lt;br>
이는 수학적 속성이나 비즈니스 규칙에서 도출될 수 있다.&lt;br>
예를 들어, 삼각함수에서 sin(x) = sin(x + 2π) 같은 관계를 활용할 수 있다.&lt;/li>
&lt;li>소스 테스트 케이스 생성&lt;br>
기본이 되는 테스트 케이스를 만든다.&lt;br>
예를 들어, 삼각함수 테스트에서 x = 30°를 소스 테스트 케이스로 선택할 수 있다.&lt;/li>
&lt;li>후속 테스트 케이스 생성&lt;br>
메타모픽 관계를 적용하여 새로운 테스트 케이스를 만든다.&lt;br>
위의 예에서는 x = 30° + 360°가 후속 테스트 케이스가 된다.&lt;/li>
&lt;li>테스트 실행 및 검증&lt;br>
두 테스트 케이스를 실행하고 결과가 메타모픽 관계를 만족하는지 확인한다.&lt;br>
sin(30°)와 sin(390°)의 값이 같아야 한다.&lt;/li>
&lt;/ol>
&lt;h3>적용 분야&lt;span class="hx-absolute -hx-mt-20" id="적용-분야">&lt;/span>
&lt;a href="#%ec%a0%81%ec%9a%a9-%eb%b6%84%ec%95%bc" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>메타모픽 테스팅은 다양한 분야에서 적용되고 있다:&lt;/p>
&lt;ul>
&lt;li>웹 서비스&lt;/li>
&lt;li>컴퓨터 그래픽스&lt;/li>
&lt;li>임베디드 시스템&lt;/li>
&lt;li>시뮬레이션 및 모델링&lt;/li>
&lt;li>기계 학습&lt;/li>
&lt;li>의사 결정 지원 시스템&lt;/li>
&lt;li>생물정보학&lt;/li>
&lt;li>컴파일러 등&lt;/li>
&lt;/ul>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>단순성: 개념이 간단하고 구현이 쉽다.&lt;/li>
&lt;li>자동화 용이성: MRs만 정의되면 테스트 과정의 대부분을 자동화할 수 있다.&lt;/li>
&lt;li>효과적인 결함 검출: 널리 사용되는 프로그램에서도 실제 결함을 발견할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>한계점&lt;span class="hx-absolute -hx-mt-20" id="한계점">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>MR 식별의 어려움: 효과적인 MRs를 식별하는 것이 쉽지 않을 수 있다.&lt;/li>
&lt;li>복잡한 시스템에서의 적용: 매우 복잡한 시스템에서는 적용이 어려울 수 있다.&lt;/li>
&lt;/ol>
&lt;p>메타모픽 테스팅은 특히 테스트 오라클이 없거나 불완전한 경우, 그리고 입력 도메인이 매우 큰 경우에 유용하다.&lt;br>
이 기법은 다른 정적 및 동적 소프트웨어 분석 기법들과 결합하여 사용될 수 있으며, 소프트웨어의 검증, 유효성 검사 및 품질 평가를 위한 강력한 도구로 발전하고 있다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>분류 트리 방법 (Classification Tree Method)</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/</link><pubDate>Wed, 11 Dec 2024 09:58:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/</guid><description>
&lt;h2>분류 트리 방법 (Classification Tree Method, CTM)&lt;span class="hx-absolute -hx-mt-20" id="분류-트리-방법-classification-tree-method-ctm">&lt;/span>
&lt;a href="#%eb%b6%84%eb%a5%98-%ed%8a%b8%eb%a6%ac-%eb%b0%a9%eb%b2%95-classification-tree-method-ctm" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.&lt;/p>
&lt;p>분류 트리 방법은 테스트 대상 시스템의 입력 도메인을 여러 분류(Classifications)로 나누고, 각 분류 아래에 클래스(Classes)들을 정의하는 방식으로 작동한다.&lt;br>
여기서 분류는 테스트할 특성이나 매개변수를 의미하고, 클래스는 그 특성이 가질 수 있는 구체적인 값들을 의미한다.&lt;/p>
&lt;p>예를 들어, 온라인 쇼핑몰의 주문 시스템을 테스트한다고 가정해보자:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>분류: 결제 방법&lt;/p>
&lt;ul>
&lt;li>클래스: 신용카드, 계좌이체, 휴대폰 결제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>분류: 배송 옵션&lt;/p>
&lt;ul>
&lt;li>클래스: 일반배송, 특급배송, 해외배송&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>분류: 주문 금액&lt;/p>
&lt;ul>
&lt;li>클래스: 1만원 미만, 1-5만원, 5만원 이상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>주요 단계&lt;span class="hx-absolute -hx-mt-20" id="주요-단계">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%eb%8b%a8%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분류(Classification): 테스트 관련 측면(classifications)과 해당 값(classes)을 식별한다.&lt;/li>
&lt;li>조합(Combination): 다양한 분류의 클래스들을 조합하여 테스트 케이스를 생성한다.&lt;/li>
&lt;li>명세(Specification): 생성된 조합을 바탕으로 실제 테스트 케이스를 작성한다.&lt;/li>
&lt;/ol>
&lt;h3>특징&lt;span class="hx-absolute -hx-mt-20" id="특징">&lt;/span>
&lt;a href="#%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>블랙박스 테스팅 방법으로, 다양한 유형의 시스템에 적용 가능하다.&lt;/li>
&lt;li>등가 분할(Equivalence Partitioning)과 경계값 분석(Boundary Value Analysis) 원칙을 활용한다.&lt;/li>
&lt;li>그래픽 기반 기법으로, 루트, 브랜치, 리프로 구성된 트리 구조를 사용한다.&lt;/li>
&lt;li>테스트 케이스 간의 관계를 시각적으로 표현하여 테스트 커버리지를 쉽게 이해할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>체계적인 접근: 테스트 프로세스에 구조화된 접근 방식을 제공한다.&lt;/li>
&lt;li>효율성: 테스트 케이스 설계와 생성 과정을 효율적으로 만든다.&lt;/li>
&lt;li>가시성: 테스트 케이스 간의 관계를 시각적으로 표현하여 이해도를 높인다.&lt;/li>
&lt;/ol>
&lt;h3>최근 발전&lt;span class="hx-absolute -hx-mt-20" id="최근-발전">&lt;/span>
&lt;a href="#%ec%b5%9c%ea%b7%bc-%eb%b0%9c%ec%a0%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>우선순위 기반 테스트 케이스 생성: 요소에 가중치를 할당하여 테스트 케이스의 우선순위를 결정할 수 있다.&lt;/li>
&lt;li>테스트 시퀀스 생성: 클래스 간 유효한 전이를 정의하여 자동으로 테스트 시퀀스를 생성할 수 있다.&lt;/li>
&lt;/ol>
&lt;p>CTM은 테스트 설계를 체계화하고 효율화하는 강력한 도구이지만, 복잡한 시스템에서는 트리가 매우 복잡해질 수 있다는 점에 유의해야 한다.&lt;br>
따라서 적절한 수준의 추상화와 분류가 중요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Equivalence Partitioning</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/</link><pubDate>Wed, 11 Dec 2024 09:57:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/</guid><description>
&lt;h2>동등 분할(Equivalence Partitioning)&lt;span class="hx-absolute -hx-mt-20" id="동등-분할equivalence-partitioning">&lt;/span>
&lt;a href="#%eb%8f%99%eb%93%b1-%eb%b6%84%ed%95%a0equivalence-partitioning" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>동등 분할은 입력 또는 출력 데이터를 의미 있는 그룹으로 나누어 테스트하는 기법.&lt;br>
이 방법의 핵심 아이디어는 같은 그룹에 속한 데이터는 프로그램에서 동일한 방식으로 처리될 것이라는 가정에 기반한다.&lt;br>
따라서 각 그룹에서 대표값만 테스트함으로써 효율적으로 테스트를 수행할 수 있다.&lt;/p>
&lt;p>예를 들어,&lt;br>
학생의 시험 점수(0-100점)를 등급(A, B, C, D, F)으로 변환하는 프로그램을 생각해보자.&lt;br>
이 경우 점수 범위를 다음과 같이 분할할 수 있다:&lt;/p>
&lt;p>유효 분할:&lt;/p>
&lt;ul>
&lt;li>90-100점: A등급&lt;/li>
&lt;li>80-89점: B등급&lt;/li>
&lt;li>70-79점: C등급&lt;/li>
&lt;li>60-69점: D등급&lt;/li>
&lt;li>0-59점: F등급&lt;/li>
&lt;/ul>
&lt;p>무효 분할:&lt;/p>
&lt;ul>
&lt;li>0점 미만&lt;/li>
&lt;li>100점 초과&lt;/li>
&lt;/ul>
&lt;h3>개념 및 정의&lt;span class="hx-absolute -hx-mt-20" id="개념-및-정의">&lt;/span>
&lt;a href="#%ea%b0%9c%eb%85%90-%eb%b0%8f-%ec%a0%95%ec%9d%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>입력값을 동등한 그룹(Equivalence Class)으로 분할한 후, 각 그룹에서 대표값을 선택하여 테스트한다.&lt;/li>
&lt;li>동일 그룹 내의 값들은 시스템이 동일하게 처리한다고 가정한다.&lt;/li>
&lt;li>하나의 값을 테스트함으로써 전체 그룹의 동작을 검증할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3>목적 및 특징&lt;span class="hx-absolute -hx-mt-20" id="목적-및-특징">&lt;/span>
&lt;a href="#%eb%aa%a9%ec%a0%81-%eb%b0%8f-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>입력값의 효율적인 테스트를 지원한다.&lt;/li>
&lt;li>모든 입력값을 개별적으로 테스트할 필요 없이, 각 그룹의 대표값으로 테스트를 수행한다.&lt;/li>
&lt;li>일반적으로 경계값 분석(Boundary Value Analysis)과 함께 사용된다.&lt;/li>
&lt;/ul>
&lt;h3>커버리지 계산&lt;span class="hx-absolute -hx-mt-20" id="커버리지-계산">&lt;/span>
&lt;a href="#%ec%bb%a4%eb%b2%84%eb%a6%ac%ec%a7%80-%ea%b3%84%ec%82%b0" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>동등 분할 커버리지는 일반적으로 백분율로 표기하며, 다음과 같이 계산한다:&lt;br>
&lt;code>(최소한 한 개의 값으로 테스트한 동등 분할 수) / (식별한 모든 동등 분할의 수) * 100&lt;/code>&lt;/p>
&lt;h3>동등 분할의 종류&lt;span class="hx-absolute -hx-mt-20" id="동등-분할의-종류">&lt;/span>
&lt;a href="#%eb%8f%99%eb%93%b1-%eb%b6%84%ed%95%a0%ec%9d%98-%ec%a2%85%eb%a5%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>유효 동등 분할: 유효한 입력값을 포함하는 그룹&lt;/li>
&lt;li>비유효 동등 분할: 유효하지 않은 입력값을 포함하는 그룹&lt;/li>
&lt;/ol>
&lt;h3>적용 방법&lt;span class="hx-absolute -hx-mt-20" id="적용-방법">&lt;/span>
&lt;a href="#%ec%a0%81%ec%9a%a9-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>입력 도메인을 식별한다.&lt;/li>
&lt;li>입력 도메인을 동등한 그룹으로 분할한다.&lt;/li>
&lt;li>각 그룹에서 대표값을 선택한다.&lt;/li>
&lt;li>선택된 대표값으로 테스트 케이스를 작성한다.&lt;/li>
&lt;/ol>
&lt;h3>동등 분할의 상세 원칙과 적용&lt;span class="hx-absolute -hx-mt-20" id="동등-분할의-상세-원칙과-적용">&lt;/span>
&lt;a href="#%eb%8f%99%eb%93%b1-%eb%b6%84%ed%95%a0%ec%9d%98-%ec%83%81%ec%84%b8-%ec%9b%90%ec%b9%99%ea%b3%bc-%ec%a0%81%ec%9a%a9" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>분할 기준 설정:
&lt;ol>
&lt;li>
&lt;p>입력 조건 기반:&lt;/p>
&lt;ul>
&lt;li>값의 범위(예: 1-100)&lt;/li>
&lt;li>숫자의 개수(예: 2-5개의 항목)&lt;/li>
&lt;li>데이터 타입(예: 숫자, 문자, 날짜)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>출력 조건 기반:&lt;/p>
&lt;ul>
&lt;li>결과값의 종류&lt;/li>
&lt;li>오류 메시지의 유형&lt;/li>
&lt;li>시스템 상태의 변화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>실제 적용 예시: 회원가입 시스템&lt;/p>
&lt;p>비밀번호 규칙을 예로 들어보자:&lt;/p>
&lt;ul>
&lt;li>길이: 8-16자&lt;/li>
&lt;li>구성: 영문자, 숫자, 특수문자 포함&lt;/li>
&lt;li>제한: 연속된 문자 3개 이상 사용 불가&lt;/li>
&lt;/ul>
&lt;p>이에 대한 동등 분할:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>유효한 경우:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>분할 1: 정상적인 비밀번호
- 예: &amp;#34;Password1!&amp;#34;
- 특징: 모든 요구사항 충족
분할 2: 최소 길이 비밀번호
- 예: &amp;#34;Pass1!@#&amp;#34;
- 특징: 8자, 모든 요구사항 충족
분할 3: 최대 길이 비밀번호
- 예: &amp;#34;Password1!@#$%^&amp;amp;&amp;#34;
- 특징: 16자, 모든 요구사항 충족&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>무효한 경우:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>분할 4: 길이 부족
- 예: &amp;#34;Pass1!&amp;#34;
- 특징: 7자 미만
분할 5: 길이 초과
- 예: &amp;#34;PasswordPassword1!&amp;#34;
- 특징: 17자 이상
분할 6: 구성요소 누락
- 예: &amp;#34;Password&amp;#34;
- 특징: 숫자/특수문자 누락
분할 7: 연속된 문자 포함
- 예: &amp;#34;Password123!&amp;#34;
- 특징: 연속된 숫자 사용&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;h3>테스트 케이스 설계 프로세스&lt;span class="hx-absolute -hx-mt-20" id="테스트-케이스-설계-프로세스">&lt;/span>
&lt;a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%84%a4%ea%b3%84-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>단계별 접근 방식:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>입력 조건 분석:&lt;/p>
&lt;ul>
&lt;li>요구사항 문서 검토&lt;/li>
&lt;li>입력 가능한 모든 조건 식별&lt;/li>
&lt;li>제약사항 파악&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>분할 영역 정의:&lt;/p>
&lt;ul>
&lt;li>유효한 입력 영역 구분&lt;/li>
&lt;li>무효한 입력 영역 구분&lt;/li>
&lt;li>경계 조건 고려&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 케이스 선택:&lt;/p>
&lt;ul>
&lt;li>각 분할에서 대표값 선정&lt;/li>
&lt;li>경계값과의 조합 고려&lt;/li>
&lt;li>특수한 시나리오 추가&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 케이스 구체화:&lt;/p>
&lt;ul>
&lt;li>입력값 정의&lt;/li>
&lt;li>기대 결과 명시&lt;/li>
&lt;li>테스트 절차 작성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>테스트 케이스 수를 효율적으로 줄일 수 있다&lt;/li>
&lt;li>체계적인 접근으로 커버리지를 보장할 수 있다&lt;/li>
&lt;li>유지보수가 용이하다&lt;/li>
&lt;/ul>
&lt;h3>한계&lt;span class="hx-absolute -hx-mt-20" id="한계">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ul>
&lt;li>분할 경계에서의 오류를 놓칠 수 있다&lt;/li>
&lt;li>복잡한 조건의 조합을 모두 다루기 어렵다&lt;/li>
&lt;li>분할 기준의 주관성이 있을 수 있다&lt;/li>
&lt;/ul>
&lt;h3>효과적인 동등 분할을 위한 권장사항&lt;span class="hx-absolute -hx-mt-20" id="효과적인-동등-분할을-위한-권장사항">&lt;/span>
&lt;a href="#%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9d%b8-%eb%8f%99%eb%93%b1-%eb%b6%84%ed%95%a0%ec%9d%84-%ec%9c%84%ed%95%9c-%ea%b6%8c%ec%9e%a5%ec%82%ac%ed%95%ad" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>데이터 특성 고려:&lt;/p>
&lt;ul>
&lt;li>데이터의 성질과 의미를 충분히 이해&lt;/li>
&lt;li>업무 규칙과 제약조건 반영&lt;/li>
&lt;li>실제 사용 패턴 분석&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>분할 기준 최적화:&lt;/p>
&lt;ul>
&lt;li>너무 세밀한 분할 지양&lt;/li>
&lt;li>너무 큰 분할 지양&lt;/li>
&lt;li>의미 있는 구분점 선택&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>테스트 효율성 향상:&lt;/p>
&lt;ul>
&lt;li>자동화 도구 활용&lt;/li>
&lt;li>테스트 데이터 생성기 사용&lt;/li>
&lt;li>테스트 케이스 관리 도구 활용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>Scenario Testing</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/scenario-testing/</link><pubDate>Wed, 11 Dec 2024 09:57:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/scenario-testing/</guid><description>
&lt;h2>시나리오 테스팅 (Scenario Testing)&lt;span class="hx-absolute -hx-mt-20" id="시나리오-테스팅-scenario-testing">&lt;/span>
&lt;a href="#%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4-%ed%85%8c%ec%8a%a4%ed%8c%85-scenario-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>시나리오 테스팅은 실제 상황을 시뮬레이션하여 소프트웨어를 검증하는 강력한 기술이다.
개별 기능에 초점을 맞춘 기존 테스트 케이스와 달리 시나리오 테스트에서는 일련의 이벤트나 상호 작용이 발생할 때 시스템이 어떻게 작동하는지 검사한다.&lt;/p>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>사용자 중심 접근: 실제 사용자의 관점에서 소프트웨어를 테스트한다.&lt;/li>
&lt;li>전체 흐름 검증: 개별 기능이 아닌 전체 사용 흐름을 테스트한다.&lt;/li>
&lt;li>현실적인 상황 재현: 실제 사용 환경과 유사한 상황을 시뮬레이션한다.&lt;/li>
&lt;li>비기술적 언어 사용: 비기술적인 사용자도 이해할 수 있는 언어로 작성된다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>사용자 경험 개선: 실제 사용자의 관점에서 테스트하므로 사용자 불편이나 흐름의 단절을 발견할 수 있다.&lt;/li>
&lt;li>종합적인 결함 발견: 기능 간 상호작용에서 발생하는 결함을 발견할 수 있다.&lt;/li>
&lt;li>예기치 못한 문제 파악: 다양한 상황을 미리 시뮬레이션하여 잠재적인 오류와 리스크를 발견할 수 있다.&lt;/li>
&lt;li>팀 간 협업 강화: 비기술적 이해관계자도 시나리오를 이해하기 쉬워 협업이 용이하다.&lt;/li>
&lt;/ol>
&lt;h3>적용 방법&lt;span class="hx-absolute -hx-mt-20" id="적용-방법">&lt;/span>
&lt;a href="#%ec%a0%81%ec%9a%a9-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>시나리오 정의: 테스트할 주요 시나리오를 식별한다.&lt;/li>
&lt;li>테스트 데이터 준비: 실제 환경에서 발생할 수 있는 모든 상황을 포괄하는 데이터를 준비한다.&lt;/li>
&lt;li>시나리오 실행: 정의된 시나리오에 따라 테스트를 수행한다.&lt;/li>
&lt;li>결과 분석: 시나리오 실행 결과를 분석하고 문제점을 식별한다.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</link><pubDate>Wed, 11 Dec 2024 09:42:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</guid><description>
&lt;h2>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)&lt;span class="hx-absolute -hx-mt-20" id="조합-테스트-설계-기법-combinatorial-test-design-techniques">&lt;/span>
&lt;a href="#%ec%a1%b0%ed%95%a9-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%84%a4%ea%b3%84-%ea%b8%b0%eb%b2%95-combinatorial-test-design-techniques" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.&lt;br>
이 기법은 모든 가능한 입력 조합을 테스트하는 대신 최적화된 조합을 선택하여 테스트 범위를 최대화하고 테스트 케이스 수를 최소화한다.&lt;/p>
&lt;p>실제 테스트 설계 시에는 다음과 같은 단계를 따르는 것이 좋다:&lt;/p>
&lt;ol>
&lt;li>테스트 대상 식별&lt;br>
먼저 어떤 요소들을 테스트할 것인지 명확히 한다.&lt;br>
각 요소가 가질 수 있는 값들도 정의한다.&lt;/li>
&lt;li>제약조건 파악&lt;br>
일부 조합은 현실적으로 불가능하거나 의미가 없을 수 있다.&lt;br>
예를 들어, 특정 운영체제 버전에서는 5G를 지원하지 않을 수 있다.&lt;/li>
&lt;li>테스트 방법 선택&lt;br>
시스템의 중요도와 가용 자원을 고려하여 적절한 테스트 방법을 선택한다.&lt;/li>
&lt;li>테스트 케이스 생성&lt;br>
선택한 방법에 따라 테스트 케이스를 생성한다.&lt;br>
이때 자동화 도구를 활용하면 더욱 효율적이다.&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>수학적 기반: 직교 배열(Orthogonal Arrays)과 같은 수학적 개념을 활용한다.&lt;/li>
&lt;li>효율성: 적은 수의 테스트 케이스로 넓은 범위의 입력 조합을 커버한다.&lt;/li>
&lt;li>리스크 감소: 특정 입력 조합에서 발생할 수 있는 결함을 효과적으로 찾아낸다.&lt;/li>
&lt;li>자동화 가능: 특수한 알고리즘이나 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>주요 기법&lt;span class="hx-absolute -hx-mt-20" id="주요-기법">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ea%b8%b0%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>페어와이즈 테스팅(Pairwise Testing): 모든 가능한 입력 매개변수 쌍의 조합을 테스트한다.&lt;/li>
&lt;li>N-방향 테스팅(N-way Testing): 페어와이즈를 확장하여 3개 이상의 매개변수 조합을 고려한다.&lt;/li>
&lt;li>직교 배열 테스팅(Orthogonal Array Testing): 수학적 직교 배열을 사용하여 효율적인 테스트 조합을 생성한다.&lt;/li>
&lt;li>올페어 알고리즘(AllPairs Algorithm): 각 변수 쌍에 대한 모든 값 조합을 효율적으로 테스트한다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>테스트 케이스 수 감소: 효율적인 조합으로 필요한 테스트 케이스 수를 줄인다.&lt;/li>
&lt;li>높은 결함 검출률: 다양한 입력 조합을 테스트하여 더 많은 결함을 발견할 수 있다.&lt;/li>
&lt;li>시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다.&lt;/li>
&lt;li>조기 결함 발견: 개발 초기 단계에서 결함을 식별할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>한계점&lt;span class="hx-absolute -hx-mt-20" id="한계점">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다.&lt;/li>
&lt;li>모든 결함 검출 불가능: 특정 시퀀스나 의존성이 필요한 결함은 놓칠 수 있다.&lt;/li>
&lt;li>정확한 입력 데이터 필요: 효과적인 테스트를 위해서는 정확하고 완전한 입력 데이터가 필요하다.&lt;/li>
&lt;/ol>
&lt;h3>조합 테스트를 더욱 효과적으로 수행하기 위한 팁&lt;span class="hx-absolute -hx-mt-20" id="조합-테스트를-더욱-효과적으로-수행하기-위한-팁">&lt;/span>
&lt;a href="#%ec%a1%b0%ed%95%a9-%ed%85%8c%ec%8a%a4%ed%8a%b8%eb%a5%bc-%eb%8d%94%ec%9a%b1-%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9c%bc%eb%a1%9c-%ec%88%98%ed%96%89%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-%ed%8c%81" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>우선순위 설정:&lt;br>
모든 조합을 테스트할 수 없다면, 중요도나 위험도를 기준으로 우선순위를 정한다.&lt;br>
예를 들어, 사용자가 가장 많이 사용하는 조합이나 문제가 발생했을 때 영향이 큰 조합을 먼저 테스트한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>테스트 자동화:&lt;br>
조합 테스트는 많은 테스트 케이스를 다루기 때문에, 가능한 한 자동화하는 것이 좋다.&lt;br>
이를 통해 테스트 실행 시간을 단축하고 인적 오류를 줄일 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>결과 분석:&lt;br>
테스트 결과를 체계적으로 분석하여 패턴을 찾는다.&lt;br>
특정 조합에서 문제가 자주 발생한다면, 그 원인을 심층적으로 조사할 필요가 있다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>조합 테스트 설계 기법은 효율적인 테스트 케이스 생성과 높은 결함 검출률을 제공하지만, 다른 테스트 기법들과 함께 사용하여 더 완전한 테스트 전략을 수립하는 것이 중요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>랜덤 테스팅(Random Testing)</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/random-testing/</link><pubDate>Wed, 11 Dec 2024 07:24:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/random-testing/</guid><description>
&lt;h2>랜덤 테스팅 (Random Testing)&lt;span class="hx-absolute -hx-mt-20" id="랜덤-테스팅-random-testing">&lt;/span>
&lt;a href="#%eb%9e%9c%eb%8d%a4-%ed%85%8c%ec%8a%a4%ed%8c%85-random-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>랜덤 테스팅은 테스트 대상 시스템에 임의로 생성된 데이터를 입력하여 프로그램의 동작을 검증하는 기법이다.&lt;br>
이는 통계적 테스팅 또는 몬테카를로 테스팅으로도 알려져 있다.&lt;/p>
&lt;p>실제 예시를 통해 더 자세히 살펴보자.&lt;br>
숫자 정렬 프로그램을 테스트한다고 가정해보자.&lt;br>
전통적인 테스트 방식에서는 미리 정해진 테스트 케이스(예: &lt;code>[1,2,3]&lt;/code> 또는 &lt;code>[3,2,1]&lt;/code>)를 사용할 것.&lt;br>
하지만 랜덤 테스팅에서는 무작위로 생성된 숫자 배열을 사용한다.&lt;br>
이를 통해 개발자가 미처 생각하지 못한 경우의 수를 테스트할 수 있다.&lt;/p>
&lt;p>랜덤 테스팅의 실제 적용 과정을 단계별로 살펴보자:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>입력 도메인 정의&lt;br>
먼저 유효한 입력값의 범위와 특성을 정의한다.&lt;br>
예를 들어, 숫자 정렬 프로그램의 경우:&lt;/p>
&lt;ul>
&lt;li>배열의 길이: 1에서 1000 사이&lt;/li>
&lt;li>각 숫자의 범위: -10000에서 10000 사이&lt;/li>
&lt;li>중복 허용 여부 등을 정의합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>랜덤 데이터 생성기 구현&lt;br>
정의된 도메인 내에서 무작위 입력값을 생성하는 메커니즘을 구현한다.&lt;br>
여기서 중요한 것은 단순한 무작위가 아닌, 정의된 제약조건을 만족하는 데이터를 생성하는 것이다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>테스트 실행 및 결과 검증&lt;br>
생성된 입력값으로 프로그램을 실행하고, 결과가 올바른지 검증한다.&lt;br>
정렬 프로그램의 경우, 결과 배열이 실제로 정렬되어 있는지 확인한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>결과 분석 및 피드백&lt;br>
발견된 오류를 분석하고, 필요한 경우 입력 생성 방식을 조정한다.&lt;br>
특정 유형의 입력에서 문제가 자주 발생한다면, 그러한 입력이 더 자주 생성되도록 조정할 수 있다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>임의성: 입력 데이터가 무작위로 생성되어 예측 불가능한 시나리오를 테스트할 수 있다.&lt;/li>
&lt;li>자동화 가능성: 대량의 테스트 케이스를 자동으로 생성하고 실행할 수 있다.&lt;/li>
&lt;li>설계자 편향 회피: 테스트 설계자의 선입견을 피할 수 있어 예상치 못한 오류를 발견할 가능성이 있다.&lt;/li>
&lt;li>입력 도메인: 테스트 데이터는 사전 정의된 도메인에서 생성되며, 이는 랜덤 테스트의 중요한 측면이다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>예상치 못한 오류 발견: 개발자나 테스터가 예상하지 못한 시나리오를 테스트할 수 있다.&lt;/li>
&lt;li>테스트 케이스 생성 용이: 대량의 테스트 케이스를 쉽고 빠르게 생성할 수 있다.&lt;/li>
&lt;li>반복 실행의 이점: 같은 테스트를 여러 차례 반복 실행하여 새로운 결함 발견 가능성을 높일 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>한계점&lt;span class="hx-absolute -hx-mt-20" id="한계점">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>낮은 결함 발견 확률: 체계적인 테스팅 방법에 비해 오류를 발견할 확률이 상대적으로 낮을 수 있다.&lt;/li>
&lt;li>테스트 결과 예측 어려움: 무작위 입력으로 인해 예상 결과를 정확히 예측하기 어려울 수 있다.&lt;/li>
&lt;li>특정 시나리오 누락: 중요한 특정 시나리오를 테스트하지 못할 가능성이 있다.&lt;/li>
&lt;/ol>
&lt;h3>적용 분야&lt;span class="hx-absolute -hx-mt-20" id="적용-분야">&lt;/span>
&lt;a href="#%ec%a0%81%ec%9a%a9-%eb%b6%84%ec%95%bc" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>랜덤 테스팅은 다양한 분야에서 활용될 수 있다:&lt;/p>
&lt;ol>
&lt;li>트레이딩 시스템: 금융 거래 시스템의 안정성과 성능을 테스트하는 데 사용된다.&lt;/li>
&lt;li>복잡한 알고리즘: 다양한 입력에 대한 알고리즘의 동작을 검증하는 데 유용하다.&lt;/li>
&lt;li>사용자 인터페이스: 예상치 못한 사용자 입력에 대한 시스템의 반응을 테스트한다.&lt;/li>
&lt;/ol>
&lt;h3>Random Testing이 발전된 기법들&lt;span class="hx-absolute -hx-mt-20" id="random-testing이-발전된-기법들">&lt;/span>
&lt;a href="#random-testing%ec%9d%b4-%eb%b0%9c%ec%a0%84%eb%90%9c-%ea%b8%b0%eb%b2%95%eb%93%a4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>퍼징(Fuzzing)&lt;br>
특별히 설계된 랜덤 테스트 기법으로, 프로그램의 취약점을 찾기 위해 의도적으로 비정상적인 입력을 생성한다.&lt;br>
보안 테스팅에서 많이 사용된다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>적응형 랜덤 테스팅&lt;br>
이전 테스트 결과를 바탕으로 다음 테스트 케이스 생성 방식을 조정하는 방법.&lt;br>
문제가 발견된 영역 주변을 더 집중적으로 테스트할 수 있다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>통계적 랜덤 테스팅&lt;br>
실제 사용 패턴의 통계적 분포를 반영하여 테스트 케이스를 생성하는 방법.&lt;br>
이를 통해 더 현실적인 테스트가 가능해진다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item><item><title>페어와이즈 테스팅(Pairwise Testing)</title><link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/pairwise-testing/</link><pubDate>Wed, 11 Dec 2024 07:06:00 +0000</pubDate><guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/pairwise-testing/</guid><description>
&lt;h2>페어와이즈 테스팅(Pairwise Testing)&lt;span class="hx-absolute -hx-mt-20" id="페어와이즈-테스팅pairwise-testing">&lt;/span>
&lt;a href="#%ed%8e%98%ec%96%b4%ec%99%80%ec%9d%b4%ec%a6%88-%ed%85%8c%ec%8a%a4%ed%8c%85pairwise-testing" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>페어와이즈 테스팅은 모든 가능한 입력 값 조합을 테스트하는 대신, 입력 매개변수의 모든 쌍(pair)을 최소한 한 번씩 테스트하는 기법이다.&lt;br>
이는 대부분의 결함이 두 입력 값의 상호작용에 기인한다는 관찰에 기반한다.&lt;/p>
&lt;p>실제 예시를 통해 더 자세히 살펴보자.&lt;br>
웹 브라우저 애플리케이션을 테스트한다고 가정하면:&lt;/p>
&lt;p>운영체제: Windows, Mac, Linux&lt;br>
브라우저: Chrome, Firefox, Safari&lt;br>
화면 해상도: HD, FHD, 4K&lt;br>
언어 설정: 한국어, 영어, 일본어&lt;/p>
&lt;p>만약 모든 가능한 조합을 테스트하려면 몇 개의 테스트 케이스가 필요할까?&lt;br>
3(운영체제) × 3(브라우저) × 3(해상도) × 3(언어) = 81개의 테스트 케이스가 필요하다.&lt;/p>
&lt;p>하지만 연구에 따르면, 소프트웨어 결함의 대부분은 두 개 매개변수 간의 상호작용에서 발생한다고 한다.&lt;br>
이러한 통계적 사실을 바탕으로, 페어와이즈 테스팅은 테스트 케이스의 수를 크게 줄이면서도 효과적으로 결함을 발견할 수 있다.&lt;/p>
&lt;p>페어와이즈 테스팅의 실제 적용 과정을 단계별로 살펴보자:&lt;/p>
&lt;ol>
&lt;li>매개변수와 값 식별&lt;br>
먼저 테스트할 매개변수들과 각각이 가질 수 있는 값들을 정의한다.&lt;br>
위의 예시에서는 4개의 매개변수(운영체제, 브라우저, 해상도, 언어)와 각각의 값들을 식별하였다.&lt;/li>
&lt;li>페어와이즈 조합 생성&lt;br>
각 매개변수 쌍에 대해 가능한 모든 조합을 생성한다.&lt;br>
예를 들어:&lt;br>
운영체제와 브라우저의 조합: Windows-Chrome, Windows-Firefox, Windows-Safari, Mac-Chrome, Mac-Firefox, Mac-Safari, Linux-Chrome, Linux-Firefox, Linux-Safari&lt;br>
이런 식으로 모든 매개변수 쌍에 대해 조합을 만든다.&lt;/li>
&lt;li>최적화된 테스트 케이스 생성&lt;br>
이렇게 만든 조합들을 최소한의 테스트 케이스로 커버할 수 있도록 최적화한다.&lt;br>
이 과정은 복잡하므로 보통 자동화 도구를 사용한다.&lt;br>
결과적으로 81개가 아닌 약 9-12개 정도의 테스트 케이스로 모든 페어와이즈 조합을 테스트할 수 있게 된다.&lt;/li>
&lt;li>테스트 실행 및 결과 분석&lt;br>
생성된 테스트 케이스들을 실행하고 결과를 분석한다.&lt;br>
특히 특정 매개변수 쌍의 조합에서 자주 발생하는 문제가 있는지 주목한다.&lt;/li>
&lt;/ol>
&lt;h3>주요 특징&lt;span class="hx-absolute -hx-mt-20" id="주요-특징">&lt;/span>
&lt;a href="#%ec%a3%bc%ec%9a%94-%ed%8a%b9%ec%a7%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>효율성: 모든 조합을 테스트하는 것보다 훨씬 적은 수의 테스트 케이스로 높은 커버리지를 달성한다.&lt;/li>
&lt;li>체계적 접근: 입력 매개변수의 모든 쌍을 고려하여 테스트 케이스를 설계한다.&lt;/li>
&lt;li>자동화 가능: PICT, ACTS 등의 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>적용 방법&lt;span class="hx-absolute -hx-mt-20" id="적용-방법">&lt;/span>
&lt;a href="#%ec%a0%81%ec%9a%a9-%eb%b0%a9%eb%b2%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>테스트할 매개변수와 각 매개변수의 가능한 값을 식별한다.&lt;/li>
&lt;li>모든 가능한 매개변수 쌍의 조합을 생성한다.&lt;/li>
&lt;li>각 쌍이 최소한 한 번씩 테스트되도록 테스트 케이스를 설계한다.&lt;/li>
&lt;/ol>
&lt;h3>장점&lt;span class="hx-absolute -hx-mt-20" id="장점">&lt;/span>
&lt;a href="#%ec%9e%a5%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>테스트 케이스 수 감소: 모든 조합을 테스트하는 것보다 훨씬 적은 수의 테스트로 높은 커버리지를 달성한다.&lt;/li>
&lt;li>효율적인 결함 검출: 대부분의 결함을 효과적으로 찾아낼 수 있다.&lt;/li>
&lt;li>시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다.&lt;/li>
&lt;/ol>
&lt;h3>한계점&lt;span class="hx-absolute -hx-mt-20" id="한계점">&lt;/span>
&lt;a href="#%ed%95%9c%ea%b3%84%ec%a0%90" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;ol>
&lt;li>모든 결함 검출 불가능: 세 개 이상의 매개변수 상호작용으로 인한 결함은 놓칠 수 있다.&lt;/li>
&lt;li>복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다.&lt;/li>
&lt;/ol>
&lt;h3>도구&lt;span class="hx-absolute -hx-mt-20" id="도구">&lt;/span>
&lt;a href="#%eb%8f%84%ea%b5%ac" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>페어와이즈 테스팅을 지원하는 다양한 도구가 있다:&lt;/p>
&lt;ol>
&lt;li>PICT (Pairwise Independent Combinatorial Testing): Microsoft에서 제공하는 무료 커맨드라인 도구.&lt;/li>
&lt;li>ACTS (Automated Combinatorial Testing for Software): NIST에서 제공하는 Java 기반 도구.&lt;/li>
&lt;li>AllPairs: Python으로 작성된 오픈 소스 도구.&lt;/li>
&lt;/ol>
&lt;p>페어와이즈 테스팅은 효율적인 테스트 케이스 생성과 높은 결함 검출률을 제공하지만, 다른 테스트 기법들과 함께 사용하여 더 완전한 테스트 전략을 수립하는 것이 중요하다.&lt;/p>
&lt;hr>
&lt;h2>참고 및 출처&lt;span class="hx-absolute -hx-mt-20" id="참고-및-출처">&lt;/span>
&lt;a href="#%ec%b0%b8%ea%b3%a0-%eb%b0%8f-%ec%b6%9c%ec%b2%98" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2></description></item></channel></rss>