<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Abstract Factory Pattern</h2></header><div class=entry-content><p>Abstract Factory Pattern 구체적인 클래스를 지정하지 않고도 관련된 객체들의 집합을 생성할 수 있게 해주는 생성 패턴
특징 제품군의 생성을 캡슐화합니다 관련된 객체들이 함께 동작하도록 보장합니다 구체적인 클래스에 의존하지 않고 인터페이스에 의존합니다 제품군을 쉽게 교체할 수 있습니다 사용사례 여러 제품군 중 하나를 선택해 시스템을 설정해야 할 때 관련된 객체들이 함께 사용되어야 할 때 제품에 대한 클래스 라이브러리를 제공하고 구현이 아닌 인터페이스만 노출하고 싶을 때 실제 예:
크로스 플랫폼 UI 컴포넌트 생성 다양한 데이터베이스 시스템 지원 여러 운영체제에 대한 서비스 구현 다양한 게임 캐릭터와 아이템 생성 문서 포맷 변환 시스템 장점 제품군의 일관성 보장 구체적인 클래스와의 결합도 감소 제품군 교체가 용이 새로운 제품 추가가 용이 단점 코드가 복잡해질 수 있음 새로운 종류의 제품을 추가하기 어려움 불필요한 추상화로 인한 오버헤드 가능성 주의사항 및 고려사항 확장성 고려 새로운 제품군 추가를 고려한 설계 인터페이스 설계 시 신중한 고려 복잡성 관리 적절한 추상화 수준 유지 명확한 책임 분리 성능 최적화 객체 생성 비용 고려 캐싱 전략 검토 테스트 용이성 목 객체 생성 방법 고려 테스트 시나리오 설계 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 from abc import ABC, abstractmethod # 추상 제품 클래스들 class Button(ABC): @abstractmethod def render(self): pass @abstractmethod def handle_click(self): pass class Checkbox(ABC): @abstractmethod def render(self): pass @abstractmethod def toggle(self): pass # 구체적인 제품 클래스들 - Light Theme class LightButton(Button): def render(self): return "밝은 테마 버튼을 렌더링합니다" def handle_click(self): return "밝은 테마 버튼 클릭을 처리합니다" class LightCheckbox(Checkbox): def render(self): return "밝은 테마 체크박스를 렌더링합니다" def toggle(self): return "밝은 테마 체크박스 상태를 토글합니다" # 구체적인 제품 클래스들 - Dark Theme class DarkButton(Button): def render(self): return "어두운 테마 버튼을 렌더링합니다" def handle_click(self): return "어두운 테마 버튼 클릭을 처리합니다" class DarkCheckbox(Checkbox): def render(self): return "어두운 테마 체크박스를 렌더링합니다" def toggle(self): return "어두운 테마 체크박스 상태를 토글합니다" # 추상 팩토리 class UIFactory(ABC): @abstractmethod def create_button(self) -> Button: pass @abstractmethod def create_checkbox(self) -> Checkbox: pass # 구체적인 팩토리들 class LightThemeFactory(UIFactory): def create_button(self) -> Button: return LightButton() def create_checkbox(self) -> Checkbox: return LightCheckbox() class DarkThemeFactory(UIFactory): def create_button(self) -> Button: return DarkButton() def create_checkbox(self) -> Checkbox: return DarkCheckbox() # 클라이언트 코드 class Application: def __init__(self, factory: UIFactory): self.factory = factory self.button = None self.checkbox = None def create_ui(self): self.button = self.factory.create_button() self.checkbox = self.factory.create_checkbox() def paint(self): print(self.button.render()) print(self.checkbox.render()) # 사용 예시 if __name__ == "__main__": # 밝은 테마 사용 print("밝은 테마 적용:") app = Application(LightThemeFactory()) app.create_ui() app.paint() print("\n어두운 테마 적용:") # 어두운 테마로 전환 app = Application(DarkThemeFactory()) app.create_ui() app.paint() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // 추상 제품 클래스들 class Vehicle { constructor() { if (this.constructor === Vehicle) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getSpecifications() { throw new Error("추상 메서드는 구현해야 합니다."); } } class Engine { constructor() { if (this.constructor === Engine) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getDetails() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 제품 클래스들 - 스포츠카 class SportsCar extends Vehicle { getSpecifications() { return "스포츠카: 고성능, 2인승"; } } class SportsEngine extends Engine { getDetails() { return "스포츠카 엔진: V8, 500hp"; } } // 구체적인 제품 클래스들 - SUV class SUV extends Vehicle { getSpecifications() { return "SUV: 실용성, 7인승"; } } class SUVEngine extends Engine { getDetails() { return "SUV 엔진: V6, 280hp"; } } // 추상 팩토리 class VehicleFactory { createVehicle() { throw new Error("추상 메서드는 구현해야 합니다."); } createEngine() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 팩토리들 class SportsCarFactory extends VehicleFactory { createVehicle() { return new SportsCar(); } createEngine() { return new SportsEngine(); } } class SUVFactory extends VehicleFactory { createVehicle() { return new SUV(); } createEngine() { return new SUVEngine(); } } // 클라이언트 코드 class CarDealer { constructor(factory) { this.factory = factory; } orderCar() { const vehicle = this.factory.createVehicle(); const engine = this.factory.createEngine(); console.log("새로운 차량 주문:"); console.log(vehicle.getSpecifications()); console.log(engine.getDetails()); } } // 사용 예시 function main() { console.log("스포츠카 주문:"); const sportsCarDealer = new CarDealer(new SportsCarFactory()); sportsCarDealer.orderCar(); console.log("\nSUV 주문:"); const suvDealer = new CarDealer(new SUVFactory()); suvDealer.orderCar(); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;849 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract Factory Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/abstract-factory-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Builder Pattern</h2></header><div class=entry-content><p>Builder Pattern 복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 생성 패턴
예를 들어, 자동차를 조립하는 과정을 생각해보면, 동일한 조립 과정을 통해 스포츠카나 SUV와 같은 다른 종류의 자동차를 만들 수 있다.
특징 복잡한 객체의 생성 과정을 단계별로 나눕니다. 생성 과정은 동일하지만 다양한 구성과 표현이 가능합니다. 객체의 생성과 조립을 분리합니다. 필수 값과 선택적 값을 구분하여 관리할 수 있습니다. 메서드 체이닝 (Method Chaining) 메서드 체이닝을 통해 직관적으로 객체를 구성할 수 있다.
객체의 메서드를 연속적으로 호출하는 프로그래밍 기법
...</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1712 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Builder Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/builder-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Prototype Pattern</h2></header><div class=entry-content><p>Prototype Pattern 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴
특징 객체 생성 비용이 높거나 복잡한 경우에 유용합니다. 원본 객체의 정확한 복사본을 제공합니다. 클라이언트가 객체의 타입을 미리 알 수 없는 경우에 사용됩니다. 사용사례 데이터베이스에서 가져온 큰 객체를 여러 번 사용해야 할 때 GUI 애플리케이션에서 복사-붙여넣기 기능을 구현할 때 게임에서 비슷한 특성을 가진 캐릭터나 아이템을 생성할 때 설정이나 구성 객체를 약간씩 다르게 여러 개 만들어야 할 때 장점 복잡한 객체를 처음부터 생성하는 비용을 절약할 수 있습니다 런타임에 동적으로 객체를 추가하거나 삭제할 수 있습니다 새로운 객체를 만들 때 상속 대신 복제를 사용하여 유연성을 높일 수 있습니다 단점 순환 참조가 있는 복잡한 객체의 경우 복제가 어려울 수 있습니다 깊은 복사(Deep Copy)를 구현할 때 모든 중첩된 객체들도 복제 가능해야 합니다 주의사항 및 고려사항 깊은 복사와 얕은 복사를 구분하여 사용해야 합니다. 객체가 다른 객체를 참조하는 경우, 깊은 복사를 사용하지 않으면 예상치 못한 부작용이 발생할 수 있습니다. 복제 과정에서 생성자가 호출되지 않음을 주의해야 합니다. 필요한 경우 초기화 로직을 별도의 메서드로 분리하여 복제 후 호출해야 합니다. 프로토타입 등록과 관리를 위한 레지스트리나 팩토리 클래스를 만들어 중앙에서 관리하는 것이 좋습니다. 복제된 객체의 식별자나 유니크한 속성들은 복제 후에 새로운 값으로 설정해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from copy import deepcopy from typing import Dict, Any class Character: def __init__(self, name: str, level: int, stats: Dict[str, int]): self.name = name self.level = level self.stats = stats def clone(self) -> 'Character': """Create a deep copy of the character""" return deepcopy(self) def __str__(self) -> str: return f"Character(name={self.name}, level={self.level}, stats={self.stats})" class CharacterPrototype: """Prototype manager class that stores and creates character templates""" def __init__(self): self._characters: Dict[str, Character] = {} def register_character(self, name: str, character: Character): """Register a character template""" self._characters[name] = character def unregister_character(self, name: str): """Remove a character template""" del self._characters[name] def clone(self, name: str, **kwargs: Any) -> Character: """Clone a character and optionally modify its attributes""" prototype = self._characters.get(name) if not prototype: raise ValueError(f"Character prototype '{name}' not found") character = prototype.clone() # Update any attributes specified in kwargs for key, value in kwargs.items(): if hasattr(character, key): setattr(character, key, value) return character # Usage example if __name__ == "__main__": # Create prototype manager prototype_manager = CharacterPrototype() # Register base warrior template warrior = Character( name="Warrior", level=1, stats={"strength": 15, "agility": 10, "intelligence": 5} ) prototype_manager.register_character("warrior", warrior) # Clone warriors with different names and levels warrior1 = prototype_manager.clone("warrior", name="Bob", level=5) warrior2 = prototype_manager.clone("warrior", name="Alice", level=7) print(warrior1) # Character(name=Bob, level=5, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) print(warrior2) # Character(name=Alice, level=7, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class DocumentTemplate { constructor(type, content, metadata) { this.type = type; this.content = content; this.metadata = metadata; } clone() { // Deep clone the object const clonedMetadata = JSON.parse(JSON.stringify(this.metadata)); return new DocumentTemplate(this.type, this.content, clonedMetadata); } customize(updates) { Object.assign(this, updates); return this; } } class DocumentPrototypeRegistry { constructor() { this.prototypes = new Map(); } registerTemplate(name, template) { this.prototypes.set(name, template); } unregisterTemplate(name) { this.prototypes.delete(name); } createDocument(templateName, customization = {}) { const template = this.prototypes.get(templateName); if (!template) { throw new Error(`Template '${templateName}' not found`); } return template.clone().customize(customization); } } // Usage example const registry = new DocumentPrototypeRegistry(); // Register some document templates const letterTemplate = new DocumentTemplate( 'letter', 'Dear {recipient},\n\n{body}\n\nBest regards,\n{sender}', { created: new Date(), version: '1.0', style: 'formal' } ); registry.registerTemplate('business_letter', letterTemplate); // Create customized documents from template const myLetter1 = registry.createDocument('business_letter', { content: 'Dear John,\n\nThank you for your inquiry.\n\nBest regards,\nJane' }); const myLetter2 = registry.createDocument('business_letter', { content: 'Dear Mary,\n\nPlease find attached our proposal.\n\nBest regards,\nBob', metadata: { version: '1.1', style: 'semiformal' } }); console.log(myLetter1); console.log(myLetter2); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;699 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prototype Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Interpreter Pattern</h2></header><div class=entry-content><p>Interpreter Pattern Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.
이 패턴은 주로 간단한 언어나 표현식을 해석해야 할 때 사용된다.
Interpreter 패턴은 SQL 파서, 정규 표현식 엔진, 프로그래밍 언어 인터프리터 등 다양한 분야에서 활용된다. 하지만 복잡한 문법을 다룰 때는 파서 생성기 등 다른 도구를 고려하는 것이 좋다.
Interpreter 패턴의 주요 특징 문법 표현: 언어의 문법을 클래스 구조로 표현한다. 해석 메커니즘: 각 문법 규칙에 대한 해석 방법을 제공한다. 추상 구문 트리: 표현식을 계층적 구조로 표현한다. Interpreter 패턴의 구성 요소 AbstractExpression: 모든 표현식 클래스가 구현해야 하는 인터페이스를 정의한다. TerminalExpression: 더 이상 분해할 수 없는 기본 표현식을 나타낸다. NonterminalExpression: 다른 표현식을 포함하는 복합 표현식을 나타낸다. Context: 해석기가 해석해야 할 정보를 포함한다. Client: 추상 구문 트리를 구성하고 해석을 요청한다. Interpreter 패턴의 장점 문법 확장성: 새로운 표현식을 쉽게 추가할 수 있다. 문법 구현 용이성: 각 문법 규칙을 클래스로 표현하여 구현이 간단하다. 복잡한 문제 분해: 복잡한 문제를 작은 단위로 분해하여 해결할 수 있다. Interpreter 패턴의 단점 복잡한 문법에 부적합: 문법이 복잡해질수록 클래스 계층 구조가 복잡해진다. 성능 문제: 대규모 문법 해석 시 성능이 저하될 수 있다. Interpreter 패턴 사용 예시 아래는 인터프리터 패턴을 활용하여 후위 표기법(Postfix Notation)을 해석하고 계산하는 예제이다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:27:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;632 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interpreter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/interpreter-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Visitor Pattern</h2></header><div class=entry-content><p>Visitor Pattern Visitor Pattern은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.
이 패턴의 주요 목적은 기존 객체 구조를 변경하지 않고 새로운 동작을 추가할 수 있게 하는 것이다.
Visitor Pattern의 주요 구성 요소 Visitor (방문자) 인터페이스:
객체 구조의 각 ConcreteElement에 대한 visit() 메서드를 선언한다. ConcreteVisitor (구체적인 방문자):
Visitor 인터페이스를 구현하여 각 ConcreteElement에 대한 구체적인 동작을 정의한다. Element (요소) 인터페이스:
accept(Visitor) 메서드를 선언하여 Visitor 객체를 받아들인다. ConcreteElement (구체적인 요소):
Element 인터페이스를 구현하고, accept() 메서드에서 visitor.visit(this)를 호출한다. ObjectStructure (객체 구조):
...</p></div><footer class=entry-footer><span title='2024-09-24 08:27:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;582 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Visitor Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/visitor-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Chain of Responsibility</h2></header><div class=entry-content><p>Chain of Responsibility Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.
Chain of Responsibility 패턴은 여러 객체를 체인으로 연결하여 요청을 순차적으로 처리하는 방식이다.
각 객체는 요청을 처리할 수 있으면 처리하고, 그렇지 않으면 다음 객체로 요청을 전달한다.
주요 특징:
요청의 발신자와 수신자를 분리한다. 여러 객체가 요청을 처리할 기회를 가진다. 요청 처리 객체를 동적으로 변경할 수 있다. 구성 요소 Handler (추상 처리자):
요청을 처리하는 인터페이스를 정의한다. 다음 처리자에 대한 참조를 가진다. ConcreteHandler (구체적 처리자):
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;536 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Chain of Responsibility" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/chain-of-responsibility/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern</h2></header><div class=entry-content><p>Mediator Pattern Mediator Pattern(중재자 패턴)은 소프트웨어 디자인 패턴 중 하나로, 객체 간의 상호작용을 캡슐화하여 서로 직접 통신하지 않고 중재자 객체를 통해서만 소통하도록 설계된 행동 패턴이다.
이 패턴은 객체 간의 복잡한 의존성을 줄이고, 시스템의 유연성과 재사용성을 향상시키는 데 도움을 준다.
주요 개념 Mediator (중재자):
객체 간의 상호작용을 조정하는 역할을 하며, 서로 다른 객체들이 직접 통신하는 대신 중재자를 통해 소통하게 한다. Mediator는 Colleague 객체들의 통신을 관리하고 조정한다. Colleague (동료):
Mediator와 상호작용하는 객체들로, 각 동료 객체는 Mediator를 통해 다른 동료와 통신한다. Colleague 객체는 Mediator에 대한 참조를 가지고 있어야 한다. ConcreteMediator (구체적인 중재자):
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;807 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/mediator-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Memento Pattern</h2></header><div class=entry-content><p>Memento Pattern Memento Pattern은 행위 디자인 패턴 중 하나로, 객체의 상태를 저장하고 이전 상태로 복원할 수 있게 해주는 패턴이다.
메멘토 패턴(Memento Pattern)은 소프트웨어 디자인 패턴 중 하나로, 객체의 상태를 저장하고 나중에 복원할 수 있는 메커니즘을 제공한다.
이 패턴의 주요 목적은 객체의 내부 상태를 캡슐화하면서도 외부에서 해당 상태를 저장하고 복원할 수 있게 하는 것이다.
메멘토 패턴은 객체의 상태 관리와 복원이 중요한 애플리케이션에서 매우 유용한 디자인 패턴이다.
이 패턴을 적절히 활용하면 코드의 유연성과 유지보수성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;518 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memento Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/memento-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Command Pattern</h2></header><div class=entry-content><p>Command Pattern 요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴
요청을 하는 객체와 그 요청을 수행하는 객체를 분리한다.
이를 통해 요청을 큐에 저장하거나, 로그를 남기거나, 작업을 취소하는 등의 부가적인 기능을 쉽게 추가할 수 있다.
특징 요청을 객체로 캡슐화하여 매개변수화한다. 요청 발신자와 수신자를 분리합니다. 주요 구성요소 Command: 실행될 작업을 캡슐화하는 인터페이스 ConcreteCommand: Command 인터페이스를 구현하여 특정 작업을 수행하는 클래스 Invoker: Command 객체를 실행하는 클래스 Receiver: 실제 작업을 수행하는 클래스 Client: Command 객체를 생성하고 Invoker에게 전달하는 클래스 사용사례 GUI 버튼 및 메뉴 항목의 액션 구현 트랜잭션 시스템에서의 작업 큐 관리 매크로 기록 및 실행 기능 구현 장점 느슨한 결합: 명령을 실행하는 객체와 실제 작업을 수행하는 객체가 분리되어 있어, 시스템의 유연성이 향상된다. 확장성: 새로운 Command 클래스를 추가하는 것만으로 새로운 기능을 쉽게 추가할 수 있다. 작업 취소/재실행: Command 객체가 이전 상태를 저장할 수 있어, Undo/Redo 기능을 쉽게 구현할 수 있다. 작업 큐잉과 로깅: Command 객체를 저장하고 나중에 실행하거나, 실행 이력을 보관할 수 있다. 단점 클래스 증가: 각 명령마다 별도의 클래스가 필요하므로, 클래스의 수가 증가할 수 있다. 복잡성: 간단한 작업의 경우에도 Command 객체를 생성해야 하므로, 불필요한 복잡성이 추가될 수 있다. 메모리 사용: 작업 이력을 저장할 경우 메모리 사용량이 증가할 수 있다. 주의사항 및 고려사항 Command 인터페이스 설계: Command 인터페이스는 가능한 한 단순하게 유지하되, 필요한 모든 작업을 수행할 수 있어야 합니다. 일반적으로 execute()와 undo() 메서드를 포함한다. 상태 관리: Undo/Redo 기능을 구현할 경우, Command 객체는 이전 상태를 적절히 저장하고 복원할 수 있어야 한다. 복합 Command: 여러 Command를 그룹화하여 하나의 Command처럼 실행할 수 있는 MacroCommand를 구현할 수 있다. 예외 처리: Command 실행 중 발생할 수 있는 예외 상황을 적절히 처리해야 한다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 from abc import ABC, abstractmethod from typing import List import time # Receiver 클래스들 class Light: def __init__(self, location: str): self.location = location self.is_on = False self.brightness = 0 def turn_on(self) -> None: self.is_on = True print(f"{self.location} light is now on") def turn_off(self) -> None: self.is_on = False print(f"{self.location} light is now off") def dim(self, level: int) -> None: self.brightness = level print(f"{self.location} light dimmed to {level}%") class Thermostat: def __init__(self, location: str): self.location = location self.temperature = 20 def set_temperature(self, temperature: float) -> None: self.temperature = temperature print(f"{self.location} thermostat set to {temperature}°C") # Command 인터페이스 class Command(ABC): @abstractmethod def execute(self) -> None: pass @abstractmethod def undo(self) -> None: pass # Concrete Command 클래스들 class LightOnCommand(Command): def __init__(self, light: Light): self.light = light self._prev_state = None def execute(self) -> None: self._prev_state = self.light.is_on self.light.turn_on() def undo(self) -> None: if self._prev_state is False: self.light.turn_off() class LightDimCommand(Command): def __init__(self, light: Light, level: int): self.light = light self.level = level self._prev_level = None def execute(self) -> None: self._prev_level = self.light.brightness self.light.dim(self.level) def undo(self) -> None: if self._prev_level is not None: self.light.dim(self._prev_level) class SetThermostatCommand(Command): def __init__(self, thermostat: Thermostat, temperature: float): self.thermostat = thermostat self.temperature = temperature self._prev_temperature = None def execute(self) -> None: self._prev_temperature = self.thermostat.temperature self.thermostat.set_temperature(self.temperature) def undo(self) -> None: if self._prev_temperature is not None: self.thermostat.set_temperature(self._prev_temperature) # Invoker 클래스 class SmartHomeController: def __init__(self): self._command_history: List[Command] = [] self._current_command = None def execute_command(self, command: Command) -> None: self._current_command = command command.execute() self._command_history.append(command) def undo_last_command(self) -> None: if self._command_history: command = self._command_history.pop() command.undo() # 클라이언트 코드 def main(): # Receiver 객체들 생성 living_room_light = Light("Living Room") bedroom_light = Light("Bedroom") living_room_thermostat = Thermostat("Living Room") # Command 객체들 생성 light_on = LightOnCommand(living_room_light) bedroom_light_dim = LightDimCommand(bedroom_light, 50) set_temp = SetThermostatCommand(living_room_thermostat, 22.5) # Invoker 생성 및 커맨드 실행 controller = SmartHomeController() print("=== Executing commands ===") controller.execute_command(light_on) time.sleep(1) # 실행 간격을 위한 지연 controller.execute_command(bedroom_light_dim) time.sleep(1) controller.execute_command(set_temp) print("\n=== Undoing commands ===") time.sleep(1) controller.undo_last_command() # 온도 설정 취소 time.sleep(1) controller.undo_last_command() # 조명 밝기 조절 취소 time.sleep(1) controller.undo_last_command() # 조명 켜기 취소 if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // Receiver 클래스들 class Light { constructor(location) { this.location = location; this.isOn = false; this.brightness = 0; } turnOn() { this.isOn = true; console.log(`${this.location} light is now on`); } turnOff() { this.isOn = false; console.log(`${this.location} light is now off`); } dim(level) { this.brightness = level; console.log(`${this.location} light dimmed to ${level}%`); } } class Thermostat { constructor(location) { this.location = location; this.temperature = 20; } setTemperature(temperature) { this.temperature = temperature; console.log(`${this.location} thermostat set to ${temperature}°C`); } } // Command 인터페이스 class Command { execute() { throw new Error('execute method must be implemented'); } undo() { throw new Error('undo method must be implemented'); } } // Concrete Command 클래스들 class LightOnCommand extends Command { constructor(light) { super(); this.light = light; this._prevState = null; } execute() { this._prevState = this.light.isOn; this.light.turnOn(); } undo() { if (this._prevState === false) { this.light.turnOff(); } } } class LightDimCommand extends Command { constructor(light, level) { super(); this.light = light; this.level = level; this._prevLevel = null; } execute() { this._prevLevel = this.light.brightness; this.light.dim(this.level); } undo() { if (this._prevLevel !== null) { this.light.dim(this._prevLevel); } } } class SetThermostatCommand extends Command { constructor(thermostat, temperature) { super(); this.thermostat = thermostat; this.temperature = temperature; this._prevTemperature = null; } execute() { this._prevTemperature = this.thermostat.temperature; this.thermostat.setTemperature(this.temperature); } undo() { if (this._prevTemperature !== null) { this.thermostat.setTemperature(this._prevTemperature); } } } // Invoker 클래스 class SmartHomeController { constructor() { this._commandHistory = []; this._currentCommand = null; } executeCommand(command) { this._currentCommand = command; command.execute(); this._commandHistory.push(command); } undoLastCommand() { if (this._commandHistory.length > 0) { const command = this._commandHistory.pop(); command.undo(); } } } // 클라이언트 코드 async function main() { // Receiver 객체들 생성 const livingRoomLight = new Light("Living Room"); const bedroomLight = new Light("Bedroom"); const livingRoomThermostat = new Thermostat("Living Room"); // Command 객체들 생성 const lightOn = new LightOnCommand(livingRoomLight); const bedroomLightDim = new LightDimCommand(bedroomLight, 50); const setTemp = new SetThermostatCommand(livingRoomThermostat, 22.5); // Invoker 생성 및 커맨드 실행 const controller = new SmartHomeController(); console.log("=== Executing commands ==="); controller.executeCommand(lightOn); await new Promise(resolve => setTimeout(resolve, 1000)); // 실행 간격을 위한 지연 controller.executeCommand(bedroomLightDim); await new Promise(resolve => setTimeout(resolve, 1000)); controller.executeCommand(setTemp); console.log("\n=== Undoing commands ==="); await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 온도 설정 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 밝기 조절 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 켜기 취소 } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1265 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Command Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/command-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>State Pattern</h2></header><div class=entry-content><p>State Pattern 객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴
상태별 동작을 별도의 클래스로 분리하고, 현재 상태를 나타내는 객체에게 행동을 위임하는 것
특징 객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다. 상태 전이를 명시적으로 표현합니다. 각 상태를 별도의 클래스로 캡슐화합니다. 유한 상태 기계(Finite-State Machine)의 개념과 유사합니다. 사용사례 문서 처리 시스템: 문서가 초안, 검토 중, 승인됨, 게시됨 등의 상태를 가지며 각 상태에서 허용되는 작업이 다릅니다. 주문 처리 시스템: 주문이 생성됨, 결제 완료, 배송 중, 배송 완료 등의 상태를 거치며, 각 상태에서 가능한 작업이 달라집니다. 게임 캐릭터: 캐릭터가 서있음, 걷기, 달리기, 점프 등 다양한 상태를 가지며, 각 상태에서의 동작이 다릅니다. 네트워크 연결: 연결 중, 연결됨, 연결 끊김 등의 상태에 따라 다른 동작을 수행합니다. 장점 상태별 동작의 명확한 분리: 각 상태의 동작이 별도의 클래스로 캡슐화되어 코드의 구조가 명확해집니다. 상태 전환 로직의 체계화: 상태 전환이 명시적으로 이루어지며, 각 상태 클래스에서 가능한 전환을 정의할 수 있습니다. 새로운 상태 추가의 용이성: 기존 코드를 수정하지 않고도 새로운 상태를 추가할 수 있어 개방-폐쇄 원칙을 만족합니다. 단점 클래스 수의 증가: 각 상태마다 새로운 클래스가 필요하므로 클래스 수가 많아질 수 있습니다. 상태 전환 로직의 복잡성: 상태 간의 전환이 복잡할 경우 관리가 어려워질 수 있습니다. Context와 State 간의 결합: State 클래스들이 Context를 참조해야 하는 경우가 있어 결합도가 높아질 수 있습니다. 주의사항 및 고려사항 상태 전환의 일관성: 상태 전환이 일관되게 이루어지도록 주의해야 하며, 잘못된 전환을 방지해야 합니다. 메모리 관리: 상태 객체들을 적절히 재사용하거나 관리하지 않으면 메모리 사용량이 증가할 수 있습니다. 순환 참조 방지: Context와 State 간의 순환 참조가 발생하지 않도록 주의해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from abc import ABC, abstractmethod # State 인터페이스 class MediaPlayerState(ABC): @abstractmethod def play(self, player) -> None: pass @abstractmethod def pause(self, player) -> None: pass @abstractmethod def stop(self, player) -> None: pass @abstractmethod def get_state_name(self) -> str: pass # 구체적인 State 클래스들 class PlayingState(MediaPlayerState): def play(self, player) -> None: print("이미 재생 중입니다.") def pause(self, player) -> None: print("재생을 일시정지합니다.") player.change_state(PausedState()) def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "재생 중" class PausedState(MediaPlayerState): def play(self, player) -> None: print("재생을 재개합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("이미 일시정지 상태입니다.") def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "일시정지" class StoppedState(MediaPlayerState): def play(self, player) -> None: print("재생을 시작합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("중지 상태에서는 일시정지할 수 없습니다.") def stop(self, player) -> None: print("이미 중지 상태입니다.") def get_state_name(self) -> str: return "중지됨" # Context 클래스 class MediaPlayer: def __init__(self): # 초기 상태는 중지 상태 self._state = StoppedState() print(f"미디어 플레이어가 {self._state.get_state_name()} 상태로 시작됩니다.") def change_state(self, state: MediaPlayerState) -> None: self._state = state print(f"상태가 {self._state.get_state_name()}(으)로 변경되었습니다.") def play(self) -> None: self._state.play(self) def pause(self) -> None: self._state.pause(self) def stop(self) -> None: self._state.stop(self) # 사용 예시 def main(): player = MediaPlayer() # 재생 시작 player.play() # 중지 -> 재생 # 일시정지 player.pause() # 재생 -> 일시정지 # 재생 재개 player.play() # 일시정지 -> 재생 # 중지 player.stop() # 재생 -> 중지 # 일시정지 시도 (중지 상태에서는 불가능) player.pause() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // State 인터페이스 interface OrderState { processPayment(order: Order): void; shipOrder(order: Order): void; cancelOrder(order: Order): void; getStateName(): string; } // 구체적인 State 클래스들 class PendingState implements OrderState { processPayment(order: Order): void { console.log("결제를 진행합니다."); order.changeState(new PaidState()); } shipOrder(order: Order): void { console.log("결제가 필요합니다. 배송을 시작할 수 없습니다."); } cancelOrder(order: Order): void { console.log("주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 대기"; } } class PaidState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("배송을 시작합니다."); order.changeState(new ShippedState()); } cancelOrder(order: Order): void { console.log("결제가 환불되었습니다. 주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 완료"; } } class ShippedState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("이미 배송 중입니다."); } cancelOrder(order: Order): void { console.log("배송이 시작된 주문은 취소할 수 없습니다."); } getStateName(): string { return "배송 중"; } } class CancelledState implements OrderState { processPayment(order: Order): void { console.log("취소된 주문은 결제할 수 없습니다."); } shipOrder(order: Order): void { console.log("취소된 주문은 배송할 수 없습니다."); } cancelOrder(order: Order): void { console.log("이미 취소된 주문입니다."); } getStateName(): string { return "주문 취소"; } } // Context 클래스 class Order { private state: OrderState; private readonly orderId: string; constructor(orderId: string) { this.orderId = orderId; this.state = new PendingState(); console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 생성되었습니다.`); } public changeState(state: OrderState): void { this.state = state; console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 변경되었습니다.`); } public processPayment(): void { this.state.processPayment(this); } public shipOrder(): void { this.state.shipOrder(this); } public cancelOrder(): void { this.state.cancelOrder(this); } } // 사용 예시 function main() { const order = new Order("ORD-2024-001"); // 정상적인 주문 프로세스 console.log("\n=== 정상적인 주문 프로세스 ==="); order.processPayment(); // 결제 대기 -> 결제 완료 order.shipOrder(); // 결제 완료 -> 배송 중 // 취소된 주문 시나리오 console.log("\n=== 취소된 주문 시나리오 ==="); const cancelledOrder = new Order("ORD-2024-002"); cancelledOrder.cancelOrder(); // 결제 대기 -> 취소됨 cancelledOrder.processPayment(); // 결제 시도 (실패) cancelledOrder.shipOrder(); // 배송 시도 (실패) } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1040 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/state-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-design-patterns/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/categories/software-design-patterns/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>