<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design Patterns | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/categories/software-design-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/categories/software-design-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/categories/software-design-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/categories/software-design-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design Patterns"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design Patterns"><meta name=twitter:description content="기록하고 기억하고 적용하자."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/categories/>Categories</a></div><h1>Software Design Patterns</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Strategy Pattern</h2></header><div class=entry-content><p>Strategy Pattern 알고리즘의 집합을 정의하고, 각각을 캡슐화하여 교환 가능하게 만드는 행동 디자인 패턴
알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.
특징 알고리즘 집합을 정의하고 각각을 별도의 클래스로 캡슐화합니다. 런타임에 알고리즘을 동적으로 교체할 수 있습니다. 컨텍스트 클래스가 전략 객체에 작업을 위임합니다. 세 가지 주요 구성 요소로 이루어진다.
Context(문맥): 전략을 사용하는 클래스로, 클라이언트가 전략을 지정할 수 있는 인터페이스를 제공합니다. Strategy(전략): 지원하는 모든 알고리즘에 대한 공통 인터페이스를 정의합니다. Concrete Strategies(구체적 전략): Strategy 인터페이스의 구체적인 구현체들입니다. 사용사례 결제 시스템: 신용카드, 페이팔, 은행 이체 등 다양한 결제 방식을 처리할 때 각각을 전략으로 구현합니다. 데이터 압축: 다양한 압축 알고리즘(ZIP, RAR, 7Z 등)을 전략으로 구현하여 상황에 따라 적절한 압축 방식을 선택합니다. 텍스트 포매팅: 마크다운, HTML, 일반 텍스트 등 다양한 출력 형식을 전략으로 구현합니다. 정렬 알고리즘: 퀵정렬, 병합정렬, 버블정렬 등 다양한 정렬 알고리즘을 상황에 따라 선택적으로 사용합니다. 장점 알고리즘의 재사용성: 동일한 알고리즘을 다양한 컨텍스트에서 재사용할 수 있습니다. 런타임 시 알고리즘 교체: 프로그램 실행 중에도 알고리즘을 동적으로 변경할 수 있습니다. 코드 중복 감소: 유사한 알고리즘들의 공통 부분을 하나의 클래스로 관리할 수 있습니다. 확장성: 새로운 전략을 추가하기 쉽습니다. 단점 클래스 수 증가: 각 전략마다 새로운 클래스가 필요하므로 클래스 수가 증가합니다. 클라이언트의 전략 인지: 클라이언트가 서로 다른 전략의 차이점을 이해해야 합니다. 오버헤드: 간단한 알고리즘의 경우 패턴 사용으로 인한 복잡도 증가가 있을 수 있습니다. 주의사항 및 고려사항 전략 선택의 기준: 언제 어떤 전략을 사용할지에 대한 명확한 기준이 필요합니다. 전략 간 데이터 공유: 전략들 간에 공유해야 하는 데이터가 있다면 이를 효율적으로 관리해야 합니다. 불필요한 복잡성 회피: 단순한 조건문으로 해결될 수 있는 상황에서는 Strategy Pattern을 사용하지 않는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from abc import ABC, abstractmethod from typing import List, Dict # Strategy 인터페이스 class ExportStrategy(ABC): @abstractmethod def export_data(self, data: List[Dict]) -> str: pass # Concrete Strategy 클래스들 class JSONExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: import json return json.dumps(data, indent=2) class CSVExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: import csv from io import StringIO output = StringIO() if not data: return "" writer = csv.DictWriter(output, fieldnames=data[0].keys()) writer.writeheader() writer.writerows(data) return output.getvalue() class XMLExporter(ExportStrategy): def export_data(self, data: List[Dict]) -> str: def dict_to_xml(d: Dict, indent: str = "") -> str: xml = [] for key, value in d.items(): if isinstance(value, dict): xml.append(f"{indent}&lt;{key}>") xml.append(dict_to_xml(value, indent + " ")) xml.append(f"{indent}&lt;/{key}>") else: xml.append(f"{indent}&lt;{key}>{value}&lt;/{key}>") return "\n".join(xml) xml_lines = ['&lt;?xml version="1.0" encoding="UTF-8"?>', "&lt;data>"] for item in data: xml_lines.append(" &lt;item>") xml_lines.append(dict_to_xml(item, " ")) xml_lines.append(" &lt;/item>") xml_lines.append("&lt;/data>") return "\n".join(xml_lines) # Context 클래스 class DataExporter: def __init__(self, export_strategy: ExportStrategy): self._strategy = export_strategy def set_strategy(self, export_strategy: ExportStrategy): self._strategy = export_strategy def export(self, data: List[Dict]) -> str: return self._strategy.export_data(data) # 사용 예시 def main(): # 테스트 데이터 data = [ {"id": 1, "name": "John Doe", "email": "john@example.com"}, {"id": 2, "name": "Jane Smith", "email": "jane@example.com"} ] # 각각의 전략으로 데이터 내보내기 exporter = DataExporter(JSONExporter()) print("JSON 형식으로 내보내기:") print(exporter.export(data)) print("\n" + "="*50 + "\n") exporter.set_strategy(CSVExporter()) print("CSV 형식으로 내보내기:") print(exporter.export(data)) print("\n" + "="*50 + "\n") exporter.set_strategy(XMLExporter()) print("XML 형식으로 내보내기:") print(exporter.export(data)) if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 // Strategy 인터페이스 interface PaymentStrategy { pay(amount: number): void; validate(): boolean; } // Concrete Strategy 클래스들 class CreditCardPayment implements PaymentStrategy { private readonly cardNumber: string; private readonly cardHolder: string; private readonly expiryDate: string; private readonly cvv: string; constructor(cardNumber: string, cardHolder: string, expiryDate: string, cvv: string) { this.cardNumber = cardNumber; this.cardHolder = cardHolder; this.expiryDate = expiryDate; this.cvv = cvv; } pay(amount: number): void { if (this.validate()) { console.log(`신용카드로 ${amount}원을 결제합니다.`); console.log(`카드 번호: ${this.maskCardNumber()}`); console.log(`카드 소유자: ${this.cardHolder}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidCardNumber = this.cardNumber.length === 16; const isValidCVV = this.cvv.length === 3; if (!isValidCardNumber) { console.log("잘못된 카드 번호입니다."); return false; } if (!isValidCVV) { console.log("잘못된 CVV입니다."); return false; } return true; } private maskCardNumber(): string { return this.cardNumber.slice(-4).padStart(16, '*'); } } class PayPalPayment implements PaymentStrategy { private readonly email: string; private readonly password: string; constructor(email: string, password: string) { this.email = email; this.password = password; } pay(amount: number): void { if (this.validate()) { console.log(`PayPal로 ${amount}원을 결제합니다.`); console.log(`PayPal 계정: ${this.email}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidEmail = this.email.includes('@'); const isValidPassword = this.password.length >= 8; if (!isValidEmail) { console.log("잘못된 이메일 형식입니다."); return false; } if (!isValidPassword) { console.log("비밀번호는 8자 이상이어야 합니다."); return false; } return true; } } class BankTransferPayment implements PaymentStrategy { private readonly bankCode: string; private readonly accountNumber: string; private readonly accountHolder: string; constructor(bankCode: string, accountNumber: string, accountHolder: string) { this.bankCode = bankCode; this.accountNumber = accountNumber; this.accountHolder = accountHolder; } pay(amount: number): void { if (this.validate()) { console.log(`계좌이체로 ${amount}원을 결제합니다.`); console.log(`은행 코드: ${this.bankCode}`); console.log(`계좌 번호: ${this.maskAccountNumber()}`); console.log(`예금주: ${this.accountHolder}`); } } validate(): boolean { // 실제로는 더 복잡한 유효성 검사가 필요합니다 const isValidBankCode = this.bankCode.length === 3; const isValidAccountNumber = this.accountNumber.length >= 10; if (!isValidBankCode) { console.log("잘못된 은행 코드입니다."); return false; } if (!isValidAccountNumber) { console.log("잘못된 계좌번호입니다."); return false; } return true; } private maskAccountNumber(): string { return this.accountNumber.slice(-4).padStart(this.accountNumber.length, '*'); } } // Context 클래스 class PaymentProcessor { private strategy: PaymentStrategy; constructor(strategy: PaymentStrategy) { this.strategy = strategy; } setStrategy(strategy: PaymentStrategy): void { this.strategy = strategy; } processPayment(amount: number): void { this.strategy.pay(amount); } } // 사용 예시 function main() { // 결제 프로세서 생성 (초기 전략: 신용카드) const processor = new PaymentProcessor( new CreditCardPayment("1234567890123456", "John Doe", "12/25", "123") ); console.log("=== 신용카드 결제 ==="); processor.processPayment(50000); console.log("\n=== PayPal 결제로 변경 ==="); processor.setStrategy( new PayPalPayment("john@example.com", "password123") ); processor.processPayment(30000); console.log("\n=== 계좌이체로 변경 ==="); processor.setStrategy( new BankTransferPayment("002", "1234567890", "John Doe") ); processor.processPayment(100000); // 잘못된 데이터로 결제 시도 console.log("\n=== 잘못된 신용카드 정보로 결제 시도 ==="); processor.setStrategy( new CreditCardPayment("123", "John Doe", "12/25", "12") ); processor.processPayment(50000); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1159 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strategy Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/strategy-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Template Method Pattern</h2></header><div class=entry-content><p>Template Method Pattern 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴
특징 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 합니다. 공통 로직은 상위 클래스에서 정의하고, 변화가 필요한 부분만 하위 클래스에서 구현합니다. 알고리즘의 구조를 변경하지 않고 특정 단계를 재정의할 수 있습니다. 두 가지 주요 부분으로 구성된다.
추상 클래스(Abstract Class): 알고리즘의 골격을 정의하는 템플릿 메서드를 포함 서브클래스에서 구현해야 하는 추상 메서드 정의 선택적으로 오버라이드할 수 있는 훅(hook) 메서드 제공 구체 클래스(Concrete Class): 추상 클래스를 상속받아 추상 메서드를 실제로 구현 필요한 경우 훅 메서드를 오버라이드하여 알고리즘을 커스터마이즈 사용사례 프레임워크에서 기본 동작을 정의하고 사용자가 일부를 커스터마이즈해야 할 때 데이터 마이닝 작업에서 데이터 처리 파이프라인을 구현할 때 리포트 생성 시스템에서 다양한 형식의 리포트를 생성할 때 장점 코드 재사용성이 높아집니다 알고리즘의 공통 부분을 한 곳에서 관리할 수 있습니다 확장성이 좋아 새로운 변형을 쉽게 추가할 수 있습니다 단점 템플릿 메소드가 복잡해질수록 유지보수가 어려워질 수 있습니다 하위 클래스에서 상위 클래스의 메소드를 실수로 오버라이드할 수 있습니다 알고리즘 단계가 많아지면 클래스 계층 구조가 복잡해질 수 있습니다 주의사항 및 고려사항 템플릿 메소드는 final로 선언하여 하위 클래스가 override하지 못하도록 해야 합니다. Python에서는 관례적으로 메소드 이름 앞에 언더스코어를 붙여 protected임을 나타냅니다. 추상 메소드(반드시 구현해야 하는 메소드)와 훅 메소드(선택적으로 구현할 수 있는 메소드)를 명확히 구분해야 합니다. 상속 계층이 깊어지지 않도록 주의해야 합니다. 일반적으로 추상 클래스와 구체 클래스의 2단계 정도가 적절합니다. 템플릿 메소드가 너무 많은 단계를 가지지 않도록 해야 합니다. 복잡한 알고리즘은 더 작은 단위로 분리하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from abc import ABC, abstractmethod class DataMiner(ABC): """데이터 마이닝을 위한 템플릿 메소드 패턴 구현""" def mine_data(self, path: str) -> None: """템플릿 메소드: 데이터 마이닝의 전체 프로세스를 정의""" raw_data = self._read_file(path) cleaned_data = self._clean_data(raw_data) analyzed_data = self._analyze_data(cleaned_data) self._send_report(analyzed_data) @abstractmethod def _read_file(self, path: str) -> list: """파일을 읽어오는 추상 메소드""" pass def _clean_data(self, data: list) -> list: """데이터 정제를 위한 훅 메소드""" return data @abstractmethod def _analyze_data(self, data: list) -> dict: """데이터 분석을 위한 추상 메소드""" pass def _send_report(self, data: dict) -> None: """분석 결과 보고를 위한 훅 메소드""" print("기본 보고서 생성:", data) class PDFDataMiner(DataMiner): """PDF 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"PDF 파일 읽기: {path}") return ["PDF 데이터 1", "PDF 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "PDF", "results": data} def _clean_data(self, data: list) -> list: # PDF 특화 데이터 정제 로직 return [item.strip() for item in data] class CSVDataMiner(DataMiner): """CSV 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"CSV 파일 읽기: {path}") return ["CSV 데이터 1", "CSV 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "CSV", "results": data} # 사용 예시 if __name__ == "__main__": pdf_miner = PDFDataMiner() csv_miner = CSVDataMiner() pdf_miner.mine_data("sample.pdf") csv_miner.mine_data("sample.csv") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BeverageMaker { /** * 음료 제조를 위한 템플릿 메소드 * @returns {void} */ prepare() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } this.serve(); } /** * 물을 끓이는 공통 메소드 * @private */ boilWater() { console.log('물을 끓입니다'); } /** * 음료를 우리는 추상 메소드 * @abstract * @private */ brew() { throw new Error('brew 메소드를 구현해야 합니다'); } /** * 컵에 따르는 공통 메소드 * @private */ pourInCup() { console.log('컵에 따릅니다'); } /** * 고객이 첨가물을 원하는지 확인하는 훅 메소드 * @returns {boolean} */ customerWantsCondiments() { return true; } /** * 첨가물을 추가하는 추상 메소드 * @abstract * @private */ addCondiments() { throw new Error('addCondiments 메소드를 구현해야 합니다'); } /** * 음료를 서빙하는 공통 메소드 * @private */ serve() { console.log('음료가 준비되었습니다'); } } class CoffeeMaker extends BeverageMaker { brew() { console.log('커피를 우립니다'); } addCondiments() { console.log('설탕과 우유를 추가합니다'); } customerWantsCondiments() { // 고객 선호도에 따라 첨가물 추가 여부 결정 return Math.random() > 0.5; } } class TeaMaker extends BeverageMaker { brew() { console.log('차를 우립니다'); } addCondiments() { console.log('레몬을 추가합니다'); } } // 사용 예시 const coffee = new CoffeeMaker(); const tea = new TeaMaker(); console.log('=== 커피 준비 ==='); coffee.prepare(); console.log('\n=== 차 준비 ==='); tea.prepare(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;786 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Template Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/template-method-pattern/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Observer Pattern</h2></header><div class=entry-content><p>Observer Pattern 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
특징 객체 간 일대다 관계를 정의합니다. 주체(Subject)와 관찰자(Observer)로 구성됩니다. 느슨한 결합을 제공하여 유연성을 높입니다. 발행/구독 모델로도 알려져 있습니다. 두 가지 인터페이스로 이루어진다.
Subject
Observer들을 등록(attach)하고 제거(detach)할 수 있으며, 상태 변경 시 모든 Observer에게 알림을 보낸다. Observer
Subject로부터 받은 알림을 처리하는 update 메서드를 구현 사용사례 이벤트 처리 시스템: GUI 애플리케이션에서 버튼 클릭이나 키보드 입력 등의 이벤트 처리 뉴스 구독 서비스: 새로운 뉴스가 발행되면 구독자들에게 알림 소셜 미디어 피드: 새로운 게시물이 등록되면 팔로워들에게 알림 주식 시장 모니터링: 주식 가격 변동을 실시간으로 관심 있는 투자자들에게 알림 장점 느슨한 결합(Loose Coupling): Subject와 Observer는 서로의 구체적인 구현을 알 필요가 없음 유연한 객체 관계: 실행 시점에 동적으로 Observer를 추가하거나 제거 가능 개방-폐쇄 원칙(OCP) 준수: 기존 코드 수정 없이 새로운 Observer 추가 가능 단점 순서 보장의 어려움: 다수의 Observer에게 알림이 전달될 때 실행 순서 보장이 어려움 메모리 누수 가능성: Observer 해제를 제대로 하지 않으면 메모리 누수 발생 위험 복잡성 증가: Observer가 많아질수록 디버깅과 테스트가 어려워질 수 있음 주의사항 및 고려사항 순환 참조 방지: Observer가 Subject를 다시 업데이트하는 순환 참조 상황 주의 메모리 관리: Observer 등록 해제를 확실히 처리 상태 일관성 유지: 다수의 Observer가 있을 때 상태 일관성 보장 비동기 처리 고려: 많은 Observer가 있을 경우 비동기 처리 검토 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from abc import ABC, abstractmethod from typing import List # Observer 인터페이스 class NewsObserver(ABC): @abstractmethod def update(self, news: str) -> None: pass # Subject(Observable) 클래스 class NewsAgency: def __init__(self): self._observers: List[NewsObserver] = [] self._latest_news: str = "" def attach(self, observer: NewsObserver) -> None: if observer not in self._observers: self._observers.append(observer) def detach(self, observer: NewsObserver) -> None: self._observers.remove(observer) def notify_observers(self) -> None: for observer in self._observers: observer.update(self._latest_news) def publish_news(self, news: str) -> None: self._latest_news = news self.notify_observers() # Concrete Observer 클래스들 class NewsChannel(NewsObserver): def __init__(self, name: str): self.name = name def update(self, news: str) -> None: print(f"{self.name} received news: {news}") class NewsApp(NewsObserver): def __init__(self, app_name: str): self.app_name = app_name def update(self, news: str) -> None: print(f"{self.app_name} pushing notification: {news}") # 사용 예시 def main(): # Subject 생성 news_agency = NewsAgency() # Observer 생성 bbc = NewsChannel("BBC") cnn = NewsChannel("CNN") news_app = NewsApp("Breaking News App") # Observer 등록 news_agency.attach(bbc) news_agency.attach(cnn) news_agency.attach(news_app) # 뉴스 발행 news_agency.publish_news("Breaking: Major tech breakthrough announced!") # Observer 제거 news_agency.detach(cnn) # 새로운 뉴스 발행 news_agency.publish_news("Update: More details on tech breakthrough…") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Observer 인터페이스 (TypeScript 스타일) interface WeatherObserver { update(temperature: number, humidity: number): void; } // Subject(Observable) 클래스 class WeatherStation { private observers: WeatherObserver[] = []; private temperature: number = 0; private humidity: number = 0; public attach(observer: WeatherObserver): void { const isExist = this.observers.includes(observer); if (!isExist) { this.observers.push(observer); } } public detach(observer: WeatherObserver): void { const observerIndex = this.observers.indexOf(observer); if (observerIndex !== -1) { this.observers.splice(observerIndex, 1); } } public notify(): void { for (const observer of this.observers) { observer.update(this.temperature, this.humidity); } } public setMeasurements(temperature: number, humidity: number): void { this.temperature = temperature; this.humidity = humidity; this.notify(); } } // Concrete Observer 클래스들 class WeatherDisplay implements WeatherObserver { private name: string; constructor(name: string) { this.name = name; } public update(temperature: number, humidity: number): void { console.log( `${this.name} Display: Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } class WeatherLogger implements WeatherObserver { public update(temperature: number, humidity: number): void { console.log( `Logging - Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } // 사용 예시 function main() { // Subject 생성 const weatherStation = new WeatherStation(); // Observer 생성 const phoneDisplay = new WeatherDisplay("Phone"); const tabletDisplay = new WeatherDisplay("Tablet"); const logger = new WeatherLogger(); // Observer 등록 weatherStation.attach(phoneDisplay); weatherStation.attach(tabletDisplay); weatherStation.attach(logger); // 날씨 정보 업데이트 console.log("First weather update:"); weatherStation.setMeasurements(24, 65); // Observer 제거 weatherStation.detach(tabletDisplay); // 새로운 날씨 정보 업데이트 console.log("\nSecond weather update:"); weatherStation.setMeasurements(27, 70); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:16:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;779 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/observer-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/categories/software-design-patterns/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>