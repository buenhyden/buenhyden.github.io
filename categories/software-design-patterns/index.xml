<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Software Design Patterns on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/categories/software-design-patterns/</link>
    <description>Recent content in Software Design Patterns on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Tue, 24 Jun 2025 13:23:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/categories/software-design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creational</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/</guid>
      <description>Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다.</description>
    </item>
    <item>
      <title>Structural</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/</link>
      <pubDate>Wed, 25 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/</guid>
      <description>GoF의 Structural Patterns 는 **객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법**으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다.</description>
    </item>
    <item>
      <title>Behavioral</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/</guid>
      <description>Behavioral Pattern 은 객체들 간 **책임 분배와 실행 흐름 협력**을 설계하여, 코드 의존성을 줄이고 유연성을 강화한다.  대표 패턴으로는 Observer, Strategy, Command 등이 있으며, 런타임 행동 변경과 확장에 효과적이다.</description>
    </item>
    <item>
      <title>Performance Optimization</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/</link>
      <pubDate>Tue, 24 Jun 2025 13:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/</guid>
      <description>&lt;h2 id=&#34;performance-optimization&#34;&gt;Performance Optimization&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;용어-정리&#34;&gt;용어 정리&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;용어&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;hr&gt;</description>
    </item>
    <item>
      <title>Object Pooling</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/object-pooling/</link>
      <pubDate>Tue, 24 Jun 2025 10:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/object-pooling/</guid>
      <description>Object Pooling 은 객체의 생성과 소멸 비용을 줄이기 위해 미리 생성된 객체들을 풀 (Pool) 에 보관하고 재사용하는 성능 최적화 디자인 패턴이다.  메모리 할당/해제 오버헤드를 줄이고 가비지 컬렉션 압력을 감소시켜 시스템 성능을 향상시킨다.</description>
    </item>
    <item>
      <title>POSA(Pattern-Oriented Software Architecture)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/posa/</link>
      <pubDate>Sat, 05 Apr 2025 01:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/posa/</guid>
      <description>POSA(패턴 지향 소프트웨어 아키텍처) 는 복잡한 소프트웨어 시스템 설계 문제에 대한 검증된 해결책을 패턴 형태로 제공하는 아키텍처 접근 방식이다. 다양한 수준의 추상화에서 재사용 가능한 디자인 패턴을 체계적으로 적용하여 소프트웨어의 품질, 유지보수성 및 확장성을 향상시키는 방법론을 제시한다.</description>
    </item>
    <item>
      <title>지연 초기화(Lazy Initialization)</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/lazy-initialization/</link>
      <pubDate>Wed, 18 Dec 2024 10:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/lazy-initialization/</guid>
      <description>지연 초기화는 객체나 값의 생성을 실제로 필요할 때까지 미루는 설계 패턴이다. 메모리 절약, 빠른 시작, 불필요한 연산 방지 등 자원 효율성을 극대화할 수 있지만, 최초 접근 시 지연, 예외 발생의 지연, 동시성 관리 등 주의가 필요하다.</description>
    </item>
    <item>
      <title>GoF</title>
      <link>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/</link>
      <pubDate>Wed, 25 Sep 2024 01:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/</guid>
      <description>GoF 디자인 패턴은 객체 생성, 구조 조합, 행동 관리를 체계화한 23 가지 솔루션이다. 재사용 가능한 코드 작성을 통해 **유지보수성**과 **확장성**을 높이며, Singleton, Adapter, Observer 등이 대표적이다. 이 패턴들은 복잡한 시스템에서 발생하는 공통 문제를 해결하기 위해 필수적으로 활용된다.</description>
    </item>
  </channel>
</rss>
