<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hyunyoun&#39;s 개발 블로그 on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/</link>
    <description>Recent content in Hyunyoun&#39;s 개발 블로그 on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.143.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 29 Jan 2025 02:56:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Semantic Web</title>
      <link>https://buenhyden.github.io/til/2024/12/04/semantic-web/</link>
      <pubDate>Wed, 04 Dec 2024 12:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/04/semantic-web/</guid>
      <description>&lt;h2 id=&#34;semantic-web&#34;&gt;Semantic Web&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Blockchain</title>
      <link>https://buenhyden.github.io/til/2024/12/04/blockchain/</link>
      <pubDate>Wed, 04 Dec 2024 12:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/04/blockchain/</guid>
      <description>&lt;h2 id=&#34;blockchain&#34;&gt;Blockchain&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Web</title>
      <link>https://buenhyden.github.io/til/2024/12/04/web/</link>
      <pubDate>Wed, 04 Dec 2024 12:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/04/web/</guid>
      <description>&lt;h2 id=&#34;web&#34;&gt;Web&lt;/h2&gt;
&lt;p&gt;Web(월드 와이드 웹)은 인터넷을 통해 접근할 수 있는 정보의 거대한 네트워크이다.&lt;br&gt;
1989년 팀 버너스 리(Tim Berners-Lee)가 유럽입자물리연구소(CERN)에서 처음 제안했으며, 전 세계 컴퓨터들을 연결하여 정보를 공유할 수 있는 거대한 네트워크를 구축하는 것을 목표로 했다.&lt;/p&gt;
&lt;p&gt;Web의 발전은 단순한 정보 제공에서 시작하여 사용자 참여와 상호작용을 거쳐, 현재는 지능형 및 분산형 시스템으로 진화하고 있다.&lt;br&gt;
이러한 발전은 기술의 진보와 사용자 요구의 변화를 반영하며, 앞으로도 계속해서 새로운 형태로 발전할 것으로 예상된다.&lt;/p&gt;
&lt;h3 id=&#34;web의-발전-과정&#34;&gt;Web의 발전 과정&lt;/h3&gt;
&lt;h4 id=&#34;web-10&#34;&gt;Web 1.0&lt;/h4&gt;
&lt;p&gt;1990년대 초부터 2000년대 초까지의 초기 웹 시대를 지칭하며, 주로 정적인 읽기 전용 콘텐츠로 구성되어 있었다.&lt;br&gt;
이 시기의 웹사이트는 정보 제공자가 콘텐츠를 생성하고, 사용자는 이를 단순히 소비하는 구조로, 상호작용이 제한적이었다&lt;/p&gt;</description>
    </item>
    <item>
      <title>OSI 7 Layers vs TCPIP 4 Layers</title>
      <link>https://buenhyden.github.io/til/2024/10/19/osi-7-layers-vs-tcpip-4-layers/</link>
      <pubDate>Sat, 19 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/19/osi-7-layers-vs-tcpip-4-layers/</guid>
      <description>OSI 7계층은 네트워크 통신의 표준 참조 모델이며, TCP/IP 4계층은 이를 바탕으로 구현된 실제 인터넷 통신의 기반이 된다.</description>
    </item>
    <item>
      <title>TCP/IP 4 Layers - 1. Network Access Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-1-network-access-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-1-network-access-layer/</guid>
      <description>데이터를 전송 매체에 맞게 포맷팅하고 물리적 하드웨어 주소를 기반으로 데이터를 주소 지정한다</description>
    </item>
    <item>
      <title>OSI 7 Layers - 1. Phygical Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-1-phygical-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-1-phygical-layer/</guid>
      <description>OSI 7계층의 가장 첫 번째 계층으로, 실제 데이터가 전기 신호나 빛으로 변환되어 전송되는 곳</description>
    </item>
    <item>
      <title>Concurrency vs Parallelism</title>
      <link>https://buenhyden.github.io/til/2024/10/05/concurrency-vs-parallelism/</link>
      <pubDate>Sat, 05 Oct 2024 02:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/concurrency-vs-parallelism/</guid>
      <description>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.</description>
    </item>
    <item>
      <title>Data Pipeline Pattern</title>
      <link>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/data-pipeline-pattern/</guid>
      <description>데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 2. Internet Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-2-internet-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-2-internet-layer/</guid>
      <description>인터넷 계층은 TCP/IP 프로토콜 스택에서 네트워크 간의 통신을 담당하는 핵심 계층으로, 네트워크 간 데이터 전송을 담당하며, 데이터 패킷이 출발지에서 목적지까지 효율적으로 전달되도록 라우팅과 주소 지정(Addressing)을 수행한다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 2. DataLink Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-2-datalink-layer/</guid>
      <description>OSI 7계층에서 두 번째 계층으로, 직접 연결된 두 장치 간의 안전한 데이터 전송을 담당</description>
    </item>
    <item>
      <title>1. 계획 (Planning)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/1-planning/</link>
      <pubDate>Fri, 20 Sep 2024 00:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/1-planning/</guid>
      <description>프로젝트의 방향성과 범위를 설정하고, 자원과 일정을 계획하며, 위험 요소를 식별하고 관리 전략을 수립한다.</description>
    </item>
    <item>
      <title>CSR vs SSR</title>
      <link>https://buenhyden.github.io/til/2024/12/02/csr-vs-ssr/</link>
      <pubDate>Mon, 02 Dec 2024 12:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/csr-vs-ssr/</guid>
      <description>Client Side Rendering (CSR)은 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링하며, Server Side Rendering (SSR)은 서버에서 HTML을 생성하여 클라이언트에 전달한다.</description>
    </item>
    <item>
      <title>라이브러리 (Library)와 프레임워크 (Framework)</title>
      <link>https://buenhyden.github.io/til/2024/11/20/library-and-framework/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/20/library-and-framework/</guid>
      <description>라이브러리(Library)는 특정 기능을 수행하는 코드의 모음이고, 프레임워크(Framework)는 애플리케이션 개발의 기본 구조를 제공한다.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 3. Transport Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-3-transport-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-3-transport-layer/</guid>
      <description>전송 계층은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신을 제공한다.</description>
    </item>
    <item>
      <title>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/2-requirements-gathering-and-analysis/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/2-requirements-gathering-and-analysis/</guid>
      <description>이해관계자의 요구사항을 수집하고 분석하여 시스템 요구사항을 정의하는 단계</description>
    </item>
    <item>
      <title>MSA 패턴 유형별 비교</title>
      <link>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Tue, 19 Nov 2024 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/msa-%ED%8C%A8%ED%84%B4-%EC%9C%A0%ED%98%95%EB%B3%84-%EB%B9%84%EA%B5%90/</guid>
      <description>MSA의 주요 패턴 유형들을 체계적으로 정리한 것.</description>
    </item>
    <item>
      <title>TCP/IP 4계층 - 4. Application Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-4-application-layer/</link>
      <pubDate>Thu, 17 Oct 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/tcp-ip-4-layers/tcpip-4-layers-4-application-layer/</guid>
      <description>TCP/IP 프로토콜 스택에서 가장 상위 계층으로, 사용자와 가장 가까운 계층으로 이메일, 웹 서핑, 파일 전송 등의 서비스를 위한 프로토콜들이 모여 있는 계층이다.</description>
    </item>
    <item>
      <title>OSI 7 Layers - 4. Transport Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-4-transport-layer/</guid>
      <description>4번째 계층으로, 데이터 전송의 신뢰성과 효율성을 담당하는 중요한 역할을 한다</description>
    </item>
    <item>
      <title>Network Traffic</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/network-traffic/</link>
      <pubDate>Wed, 16 Oct 2024 02:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/network-traffic/</guid>
      <description>네트워크 트래픽은 컴퓨터 네트워크를 통해 이동하는 데이터의 양을 의미한다.</description>
    </item>
    <item>
      <title>3. 설계 (Design)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/3-design/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/3-design/</guid>
      <description>요구사항을 바탕으로 시스템의 구조와 세부 사항을 설계하는 단계</description>
    </item>
    <item>
      <title>OSI 7 Layers - 5. Session Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-5-session-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-5-session-layer/</guid>
      <description>세션 계층은 OSI 모델의 5번째 계층으로, 통신 세션을 구성하는 계층으로 응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 프로세스들의 논리적인 연결을 담당한다.</description>
    </item>
    <item>
      <title>4. 구현 (Implementation)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/4-implementation/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/4-implementation/</guid>
      <description>설계를 바탕으로 실제 코드를 작성하는 단계</description>
    </item>
    <item>
      <title>OSI 7 Layers - 6. Presentation Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-6-presentation-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-6-presentation-layer/</guid>
      <description>OSI 7계층 모델에서 6번째 계층으로, 데이터의 표현과 암호화를 담당하는 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Concurrent Hash Map vs Hash Map vs Hash Table</title>
      <link>https://buenhyden.github.io/til/2024/10/12/concurrent-hash-map-vs-hash-map-vs-hash-table/</link>
      <pubDate>Sat, 12 Oct 2024 14:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/concurrent-hash-map-vs-hash-map-vs-hash-table/</guid>
      <description>&lt;h2 id=&#34;concurrent-hash-map-vs-hash-map-vs-hash-table&#34;&gt;Concurrent Hash Map Vs Hash Map Vs Hash Table&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특성&lt;/th&gt;
          &lt;th&gt;Concurrent HashMap&lt;/th&gt;
          &lt;th&gt;HashMap&lt;/th&gt;
          &lt;th&gt;HashTable&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트/버킷 단위의 부분 동기화 지원&lt;/td&gt;
          &lt;td&gt;동기화 지원하지 않음&lt;/td&gt;
          &lt;td&gt;메서드 단위의 전체 동기화 지원&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동시성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;높은 동시성 지원 (여러 스레드가 동시에 다른 세그먼트에 접근 가능)&lt;/td&gt;
          &lt;td&gt;동시성 지원하지 않음 (단일 스레드 환경용)&lt;/td&gt;
          &lt;td&gt;낮은 동시성 (한 번에 하나의 스레드만 접근 가능)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동시 접근 시 높은 성능&lt;/td&gt;
          &lt;td&gt;단일 스레드에서 가장 높은 성능&lt;/td&gt;
          &lt;td&gt;동기화로 인한 성능 저하&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;null 허용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
          &lt;td&gt;key는 하나만 null 허용, value는 여러 개 null 허용&lt;/td&gt;
          &lt;td&gt;key와 value 모두 null 불가&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;초기 용량&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 16, 세그먼트 수는 16&lt;/td&gt;
          &lt;td&gt;기본 16&lt;/td&gt;
          &lt;td&gt;기본 11&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;적재율&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
          &lt;td&gt;기본 0.75&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;이터레이션&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;fail-safe 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
          &lt;td&gt;fail-fast 이터레이터 제공&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;생성 시기&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;Java 5&lt;/td&gt;
          &lt;td&gt;Java 1.2&lt;/td&gt;
          &lt;td&gt;Java 1.0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;메모리 사용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;세그먼트로 인한 추가 메모리 필요&lt;/td&gt;
          &lt;td&gt;가장 적은 메모리 사용&lt;/td&gt;
          &lt;td&gt;동기화로 인한 추가 메모리 필요&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;용도&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;멀티스레드 환경의 동시성이 필요한 경우&lt;/td&gt;
          &lt;td&gt;단일 스레드 환경의 일반적인 경우&lt;/td&gt;
          &lt;td&gt;레거시 코드 호환성이 필요한 경우&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
          &lt;td&gt;동적 확장 가능&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;순서 보장&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
          &lt;td&gt;삽입 순서 보장하지 않음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;동기화 비용&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;부분적 동기화로 중간 수준의 비용&lt;/td&gt;
          &lt;td&gt;동기화 비용 없음&lt;/td&gt;
          &lt;td&gt;전체 동기화로 높은 비용&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;스레드 안전성&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
          &lt;td&gt;스레드 안전하지 않음&lt;/td&gt;
          &lt;td&gt;스레드 안전&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;키 충돌 처리&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
          &lt;td&gt;체이닝 방식&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;참고로 몇 가지 중요한 추가 설명을 하자면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Concurrent Data Structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/concurrent-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/concurrent-data-structure/</guid>
      <description>Concurrent Data Structure는 여러 스레드가 동시에 안전하게 접근하고 조작할 수 있도록 설계된 데이터 구조로, 전통적인 데이터 구조와 달리, 동시성을 고려하여 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 제공하는 것이 특징이다.</description>
    </item>
    <item>
      <title>Linear Data Structure vs Non-Linear Data Structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/linear-data-structure-vs-non-linear-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/linear-data-structure-vs-non-linear-data-structure/</guid>
      <description>Linear Data Structure Vs Non-Linear Data Structure</description>
    </item>
    <item>
      <title>Primitive data structure vs Non-Primitive data structure</title>
      <link>https://buenhyden.github.io/til/2024/10/12/primitive-data-structure-vs-non-primitive-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 08:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/primitive-data-structure-vs-non-primitive-data-structure/</guid>
      <description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description>
    </item>
    <item>
      <title>5. 테스트 (Testing)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/5-testing/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/5-testing/</guid>
      <description>개발된 소프트웨어의 품질을 검증하고 결함을 식별하는 단계</description>
    </item>
    <item>
      <title>OSI 7 Layers - 7. Application Layer</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-7-application-layer/</link>
      <pubDate>Wed, 16 Oct 2024 07:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/osi-7-layers-7-application-layer/</guid>
      <description>OSI 7계층 모델에서 최상위 계층으로, 사용자와 네트워크 간의 직접적인 상호작용을 담당한다</description>
    </item>
    <item>
      <title>6. 배포 (Deployment)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/6-deployment/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/6-deployment/</guid>
      <description>완성된 소프트웨어를 실제 운영 환경에 설치하고 사용자에게 제공하는 단계</description>
    </item>
    <item>
      <title>Websocket vs WebRTC</title>
      <link>https://buenhyden.github.io/til/2024/10/19/websocket-vs-webrtc/</link>
      <pubDate>Sat, 19 Oct 2024 05:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/19/websocket-vs-webrtc/</guid>
      <description>WebSocket과 WebRTC는 실시간 웹 통신을 위한 중요한 기술</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/til/2024/10/12/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Sat, 12 Oct 2024 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/12/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>7. 유지보수 (Maintenance)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/7-maintenance/</link>
      <pubDate>Fri, 20 Sep 2024 00:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-life-cycle/7-maintenance/</guid>
      <description>배포된 소프트웨어를 지속적으로 관리하고 개선하는 단계</description>
    </item>
    <item>
      <title>Json (JavaScript Object Notation)</title>
      <link>https://buenhyden.github.io/til/2024/10/26/json/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/json/</guid>
      <description>Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷.</description>
    </item>
    <item>
      <title>TOML (Tom&#39;s Obvious Minimal Language)</title>
      <link>https://buenhyden.github.io/til/2024/10/26/toml/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/toml/</guid>
      <description>서로 다른 시스템이나 프로그램 간에 데이터를 주고받을 때 사용하는 표준화된 형식</description>
    </item>
    <item>
      <title>YAML (YAML Ain&#39;t Markup Language)</title>
      <link>https://buenhyden.github.io/til/2024/10/26/yaml/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/yaml/</guid>
      <description>서로 다른 시스템이나 프로그램 간에 데이터를 주고받을 때 사용하는 표준화된 형식</description>
    </item>
    <item>
      <title>데이터 교환 형식</title>
      <link>https://buenhyden.github.io/til/2024/10/26/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%90%ED%99%98-%ED%98%95%EC%8B%9D/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%90%ED%99%98-%ED%98%95%EC%8B%9D/</guid>
      <description>서로 다른 시스템이나 프로그램 간에 데이터를 주고받을 때 사용하는 표준화된 형식</description>
    </item>
    <item>
      <title>인코딩 (Encoding)과 디코딩 (Decoding)</title>
      <link>https://buenhyden.github.io/til/2024/10/26/encoding-and-decoding/</link>
      <pubDate>Sat, 26 Oct 2024 07:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/encoding-and-decoding/</guid>
      <description>인코딩(Encoding)은 데이터를 특정 형식으로 변환하는 과정이고, 디코딩(Decoding)은 인코딩의 반대 과정으로, 변환된 데이터를 원래의 형식으로 되돌리는 과정</description>
    </item>
    <item>
      <title>Blocking vs Non-Blocking</title>
      <link>https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/blocking-vs-non-blocking/</guid>
      <description>프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.</description>
    </item>
    <item>
      <title>동기(Synchronous)와 비동기(Asynchronous)</title>
      <link>https://buenhyden.github.io/til/2024/10/06/synchronous-and-asynchronous/</link>
      <pubDate>Sun, 06 Oct 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/synchronous-and-asynchronous/</guid>
      <description>프로그래밍에서 작업을 처리하는 두 가지 주요 방식</description>
    </item>
    <item>
      <title>Memoization vs Tabulation</title>
      <link>https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/13/memoization-vs-tabulation/</guid>
      <description>Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법</description>
    </item>
    <item>
      <title>Programming Language Control Structures</title>
      <link>https://buenhyden.github.io/til/2024/10/06/programming-language-control-structures/</link>
      <pubDate>Sun, 06 Oct 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/programming-language-control-structures/</guid>
      <description>프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.</description>
    </item>
    <item>
      <title>Iteration vs Recursion</title>
      <link>https://buenhyden.github.io/til/2024/10/06/iteration-vs-recursion/</link>
      <pubDate>Sun, 06 Oct 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/iteration-vs-recursion/</guid>
      <description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</description>
    </item>
    <item>
      <title>Interface vs Abstract class</title>
      <link>https://buenhyden.github.io/til/2024/09/22/interface-vs-abstract-class/</link>
      <pubDate>Sun, 22 Sep 2024 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/22/interface-vs-abstract-class/</guid>
      <description>인터페이스는 클래스가 &amp;#39;무엇을 해야 하는지&amp;#39;를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.</description>
    </item>
    <item>
      <title>Process vs Thread vs Coroutine</title>
      <link>https://buenhyden.github.io/til/2024/10/06/process-vs-thread-vs-coroutine/</link>
      <pubDate>Sun, 06 Oct 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/process-vs-thread-vs-coroutine/</guid>
      <description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</description>
    </item>
    <item>
      <title>Multithreading Vs Multiprocessing vs Multitasking</title>
      <link>https://buenhyden.github.io/til/2024/10/05/multithreading-vs-multiprocessing-vs-multitasking/</link>
      <pubDate>Sat, 05 Oct 2024 14:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/multithreading-vs-multiprocessing-vs-multitasking/</guid>
      <description>Multithreading, Multiprocessing, Multitasking은 컴퓨터 시스템에서 동시성과 병렬성을 구현하는 세 가지 주요 개념이다.</description>
    </item>
    <item>
      <title>Process vs Thread</title>
      <link>https://buenhyden.github.io/til/2024/10/05/process-vs-thread/</link>
      <pubDate>Sat, 05 Oct 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/process-vs-thread/</guid>
      <description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</description>
    </item>
    <item>
      <title>Poetry vs uv vs Rye</title>
      <link>https://buenhyden.github.io/til/2024/11/27/poetry-vs-uv-vs-rye/</link>
      <pubDate>Wed, 27 Nov 2024 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/27/poetry-vs-uv-vs-rye/</guid>
      <description>파이썬 프로젝트 관리와 패키지 설치를 위한 도구들</description>
    </item>
    <item>
      <title>Linux Basic Command</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/linux/linux-basic-command/</link>
      <pubDate>Tue, 01 Oct 2024 15:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/linux/linux-basic-command/</guid>
      <description>Linux에서 자주 사용하는 명령어 모음</description>
    </item>
    <item>
      <title>Linux Permission</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/linux/linux-permission/</link>
      <pubDate>Tue, 01 Oct 2024 15:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/linux/linux-permission/</guid>
      <description>Linux 권한 설정</description>
    </item>
    <item>
      <title>programmers (Lv2) 네트워크</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/</link>
      <pubDate>Thu, 16 Jan 2025 23:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>programmers (Lv2) 등굣길</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%93%B1%EA%B5%A3%EA%B8%B8/</link>
      <pubDate>Thu, 16 Jan 2025 23:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%93%B1%EA%B5%A3%EA%B8%B8/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>programmers (Lv2) 올바른 괄호</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/</link>
      <pubDate>Thu, 16 Jan 2025 16:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>Programmers (Lv2) 최댓값과 최솟값</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EC%B5%9C%EB%8C%93%EA%B0%92%EA%B3%BC-%EC%B5%9C%EC%86%9F%EA%B0%92/</link>
      <pubDate>Thu, 16 Jan 2025 16:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EC%B5%9C%EB%8C%93%EA%B0%92%EA%B3%BC-%EC%B5%9C%EC%86%9F%EA%B0%92/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>programmers (Lv2) 멀리 뛰기</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%A9%80%EB%A6%AC-%EB%9B%B0%EA%B8%B0/</link>
      <pubDate>Thu, 16 Jan 2025 16:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/16/programmers-lv2-%EB%A9%80%EB%A6%AC-%EB%9B%B0%EA%B8%B0/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>Event-Driven Architecture vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/event-driven-architecture-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</guid>
      <description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description>
    </item>
    <item>
      <title>Scenario Testing vs Use Case Testing</title>
      <link>https://buenhyden.github.io/til/2024/11/05/scenario-testing-vs-use-case-testing/</link>
      <pubDate>Tue, 05 Nov 2024 17:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/scenario-testing-vs-use-case-testing/</guid>
      <description>Scenario Testing과 Use Case Testing은 소프트웨어 테스팅 기법으로, 사용자 관점에서 시스템의 기능과 동작을 검증하는 데 사용된다.</description>
    </item>
    <item>
      <title>Nginx vs Apache HTTP Server vs Caddy</title>
      <link>https://buenhyden.github.io/til/2024/10/22/nginx-vs-apache-tomcat-vs-caddy/</link>
      <pubDate>Tue, 22 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/nginx-vs-apache-tomcat-vs-caddy/</guid>
      <description>Nginx, Apache HTTP Server, 그리고 Caddy는 모두 웹 서버 소프트웨어이다.</description>
    </item>
    <item>
      <title>Kafka vs RabbitMQ</title>
      <link>https://buenhyden.github.io/til/2024/10/22/kafka-vs-rabbitmq/</link>
      <pubDate>Tue, 22 Oct 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/kafka-vs-rabbitmq/</guid>
      <description>Kafka와 RabbitMQ는 모두 메시지 브로커 시스템으로, 분산 시스템에서 데이터를 효율적으로 전송하고 처리하는 역할을 한다.</description>
    </item>
    <item>
      <title>Paging vs Segmentation</title>
      <link>https://buenhyden.github.io/til/2024/10/05/paging-vs-segmentation/</link>
      <pubDate>Sat, 05 Oct 2024 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/paging-vs-segmentation/</guid>
      <description>Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.</description>
    </item>
    <item>
      <title>programmers (Lv2) 더 맵게</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/17/programmers-lv2-%EB%8D%94-%EB%A7%B5%EA%B2%8C/</link>
      <pubDate>Fri, 17 Jan 2025 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/17/programmers-lv2-%EB%8D%94-%EB%A7%B5%EA%B2%8C/</guid>
      <description>코딩 테스트</description>
    </item>
    <item>
      <title>VueJS vs ReactJS vs NextJS</title>
      <link>https://buenhyden.github.io/til/2024/12/02/vuejs-vs-reactjs-vs-nextjs/</link>
      <pubDate>Mon, 02 Dec 2024 04:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/vuejs-vs-reactjs-vs-nextjs/</guid>
      <description>VueJS, ReactJS, NextJS는 현대 웹 개발에서 사용되는 주요 프론트엔드 프레임워크와 라이브러리들이다.</description>
    </item>
    <item>
      <title>Callback vs Promise vs Async/Await</title>
      <link>https://buenhyden.github.io/til/2024/11/23/callback-vs-promise-vs-async-await/</link>
      <pubDate>Sat, 23 Nov 2024 09:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/23/callback-vs-promise-vs-async-await/</guid>
      <description>JavaScript의 비동기 처리 방식</description>
    </item>
    <item>
      <title>ExpressJS vs NestJS</title>
      <link>https://buenhyden.github.io/til/2024/11/23/expressjs-vs-nestjs/</link>
      <pubDate>Sat, 23 Nov 2024 04:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/23/expressjs-vs-nestjs/</guid>
      <description>Express.js와 Nest.js는</description>
    </item>
    <item>
      <title>Streaming vs Polling</title>
      <link>https://buenhyden.github.io/til/2024/10/20/streaming-vs-polling/</link>
      <pubDate>Sun, 20 Oct 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/streaming-vs-polling/</guid>
      <description>Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술</description>
    </item>
    <item>
      <title>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</title>
      <link>https://buenhyden.github.io/til/2024/10/06/synchronous-and-asynchronous-and-blocking-and-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/synchronous-and-asynchronous-and-blocking-and-non-blocking/</guid>
      <description>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</description>
    </item>
    <item>
      <title>Lock and Mutex</title>
      <link>https://buenhyden.github.io/til/2024/10/05/lock-and-mutex/</link>
      <pubDate>Sat, 05 Oct 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/lock-and-mutex/</guid>
      <description>Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.</description>
    </item>
    <item>
      <title>Redis와 Valkey</title>
      <link>https://buenhyden.github.io/til/2024/10/22/redis%EC%99%80-valkey/</link>
      <pubDate>Tue, 22 Oct 2024 01:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/redis%EC%99%80-valkey/</guid>
      <description>Redis와 Valkey 모두 인메모리 데이터베이스로, 빠른 읽기/쓰기 성능을 제공하나, Redis의 라이선스 정책 변경으로 인해 Valkey가 fork되어 새로운 프로젝트가 되었다.</description>
    </item>
    <item>
      <title>마이그레이션 (Migration)</title>
      <link>https://buenhyden.github.io/til/2024/09/19/migration/</link>
      <pubDate>Thu, 19 Sep 2024 15:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/19/migration/</guid>
      <description>IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정</description>
    </item>
    <item>
      <title>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)</title>
      <link>https://buenhyden.github.io/til/2024/09/19/cloud-security-assurance-program/</link>
      <pubDate>Thu, 19 Sep 2024 11:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/19/cloud-security-assurance-program/</guid>
      <description>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)은 한국인터넷진흥원(KISA)에서 주관하는 클라우드 서비스의 보안성을 평가하고 인증하는 제도.</description>
    </item>
    <item>
      <title>E-Commerce Service</title>
      <link>https://buenhyden.github.io/til/2024/12/03/e-commerce-service/</link>
      <pubDate>Tue, 03 Dec 2024 12:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/e-commerce-service/</guid>
      <description>물품 구매 서비스를 구현하기 위해 필요한 사항들을 정리한다.</description>
    </item>
    <item>
      <title>선사용 IT 솔루션</title>
      <link>https://buenhyden.github.io/til/2024/12/03/%EC%84%A0%EC%82%AC%EC%9A%A9-it-%EC%86%94%EB%A3%A8%EC%85%98/</link>
      <pubDate>Tue, 03 Dec 2024 01:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/%EC%84%A0%EC%82%AC%EC%9A%A9-it-%EC%86%94%EB%A3%A8%EC%85%98/</guid>
      <description>해운업계의 디지털 전환 사례와 최신 기술 트렌드를 기반으로 정리</description>
    </item>
    <item>
      <title>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</title>
      <link>https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/</link>
      <pubDate>Sat, 19 Oct 2024 06:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/19/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/</guid>
      <description>API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석</description>
    </item>
    <item>
      <title>Webhook vs Server-Sent Events</title>
      <link>https://buenhyden.github.io/til/2024/10/19/webhook-vs-server-sent-events/</link>
      <pubDate>Sat, 19 Oct 2024 06:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/19/webhook-vs-server-sent-events/</guid>
      <description>Webhook과 Server-Sent Events(SSE)는 실시간 데이터 전송을 위한 웹 기술이다.</description>
    </item>
    <item>
      <title>leetcode 70 Climbing Stairs</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-70-climbing-stairs/</link>
      <pubDate>Tue, 21 Jan 2025 11:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-70-climbing-stairs/</guid>
      <description>&lt;h2 id=&#34;문제-설명---easy&#34;&gt;문제 설명 - Easy&lt;/h2&gt;
&lt;p&gt;You are climbing a staircase. It takes &lt;code&gt;n&lt;/code&gt; steps to reach the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; n = 2&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2&lt;br&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; There are two ways to climb to the top.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1 step + 1 step&lt;/li&gt;
&lt;li&gt;2 steps&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; n = 3&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;br&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; There are three ways to climb to the top.&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 200 Number of Islands</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-200-number-of-islands/</link>
      <pubDate>Tue, 21 Jan 2025 11:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-200-number-of-islands/</guid>
      <description>&lt;h2 id=&#34;문제-설명---medium&#34;&gt;문제 설명 - Medium&lt;/h2&gt;
&lt;p&gt;Given an &lt;code&gt;m x n&lt;/code&gt; 2D binary grid &lt;code&gt;grid&lt;/code&gt; which represents a map of &lt;code&gt;&#39;1&#39;&lt;/code&gt;s (land) and &lt;code&gt;&#39;0&#39;&lt;/code&gt;s (water), return &lt;em&gt;the number of islands&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;island&lt;/strong&gt; is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; grid =&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;]  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; 1&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 704 Binary Search</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-704-binary-search/</link>
      <pubDate>Tue, 21 Jan 2025 11:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/21/leetcode-704-binary-search/</guid>
      <description>&lt;h2 id=&#34;문제-설명---easy&#34;&gt;문제 설명 - Easy&lt;/h2&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; which is sorted in ascending order, and an integer &lt;code&gt;target&lt;/code&gt;, write a function to search &lt;code&gt;target&lt;/code&gt; in &lt;code&gt;nums&lt;/code&gt;. If &lt;code&gt;target&lt;/code&gt; exists, then return its index. Otherwise, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You must write an algorithm with &lt;code&gt;O(log n)&lt;/code&gt; runtime complexity.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = &lt;code&gt;[-1,0,3,5,9,12]&lt;/code&gt;, target = 9&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 4&lt;br&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; 9 exists in nums and its index is 4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>물류 운송 관리 시스템 (Transportation Management System, TMS)</title>
      <link>https://buenhyden.github.io/til/2024/12/03/transportation-management-system/</link>
      <pubDate>Tue, 03 Dec 2024 06:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/transportation-management-system/</guid>
      <description>물류 운송 관리 시스템으로, 기업의 물류 운송 프로세스를 효율적으로 관리하고 최적화하기 위한 솔루션</description>
    </item>
    <item>
      <title>Enterprise Resource Planning</title>
      <link>https://buenhyden.github.io/til/2024/12/03/enterprise-resource-planning/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/enterprise-resource-planning/</guid>
      <description>ERP(Enterprise Resource Planning)는 기업의 모든 자원을 통합적으로 관리하고 운영하기 위한 시스템</description>
    </item>
    <item>
      <title>Warehouse Management System</title>
      <link>https://buenhyden.github.io/til/2024/12/03/warehouse-management-system/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/warehouse-management-system/</guid>
      <description>WMS(Warehouse Management System)는 창고 관리 시스템으로, 창고 내의 물류 프로세스를 최적화하고 효율적으로 관리하기 위한 소프트웨어 애플리케이션을 말한다</description>
    </item>
    <item>
      <title>setup.cfg vs pyproject.toml</title>
      <link>https://buenhyden.github.io/til/2024/11/27/setup.cfg-vs-pyproject.toml/</link>
      <pubDate>Wed, 27 Nov 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/27/setup.cfg-vs-pyproject.toml/</guid>
      <description>Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.</description>
    </item>
    <item>
      <title>Programming Languages and Frameworks</title>
      <link>https://buenhyden.github.io/til/2024/11/20/programming-languages-and-frameworks/</link>
      <pubDate>Wed, 20 Nov 2024 08:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/20/programming-languages-and-frameworks/</guid>
      <description>Python, Node.js, Spring을 비교하고 특징 및 장단점을 서술한다.</description>
    </item>
    <item>
      <title>Cloud and On-Premise</title>
      <link>https://buenhyden.github.io/til/2024/11/10/cloud-and-on-premise/</link>
      <pubDate>Sun, 10 Nov 2024 10:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/10/cloud-and-on-premise/</guid>
      <description>Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.</description>
    </item>
    <item>
      <title>Computer Science and Engineering</title>
      <link>https://buenhyden.github.io/til/2024/09/19/computer-science-and-engineering/</link>
      <pubDate>Thu, 19 Sep 2024 15:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/19/computer-science-and-engineering/</guid>
      <description>계산(Computation), 정보(Information) 그리고 자동화(Automation)에 대한 학문</description>
    </item>
    <item>
      <title>Shared Database vs Shared Database Per Service</title>
      <link>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 08:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/12/shared-database-vs-shared-database-per-service/</guid>
      <description>&lt;h2 id=&#34;shared-database-vs-shared-database-per-service&#34;&gt;Shared Database vs Shared Database Per Service&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>CCE vs CVE vs CWE</title>
      <link>https://buenhyden.github.io/til/2024/11/07/cce-vs-cve-vs-cwe/</link>
      <pubDate>Thu, 07 Nov 2024 07:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/07/cce-vs-cve-vs-cwe/</guid>
      <description>CCE, CVE, CWE는 모두 컴퓨터 시스템과 소프트웨어의 보안 취약점을 식별하고 분류하기 위한 표준화된 체계이다.</description>
    </item>
    <item>
      <title>ETL vs ELT</title>
      <link>https://buenhyden.github.io/til/2024/10/26/etl-vs-elt/</link>
      <pubDate>Sat, 26 Oct 2024 07:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/etl-vs-elt/</guid>
      <description>데이터 통합 및 처리를 위한 두 가지 주요 접근 방식</description>
    </item>
    <item>
      <title>Data Lake vs Data Warehouse  vs Data Lakehouse</title>
      <link>https://buenhyden.github.io/til/2024/10/26/data-lake-vs-data-warehouse--vs-data-lakehouse/</link>
      <pubDate>Sat, 26 Oct 2024 05:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/data-lake-vs-data-warehouse--vs-data-lakehouse/</guid>
      <description>데이터 레이크(Data Lake)와 데이터 웨어하우스(Data Warehouse)는 기업의 데이터 관리 및 분석을 위한 중요한 저장소 시스템이다.</description>
    </item>
    <item>
      <title>leetcode 5 Longest Palindromic Substring</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-5-longest-palindromic-substring/</link>
      <pubDate>Thu, 23 Jan 2025 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-5-longest-palindromic-substring/</guid>
      <description>&lt;h2 id=&#34;문제-설명---medium&#34;&gt;문제 설명 - Medium&lt;/h2&gt;
&lt;p&gt;Given a string &lt;code&gt;s&lt;/code&gt;, return &lt;em&gt;the longest&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;palindromic&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;substring&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; in &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;babad&amp;rdquo;&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;bab&amp;rdquo;&lt;br&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; &amp;ldquo;aba&amp;rdquo; is also a valid answer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; s = &amp;ldquo;cbbd&amp;rdquo;&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &amp;ldquo;bb&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; consist of only digits and English letters.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;코드-풀이&#34;&gt;코드 풀이&lt;/h2&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;javascript&#34;&gt;Javascript&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;해설&#34;&gt;해설&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://school.programmers.co.kr/learn/challenges&#34;&gt;programmers Coding Test&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode.com/&#34;&gt;LeetCode - The World&amp;rsquo;s Leading Online Programming Learning Platform&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 94 Binary Tree Inorder Traversal</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-94-binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 23 Jan 2025 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-94-binary-tree-inorder-traversal/</guid>
      <description>&lt;h2 id=&#34;문제-설명---easy&#34;&gt;문제 설명 - Easy&lt;/h2&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, return &lt;em&gt;the inorder traversal of its nodes&amp;rsquo; values&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; root = &lt;code&gt;[1,null,3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[1,3,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img loading=&#34;lazy&#34; src=&#34;https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; root = &lt;code&gt;[1,2,3,4,5,null,null,null,7,9]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[4,2,6,5,7,1,3,9,8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img loading=&#34;lazy&#34; src=&#34;https://assets.leetcode.com/uploads/2024/08/29/tree_2.png&#34;&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; root = &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; root = &lt;code&gt;[1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is in the range &lt;code&gt;[0, 100]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it iteratively?&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 1 Two Sum</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-1-two-sum/</link>
      <pubDate>Thu, 23 Jan 2025 00:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-1-two-sum/</guid>
      <description>&lt;h2 id=&#34;문제-설명---easy&#34;&gt;문제 설명 - Easy&lt;/h2&gt;
&lt;p&gt;Given an array of integers &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;target&lt;/code&gt;, return &lt;em&gt;indices of the two numbers such that they add up to &lt;code&gt;target&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;&lt;em&gt;exactly&lt;/em&gt; one solution&lt;/strong&gt;, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;
&lt;p&gt;You can return the answer in any order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; nums = &lt;code&gt;[2,7,11,15]&lt;/code&gt;, target = 9
&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[0,1]&lt;/code&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; Because &lt;code&gt;nums[0] + nums[1] == 9&lt;/code&gt;, we return &lt;code&gt;[0, 1]&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 39 Combination Sum</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-39-combination-sum/</link>
      <pubDate>Thu, 23 Jan 2025 00:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-39-combination-sum/</guid>
      <description>&lt;h2 id=&#34;문제-설명---medium&#34;&gt;문제 설명 - Medium&lt;/h2&gt;
&lt;p&gt;Given an array of &lt;strong&gt;distinct&lt;/strong&gt; integers &lt;code&gt;candidates&lt;/code&gt; and a target integer &lt;code&gt;target&lt;/code&gt;, return &lt;em&gt;a list of all &lt;strong&gt;unique combinations&lt;/strong&gt; of&lt;/em&gt; &lt;code&gt;candidates&lt;/code&gt; &lt;em&gt;where the chosen numbers sum to&lt;/em&gt; &lt;code&gt;target&lt;/code&gt;&lt;em&gt;.&lt;/em&gt; You may return the combinations in &lt;strong&gt;any order&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;same&lt;/strong&gt; number may be chosen from &lt;code&gt;candidates&lt;/code&gt; an &lt;strong&gt;unlimited number of times&lt;/strong&gt;. Two combinations are unique if the frequency of at least one of the chosen numbers is different.&lt;/p&gt;</description>
    </item>
    <item>
      <title>leetcode 56 Merge Intervals</title>
      <link>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-56-merge-intervals/</link>
      <pubDate>Thu, 23 Jan 2025 00:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/01/23/leetcode-56-merge-intervals/</guid>
      <description>&lt;h2 id=&#34;문제-설명---medium&#34;&gt;문제 설명 - Medium&lt;/h2&gt;
&lt;p&gt;Given an array of &lt;code&gt;intervals&lt;/code&gt; where &lt;code&gt;intervals[i] = [starti, endi]&lt;/code&gt;, merge all overlapping intervals, and return &lt;em&gt;an array of the non-overlapping intervals that cover all the intervals in the input&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; intervals = &lt;code&gt;[[1,3],[2,6],[8,10],[15,18]]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[[1,6],[8,10],[15,18]]   **Explanation:** Since intervals &lt;/code&gt;[1,3]&lt;code&gt;and&lt;/code&gt;[2,6]&lt;code&gt;overlap, merge them into&lt;/code&gt;[1,6]`.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; intervals = &lt;code&gt;[[1,4],[4,5]] &lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Output:&lt;/strong&gt; &lt;code&gt;[[1,5]]  &lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Explanation:&lt;/strong&gt; Intervals &lt;code&gt;[1,4]&lt;/code&gt; and &lt;code&gt;[4,5]&lt;/code&gt; are considered overlapping.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= intervals.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intervals[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= starti &amp;lt;= endi &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;코드-풀이&#34;&gt;코드 풀이&lt;/h2&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;javascript&#34;&gt;Javascript&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;해설&#34;&gt;해설&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://school.programmers.co.kr/learn/challenges&#34;&gt;programmers Coding Test&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode.com/&#34;&gt;LeetCode - The World&amp;rsquo;s Leading Online Programming Learning Platform&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Software Architecture pattern vs Software Design Pattern</title>
      <link>https://buenhyden.github.io/til/2024/09/27/software-architecture-pattern-vs-software-design-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/27/software-architecture-pattern-vs-software-design-pattern/</guid>
      <description>Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다. 이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.</description>
    </item>
    <item>
      <title>WCS(Warehouse Control System)</title>
      <link>https://buenhyden.github.io/til/2024/12/03/warehouse-control-system/</link>
      <pubDate>Tue, 03 Dec 2024 06:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/03/warehouse-control-system/</guid>
      <description>WCS(Warehouse Control System)는 물류 창고의 자동화 설비를 실시간으로 제어하고 관리하는 시스템</description>
    </item>
    <item>
      <title>Connection Pool</title>
      <link>https://buenhyden.github.io/til/2024/10/25/connection-pool/</link>
      <pubDate>Fri, 25 Oct 2024 06:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/25/connection-pool/</guid>
      <description>&lt;h2 id=&#34;connection-pool&#34;&gt;Connection Pool&lt;/h2&gt;
&lt;p&gt;Connection pool(연결 풀)은 데이터베이스 연결을 효율적으로 관리하기 위한 기술이다.&lt;br&gt;
이 기술은 애플리케이션의 성능을 향상시키고 리소스 사용을 최적화하는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Connection pool은 데이터베이스 연결을 재사용 가능한 형태로 캐시하는 메커니즘이다.&lt;br&gt;
이는 애플리케이션이 데이터베이스에 연결할 때마다 새로운 연결을 생성하는 대신, 미리 생성된 연결을 사용할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;Connection pool은 현대 데이터베이스 애플리케이션에서 필수적인 기술로, 적절히 구현 및 설정될 경우 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Connection Pool&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/1_nU2n5j4EuBrApI1DWBp1TQ.webp&#34;&gt;&lt;figcaption&gt;https://medium.com/@sujoy.swe/database-connection-pool-647843dd250b&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;connection-pool의-작동-원리&#34;&gt;Connection Pool의 작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;초기화: 애플리케이션 시작 시 미리 정해진 수의 데이터베이스 연결을 생성하여 풀에 저장한다.&lt;/li&gt;
&lt;li&gt;연결 요청: 클라이언트가 데이터베이스 작업을 요청하면, 풀에서 사용 가능한 연결을 가져온다.&lt;/li&gt;
&lt;li&gt;연결 사용: 클라이언트는 가져온 연결을 사용하여 데이터베이스 작업을 수행한다.&lt;/li&gt;
&lt;li&gt;연결 반환: 작업이 완료되면 연결은 풀로 다시 반환된다.&lt;/li&gt;
&lt;li&gt;연결 관리: 풀은 연결의 수명주기를 관리하며, 필요에 따라 새로운 연결을 생성하거나 오래된 연결을 제거한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;connection-pool의-주요-설정-파라미터&#34;&gt;Connection Pool의 주요 설정 파라미터&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;초기 연결 수 (initialSize):&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decompose by Business Capability vs Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/til/2024/11/13/decompose-by-business-capability-vs-decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/13/decompose-by-business-capability-vs-decompose-by-subdomain/</guid>
      <description>&lt;h2 id=&#34;decompose-by-business-capability-vs-decompose-by-subdomain&#34;&gt;Decompose by Business Capability Vs Decompose by Subdomain&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Decompose by Business Capability&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 비즈니스의 기능적 역량을 중심으로 시스템을 분해하는 방식으로, 조직의 주요 기능(예: 판매, 마케팅, 고객 서비스 등)에 따라 모듈을 나누는 방법.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;비즈니스의 주요 역량을 중심으로 서비스나 모듈을 설계.&lt;/li&gt;
&lt;li&gt;시스템의 경계가 기능적인 책임(Functional Responsibility)에 맞춰 설정됨.&lt;/li&gt;
&lt;li&gt;기술적으로 독립적이고 명확한 책임 분리가 가능.&lt;/li&gt;
&lt;li&gt;조직 구조와 자연스럽게 연계되므로 비즈니스와 IT의 연계성이 높아짐.&lt;/li&gt;
&lt;li&gt;비즈니스의 장기적 확장성과 변화를 쉽게 수용할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;주문 관리 시스템(Order Management System)&lt;/strong&gt;, &lt;strong&gt;재고 관리 시스템(Inventory Management System)&lt;/strong&gt; 등으로 분할.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Decompose by Subdomain&lt;/p&gt;</description>
    </item>
    <item>
      <title>ER(Entity-Relationship) 모델링</title>
      <link>https://buenhyden.github.io/til/2024/10/25/entity-relationship-modeling/</link>
      <pubDate>Fri, 25 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/25/entity-relationship-modeling/</guid>
      <description>실제 세계의 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 표현하여 데이터베이스를 설계하는 방법</description>
    </item>
    <item>
      <title>Deadlock vs Livelock</title>
      <link>https://buenhyden.github.io/til/2024/10/05/deadlock-vs-livelock/</link>
      <pubDate>Sat, 05 Oct 2024 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/deadlock-vs-livelock/</guid>
      <description>데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다</description>
    </item>
    <item>
      <title>Mediator Pattern vs Observer Pattern</title>
      <link>https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/24/mediator-pattern-vs-observer-pattern/</guid>
      <description>&lt;h2 id=&#34;mediator-pattern-vs-observer-pattern&#34;&gt;Mediator Pattern Vs Observer Pattern&lt;/h2&gt;
&lt;p&gt;Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.&lt;/p&gt;
&lt;p&gt;Mediator 패턴:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴&lt;/li&gt;
&lt;li&gt;객체 간 결합도를 낮추고 상호작용을 중앙 집중화함&lt;/li&gt;
&lt;li&gt;복잡한 다대다 관계를 단순화하는 데 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Observer 패턴:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴&lt;/li&gt;
&lt;li&gt;주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함&lt;/li&gt;
&lt;li&gt;상태 변경에 대한 효율적인 알림 메커니즘을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 &lt;strong&gt;객체 간의 결합도를 줄이고 상호작용 로직을 집중&lt;/strong&gt;시키는 데 적합하다.
Observer 패턴은 상태 변화에 따른 &lt;strong&gt;자동 알림 및 실시간 동기화&lt;/strong&gt;를 구현할 때 적합하며, &lt;strong&gt;이벤트 기반 시스템&lt;/strong&gt;에 자주 사용된다.
두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, &lt;strong&gt;Mediator&lt;/strong&gt;는 상호작용을 캡슐화하고 &lt;strong&gt;Observer&lt;/strong&gt;는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Gateway</title>
      <link>https://buenhyden.github.io/til/2024/10/20/api-gateway/</link>
      <pubDate>Sun, 20 Oct 2024 09:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/api-gateway/</guid>
      <description>클라이언트와 백엔드 서비스 사이에서 중개자 역할을 하는 서버로, 여러 마이크로서비스나 백엔드 시스템에 대한 단일 진입점을 제공하는 중요한 컴포넌트</description>
    </item>
    <item>
      <title>System Test vs End-to-End Test</title>
      <link>https://buenhyden.github.io/til/2024/11/05/system-test-vs-end-to-end-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/system-test-vs-end-to-end-test/</guid>
      <description>System Testing과 End-to-End Testing은 소프트웨어 테스팅 과정에서 사용되는 두 가지 중요한 테스트 방법이다. 이 두 방법은 소프트웨어의 품질을 보장하기 위해 사용되지만, 그 범위와 목적에 차이가 있다.</description>
    </item>
    <item>
      <title>Elasticsearch and Opensearch</title>
      <link>https://buenhyden.github.io/til/2024/10/22/elasticsearch-and-opensearch/</link>
      <pubDate>Tue, 22 Oct 2024 06:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/elasticsearch-and-opensearch/</guid>
      <description>Elasticsearch는 Apache Lucene 기반의 오픈소스 검색엔진이며, Opensearch는 Elasticsearch의 포크 버전</description>
    </item>
    <item>
      <title>동적테스트(Dynamic Test) vs 정적테스트(Static Test)</title>
      <link>https://buenhyden.github.io/til/2024/11/05/dynamic-test-vs-static-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/dynamic-test-vs-static-test/</guid>
      <description>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.</description>
    </item>
    <item>
      <title>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</title>
      <link>https://buenhyden.github.io/til/2024/09/25/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/</link>
      <pubDate>Wed, 25 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/25/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/</guid>
      <description>소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리</description>
    </item>
    <item>
      <title>Javascript vs Node.js</title>
      <link>https://buenhyden.github.io/til/2024/11/23/javascript-vs-node.js/</link>
      <pubDate>Sat, 23 Nov 2024 09:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/23/javascript-vs-node.js/</guid>
      <description>&lt;h2 id=&#34;javascript-vs-nodejs&#34;&gt;Javascript Vs Node.js&lt;/h2&gt;
&lt;p&gt;JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.&lt;br&gt;
주요 특징은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;객체 기반의 스크립트 언어이다.&lt;/li&gt;
&lt;li&gt;동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다.&lt;/li&gt;
&lt;li&gt;이벤트 중심의 프로그래밍이 가능하다.&lt;/li&gt;
&lt;li&gt;웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다.&lt;/li&gt;
&lt;li&gt;프로토타입 기반의 객체지향 프로그래밍을 지원한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// JavaScript 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// DOM 조작
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;myButton&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addEventListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;alert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;버튼이 클릭되었습니다!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 비동기 처리
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;https://api.example.com/data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;****&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.&lt;br&gt;
주요 특징은 다음과 같다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>import vs require</title>
      <link>https://buenhyden.github.io/til/2024/11/23/import-vs-require/</link>
      <pubDate>Sat, 23 Nov 2024 03:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/23/import-vs-require/</guid>
      <description>&lt;h2 id=&#34;import-vs-require&#34;&gt;Import Vs Require&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt;는 Node.js에서 사용되는 CommonJS 모듈 시스템의 키워드로, 동기적으로 모듈을 로드하며 프로그램의 어느 지점에서나 호출할 수 있다. 반면에 &lt;code&gt;import&lt;/code&gt;는 ES6에서 도입된 모듈 시스템의 키워드로, 코드 실행 전에 모듈을 미리 로드하며 파일의 시작 부분에서만 사용할 수 있다. 따라서 프로젝트의 환경과 요구 사항에 따라 적절한 키워드를 선택하여 사용하는 것이 중요하다.&lt;/p&gt;
&lt;h3 id=&#34;import-es-modules&#34;&gt;Import (ES Modules)&lt;/h3&gt;
&lt;p&gt;ES6(ES2015)에서 도입된 모듈 시스템으로, JavaScript의 공식 표준 모듈 시스템. 정적 임포트 방식을 사용하며, 브라우저에서 기본적으로 지원된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 기본 가져오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 부분 가져오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;function1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;function2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 모든 것을 객체로 가져오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;moduleObject&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 이름 변경하여 가져오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;originalName&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 가져오기와 실행만 하기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;require-commonjs&#34;&gt;Require (CommonJS)&lt;/h3&gt;
&lt;p&gt;Node.js에서 기본적으로 사용되는 모듈 시스템으로, 동적 임포트를 지원한다. 런타임에 모듈을 로드할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Web Application Server (WAS) and Web Server</title>
      <link>https://buenhyden.github.io/til/2024/10/22/web-application-server-and-web-server/</link>
      <pubDate>Tue, 22 Oct 2024 07:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/web-application-server-and-web-server/</guid>
      <description>Web Application Server와 Web Server 비교 분석한다.</description>
    </item>
    <item>
      <title>Message Queue vs Message Broker vs Event Broker</title>
      <link>https://buenhyden.github.io/til/2024/10/22/message-queue-vs-message-broker-vs-event-broker/</link>
      <pubDate>Tue, 22 Oct 2024 07:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/22/message-queue-vs-message-broker-vs-event-broker/</guid>
      <description>Message Queue의 Event Broker와 Message Broker를 비교한다.</description>
    </item>
    <item>
      <title>Cache Strategy vs Cache Policy</title>
      <link>https://buenhyden.github.io/til/2024/09/30/cache-strategy-vs-cache-policy/</link>
      <pubDate>Mon, 30 Sep 2024 15:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/30/cache-strategy-vs-cache-policy/</guid>
      <description>&lt;h2 id=&#34;cache-strategy-vs-cache-policy&#34;&gt;Cache Strategy vs Cache Policy&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Von Neumann Architecture vs Harvard Architecture</title>
      <link>https://buenhyden.github.io/til/2024/09/29/von-neumann-architecture-vs-harvard-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 05:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/29/von-neumann-architecture-vs-harvard-architecture/</guid>
      <description>하버드 아키텍처(Harvard Architecture)와 폰 노이만 아키텍처(von Neumann Architecture)는 컴퓨터 시스템의 메모리 구조를 정의하는 두 가지 대표적인 설계 방식이다.</description>
    </item>
    <item>
      <title>QA vs QC vs Testing</title>
      <link>https://buenhyden.github.io/til/2024/11/05/quality-assurance-vs-quality-control-vs-testing/</link>
      <pubDate>Tue, 05 Nov 2024 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/quality-assurance-vs-quality-control-vs-testing/</guid>
      <description>Quality Assurance (QA)는 제품이나 서비스의 품질을 보장하기 위한 계획적이고 체계적인 활동들의 집합이며, Quality Control (QC)는 개발된 제품이나 서비스가 정해진 품질 기준을 충족하는지 확인하는 활동이고, Testing은 소프트웨어가 예상대로 작동하는지 확인하는 구체적인 실행 활동이다.</description>
    </item>
    <item>
      <title>Java Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/concepts/keywords/</link>
      <pubDate>Wed, 29 Jan 2025 02:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/concepts/keywords/</guid>
      <description>&lt;h2 id=&#34;keyword&#34;&gt;Keyword&lt;/h2&gt;
&lt;p&gt;키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.&lt;br&gt;
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.&lt;br&gt;
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.&lt;/p&gt;
&lt;p&gt;각 키워드의 특징과 주의사항:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;모든 키워드는 소문자로만 작성된다.&lt;/li&gt;
&lt;li&gt;키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다.&lt;/li&gt;
&lt;li&gt;일부 키워드는 특정 컨텍스트에서만 의미를 가진다.&lt;/li&gt;
&lt;li&gt;예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;데이터-타입-키워드&#34;&gt;데이터 타입 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;byte&lt;/td&gt;
          &lt;td&gt;8비트 정수형 (-128 ~ 127)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;byte b = 100;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;short&lt;/td&gt;
          &lt;td&gt;16비트 정수형 (-32,768 ~ 32,767)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;short s = 1000;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;int&lt;/td&gt;
          &lt;td&gt;32비트 정수형&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;int i = 10000;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;long&lt;/td&gt;
          &lt;td&gt;64비트 정수형&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;long l = 100000L;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;float&lt;/td&gt;
          &lt;td&gt;32비트 단정도 실수형&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;float f = 3.14f;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;double&lt;/td&gt;
          &lt;td&gt;64비트 배정도 실수형&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;double d = 3.14159;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;boolean&lt;/td&gt;
          &lt;td&gt;논리형 (true/false)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;boolean flag = true;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;char&lt;/td&gt;
          &lt;td&gt;16비트 유니코드 문자&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;char c = &#39;A&#39;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;void&lt;/td&gt;
          &lt;td&gt;반환값이 없음을 나타냄&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;void method() {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;제어문-키워드&#34;&gt;제어문 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;if&lt;/td&gt;
          &lt;td&gt;조건문 시작&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;if (x &amp;gt; 0) {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;else&lt;/td&gt;
          &lt;td&gt;if문의 대안 경로&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;else {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;switch&lt;/td&gt;
          &lt;td&gt;다중 분기문 시작&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;switch(value) {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;case&lt;/td&gt;
          &lt;td&gt;switch문의 각 경우&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;case 1:&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;default&lt;/td&gt;
          &lt;td&gt;switch문의 기본 경우&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;default:&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;for&lt;/td&gt;
          &lt;td&gt;반복문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;for (int i = 0; i &amp;lt; n; i++)&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;while&lt;/td&gt;
          &lt;td&gt;조건 기반 반복문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;while (condition)&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;do&lt;/td&gt;
          &lt;td&gt;do-while 반복문 시작&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;do {} while();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;break&lt;/td&gt;
          &lt;td&gt;반복문/switch문 탈출&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;break;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;continue&lt;/td&gt;
          &lt;td&gt;현재 반복 건너뛰기&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;continue;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;return&lt;/td&gt;
          &lt;td&gt;메소드에서 값 반환/종료&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;return value;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;클래스-관련-키워드&#34;&gt;클래스 관련 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;class&lt;/td&gt;
          &lt;td&gt;클래스 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;public class MyClass {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;interface&lt;/td&gt;
          &lt;td&gt;인터페이스 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;interface MyInterface {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;extends&lt;/td&gt;
          &lt;td&gt;클래스/인터페이스 상속&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;class Child extends Parent {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;implements&lt;/td&gt;
          &lt;td&gt;인터페이스 구현&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;class MyClass implements Interface {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;enum&lt;/td&gt;
          &lt;td&gt;열거형 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;enum Direction {NORTH, SOUTH}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;this&lt;/td&gt;
          &lt;td&gt;현재 인스턴스 참조&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;this.value = value;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;super&lt;/td&gt;
          &lt;td&gt;상위 클래스 참조&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;super.method();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;new&lt;/td&gt;
          &lt;td&gt;객체 생성&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;new Object();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;instanceof&lt;/td&gt;
          &lt;td&gt;객체 타입 검사&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;obj instanceof String&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;접근-제어-키워드&#34;&gt;접근 제어 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;public&lt;/td&gt;
          &lt;td&gt;전체 접근 허용&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;public class Public {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;private&lt;/td&gt;
          &lt;td&gt;클래스 내부만 접근 가능&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;private int value;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;protected&lt;/td&gt;
          &lt;td&gt;패키지와 자식 클래스 접근 가능&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;protected void method() {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;default&lt;/td&gt;
          &lt;td&gt;패키지 내부만 접근 가능&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;int value;&lt;/code&gt; (키워드 생략)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;제어자-키워드&#34;&gt;제어자 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;static&lt;/td&gt;
          &lt;td&gt;클래스 레벨 멤버 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;static int count;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;final&lt;/td&gt;
          &lt;td&gt;변경 불가 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;final int MAX = 100;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;abstract&lt;/td&gt;
          &lt;td&gt;추상 클래스/메소드 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;abstract class Abstract {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;synchronized&lt;/td&gt;
          &lt;td&gt;스레드 동기화&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;synchronized void method() {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;volatile&lt;/td&gt;
          &lt;td&gt;메모리 직접 접근 변수&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;volatile boolean flag;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;transient&lt;/td&gt;
          &lt;td&gt;직렬화 제외 필드&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;transient int temp;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;native&lt;/td&gt;
          &lt;td&gt;네이티브 메소드 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;native void method();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;strictfp&lt;/td&gt;
          &lt;td&gt;엄격한 부동소수점 연산&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;strictfp class Math {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;예외-처리-키워드&#34;&gt;예외 처리 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;try&lt;/td&gt;
          &lt;td&gt;예외 발생 가능 블록&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;try {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;catch&lt;/td&gt;
          &lt;td&gt;예외 처리 블록&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;catch (Exception e) {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;finally&lt;/td&gt;
          &lt;td&gt;항상 실행되는 블록&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;finally {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;throw&lt;/td&gt;
          &lt;td&gt;예외 발생&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;throw new Exception();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;throws&lt;/td&gt;
          &lt;td&gt;예외 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;void method() throws Exception {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;assert&lt;/td&gt;
          &lt;td&gt;조건 검증&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;assert x &amp;gt; 0;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;패키지-관련-키워드&#34;&gt;패키지 관련 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;package&lt;/td&gt;
          &lt;td&gt;패키지 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;package com.example;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;import&lt;/td&gt;
          &lt;td&gt;클래스 임포트&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;import java.util.List;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;리터럴-키워드&#34;&gt;리터럴 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;true&lt;/td&gt;
          &lt;td&gt;논리 참 값&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;boolean t = true;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;false&lt;/td&gt;
          &lt;td&gt;논리 거짓 값&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;boolean f = false;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;null&lt;/td&gt;
          &lt;td&gt;참조 없음&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Object obj = null;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;예약된-키워드-미사용&#34;&gt;예약된 키워드 (미사용)&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;const&lt;/td&gt;
          &lt;td&gt;상수 (사용되지 않음)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;goto&lt;/td&gt;
          &lt;td&gt;이동 (사용되지 않음)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>SEO(Search Engine Optimization)</title>
      <link>https://buenhyden.github.io/til/2024/12/02/seo/</link>
      <pubDate>Mon, 02 Dec 2024 12:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/seo/</guid>
      <description>검색 엔진 최적화를 의미하며, 웹사이트나 콘텐츠를 검색 엔진의 검색 결과에서 상위에 노출시키기 위한 전략과 기술</description>
    </item>
    <item>
      <title>DOM</title>
      <link>https://buenhyden.github.io/til/2024/12/02/dom/</link>
      <pubDate>Mon, 02 Dec 2024 06:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/dom/</guid>
      <description>HTML이나 XML 문서의 구조를 표현하는 프로그래밍 인터페이스.</description>
    </item>
    <item>
      <title>CSR</title>
      <link>https://buenhyden.github.io/til/2024/12/02/csr/</link>
      <pubDate>Mon, 02 Dec 2024 03:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/csr/</guid>
      <description>웹 애플리케이션에서 클라이언트 측, 즉 사용자의 웹 브라우저에서 JavaScript를 사용하여 웹 페이지를 렌더링하는 방식</description>
    </item>
    <item>
      <title>SSR</title>
      <link>https://buenhyden.github.io/til/2024/12/02/ssr/</link>
      <pubDate>Mon, 02 Dec 2024 03:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/12/02/ssr/</guid>
      <description>웹 페이지의 초기 로드 시 서버에서 페이지를 렌더링하여 클라이언트에게 전달하는 웹 렌더링 기술</description>
    </item>
    <item>
      <title>LESS</title>
      <link>https://buenhyden.github.io/posts/frontend/stylesheet/less/</link>
      <pubDate>Sun, 01 Dec 2024 06:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend/stylesheet/less/</guid>
      <description>LESS는 CSS를 더 효율적으로 작성할 수 있게 해주는 전처리기(preprocessor)</description>
    </item>
    <item>
      <title>PostCSS</title>
      <link>https://buenhyden.github.io/posts/frontend/stylesheet/postcss/</link>
      <pubDate>Sun, 01 Dec 2024 06:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend/stylesheet/postcss/</guid>
      <description>JavaScript 플러그인을 사용하여 CSS를 변환하는 강력한 도구</description>
    </item>
    <item>
      <title>SASS</title>
      <link>https://buenhyden.github.io/posts/frontend/stylesheet/sass/</link>
      <pubDate>Sun, 01 Dec 2024 06:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend/stylesheet/sass/</guid>
      <description>Sass는 CSS를 더 강력하고 우아하게 작성할 수 있게 해주는 전처리기</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://buenhyden.github.io/posts/frontend/stylesheet/css/</link>
      <pubDate>Sun, 01 Dec 2024 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend/stylesheet/css/</guid>
      <description>웹 페이지의 스타일과 레이아웃을 정의하는 스타일 시트 언어</description>
    </item>
    <item>
      <title>SQLAlchemy</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/orm/sqlalchemy/</link>
      <pubDate>Sat, 30 Nov 2024 09:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/orm/sqlalchemy/</guid>
      <description>파이썬에서 사용되는 강력하고 유연한 SQL 툴킷 및 객체 관계 매핑(ORM) 라이브러리</description>
    </item>
    <item>
      <title>daphne</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/daphne/</link>
      <pubDate>Sat, 30 Nov 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/daphne/</guid>
      <description>Daphne는 Django Channels를 위해 개발된 HTTP, HTTP2 및 WebSocket 프로토콜 서버이다.</description>
    </item>
    <item>
      <title>uvicorn</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uvicorn/</link>
      <pubDate>Sat, 30 Nov 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uvicorn/</guid>
      <description>Uvicorn은 Python용 ASGI(Asynchronous Server Gateway Interface) 웹 서버 구현체이다.</description>
    </item>
    <item>
      <title>Modin</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/modin/</link>
      <pubDate>Sat, 30 Nov 2024 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/modin/</guid>
      <description>pandas를 대체할 수 있는 고성능 데이터프레임 라이브러리</description>
    </item>
    <item>
      <title>Dask</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/dask/</link>
      <pubDate>Sat, 30 Nov 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/dask/</guid>
      <description>파이썬을 위한 유연한 병렬 컴퓨팅 라이브러리</description>
    </item>
    <item>
      <title>Polars</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/</link>
      <pubDate>Sat, 30 Nov 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/</guid>
      <description>고성능 데이터 처리를 위해 설계된 파이썬 DataFrame 라이브러리</description>
    </item>
    <item>
      <title>Numpy</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/numpy/</link>
      <pubDate>Sat, 30 Nov 2024 07:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/numpy/</guid>
      <description>파이썬에서 과학 계산을 위한 핵심 라이브러리.</description>
    </item>
    <item>
      <title>Celery</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/queue/celery/</link>
      <pubDate>Sat, 30 Nov 2024 07:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/queue/celery/</guid>
      <description>&lt;h2 id=&#34;celery&#34;&gt;Celery&lt;/h2&gt;
&lt;p&gt;Celery는 파이썬으로 작성된 분산 작업 큐 시스템이다.&lt;br&gt;
주로 웹 애플리케이션에서 비동기 작업 처리와 작업 스케줄링을 위해 사용된다.&lt;/p&gt;
&lt;p&gt;Celery는 파이썬으로 작성된 비동기 작업 큐/작업 스케줄러이다. 분산 메시지 전달을 기반으로 동작하며, 실시간 처리와 작업 스케줄링을 지원한다.&lt;/p&gt;
&lt;p&gt;주요 역할:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비동기 작업 처리&lt;/li&gt;
&lt;li&gt;실시간 작업 처리&lt;/li&gt;
&lt;li&gt;예약된 작업 실행&lt;/li&gt;
&lt;li&gt;분산 시스템에서의 작업 관리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Celery는 복잡한 비동기 작업 처리와 분산 시스템 구축에 매우 유용한 도구이다.&lt;br&gt;
웹 애플리케이션의 성능을 향상시키고 확장성을 높이는 데 큰 도움이 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pandas</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/pandas/</link>
      <pubDate>Sat, 30 Nov 2024 05:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/pandas/</guid>
      <description>데이터를 다루기 위한 강력한 도구로, 엑셀의 스프레드시트와 비슷한 형태로 데이터를 처리할 수 있게 해준다.</description>
    </item>
    <item>
      <title>gunicorn</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/gunicorn/</link>
      <pubDate>Sat, 30 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/gunicorn/</guid>
      <description>Gunicorn(Green Unicorn)은 Python WSGI(Web Server Gateway Interface) HTTP 서버로, 파이썬 웹 애플리케이션을 위한 강력하고 효율적인 서버 솔루션이다.</description>
    </item>
    <item>
      <title>UWSGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/</link>
      <pubDate>Sat, 30 Nov 2024 03:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/</guid>
      <description>파이썬 웹 애플리케이션을 위한 강력하고 유연한 애플리케이션 서버</description>
    </item>
    <item>
      <title>pydantic</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-validation/pydantic/</link>
      <pubDate>Sat, 30 Nov 2024 03:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-validation/pydantic/</guid>
      <description>데이터 검증과 설정 관리를 위한 라이브러리</description>
    </item>
    <item>
      <title>Pytest</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/testing/pytest/</link>
      <pubDate>Fri, 29 Nov 2024 23:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/testing/pytest/</guid>
      <description>파이썬을 위한 강력하고 유연한 테스트 프레임워크</description>
    </item>
    <item>
      <title>Unittest</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/testing/unittest/</link>
      <pubDate>Fri, 29 Nov 2024 23:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/testing/unittest/</guid>
      <description>파이썬의 표준 라이브러리에 포함된 단위 테스트 프레임워크</description>
    </item>
    <item>
      <title>Greenlet and Gevent</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/</link>
      <pubDate>Fri, 29 Nov 2024 05:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/</guid>
      <description>Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.</description>
    </item>
    <item>
      <title>Starlette</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/starlette/</link>
      <pubDate>Fri, 29 Nov 2024 03:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/starlette/</guid>
      <description>고성능 비동기 웹 애플리케이션을 구축하기 위한 경량 ASGI 프레임워크</description>
    </item>
    <item>
      <title>Django</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/django/</link>
      <pubDate>Fri, 29 Nov 2024 02:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/django/</guid>
      <description>웹 개발에 필요한 모든 요소를 포함하는 풀 스택 프레임워크</description>
    </item>
    <item>
      <title>Flask</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/flask/</link>
      <pubDate>Fri, 29 Nov 2024 02:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/flask/</guid>
      <description>&amp;#34;마이크로 프레임워크&amp;#34;라고 불리는 Flask는 핵심 기능만을 가볍게 유지하면서도 필요에 따라 확장할 수 있는 유연한 구조를 제공한다.</description>
    </item>
    <item>
      <title>FastAPI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/fastapi/</link>
      <pubDate>Fri, 29 Nov 2024 02:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/fastapi/</guid>
      <description>Python 3.6&#43; 의 타입 힌트를 기반으로 하며, 비동기 프로그래밍을 지원하는 고성능 웹 프레임워크</description>
    </item>
    <item>
      <title>ruff</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/ruff/</link>
      <pubDate>Thu, 28 Nov 2024 08:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/ruff/</guid>
      <description>Python 코드 품질을 개선하기 위한 린터</description>
    </item>
    <item>
      <title>autopep8</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/autopep8/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/autopep8/</guid>
      <description>Python 코드를 PEP 8 스타일 가이드라인에 맞게 자동으로 포맷팅해주는 도구</description>
    </item>
    <item>
      <title>Black</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/black/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/black/</guid>
      <description>파이썬을 위한 강력하고 엄격한 코드 포매터</description>
    </item>
    <item>
      <title>Flake8</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/flake8/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/flake8/</guid>
      <description>파이썬 코드를 위한 강력한 린팅(linting) 도구</description>
    </item>
    <item>
      <title>YAPF(Yet Another Python Formatter)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/yapf/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/yapf/</guid>
      <description>Google에서 개발한 파이썬 코드 포매터.</description>
    </item>
    <item>
      <title>Pylint</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/pylint/</link>
      <pubDate>Thu, 28 Nov 2024 03:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/linter-and-formatter/pylint/</guid>
      <description>파이썬 코드의 품질을 검사하고 개선하는데 도움을 주는 강력한 정적 코드 분석 도구</description>
    </item>
    <item>
      <title>ASGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/asgi/</link>
      <pubDate>Thu, 28 Nov 2024 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/asgi/</guid>
      <description>Python 웹 애플리케이션과 웹 서버 간의 비동기 통신을 위한 표준 인터페이스</description>
    </item>
    <item>
      <title>CGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/cgi/</link>
      <pubDate>Thu, 28 Nov 2024 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/cgi/</guid>
      <description>웹 서버와 외부 프로그램 간의 통신을 위한 표준 인터페이스</description>
    </item>
    <item>
      <title>WSGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/wsgi/</link>
      <pubDate>Thu, 28 Nov 2024 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/gateway-interface/wsgi/</guid>
      <description>파이썬 웹 애플리케이션과 웹 서버 간의 표준 인터페이스를 정의하는 규약</description>
    </item>
    <item>
      <title>setup.cfg</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/configuration/setup.cfg/</link>
      <pubDate>Wed, 27 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/configuration/setup.cfg/</guid>
      <description>파이썬 프로젝트의 설정을 관리하는 구성 파일</description>
    </item>
    <item>
      <title>Poetry Configuration</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-configuration/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-configuration/</guid>
      <description>`config` 명령어나 `config.toml` 파일을 통해 설정할 수 있다.</description>
    </item>
    <item>
      <title>Poetry Libraries</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-libraries/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-libraries/</guid>
      <description>Poetry는 파이썬 라이브러리를 효율적으로 관리하고 배포할 수 있도록 지원하는 도구로 라이브러리를 설치 가능하게 만들기 위해 다음과 같은 절차를 따를 수 있다.</description>
    </item>
    <item>
      <title>Poetry Managing dependencies</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-managing-dependencies/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-managing-dependencies/</guid>
      <description>Poetry는 의존성을 효율적으로 관리하기 위해 다양한 기능을 제공한다.</description>
    </item>
    <item>
      <title>Poetry Usage</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-usage/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/poetry/poetry-usage/</guid>
      <description>Python 프로젝트의 의존성 관리와 패키징을 위한 도구</description>
    </item>
    <item>
      <title>The pyproject.toml file</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/configuration/the-pyproject.toml-file/</link>
      <pubDate>Wed, 27 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/configuration/the-pyproject.toml-file/</guid>
      <description>Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일</description>
    </item>
    <item>
      <title>Rye</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/rye/</link>
      <pubDate>Wed, 27 Nov 2024 04:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/rye/</guid>
      <description>Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.</description>
    </item>
    <item>
      <title>PEP 20–The Zen of Python</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/</guid>
      <description>파이썬의 철학과 디자인 원칙을 담고 있는 19개의 지침.</description>
    </item>
    <item>
      <title>PEP 257–Docstring Conventions</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/</guid>
      <description>Python 코드의 docstring 작성에 대한 규칙과 관례를 정의한 문서</description>
    </item>
    <item>
      <title>PEP 3000–Python 3000</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/</guid>
      <description>Python 3000 (Python 3.0 또는 Py3k로도 알려짐) 개발에 대한 가이드라인을 제시하는 문서</description>
    </item>
    <item>
      <title>PEP 3333–Python Web Server Gateway Interface V1.0.1</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/</guid>
      <description>Python Web Server Gateway Interface (WSGI) 버전 1.0.1을 정의하는 문서</description>
    </item>
    <item>
      <title>PEP 484–Type Hints</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/</guid>
      <description>Python에 타입 힌트(Type Hints)를 도입하여 함수의 인자와 반환값에 대한 타입을 명시할 수 있도록 하는 표준을 정의</description>
    </item>
    <item>
      <title>PEP 492–Coroutines with Async and Await Syntax</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/</guid>
      <description>Python에 비동기 프로그래밍을 위한 async와 await 구문을 도입하여 코루틴(coroutine)을 명시적으로 정의하고 사용하는 방법을 제안</description>
    </item>
    <item>
      <title>PEP 8-Style Guide for Python Code</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-8-style-guide-for-python-code/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-8-style-guide-for-python-code/</guid>
      <description>Python 코드의 스타일 가이드로, 가독성과 일관성을 높이기 위한 다양한 규칙과 권장사항을 제시</description>
    </item>
    <item>
      <title>Python-Special Methods</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/special-methods/</link>
      <pubDate>Mon, 25 Nov 2024 23:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/special-methods/</guid>
      <description>클래스에 특별한 기능을 부여하는 특수한 메소드</description>
    </item>
    <item>
      <title>Python - Iterators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/iterators/</link>
      <pubDate>Mon, 25 Nov 2024 17:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/iterators/</guid>
      <description>데이터 컬렉션의 요소들을 순차적으로 접근할 수 있게 해주는 객체</description>
    </item>
    <item>
      <title>Python Super</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/super/</link>
      <pubDate>Mon, 25 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/super/</guid>
      <description>super()는 상속 관계에서 부모 클래스의 메서드를 호출하는 데 사용되는 중요한 도구.</description>
    </item>
    <item>
      <title>Method Resolution Order (MRO)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/method-resolution-order/</link>
      <pubDate>Mon, 25 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/class/method-resolution-order/</guid>
      <description>파이썬에서 클래스의 상속 관계에서 메서드를 찾는 순서를 정의하는 규칙</description>
    </item>
    <item>
      <title>classmethod and staticmethod</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/decorators/classmethod-and-staticmethod/</link>
      <pubDate>Sun, 24 Nov 2024 12:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/decorators/classmethod-and-staticmethod/</guid>
      <description>Python의 클래스에서 사용되는 두 가지 다른 종류의 메서드 데코레이터</description>
    </item>
    <item>
      <title>Python Lambda</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/function/lambda/</link>
      <pubDate>Sun, 24 Nov 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/function/lambda/</guid>
      <description>익명 함수를 생성하는 강력한 도구</description>
    </item>
    <item>
      <title>Python Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/keywords/</link>
      <pubDate>Sun, 24 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/keywords/</guid>
      <description>파이썬에서 이미 예약되어있는 문자열</description>
    </item>
    <item>
      <title>Generator and Iterator</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/generator-and-iterator/</link>
      <pubDate>Sun, 24 Nov 2024 10:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/generator-and-iterator/</guid>
      <description>이터레이터는 값을 차례대로 반환하는 객체로, `__iter__()`와 `__next__()` 메서드를 구현한다.  제너레이터는 `yield` 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.</description>
    </item>
    <item>
      <title>Python - Generators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/function/generators/</link>
      <pubDate>Sun, 24 Nov 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/function/generators/</guid>
      <description>반복 가능한 객체를 생성하는 강력한 도구</description>
    </item>
    <item>
      <title>Python GIL</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/python-gil/</link>
      <pubDate>Sun, 24 Nov 2024 08:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/python-gil/</guid>
      <description>Python 객체에 대한 접근을 제어하는 뮤텍스(mutex)로, 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 보장</description>
    </item>
    <item>
      <title>내장 데코레이터 (Built-in Decorators)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/decorators/built-in-decorators/</link>
      <pubDate>Sun, 24 Nov 2024 07:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/decorators/built-in-decorators/</guid>
      <description>파이썬에는 다양한 내장 데코레이터가 있으며, 이들은 코드를 최적화하고 기능을 확장하는 데 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Docstring</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/docstring/</link>
      <pubDate>Sun, 24 Nov 2024 03:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/docstring/</guid>
      <description>python에서 함수, 클래스, 모듈에 대한 문서화를 위해 사용되는 문자열</description>
    </item>
    <item>
      <title>Operators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/concepts/operators/</link>
      <pubDate>Sun, 24 Nov 2024 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/concepts/operators/</guid>
      <description>연산자는 프로그래밍의 기본적인 구성 요소로, 데이터를 조작하고 계산하는 데 사용된다.</description>
    </item>
    <item>
      <title>NodeJS</title>
      <link>https://buenhyden.github.io/til/2024/11/23/nodejs/</link>
      <pubDate>Sat, 23 Nov 2024 04:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/23/nodejs/</guid>
      <description>Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경</description>
    </item>
    <item>
      <title>Cypress</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/cypress/</link>
      <pubDate>Fri, 22 Nov 2024 23:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/cypress/</guid>
      <description>Cypress는 JavaScript 기반의 강력한 프론트엔드 테스팅 프레임워크.</description>
    </item>
    <item>
      <title>Jest</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/jest/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/jest/</guid>
      <description>JavaScript 테스팅 프레임워크로, JavaScript 코드의 단위 테스트(Unit Test)를 위해 설계되었다.</description>
    </item>
    <item>
      <title>MochaJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/mochajs/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/mochajs/</guid>
      <description>Mocha.js는 Node.js와 브라우저 환경 모두에서 동작하는 유연하고 강력한 JavaScript 코드의 단위 테스트, 통합 테스트 등을 위한 JavaScript 테스팅 프레임워크.</description>
    </item>
    <item>
      <title>Playwright</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/playwright/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/playwright/</guid>
      <description>Playwright는 Microsoft에서 개발한 현대적이고 강력한 웹 자동화 및 테스팅 라이브러리</description>
    </item>
    <item>
      <title>Puppeteer</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/puppeteer/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/puppeteer/</guid>
      <description>Google에서 개발한 Node.js 라이브러리로, 프로그래밍을 통해 Chrome 또는 Chromium 브라우저를 제어할 수 있게 해주는 고급 웹 자동화 도구</description>
    </item>
    <item>
      <title>Fastify</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/fastify/</link>
      <pubDate>Fri, 22 Nov 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/fastify/</guid>
      <description>Fastify는 Node.js를 위한 빠르고 낮은 오버헤드의 웹 프레임워크</description>
    </item>
    <item>
      <title>Koa</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/koa/</link>
      <pubDate>Fri, 22 Nov 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/koa/</guid>
      <description>Node.js를 위한 경량 웹 프레임워크로, Express.js 팀에 의해 개발되었다. Koa는 더 작고, 더 표현력이 풍부하며, 더 강력한 웹 애플리케이션과 API의 기초를 제공하기 위해 설계되었다.</description>
    </item>
    <item>
      <title>NextJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/nextjs/</link>
      <pubDate>Fri, 22 Nov 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/nextjs/</guid>
      <description>NextJS는 React 기반의 풀스택 웹 프레임워크로, React의 장점을 모두 활용하면서도, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)과 같은 고급 기능들을 손쉽게 구현할 수 있게 해준다.</description>
    </item>
    <item>
      <title>jasmine</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/jasmine/</link>
      <pubDate>Fri, 22 Nov 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/jasmine/</guid>
      <description>Jasmine은 JavaScript 애플리케이션을 위한 행위 주도 개발(BDD) 스타일의 테스팅 프레임워크</description>
    </item>
    <item>
      <title>Karma</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/testing/karma/</link>
      <pubDate>Fri, 22 Nov 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/testing/karma/</guid>
      <description>Karma는 모든 브라우저에서 JavaScript 코드를 테스트할 수 있게 해주는 테스트 러너이다.</description>
    </item>
    <item>
      <title>VueJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/vuejs/</link>
      <pubDate>Fri, 22 Nov 2024 04:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/vuejs/</guid>
      <description>Vue.js는 사용자 인터페이스를 구축하기 위한 진보적이고 가벼운 JavaScript 프레임워크이다.</description>
    </item>
    <item>
      <title>ExpressJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/expressjs/</link>
      <pubDate>Fri, 22 Nov 2024 03:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/expressjs/</guid>
      <description>Express.js는 Node.js를 위한 빠르고 개방적인 웹 프레임워크</description>
    </item>
    <item>
      <title>NestJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/nestjs/</link>
      <pubDate>Fri, 22 Nov 2024 01:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/web-framework/nestjs/</guid>
      <description>Nest.js는 효율적이고 확장 가능한 Node.js 서버 측 애플리케이션을 구축하기 위한 프레임워크</description>
    </item>
    <item>
      <title>winston</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/package/winston/</link>
      <pubDate>Thu, 21 Nov 2024 15:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/package/winston/</guid>
      <description>Winston은 Node.js 애플리케이션을 위한 다목적 로깅 라이브러리</description>
    </item>
    <item>
      <title>pino</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/package/pino/</link>
      <pubDate>Thu, 21 Nov 2024 15:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/package/pino/</guid>
      <description>Node.js를 위한 매우 빠르고 가벼운 로깅 라이브러리</description>
    </item>
    <item>
      <title>Mongoose</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/package/mongoose/</link>
      <pubDate>Thu, 21 Nov 2024 15:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/package/mongoose/</guid>
      <description>MongoDB와 Node.js 애플리케이션을 연결해주는 강력한 Object Document Mapper(ODM) 라이브러리</description>
    </item>
    <item>
      <title>Sequelize</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/package/sequelize/</link>
      <pubDate>Thu, 21 Nov 2024 15:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/package/sequelize/</guid>
      <description>Node.js 환경에서 사용되는 강력한 ORM(Object-Relational Mapping) 라이브러리</description>
    </item>
    <item>
      <title>Biome</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/biome/</link>
      <pubDate>Thu, 21 Nov 2024 15:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/biome/</guid>
      <description>JavaScript, TypeScript, JSX, TSX, JSON, CSS, GraphQL 등 다양한 웹 개발 언어를 위한 빠른 포매터이자 린터</description>
    </item>
    <item>
      <title>eslint</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/eslint/</link>
      <pubDate>Thu, 21 Nov 2024 15:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/eslint/</guid>
      <description>JavaScript 코드 분석 도구로, 코드의 품질을 향상시키고 잠재적인 문제를 미리 발견하는 것이 주요 목적</description>
    </item>
    <item>
      <title>prettier</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/prettier/</link>
      <pubDate>Thu, 21 Nov 2024 15:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/linter-and-formatter/prettier/</guid>
      <description>JavaScript를 포함한 여러 웹 개발 언어를 위한 강력한 코드 포매터</description>
    </item>
    <item>
      <title>프로미스(Promise)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/promise/</link>
      <pubDate>Thu, 21 Nov 2024 14:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/promise/</guid>
      <description>자바스크립트에서 비동기 처리를 위해 사용되는 객체</description>
    </item>
    <item>
      <title>Event Loop</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/</link>
      <pubDate>Thu, 21 Nov 2024 12:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/</guid>
      <description>이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.</description>
    </item>
    <item>
      <title>pm2</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/package/pm2/</link>
      <pubDate>Thu, 21 Nov 2024 12:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/package/pm2/</guid>
      <description>PM2는 Node.js 애플리케이션을 위한 고급 프로덕션 프로세스 관리자.</description>
    </item>
    <item>
      <title>jsdoc</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/jsdoc/</link>
      <pubDate>Thu, 21 Nov 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/jsdoc/</guid>
      <description>JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.</description>
    </item>
    <item>
      <title>Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/keywords/</link>
      <pubDate>Thu, 21 Nov 2024 03:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/concepts/keywords/</guid>
      <description>&lt;h2 id=&#34;keywords&#34;&gt;Keywords&lt;/h2&gt;
&lt;p&gt;키워드들은 JavaScript 프로그래밍의 기본 구성 요소이며, ECMAScript 표준의 일부이다.&lt;br&gt;
각 키워드는 특정한 프로그래밍 목적을 위해 설계되었으며, 이들을 올바르게 이해하고 사용하는 것이 효과적인 JavaScript 프로그래밍의 기초가 된다.&lt;/p&gt;
&lt;h3 id=&#34;선언-관련-키워드&#34;&gt;선언 관련 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;var&lt;/td&gt;
          &lt;td&gt;변수 선언 (함수 스코프)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;var name = &amp;quot;John&amp;quot;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;let&lt;/td&gt;
          &lt;td&gt;변수 선언 (블록 스코프)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let age = 25;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;const&lt;/td&gt;
          &lt;td&gt;상수 선언 (재할당 불가)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;const PI = 3.14;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;function&lt;/td&gt;
          &lt;td&gt;함수 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;function add(a, b) { return a + b; }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;class&lt;/td&gt;
          &lt;td&gt;클래스 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;class Person { constructor() {} }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;조건문-및-반복문-키워드&#34;&gt;조건문 및 반복문 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;if&lt;/td&gt;
          &lt;td&gt;조건문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;if (age &amp;gt; 18) { console.log(&amp;quot;Adult&amp;quot;); }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;else&lt;/td&gt;
          &lt;td&gt;if문의 대안 조건&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;else { console.log(&amp;quot;Minor&amp;quot;); }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;switch&lt;/td&gt;
          &lt;td&gt;다중 분기 조건문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;switch (value) { case 1: break; }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;case&lt;/td&gt;
          &lt;td&gt;switch문의 각 경우&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;case &amp;quot;A&amp;quot;: return &amp;quot;Excellent&amp;quot;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;default&lt;/td&gt;
          &lt;td&gt;switch문의 기본 경우&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;default: return &amp;quot;Invalid&amp;quot;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;for&lt;/td&gt;
          &lt;td&gt;반복문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 5; i++) {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;while&lt;/td&gt;
          &lt;td&gt;조건기반 반복문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;while (count &amp;lt; 10) {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;do&lt;/td&gt;
          &lt;td&gt;최소 한번 실행되는 반복문&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;do { count++; } while (count &amp;lt; 5);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;제어-흐름-키워드&#34;&gt;제어 흐름 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;break&lt;/td&gt;
          &lt;td&gt;반복문/switch문 탈출&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;break;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;continue&lt;/td&gt;
          &lt;td&gt;현재 반복 건너뛰기&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;continue;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;return&lt;/td&gt;
          &lt;td&gt;함수에서 값 반환&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;return result;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;throw&lt;/td&gt;
          &lt;td&gt;예외 발생&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;throw new Error(&amp;quot;Invalid input&amp;quot;);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;try&lt;/td&gt;
          &lt;td&gt;예외처리 시도 블록&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;try { riskyOperation(); }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;catch&lt;/td&gt;
          &lt;td&gt;예외처리 블록&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;catch (error) { handleError(error); }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;finally&lt;/td&gt;
          &lt;td&gt;예외 발생 여부와 관계없이 실행&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;finally { cleanup(); }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;객체-지향-프로그래밍-키워드&#34;&gt;객체 지향 프로그래밍 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;this&lt;/td&gt;
          &lt;td&gt;현재 객체 참조&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;this.name = name;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;super&lt;/td&gt;
          &lt;td&gt;부모 클래스 참조&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;super(name);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;new&lt;/td&gt;
          &lt;td&gt;객체 생성&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;new Date();&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;extends&lt;/td&gt;
          &lt;td&gt;클래스 상속&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;class Student extends Person {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;static&lt;/td&gt;
          &lt;td&gt;클래스 레벨 멤버 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;static count = 0;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;get&lt;/td&gt;
          &lt;td&gt;getter 메서드 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;get name() { return this._name; }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;set&lt;/td&gt;
          &lt;td&gt;setter 메서드 정의&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;set name(value) { this._name = value; }&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;모듈-및-패키지-키워드&#34;&gt;모듈 및 패키지 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;import&lt;/td&gt;
          &lt;td&gt;모듈 가져오기&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;import { useState } from &#39;react&#39;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;export&lt;/td&gt;
          &lt;td&gt;모듈 내보내기&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;export default class MyComponent {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;from&lt;/td&gt;
          &lt;td&gt;모듈 출처 지정&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;import React from &#39;react&#39;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;as&lt;/td&gt;
          &lt;td&gt;모듈 별칭 지정&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;import * as utils from &#39;./utils&#39;;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;기타-키워드&#34;&gt;기타 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;typeof&lt;/td&gt;
          &lt;td&gt;데이터 타입 확인&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;typeof value === &amp;quot;string&amp;quot;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;instanceof&lt;/td&gt;
          &lt;td&gt;객체 타입 확인&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;obj instanceof Array&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;void&lt;/td&gt;
          &lt;td&gt;undefined 값 반환&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;void function() {}&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;delete&lt;/td&gt;
          &lt;td&gt;객체 프로퍼티 삭제&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;delete object.property&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;in&lt;/td&gt;
          &lt;td&gt;프로퍼티 존재 확인&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;&amp;quot;name&amp;quot; in object&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;debugger&lt;/td&gt;
          &lt;td&gt;디버깅 중단점&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;debugger;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;예약된-리터럴&#34;&gt;예약된 리터럴&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;true&lt;/td&gt;
          &lt;td&gt;논리 참 값&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let isActive = true;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;false&lt;/td&gt;
          &lt;td&gt;논리 거짓 값&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let isDisabled = false;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;null&lt;/td&gt;
          &lt;td&gt;값이 없음을 나타내는 객체&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let value = null;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;undefined&lt;/td&gt;
          &lt;td&gt;정의되지 않은 값&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let value = undefined;&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;엄격-모드-키워드&#34;&gt;엄격 모드 키워드&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;키워드&lt;/th&gt;
          &lt;th&gt;설명&lt;/th&gt;
          &lt;th&gt;예시&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;ldquo;use strict&amp;rdquo;&lt;/td&gt;
          &lt;td&gt;엄격 모드 선언&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;; // 코드의 시작 부분&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Spring</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/framework/spring/</link>
      <pubDate>Wed, 20 Nov 2024 09:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/framework/spring/</guid>
      <description>Spring은 Java 기반의 현대적인 엔터프라이즈 애플리케이션 개발을 위한 포괄적인 프레임워크</description>
    </item>
    <item>
      <title>Spring Boot</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/web-framework/spring-boot/</link>
      <pubDate>Wed, 20 Nov 2024 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/web-framework/spring-boot/</guid>
      <description>Spring 프레임워크를 기반으로 한 Java 애플리케이션 개발을 더욱 쉽고 빠르게 만들어주는 도구</description>
    </item>
    <item>
      <title>Junit</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/testing/junit/</link>
      <pubDate>Wed, 20 Nov 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/testing/junit/</guid>
      <description>Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크</description>
    </item>
    <item>
      <title>Polling publisher</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</link>
      <pubDate>Tue, 19 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/</guid>
      <description>&lt;h2 id=&#34;polling-publisher&#34;&gt;Polling Publisher&lt;/h2&gt;
&lt;p&gt;Polling publisher는 마이크로서비스 아키텍처(MSA)에서 트랜잭셔널 메시징을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 Transactional Outbox 패턴과 함께 사용되어 데이터 일관성을 유지하면서 메시지를 안정적으로 발행하는 데 도움을 준다.&lt;/p&gt;
&lt;p&gt;Polling publisher는 특히 소규모 시스템이나 간단한 구현이 필요한 경우에 적합한 방식이다. 그러나 대규모 시스템이나 실시간성이 중요한 경우에는 Transaction Log Tailing과 같은 다른 방식을 고려할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;기본-개념&#34;&gt;기본 개념&lt;/h3&gt;
&lt;p&gt;Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.&lt;br&gt;
데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transaction log tailing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/</guid>
      <description>&lt;h2 id=&#34;transaction-log-tailing&#34;&gt;Transaction Log Tailing&lt;/h2&gt;
&lt;p&gt;Transaction log tailing은 마이크로서비스 아키텍처(MSA)에서 Transactional Messaging을 구현하는 방법 중 하나이다.&lt;br&gt;
이 패턴은 데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.&lt;/p&gt;
&lt;p&gt;Transaction log tailing은 Polling publisher 방식과 비교될 수 있다. Polling은 주기적으로 데이터베이스를 조회하는 반면, log tailing은 실시간으로 변경사항을 감지한다. 이로 인해 log tailing이 더 빠르고 효율적이지만, 구현이 더 복잡할 수 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 사용할 때는 메시지의 중복 발행 가능성을 고려해야 하며, 소비자 측에서 멱등성을 보장하는 방식으로 구현해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Transactional Outbox</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transactional-outbox/</guid>
      <description>&lt;h2 id=&#34;transactional-outbox&#34;&gt;Transactional Outbox&lt;/h2&gt;
&lt;p&gt;Transactional Outbox 패턴은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성과 메시지 전달의 신뢰성을 보장하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 데이터베이스 업데이트와 메시지 발행을 원자적으로 처리하기 위한 방법으로, 데이터베이스 트랜잭션과 메시지 발행 사이의 일관성을 보장하는 것을 목적으로 한다.&lt;/p&gt;
&lt;p&gt;Transactional Outbox 패턴은 분산 시스템에서 데이터 일관성과 메시지 전달의 신뢰성을 높이는 효과적인 방법이다. 이 패턴을 통해 개발자는 복잡한 분산 트랜잭션 문제를 해결하고, 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-방식&#34;&gt;작동 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 업데이트와 함께 발행할 메시지를 &amp;lsquo;outbox&amp;rsquo; 테이블에 저장한다.&lt;/li&gt;
&lt;li&gt;이 두 작업은 하나의 데이터베이스 트랜잭션으로 처리된다.&lt;/li&gt;
&lt;li&gt;별도의 프로세스(Message Relay)가 outbox 테이블에서 메시지를 읽어 실제 메시지 브로커로 전송한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Outbox 테이블: 발행할 메시지를 임시로 저장하는 데이터베이스 테이블&lt;/li&gt;
&lt;li&gt;Message Relay: outbox 테이블에서 메시지를 읽어 메시지 브로커로 전송하는 프로세스&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;p&gt;a. Polling Publisher:&lt;br&gt;
- 주기적으로 outbox 테이블을 폴링하여 미발행 메시지를 조회하고 발행한다.&lt;br&gt;
- 구현이 간단하지만 실시간성이 떨어질 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side UI composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/client-side-ui-composition/</guid>
      <description>&lt;h2 id=&#34;client-side-ui-composition&#34;&gt;Client-side UI Composition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Client-side UI Composition&lt;/strong&gt;은 마이크로서비스 아키텍처(MSA)에서 클라이언트(주로 브라우저)가 여러 마이크로서비스로부터 데이터를 직접 가져와 사용자 인터페이스(UI)를 구성하는 패턴이다.&lt;br&gt;
이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;이 패턴에서는 클라이언트(브라우저)가 여러 마이크로서비스로부터 데이터를 요청하고, 해당 데이터를 기반으로 UI를 렌더링한다. 각 마이크로서비스는 자신만의 UI 컴포넌트(HTML, CSS, JavaScript 등)를 제공하며, 클라이언트는 이러한 컴포넌트를 조합해 전체 화면을 구성한다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전자상거래 웹사이트의 상품 상세 페이지를 생각해보면:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Server-side page fragment composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/ui/server-side-page-fragment-composition/</guid>
      <description>&lt;h2 id=&#34;server-side-page-fragment-composition&#34;&gt;Server-side Page Fragment Composition&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Server-side page fragment composition&lt;/strong&gt;은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.&lt;/p&gt;
&lt;p&gt;Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Twelve-Factor App methodology</title>
      <link>https://buenhyden.github.io/til/2024/11/19/twelve-factor-app-methodology/</link>
      <pubDate>Tue, 19 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/19/twelve-factor-app-methodology/</guid>
      <description>클라우드 네이티브 애플리케이션을 구축하기 위한 12가지 모범 사례를 제시</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/api-key-authentication/</guid>
      <description>&lt;h2 id=&#34;api-key-authentication&#34;&gt;API Key Authentication&lt;/h2&gt;
&lt;p&gt;API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.&lt;/p&gt;
&lt;p&gt;API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/</guid>
      <description>&lt;h2 id=&#34;cors&#34;&gt;CORS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.&lt;/p&gt;
&lt;h3 id=&#34;cors의-작동-원리&#34;&gt;CORS의 작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다.&lt;/li&gt;
&lt;li&gt;서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다.&lt;/li&gt;
&lt;li&gt;브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Origin의 정의&lt;br&gt;
Origin은 다음 세 가지 요소로 구성된다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mutual TLS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/</guid>
      <description>&lt;h2 id=&#34;mutual-tls&#34;&gt;Mutual TLS&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.&lt;/p&gt;
&lt;p&gt;Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;mTLS&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/how_mtls_works-what_is_mutual_tls.webp&#34;&gt;&lt;figcaption&gt;https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;일반-tls와의-차이점&#34;&gt;일반 TLS와의 차이점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다.&lt;/li&gt;
&lt;li&gt;mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mtls의-작동-원리&#34;&gt;mTLS의 작동 원리&lt;/h3&gt;
&lt;p&gt;mTLS는 다음과 같은 단계로 작동한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/</guid>
      <description>&lt;h2 id=&#34;oauth2oidc-openid-connect&#34;&gt;OAuth2/OIDC (OpenID Connect)&lt;/h2&gt;
&lt;p&gt;MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;oauth-20&#34;&gt;OAuth 2.0&lt;/h3&gt;
&lt;p&gt;OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.&lt;br&gt;
주요 특징은 다음과 같다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/rate-limiting/</guid>
      <description>&lt;h2 id=&#34;rate-limiting&#34;&gt;Rate Limiting&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Secret Management</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/secret-management/</guid>
      <description>&lt;h2 id=&#34;secret-management&#34;&gt;Secret Management&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Access Token</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/access-token/</guid>
      <description>&lt;h2 id=&#34;access-token&#34;&gt;Access Token&lt;/h2&gt;
&lt;p&gt;Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.&lt;br&gt;
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;access-token의-특징&#34;&gt;Access Token의 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다.&lt;/li&gt;
&lt;li&gt;Stateless: 서버에 상태를 저장하지 않아 확장성이 높다.&lt;/li&gt;
&lt;li&gt;암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다.&lt;/li&gt;
&lt;li&gt;포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-동작-방식&#34;&gt;Access Token의 동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다.&lt;/li&gt;
&lt;li&gt;토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지).&lt;/li&gt;
&lt;li&gt;요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다.&lt;/li&gt;
&lt;li&gt;서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-장점&#34;&gt;Access Token의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;확장성: Stateless 특성으로 서버 확장이 용이하다.&lt;/li&gt;
&lt;li&gt;보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다.&lt;/li&gt;
&lt;li&gt;효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token의-단점&#34;&gt;Access Token의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다.&lt;/li&gt;
&lt;li&gt;제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;access-token과-refresh-token&#34;&gt;Access Token과 Refresh Token&lt;/h3&gt;
&lt;p&gt;보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Consumer-side contract test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</link>
      <pubDate>Mon, 18 Nov 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/</guid>
      <description>&lt;h2 id=&#34;consumer-side-contract-test&#34;&gt;Consumer-side Contract Test&lt;/h2&gt;
&lt;p&gt;Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.&lt;/p&gt;
&lt;p&gt;Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다.&lt;/li&gt;
&lt;li&gt;테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다.&lt;/li&gt;
&lt;li&gt;테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다.&lt;/li&gt;
&lt;li&gt;명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다.&lt;/li&gt;
&lt;li&gt;유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다.&lt;/li&gt;
&lt;li&gt;완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Consumer-Driven Contract Testing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-driven-contract-testing/</guid>
      <description>&lt;h2 id=&#34;consumer-driven-contract-testing&#34;&gt;Consumer-Driven Contract Testing&lt;/h2&gt;
&lt;p&gt;Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.&lt;br&gt;
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.&lt;/p&gt;
&lt;p&gt;CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.&lt;/p&gt;
&lt;p&gt;CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 중심: 소비자가 테스트의 주도권을 가진다.&lt;/li&gt;
&lt;li&gt;실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다.&lt;/li&gt;
&lt;li&gt;격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-단계&#34;&gt;구현 단계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다.&lt;/li&gt;
&lt;li&gt;계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다.&lt;/li&gt;
&lt;li&gt;계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다.&lt;/li&gt;
&lt;li&gt;제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;빠른 피드백: 통합 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;li&gt;독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음.&lt;/li&gt;
&lt;li&gt;계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도구&#34;&gt;도구&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pact: CDC 테스팅을 위한 대표적인 도구.&lt;/li&gt;
&lt;li&gt;Testsigma: CDC 테스팅을 지원하는 또 다른 도구.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service Component Test</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/service-component-test/</guid>
      <description>&lt;h2 id=&#34;service-component-test&#34;&gt;Service Component Test&lt;/h2&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.&lt;br&gt;
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.&lt;/p&gt;
&lt;p&gt;Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다.&lt;/li&gt;
&lt;li&gt;경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다.&lt;/li&gt;
&lt;li&gt;집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다.&lt;/li&gt;
&lt;li&gt;반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;테스트 환경 설정:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/back-pressure/</guid>
      <description>&lt;h2 id=&#34;back-pressure&#34;&gt;Back Pressure&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Back Pressure&amp;quot;는 마이크로서비스 아키텍처(MSA)의 Reliability 패턴 중 하나로, 시스템의 안정성과 성능을 유지하기 위한 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.&lt;br&gt;
이는 과부하 상태에서 시스템이 완전히 실패하는 것을 방지하고, 가능한 한 많은 요청을 처리할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;Back Pressure는 MSA의 Reliability를 향상시키는 중요한 패턴이다.&lt;br&gt;
이를 효과적으로 구현하면 시스템의 안정성과 성능을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;back-pressure의-필요성&#34;&gt;Back Pressure의 필요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;시스템 안정성 유지: 과도한 요청으로 인한 시스템 다운을 방지한다.&lt;/li&gt;
&lt;li&gt;리소스 관리: 제한된 리소스를 효율적으로 사용할 수 있게 한다.&lt;/li&gt;
&lt;li&gt;서비스 품질 유지: 일부 요청을 거부하더라도 전체적인 서비스 품질을 유지할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;back-pressure-구현-방법&#34;&gt;Back Pressure 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;요청 큐잉&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bulkhead</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/bulkhead/</guid>
      <description>Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/cache-aside/</guid>
      <description>&lt;h2 id=&#34;cache-aside&#34;&gt;Cache-Aside&lt;/h2&gt;
&lt;p&gt;Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.&lt;br&gt;
이 패턴은 &amp;ldquo;Lazy Loading&amp;rdquo; 또는 &amp;ldquo;Look Aside&amp;rdquo; 패턴으로도 알려져 있다.&lt;/p&gt;
&lt;p&gt;Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Cache-aside&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/cache-aside-diagram.png&#34;&gt;&lt;figcaption&gt;https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;애플리케이션이 데이터를 요청한다.&lt;/li&gt;
&lt;li&gt;캐시를 먼저 확인한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다.&lt;/li&gt;
&lt;li&gt;캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서 가져온 데이터를 캐시에 저장한다.&lt;/li&gt;
&lt;li&gt;데이터를 애플리케이션에 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다.&lt;/li&gt;
&lt;li&gt;TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다.&lt;/li&gt;
&lt;li&gt;캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다.&lt;/li&gt;
&lt;li&gt;동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다.&lt;/li&gt;
&lt;li&gt;추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;동시성 처리와 오류 복구를 포함한 버전&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fail Fast</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/fail-fast/</guid>
      <description>&lt;h2 id=&#34;fail-fast&#34;&gt;Fail Fast&lt;/h2&gt;
&lt;p&gt;Fail Fast는 MSA의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
잠재적인 문제를 조기에 발견하고 빠르게 대응함으로써 전체 시스템의 안정성과 신뢰성을 향상시킬 수 있다.&lt;/p&gt;
&lt;p&gt;Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙이다.&lt;br&gt;
이는 잠재적인 오류를 조기에 감지하고 빠르게 대응하여 시스템의 안정성을 높이는 데 목적이 있다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하기 위해서는 철저한 모니터링과 로깅, 적절한 알림 시스템, 그리고 자동화된 복구 메커니즘이 함께 구현되어야 한다. 또한 각 서비스의 특성에 맞는 임계값과 정책을 설정하고, 지속적으로 이를 개선해 나가는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/</guid>
      <description>&lt;h2 id=&#34;anti-corruption-layer&#34;&gt;Anti-Corruption Layer&lt;/h2&gt;
&lt;p&gt;Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.&lt;br&gt;
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.&lt;/p&gt;
&lt;p&gt;ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.&lt;br&gt;
주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다.&lt;/li&gt;
&lt;li&gt;도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다.&lt;/li&gt;
&lt;li&gt;데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.&lt;br&gt;
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Circuit Breaker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</link>
      <pubDate>Sun, 17 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/</guid>
      <description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Timeout Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</link>
      <pubDate>Sun, 17 Nov 2024 02:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/</guid>
      <description>&lt;h2 id=&#34;timeout-pattern&#34;&gt;Timeout Pattern&lt;/h2&gt;
&lt;p&gt;Timeout Pattern은 마이크로서비스 간 통신에서 응답 지연이나 실패를 관리하기 위한 전략이다.&lt;br&gt;
이 패턴은 서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.&lt;/p&gt;
&lt;p&gt;Timeout Pattern은 MSA 환경에서 서비스 간 통신의 신뢰성을 높이고 시스템의 전반적인 안정성을 향상시키는 중요한 전략이다. 적절히 구현된 Timeout Pattern은 마이크로서비스 아키텍처의 장점을 극대화하고 잠재적인 문제를 최소화하는 데 큰 도움이 된다.&lt;/p&gt;
&lt;h3 id=&#34;타임아웃-패턴의-필요성&#34;&gt;타임아웃 패턴의 필요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 여러 서비스가 네트워크를 통해 상호 작용하므로, 다음과 같은 이유로 타임아웃 패턴이 필요하다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</link>
      <pubDate>Sun, 17 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/</guid>
      <description>&lt;h2 id=&#34;retry-pattern&#34;&gt;Retry Pattern&lt;/h2&gt;
&lt;p&gt;Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.&lt;br&gt;
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.&lt;/p&gt;
&lt;p&gt;Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.&lt;br&gt;
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;retry-pattern의-주요-특징&#34;&gt;Retry Pattern의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;재시도 횟수&lt;/strong&gt;: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 간격&lt;/strong&gt;: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백오프 전략&lt;/strong&gt;: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조건부 재시도&lt;/strong&gt;: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;retry-pattern-구현-방법&#34;&gt;Retry Pattern 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Retry 사용&lt;/strong&gt;: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resilience4j 사용&lt;/strong&gt;: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스텀 구현&lt;/strong&gt;: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;재시도-패턴-구현-시-고려사항&#34;&gt;재시도 패턴 구현 시 고려사항&lt;/h3&gt;
&lt;p&gt;재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Strangler Application</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</link>
      <pubDate>Sun, 17 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/</guid>
      <description>&lt;h2 id=&#34;strangler-application&#34;&gt;Strangler Application&lt;/h2&gt;
&lt;p&gt;Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.&lt;br&gt;
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.&lt;/p&gt;
&lt;p&gt;Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Application metrics</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/</guid>
      <description>&lt;h2 id=&#34;application-metrics&#34;&gt;Application Metrics&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA) 패턴에서 Observability는 매우 중요한 개념이며, 그 중 Application Metrics는 핵심적인 요소이다.&lt;br&gt;
Application Metrics는 애플리케이션의 성능과 동작을 이해하고 문제를 해결하는 데 필수적인 도구이다.&lt;/p&gt;
&lt;p&gt;Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.&lt;br&gt;
이는 개별 작업에 대한 통계를 수집하고, 이를 중앙 집중식 메트릭 서비스에 집계하여 보고 및 경고를 제공하는 패턴을 말한다.&lt;/p&gt;
&lt;p&gt;Application Metrics는 MSA 환경에서 Observability를 달성하는 데 핵심적인 역할을 한다.&lt;br&gt;
이를 통해 개발자와 운영팀은 복잡한 시스템을 더 잘 이해하고, 문제를 신속하게 해결하며, 시스템의 성능을 지속적으로 개선할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Log deployments and changes</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</link>
      <pubDate>Sat, 16 Nov 2024 11:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/</guid>
      <description>&lt;h2 id=&#34;log-deployments-and-changes&#34;&gt;Log Deployments and Changes&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.&lt;/p&gt;
&lt;h3 id=&#34;패턴의-정의와-목적&#34;&gt;패턴의 정의와 목적&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.&lt;br&gt;
이 패턴의 주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시스템 변경사항과 문제 발생 간의 상관관계 파악&lt;/li&gt;
&lt;li&gt;문제 해결 시간 단축&lt;/li&gt;
&lt;li&gt;시스템 동작에 대한 이해도 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Log deployments and changes&amp;rdquo; 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>API Composition</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/</guid>
      <description>이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.</description>
    </item>
    <item>
      <title>CQRS</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/cqrs/</link>
      <pubDate>Sat, 16 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/cqrs/</guid>
      <description>&lt;h2 id=&#34;cqrs&#34;&gt;CQRS&lt;/h2&gt;
&lt;p&gt;CQRS(Command Query Responsibility Segregation)는 마이크로서비스 아키텍처(MSA)에서 중요한 패턴 중 하나이다.&lt;br&gt;
CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.&lt;/p&gt;
&lt;p&gt;CQRS는 다음과 같은 핵심 개념을 가지고 있다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;명령(Command)&lt;/strong&gt;: 시스템의 상태를 변경하는 작업 (예: 주문하기, 회원가입)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조회(Query)&lt;/strong&gt;: 시스템의 상태를 조회하는 작업 (예: 주문 목록 조회, 회원 정보 조회)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;책임 분리(Responsibility Segregation)&lt;/strong&gt;: 명령과 조회 작업을 별도의 모델로 분리&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CQRS 패턴은 시스템의 성능, 확장성, 유지보수성을 향상시킬 수 있는 강력한 도구이다. 하지만 모든 시스템에 적합한 것은 아니므로, 프로젝트의 요구사항과 특성을 고려하여 적용 여부를 신중히 결정해야 한다.&lt;br&gt;
CQRS를 효과적으로 구현하기 위해서는 명령과 조회 모델의 분리, 데이터 동기화 전략, 그리고 전체 시스템 아키텍처에 대한 깊은 이해가 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Audit Logging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</link>
      <pubDate>Sat, 16 Nov 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/audit-logging/</guid>
      <description>&lt;h2 id=&#34;audit-logging&#34;&gt;Audit Logging&lt;/h2&gt;
&lt;p&gt;Audit Logging은 시스템 내에서 발생하는 중요한 이벤트와 변경사항을 기록하는 프로세스이다.&lt;br&gt;
이는 사용자 활동, 시스템 변경, 데이터 접근 등을 포함하며, 시스템의 동작을 이해하고 문제를 해결하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Audit Logging은 MSA 환경에서 시스템의 투명성, 보안성, 그리고 문제 해결 능력을 크게 향상시킨다. 적절히 구현된 Audit Logging 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;
&lt;h3 id=&#34;기본-구성-요소&#34;&gt;기본 구성 요소&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Audit Log 엔티티 예시&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Entity&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AuditLog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@GeneratedValue&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Long&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 이벤트 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 유형&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resourceId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 리소스 식별자&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 ID&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 수행된 작업&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 전 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 변경 후 값&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 발생 시간&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ipAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// IP 주소&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userAgent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 사용자 에이전트&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// getters, setters&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;audit-logging의-중요성&#34;&gt;Audit Logging의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;규정 준수&lt;/strong&gt;: PCI DSS, SOC 2 등의 산업 표준 및 규제 요구사항을 충족하는 데 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;: 비정상적인 활동을 감지하고 보안 위협을 조사하는 데 도움이 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 시스템 장애나 오류의 원인을 파악하는 데 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;사용자 행동 이해&lt;/strong&gt;: 고객 지원, 시스템 개선을 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-방법&#34;&gt;Audit Logging 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 로깅 서비스&lt;/strong&gt;: 모든 마이크로서비스의 로그를 한 곳에서 수집하고 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화된 로그 형식&lt;/strong&gt;: 일관된 형식을 사용하여 로그 분석을 용이하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안 및 접근 제어&lt;/strong&gt;: 로그 데이터의 무결성과 기밀성을 보장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 대량의 로그 데이터를 효율적으로 처리할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-구현-시-고려사항&#34;&gt;Audit Logging 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;과도한 로깅 vs 부족한 로깅&lt;/strong&gt;: 적절한 수준의 로깅을 유지해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: 로깅이 시스템 성능에 미치는 영향을 최소화해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 보존 정책&lt;/strong&gt;: 로그 데이터의 보존 기간과 방법을 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 모니터링&lt;/strong&gt;: 중요한 이벤트에 대한 실시간 알림 시스템을 구축해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging-도구-및-기술&#34;&gt;Audit Logging 도구 및 기술&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Elasticsearch, Logstash, Kibana (ELK) 스택&lt;/strong&gt;: 로그 수집, 저장, 시각화에 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serilog&lt;/strong&gt;:.NET 환경에서 구조화된 로깅을 위한 프레임워크이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka&lt;/strong&gt;: 대규모 로그 스트림 처리에 적합한 메시징 시스템이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud-native 솔루션&lt;/strong&gt;: AWS CloudWatch, Google Cloud Logging 등이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;audit-logging을-효과적으로-구현하기-위한-방법&#34;&gt;Audit Logging을 효과적으로 구현하기 위한 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비즈니스 로직 내에 로깅 코드 추가&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 구현이 비교적 간단하며, 특정 이벤트에 대한 상세한 로깅이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 비즈니스 로직과 로깅 코드가 혼재되어 코드의 가독성과 유지보수성이 저하될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOP(Aspect-Oriented Programming) 활용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 비즈니스 로직과 로깅 기능을 분리하여 코드의 모듈성을 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 메서드명이나 인수에만 접근할 수 있어, 비즈니스 컨텍스트에 따른 상세한 로깅에는 한계가 있을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 소싱(Event Sourcing) 사용&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt;: 시스템의 상태 변화를 이벤트 형태로 저장하여, 모든 변경 이력을 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;: 쿼리 작업은 이벤트로 기록되지 않으므로, 이러한 작업에 대한 로깅은 별도의 방법을 통해 구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상관 관계 ID 사용&lt;/strong&gt;: 마이크로서비스 간 요청 추적을 위해 고유 ID를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 정보 포함&lt;/strong&gt;: 사용자 ID, 서비스 이름, 요청 ID 등을 로그에 포함한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;민감한 정보 보호&lt;/strong&gt;: 개인정보나 보안 관련 데이터는 마스킹 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로그 레벨 구분&lt;/strong&gt;: 중요도에 따라 로그 레벨을 적절히 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Exception Tracking</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</link>
      <pubDate>Sat, 16 Nov 2024 02:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/exception-tracking/</guid>
      <description>&lt;h2 id=&#34;exception-tracking&#34;&gt;Exception Tracking&lt;/h2&gt;
&lt;p&gt;Exception Tracking은 분산 시스템 전반에 걸쳐 발생하는 예외를 중앙에서 수집, 집계, 분석하는 패턴이다.&lt;br&gt;
이 패턴은 복잡한 마이크로서비스 환경에서 오류를 효과적으로 모니터링하고 디버깅하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Exception Tracking은 MSA 환경에서 시스템의 안정성을 유지하고 문제를 신속하게 해결하는 데 필수적인 도구이다.&lt;br&gt;
이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고 사용자 경험을 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 예외 로거&lt;/strong&gt;: 여러 마이크로서비스에서 발생하는 예외 데이터를 수집하고 저장하는 전용 서비스나 도구이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예외 처리 미들웨어&lt;/strong&gt;: 각 마이크로서비스에 구현되어 예외를 캐치하고 중앙 로거로 전달하는 컴포넌트이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상관 관계 ID&lt;/strong&gt;: 여러 서비스에 걸친 요청 흐름과 관련 예외를 추적하는 데 사용되는 고유 식별자이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;알림 및 모니터링&lt;/strong&gt;: 중요한 문제에 대해 개발 및 운영 팀에 실시간으로 알리는 통합 모니터링 도구이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;대시보드&lt;/strong&gt;: 예외의 빈도, 심각도, 잠재적 영향 등에 대한 인사이트와 분석을 제공하는 사용자 인터페이스이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;exception-tracking의-중요성&#34;&gt;Exception Tracking의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 관리&lt;/strong&gt;: 수많은 서비스로 구성된 시스템에서 오류의 흐름을 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신속한 문제 해결&lt;/strong&gt;: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 이해 향상&lt;/strong&gt;: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;중앙 집중식 로깅 서비스 구축&lt;/strong&gt;: ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 사용하여 모든 마이크로서비스의 로그를 한 곳에서 수집하고 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;고유 요청 ID 생성&lt;/strong&gt;: 각 요청에 고유한 ID를 할당하여 여러 서비스에 걸친 예외 추적을 가능하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화된 예외 형식 사용&lt;/strong&gt;: 일관된 형식을 사용하여 예외 데이터를 수집하고 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;실시간 알림 설정&lt;/strong&gt;: 중요한 예외 발생 시 개발팀에 즉시 알림을 보내도록 구성한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Feign Error Decoder 활용&lt;/strong&gt;: Spring Cloud Openfeign을 사용하는 경우, Feign Error Decoder를 구현하여 마이크로서비스 간 통신 중 발생하는 예외를 효과적으로 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;예외 분류 및 우선순위 지정&lt;/strong&gt;: 예외의 심각도와 영향도에 따라 분류하고 우선순위를 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 정보 포함&lt;/strong&gt;: 예외 로그에 사용자 정보, 요청 세부 사항 등 충분한 컨텍스트 정보를 포함시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;정기적인 분석 및 개선&lt;/strong&gt;: 수집된 예외 데이터를 정기적으로 분석하여 시스템 안정성을 지속적으로 개선한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fail Fast 원칙 적용&lt;/strong&gt;: 문제를 조기에 감지하고 신속하게 대응할 수 있도록 Fail Fast 원칙을 적용한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Distributed Tracing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/distributed-tracing/</guid>
      <description>&lt;h2 id=&#34;distributed-tracing&#34;&gt;Distributed Tracing&lt;/h2&gt;
&lt;p&gt;Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고유 식별자 할당&lt;/strong&gt;: 각 요청에 고유한 Trace ID를 부여한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스팬 생성&lt;/strong&gt;: 요청이 각 서비스를 통과할 때마다 &amp;lsquo;스팬&amp;rsquo;이라는 작업 단위가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;계층 구조&lt;/strong&gt;: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메타데이터 수집&lt;/strong&gt;: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;distributed-tracing의-중요성&#34;&gt;Distributed Tracing의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 관리&lt;/strong&gt;: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 해결&lt;/strong&gt;: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 이해&lt;/strong&gt;: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-사용-사례&#34;&gt;주요 사용 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 병목 식별&lt;/strong&gt;: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오류 추적&lt;/strong&gt;: 실패한 요청의 정확한 실패 지점과 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 의존성 분석&lt;/strong&gt;: 서비스 간 통신 패턴과 의존성을 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화&lt;/strong&gt;: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;계측&lt;/strong&gt;: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 수집&lt;/strong&gt;: 각 요청에 대한 스팬 데이터를 수집한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;분석 및 시각화&lt;/strong&gt;: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-도구&#34;&gt;주요 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Jaeger&lt;/strong&gt;: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zipkin&lt;/strong&gt;: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Datadog APM&lt;/strong&gt;: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New Relic&lt;/strong&gt;: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;모범-사례&#34;&gt;모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;샘플링 전략 수립&lt;/strong&gt;: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컨텍스트 전파&lt;/strong&gt;: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;표준화&lt;/strong&gt;: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시각화 도구 활용&lt;/strong&gt;: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Health Check API</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</link>
      <pubDate>Sat, 16 Nov 2024 01:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/health-check-api/</guid>
      <description>&lt;h2 id=&#34;health-check-api&#34;&gt;Health Check API&lt;/h2&gt;
&lt;p&gt;Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.&lt;br&gt;
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.&lt;/p&gt;
&lt;p&gt;Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.&lt;br&gt;
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.&lt;/p&gt;
&lt;h3 id=&#34;health-check-api의-중요성&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;고가용성 보장&lt;/strong&gt;: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문제 조기 발견&lt;/strong&gt;: 서비스의 이상을 조기에 감지하여 대응할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api의-주요-기능&#34;&gt;Health Check API의 주요 기능&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;상태 확인:&lt;/strong&gt; 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;종속성 검사:&lt;/strong&gt; 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 모니터링:&lt;/strong&gt; 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api의-중요성-1&#34;&gt;Health Check API의 중요성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;장애 감지:&lt;/strong&gt; 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리 통합:&lt;/strong&gt; 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상:&lt;/strong&gt; 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;health-check-api-구현-방법&#34;&gt;Health Check API 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;엔드포인트 생성&lt;/strong&gt;: 일반적으로 &lt;code&gt;/health&lt;/code&gt; 또는 &lt;code&gt;/ping&lt;/code&gt; 경로로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;응답 코드&lt;/strong&gt;: 정상 상태일 때 HTTP 200 OK를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 정보 포함&lt;/strong&gt;: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-유형&#34;&gt;Health Check 유형&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Passive Health Checks&lt;/strong&gt;: 실제 요청에 대한 응답을 모니터링한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active Health Checks&lt;/strong&gt;: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent-based Health Checks&lt;/strong&gt;: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-구현-도구&#34;&gt;Health Check API 구현 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot Actuator&lt;/strong&gt;: 자동으로 &lt;code&gt;/actuator/health&lt;/code&gt; 엔드포인트를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes Probes&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Liveness Probe: 애플리케이션이 살아있는지 확인&lt;/li&gt;
&lt;li&gt;Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인&lt;/li&gt;
&lt;li&gt;Startup Probe: 애플리케이션의 시작이 완료되었는지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;health-check-api-모범-사례&#34;&gt;Health Check API 모범 사례&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;상세한 상태 정보&lt;/strong&gt;: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커스터마이징&lt;/strong&gt;: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Log Aggregation</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</link>
      <pubDate>Sat, 16 Nov 2024 01:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-aggregation/</guid>
      <description>&lt;h2 id=&#34;log-aggregation&#34;&gt;Log Aggregation&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.&lt;br&gt;
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dead Letter Queue</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/dead-letter-queue/</guid>
      <description>&lt;h2 id=&#34;dead-letter-queue&#34;&gt;Dead Letter Queue&lt;/h2&gt;
&lt;p&gt;Dead Letter Queue(DLQ)는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 처리할 수 없는 메시지를 안전하게 저장하고 관리하는 중요한 메커니즘이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐이다.&lt;/p&gt;
&lt;p&gt;Dead Letter Queue는 MSA 환경에서 메시지 처리의 신뢰성과 안정성을 높이는 중요한 패턴이다. 적절히 구현하고 관리함으로써 시스템의 복원력을 향상시키고 문제 상황에 대한 가시성을 확보할 수 있다. DLQ를 효과적으로 활용하면 마이크로서비스 간 통신의 안정성을 크게 개선할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;데드-레터-큐에-메시지가-전달되는-일반적인-상황&#34;&gt;데드 레터 큐에 메시지가 전달되는 일반적인 상황&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;존재하지 않는 큐로의 메시지 전송&lt;/strong&gt;: 메시지가 존재하지 않는 큐로 전송될 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;큐의 최대 길이 초과&lt;/strong&gt;: 큐의 저장 용량이 초과되어 더 이상 메시지를 수용할 수 없을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 크기 제한 초과&lt;/strong&gt;: 메시지의 크기가 시스템에서 허용하는 최대 크기를 초과할 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 만료&lt;/strong&gt;: 메시지가 설정된 TTL(Time To Live, 생존 시간)을 초과하여 만료되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 거부&lt;/strong&gt;: 다른 큐나 교환기에 의해 메시지가 거부되었을 때.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;과도한 재시도 실패&lt;/strong&gt;: 메시지가 여러 번 처리되었지만 계속해서 실패할 때.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq의-주요-특징&#34;&gt;DLQ의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분리 저장&lt;/strong&gt;: 문제가 있는 메시지를 정상적인 메시지와 분리하여 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재처리 가능성&lt;/strong&gt;: DLQ에 저장된 메시지는 나중에 분석하거나 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시스템 안정성 향상&lt;/strong&gt;: 문제가 있는 메시지로 인한 시스템 장애를 방지한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;모니터링 및 알림&lt;/strong&gt;: DLQ를 모니터링하여 시스템 문제를 조기에 발견할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-구현-방법&#34;&gt;DLQ 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;큐 생성&lt;/strong&gt;: 일반 큐와 별도로 DLQ를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재시도 정책 설정&lt;/strong&gt;: 메시지 처리 실패 시 재시도 횟수와 간격을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLQ 연결&lt;/strong&gt;: 일반 큐에 DLQ를 연결하여 처리 실패한 메시지가 자동으로 이동하도록 설정한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dlq-활용-전략&#34;&gt;DLQ 활용 전략&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;분석 및 디버깅&lt;/strong&gt;: DLQ에 저장된 메시지를 분석하여 실패 원인을 파악한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 재처리&lt;/strong&gt;: 특정 조건에 따라 DLQ의 메시지를 자동으로 원래 큐로 되돌려 재처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;알림 설정&lt;/strong&gt;: DLQ에 메시지가 쌓이면 운영팀에 알림을 보내 신속한 대응을 유도한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: DLQ 상태를 지속적으로 모니터링하고 로깅하여 시스템 건강 상태를 파악한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;보존 기간 설정&lt;/strong&gt;: DLQ에 저장된 메시지의 보존 기간을 적절히 설정하여 리소스 관리에 유의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: DLQ에 저장된 메시지에 민감한 정보가 포함될 수 있으므로 보안에 주의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;성능 영향&lt;/strong&gt;: DLQ 처리로 인한 시스템 부하를 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;데드-레터-큐를-지원하는-주요-메시징-시스템&#34;&gt;데드 레터 큐를 지원하는 주요 메시징 시스템&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Amazon SQS&lt;/strong&gt;: 데드 레터 큐를 통해 처리 실패한 메시지를 별도로 보관하고, 이후에 재처리할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apache Kafka&lt;/strong&gt;: 메시지 처리 중 오류가 발생한 경우, 해당 메시지를 데드 레터 토픽에 저장하여 후속 조치를 취할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;: 데드 레터 교환기(Dead Letter Exchange)를 설정하여 처리되지 않은 메시지를 지정된 큐로 라우팅할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;Node.js와 RabbitMQ를 사용&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Broker</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-broker/</guid>
      <description>&lt;h2 id=&#34;message-broker&#34;&gt;Message Broker&lt;/h2&gt;
&lt;p&gt;메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.&lt;/p&gt;
&lt;p&gt;메시지 브로커는 **생산자(Producer)**와 &lt;strong&gt;소비자(Consumer)&lt;/strong&gt; 간의 메시지를 중개하여 전달하는 소프트웨어이다. 이를 통해 서로 다른 애플리케이션이나 서비스가 직접 통신하지 않고도 데이터를 교환할 수 있다. 메시지 브로커는 주로 &lt;strong&gt;비동기 통신&lt;/strong&gt;과 &lt;strong&gt;데이터 전달 신뢰성&lt;/strong&gt;을 보장하기 위해 사용된다.&lt;/p&gt;
&lt;h3 id=&#34;메시지-브로커의-주요-역할&#34;&gt;&lt;strong&gt;메시지 브로커의 주요 역할&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메시지 전달&lt;/strong&gt;: 생산자가 생성한 메시지를 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐잉(Message Queuing)&lt;/strong&gt;: 메시지를 임시로 저장하여 소비자가 준비되었을 때 처리할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비동기 통신 지원&lt;/strong&gt;: 실시간 응답을 기다리지 않고 독립적으로 작업을 처리할 수 있도록 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;라우팅(Routing)&lt;/strong&gt;: 특정 조건에 따라 메시지를 적절한 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신뢰성 보장&lt;/strong&gt;: 메시지가 손실되지 않도록 저장 및 재전송 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성(Scalability)&lt;/strong&gt;: 시스템이 더 많은 메시지를 처리할 수 있도록 확장성을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-동작-방식&#34;&gt;&lt;strong&gt;메시지 브로커의 동작 방식&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;생산자(Producer)&lt;/strong&gt;: 메시지를 생성하고 브로커에 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;브로커(Broker)&lt;/strong&gt;: 메시지를 임시 저장하고, 특정 규칙에 따라 적절한 소비자에게 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소비자(Consumer)&lt;/strong&gt;: 브로커에서 전달받은 메시지를 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;큐(Queue)&lt;/strong&gt;: 메시지가 순서대로 저장되는 대기열이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;토픽(Topic)&lt;/strong&gt;: 여러 소비자가 동일한 메시지를 구독할 수 있는 주제 기반 구조이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-장점&#34;&gt;메시지 브로커의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;서비스 간 느슨한 결합&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;서비스들이 직접 통신하지 않고 브로커를 통해 데이터를 주고받아 독립성을 유지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비동기 처리&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;생산자와 소비자가 동시에 작동하지 않아도 작업이 진행될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;필요에 따라 브로커를 확장하여 더 많은 메시지를 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;메시지가 손실되지 않도록 보장하며, 실패 시 재전송 기능을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연한 통신 패턴 지원&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;1:1(Point-to-Point), 1:N(Pub/Sub) 등 다양한 통신 방식을 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;메시지-브로커의-단점&#34;&gt;메시지 브로커의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;운영 복잡성 증가&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;추가적인 소프트웨어 구성 요소를 설치하고 관리해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단일 장애 지점(Single Point of Failure)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;브로커가 고장 나면 전체 시스템이 영향을 받을 수 있으므로 고가용성 설계가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;병목현상 가능성&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;처리량이 높은 경우 브로커가 병목현상이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-메시지-브로커-도구&#34;&gt;주요 메시지 브로커 도구&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Competing Consumers</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/competing-consumers/</guid>
      <description>&lt;h2 id=&#34;competing-consumers&#34;&gt;Competing Consumers&lt;/h2&gt;
&lt;p&gt;Competing Consumers 패턴은 여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.&lt;/p&gt;
&lt;p&gt;Competing Consumers 패턴은 MSA 환경에서 메시지 처리의 확장성과 효율성을 크게 향상시킬 수 있다. 하지만 메시지 순서와 같은 특정 요구사항이 있는 경우에는 신중하게 적용해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메시지 생성: 애플리케이션이 메시지 큐에 메시지를 게시한다.&lt;/li&gt;
&lt;li&gt;메시지 소비: 여러 소비자 인스턴스가 동일한 큐에서 메시지를 가져와 처리한다.&lt;/li&gt;
&lt;li&gt;경쟁: 각 소비자는 다음 메시지를 처리하기 위해 경쟁한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;메시지 생산자(Producer)&lt;/strong&gt;: 애플리케이션은 처리해야 할 작업을 메시지 형태로 메시지 큐에 게시한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐(Message Queue)&lt;/strong&gt;: 게시된 메시지는 큐에 저장되어 대기한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 소비자(Consumer)&lt;/strong&gt;: 여러 개의 소비자 인스턴스가 동일한 메시지 큐에서 메시지를 수신한다. 각 메시지는 한 번에 하나의 소비자에게만 전달되며, 이를 통해 작업이 병렬로 처리된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이러한 구조를 통해 시스템은 &lt;strong&gt;작업 부하를 여러 소비자 인스턴스에 분산&lt;/strong&gt;시켜 병목 현상을 방지하고, &lt;strong&gt;동시 처리 능력&lt;/strong&gt;을 향상시킨다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Filter</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-filter/</guid>
      <description>&lt;h2 id=&#34;message-filter&#34;&gt;Message Filter&lt;/h2&gt;
&lt;p&gt;Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.&lt;br&gt;
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.&lt;/p&gt;
&lt;p&gt;Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;단일 입력 채널과 단일 출력 채널을 가진다.&lt;/li&gt;
&lt;li&gt;정의된 기준에 따라 메시지를 평가한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하는 메시지만 출력 채널로 전달한다.&lt;/li&gt;
&lt;li&gt;기준을 충족하지 않는 메시지는 폐기된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;필터 조건 정의: 메시지를 평가할 기준을 설정한다.&lt;/li&gt;
&lt;li&gt;메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다.&lt;/li&gt;
&lt;li&gt;메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방식&#34;&gt;구현 방식&lt;/h3&gt;
&lt;p&gt;메시지 필터는 주로 다음과 같은 방식으로 구현된다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Message Router</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/message-router/</guid>
      <description>&lt;h2 id=&#34;message-router&#34;&gt;Message Router&lt;/h2&gt;
&lt;p&gt;Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Message Router는 MSA 환경에서 메시지 흐름을 효과적으로 관리하고 시스템의 유연성을 높이는 중요한 패턴이다. 적절히 구현하면 시스템의 확장성과 유지보수성을 크게 향상시킬 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;message-router의-주요-특징&#34;&gt;Message Router의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메시지 내용 기반 라우팅: 메시지의 페이로드나 헤더를 분석하여 라우팅 결정을 내린다.&lt;/li&gt;
&lt;li&gt;동적 라우팅: 런타임에 라우팅 규칙을 변경할 수 있어 시스템의 유연성을 높인다.&lt;/li&gt;
&lt;li&gt;다중 목적지 지원: 하나의 메시지를 여러 목적지로 라우팅할 수 있다.&lt;/li&gt;
&lt;li&gt;메시지 변환: 필요에 따라 메시지 형식을 변환할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router의-종류&#34;&gt;Message Router의 종류&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;콘텐츠 기반 라우터: 메시지 내용을 분석하여 라우팅한다.&lt;/li&gt;
&lt;li&gt;헤더 값 라우터: 메시지 헤더의 특정 값을 기준으로 라우팅한다.&lt;/li&gt;
&lt;li&gt;수신자 목록 라우터: 미리 정의된 수신자 목록에 따라 메시지를 분배한다.&lt;/li&gt;
&lt;li&gt;동적 라우터: 외부 조건이나 설정에 따라 라우팅 로직을 동적으로 변경한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router의-장점&#34;&gt;Message Router의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;유연성: 시스템 구성 요소 간의 결합도를 낮추어 유연성을 높인다.&lt;/li&gt;
&lt;li&gt;확장성: 새로운 처리 로직이나 목적지를 쉽게 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;트래픽 관리: 메시지 흐름을 제어하여 시스템 부하를 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;비즈니스 로직 분리: 라우팅 로직을 중앙화하여 비즈니스 로직과 분리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;복잡성 관리: 라우팅 규칙이 복잡해질수록 관리가 어려워질 수 있다.&lt;/li&gt;
&lt;li&gt;성능 고려: 복잡한 라우팅 로직은 시스템 성능에 영향을 줄 수 있다.&lt;/li&gt;
&lt;li&gt;오류 처리: 라우팅 실패 시의 오류 처리 전략이 필요하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;message-router-구현-예시&#34;&gt;Message Router 구현 예시&lt;/h3&gt;
&lt;p&gt;Node.js를 사용한 Message Filter&lt;/p&gt;</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/messaging/idempotent-consumer/</guid>
      <description>&lt;h2 id=&#34;idempotent-consumer&#34;&gt;Idempotent Consumer&lt;/h2&gt;
&lt;p&gt;Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.&lt;/p&gt;
&lt;p&gt;Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Domain event</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</link>
      <pubDate>Fri, 15 Nov 2024 11:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/domain-event/</guid>
      <description>&lt;h2 id=&#34;domain-event&#34;&gt;Domain Event&lt;/h2&gt;
&lt;p&gt;도메인 이벤트(Domain Event)는 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하고 시스템 간 의존성을 줄이며 확장성을 높이는 데 중요한 개념이다.&lt;br&gt;
도메인 이벤트는 주로 &lt;strong&gt;도메인 주도 설계(DDD)&lt;/strong&gt; 의 개념에서 비롯되었으며, 비즈니스 로직과 시스템 상태 변화의 핵심을 나타낸다.&lt;br&gt;
이를 통해 분산 시스템에서 데이터 일관성과 비즈니스 흐름을 효과적으로 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;도메인 이벤트는 &lt;strong&gt;도메인 내에서 발생한 중요한 상태 변화&lt;/strong&gt;를 나타내는 객체이다.&lt;br&gt;
이는 과거에 발생한 사건을 기술하며, 다른 모듈이나 시스템이 해당 이벤트를 구독하고 적절히 반응할 수 있도록 설계된다. 예를 들어, 전자상거래 시스템에서 &amp;ldquo;주문이 생성됨(Order Created)&amp;ldquo;이나 &amp;ldquo;결제가 완료됨(Payment Completed)&amp;rdquo; 같은 사건이 도메인 이벤트로 표현될 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Saga Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</link>
      <pubDate>Fri, 15 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/saga/</guid>
      <description>Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Aggregate Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</link>
      <pubDate>Fri, 15 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/</guid>
      <description>Aggregate 패턴은 도메인 주도 설계(DDD)에서 유래한 개념으로, 관련된 객체들을 하나의 단위로 묶어 데이터 변경 시 일관성을 유지한다.</description>
    </item>
    <item>
      <title>Event Sourcing</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/</link>
      <pubDate>Fri, 15 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/</guid>
      <description>&lt;h2 id=&#34;event-sourcing&#34;&gt;Event Sourcing&lt;/h2&gt;
&lt;p&gt;Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.&lt;br&gt;
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.&lt;/p&gt;
&lt;p&gt;Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;event-sourcing의-핵심-개념&#34;&gt;Event Sourcing의 핵심 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 중심 저장&lt;/strong&gt;: 시스템의 모든 상태 변경을 이벤트로 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;불변성&lt;/strong&gt;: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 순서&lt;/strong&gt;: 이벤트는 발생한 순서대로 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성&lt;/strong&gt;: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-장점&#34;&gt;Event Sourcing의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;완전한 감사 추적&lt;/strong&gt;: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;시간 여행 가능&lt;/strong&gt;: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-구현-방법&#34;&gt;Event Sourcing의 구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;이벤트 정의&lt;/strong&gt;: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 저장소&lt;/strong&gt;: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 핸들러&lt;/strong&gt;: 각 이벤트 유형에 대한 처리 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 재구성 로직&lt;/strong&gt;: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;event-sourcing의-주의사항&#34;&gt;Event Sourcing의 주의사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;성능 고려&lt;/strong&gt;: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이벤트 버전 관리&lt;/strong&gt;: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최종 일관성&lt;/strong&gt;: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;이벤트-소싱의-구현-시-고려사항&#34;&gt;이벤트 소싱의 구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;이벤트 저장소(Event Store)&lt;/strong&gt;: 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>3rd party registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/</guid>
      <description>이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.</description>
    </item>
    <item>
      <title>Self registration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/self-registration/</guid>
      <description>&lt;h2 id=&#34;self-registration&#34;&gt;Self Registration&lt;/h2&gt;
&lt;p&gt;Self Registration은 각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다. 서비스가 시작될 때 자동으로 등록되고, 종료될 때 해제되는 방식으로 동작한다.&lt;/p&gt;
&lt;p&gt;Self Registration 패턴은 마이크로서비스 환경에서 동적으로 변화하는 서비스 인스턴스를 효과적으로 관리할 수 있게 해주는 중요한 패턴이다. 하지만 구현의 복잡성과 유지보수 측면에서 주의가 필요하며, 프로젝트의 규모와 요구사항에 따라 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;자동 등록&lt;/strong&gt;: 서비스 인스턴스가 시작될 때 자신의 정보(호스트, IP 주소, 포트 등)를 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 해제&lt;/strong&gt;: 서비스가 종료될 때 레지스트리에서 자신의 정보를 제거한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;헬스체크&lt;/strong&gt;: 주기적으로 레지스트리에 헬스체크 신호를 보내 자신이 살아있음을 알린다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;상태 관리&lt;/strong&gt;: 서비스 인스턴스가 자신의 상태를 가장 잘 알기 때문에, UP/DOWN 외에도 STARTING, AVAILABLE 등 더 복잡한 상태 모델을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 레지스트리 설정: Eureka, Consul, ZooKeeper 등의 도구를 사용하여 중앙 레지스트리를 구축한다.&lt;/li&gt;
&lt;li&gt;서비스 등록 코드 구현: 각 마이크로서비스에 자신을 레지스트리에 등록하는 코드를 추가한다.&lt;/li&gt;
&lt;li&gt;헬스체크 메커니즘 구현: 주기적으로 레지스트리에 헬스체크 신호를 보내는 로직을 구현한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리 클라이언트 구현: 다른 서비스들이 등록된 서비스를 찾고 통신할 수 있도록 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;구현이 비교적 간단하다.&lt;/li&gt;
&lt;li&gt;추가적인 시스템 컴포넌트가 필요하지 않다.&lt;/li&gt;
&lt;li&gt;서비스가 자신의 상태를 가장 잘 알기 때문에 정확한 정보를 제공할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스와 레지스트리 간의 결합도가 높아진다.&lt;/li&gt;
&lt;li&gt;각 프로그래밍 언어와 프레임워크마다 등록 로직을 구현해야 한다.&lt;/li&gt;
&lt;li&gt;서비스가 비정상적으로 종료될 경우 레지스트리에서 자동으로 제거되지 않을 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Netflix Eureka&lt;/strong&gt;는 셀프 등록 패턴의 대표적인 예시이다.&lt;br&gt;
Eureka 클라이언트는 다음과 같은 방식으로 동작한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Server-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/server-side-discovery/</guid>
      <description>&lt;h2 id=&#34;server-side-discovery&#34;&gt;Server-side Discovery&lt;/h2&gt;
&lt;p&gt;Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.&lt;/p&gt;
&lt;p&gt;Server-side Discovery는 클라이언트를 단순화하고 중앙 집중식 관리를 가능하게 하는 장점이 있지만, 추가 인프라와 관리가 필요한 단점도 있다. 프로젝트의 요구사항과 팀의 역량을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;작동-원리&#34;&gt;작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;서비스 등록: 각 서비스 인스턴스는 시작 시 자신의 정보를 서비스 레지스트리에 등록한다.&lt;/li&gt;
&lt;li&gt;클라이언트 요청: 클라이언트는 서비스의 실제 위치를 모르고, 로드 밸런서에 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;서비스 조회: 로드 밸런서는 서비스 레지스트리에서 해당 서비스의 가용한 인스턴스 정보를 조회한다.&lt;/li&gt;
&lt;li&gt;요청 라우팅: 로드 밸런서는 적절한 서비스 인스턴스를 선택하여 요청을 전달한다.&lt;/li&gt;
&lt;li&gt;응답 반환: 서비스의 응답은 로드 밸런서를 통해 클라이언트에게 전달된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트 단순화: 클라이언트는 서비스 디스커버리 로직을 구현할 필요가 없어 단순해진다.&lt;/li&gt;
&lt;li&gt;언어 중립성: 클라이언트 측 구현이 필요 없어 다양한 프로그래밍 언어로 개발된 서비스들을 쉽게 통합할 수 있다.&lt;/li&gt;
&lt;li&gt;보안 강화: 로드 밸런서 수준에서 추가적인 보안 계층을 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;중앙 집중식 관리: 서비스 디스커버리와 로드 밸런싱을 중앙에서 관리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;추가 인프라 필요: 로드 밸런서나 프록시 서버와 같은 추가 인프라가 필요하다.&lt;/li&gt;
&lt;li&gt;단일 실패 지점: 로드 밸런서가 단일 실패 지점이 될 수 있어 고가용성 설계가 중요하다.&lt;/li&gt;
&lt;li&gt;복잡성 증가: 전체 시스템의 복잡성이 증가할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AWS Elastic Load Balancer (ELB)&lt;/strong&gt;: 클라이언트는 ELB의 DNS 이름을 통해 요청을 보내며, ELB는 등록된 EC2 인스턴스나 ECS 컨테이너 사이에서 부하를 분산한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes의 kube-proxy&lt;/strong&gt;: Kubernetes에서는 각 노드에서 실행되는 kube-proxy가 서비스 디스커버리와 로드 밸런싱을 담당하며, 클러스터 내의 서비스 요청을 적절한 파드(Pod)로 전달한다.&lt;/li&gt;
&lt;li&gt;Node.js를 사용한 Server-side Discovery 구현 예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-21&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-21&#34;&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-22&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-22&#34;&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-23&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-23&#34;&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-24&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-24&#34;&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-25&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-25&#34;&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-26&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-26&#34;&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-27&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-27&#34;&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-28&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-28&#34;&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-29&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-29&#34;&gt;29&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-30&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-30&#34;&gt;30&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-31&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-31&#34;&gt;31&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-32&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-32&#34;&gt;32&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-33&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-33&#34;&gt;33&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-34&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-34&#34;&gt;34&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-35&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-35&#34;&gt;35&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-36&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-36&#34;&gt;36&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-37&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-37&#34;&gt;37&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-38&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-38&#34;&gt;38&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-39&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-39&#34;&gt;39&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-40&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-40&#34;&gt;40&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-41&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-41&#34;&gt;41&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-42&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-42&#34;&gt;42&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-43&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-43&#34;&gt;43&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-44&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-44&#34;&gt;44&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-45&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-45&#34;&gt;45&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-46&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-46&#34;&gt;46&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-47&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-47&#34;&gt;47&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-48&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-48&#34;&gt;48&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-49&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-49&#34;&gt;49&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-50&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-50&#34;&gt;50&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-51&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-51&#34;&gt;51&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-52&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-52&#34;&gt;52&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 서버 사이드 디스커버리 라우터 구현
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServiceRouter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;registryUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://service-registry:8500&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cacheTimeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 30초
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LoadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extractServiceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 서비스 인스턴스 찾기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 요청 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 응답 전달
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handleError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;findServiceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 캐시된 서비스 확인
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getCachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cachedInstances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 서비스 레지스트리 조회
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;queryRegistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;updateCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selectInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;instances&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;forwardRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buildTargetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;serviceInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;targetUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service registry</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/service-registry/</guid>
      <description>&lt;h2 id=&#34;service-registry&#34;&gt;Service Registry&lt;/h2&gt;
&lt;p&gt;Service Registry는 마이크로서비스 환경에서 각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스이다.&lt;br&gt;
이는 동적으로 변화하는 마이크로서비스 환경에서 서비스 디스커버리를 가능하게 하는 핵심 요소이다.&lt;/p&gt;
&lt;p&gt;Service Registry는 MSA 환경에서 서비스 디스커버리를 가능하게 하는 핵심 컴포넌트이다. 이를 통해 동적이고 확장 가능한 마이크로서비스 아키텍처를 구현할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;서비스-레지스트리의-중요성&#34;&gt;서비스 레지스트리의 중요성&lt;/h3&gt;
&lt;p&gt;MSA 환경에서는 서비스 인스턴스가 자동 확장, 장애 복구, 배포 등의 이유로 동적으로 생성되고 소멸되며, 이에 따라 네트워크 위치가 변경된다.&lt;br&gt;
이러한 동적인 특성으로 인해, 서비스 레지스트리는 다음과 같은 역할을 수행한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Client-side discovery</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/client-side-discovery/</guid>
      <description>&lt;h2 id=&#34;client-side-discovery&#34;&gt;Client-side Discovery&lt;/h2&gt;
&lt;p&gt;Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.&lt;/p&gt;
&lt;p&gt;Client-side Discovery는 마이크로서비스 환경에서 유연하고 확장 가능한 서비스 디스커버리 방식을 제공한다. 그러나 클라이언트의 복잡도가 증가하는 단점이 있으므로, 프로젝트의 요구사항과 팀의 기술 스택을 고려하여 적절히 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;서비스 레지스트리(Service Registry)&lt;/strong&gt;: 각 서비스 인스턴스의 네트워크 위치(예: IP 주소, 포트)를 저장하고 관리하는 데이터베이스이다. 서비스 인스턴스는 시작 시 자신의 정보를 레지스트리에 등록하고, 종료 시 등록을 해제한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Backend for Frontend Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</link>
      <pubDate>Thu, 14 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/backend-for-frontend/</guid>
      <description>BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다.</description>
    </item>
    <item>
      <title>API Gateway Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway/</link>
      <pubDate>Thu, 14 Nov 2024 01:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/api-gateway/</guid>
      <description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</description>
    </item>
    <item>
      <title>Service deployment platform</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-deployment-platform/</guid>
      <description>&lt;h2 id=&#34;service-deployment-platform&#34;&gt;Service Deployment Platform&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service deployment platform&amp;quot;은 마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼이다. 이 플랫폼은 개발자들이 마이크로서비스를 쉽게 개발, 배포, 운영할 수 있도록 지원하는 종합적인 환경을 제공한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;자동화된 배포: Service deployment platform은 CI/CD (지속적 통합/지속적 배포) 파이프라인을 통해 자동화된 배포 프로세스를 제공한다. 이를 통해 개발자는 코드 변경사항을 빠르고 안정적으로 프로덕션 환경에 반영할 수 있다.&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션: 대부분의 Service deployment platform은 쿠버네티스와 같은 컨테이너 오케스트레이션 도구를 기반으로 한다. 이를 통해 마이크로서비스의 확장성, 가용성, 복원력을 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리: 플랫폼은 서비스 디스커버리 메커니즘을 제공하여 마이크로서비스 간의 통신을 용이하게 한다. 이를 통해 동적으로 변화하는 환경에서도 서비스 간 연결을 유지할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅: Service deployment platform은 통합된 모니터링 및 로깅 기능을 제공한다. 이를 통해 개발자와 운영팀은 서비스의 성능을 실시간으로 모니터링하고 문제를 신속하게 진단할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 레지스트리: 서비스의 컨테이너 이미지를 저장하고 관리하는 중앙 저장소이다.&lt;/li&gt;
&lt;li&gt;오케스트레이션 엔진: 쿠버네티스와 같은 도구로, 컨테이너의 배포, 스케일링, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;API 게이트웨이: 클라이언트 요청을 적절한 마이크로서비스로 라우팅하고 인증, 로드 밸런싱 등의 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;서비스 메시: 마이크로서비스 간의 통신을 관리하고 모니터링하는 인프라 레이어이다.&lt;/li&gt;
&lt;li&gt;설정 관리: 다양한 환경(개발, 테스트, 프로덕션)에 대한 설정을 중앙에서 관리한다.&lt;/li&gt;
&lt;li&gt;로깅 및 모니터링 도구: 서비스의 성능과 상태를 추적하고 분석하는 도구들이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;개발 생산성 향상: 개발자가 인프라 관리보다는 비즈니스 로직 개발에 집중할 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;빠른 배포 및 롤백: 자동화된 프로세스를 통해 신속한 배포와 문제 발생 시 빠른 롤백이 가능하다.&lt;/li&gt;
&lt;li&gt;확장성: 트래픽 증가에 따라 서비스를 쉽게 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;운영 효율성: 자동화된 모니터링과 관리 도구를 통해 운영 효율성을 높일 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;대표적인-서비스-배포-플랫폼&#34;&gt;대표적인 서비스 배포 플랫폼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;쿠버네티스(Kubernetes):&lt;/strong&gt; 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 플랫폼으로, MSA 환경에서 널리 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;오픈시프트(OpenShift):&lt;/strong&gt; 레드햇에서 개발한 쿠버네티스 기반의 엔터프라이즈급 애플리케이션 플랫폼으로, 추가적인 개발자 및 운영자 도구를 제공한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이스티오(Istio):&lt;/strong&gt; 서비스 메시(Service Mesh) 구현체로, 서비스 간의 통신, 보안, 모니터링, 트래픽 관리를 지원하여 MSA의 운영 복잡성을 줄여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도입-시-고려사항&#34;&gt;도입 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;러닝 커브:&lt;/strong&gt; 새로운 플랫폼 도입에 따른 학습 곡선이 있을 수 있으므로, 충분한 교육과 학습 기간이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인프라 요구사항:&lt;/strong&gt; 플랫폼이 요구하는 인프라 자원을 사전에 평가하고, 이에 맞게 인프라를 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; 플랫폼 자체의 보안 기능과 더불어, 조직의 보안 정책에 부합하는지 검토해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;커뮤니티 및 지원:&lt;/strong&gt; 플랫폼의 커뮤니티 활성도와 지원 체계를 확인하여, 문제 발생 시 신속한 대응이 가능한지 판단해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-vm/</guid>
      <description>&lt;h2 id=&#34;service-per-vm&#34;&gt;Service per VM&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; (VM당 서비스) 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식이다. 이 패턴의 주요 특징과 장단점을 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Service per-VM&amp;rdquo; 패턴은 강력한 격리와 리소스 관리를 제공하지만, 리소스 오버헤드와 관리 복잡성 증가라는 대가가 따른다. 이 패턴은 높은 수준의 격리가 필요하거나 서비스 간 리소스 경쟁을 최소화해야 하는 경우에 적합하다.&lt;br&gt;
그러나 리소스 효율성과 빠른 배포가 중요한 경우에는 다른 배포 패턴을 고려해볼 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/multiple-services-per-host/</guid>
      <description>&lt;h2 id=&#34;multiple-services-per-host&#34;&gt;Multiple Services per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Multiple Services per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;이 패턴에서는 하나 이상의 물리적 또는 가상 호스트를 준비하고, 각 호스트에 여러 개의 서비스 인스턴스를 실행한다. 이는 전통적인 애플리케이션 배포 방식을 반영한 것이다.&lt;/p&gt;
&lt;p&gt;이 패턴은 리소스 효율성과 배포 용이성이라는 장점이 있지만, 복잡성 증가와 서비스 간 격리 부족이라는 단점도 있다. 따라서 프로젝트의 요구사항과 규모에 따라 신중하게 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per-Container</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-per-container/</guid>
      <description>&lt;h2 id=&#34;service-per-container&#34;&gt;Service per-Container&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Service per-Container&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;독립성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;경량화&lt;/strong&gt;: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이식성&lt;/strong&gt;: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 &amp;ldquo;한 번 빌드하고 어디서나 실행&amp;quot;이라는 원칙을 실현한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;버전 관리&lt;/strong&gt;: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장애 격리&lt;/strong&gt;: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기술 스택 다양성&lt;/strong&gt;: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;배포 유연성&lt;/strong&gt;: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡성 증가&lt;/strong&gt;: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리소스 오버헤드&lt;/strong&gt;: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;통신 오버헤드&lt;/strong&gt;: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컨테이너 오케스트레이션&lt;/strong&gt;: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 디스커버리&lt;/strong&gt;: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;로깅 및 모니터링&lt;/strong&gt;: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다.&lt;/li&gt;
&lt;li&gt;컨테이너 이미지 최적화
&lt;ol&gt;
&lt;li&gt;기반 이미지 최소화&lt;/li&gt;
&lt;li&gt;멀티 스테이지 빌드 적용&lt;/li&gt;
&lt;li&gt;캐시 레이어 최적화&lt;/li&gt;
&lt;li&gt;불필요한 파일 제거&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;네트워킹
&lt;ol&gt;
&lt;li&gt;서비스간 통신 설정&lt;/li&gt;
&lt;li&gt;네트워크 보안 정책&lt;/li&gt;
&lt;li&gt;로드 밸런싱&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-방법&#34;&gt;구현 방법&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 이미지 생성:
&lt;ul&gt;
&lt;li&gt;각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다.&lt;/li&gt;
&lt;li&gt;Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컨테이너 오케스트레이션:
&lt;ul&gt;
&lt;li&gt;Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다.&lt;/li&gt;
&lt;li&gt;서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모니터링 및 로깅 설정:
&lt;ul&gt;
&lt;li&gt;Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;p&gt;예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/single-service-per-host/</guid>
      <description>&lt;h2 id=&#34;single-service-per-host&#34;&gt;Single Service per Host&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Single Service per Host&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.&lt;/p&gt;
&lt;p&gt;Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/serverless-deployment/</guid>
      <description>&lt;h2 id=&#34;serverless-deployment&#34;&gt;Serverless Deployment&lt;/h2&gt;
&lt;p&gt;Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 혁신적인 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.&lt;/p&gt;
&lt;p&gt;결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/self-contained-service/</guid>
      <description>&lt;h2 id=&#34;self-contained-service&#34;&gt;Self-contained Service&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;self-contained service&amp;rdquo; 패턴은 서비스의 자율성과 독립성을 극대화하는 중요한 개념이다.&lt;/p&gt;
&lt;p&gt;Self-contained Service는 단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.&lt;br&gt;
이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.&lt;/p&gt;
&lt;p&gt;Self-contained Service 패턴은 MSA의 핵심 원칙을 구현하는 방법 중 하나로, 서비스의 자율성과 독립성을 극대화하여 시스템의 유연성과 확장성을 높이는 데 기여한다. 하지만 이 패턴을 적용할 때는 시스템의 복잡성 증가와 데이터 일관성 관리 등의 도전 과제를 고려해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/service-per-team/</guid>
      <description>&lt;h2 id=&#34;service-per-team&#34;&gt;Service per Team&lt;/h2&gt;
&lt;p&gt;Service per team 패턴은 각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식이다.&lt;br&gt;
이 패턴에서는 각 팀이 특정 비즈니스 기능을 담당하며, 해당 기능의 코드베이스를 소유한다.&lt;/p&gt;
&lt;p&gt;Service per team 패턴은 팀의 자율성과 책임감을 높이는 동시에 마이크로서비스 아키텍처의 이점을 최대화할 수 있는 효과적인 접근 방식이다. 그러나 이 패턴을 성공적으로 구현하기 위해서는 조직 문화, 팀 구조, 그리고 기술적 인프라 등 여러 측면에서의 신중한 고려가 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성&lt;/strong&gt;: 각 팀은 자신의 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 중심 협업&lt;/strong&gt;: 팀들은 주로 API를 통해 상호작용하며, 다른 팀과의 협업을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;소규모 팀&lt;/strong&gt;: 일반적으로 &amp;ldquo;two-pizza team&amp;rdquo; 크기의 소규모 팀이 각 서비스를 담당한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인지 부하 감소&lt;/strong&gt;: 팀원들이 전체 시스템이 아닌 특정 서비스에만 집중할 수 있어 인지 부하가 감소한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 자율성 강화&lt;/strong&gt;: 각 팀이 독립적으로 의사 결정을 내릴 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;느슨한 결합&lt;/strong&gt;: 팀 간의 의존성이 줄어들어 더 유연한 개발이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;코드 품질 향상&lt;/strong&gt;: 장기적인 코드 소유권으로 인해 코드 품질이 개선된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;빠른 개발 및 배포&lt;/strong&gt;: 작은 팀이 독립적으로 개발하고 배포할 수 있어 시장 변화에 빠르게 대응할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;복잡한 프로젝트 조정&lt;/strong&gt;: 여러 서비스에 걸친 복잡한 프로젝트의 경우 팀 간 조정이 어려워질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;높은 WIP (Work in Progress)&lt;/strong&gt;: 각 팀이 항상 바쁘게 유지되어야 하므로 진행 중인 작업이 많아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;좁은 가치 흐름&lt;/strong&gt;: 이상적인 구현에서는 팀들이 완전히 분리되어 있어, 조직 전체의 가치 흐름이 좁아질 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;최적화되지 않은 우선순위 지정&lt;/strong&gt;: 팀의 가용성이 프로젝트 우선순위 결정의 주요 요인이 될 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-시-고려사항&#34;&gt;구현 시 고려사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;팀 구성&lt;/strong&gt;: 각 서비스를 담당할 수 있는 cross-functional 팀을 구성해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서비스 경계 정의&lt;/strong&gt;: 비즈니스 기능과 하위 도메인을 기반으로 서비스 경계를 명확히 정의해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀 간 커뮤니케이션&lt;/strong&gt;: API 설계와 변경에 대한 팀 간 효과적인 커뮤니케이션 채널을 구축해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 고려&lt;/strong&gt;: 새로운 팀을 추가하거나 기존 서비스를 분할할 때의 전략을 미리 수립해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;예시&#34;&gt;&lt;strong&gt;예시:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;대규모 전자상거래 플랫폼을 운영하는 기업을 예로 들어보자.&lt;br&gt;
이 기업은 다음과 같은 주요 비즈니스 기능을 가지고 있다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Service Mesh</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-mesh/</link>
      <pubDate>Wed, 13 Nov 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/service-mesh/</guid>
      <description>마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하기 위한 인프라 계층</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-business-capability/</guid>
      <description>&lt;h2 id=&#34;decompose-by-business-capability&#34;&gt;Decompose by Business Capability&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Business Capability&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴이다.&lt;br&gt;
이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.&lt;/p&gt;
&lt;p&gt;이 패턴은 조직의 비즈니스 능력을 기반으로 마이크로서비스를 정의한다.&lt;br&gt;
비즈니스 능력은 조직이 가치를 창출하기 위해 수행하는 특정 기능이나 프로세스를 의미한다.&lt;/p&gt;
&lt;p&gt;주요 목적은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;비즈니스 목표와 소프트웨어 개발의 정렬&lt;/li&gt;
&lt;li&gt;독립적으로 개발 및 유지보수 가능한 서비스 생성&lt;/li&gt;
&lt;li&gt;조직 구조와 시스템 아키텍처의 일치&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 조직의 비즈니스 도메인에 대한 깊은 이해가 필요하며, 지속적인 비즈니스 분석과 서비스 경계의 조정이 필요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/decompose-by-subdomain/</guid>
      <description>&lt;h2 id=&#34;decompose-by-subdomain&#34;&gt;Decompose by Subdomain&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Decompose by Subdomain&amp;rdquo; 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴 중 하나이다.&lt;br&gt;
이 패턴은 도메인 주도 설계(DDD)의 개념을 기반으로 하며, 비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법이다.&lt;/p&gt;
&lt;p&gt;이 패턴을 효과적으로 적용하려면 비즈니스 도메인에 대한 깊은 이해와 지속적인 분석이 필요하다. 또한, 하위 도메인 간의 상호작용을 고려하여 서비스 간 통신을 설계해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;비즈니스 중심 접근: 기술적 세부사항보다 비즈니스 기능에 초점을 맞춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하위 도메인 분류:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;핵심(Core): 비즈니스의 핵심 차별화 요소&lt;/li&gt;
&lt;li&gt;지원(Supporting): 비즈니스 관련이지만 차별화 요소는 아님&lt;/li&gt;
&lt;li&gt;일반(Generic): 비즈니스 특화되지 않은 일반적 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경계 설정: 각 하위 도메인은 명확한 경계(Bounded Context)를 가진다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Domain-specific</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/</guid>
      <description>&lt;h2 id=&#34;domain-specific&#34;&gt;Domain-specific&lt;/h2&gt;
&lt;p&gt;Domain-specific 프로토콜은 특정 도메인이나 비즈니스 영역에 특화된 통신 프로토콜을 의미한다.&lt;br&gt;
이 프로토콜은 일반적인 통신 프로토콜보다 해당 도메인의 특성과 요구사항에 더 적합하게 설계되어 있다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;도메인 주도 설계(DDD)와의 연계:&lt;/strong&gt; 도메인 주도 설계는 복잡한 소프트웨어를 개발할 때 도메인 모델을 중심으로 설계하는 접근 방식이다. MSA에서 도메인별 통신 스타일을 적용하면, 각 도메인의 비즈니스 로직과 데이터가 해당 서비스 내에서 캡슐화되어 독립성을 유지할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;통신 프로토콜의 선택:&lt;/strong&gt; 각 도메인의 특성에 따라 적합한 통신 프로토콜을 선택한다. 예를 들어, 실시간성이 중요한 도메인에서는 gRPC나 GraphQL과 같은 프로토콜을, 비동기 처리가 적합한 도메인에서는 Kafka나 AMQP와 같은 메시징 프로토콜을 사용할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Remote-Procedure</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</link>
      <pubDate>Tue, 12 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/</guid>
      <description>&lt;h2 id=&#34;remote-procedure&#34;&gt;Remote-Procedure&lt;/h2&gt;
&lt;p&gt;Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.&lt;/p&gt;
&lt;h3 id=&#34;rpc의-작동-원리&#34;&gt;RPC의 작동 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트가 로컬 프로시저를 호출한다.&lt;/li&gt;
&lt;li&gt;클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다.&lt;/li&gt;
&lt;li&gt;클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다.&lt;/li&gt;
&lt;li&gt;서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다.&lt;/li&gt;
&lt;li&gt;서버 스텁이 파라미터를 언마샬링(unmarshalling)한다.&lt;/li&gt;
&lt;li&gt;서버 스텁이 서버 프로시저를 호출한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-특징&#34;&gt;RPC의 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다.&lt;/li&gt;
&lt;li&gt;높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다.&lt;/li&gt;
&lt;li&gt;위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpi-패턴의-주요-구성-요소&#34;&gt;RPI 패턴의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다.&lt;/li&gt;
&lt;li&gt;서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-장점&#34;&gt;RPC의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;효율성: 도메인 특화 기능으로 통신 효율성이 높아진다.&lt;/li&gt;
&lt;li&gt;구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc의-단점&#34;&gt;RPC의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다.&lt;/li&gt;
&lt;li&gt;복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다.&lt;/li&gt;
&lt;li&gt;호환성 문제: 다른 시스템과의 통합이 어려울 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpi-패턴-구현-시-고려해야-할-사항&#34;&gt;RPI 패턴 구현 시 고려해야 할 사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다.&lt;/li&gt;
&lt;li&gt;확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;msa에서의-rpc-활용&#34;&gt;MSA에서의 RPC 활용&lt;/h3&gt;
&lt;p&gt;마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Messaging</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</link>
      <pubDate>Tue, 12 Nov 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/</guid>
      <description>&lt;h2 id=&#34;messaging&#34;&gt;Messaging&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 Messaging은 중요한 Communication style 중 하나이다.&lt;br&gt;
Messaging은 서비스 간 비동기 통신을 가능하게 하며, 시스템의 확장성과 유연성을 향상시킨다.&lt;/p&gt;
&lt;p&gt;Messaging은 서비스들이 메시지를 통해 비동기적으로 통신하는 방식이다. 서비스들은 메시지 브로커를 통해 메시지를 주고받으며, 이를 통해 느슨한 결합(loose coupling)을 실현한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비동기 통신&lt;/strong&gt;: 서비스는 메시지를 보내고 즉시 다른 작업을 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;느슨한 결합&lt;/strong&gt;: 서비스들은 직접적인 연결 없이 메시지를 통해 통신한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 구조&lt;/strong&gt;: 메시지는 일반적으로 헤더(header)와 바디(message body)로 구성된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;채널 기반 통신&lt;/strong&gt;: 메시지는 채널을 통해 전달된다. point-to-point 채널과 publish-subscribe 채널이 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;messaging-패턴&#34;&gt;Messaging 패턴&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Request/Response&lt;/strong&gt;: 서비스가 요청 메시지를 보내고 응답을 기다린다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Notifications&lt;/strong&gt;: 서비스가 메시지를 보내지만 응답을 기대하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Publish/Subscribe&lt;/strong&gt;: 서비스가 메시지를 발행하면 여러 수신자가 구독할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event-Driven&lt;/strong&gt;: 서비스가 이벤트를 발행하고 다른 서비스들이 이에 반응한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;messaging-패턴의-주요-구성-요소&#34;&gt;Messaging 패턴의 주요 구성 요소&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;메시지 구조:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Microservice Chassis</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/</guid>
      <description>&lt;h2 id=&#34;microservice-chassis&#34;&gt;Microservice Chassis&lt;/h2&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 프레임워크나 라이브러리 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Microservice Chassis는 마이크로서비스 개발에 필요한 공통 기능을 제공하는 기본 프레임워크이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;공통 기능의 추상화:&lt;/strong&gt; 인증 및 권한 부여, 로깅, 설정 관리, 헬스 체크, 메트릭 수집, 분산 추적 등 여러 서비스에 걸쳐 공통적으로 필요한 기능들을 섀시에서 제공하여 코드 중복을 최소화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관된 빌드 및 배포 프로세스:&lt;/strong&gt; 빌드 로직과 배포 설정을 섀시에서 관리하여, 모든 서비스가 일관된 방식으로 빌드되고 배포될 수 있도록 지원한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 새로운 서비스 개발 시 섀시를 기반으로 빠르게 시작할 수 있으며, 공통 기능의 변경이 필요할 경우 섀시를 업데이트하여 모든 서비스에 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Microservice Chassis는 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Service Template</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</link>
      <pubDate>Tue, 12 Nov 2024 11:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/</guid>
      <description>&lt;h2 id=&#34;service-template&#34;&gt;Service Template&lt;/h2&gt;
&lt;p&gt;Service Template 패턴은 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 중요한 패턴이다.&lt;br&gt;
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 템플릿 형태로 제공한다.&lt;/p&gt;
&lt;p&gt;Service Template은 마이크로서비스 개발에 필요한 공통 기능과 구조를 제공하는 기본 템플릿이다.&lt;br&gt;
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;재사용 가능한 코드 기반:&lt;/strong&gt; 서비스 템플릿은 빌드 로직, 공통 설정, 크로스커팅 관심사(예: 로깅, 보안, 설정 관리 등)를 포함한 실행 가능한 간단한 서비스를 제공한다. 이를 통해 새로운 서비스를 시작할 때 필요한 기본 구조를 빠르게 구축할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일관성 유지:&lt;/strong&gt; 모든 서비스가 동일한 템플릿을 기반으로 생성되므로, 코드 구조와 설정이 일관되어 유지보수성과 가독성이 향상된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주요-기능&#34;&gt;주요 기능&lt;/h3&gt;
&lt;p&gt;Service Template은 다음과 같은 Cross-Cutting Concern을 처리한다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Database per Service Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/</guid>
      <description>&lt;h2 id=&#34;shared-database&#34;&gt;Shared Database&lt;/h2&gt;
&lt;p&gt;마이크로서비스 아키텍처(MSA)에서 &amp;ldquo;Shared Database&amp;rdquo; 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.&lt;/p&gt;
&lt;p&gt;Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/docker/</link>
      <pubDate>Mon, 11 Nov 2024 15:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/docker/</guid>
      <description>빠르게 애플리케이션을 구축, 테스트 및 배포할 수 있도록 도와주는 컨테이너 런타임 기술</description>
    </item>
    <item>
      <title>Portainer</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/portainer/</link>
      <pubDate>Mon, 11 Nov 2024 15:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/portainer/</guid>
      <description>컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구</description>
    </item>
    <item>
      <title>분산 잠금 (Distributed Locking)</title>
      <link>https://buenhyden.github.io/posts/system-design/distributed-system/distributed-locking/</link>
      <pubDate>Mon, 11 Nov 2024 15:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/distributed-system/distributed-locking/</guid>
      <description>분산 시스템 환경에서 여러 노드 또는 프로세스 간에 공유 자원에 대한 접근을 동기화하는 메커니즘</description>
    </item>
    <item>
      <title>VMware</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/vmware/</link>
      <pubDate>Mon, 11 Nov 2024 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/vmware/</guid>
      <description>가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구</description>
    </item>
    <item>
      <title>Envoy</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/kubernetes/envoy/</link>
      <pubDate>Mon, 11 Nov 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/kubernetes/envoy/</guid>
      <description>Kubernetes 환경에서 널리 사용되는 고성능 프록시 서버</description>
    </item>
    <item>
      <title>Istio</title>
      <link>https://buenhyden.github.io/posts/system-design/distributed-system/istio/</link>
      <pubDate>Mon, 11 Nov 2024 06:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/distributed-system/istio/</guid>
      <description>마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하는 서비스 메시(Service Mesh) 플랫폼</description>
    </item>
    <item>
      <title>Helm</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/kubernetes/helm/</link>
      <pubDate>Mon, 11 Nov 2024 06:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/kubernetes/helm/</guid>
      <description>쿠버네티스를 위한 패키지 관리자로, 복잡한 쿠버네티스 애플리케이션의 배포와 관리를 간소화하는 도구</description>
    </item>
    <item>
      <title>VirtualBox</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/virtualbox/</link>
      <pubDate>Mon, 11 Nov 2024 04:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/virtualbox/</guid>
      <description>가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구</description>
    </item>
    <item>
      <title>클라우드(AWS, GCP, Azure, NCP) 비교</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/cloud/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Sun, 10 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/cloud/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%B9%84%EA%B5%90/</guid>
      <description>네이버 클라우드 플랫폼(NCP)과 AWS, Azure, Google Cloud Platform(GCP)의 주요 서비스를 비교하여 설명</description>
    </item>
    <item>
      <title>온프레미스(On-Premise)</title>
      <link>https://buenhyden.github.io/til/2024/11/10/on-premise/</link>
      <pubDate>Sun, 10 Nov 2024 10:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/10/on-premise/</guid>
      <description>On-Premise는 기업이 자체적으로 보유한 시설이나 건물에 IT 인프라를 구축하고 운영하는 방식을 의미한다.</description>
    </item>
    <item>
      <title>IaaS PaaS SaaS</title>
      <link>https://buenhyden.github.io/posts/system-design/infrastructure/cloud/iaas-paas-saas/</link>
      <pubDate>Sun, 10 Nov 2024 06:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-design/infrastructure/cloud/iaas-paas-saas/</guid>
      <description>IaaS, PaaS, SaaS는 클라우드 컴퓨팅의 주요 서비스 모델</description>
    </item>
    <item>
      <title>비대칭키 암호화 (Asymmetric Encryption)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/asymmetric-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 21:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/asymmetric-encryption/</guid>
      <description>공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식</description>
    </item>
    <item>
      <title>해시 함수 (Hash Functions)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/hash-functions/</link>
      <pubDate>Sat, 09 Nov 2024 21:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/hash-functions/</guid>
      <description>임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수</description>
    </item>
    <item>
      <title>대칭키 암호화 (Symmetric Encryption)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/symmetric-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 21:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/symmetric-encryption/</guid>
      <description>동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식</description>
    </item>
    <item>
      <title>Content Security Policy</title>
      <link>https://buenhyden.github.io/til/2024/11/09/content-security-policy/</link>
      <pubDate>Sat, 09 Nov 2024 19:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/09/content-security-policy/</guid>
      <description>신뢰된 웹 페이지 콘텍스트에서 악의적인 콘텐츠를 실행하게 하는 사이트 간 스크립팅, 클릭재킹, 그리고 기타 코드 인젝션 공격을 예방하기 위해 도입된 컴퓨터 보안 표준</description>
    </item>
    <item>
      <title>동형 암호화(Homomorphic Encryption)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/homomorphic-encryption/</link>
      <pubDate>Sat, 09 Nov 2024 13:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/homomorphic-encryption/</guid>
      <description>동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술</description>
    </item>
    <item>
      <title>양자 암호화(quantum cryptography)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/quantum-cryptography/</link>
      <pubDate>Sat, 09 Nov 2024 13:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/quantum-cryptography/</guid>
      <description>양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술</description>
    </item>
    <item>
      <title>영지식 증명(Zero-Knowledge Proof, ZKP)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/</link>
      <pubDate>Sat, 09 Nov 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/</guid>
      <description>영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.</description>
    </item>
    <item>
      <title>The Open Web Application Security Project</title>
      <link>https://buenhyden.github.io/til/2024/11/09/the-open-web-application-security-project/</link>
      <pubDate>Sat, 09 Nov 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/09/the-open-web-application-security-project/</guid>
      <description>웹 애플리케이션의 가장 심각한 보안 위험 10가지를 정리한 보고서</description>
    </item>
    <item>
      <title>Server Security</title>
      <link>https://buenhyden.github.io/til/2024/11/09/server-security/</link>
      <pubDate>Sat, 09 Nov 2024 07:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/09/server-security/</guid>
      <description>서버를 무단 액세스, 데이터 유출 및 기타 보안 위협으로부터 보호하기 위한 프로세스와 도구를 의미</description>
    </item>
    <item>
      <title>디지털 서명 (digital signature)</title>
      <link>https://buenhyden.github.io/posts/security/encryption-and-decryption/digital-signature/</link>
      <pubDate>Sat, 09 Nov 2024 06:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/encryption-and-decryption/digital-signature/</guid>
      <description>전자 문서나 메시지의 진위성, 무결성, 그리고 부인 방지를 보장하기 위해 사용되는 암호화 기술</description>
    </item>
    <item>
      <title>제로 트러스트 (Zero Trust)</title>
      <link>https://buenhyden.github.io/til/2024/11/09/zero-trust/</link>
      <pubDate>Sat, 09 Nov 2024 01:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/09/zero-trust/</guid>
      <description> &amp;#34;절대 신뢰하지 말고, 항상 검증하라(Never trust, always verify)&amp;#34;라는 보안 철학에 기반을 둔 현대적인 보안 접근 방식</description>
    </item>
    <item>
      <title>Nonce</title>
      <link>https://buenhyden.github.io/posts/security/cryptography/nonce/</link>
      <pubDate>Fri, 08 Nov 2024 15:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/cryptography/nonce/</guid>
      <description>&amp;#34;Number used Once&amp;#34;의 약자로 단 한 번만 사용되는 임의의 숫자</description>
    </item>
    <item>
      <title>Message Authentication Code</title>
      <link>https://buenhyden.github.io/posts/security/cryptography/message-authentication-code/</link>
      <pubDate>Fri, 08 Nov 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/cryptography/message-authentication-code/</guid>
      <description>Message Authentication Code는 메시지의 무결성(integrity)과 출처 인증(authentication)을 동시에 보장하기 위한 암호학적 도구로, 메시지와 비밀키를 입력으로 받아 고정된 길이의 값을 생성하며, 이 값은 메시지에 대한 일종의 디지털 지문 역할을 한다.</description>
    </item>
    <item>
      <title>방화벽 (Firewall)</title>
      <link>https://buenhyden.github.io/posts/security/security-tools/firewall/</link>
      <pubDate>Fri, 08 Nov 2024 06:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-tools/firewall/</guid>
      <description>네트워크 보안의 핵심 요소로, 내부 네트워크를 외부의 위협으로부터 보호하는 시스템.</description>
    </item>
    <item>
      <title>IDS and IPS</title>
      <link>https://buenhyden.github.io/posts/security/security-tools/ids-and-ips/</link>
      <pubDate>Fri, 08 Nov 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-tools/ids-and-ips/</guid>
      <description>IDS(침입 탐지 시스템)와 IPS(침입 방지 시스템)는 네트워크 보안을 위한 중요한 개념이다. 이 두 시스템은 네트워크 상의 악의적인 활동을 탐지하고 대응하는 데 사용된다.</description>
    </item>
    <item>
      <title>CCE(Common Configuration Enumeration)</title>
      <link>https://buenhyden.github.io/posts/security/security-vulnerability/cce/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-vulnerability/cce/</guid>
      <description>CCE(Common Configuration Enumeration)는 시스템의 보안 설정과 관련된 취약점을 식별하고 관리하기 위한 표준화된 명명 체계</description>
    </item>
    <item>
      <title>CVE</title>
      <link>https://buenhyden.github.io/posts/security/security-vulnerability/cve/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-vulnerability/cve/</guid>
      <description>CVE(Common Vulnerabilities and Exposures)는 공개적으로 알려진 컴퓨터 보안 취약점을 식별하고 카탈로그화하는 표준화된 시스템</description>
    </item>
    <item>
      <title>CVSS(Common Vulnerability Scoring System)</title>
      <link>https://buenhyden.github.io/posts/security/security-vulnerability/cvss/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-vulnerability/cvss/</guid>
      <description>CVSS(Common Vulnerability Scoring System)는 보안 취약점의 심각도를 평가하고 수치화하는 표준화된 시스템</description>
    </item>
    <item>
      <title>CWE(Common Weakness Enumeration)</title>
      <link>https://buenhyden.github.io/posts/security/security-vulnerability/cwe/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/security-vulnerability/cwe/</guid>
      <description>CWE(Common Weakness Enumeration)는 소프트웨어와 하드웨어의 보안 약점을 체계적으로 분류하고 나열한 표준화된 목록</description>
    </item>
    <item>
      <title>Session base Auth and Cookie base Auth</title>
      <link>https://buenhyden.github.io/til/2024/11/07/session-base-auth-and-cookie-base-auth/</link>
      <pubDate>Thu, 07 Nov 2024 02:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/07/session-base-auth-and-cookie-base-auth/</guid>
      <description>세션 기반 인증(Session Based Authentication)과 쿠키 기반 인증(Cookie Based Authentication)은 웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식이다.</description>
    </item>
    <item>
      <title>DAC</title>
      <link>https://buenhyden.github.io/posts/security/authorization/dac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authorization/dac/</guid>
      <description>리소스의 소유자가 해당 리소스에 대한다른  사용자들의 접근 권한을 직접 제어할 수 있는 접근 제어 방식</description>
    </item>
    <item>
      <title>MAC</title>
      <link>https://buenhyden.github.io/posts/security/authorization/mac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authorization/mac/</guid>
      <description>시스템 전체에 걸쳐 중앙에서 정의된 보안 정책에 따라 접근 권한을 강제로 적용하는 접근 제어 방식.</description>
    </item>
    <item>
      <title>PBAC</title>
      <link>https://buenhyden.github.io/posts/security/authorization/pbac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authorization/pbac/</guid>
      <description>중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.  각 정책은 &amp;#34;누가&amp;#34;, &amp;#34;무엇을&amp;#34;, &amp;#34;어떤 조건에서&amp;#34; 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.</description>
    </item>
    <item>
      <title>ABAC</title>
      <link>https://buenhyden.github.io/posts/security/authorization/abac/</link>
      <pubDate>Wed, 06 Nov 2024 23:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authorization/abac/</guid>
      <description>ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.</description>
    </item>
    <item>
      <title>RBAC</title>
      <link>https://buenhyden.github.io/posts/security/authorization/rbac/</link>
      <pubDate>Wed, 06 Nov 2024 23:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authorization/rbac/</guid>
      <description>RBAC는 &amp;#34;만약 ~라면 ~할 수 있다&amp;#34;와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다. 각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.</description>
    </item>
    <item>
      <title>ReactJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript/library/reactjs/</link>
      <pubDate>Wed, 06 Nov 2024 13:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript/library/reactjs/</guid>
      <description>React는 사용자 인터페이스를 구축하기 위한 현대적인 JavaScript 라이브러리로, Facebook(현 Meta)에서 개발했다.</description>
    </item>
    <item>
      <title>Session based Auth</title>
      <link>https://buenhyden.github.io/posts/security/authentication/session-based-auth/</link>
      <pubDate>Wed, 06 Nov 2024 11:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/session-based-auth/</guid>
      <description>웹 애플리케이션에서 사용자의 인증 상태를 유지하는 전통적인 방법</description>
    </item>
    <item>
      <title>SAML</title>
      <link>https://buenhyden.github.io/posts/security/authentication/saml/</link>
      <pubDate>Wed, 06 Nov 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/saml/</guid>
      <description>웹 애플리케이션에서 사용자 인증과 권한 부여를 위한 개방형 표준 프로토콜</description>
    </item>
    <item>
      <title>Basic Authentication</title>
      <link>https://buenhyden.github.io/posts/security/authentication/basic-authentication/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/basic-authentication/</guid>
      <description>HTTP 헤더에 사용자의 인증 정보를 포함시켜 전송하는 방식</description>
    </item>
    <item>
      <title>Cookie Based Auth</title>
      <link>https://buenhyden.github.io/posts/security/authentication/cookie-based-auth/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/cookie-based-auth/</guid>
      <description>웹 애플리케이션에서 사용자 세션을 유지하는 전통적인 방법</description>
    </item>
    <item>
      <title>JWT</title>
      <link>https://buenhyden.github.io/posts/security/authentication/jwt/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/jwt/</guid>
      <description>당사자 간에 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함된 방식을 정의하는 개방형 표준(RFC 7519)</description>
    </item>
    <item>
      <title>OAuth</title>
      <link>https://buenhyden.github.io/posts/security/authentication/oauth/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/oauth/</guid>
      <description>사용자의 비밀번호를 공유하지 않고도 제3자 애플리케이션이 사용자의 데이터에 안전하게 접근할 수 있도록 하는 표준 프로토콜</description>
    </item>
    <item>
      <title>OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security/authentication/openid-connect/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/openid-connect/</guid>
      <description>OAuth 2.0 프로토콜 위에 구축된 인증 계층으로, 사용자 인증과 기본적인 프로필 정보 획득을 위한 표준화된 방법을 제공</description>
    </item>
    <item>
      <title>Token Authentication</title>
      <link>https://buenhyden.github.io/posts/security/authentication/token-authentication/</link>
      <pubDate>Wed, 06 Nov 2024 11:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security/authentication/token-authentication/</guid>
      <description>사용자 자격 증명 대신 고유한 토큰을 사용하여 인증을 수행하며, 반복적인 로그인 없이 지속적인 접근을 가능하게 한다.</description>
    </item>
    <item>
      <title>Validation and Verification</title>
      <link>https://buenhyden.github.io/til/2024/11/05/validation-and-verification/</link>
      <pubDate>Tue, 05 Nov 2024 08:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/validation-and-verification/</guid>
      <description>Verification은 &amp;#34;제품을 올바르게 만들고 있는가?&amp;#34;를 확인하는 과정이고, Validation은 &amp;#34;올바른 제품을 만들고 있는가?&amp;#34;를 확인하는 과정이다.</description>
    </item>
    <item>
      <title>Formal Review and Informal Review</title>
      <link>https://buenhyden.github.io/til/2024/11/05/formal-review-and-informal-review/</link>
      <pubDate>Tue, 05 Nov 2024 05:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/formal-review-and-informal-review/</guid>
      <description>소프트웨어 개발 과정에서 품질 보증을 위해 사용되는 두 가지 주요 검토 방식이다.</description>
    </item>
    <item>
      <title>Black-box Test and White-box Test</title>
      <link>https://buenhyden.github.io/til/2024/11/05/black-box-test-and-white-box-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/11/05/black-box-test-and-white-box-test/</guid>
      <description>Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Beta Test</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/acceptance-test/beta-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/acceptance-test/beta-test/</guid>
      <description>베타 테스트는 소프트웨어 개발 주기의 마지막 단계에서 수행되는 테스트로, 제품이 일반 대중에게 공개되기 전 최종 단계에서 실제 사용자들이 참여하여 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Alpha Test</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/acceptance-test/alpha-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/acceptance-test/alpha-test/</guid>
      <description>알파 테스트는 소프트웨어 개발 주기의 후반부에 수행되는 중요한 테스트 단계로 개발 중인 소프트웨어를 실제 환경과 유사한 조건에서 테스트하는 과정이다.</description>
    </item>
    <item>
      <title>시스템 테스트 (System test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/system-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/system-test/</guid>
      <description>개발된 소프트웨어 시스템 전체를 검사하는 과정으로, 모든 개별 모듈과 구성 요소가 통합된 후 전체 시스템이 예상대로 작동하는지 확인한다.</description>
    </item>
    <item>
      <title>통합 테스트 (Integration Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/integration-test/</link>
      <pubDate>Mon, 04 Nov 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/integration-test/</guid>
      <description>통합 테스트는 소프트웨어 개발 과정에서 개별적으로 테스트된 모듈들을 결합하여 전체 시스템으로서의 상호작용을 검증하는 과정이다</description>
    </item>
    <item>
      <title>단위 테스트 (Unit Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/unit-test/</link>
      <pubDate>Mon, 04 Nov 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/unit-test/</guid>
      <description>단위 테스트는 소프트웨어의 가장 작은 단위인 개별 모듈이나 컴포넌트를 독립적으로 테스트하는 과정이다.</description>
    </item>
    <item>
      <title>회귀 테스트 (Regression Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/regression-test/</link>
      <pubDate>Sun, 03 Nov 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/regression-test/</guid>
      <description>회귀 테스트는 소프트웨어의 변경이나 수정 후에 기존 기능이 여전히 올바르게 작동하는지 확인하는 테스트이다.</description>
    </item>
    <item>
      <title>사용성 테스트 (Usability Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/usability-test/</link>
      <pubDate>Sun, 03 Nov 2024 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/usability-test/</guid>
      <description>사용성 테스트는 제품이나 서비스를 실제 사용자가 사용해보면서 그 과정을 관찰하고 분석하는 테스트 방법이다.</description>
    </item>
    <item>
      <title>부하 테스트(Load Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/load-testing/</link>
      <pubDate>Sun, 03 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/load-testing/</guid>
      <description>부하 테스트는 소프트웨어 시스템이 예상되는 사용자 부하 하에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>스트레스 테스트 (Stress Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/stress-testing/</link>
      <pubDate>Sun, 03 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/stress-testing/</guid>
      <description>스트레스 테스트는 소프트웨어 시스템을 극한의 조건에서 테스트하여 그 한계를 파악하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>보안 테스트 (Security Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/security-test/</link>
      <pubDate>Sun, 03 Nov 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/security-test/</guid>
      <description>소프트웨어 시스템의 보안성을 평가하기 위한 일련의 활동</description>
    </item>
    <item>
      <title>호환성 테스트 (Compatibility Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/compatibility-test/</link>
      <pubDate>Sun, 03 Nov 2024 03:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/compatibility-test/</guid>
      <description>호환성 테스트는 소프트웨어가 다양한 하드웨어, 운영체제, 네트워크 환경 등에서 올바르게 작동하는지 확인하기 위해 수행되는 테스트이다.</description>
    </item>
    <item>
      <title>용량 테스트 (Volume Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/volume-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/volume-test/</guid>
      <description>용량 테스트는 소프트웨어 시스템이 대량의 데이터를 처리할 때 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>확장성 테스트 (Scalability Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/scalability-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/scalability-test/</guid>
      <description>확장성 테스트는 소프트웨어 시스템이 증가하는 부하나 규모에 얼마나 잘 대응할 수 있는지를 평가하는 성능 테스트의 한 유형이다</description>
    </item>
    <item>
      <title>스모크 테스트 (Smoke Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/smoke-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/smoke-test/</guid>
      <description>스모크 테스트는 소프트웨어의 가장 중요한 기능이 제대로 작동하는지 빠르게 확인하는 예비 테스트이다</description>
    </item>
    <item>
      <title>기능 테스트 (Functional Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/functional-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/functional-test/</guid>
      <description>기능 테스트는 소프트웨어가 사용자의 요구사항을 충족하는지 확인하는 테스트 방법이다. 이는 시스템이 &amp;#34;무엇을 하는지&amp;#34;에 초점을 맞추며, 사용자 관점에서 소프트웨어의 기능을 검증한다.</description>
    </item>
    <item>
      <title>엔드투엔드 테스트(End-to-End Test, E2E Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/end-to-end-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/end-to-end-test/</guid>
      <description>이는 사용자의 관점에서 전체 애플리케이션의 흐름을 테스트하여 모든 구성 요소가 올바르게 작동하는지 확인한다.</description>
    </item>
    <item>
      <title>스파이크 테스트(Spike Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/spike-test/</link>
      <pubDate>Sun, 03 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/spike-test/</guid>
      <description>스파이크 테스트는 시스템에 갑작스럽고 극단적인 부하를 주어 시스템의 반응을 측정하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>지속성 테스트(Endurance Test)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/endurance-test/</link>
      <pubDate>Sun, 03 Nov 2024 01:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/endurance-test/</guid>
      <description>지속성 테스트는 소프트웨어 시스템이 장기간 동안 지속적인 부하 상태에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다</description>
    </item>
    <item>
      <title>Use Case Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/use-case-testing/</link>
      <pubDate>Sat, 02 Nov 2024 17:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/use-case-testing/</guid>
      <description>유즈케이스 테스팅은 유즈케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화하는 블랙박스 테스트 설계 기법</description>
    </item>
    <item>
      <title>Requirements-based Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/requirements-based-testing/</link>
      <pubDate>Sat, 02 Nov 2024 10:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/requirements-based-testing/</guid>
      <description>시스템의 요구사항을 기반으로 테스트 케이스를 설계하고 수행하는 방법</description>
    </item>
    <item>
      <title>Metamorphic Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/metamorphic-testing/</link>
      <pubDate>Sat, 02 Nov 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/metamorphic-testing/</guid>
      <description>메타모픽 테스팅은 소프트웨어의 의도된 기능에 대한 필수적인 속성인 메타모픽 관계(Metamorphic Relations, MRs)를 활용하여 테스트를 수행</description>
    </item>
    <item>
      <title>Boundary Value Analysis</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/boundary-value-analysis/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/boundary-value-analysis/</guid>
      <description>경계값 분석은 입력 또는 출력 범위의 경계 근처에서 결함이 발생할 가능성이 높다는 경험적 관찰에 기반한 테스트 기법</description>
    </item>
    <item>
      <title>Cause-Effect Graphing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/cause-effect-graphing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/cause-effect-graphing/</guid>
      <description>원인-결과 그래프 검사(Cause-Effect Graph Testing)는 블랙박스 테스트 기법 중 하나로, 입력 조건(원인)과 출력 결과(결과) 사이의 관계를 체계적으로 분석하고 모델링하여 효과적인 테스트 케이스를 도출하는 방법.</description>
    </item>
    <item>
      <title>Decision Table Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/decision-table-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/decision-table-testing/</guid>
      <description>여러 조건(conditions)과 그에 따른 행동(actions)의 모든 가능한 조합을 표 형태로 정리하여 테스트 케이스를 도출하는 기법</description>
    </item>
    <item>
      <title>State Transition Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/state-transition-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/state-transition-testing/</guid>
      <description>상태 전이 테스트는 시스템이나 객체의 상태 변화를 모델링하고, 이벤트에 따른 상태 전이와 그 결과를 검증하는 기법이다.</description>
    </item>
    <item>
      <title>분류 트리 방법 (Classification Tree Method)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/</guid>
      <description>CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.</description>
    </item>
    <item>
      <title>Equivalence Partitioning</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/</link>
      <pubDate>Sat, 02 Nov 2024 09:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/</guid>
      <description>동등 분할은 입력 또는 출력 데이터를 의미 있는 그룹으로 나누어 테스트하는 기법으로 핵심 아이디어는 같은 그룹에 속한 데이터는 프로그램에서 동일한 방식으로 처리될 것이라는 가정에 기반한다.</description>
    </item>
    <item>
      <title>Scenario Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/scenario-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/scenario-testing/</guid>
      <description>시나리오 테스팅은 실제 상황을 시뮬레이션하여 소프트웨어를 검증하는 강력한 기술이다. 개별 기능에 초점을 맞춘 기존 테스트 케이스와 달리 시나리오 테스트에서는 일련의 이벤트나 상호 작용이 발생할 때 시스템이 어떻게 작동하는지 검사한다.</description>
    </item>
    <item>
      <title>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</link>
      <pubDate>Sat, 02 Nov 2024 09:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</guid>
      <description>조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.</description>
    </item>
    <item>
      <title>체크리스트 기반 테스팅 (Checklist-based Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/checklist-based-testing/</link>
      <pubDate>Sat, 02 Nov 2024 08:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/checklist-based-testing/</guid>
      <description>Checklist-based Testing은 소프트웨어 테스팅 기법 중 하나로, 미리 정의된 체크리스트를 사용하여 체계적으로 테스트를 수행하는 방법</description>
    </item>
    <item>
      <title>랜덤 테스팅(Random Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/random-testing/</link>
      <pubDate>Sat, 02 Nov 2024 07:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/random-testing/</guid>
      <description>임의로 생성된 입력 데이터를 사용하여 프로그램을 테스트하는 방법</description>
    </item>
    <item>
      <title>탐색적 테스팅(Exploratory Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/exploratory-testing/</link>
      <pubDate>Sat, 02 Nov 2024 07:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/exploratory-testing/</guid>
      <description>탐색적 테스팅(Exploratory Testing)은 소프트웨어 테스팅의 한 접근 방식으로, 테스터의 창의성, 경험, 직관을 활용하여 소프트웨어를 자유롭게 탐색하며 결함을 발견하는 과정</description>
    </item>
    <item>
      <title>페어와이즈 테스팅(Pairwise Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/pairwise-testing/</link>
      <pubDate>Sat, 02 Nov 2024 07:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/pairwise-testing/</guid>
      <description>페어와이즈 테스팅은 모든 가능한 입력 값 조합을 테스트하는 대신, 입력 매개변수의 모든 쌍(pair)을 최소한 한 번씩 테스트하는 기법이다.</description>
    </item>
    <item>
      <title>비교 검사(Comparison Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/comparison-testing/</link>
      <pubDate>Sat, 02 Nov 2024 00:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/comparison-testing/</guid>
      <description>비교 검사는 블랙박스 테스팅 기법 중 하나로, 동일한 기능을 수행하는 여러 버전의 소프트웨어나 시스템을 비교하여 테스트하는 방법으로 동일한 입력값을 여러 버전의 소프트웨어에 제공하고, 그 출력값을 비교하는 방식으로 진행된다.</description>
    </item>
    <item>
      <title>오류 예측 검사(Error Guessing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/error-guessing/</link>
      <pubDate>Sat, 02 Nov 2024 00:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/error-guessing/</guid>
      <description>오류 예측 검사(Error Guessing)는 블랙박스 테스트 기법 중 하나로, 테스터의 **경험, 지식, 직관**을 활용하여 소프트웨어에서 발생할 가능성이 높은 오류를 예측하고 이를 기반으로 테스트 케이스를 설계하는 방법</description>
    </item>
    <item>
      <title>Fakes</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/fakes/</link>
      <pubDate>Fri, 01 Nov 2024 21:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/fakes/</guid>
      <description>실제 객체의 간단한 구현을 제공하는 테스트용 객체</description>
    </item>
    <item>
      <title>Dummy Objects</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/dummy-objects/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/dummy-objects/</guid>
      <description>테스트 과정에서 실제로는 사용되지 않지만 메서드의 파라미터를 채우기 위해 전달되는 객체</description>
    </item>
    <item>
      <title>Spies</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/spies/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/spies/</guid>
      <description>실제 객체의 메서드 호출을 추적하고 기록하는 데 사용</description>
    </item>
    <item>
      <title>Path Coverage</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/path-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/path-coverage/</guid>
      <description>프로그램의 모든 가능한 실행 경로를 최소한 한 번씩 테스트하는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>조건 커버리지 (Condition Coverage)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/condition-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/condition-coverage/</guid>
      <description>조건 커버리지는 결정 포인트 내의 각 개별 조건식이 참(true)과 거짓(false)의 결과를 최소한 한 번씩 갖도록 테스트하는 기법</description>
    </item>
    <item>
      <title>Decision Coverage</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/decision-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/decision-coverage/</guid>
      <description>결정 커버리지는 프로그램의 모든 결정 포인트(조건문)에서 전체 조건식이 최소한 한 번씩 참(True)과 거짓(False)의 결과를 가지도록 테스트하는 방법</description>
    </item>
    <item>
      <title>Statement Coverage</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/statement-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/statement-coverage/</guid>
      <description>프로그램을 구성하는 모든 문장들이 최소한 한 번은 실행될 수 있는 입력 데이터를 테스트 데이터로 선정하는 기준</description>
    </item>
    <item>
      <title>Function Coverage</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/function-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 10:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/function-coverage/</guid>
      <description>함수 커버리지는 프로그램 내의 모든 함수가 테스트 중에 최소한 한 번 이상 호출되었는지를 측정하는 지표이다.</description>
    </item>
    <item>
      <title>다중 조건 테스팅 (Branch Condition Combination Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/branch-condition-combination-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/branch-condition-combination-testing/</guid>
      <description>다중 조건 테스팅(Branch Condition Combination Testing)은 화이트박스 테스트 기법 중 하나로, 조건문 내의 모든 가능한 조건 조합을 테스트하는 방법이다</description>
    </item>
    <item>
      <title>Data Flow Testing</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/data-flow-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/data-flow-testing/</guid>
      <description>데이터 흐름 테스팅(Data Flow Testing)은 소프트웨어 테스트 기법 중 하나로, 프로그램 내에서 데이터의 정의와 사용에 초점을 맞춰 테스트를 수행하는 방법</description>
    </item>
    <item>
      <title>변경 조건/결정 커버리지 테스팅 (Modified Condition/Decision Coverage Testing, MC/DC)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/modified-condition-decision-coverage-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/modified-condition-decision-coverage-testing/</guid>
      <description>MC/DC는 결정문 내의 각 조건이 독립적으로 결정의 결과에 영향을 미치는지 확인하는 테스트 기법</description>
    </item>
    <item>
      <title>Stubs</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/stubs/</link>
      <pubDate>Fri, 01 Nov 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/stubs/</guid>
      <description>테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘</description>
    </item>
    <item>
      <title>구문 테스팅(Syntax Testing)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/syntax-testing/</link>
      <pubDate>Fri, 01 Nov 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/syntax-testing/</guid>
      <description>구문 테스팅(Syntax Testing)은 화이트박스 테스트 기법 중 하나로, 소프트웨어의 내부 구조와 코드를 검증하는 방법</description>
    </item>
    <item>
      <title>Mocks</title>
      <link>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/mocks/</link>
      <pubDate>Fri, 01 Nov 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/test/test-mgmt/test-double/mocks/</guid>
      <description>소프트웨어 테스트에서 사용되는 중요한 기법으로, 실제 객체를 모방하는 가짜 객체를 만들어 테스트하는 방법</description>
    </item>
    <item>
      <title>레플리케이션 (replication)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/replication/</link>
      <pubDate>Wed, 30 Oct 2024 06:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/replication/</guid>
      <description>하나의 데이터베이스(마스터 또는 프라이머리)의 데이터를 다른 데이터베이스(슬레이브 또는 세컨더리)로 복제하는 프로세스</description>
    </item>
    <item>
      <title>Security Vulnerability Scanning</title>
      <link>https://buenhyden.github.io/posts/qa/qc/technical-verification/security-vulnerability-scanning/</link>
      <pubDate>Tue, 29 Oct 2024 16:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/technical-verification/security-vulnerability-scanning/</guid>
      <description>보안 취약점 스캔은 자동화된 도구를 사용하여 시스템과 소프트웨어의 보안 약점을 찾아내는 과정으로, 시스템, 네트워크, 소프트웨어의 보안 취약점을 식별하고 분석하는 프로세스이다</description>
    </item>
    <item>
      <title>성능 프로파일링 (Performance Profiling)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/technical-verification/performance-profiling/</link>
      <pubDate>Tue, 29 Oct 2024 16:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/technical-verification/performance-profiling/</guid>
      <description>성능 프로파일링(Performance Profiling)은 소프트웨어의 실행 동작을 분석하여 성능을 측정하고 개선하는 기술이다</description>
    </item>
    <item>
      <title>Desk Check</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/desk-check/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/desk-check/</guid>
      <description>데스크 체크는 가장 기본적인 비형식 리뷰 방법 중 하나로, 개발자가 자신의 코드를 스스로 검토하는 과정</description>
    </item>
    <item>
      <title>워크스루(Walkthrough)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/walkthrough/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/walkthrough/</guid>
      <description>워크스루는 코드 작성자가 다른 개발자들에게 코드를 단계별로 설명하며 진행하는 비형식적 리뷰 방식</description>
    </item>
    <item>
      <title>코드 리뷰 (Code Review)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/code-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/code-review/</guid>
      <description>코드 리뷰는 개발자가 작성한 코드를 다른 개발자들이 검토하고 피드백을 제공하는 과정이다.</description>
    </item>
    <item>
      <title>패스 어라운드(Pass Around)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/pass-around/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/pass-around/</guid>
      <description>패스 어라운드는 비형식적 코드 리뷰의 한 형태로, 코드가 여러 리뷰어들 사이를 &amp;#34;돌아다니며&amp;#34; 검토되는 방식을 말한다.</description>
    </item>
    <item>
      <title>감사(Audit)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/audit/</link>
      <pubDate>Tue, 29 Oct 2024 07:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/audit/</guid>
      <description>독립적인 검토자들이 소프트웨어 산출물과 프로세스를 체계적으로 검사하고 평가하는 공식적인 검토 과정이다.</description>
    </item>
    <item>
      <title>페어 프로그래밍(Pair Programming)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/pair-programming/</link>
      <pubDate>Tue, 29 Oct 2024 07:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/informal-review/pair-programming/</guid>
      <description>페어 프로그래밍은 두 명의 개발자가 하나의 컴퓨터에서 함께 작업하는 협력적인 개발 방식</description>
    </item>
    <item>
      <title>Inspection</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/inspection/</link>
      <pubDate>Tue, 29 Oct 2024 07:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/inspection/</guid>
      <description>인스펙션은 FTR(Formal Technical Review)라고도 불리며, 정형화된 절차와 체크리스트를 사용하여 소프트웨어 산출물의 결함을 찾아내는 방법이다.</description>
    </item>
    <item>
      <title>관리 검토(Management Review)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/management-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/management-review/</guid>
      <description>관리 검토는 소프트웨어 개발 프로젝트의 진행 상황, 목표 달성도, 리스크 등을 경영진과 프로젝트 관리자가 검토하는 공식적인 프로세스</description>
    </item>
    <item>
      <title>기술 검토(Technical Review)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/technical-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/deliverable-verification/peer-review/formal-review/technical-review/</guid>
      <description>기술 검토는 소프트웨어의 기술적 측면을 전문가들이 체계적으로 평가하는 공식적인 검토 프로세스이다.</description>
    </item>
    <item>
      <title>정적 코드 분석 (Static Code analysis)</title>
      <link>https://buenhyden.github.io/posts/qa/qc/technical-verification/static-code-analysis/</link>
      <pubDate>Tue, 29 Oct 2024 06:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/qc/technical-verification/static-code-analysis/</guid>
      <description>정적 코드 분석은 프로그램을 실행하지 않고 소스 코드를 분석하여 잠재적인 결함, 취약점, 코딩 표준 위반 등을 찾아내는 기술이다</description>
    </item>
    <item>
      <title>코드 크기 메트릭(Lines of Code, LOC)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/lines-of-code/</link>
      <pubDate>Mon, 28 Oct 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/lines-of-code/</guid>
      <description>이 메트릭은 프로그램의 크기를 코드 라인 수로 표현하며, 소프트웨어 개발 프로젝트의 규모 추정, 생산성 측정, 품질 관리 등에 활용된다</description>
    </item>
    <item>
      <title>유지보수성 지수 (Maintainability Index)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/maintainability-index/</link>
      <pubDate>Mon, 28 Oct 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/maintainability-index/</guid>
      <description>유지보수성 지수는 코드를 얼마나 쉽게 유지보수할 수 있는지를 나타내는 0에서 100 사이의 수치로 높을수록 코드의 유지보수가 더 쉽다는 것을 의미한다.</description>
    </item>
    <item>
      <title>응집도(Cohesion)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/cohesion/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/cohesion/</guid>
      <description>하나의 모듈이 얼마나 단일한 목적에 집중되어 있는지를 나타낸다.</description>
    </item>
    <item>
      <title>코드 중복도 (Code Duplication)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/code-duplication/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/code-duplication/</guid>
      <description>코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다</description>
    </item>
    <item>
      <title>결합도 (Coupling)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/coupling/</link>
      <pubDate>Mon, 28 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/coupling/</guid>
      <description>서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표</description>
    </item>
    <item>
      <title>테스트 커버리지 (Test Coverage)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/test-coverage/</link>
      <pubDate>Mon, 28 Oct 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/test-coverage/</guid>
      <description>테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도</description>
    </item>
    <item>
      <title>Halstead Complexity</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/halstead-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/halstead-complexity/</guid>
      <description>프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다</description>
    </item>
    <item>
      <title>순환 복잡도 (Cyclomatic Complexity)</title>
      <link>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/cyclomatic-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/cyclomatic-complexity/</guid>
      <description>프로그램의 논리적 복잡성을 정량적으로 측정하는 지표</description>
    </item>
    <item>
      <title>SOC 2</title>
      <link>https://buenhyden.github.io/posts/qa/standards-and-policies/soc-2/</link>
      <pubDate>Sun, 27 Oct 2024 13:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/standards-and-policies/soc-2/</guid>
      <description>&lt;h2 id=&#34;soc-2&#34;&gt;SOC 2&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>PCI DSS</title>
      <link>https://buenhyden.github.io/posts/qa/standards-and-policies/pci-dss/</link>
      <pubDate>Sun, 27 Oct 2024 13:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/standards-and-policies/pci-dss/</guid>
      <description>&lt;h2 id=&#34;pci-dss&#34;&gt;PCI DSS&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>소프트웨어 라이선스 (Software License)</title>
      <link>https://buenhyden.github.io/posts/qa/standards-and-policies/software-license/</link>
      <pubDate>Sun, 27 Oct 2024 12:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/qa/standards-and-policies/software-license/</guid>
      <description>소프트웨어의 사용, 수정, 배포에 대한 권리와 제한을 정의하는 법적 도구</description>
    </item>
    <item>
      <title>Airflow</title>
      <link>https://buenhyden.github.io/posts/data-engineering/data-pipeline/airflow/</link>
      <pubDate>Sat, 26 Oct 2024 05:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-engineering/data-pipeline/airflow/</guid>
      <description>&lt;h2 id=&#34;airflow&#34;&gt;Airflow&lt;/h2&gt;
&lt;p&gt;Apache Airflow는 데이터 파이프라인을 구축, 관리, 모니터링하기 위한 오픈소스 플랫폼이다.&lt;/p&gt;
&lt;p&gt;Airflow는 복잡한 데이터 파이프라인을 효율적으로 관리할 수 있게 해주는 강력한 도구이다.&lt;br&gt;
데이터 엔지니어링 분야에서 널리 사용되며, 지속적으로 발전하고 있는 플랫폼이다.&lt;/p&gt;
&lt;p&gt;기본적인 DAG(Directed Acyclic Graph) 예시:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-21&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-21&#34;&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-22&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-22&#34;&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-23&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-23&#34;&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-24&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-24&#34;&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-25&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-25&#34;&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-26&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-26&#34;&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-27&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-27&#34;&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-28&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-28&#34;&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-29&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-29&#34;&gt;29&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-30&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-30&#34;&gt;30&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-31&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-31&#34;&gt;31&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-32&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-32&#34;&gt;32&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-33&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-33&#34;&gt;33&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-34&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-34&#34;&gt;34&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-35&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-35&#34;&gt;35&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-36&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-36&#34;&gt;36&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-37&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-37&#34;&gt;37&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-38&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-38&#34;&gt;38&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-39&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-39&#34;&gt;39&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-40&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-40&#34;&gt;40&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-41&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-41&#34;&gt;41&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-42&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-42&#34;&gt;42&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-43&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-43&#34;&gt;43&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-44&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-44&#34;&gt;44&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-45&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-45&#34;&gt;45&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-46&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-46&#34;&gt;46&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-47&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-47&#34;&gt;47&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-48&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-48&#34;&gt;48&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-49&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-49&#34;&gt;49&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-50&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-50&#34;&gt;50&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-51&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-51&#34;&gt;51&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-52&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-52&#34;&gt;52&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-53&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-53&#34;&gt;53&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-54&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-54&#34;&gt;54&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-55&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-55&#34;&gt;55&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-56&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-56&#34;&gt;56&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-57&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-57&#34;&gt;57&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-58&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-58&#34;&gt;58&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-59&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-59&#34;&gt;59&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-60&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-60&#34;&gt;60&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-61&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-61&#34;&gt;61&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-62&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-62&#34;&gt;62&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-63&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-63&#34;&gt;63&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-64&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-64&#34;&gt;64&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;airflow&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DAG&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;airflow.operators.python&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PythonOperator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;datetime&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datetime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timedelta&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# DAG 기본 설정&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;default_args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;owner&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;data_engineer&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;depends_on_past&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;start_date&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datetime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;email&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;alert@example.com&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;email_on_failure&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;retries&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;retry_delay&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timedelta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minutes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# DAG 정의&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DAG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;data_processing_pipeline&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;default_args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;default_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;description&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;데이터 처리 파이프라인&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;schedule_interval&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;0 0 * * *&amp;#39;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 매일 자정에 실행&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 태스크 함수 정의&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;extract_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 데이터 추출 로직&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;raw_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;extracted_value&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;task_instance&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xcom_push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;raw_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;raw_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;transform_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 데이터 변환 로직&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;raw_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;task_instance&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xcom_pull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;raw_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;transformed_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;transformed_&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;raw_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;task_instance&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xcom_push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;transformed_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;transformed_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 데이터 적재 로직&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;transformed_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;task_instance&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xcom_pull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;transformed_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Loading data: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;transformed_data&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 태스크 생성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;extract_task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PythonOperator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;task_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;extract_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;python_callable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extract_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;provide_context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;transform_task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PythonOperator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;task_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;transform_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;python_callable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;transform_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;provide_context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;load_task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PythonOperator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;task_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;load_data&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;python_callable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;provide_context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 태스크 의존성 설정&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;extract_task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transform_task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;load_task&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;airflow의-주요-특징&#34;&gt;Airflow의 주요 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Python 기반: DAG(Directed Acyclic Graph)를 Python 코드로 정의할 수 있어 유연성과 확장성이 뛰어나다.&lt;/li&gt;
&lt;li&gt;스케줄링: 복잡한 워크플로우를 쉽게 스케줄링할 수 있다.&lt;/li&gt;
&lt;li&gt;모니터링: 웹 인터페이스를 통해 작업 실행 상태를 실시간으로 모니터링할 수 있다.&lt;/li&gt;
&lt;li&gt;확장성: 다양한 외부 시스템과 쉽게 통합할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;airflow의-주요-구성-요소&#34;&gt;Airflow의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DAG (Directed Acyclic Graph):&lt;/p&gt;</description>
    </item>
    <item>
      <title>백프레셔(Backpressure)</title>
      <link>https://buenhyden.github.io/til/2024/10/26/backpressure/</link>
      <pubDate>Sat, 26 Oct 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/26/backpressure/</guid>
      <description>백프레셔는 시스템에서 데이터나 작업의 처리 속도가 유입 속도를 따라가지 못할 때 발생하는 압력을 의미한다.</description>
    </item>
    <item>
      <title>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</title>
      <link>https://buenhyden.github.io/til/2024/10/25/database-clustering-and-replication/</link>
      <pubDate>Fri, 25 Oct 2024 15:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/25/database-clustering-and-replication/</guid>
      <description>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다.</description>
    </item>
    <item>
      <title>데이터 불일치 (Data Inconsistency)</title>
      <link>https://buenhyden.github.io/til/2024/10/25/data-inconsistency/</link>
      <pubDate>Fri, 25 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/25/data-inconsistency/</guid>
      <description>동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황</description>
    </item>
    <item>
      <title>데이터베이스 잠금 (database lock)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/tracsaction/database-lock/</link>
      <pubDate>Thu, 24 Oct 2024 15:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/tracsaction/database-lock/</guid>
      <description>여러 사용자가 동시에 데이터에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 핵심적인 메커니즘</description>
    </item>
    <item>
      <title>sql subquery</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/rdbms/sql/sql-subquery/</link>
      <pubDate>Thu, 24 Oct 2024 15:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/rdbms/sql/sql-subquery/</guid>
      <description>서브쿼리(Subquery)는 다른 SQL 쿼리 내부에 중첩된 쿼리를 의미</description>
    </item>
    <item>
      <title>sql join</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/rdbms/sql/sql-join/</link>
      <pubDate>Thu, 24 Oct 2024 15:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/rdbms/sql/sql-join/</guid>
      <description>JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법</description>
    </item>
    <item>
      <title>ACID</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/tracsaction/acid/</link>
      <pubDate>Thu, 24 Oct 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/tracsaction/acid/</guid>
      <description>트랜잭션의 신뢰성과 일관성을 정의하는 네 가지 주요 특성</description>
    </item>
    <item>
      <title>N&#43;1</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/orm/n&#43;1/</link>
      <pubDate>Thu, 24 Oct 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/orm/n&#43;1/</guid>
      <description>N&#43;1 문제는 하나의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 연관된 데이터를 조회하기 위해 N번의 추가 쿼리가 발생하는 현상을 말한다.</description>
    </item>
    <item>
      <title>프로시저 (Procedure)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/rdbms/procedure/</link>
      <pubDate>Thu, 24 Oct 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/rdbms/procedure/</guid>
      <description>데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합이다.</description>
    </item>
    <item>
      <title>Cardinality</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/cardinality/</link>
      <pubDate>Tue, 22 Oct 2024 15:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/cardinality/</guid>
      <description>두 엔티티 간의 최대 연관성 혹은 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.</description>
    </item>
    <item>
      <title>분산 쿼리 (distributed query)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-query/</link>
      <pubDate>Tue, 22 Oct 2024 09:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-query/</guid>
      <description>여러 노드에 분산된 데이터를 대상으로 쿼리를 실행하고 결과를 얻는 과정</description>
    </item>
    <item>
      <title>분산 트랜잭션 (Distributed transaction)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-transaction/</link>
      <pubDate>Tue, 22 Oct 2024 09:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/distributed-transaction/</guid>
      <description>여러 분산된 데이터베이스 노드에서 수행되는 하나의 논리적 작업 단위를 의미한다</description>
    </item>
    <item>
      <title>데이터베이스 클러스터링(Database Clustering)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/database-clustering/</link>
      <pubDate>Tue, 22 Oct 2024 06:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/database-clustering/</guid>
      <description>하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술</description>
    </item>
    <item>
      <title>데이터베이스 파티셔닝 (Database Partitioning)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-partitioning/</link>
      <pubDate>Tue, 22 Oct 2024 06:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-partitioning/</guid>
      <description>파티셔닝은 큰 테이블이나 인덱스를 더 작고 관리하기 쉬운 단위로 나누는 것</description>
    </item>
    <item>
      <title>샤딩 (sharding)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/sharding/</link>
      <pubDate>Tue, 22 Oct 2024 06:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/distributed-database/sharding/</guid>
      <description>대규모 데이터베이스 시스템에서 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 기술</description>
    </item>
    <item>
      <title>데이터베이스 캐싱 (Database Caching)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-caching/</link>
      <pubDate>Tue, 22 Oct 2024 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-caching/</guid>
      <description>자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술</description>
    </item>
    <item>
      <title>데이터베이스 쿼리 최적화 (Database Query Optimization)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-query-optimization/</link>
      <pubDate>Tue, 22 Oct 2024 06:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-query-optimization/</guid>
      <description>데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 중요한 프로세스</description>
    </item>
    <item>
      <title>데이터베이스 인덱싱 (Database Indexing)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-indexing/</link>
      <pubDate>Tue, 22 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-indexing/</guid>
      <description>인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조</description>
    </item>
    <item>
      <title>데이터베이스 정규화 (Database Normalization)</title>
      <link>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-normalization/</link>
      <pubDate>Tue, 22 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-normalization/</guid>
      <description>관계형 데이터베이스의 설계를 체계화하고 최적화하는 과정</description>
    </item>
    <item>
      <title>Apache HTTP Server</title>
      <link>https://buenhyden.github.io/posts/backend/web-server/apache-http-server/</link>
      <pubDate>Mon, 21 Oct 2024 11:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/web-server/apache-http-server/</guid>
      <description>Apache HTTP Server는 가장 널리 사용되는 오픈 소스 웹 서버 소프트웨어이다.</description>
    </item>
    <item>
      <title>Caddy</title>
      <link>https://buenhyden.github.io/posts/backend/web-server/caddy/</link>
      <pubDate>Mon, 21 Oct 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/web-server/caddy/</guid>
      <description>Caddy는 Go 언어로 작성된 현대적이고 강력한 오픈 소스 웹 서버이다.</description>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://buenhyden.github.io/posts/backend/web-server/nginx/</link>
      <pubDate>Mon, 21 Oct 2024 08:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/web-server/nginx/</guid>
      <description>Nginx는 고성능의 오픈 소스 웹 서버 소프트웨어로, 웹 서버, 리버스 프록시, 로드 밸런서 등 다양한 기능을 제공한다.</description>
    </item>
    <item>
      <title>Message Queue</title>
      <link>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue/</link>
      <pubDate>Mon, 21 Oct 2024 06:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-queue/</guid>
      <description>메시지 큐는 프로그램, 네트워크, 서비스 간에 데이터를 주고받을 때 사용하는 비동기 통신 방법</description>
    </item>
    <item>
      <title>Event Broker</title>
      <link>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/event-broker/</link>
      <pubDate>Mon, 21 Oct 2024 06:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/event-broker/</guid>
      <description>이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다</description>
    </item>
    <item>
      <title>Message Broker</title>
      <link>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-broker/</link>
      <pubDate>Mon, 21 Oct 2024 05:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-broker/</guid>
      <description>소프트웨어 애플리케이션, 시스템 및 서비스 간의 통신을 가능하게 하는 중간 소프트웨어 모듈</description>
    </item>
    <item>
      <title>Kafka</title>
      <link>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/kafka/</link>
      <pubDate>Mon, 21 Oct 2024 00:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/kafka/</guid>
      <description>데이터 파이프라인을 구축하기 위한 분산 메시징 시스템으로, 실시간 데이터 파이프라인과 스트리밍 애플리케이션을 구축하는 데 사용된다.</description>
    </item>
    <item>
      <title>RabbitMQ</title>
      <link>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/rabbitmq/</link>
      <pubDate>Mon, 21 Oct 2024 00:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/rabbitmq/</guid>
      <description>RabbitMQ는 오픈 소스 메시지 브로커 소프트웨어로, 다양한 애플리케이션, 서비스, 시스템 간의 통신을 용이하게 한다.</description>
    </item>
    <item>
      <title>Cloud Networking</title>
      <link>https://buenhyden.github.io/til/2024/10/20/cloud-networking/</link>
      <pubDate>Sun, 20 Oct 2024 17:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/cloud-networking/</guid>
      <description>클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.</description>
    </item>
    <item>
      <title>폴링(Polling)</title>
      <link>https://buenhyden.github.io/til/2024/10/20/polling/</link>
      <pubDate>Sun, 20 Oct 2024 16:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/polling/</guid>
      <description>폴링(Polling)은 소프트웨어 개발에서 중요한 통신 기법으로, 클라이언트가 주기적으로 서버에 데이터나 상태 변경을 요청하는 방식이다.</description>
    </item>
    <item>
      <title>Data Transmission</title>
      <link>https://buenhyden.github.io/til/2024/10/20/data-transmission/</link>
      <pubDate>Sun, 20 Oct 2024 09:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/data-transmission/</guid>
      <description>데이터 전송 및 처리 방식은 다양한 기준에 따라 분류되며, 각 방식은 특정한 통신 환경과 요구 사항에 맞게 선택된다.</description>
    </item>
    <item>
      <title>스트리밍 (Streaming)</title>
      <link>https://buenhyden.github.io/til/2024/10/20/streaming/</link>
      <pubDate>Sun, 20 Oct 2024 06:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/streaming/</guid>
      <description>스트리밍은 인터넷을 통해 오디오, 비디오 및 기타 콘텐츠를 실시간으로 전송하고 재생하는 기술</description>
    </item>
    <item>
      <title>네트워크 기능 가상화(Network Functions Virtualization, NFV)</title>
      <link>https://buenhyden.github.io/til/2024/10/20/network-functions-virtualization/</link>
      <pubDate>Sun, 20 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/network-functions-virtualization/</guid>
      <description>NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.</description>
    </item>
    <item>
      <title>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</title>
      <link>https://buenhyden.github.io/til/2024/10/20/software-defined-networking/</link>
      <pubDate>Sun, 20 Oct 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/software-defined-networking/</guid>
      <description>네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.</description>
    </item>
    <item>
      <title>RDMA</title>
      <link>https://buenhyden.github.io/til/2024/10/20/rdma/</link>
      <pubDate>Sun, 20 Oct 2024 01:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/20/rdma/</guid>
      <description>네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술</description>
    </item>
    <item>
      <title>프록시(Proxy)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/concepts/proxy/</link>
      <pubDate>Sat, 19 Oct 2024 08:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/concepts/proxy/</guid>
      <description>프록시 서버는 클라이언트의 요청을 받아 대신 서버에 접속하여 데이터를 주고받는 중개자 역할을 한다.</description>
    </item>
    <item>
      <title>HATEOAS (Hypermedia As The Engine Of Application State)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/hateoas/</link>
      <pubDate>Sat, 19 Oct 2024 07:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/hateoas/</guid>
      <description>RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.</description>
    </item>
    <item>
      <title>웹훅 (Webhook)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/webhook/</link>
      <pubDate>Sat, 19 Oct 2024 06:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/webhook/</guid>
      <description>웹훅은 웹 애플리케이션에서 특정 이벤트가 발생했을 때 다른 애플리케이션에 실시간으로 정보를 전달하는 방법이다.</description>
    </item>
    <item>
      <title>WebRTC(Web Real-Time Communication) API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/webrtc-api/</link>
      <pubDate>Sat, 19 Oct 2024 06:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/webrtc-api/</guid>
      <description>WebRTC(Web Real-Time Communication) API는 웹 브라우저 간에 플러그인 없이 실시간 통신을 가능하게 하는 기술.</description>
    </item>
    <item>
      <title>Server sent Events</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/</link>
      <pubDate>Sat, 19 Oct 2024 06:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/server-sent-events/</guid>
      <description>SSE는 서버가 클라이언트로 단방향 실시간 이벤트 스트림을 전송할 수 있게 해주는 웹 기술</description>
    </item>
    <item>
      <title>WebSocket API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/websocket-api/</link>
      <pubDate>Sat, 19 Oct 2024 05:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/websocket-api/</guid>
      <description>WebSocket API는 WebSocket 프로토콜을 사용하여 클라이언트와 서버 간의 양방향, 실시간 통신을 가능하게 하는 웹 API이다.</description>
    </item>
    <item>
      <title>쓰로틀링 (Throttling)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/</link>
      <pubDate>Sat, 19 Oct 2024 04:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/</guid>
      <description>쓰로틀링(Throttling)은 시스템이나 리소스의 과도한 사용을 제어하고 관리하는 기술이다.</description>
    </item>
    <item>
      <title>GraphQL API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/graphql-api/</link>
      <pubDate>Sat, 19 Oct 2024 03:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/graphql-api/</guid>
      <description>API를 위한 쿼리 언어이자 서버 측 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청하고 받을 수 있게 해주는 강력한 도구</description>
    </item>
    <item>
      <title>gRPC API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/</link>
      <pubDate>Sat, 19 Oct 2024 03:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/</guid>
      <description>Google에서 개발한 오픈소스 원격 프로시저 호출(RPC) 시스템</description>
    </item>
    <item>
      <title>RESTful API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/</link>
      <pubDate>Sat, 19 Oct 2024 03:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/</guid>
      <description>웹 서비스를 설계하고 구현하기 위한 아키텍처 스타일</description>
    </item>
    <item>
      <title>SOAP API</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/</link>
      <pubDate>Sat, 19 Oct 2024 03:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/</guid>
      <description>SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜</description>
    </item>
    <item>
      <title>로드밸런싱 (LoadBalancing)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/</link>
      <pubDate>Sat, 19 Oct 2024 02:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/</guid>
      <description>여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.</description>
    </item>
    <item>
      <title>encapsulation and decapsulation</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/concepts/encapsulation-and-decapsulation/</link>
      <pubDate>Sat, 19 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/concepts/encapsulation-and-decapsulation/</guid>
      <description>데이터에 헤더 (Header) 를 붙이고 아래 계층에 보내는 것을 캡슐화 (Encapsulation), 데이터에 헤더를 제거하고 위 계층에 보내는 것을 역캡슐화 (Decapsulation)</description>
    </item>
    <item>
      <title>멱등성 (Idempotency)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency/</link>
      <pubDate>Fri, 18 Oct 2024 16:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency/</guid>
      <description>일한 동요청을 여러 번 수행해도 시스템의 상태가 한 번 수행한 것과 동일한 결과를 보장하는 속성</description>
    </item>
    <item>
      <title>안전한 메서드 (Safe Methods)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/safe-methods/</link>
      <pubDate>Fri, 18 Oct 2024 16:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/safe-methods/</guid>
      <description>서버의 상태를 변경하지 않는 HTTP 메서드</description>
    </item>
    <item>
      <title>SSH (Secure Shell)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ssh/</link>
      <pubDate>Fri, 18 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ssh/</guid>
      <description>SSH는 네트워크 상의 다른 컴퓨터에 안전하게 접속하기 위한 암호화 네트워크 프로토콜.</description>
    </item>
    <item>
      <title>SSL and TLS</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ssl-and-tls/</link>
      <pubDate>Fri, 18 Oct 2024 08:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ssl-and-tls/</guid>
      <description>인터넷 상에서 데이터를 안전하게 전송하기 위한 암호화 프로토콜.</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/cors/</link>
      <pubDate>Fri, 18 Oct 2024 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/cors/</guid>
      <description>다른 출처(Origin)의 리소스를 공유하기 위한 보안 메커니즘</description>
    </item>
    <item>
      <title>Cookies</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/cookies/</link>
      <pubDate>Fri, 18 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/cookies/</guid>
      <description>웹사이트가 사용자의 브라우저에 저장하는 작은 텍스트 파일</description>
    </item>
    <item>
      <title>HTTP Cache</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-cache/</link>
      <pubDate>Fri, 18 Oct 2024 07:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-cache/</guid>
      <description>웹 브라우저나 서버에서 데이터를 임시 저장하는 기술</description>
    </item>
    <item>
      <title>HTTP Headers</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-headers/</link>
      <pubDate>Fri, 18 Oct 2024 07:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-headers/</guid>
      <description>HTTP 요청이나 응답에서 전달할 부가적인 정보를 담는 데이터</description>
    </item>
    <item>
      <title>HTTP Request Methods</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-request-methods/</link>
      <pubDate>Fri, 18 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-request-methods/</guid>
      <description>클라이언트가 서버에 특정 작업을 요청하기 위해 사용하는 방식</description>
    </item>
    <item>
      <title>HTTP Status Code</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-status-code/</link>
      <pubDate>Fri, 18 Oct 2024 07:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/http-status-code/</guid>
      <description>서버가 클라이언트의 요청에 대한 응답 상태를 나타내는 3자리 숫자.</description>
    </item>
    <item>
      <title>URI</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/uri/</link>
      <pubDate>Fri, 18 Oct 2024 04:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/uri/</guid>
      <description>인터넷 상의 자원을 고유하게 식별하기 위한 문자열로 URL과 URN은 모두 URI의 하위 개념이라고 볼 수 있다.</description>
    </item>
    <item>
      <title>WebSocket</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/websocket/</link>
      <pubDate>Fri, 18 Oct 2024 04:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/websocket/</guid>
      <description>웹 환경에서 클라이언트와 서버 간의 실시간 양방향 통신을 가능하게 하는 프로토콜</description>
    </item>
    <item>
      <title>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency-and-safe-methods/</link>
      <pubDate>Fri, 18 Oct 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency-and-safe-methods/</guid>
      <description>멱등성과 안전한 메서드는 HTTP 메서드의 중요한 특성으로, 서버의 상태 변화와 관련이 있다.</description>
    </item>
    <item>
      <title>서브넷팅 (Subnetting)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/subnetting/</link>
      <pubDate>Thu, 17 Oct 2024 13:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/subnetting/</guid>
      <description>서브넷팅(Subnetting)은 네트워크를 더 작은 단위의 네트워크로 분할하는 기술로 IP 주소의 효율적인 사용과 네트워크 관리를 개선하기 위해 사용된다.</description>
    </item>
    <item>
      <title>네트워크 주소 변환 (NAT, Network Address Translation)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/nat/</link>
      <pubDate>Thu, 17 Oct 2024 13:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/nat/</guid>
      <description>네트워크 주소 변환(NAT, Network Address Translation)은 IP 패킷의 TCP/UDP 포트 번호와 소스 및 목적지의 IP 주소를 재기록하면서 라우터를 통해 네트워크 트래픽을 주고받는 기술이다.</description>
    </item>
    <item>
      <title>CIDR (Classless Inter-Domain Routing)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/cidr/</link>
      <pubDate>Thu, 17 Oct 2024 11:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/cidr/</guid>
      <description>CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식</description>
    </item>
    <item>
      <title>IP Delivery Modes</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/ip-delivery-modes/</link>
      <pubDate>Thu, 17 Oct 2024 07:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/ip/ip-delivery-modes/</guid>
      <description>네트워크에서 데이터를 전송하는 다양한 방식.</description>
    </item>
    <item>
      <title>DNS 캐싱 (DNS Caching)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/dns-caching/</link>
      <pubDate>Thu, 17 Oct 2024 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/dns-caching/</guid>
      <description>DNS 캐싱은 이전에 조회한 도메인 이름과 IP 주소의 매핑 정보를 임시로 저장하는 메커니즘이다.</description>
    </item>
    <item>
      <title>DNS Records</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/dns-records/</link>
      <pubDate>Thu, 17 Oct 2024 07:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/dns-records/</guid>
      <description>DNS Records는 도메인 이름 시스템(DNS)에서 사용되는 데이터 구조로, 도메인과 관련된 다양한 정보를 저장한다.</description>
    </item>
    <item>
      <title>TCP</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/</link>
      <pubDate>Thu, 17 Oct 2024 04:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/</guid>
      <description>TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜</description>
    </item>
    <item>
      <title>UDP</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/udp/</link>
      <pubDate>Thu, 17 Oct 2024 04:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/udp/</guid>
      <description>연결 설정 과정 없이 데이터그램 단위로 전송하며, 신뢰성보다는 속도와 실시간 처리가 중요한 애플리케이션에서 주로 사용한다</description>
    </item>
    <item>
      <title>Domain</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/domain/</link>
      <pubDate>Thu, 17 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/domain/</guid>
      <description>도메인(Domain)은 인터넷 상의 계층적 주소 체계로, 사용자가 이해하기 쉬운 형태의 웹사이트 주소를 제공한다.</description>
    </item>
    <item>
      <title>Media Access Control Address (MAC Address)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/media-access-control-address/</link>
      <pubDate>Wed, 16 Oct 2024 12:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/media-access-control-address/</guid>
      <description>네트워크 장비를 식별하기 위한 고유한 하드웨어 주소</description>
    </item>
    <item>
      <title>Packet</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/</guid>
      <description>패킷(Packet)은 네트워크를 통해 전송되는 데이터의 기본 단위</description>
    </item>
    <item>
      <title>Routing</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/routing/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/routing/</guid>
      <description>데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.</description>
    </item>
    <item>
      <title>Network Hop</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/network-hop/</link>
      <pubDate>Wed, 16 Oct 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/network-hop/</guid>
      <description>네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.</description>
    </item>
    <item>
      <title>프래그먼테이션 (Fragmentation)</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/fragmentation/</link>
      <pubDate>Wed, 16 Oct 2024 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/fragmentation/</guid>
      <description>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</description>
    </item>
    <item>
      <title>Network and Communication Devices</title>
      <link>https://buenhyden.github.io/posts/networking-and-communications/network-and-communication-devices/</link>
      <pubDate>Wed, 16 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/networking-and-communications/network-and-communication-devices/</guid>
      <description>컴퓨터 네트워크와 통신 시스템에서 데이터를 전송, 수신, 처리하는데 사용되는 하드웨어 장치.</description>
    </item>
    <item>
      <title>보간 검색 (Interpolation Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</link>
      <pubDate>Tue, 15 Oct 2024 12:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/</guid>
      <description>&lt;h2 id=&#34;보간-검색-interpolation-search&#34;&gt;보간 검색 (Interpolation Search)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/</guid>
      <description>&lt;h2 id=&#34;버블-정렬-bubble-sort&#34;&gt;버블 정렬 (Bubble Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/</guid>
      <description>&lt;h2 id=&#34;병합-정렬-merge-sort&#34;&gt;병합 정렬 (Merge Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/insertion-sort/</guid>
      <description>&lt;h2 id=&#34;삽입-정렬-insertion-sort&#34;&gt;삽입 정렬 (Insertion Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/selection-sort/</guid>
      <description>&lt;h2 id=&#34;선택-정렬-selection-sort&#34;&gt;선택 정렬 (Selection Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/quick-sort/</guid>
      <description>&lt;h2 id=&#34;퀵-정렬-quick-sort&#34;&gt;퀵 정렬 (Quick Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/heap-sort/</guid>
      <description>&lt;h2 id=&#34;힙-정렬-heap-sort&#34;&gt;힙 정렬 (Heap Sort)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>깊이 우선 탐색 (Depth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/depth-first-search/</guid>
      <description>그래프나 트리 구조에서 하나의 경로를 끝까지 탐색한 후 다음 경로를 탐색하는 알고리즘.</description>
    </item>
    <item>
      <title>너비 우선 탐색 (Breadth-First Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/breadth-first-search/</guid>
      <description>BFS는 그래프나 트리 구조에서 가까운 노드부터 탐색하는 알고리즘</description>
    </item>
    <item>
      <title>이진 검색 (Binary Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/binary-search/</guid>
      <description>리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다</description>
    </item>
    <item>
      <title>해시 검색 (Hash Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/hash-search/</guid>
      <description>해시 검색은 키(key)를 해시 함수(hash function)에 통과시켜 얻은 해시 값(hash value)을 인덱스로 사용하여 데이터에 직접 접근하는 방식.</description>
    </item>
    <item>
      <title>순차 검색 (Sequential Search)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/</guid>
      <description>순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법으로 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/reducibility/</guid>
      <description>환원 가능성 (Reducibility)이란 한 문제를 다른 문제로 변환하는 과정을 말한다.</description>
    </item>
    <item>
      <title>메모이제이션 (Memoization)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</link>
      <pubDate>Sun, 13 Oct 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/memoization/</guid>
      <description>메모이제이션(Memoization)은 컴퓨터 프로그래밍에서 사용되는 최적화 기법으로, 함수의 호출 결과를 저장해두고 재사용함으로써 프로그램의 실행 속도를 향상시키는 방법이다.</description>
    </item>
    <item>
      <title>테이블레이션(Tabulation)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/</guid>
      <description>Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.</description>
    </item>
    <item>
      <title>튜링 기계 (Turing Machine)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</link>
      <pubDate>Sun, 13 Oct 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/</guid>
      <description>튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.</description>
    </item>
    <item>
      <title>복잡도 클래스(Complexity Classes)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</link>
      <pubDate>Sun, 13 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/</guid>
      <description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>브루트 포스 (Brute Force)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</link>
      <pubDate>Sun, 13 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/</guid>
      <description>브루트 포스는 &amp;#34;무식한 힘&amp;#34;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>Approaches to algorithm design</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</link>
      <pubDate>Sun, 13 Oct 2024 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/</guid>
      <description>알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.</description>
    </item>
    <item>
      <title>랜덤화 알고리즘 (Randomized Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/</guid>
      <description>랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다.</description>
    </item>
    <item>
      <title>근사 알고리즘 (Approximation algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/</guid>
      <description>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &amp;#39;충분히 가까운&amp;#39; 해답을 찾는 알고리즘이다.</description>
    </item>
    <item>
      <title>백트래킹 (Backtracking)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/</guid>
      <description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</description>
    </item>
    <item>
      <title>분기 한정법 (Branch and Bound)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/</guid>
      <description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</description>
    </item>
    <item>
      <title>탐욕 알고리즘 (Greedy Algorithm)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</link>
      <pubDate>Sun, 13 Oct 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/greedy-algorithm/</guid>
      <description>문제를 해결하는 과정에서 매 순간 현재 상황에서 가장 좋아 보이는 선택을 하는 방법이다. 즉, &amp;#39;탐욕적&amp;#39;으로 각 단계에서 최적이라고 생각되는 해를 선택하여 최종적인 해답에 도달하는 알고리즘이다.</description>
    </item>
    <item>
      <title>분할 정복 (Divide and Conquer)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</link>
      <pubDate>Sun, 13 Oct 2024 05:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/divide-and-conquer/</guid>
      <description>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.</description>
    </item>
    <item>
      <title>Big O 표기법 (Big O notation)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</link>
      <pubDate>Sun, 13 Oct 2024 01:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/big-o-notation/</guid>
      <description>알고리즘의 성능과 효율성을 수학적으로 표현하는 방법으로, 주로 알고리즘이 처리해야 할 데이터의 크기(n)가 늘어날 때, 실행 시간이나 메모리 사용량이 어떻게 증가하는지를 나타낸다.</description>
    </item>
    <item>
      <title>Octree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/octree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/octree/</guid>
      <description>Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.</description>
    </item>
    <item>
      <title>Splay Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/splay-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/splay-tree/</guid>
      <description>Splay Tree는 자체 균형 이진 검색 트리의 일종으로, 최근에 접근한 노드를 루트로 이동시키는 &amp;#34;splay&amp;#34; 연산을 통해 자가 조정되는 특징을 가진다.</description>
    </item>
    <item>
      <title>Fenwick Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/fenwick-tree/</guid>
      <description>Fenwick Tree는 구간 합을 효율적으로 계산하고 업데이트하기 위해 설계된 특수한 트리 구조로, 데이터베이스, 알고리즘 문제 해결, 그리고 다양한 응용 프로그램에서 사용된다.</description>
    </item>
    <item>
      <title>Segment Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/range-query/segment-tree/</guid>
      <description>세그먼트 트리는 배열의 특정 구간에 대한 정보를 빠르게 구할 수 있도록 설계된 이진 트리 기반의 자료구조</description>
    </item>
    <item>
      <title>AVL 트리 (AVL tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/avl-tree/</guid>
      <description>AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리이다.  각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.</description>
    </item>
    <item>
      <title>레드-블랙 트리 (red-black tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/red-black-tree/</link>
      <pubDate>Fri, 11 Oct 2024 12:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/red-black-tree/</guid>
      <description>Red-black tree는 각 노드에 추가적인 색상 속성(빨간색 또는 검은색)을 가진 자체 균형 이진 검색 트리로, 트리의 균형을 유지하여 효율적인 검색, 삽입, 삭제 연산을 보장한다.</description>
    </item>
    <item>
      <title>Ball tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/ball-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/ball-tree/</guid>
      <description>&lt;h2 id=&#34;spatial-data-partitioning&#34;&gt;Spatial Data partitioning&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>BK-tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bk-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bk-tree/</guid>
      <description>&lt;h2 id=&#34;spatial-data-partitioning&#34;&gt;Spatial Data partitioning&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>BSP Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/bsp-tree/</guid>
      <description>BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것</description>
    </item>
    <item>
      <title>K-d Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/k-d-tree/</guid>
      <description>K-d Tree는 k차원 공간에서 점들을 효율적으로 저장하고 검색하기 위한 이진 트리 기반의 공간 분할 데이터 구조로, K-d Tree는 k차원 공간을 재귀적으로 분할하여 표현하는 이진 트리이다.</description>
    </item>
    <item>
      <title>Merkle Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/hash/merkle-tree/</guid>
      <description>&lt;h2 id=&#34;merkle-tree&#34;&gt;Merkle Tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Quad Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/quad-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/quad-tree/</guid>
      <description>Quad Tree는 2차원 공간을 재귀적으로 4개의 영역으로 분할하여 표현하는 트리 기반의 데이터 구조로, 각 노드가 정확히 4개의 자식 노드를 갖는 트리 구조이다.</description>
    </item>
    <item>
      <title>R-tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/r-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/r-tree/</guid>
      <description>R-Tree는 다차원 공간 데이터를 효율적으로 저장하고 검색하기 위해 설계된 트리 기반의 데이터 구조로, 공간 인덱스 알고리즘이다.</description>
    </item>
    <item>
      <title>Radix tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/radix-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/radix-tree/</guid>
      <description>&lt;h2 id=&#34;radix-tree&#34;&gt;Radix tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Rope</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/rope/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/rope/</guid>
      <description>Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조</description>
    </item>
    <item>
      <title>Suffix Tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/suffix-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/suffix-tree/</guid>
      <description>Suffix Tree는 문자열의 모든 접미사를 효율적으로 저장하고 검색하는 특수한 트리 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>Ternary search tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/ternary-search-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/ternary-search-tree/</guid>
      <description>&lt;h2 id=&#34;ternary-search-tree&#34;&gt;Ternary search tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>vantage-point tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/vantage-point-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/vantage-point-tree/</guid>
      <description>&lt;h2 id=&#34;vantage-point-tree&#34;&gt;vantage-point tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>X-tree</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/x-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/spatial-data-partitioning/x-tree/</guid>
      <description>&lt;h2 id=&#34;x-tree&#34;&gt;X-tree&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>트라이 (Trie)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/string/trie/</guid>
      <description>문자열을 효율적으로 저장하고 검색할 수 있는 트리 기반의 자료구조</description>
    </item>
    <item>
      <title>디스조인트 셋 (Disjoint-Set)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/disjoint-set/</link>
      <pubDate>Fri, 11 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/disjoint-set/</guid>
      <description>디스조인트 셋은 서로 겹치지 않는(disjoint) 부분 집합들로 나누어진 요소들의 집합을 표현하고 조작하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>B 트리 (B-tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/b-tree/</link>
      <pubDate>Fri, 11 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/b-tree/</guid>
      <description>균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조</description>
    </item>
    <item>
      <title>binary heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/binary-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/binary-heap/</guid>
      <description>&lt;h2 id=&#34;binary-heap&#34;&gt;binary heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>binomial heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/binomial-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/binomial-heap/</guid>
      <description>&lt;h2 id=&#34;binomial-heap&#34;&gt;binomial heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Brodal queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/brodal-queue/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/brodal-queue/</guid>
      <description>&lt;h2 id=&#34;brodal-queue&#34;&gt;Brodal queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>d-ary heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/d-ary-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/d-ary-heap/</guid>
      <description>&lt;h2 id=&#34;d-ary-heap&#34;&gt;d-ary heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Pairing heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/pairing-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/pairing-heap/</guid>
      <description>&lt;h2 id=&#34;pairing-heap&#34;&gt;Pairing heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Skew heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/skew-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/skew-heap/</guid>
      <description>&lt;h2 id=&#34;skew-heap&#34;&gt;Skew heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Weak heap</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/weak-heap/</link>
      <pubDate>Thu, 10 Oct 2024 16:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/heap/weak-heap/</guid>
      <description>&lt;h2 id=&#34;weak-heap&#34;&gt;Weak heap&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Hash Map</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-map/</guid>
      <description>HashMap은 해시 함수를 사용하여 키를 배열의 인덱스로 변환하고, 해당 인덱스에 값을 저장하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>Lock-free Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/</link>
      <pubDate>Wed, 09 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/</guid>
      <description>Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.</description>
    </item>
    <item>
      <title>Concurrent Hash Map</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/</guid>
      <description>여러 스레드가 동시에 데이터를 안전하게 접근하고 수정할 수 있도록 설계된 스레드 안전(thread-safe)한 해시 맵 구현체</description>
    </item>
    <item>
      <title>Count-Min Sketch</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/count-min-sketch/</link>
      <pubDate>Wed, 09 Oct 2024 13:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/count-min-sketch/</guid>
      <description>&lt;h2 id=&#34;count-min-sketch&#34;&gt;Count-Min Sketch&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Cuckoo Filter</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-filter/</link>
      <pubDate>Wed, 09 Oct 2024 13:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-filter/</guid>
      <description>&lt;h2 id=&#34;cuckoo-filter&#34;&gt;Cuckoo Filter&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>HyperLogLog</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hyperloglog/</link>
      <pubDate>Wed, 09 Oct 2024 13:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hyperloglog/</guid>
      <description>&lt;h2 id=&#34;hyperloglog&#34;&gt;HyperLogLog&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>MinHash</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/minhash/</link>
      <pubDate>Wed, 09 Oct 2024 13:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/minhash/</guid>
      <description>&lt;h2 id=&#34;minhash&#34;&gt;MinHash&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Cuckoo Hash Table</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-hash-table/</guid>
      <description>Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.</description>
    </item>
    <item>
      <title>Bloom filter</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/bloom-filter/</link>
      <pubDate>Wed, 09 Oct 2024 12:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/bloom-filter/</guid>
      <description>&lt;h2 id=&#34;블룸-필터-bloom-filter&#34;&gt;블룸 필터 (Bloom filter)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Directed Acyclic Graph</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/directed-acyclic-graph/</link>
      <pubDate>Wed, 09 Oct 2024 10:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/directed-acyclic-graph/</guid>
      <description>&lt;h2 id=&#34;directed-acyclic-graph&#34;&gt;Directed Acyclic Graph&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Hopscotch Hash Table</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hopscotch-hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 08:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hopscotch-hash-table/</guid>
      <description>&lt;h2 id=&#34;hopscotch-hash-table&#34;&gt;Hopscotch Hash Table&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Hash Chain</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-chain/</link>
      <pubDate>Wed, 09 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-chain/</guid>
      <description>&lt;h2 id=&#34;hash-chain&#34;&gt;Hash Chain&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Hash Set</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-set/</link>
      <pubDate>Wed, 09 Oct 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-set/</guid>
      <description>&lt;h2 id=&#34;hash-set&#34;&gt;Hash Set&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Directed Graphs</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/directed-graphs/</link>
      <pubDate>Wed, 09 Oct 2024 07:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/directed-graphs/</guid>
      <description>&lt;h2 id=&#34;directed-graphs&#34;&gt;Directed Graphs&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Undirected Graphs</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/undirected-graphs/</link>
      <pubDate>Wed, 09 Oct 2024 07:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/undirected-graphs/</guid>
      <description>&lt;h2 id=&#34;undirected-graphs&#34;&gt;Undirected Graphs&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Weighted Graphs</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/weighted-graphs/</link>
      <pubDate>Wed, 09 Oct 2024 07:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/graph/weighted-graphs/</guid>
      <description>&lt;h2 id=&#34;weighted-graphs&#34;&gt;Weighted Graphs&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Array-based Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/array-based-stack/</link>
      <pubDate>Wed, 09 Oct 2024 07:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/array-based-stack/</guid>
      <description>&lt;h2 id=&#34;array-based-stack&#34;&gt;Array-based Stack&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Dynamic Size Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/dynamic-size-stack/</link>
      <pubDate>Wed, 09 Oct 2024 07:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/dynamic-size-stack/</guid>
      <description>&lt;h2 id=&#34;dynamic-size-stack&#34;&gt;Dynamic Size Stack&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Fixed Size Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/fixed-size-stack/</link>
      <pubDate>Wed, 09 Oct 2024 07:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/fixed-size-stack/</guid>
      <description>&lt;h2 id=&#34;fixed-size-stack&#34;&gt;Fixed Size Stack&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Linked List-based Stack</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/linked-list-based-stack/</link>
      <pubDate>Wed, 09 Oct 2024 07:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/linked-list-based-stack/</guid>
      <description>&lt;h2 id=&#34;linked-list-based-stack&#34;&gt;Linked List-based Stack&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>해시 테이블(Hash Table)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 05:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-table/</guid>
      <description>키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 키를 인덱스로 변환</description>
    </item>
    <item>
      <title>Concurrent Skip List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/</guid>
      <description>Concurrent Skip List는 Skip List 자료구조를 기반으로 하여 멀티스레드 환경에서 동시에 삽입, 삭제, 검색 작업을 수행할 수 있도록 구현된 동시성 자료구조이다.</description>
    </item>
    <item>
      <title>Read-Copy-Update List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/</guid>
      <description>RCU List는 Read-Copy-Update 메커니즘을 사용하여 구현된 동시성 연결 리스트로 읽기 작업에 대해 락을 사용하지 않으면서도 동시에 업데이트를 수행할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Lock-free Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/lock-free-queue/</link>
      <pubDate>Tue, 08 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/lock-free-queue/</guid>
      <description>Lock-free Queue는 락(lock)을 사용하지 않고 동시성을 제공하는 FIFO(First-In-First-Out) 자료구조이다.</description>
    </item>
    <item>
      <title>Suffix Array</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/suffix-array/</link>
      <pubDate>Tue, 08 Oct 2024 13:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/suffix-array/</guid>
      <description>Suffix Array는 문자열의 모든 접미사를 효율적으로 저장하고 관리하는 특수한 배열 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>Circular Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-linked-list/</guid>
      <description>Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.</description>
    </item>
    <item>
      <title>Circular Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/circular-queue/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/circular-queue/</guid>
      <description>Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.</description>
    </item>
    <item>
      <title>Doubly Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/doubly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/doubly-linked-list/</guid>
      <description>Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.</description>
    </item>
    <item>
      <title>Skip List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/skip-list/</guid>
      <description>Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다</description>
    </item>
    <item>
      <title>Deque</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/deque/</link>
      <pubDate>Tue, 08 Oct 2024 12:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/deque/</guid>
      <description>Deque는 양쪽 끝에서 삽입과 삭제가 가능한 선형 데이터 구조로, 큐와 스택의 특성을 모두 가지고 있다.</description>
    </item>
    <item>
      <title>Linear Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/linear-queue/</link>
      <pubDate>Tue, 08 Oct 2024 07:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/linear-queue/</guid>
      <description>&lt;h2 id=&#34;linear-queue&#34;&gt;Linear Queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Blocking Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/blocking-queue/</link>
      <pubDate>Tue, 08 Oct 2024 07:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/blocking-queue/</guid>
      <description>&lt;h2 id=&#34;blocking-queue&#34;&gt;Blocking Queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Concurrent Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/concurrent-queue/</link>
      <pubDate>Tue, 08 Oct 2024 07:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/concurrent-queue/</guid>
      <description>&lt;h2 id=&#34;concurrent-queue&#34;&gt;Concurrent Queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Priority Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/priority-queue/</link>
      <pubDate>Tue, 08 Oct 2024 07:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/priority-queue/</guid>
      <description>&lt;h2 id=&#34;priority-queue&#34;&gt;Priority Queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Circular Doubly Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-doubly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 07:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/circular-doubly-linked-list/</guid>
      <description>&lt;h2 id=&#34;circular-doubly-linked-list&#34;&gt;Circular Doubly Linked List&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Simple Queue</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/simple-queue/</link>
      <pubDate>Tue, 08 Oct 2024 07:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/queue/simple-queue/</guid>
      <description>&lt;h2 id=&#34;simple-queue&#34;&gt;Simple Queue&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Fixed Size Array</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/fixed-size-array/</link>
      <pubDate>Tue, 08 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/fixed-size-array/</guid>
      <description>&lt;h2 id=&#34;fixed-size-array&#34;&gt;Fixed Size Array&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Multi-dimensional Array</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/multi-dimensional-array/</link>
      <pubDate>Tue, 08 Oct 2024 07:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/multi-dimensional-array/</guid>
      <description>&lt;h2 id=&#34;multi-dimensional-array&#34;&gt;Multi-dimensional Array&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>One-dimensional Array</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/one-dimensional-array/</link>
      <pubDate>Tue, 08 Oct 2024 07:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/one-dimensional-array/</guid>
      <description>&lt;h2 id=&#34;one-dimensional-array&#34;&gt;One-dimensional Array&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Singly Linked List</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/singly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 07:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/singly-linked-list/</guid>
      <description>&lt;h2 id=&#34;singly-linked-list&#34;&gt;Singly Linked List&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>동적 배열 (Dynamic Array)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/dynamic-array/</link>
      <pubDate>Tue, 08 Oct 2024 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/array/dynamic-array/</guid>
      <description>동적 배열은 크기가 가변적인 배열 형태의 데이터 구조이다.</description>
    </item>
    <item>
      <title>이진 검색 트리 (Binary Search Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-search-tree/</link>
      <pubDate>Mon, 07 Oct 2024 12:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-search-tree/</guid>
      <description>BST는 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용되는 특수한 이진 트리 구조이다.</description>
    </item>
    <item>
      <title>논리값 (Boolean)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/boolean/</link>
      <pubDate>Mon, 07 Oct 2024 07:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/boolean/</guid>
      <description>Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.</description>
    </item>
    <item>
      <title>Integer</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/integer/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/integer/</guid>
      <description>정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.</description>
    </item>
    <item>
      <title>문자 (Character)과 문자열 (String)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/character-and-string/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/character-and-string/</guid>
      <description>문자 (Character)는 단일 문자를 표현하는 데이터 타입이고,문자열 (String)은 문자들의 배열 또는 시퀀스</description>
    </item>
    <item>
      <title>부동 소수점 (Float)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/float/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/float/</guid>
      <description>부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.</description>
    </item>
    <item>
      <title>이진 트리 (Binary Tree)</title>
      <link>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/</link>
      <pubDate>Mon, 07 Oct 2024 07:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/</guid>
      <description>이진 트리는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 데이터 구조로, 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용된다.</description>
    </item>
    <item>
      <title>Exception Handling</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/exception-handling/</link>
      <pubDate>Sun, 06 Oct 2024 15:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/exception-handling/</guid>
      <description>예외 처리(Exception Handling)는 프로그램 실행 중 발생할 수 있는 예기치 못한 상황을 관리하는 중요한 프로그래밍 개념이다.</description>
    </item>
    <item>
      <title>조건문 (Conditional Statements)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/conditional-statements/</link>
      <pubDate>Sun, 06 Oct 2024 15:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/conditional-statements/</guid>
      <description>조건문(Conditional Statements)은 프로그램의 흐름을 제어하는 중요한 구조이다.</description>
    </item>
    <item>
      <title>반복문(Iteration)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/iteration/</link>
      <pubDate>Sun, 06 Oct 2024 15:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/iteration/</guid>
      <description>특정 코드 블록을 여러 번 실행하는 제어 구조이다.</description>
    </item>
    <item>
      <title>재귀 (Recursion)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/recursion/</link>
      <pubDate>Sun, 06 Oct 2024 15:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/recursion/</guid>
      <description>재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.</description>
    </item>
    <item>
      <title>Callback Function (콜백 함수)</title>
      <link>https://buenhyden.github.io/til/2024/10/06/callback-function/</link>
      <pubDate>Sun, 06 Oct 2024 12:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/callback-function/</guid>
      <description>프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수</description>
    </item>
    <item>
      <title>가비지 컬렉션 (Garbage Collection, GC)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/garbage-collection/</link>
      <pubDate>Sun, 06 Oct 2024 10:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/garbage-collection/</guid>
      <description>프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능</description>
    </item>
    <item>
      <title>인터프리터(Interpreter)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/interpreter/</link>
      <pubDate>Sun, 06 Oct 2024 05:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/interpreter/</guid>
      <description>프로그래밍 언어의 소스 코드를 직접 실행하는 프로그램 또는 환경</description>
    </item>
    <item>
      <title>컴파일러(Compiler)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/concepts/compiler/</link>
      <pubDate>Sun, 06 Oct 2024 05:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/concepts/compiler/</guid>
      <description>우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램</description>
    </item>
    <item>
      <title>비동기(Asynchronous)</title>
      <link>https://buenhyden.github.io/til/2024/10/06/asynchronous/</link>
      <pubDate>Sun, 06 Oct 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/06/asynchronous/</guid>
      <description>프로그래밍에서 작업을 처리하는 두 가지 주요 방식</description>
    </item>
    <item>
      <title>메모리 보호와 안전 (Memory Protection and Safety)</title>
      <link>https://buenhyden.github.io/til/2024/10/05/memory-protection-and-safety/</link>
      <pubDate>Sat, 05 Oct 2024 08:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/memory-protection-and-safety/</guid>
      <description>메모리 보호는 컴퓨터 시스템에서 프로세스가 허가되지 않은 메모리 영역에 접근하는 것을 방지하는 메커니즘이다.</description>
    </item>
    <item>
      <title>코루틴(Coroutine)</title>
      <link>https://buenhyden.github.io/til/2024/10/05/coroutine/</link>
      <pubDate>Sat, 05 Oct 2024 06:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/coroutine/</guid>
      <description>코루틴은 &amp;#34;협력적인 루틴&amp;#34;이라는 의미로, 여러 작업이 협력하여 실행되는 방식을 말한다. 일반 함수와 달리, 코루틴은 실행 중간에 일시 중단되었다가 나중에 다시 재개될 수 있다.</description>
    </item>
    <item>
      <title>동기(Synchronous)</title>
      <link>https://buenhyden.github.io/til/2024/10/05/synchronous/</link>
      <pubDate>Sat, 05 Oct 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/synchronous/</guid>
      <description>프로그래밍에서 작업을 처리하는 두 가지 주요 방식</description>
    </item>
    <item>
      <title>Thrashing</title>
      <link>https://buenhyden.github.io/til/2024/10/05/thrashing/</link>
      <pubDate>Sat, 05 Oct 2024 00:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/10/05/thrashing/</guid>
      <description>운영체제에서 발생하는 성능 저하 현상으로, 프로세스의 실제 작업 시간보다 페이지 교체(페이징)에 더 많은 시간을 소비하는 현상</description>
    </item>
    <item>
      <title>Thread</title>
      <link>https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/thread/</link>
      <pubDate>Fri, 04 Oct 2024 23:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/thread/</guid>
      <description>Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.</description>
    </item>
    <item>
      <title>Multithreading</title>
      <link>https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/multithreading/</link>
      <pubDate>Fri, 04 Oct 2024 14:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/multithreading/</guid>
      <description>Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다.  즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.</description>
    </item>
    <item>
      <title>교착상태 (Deadlock)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/deadlock/</link>
      <pubDate>Thu, 03 Oct 2024 23:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/deadlock/</guid>
      <description>둘 이상의 프로세스가 서로가 가진 자원을 기다리며 더 이상 진행할 수 없는 상태</description>
    </item>
    <item>
      <title>Race Condition</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/race-condition/</link>
      <pubDate>Thu, 03 Oct 2024 23:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/race-condition/</guid>
      <description>여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 접근의 타이밍이나 순서에 따라 결과가 달라질 수 있는 상황</description>
    </item>
    <item>
      <title>Mutex</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/mutex/</link>
      <pubDate>Thu, 03 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/mutex/</guid>
      <description>Mutex(Mutual Exclusion)는 공유 자원에 대한 접근을 동기화하는 객체.</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/monitor/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/monitor/</guid>
      <description>&lt;h2 id=&#34;monitor&#34;&gt;Monitor&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/semaphore/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/semaphore/</guid>
      <description>멀티스레딩 환경에서 공유 자원에 대한 접근을 제어하는 동기화 도구</description>
    </item>
    <item>
      <title>잠금 (Lock)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/lock/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/lock/</guid>
      <description>여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 기본 요소이다. 임계 영역을 보호하고 한 번에 하나의 스레드만 접근할 수 있도록 한다.</description>
    </item>
    <item>
      <title>조건 변수 (Condition Variable)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/condition-variable/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/condition-variable/</guid>
      <description>조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.</description>
    </item>
    <item>
      <title>원자적 연산 (Atomic Operation)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/atomic-operation/</link>
      <pubDate>Thu, 03 Oct 2024 10:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/atomic-operation/</guid>
      <description>원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.</description>
    </item>
    <item>
      <title>데커 알고리즘 (Dekker&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/dekkers-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/dekkers-algorithm/</guid>
      <description>&lt;h2 id=&#34;데커-알고리즘-dekkers-algorithm&#34;&gt;데커 알고리즘 (Dekker&amp;rsquo;s Algorithm)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>램포트의 빵집 알고리즘 (Lamport&#39;s Bakery Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/lamports-bakery-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/lamports-bakery-algorithm/</guid>
      <description>&lt;h2 id=&#34;램포트의-빵집-알고리즘-lamports-bakery-algorithm&#34;&gt;램포트의 빵집 알고리즘 (Lamport&amp;rsquo;s Bakery Algorithm)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>피터슨 알고리즘 (Peterson&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/petersons-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/petersons-algorithm/</guid>
      <description>&lt;h2 id=&#34;피터슨-알고리즘-petersons-algorithm&#34;&gt;피터슨 알고리즘 (Peterson&amp;rsquo;s Algorithm)&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>라이브락 (Livelock)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/livelock/</link>
      <pubDate>Thu, 03 Oct 2024 09:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/livelock/</guid>
      <description>멀티스레딩 환경에서 발생할 수 있는 문제 상황으로, 프로세스나 스레드가 계속 실행 중이지만 실제로는 유용한 작업을 수행하지 못하는 상태</description>
    </item>
    <item>
      <title>Starvation</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/starvation/</link>
      <pubDate>Thu, 03 Oct 2024 07:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/starvation/</guid>
      <description>운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황</description>
    </item>
    <item>
      <title>상호 배제 (Mutual Exclusion)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/</link>
      <pubDate>Thu, 03 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/</guid>
      <description>여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘</description>
    </item>
    <item>
      <title>Process</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/</link>
      <pubDate>Wed, 02 Oct 2024 23:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/</guid>
      <description>프로세스는 실행 중인 프로그램의 인스턴스</description>
    </item>
    <item>
      <title>소켓(Socket)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/</link>
      <pubDate>Wed, 02 Oct 2024 16:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/</guid>
      <description>네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다.</description>
    </item>
    <item>
      <title>Message Queue</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/</link>
      <pubDate>Wed, 02 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/</guid>
      <description>프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Shared Memory</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/shared-memory/</link>
      <pubDate>Wed, 02 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/shared-memory/</guid>
      <description>공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.</description>
    </item>
    <item>
      <title>Pipe</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/pipe/</link>
      <pubDate>Wed, 02 Oct 2024 12:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/pipe/</guid>
      <description>파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.</description>
    </item>
    <item>
      <title>동기화 (Synchronization)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/synchronization/</link>
      <pubDate>Wed, 02 Oct 2024 07:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/synchronization/</guid>
      <description>여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 메커니즘</description>
    </item>
    <item>
      <title>프로세스 제어 블록(Process Control Block, PCB)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-control-block/</link>
      <pubDate>Wed, 02 Oct 2024 06:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-control-block/</guid>
      <description>프로세스 제어 블록(Process Control Block, PCB)은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다. PCB는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.</description>
    </item>
    <item>
      <title>Process Scheduling</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/</link>
      <pubDate>Wed, 02 Oct 2024 06:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/</guid>
      <description>프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘</description>
    </item>
    <item>
      <title>동시성 제어 (Concurrency Control)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/</link>
      <pubDate>Wed, 02 Oct 2024 02:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/</guid>
      <description>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘</description>
    </item>
    <item>
      <title>Context Switching</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/context-switching/</link>
      <pubDate>Wed, 02 Oct 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/context-switching/</guid>
      <description>Context Switching은 운영 체제에서 매우 중요한 개념으로, 여러 프로세스나 스레드가 단일 CPU 자원을 공유하여 효율적으로 실행될 수 있게 하는 메커니즘으로, CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 불러와 실행을 재개하는 과정을 말한다.  이를 통해 여러 작업이 동시에 실행되는 것처럼 보이게 된다.</description>
    </item>
    <item>
      <title>가상 메모리 (Virtual Memory)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/</link>
      <pubDate>Tue, 01 Oct 2024 13:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/</guid>
      <description>가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.</description>
    </item>
    <item>
      <title>세그먼테이션 (Segmentation)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/</link>
      <pubDate>Tue, 01 Oct 2024 13:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/</guid>
      <description>세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.</description>
    </item>
    <item>
      <title>페이징 (Paging)</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/</link>
      <pubDate>Tue, 01 Oct 2024 13:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/</guid>
      <description>페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다.</description>
    </item>
    <item>
      <title>System Call Interface</title>
      <link>https://buenhyden.github.io/posts/computer-system/operating-system/kernel/system-call-interface/</link>
      <pubDate>Tue, 01 Oct 2024 03:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/operating-system/kernel/system-call-interface/</guid>
      <description>사용자 공간의 프로그램과 운영 체제 커널 사이의 중간 계층으로, 프로그램이 운영 체제의 서비스를 요청할 수 있게 해주는 인터페이스</description>
    </item>
    <item>
      <title>캐시 (Cache)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache/</link>
      <pubDate>Mon, 30 Sep 2024 13:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache/</guid>
      <description>캐시(Cache)는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미한다.</description>
    </item>
    <item>
      <title>Byte Addressable Memory vs Word Addressable Memory</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/byte-addressable-memory-vs-word-addressable-memory/</link>
      <pubDate>Mon, 30 Sep 2024 11:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/byte-addressable-memory-vs-word-addressable-memory/</guid>
      <description>컴퓨터 메모리의 주소 지정 방식을 설명하는 개념</description>
    </item>
    <item>
      <title>Cache Memory</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/cache-memory/</link>
      <pubDate>Mon, 30 Sep 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/cache-memory/</guid>
      <description>캐시 메모리(Cache Memory)는 컴퓨터 아키텍처에서 중요한 역할을 하는 CPU와 주 메모리(RAM) 사이에 위치한 소규모의 고속 메모리이다.</description>
    </item>
    <item>
      <title>Allocation Policy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/allocation-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/allocation-policy/</guid>
      <description>&lt;h2 id=&#34;allocation-policy&#34;&gt;Allocation Policy&lt;/h2&gt;
&lt;p&gt;Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.&lt;br&gt;
이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;cache-allocation-policy의-주요-유형과-특징&#34;&gt;Cache Allocation Policy의 주요 유형과 특징&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Write-Allocate (Fetch-on-Write)&lt;br&gt;
Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prefetch Policy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/prefetch-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/prefetch-policy/</guid>
      <description>**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략</description>
    </item>
    <item>
      <title>Replacement Policy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/replacement-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/replacement-policy/</guid>
      <description>&lt;h2 id=&#34;replacement-policy&#34;&gt;Replacement Policy&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cache Replacement Policy(캐시 교체 정책)&lt;/strong&gt; 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.&lt;br&gt;
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.&lt;/p&gt;
&lt;p&gt;Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.&lt;br&gt;
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Write Policy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/</guid>
      <description>&lt;h2 id=&#34;write-policy&#34;&gt;Write Policy&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cache Policy&lt;/strong&gt;의 &lt;strong&gt;Write Policy(쓰기 정책)&lt;/strong&gt; 는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.&lt;br&gt;
이 정책은 데이터 일관성과 시스템 성능에 중요한 영향을 미친다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Policy&lt;/strong&gt;는 캐싱 시스템의 성능과 일관성에 중요한 영향을 미치는 요소이다. &lt;code&gt;Write-Through&lt;/code&gt;와 &lt;code&gt;Write-Back&lt;/code&gt;은 각각 장단점이 있으며, 워크로드 특성과 요구사항에 따라 적절한 정책을 선택해야 한다. 또한, &lt;code&gt;Write Allocate&lt;/code&gt;와 &lt;code&gt;No Write Allocate&lt;/code&gt; 같은 추가적인 처리 방식을 조합하여 최적의 결과를 얻을 수 있다. 올바른 정책 선택은 시스템의 효율성을 극대화하고 사용자 경험을 향상시키는 데 중요한 역할을 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Placement Policy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/placement-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/placement-policy/</guid>
      <description>&lt;h2 id=&#34;placement-policy&#34;&gt;Placement Policy&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cache Placement Policy&lt;/strong&gt;는 캐시 메모리에서 특정 메모리 블록이 캐시에 저장될 위치를 결정하는 규칙을 의미한다.&lt;br&gt;
이는 캐시의 구조와 데이터 접근 패턴에 따라 성능과 효율성에 큰 영향을 미친다. Placement Policy는 캐시 메모리의 설계와 운영에서 중요한 역할을 하며, 주로 다음 세 가지 주요 유형으로 나뉜다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct-Mapped Cache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fully Associative Cache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set-Associative Cache&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cache-placement-policy란&#34;&gt;Cache Placement Policy란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: Placement Policy는 특정 메모리 블록이 캐시에 저장될 때, 캐시 내에서 어느 위치(캐시 라인)에 저장될지를 결정하는 규칙이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;목적&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;캐시 메모리의 효율적인 사용.&lt;/li&gt;
&lt;li&gt;데이터 접근 속도 최적화.&lt;/li&gt;
&lt;li&gt;충돌(Collision) 관리: 동일한 캐시 라인에 여러 데이터가 매핑되는 상황을 최소화.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cache Placement Policy는 데이터가 캐시에 저장되는 위치를 결정하며, 시스템 성능과 효율성에 직접적인 영향을 미친다.&lt;br&gt;
Direct-Mapped, Fully Associative, Set-Associative 각각 장단점이 있으므로, 애플리케이션 요구사항과 하드웨어 제약 조건을 고려하여 적절한 정책을 선택해야 한다.&lt;br&gt;
Set-Associative는 대부분의 현대 시스템에서 자주 사용되는 절충안으로, 성능과 비용 간 균형을 제공한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>메모리 접근 방법 (Memory Access Methods)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-access-methods/</link>
      <pubDate>Mon, 30 Sep 2024 08:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-access-methods/</guid>
      <description>메모리 접근 방식 (Memory Access Methods)은 컴퓨터 시스템에서 메모리에 접근하는 방식을 말한다.</description>
    </item>
    <item>
      <title>메모리 주소 지정 방식 (Memory Address Modes)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-address-modes/</link>
      <pubDate>Mon, 30 Sep 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-address-modes/</guid>
      <description>메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.</description>
    </item>
    <item>
      <title>메모리의 계층 구조 (Memory Hierarchy)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/</link>
      <pubDate>Mon, 30 Sep 2024 03:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/</guid>
      <description>컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조</description>
    </item>
    <item>
      <title>Cache Coherence</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-coherence/</link>
      <pubDate>Mon, 30 Sep 2024 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-coherence/</guid>
      <description>Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.</description>
    </item>
    <item>
      <title>Cache Invalidation</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-invalidation/</link>
      <pubDate>Mon, 30 Sep 2024 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-invalidation/</guid>
      <description>Cache Invalidation(캐시 무효화)는 캐시에 저장된 데이터가 더 이상 최신 상태가 아니거나 유효하지 않을 때, 이를 무효화하여 캐시가 최신 데이터를 제공하도록 보장하는 과정이다.</description>
    </item>
    <item>
      <title>Cache Strategy</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-strategy/</link>
      <pubDate>Mon, 30 Sep 2024 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-strategy/</guid>
      <description>Cache Strategy(캐시 전략)는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.</description>
    </item>
    <item>
      <title>Caching Techniques</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/caching-techniques/</link>
      <pubDate>Mon, 30 Sep 2024 02:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/caching-techniques/</guid>
      <description>캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.</description>
    </item>
    <item>
      <title>컴퓨터 구성 요소 (Components of Computer Architecture)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/components-of-computer-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 16:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/components-of-computer-architecture/</guid>
      <description>이 구성 요소들의 상호작용을 통해 컴퓨터가 작동하게 된다.</description>
    </item>
    <item>
      <title>CPU</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/cpu/</link>
      <pubDate>Sun, 29 Sep 2024 16:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/cpu/</guid>
      <description>컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.</description>
    </item>
    <item>
      <title>인터럽트 (Interrupt)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/i-o-systems/interrupt/</link>
      <pubDate>Sun, 29 Sep 2024 06:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/i-o-systems/interrupt/</guid>
      <description>프로세서에게 현재 실행 중인 코드를 중단하고 특정 이벤트를 처리하도록 요청하는 신호</description>
    </item>
    <item>
      <title>파이프라이닝 (Pipelining)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/pipelining/</link>
      <pubDate>Sun, 29 Sep 2024 02:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/pipelining/</guid>
      <description>파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.</description>
    </item>
    <item>
      <title>명령어 집합 구조 (Instruction Set Architecture)</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/instruction-set-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/instruction-set-architecture/</guid>
      <description>ISA는 프로세서가 실행할 수 있는 명령어들의 집합을 정의하며, 프로그래머와 컴파일러 작성자에게 중요한 추상화 계층을 제공한다.</description>
    </item>
    <item>
      <title>System Bus</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/i-o-systems/system-bus/</link>
      <pubDate>Sun, 29 Sep 2024 02:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/i-o-systems/system-bus/</guid>
      <description>System Bus는 컴퓨터 아키텍처에서 주요 구성 요소들을 연결하는 중요한 통신 경로로, 컴퓨터의 혈관과 같은 역할을 한다.</description>
    </item>
    <item>
      <title>Harvard Architecture</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/harvard-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 01:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/harvard-architecture/</guid>
      <description>하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.</description>
    </item>
    <item>
      <title>Von Neumann architecture</title>
      <link>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/von-neumann-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 01:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/von-neumann-architecture/</guid>
      <description>Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.</description>
    </item>
    <item>
      <title>Version Control</title>
      <link>https://buenhyden.github.io/til/2024/09/28/version-control/</link>
      <pubDate>Sat, 28 Sep 2024 15:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/28/version-control/</guid>
      <description>동일한 정보에 대한 여러 버전을 관리하는 것</description>
    </item>
    <item>
      <title>Jenkins</title>
      <link>https://buenhyden.github.io/til/2024/09/28/jenkins/</link>
      <pubDate>Sat, 28 Sep 2024 15:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/28/jenkins/</guid>
      <description>오픈 소스 자동화 서버로, 주로 지속적 통합(CI)과 지속적 배포(CD) 프로세스를 자동화하는 데 사용되는 도구</description>
    </item>
    <item>
      <title>Shadow Deployment</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/shadow-deployment/</link>
      <pubDate>Sat, 28 Sep 2024 12:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/shadow-deployment/</guid>
      <description>&lt;h2 id=&#34;shadow-deployment&#34;&gt;Shadow Deployment&lt;/h2&gt;
&lt;p&gt;Shadow Deployment는 소프트웨어 배포 전략 중 하나로, 새로운 버전의 애플리케이션을 기존 버전과 병행하여 실행하되 사용자에게는 영향을 주지 않는 방식이다.&lt;/p&gt;
&lt;p&gt;Shadow Deployment는 새로운 버전의 애플리케이션을 프로덕션 환경에 배포하고 실제 트래픽을 복제하여 새 버전으로 전송하지만, 그 결과는 사용자에게 반환하지 않는 방식이다. 이는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;Shadow Deployment는 실제 환경에서 새로운 버전을 안전하게 테스트할 수 있는 전략이다. 하지만 구현 복잡성과 리소스 사용 증가 등의 단점도 있으므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 사용해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feature Flags</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/feature-flags/</link>
      <pubDate>Sat, 28 Sep 2024 12:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/feature-flags/</guid>
      <description>Feature flags는 조건문을 사용하여 코드의 특정 부분을 동적으로 제어하는 소프트웨어 개발 기법</description>
    </item>
    <item>
      <title>Git Branch 전략</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/</link>
      <pubDate>Sat, 28 Sep 2024 10:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/</guid>
      <description>Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)</description>
    </item>
    <item>
      <title>Monitoring and Observability</title>
      <link>https://buenhyden.github.io/til/2024/09/28/monitoring-and-observability/</link>
      <pubDate>Sat, 28 Sep 2024 08:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/28/monitoring-and-observability/</guid>
      <description>Observability는 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력을 말하고, Monitoring은 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동을 말한다.</description>
    </item>
    <item>
      <title>Git 원격 저장소와 Branch</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/</link>
      <pubDate>Sat, 28 Sep 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/</guid>
      <description>소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다.</description>
    </item>
    <item>
      <title>Git의 고급 기능</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git%EC%9D%98-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/</link>
      <pubDate>Sat, 28 Sep 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git%EC%9D%98-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/</guid>
      <description>소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다.</description>
    </item>
    <item>
      <title>Github Actions</title>
      <link>https://buenhyden.github.io/til/2024/09/28/github-actions/</link>
      <pubDate>Sat, 28 Sep 2024 03:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/28/github-actions/</guid>
      <description>GitHub에서 각각 제공하는 CI/CD(Continuous Integration and Continuous Deployment) 도구</description>
    </item>
    <item>
      <title>Gitlab CI</title>
      <link>https://buenhyden.github.io/til/2024/09/28/gitlab-ci/</link>
      <pubDate>Sat, 28 Sep 2024 03:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/28/gitlab-ci/</guid>
      <description>Gitlab에서 각각 제공하는 CI/CD(Continuous Integration and Continuous Deployment) 도구</description>
    </item>
    <item>
      <title>Metric</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/metric/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/metric/</guid>
      <description>Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값</description>
    </item>
    <item>
      <title>Trace</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/trace/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/trace/</guid>
      <description>분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것</description>
    </item>
    <item>
      <title>Log</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/log/</link>
      <pubDate>Sat, 28 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/observability/log/</guid>
      <description>Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.</description>
    </item>
    <item>
      <title>A/B Testing</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/a-b-testing/</link>
      <pubDate>Sat, 28 Sep 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/a-b-testing/</guid>
      <description>&lt;h2 id=&#34;ab-testing&#34;&gt;A/B Testing&lt;/h2&gt;
&lt;p&gt;A/B Testing은 소프트웨어 배포 전략 중 하나로, 두 가지 이상의 버전을 사용자에게 제공하여 어떤 버전이 더 효과적인지 비교하는 방법이다.&lt;/p&gt;
&lt;p&gt;A/B Testing은 두 가지 이상의 버전(A와 B)을 사용자 그룹에게 무작위로 제공하여 각 버전의 성능을 비교하는 실험적 접근 방식이다. 이는 웹사이트, 모바일 앱, 마케팅 캠페인 등 다양한 분야에서 사용된다.&lt;/p&gt;
&lt;p&gt;A/B Testing은 데이터 기반의 의사결정을 가능하게 한다. 하지만 올바른 설계와 분석이 필수적이며, 단기적 결과에만 집중하지 않도록 주의해야 한다. 지속적인 학습과 개선을 통해 사용자 경험을 향상시키고 비즈니스 목표를 달성하는 데 큰 도움이 될 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Blue-Green Deployment</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/blue-green-deployment/</link>
      <pubDate>Sat, 28 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/blue-green-deployment/</guid>
      <description>Blue-Green Deployment Pattern은 무중단 배포 전략 중 하나로, 애플리케이션의 새 버전을 안전하고 효율적으로 배포하는 방법이다.</description>
    </item>
    <item>
      <title>Canary Deployment</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/canary-deployment/</link>
      <pubDate>Sat, 28 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/canary-deployment/</guid>
      <description>카나리 배포(Canary Deployment) 패턴은 새로운 버전의 애플리케이션을 점진적으로 배포하는 전략이다.</description>
    </item>
    <item>
      <title>Rolling Deployment</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/rolling-deployment/</link>
      <pubDate>Sat, 28 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/deployment-strategies/rolling-deployment/</guid>
      <description>Rolling Deployment는 애플리케이션의 새 버전을 점진적으로 배포하는 무중단 배포 전략이다.</description>
    </item>
    <item>
      <title>멀티 테넌시(Multi-tenancy)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/</link>
      <pubDate>Fri, 27 Sep 2024 14:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/multi-tenancy/</guid>
      <description>하나의 소프트웨어 애플리케이션이나 시스템이 여러 고객(테넌트)에게 서비스를 제공하는 아키텍처이다.</description>
    </item>
    <item>
      <title>Rate Limiting Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/rate-limiting-pattern/</guid>
      <description>&lt;h2 id=&#34;rate-limiting-pattern&#34;&gt;Rate Limiting Pattern&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Rate Limiting Pattern&amp;quot;은 소프트웨어 아키텍처에서 &lt;strong&gt;서비스의 과도한 사용을 방지&lt;/strong&gt;하고 자원을 공정하게 분배하기 위한 핵심 전략이다.&lt;br&gt;
이 패턴은 특히 마이크로서비스, API 게이트웨이, 분산 시스템에서 중요하게 활용되며, 다음과 같은 세부 사항으로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rate Limiting&lt;/strong&gt;은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.&lt;br&gt;
주로 다음 목적을 위해 사용된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;서비스 장애 예방&lt;/strong&gt;: DDoS 공격, API 오용, 리소스 고갈 방지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비용 관리&lt;/strong&gt;: 클라우드 환경에서 트래픽 증가로 인한 예산 초과 방지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;공정한 자원 분배&lt;/strong&gt;: 특정 사용자가 시스템을 독점하지 않도록 제어.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Serverless Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/serverless-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/serverless-architecture/</guid>
      <description>&lt;h2 id=&#34;serverless-architecture&#34;&gt;Serverless Architecture&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Serverless Architecture&lt;/strong&gt;는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, &lt;strong&gt;이벤트 기반의 자동 확장성&lt;/strong&gt;과 &lt;strong&gt;사용한 만큼만 비용을 지불&lt;/strong&gt;하는 구조가 핵심이다.&lt;/p&gt;
&lt;p&gt;Serverless Architecture는 &lt;strong&gt;빠른 개발 속도&lt;/strong&gt;와 &lt;strong&gt;비용 효율성&lt;/strong&gt;으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.&lt;br&gt;
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Publisher-Subscriber Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/publisher-subscriber-pattern/</guid>
      <description>이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/retry-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/retry-pattern/</guid>
      <description>&lt;h2 id=&#34;retry-pattern&#34;&gt;Retry Pattern&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Retry Pattern&lt;/strong&gt;은 분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.&lt;br&gt;
네트워크 불안정, 일시적인 서비스 중단 등 &lt;strong&gt;일시적인 실패 상황에서 시스템의 복원력(Resilience)을 강화&lt;/strong&gt;하는 데 목적을 둔다.&lt;/p&gt;
&lt;p&gt;이 패턴은 &lt;strong&gt;분산 시스템의 안정성&lt;/strong&gt;을 높이는 필수 도구이지만, 남용할 경우 역효과를 낼 수 있으므로 &lt;strong&gt;신중한 정책 수립&lt;/strong&gt;이 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;retry-pattern의-핵심-개념&#34;&gt;&lt;strong&gt;Retry Pattern의 핵심 개념&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;작동 원리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;실패한 작업 자동 재시도&lt;/strong&gt;: API 호출, 데이터베이스 접근 등 실패 가능성이 있는 작업을 &lt;strong&gt;정의된 정책에 따라 재시도&lt;/strong&gt;한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;일시적 오류 감지&lt;/strong&gt;: 네트워크 타임아웃, HTTP 5xx 에러, 데이터베이스 연결 실패 등 &lt;strong&gt;일시적인 오류만 대상&lt;/strong&gt;으로 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;주요 구성 요소&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Model-View-ViewModel Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/</guid>
      <description>&lt;h2 id=&#34;model-view-viewmodel-pattern&#34;&gt;Model-View-ViewModel Pattern&lt;/h2&gt;
&lt;p&gt;MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.&lt;br&gt;
이 패턴은 MVC(Model-View-Controller) 패턴의 발전된 형태로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;MVVM 패턴은 복잡한 UI 애플리케이션 개발에 특히 유용하며, 대규모 프로젝트에서 코드의 구조화와 관리를 용이하게 한다.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
  &lt;img alt=&#34;Model-View-ViewModel Pattern&#34; loading=&#34;lazy&#34; src=&#34;https://buenhyden.github.io/img/mvvm-pattern.png&#34;&gt;&lt;figcaption&gt;https://learn.microsoft.com/ko-kr/dotnet/architecture/maui/mvvm&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;mvvm의-구성-요소&#34;&gt;MVVM의 구성 요소&lt;/h3&gt;
&lt;p&gt;MVVM 패턴은 세 가지 주요 구성 요소로 이루어져 있다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;모델(Model)&lt;/strong&gt;: 데이터와 비즈니스 로직을 담당한다. 데이터베이스나 웹 서비스와의 통신을 통해 데이터를 가져오거나 저장하는 역할을 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;뷰(View)&lt;/strong&gt;: 사용자 인터페이스(UI)를 담당한다. 데이터를 표시하고 사용자 입력을 받아 ViewModel에 전달한다. 버튼, 텍스트 박스 등 화면에 표시되는 모든 요소를 포함하며, 사용자와의 상호작용을 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;뷰모델(ViewModel)&lt;/strong&gt;: 뷰와 모델 사이의 중재자 역할을 한다. 뷰에서 보여지는 데이터와 이를 조작하는 메서드, 상태를 포함한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mvvm의-핵심-개념&#34;&gt;MVVM의 핵심 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;데이터 바인딩&lt;/strong&gt;: MVVM의 핵심 아이디어는 뷰와 뷰모델 사이에 양방향 데이터 바인딩을 통해 자동 업데이트를 가능하게 하는 것이다. 이를 통해 뷰와 뷰모델 사이의 데이터 동기화가 자동으로 이루어진다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;명령(Command):&lt;/strong&gt; 버튼 클릭과 같은 사용자 액션을 뷰모델에서 처리하기 위한 메커니즘이다. 뷰모델은 ICommand 인터페이스를 구현하여 뷰에서 발생하는 이벤트를 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;의존성 관리&lt;/strong&gt;: 뷰모델을 중재자로 사용하여 뷰와 모델 사이의 의존성을 해결한다. 이로 인해 뷰와 모델의 결합도가 낮아진다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;테스트 용이성&lt;/strong&gt;: 뷰와 모델이 분리되어 있어 각 구성 요소를 독립적으로 테스트하기 쉽다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mvvm의-장점&#34;&gt;MVVM의 장점&lt;/h3&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;유지보수성 향상&lt;/strong&gt;: UI와 비즈니스 로직이 분리되어 있어 코드의 유지보수가 용이하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;재사용성 증가&lt;/strong&gt;: 뷰모델은 여러 뷰에서 재사용될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자동 업데이트&lt;/strong&gt;: 데이터 바인딩을 통해 뷰모델의 상태 변화가 자동으로 UI에 반영된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;개발 효율성&lt;/strong&gt;: 개발자는 데이터 변경에 직접 관여하지 않고, 뷰모델을 통해 데이터를 조작하고 업데이트할 수 있어 코드의 복잡성이 줄어든다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mvvm-구현-예시&#34;&gt;MVVM 구현 예시&lt;/h3&gt;
&lt;p&gt;다음은 간단한 카운터 애플리케이션의 MVVM 구현 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Monolithic Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/monolithic-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/monolithic-pattern/</guid>
      <description>애플리케이션의 모든 구성 요소가 단일 코드베이스와 단일 실행 단위로 통합된 형태</description>
    </item>
    <item>
      <title>Service-oriented architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/service-oriented-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/service-oriented-architecture/</guid>
      <description>&lt;h2 id=&#34;service-oriented-architecture&#34;&gt;Service-oriented Architecture&lt;/h2&gt;
&lt;p&gt;**Service-Oriented Architecture(SOA)**는 기업의 복잡한 IT 시스템을 &lt;strong&gt;비즈니스 기능 단위의 서비스&lt;/strong&gt;로 모듈화하고, 이를 조합해 유연한 애플리케이션을 구축하는 소프트웨어 설계 패턴이다.&lt;br&gt;
대규모 분산 시스템에서 &lt;strong&gt;재사용성&lt;/strong&gt;과 &lt;strong&gt;상호 운용성&lt;/strong&gt;을 극대화하는 데 목적을 둔다.&lt;/p&gt;
&lt;p&gt;SOA는 &lt;strong&gt;기업 IT 시스템의 유연성&lt;/strong&gt;을 높이는 전략적 도구이지만, 초기 설계 단계에서 명확한 서비스 경계 정의와 ESB 관리 계획 수립이 필수적이다.&lt;br&gt;
특히 금융, 의료 등 복잡한 업무 프로세스가 존재하는 분야에서 효과적이며, 최근에는 MSA로 진화하면서 클라우드 환경에 적합한 형태로 재편되고 있다. 성공적인 SOA 구축을 위해서는 조직 차원의 아키텍처 거버넌스와 지속적인 모니터링 체계 구축이 동반되어야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Model–view–presenter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/modelviewpresenter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 09:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/modelviewpresenter-pattern/</guid>
      <description>&lt;h2 id=&#34;modelviewpresenter-pattern&#34;&gt;Model–view–presenter Pattern&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-및-출처&#34;&gt;참고 및 출처&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Message Queues and Streams</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/message-queues-and-streams/</link>
      <pubDate>Fri, 27 Sep 2024 09:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/message-queues-and-streams/</guid>
      <description>&lt;h2 id=&#34;message-queues-and-streams&#34;&gt;Message Queues and Streams&lt;/h2&gt;
&lt;p&gt;소프트웨어 아키텍처 패턴 중 &amp;ldquo;Message Queues and Streams&amp;quot;는 분산 시스템에서 중요한 역할을 하는 통신 메커니즘이다. 이 두 가지 패턴은 비슷해 보이지만 각각 고유한 특성과 용도를 가지고 있다.&lt;/p&gt;
&lt;p&gt;Message Queues와 Streams는 각각 고유한 장단점을 가지고 있다. 메시지 큐는 작업의 안정적인 처리와 시스템 간 결합도 감소에 적합하며, 스트림은 실시간 데이터 처리와 분석에 더 적합하다.&lt;br&gt;
프로젝트의 요구사항과 특성에 따라 적절한 패턴을 선택하거나 두 패턴을 조합하여 사용할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;message-queues-메시지-큐&#34;&gt;Message Queues (메시지 큐)&lt;/h3&gt;
&lt;p&gt;메시지 큐는 애플리케이션 간 비동기 통신을 위한 중간 계층 역할을 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Microkernel Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/microkernel-architecture/</guid>
      <description>시스템의 핵심 기능을 최소화하고 확장성과 유연성을 극대화하는 설계 방식</description>
    </item>
    <item>
      <title>Repository Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/</guid>
      <description>데이터 접근 로직을 추상화하고 캡슐화하여 비즈니스 로직과 데이터 저장소 간의 의존성을 줄이는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Space-Based Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/space-based-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/space-based-architecture/</guid>
      <description>분산 컴퓨팅 시스템을 위한 소프트웨어 아키텍처 패턴으로, 복잡성을 증가시키지 않으면서 애플리케이션과 시스템의 확장성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Master-Slave Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/</guid>
      <description>하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다</description>
    </item>
    <item>
      <title>Model-View-Controller Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-controller-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-controller-pattern/</guid>
      <description>애플리케이션을 세 가지 주요 구성 요소로 분리하여 개발의 유연성과 유지보수성을 향상시킨다.</description>
    </item>
    <item>
      <title>Peer-to-Peer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/peer-to-peer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/peer-to-peer-pattern/</guid>
      <description>분산 네트워크 아키텍처의 한 형태로, 각 노드(피어)가 클라이언트와 서버의 역할을 동시에 수행하는 구조</description>
    </item>
    <item>
      <title>Pipe-Filter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/</guid>
      <description>데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/producer-consumer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/producer-consumer-pattern/</guid>
      <description>이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.</description>
    </item>
    <item>
      <title>Component-Based Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/component-based-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 11:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/component-based-architecture/</guid>
      <description>&lt;h2 id=&#34;component-based-architecture&#34;&gt;Component-Based Architecture&lt;/h2&gt;
&lt;p&gt;컴포넌트 기반 아키텍처(Component-based Architecture)는 소프트웨어 개발에서 중요한 설계 패턴 중 하나이다.&lt;br&gt;
이 아키텍처는 애플리케이션을 독립적이고 재사용 가능한 단위인 &amp;lsquo;컴포넌트&amp;rsquo;로 구성하는 방식을 말한다.&lt;/p&gt;
&lt;p&gt;컴포넌트 기반 아키텍처는 소프트웨어를 독립적으로 배포 가능한 모듈인 &amp;lsquo;컴포넌트&amp;rsquo;로 구성하는 설계 방식이다.&lt;br&gt;
각 컴포넌트는 특정 기능을 수행하며, 잘 정의된 인터페이스를 통해 다른 컴포넌트와 상호작용한다.&lt;/p&gt;
&lt;p&gt;컴포넌트 기반 아키텍처는 소프트웨어 개발의 복잡성을 관리하고, 재사용성을 높이며, 유지보수를 용이하게 하는 강력한 접근 방식이다. 이는 현대 소프트웨어 개발에서 중요한 역할을 하며, 특히 대규모 애플리케이션 개발에 적합하다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Event-Driven Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-driven-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 11:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-driven-architecture/</guid>
      <description>Event-Driven Architecture (EDA)는 현대 소프트웨어 아키텍처 패턴 중 하나로, 시스템 내에서 발생하는 이벤트를 중심으로 동작하는 설계 방식이다.</description>
    </item>
    <item>
      <title>Event Sourcing Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 11:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/</guid>
      <description>Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.</description>
    </item>
    <item>
      <title>CQRS 패턴 (Command Query Responsibility Segregation)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/</guid>
      <description>애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Domain-Driven Design</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/</guid>
      <description>복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론</description>
    </item>
    <item>
      <title>Hexagonal Architecture</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/</link>
      <pubDate>Thu, 26 Sep 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/hexagonal-architecture/</guid>
      <description>애플리케이션의 핵심 비즈니스 로직을 외부 요소로부터 분리하여 유연하고 유지보수가 용이한 시스템을 구축하는 것을 목표로 한다</description>
    </item>
    <item>
      <title>Blackboard Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/</guid>
      <description>Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴으로 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.</description>
    </item>
    <item>
      <title>Broker Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/broker-pattern/</guid>
      <description>분산 시스템에서 컴포넌트들 간의 통신을 조정하고 중개하는 구조적 패턴</description>
    </item>
    <item>
      <title>Event-Bus Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-bus-pattern/</guid>
      <description>소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴</description>
    </item>
    <item>
      <title>Client-Server Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/client-server-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/client-server-pattern/</guid>
      <description>서비스를 제공하는 서버와 서비스를 요청하는 클라이언트로 구성되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Layered Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/layered-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/layered-pattern/</guid>
      <description>애플리케이션의 구성 요소를 수평적 계층으로 조직화하여 각 계층이 특정 기능을 담당하도록 한다.</description>
    </item>
    <item>
      <title>Factory Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/factory-method-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/factory-method-pattern/</guid>
      <description>객체 생성을 위한 인터페이스를 정의하지만, 실제 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정하도록 하는 디자인 패턴</description>
    </item>
    <item>
      <title>Singleton Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/singleton-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 18:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/singleton-pattern/</guid>
      <description>클래스의 인스턴스가 프로그램 전체에서 오직 하나만 생성되도록 보장하는 소프트웨어 디자인 패턴.</description>
    </item>
    <item>
      <title>Flyweight Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/flyweight-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/flyweight-pattern/</guid>
      <description>&lt;h2 id=&#34;flyweight-pattern&#34;&gt;Flyweight Pattern&lt;/h2&gt;
&lt;p&gt;Flyweight 패턴은 구조적 디자인 패턴 중 하나로, 객체를 공유하여 메모리 사용을 최소화하는 패턴이다.&lt;/p&gt;
&lt;p&gt;플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.&lt;br&gt;
간단히 말하면 캐시(Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성(extrinsic)과 변하지 않는 속성(intrinsic)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.&lt;/p&gt;
&lt;h3 id=&#34;flyweight-패턴의-주요-구성-요소&#34;&gt;Flyweight 패턴의 주요 구성 요소&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Flyweight: 경량 객체를 묶는 인터페이스.&lt;/li&gt;
&lt;li&gt;ConcreteFlyweight: 공유 가능하여 재사용되는 객체로, intrinsic state를 포함한다.&lt;/li&gt;
&lt;li&gt;UnsahredConcreteFlyweight: 공유 불가능한 객체로, extrinsic state를 포함한다.&lt;/li&gt;
&lt;li&gt;FlyweightFactory: 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스.&lt;/li&gt;
&lt;li&gt;Client: FlyweightFactory를 통해 Flyweight 타입의 객체를 얻어 사용한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flyweight-패턴의-동작-방식&#34;&gt;Flyweight 패턴의 동작 방식&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;FlyweightFactory는 Flyweight 객체들을 생성하고 관리한다.&lt;/li&gt;
&lt;li&gt;GetFlyweight() 메서드는 팩토리 메서드 역할을 한다. 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flyweight-패턴의-장점&#34;&gt;Flyweight 패턴의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;많은 객체를 만들 때 성능을 향상시킬 수 있다.&lt;/li&gt;
&lt;li&gt;많은 객체를 만들 때 메모리를 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;메모리 절약: 대규모 객체 시스템에서 상당한 메모리 절감 효과를 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;중복 최소화: 공유를 통해 객체의 중복 생성을 방지한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flyweight-패턴의-단점&#34;&gt;Flyweight 패턴의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;특정 인스턴스를 다르게 처리하는 것이 힘들어진다.&lt;/li&gt;
&lt;li&gt;코드 복잡성 증가: 객체를 공유하는 방식은 구현을 복잡하게 만들 수 있다.&lt;/li&gt;
&lt;li&gt;런타임 비용: 객체 상태를 관리하는 데 런타임 비용이 발생할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flyweight-패턴의-사용-시기&#34;&gt;Flyweight 패턴의 사용 시기&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;대량의 작은 객체를 생성해야 할 때 유용하다.&lt;/li&gt;
&lt;li&gt;객체의 상태를 자주 변하는 속성(Extrinsic)과 변하지 않는 속성(Intrinsic)으로 분리할 수 있을 때 적합하다.&lt;/li&gt;
&lt;li&gt;공통된 내재 상태를 공유함으로써 메모리 사용을 줄일 수 있을 때 사용한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;구현-예시&#34;&gt;구현 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-1&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-1&#34;&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-2&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-2&#34;&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-3&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-3&#34;&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-4&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-4&#34;&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-5&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-5&#34;&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-6&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-6&#34;&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-7&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-7&#34;&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-8&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-8&#34;&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-9&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-9&#34;&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-10&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-10&#34;&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-11&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-11&#34;&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-12&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-12&#34;&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-13&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-13&#34;&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-14&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-14&#34;&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-15&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-15&#34;&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-16&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-16&#34;&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-17&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-17&#34;&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-18&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-18&#34;&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-19&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-19&#34;&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-20&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-20&#34;&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-21&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-21&#34;&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-22&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-22&#34;&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-23&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-23&#34;&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-24&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-24&#34;&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-25&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-25&#34;&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-26&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-26&#34;&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-27&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-27&#34;&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-28&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-28&#34;&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-29&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-29&#34;&gt;29&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-30&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-30&#34;&gt;30&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-31&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-31&#34;&gt;31&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-32&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-32&#34;&gt;32&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-33&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-33&#34;&gt;33&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-34&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-34&#34;&gt;34&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-35&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-35&#34;&gt;35&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-36&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-36&#34;&gt;36&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-37&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-37&#34;&gt;37&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-38&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-38&#34;&gt;38&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-39&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-39&#34;&gt;39&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-40&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-40&#34;&gt;40&lt;/a&gt;
&lt;/span&gt;&lt;span class=&#34;lnt&#34; id=&#34;hl-0-41&#34;&gt;&lt;a class=&#34;lnlinks&#34; href=&#34;#hl-0-41&#34;&gt;41&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;typing&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dict&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Flyweight 클래스: 공유될 객체의 내부 상태를 정의&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CharacterStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;render&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Rendering &amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#39; at &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; with &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;, &amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;size &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;, &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;bold&amp;#39;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Flyweight 팩토리: Flyweight 객체들을 관리하고 공유&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CharacterStyleFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_styles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharacterStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharacterStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# 스타일을 식별하기 위한 키 생성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# 스타일이 존재하지 않으면 새로 생성&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_styles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_styles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharacterStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;font_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;font_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Creating new style: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_styles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_style_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_styles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 문자 객체: Flyweight를 사용하는 클래스&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Character&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharacterStyle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 외부 상태 (extrinsic state)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;style&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;style&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 공유 상태 (intrinsic state)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 외부 상태&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;render&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;render&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;실제 사용 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Composite Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/composite-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/composite-pattern/</guid>
      <description>&lt;h2 id=&#34;composite-pattern&#34;&gt;Composite Pattern&lt;/h2&gt;
&lt;p&gt;Composite Pattern은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴이다.&lt;/p&gt;
&lt;p&gt;Composite Pattern은 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층 구조를 만든다. 이 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 동일하게 다룰 수 있다.&lt;/p&gt;
&lt;p&gt;Composite Pattern은 복잡한 트리 구조를 간단하게 다룰 수 있게 해주는 강력한 도구이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 요구사항과 구조를 고려하여 적절히 사용해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;주요-구성-요소&#34;&gt;주요 구성 요소&lt;/h3&gt;
&lt;p&gt;Composite Pattern은 다음과 같은 주요 구성 요소로 이루어진다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bridge Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/bridge-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/bridge-pattern/</guid>
      <description>복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴</description>
    </item>
    <item>
      <title>Decorator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/decorator-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/decorator-pattern/</guid>
      <description>객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Facade Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/facade-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/facade-pattern/</guid>
      <description>복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Proxy Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/proxy-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/proxy-pattern/</guid>
      <description>객체에 대한 접근을 제어하기 위한 대리인(또는 대변인) 역할을 하는 객체를 제공하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Adapter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/adapter-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/adapter-pattern/</guid>
      <description>호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있도록 하는 구조적 디자인 패턴</description>
    </item>
    <item>
      <title>Abstract Factory Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/abstract-factory-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/abstract-factory-pattern/</guid>
      <description>구체적인 클래스를 지정하지 않고도 관련된 객체들의 집합을 생성할 수 있게 해주는 생성 패턴</description>
    </item>
    <item>
      <title>Builder Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/builder-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/builder-pattern/</guid>
      <description>복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 생성 패턴</description>
    </item>
    <item>
      <title>Prototype Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/</link>
      <pubDate>Wed, 25 Sep 2024 06:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/</guid>
      <description>기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴</description>
    </item>
    <item>
      <title>Interpreter Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/interpreter-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/interpreter-pattern/</guid>
      <description>Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.</description>
    </item>
    <item>
      <title>Visitor Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/visitor-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/visitor-pattern/</guid>
      <description>Visitor Pattern은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Chain of Responsibility</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/chain-of-responsibility/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/chain-of-responsibility/</guid>
      <description>Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Mediator Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/mediator-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/mediator-pattern/</guid>
      <description>&lt;h2 id=&#34;mediator-pattern&#34;&gt;Mediator Pattern&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mediator Pattern&lt;/strong&gt;(중재자 패턴)은 소프트웨어 디자인 패턴 중 하나로, 객체 간의 상호작용을 캡슐화하여 서로 직접 통신하지 않고 중재자 객체를 통해서만 소통하도록 설계된 행동 패턴이다.&lt;br&gt;
이 패턴은 객체 간의 복잡한 의존성을 줄이고, 시스템의 유연성과 재사용성을 향상시키는 데 도움을 준다.&lt;/p&gt;
&lt;h3 id=&#34;주요-개념&#34;&gt;주요 개념&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mediator (중재자)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체 간의 상호작용을 조정하는 역할을 하며, 서로 다른 객체들이 직접 통신하는 대신 중재자를 통해 소통하게 한다.&lt;/li&gt;
&lt;li&gt;Mediator는 Colleague 객체들의 통신을 관리하고 조정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Colleague (동료)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mediator와 상호작용하는 객체들로, 각 동료 객체는 Mediator를 통해 다른 동료와 통신한다.&lt;/li&gt;
&lt;li&gt;Colleague 객체는 Mediator에 대한 참조를 가지고 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ConcreteMediator (구체적인 중재자)&lt;/strong&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memento Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/memento-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 08:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/memento-pattern/</guid>
      <description>Mediator 패턴은 객체 지향 소프트웨어 디자인 패턴 중 하나로, 객체들 간의 복잡한 상호작용을 캡슐화하여 객체 간 결합도를 낮추는 행위 패턴이다.</description>
    </item>
    <item>
      <title>Command Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/command-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/command-pattern/</guid>
      <description>요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>State Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/state-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/state-pattern/</guid>
      <description>객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Strategy Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/strategy-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/strategy-pattern/</guid>
      <description>알고리즘의 집합을 정의하고, 각각을 캡슐화하여 교환 가능하게 만드는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Template Method Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/template-method-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/template-method-pattern/</guid>
      <description>알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴</description>
    </item>
    <item>
      <title>Observer Pattern</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 06:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/observer-pattern/</guid>
      <description>객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴</description>
    </item>
    <item>
      <title>프로그램 설계 방법론</title>
      <link>https://buenhyden.github.io/til/2024/09/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95%EB%A1%A0/</link>
      <pubDate>Tue, 24 Sep 2024 05:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%84%A4%EA%B3%84-%EB%B0%A9%EB%B2%95%EB%A1%A0/</guid>
      <description>소프트웨어 개발 과정에서 시스템을 구조화하고 모듈화하는 체계적인 접근 방식</description>
    </item>
    <item>
      <title>KISS Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/</link>
      <pubDate>Mon, 23 Sep 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/</guid>
      <description>시스템이나 코드의 복잡성을 최소화하라.</description>
    </item>
    <item>
      <title>YAGNI Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/</link>
      <pubDate>Mon, 23 Sep 2024 00:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/</guid>
      <description>당장 필요하지 않은 기능을 미리 구현하지 마라.</description>
    </item>
    <item>
      <title>DRY Principle</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/</link>
      <pubDate>Mon, 23 Sep 2024 00:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/</guid>
      <description>코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.</description>
    </item>
    <item>
      <title>SOLID Principles</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/</link>
      <pubDate>Mon, 23 Sep 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/</guid>
      <description>객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.</description>
    </item>
    <item>
      <title>동시성 프로그래밍 (Concurrency Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/</link>
      <pubDate>Sun, 22 Sep 2024 23:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/</guid>
      <description>여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법</description>
    </item>
    <item>
      <title>Class and Instance</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/</link>
      <pubDate>Sun, 22 Sep 2024 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/</guid>
      <description>클래스란 객체를 생성하기 위한 템플릿 또는 청사진이고, 인스턴스는 클래스를 기반으로 생성된 실제 객체</description>
    </item>
    <item>
      <title>다형성 (Polymorphism)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/polymorphism/</link>
      <pubDate>Sun, 22 Sep 2024 10:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/polymorphism/</guid>
      <description>다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, &amp;#34;여러 가지 형태를 가질 수 있는 능력&amp;#34;을 의미한다</description>
    </item>
    <item>
      <title>상속 (Inheritance)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/inheritance/</link>
      <pubDate>Sun, 22 Sep 2024 10:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/inheritance/</guid>
      <description>상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘</description>
    </item>
    <item>
      <title>Interface</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface/</link>
      <pubDate>Sun, 22 Sep 2024 09:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface/</guid>
      <description>소프트웨어나 애플리케이션에서 인터페이스(Interface)는 두 개의 시스템, 프로그램, 장치 또는 구성 요소 간의 상호 작용을 가능하게 하는 연결점 또는 접점을 의미한다.</description>
    </item>
    <item>
      <title>구조적 프로그래밍 (Structured Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/structured-programming/</guid>
      <description>구조적 프로그래밍은 1960년대에 등장한 프로그래밍 패러다임으로, 프로그램을 순차, 선택, 반복의 세 가지 기본 제어 구조로 구성하여 코드의 흐름을 체계적으로 관리하는 방식</description>
    </item>
    <item>
      <title>절차적 프로그래밍 (Procedural Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/procedural-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/procedural-programming/</guid>
      <description>프로그램의 실행 흐름을 일련의 절차나 함수로 구성하는 프로그래밍 패러다임</description>
    </item>
    <item>
      <title>제약 프로그래밍 (Constraint programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/constraint-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/constraint-programming/</guid>
      <description>문제를 변수와 이들 변수에 대한 제약 조건의 형태로 표현하는 프로그래밍 방식</description>
    </item>
    <item>
      <title>논리 프로그래밍 (Logic Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/</guid>
      <description>형식 논리에 기반한 프로그래밍 패러다임</description>
    </item>
    <item>
      <title>함수형 프로그래밍 (Functional Programming)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/</link>
      <pubDate>Sun, 22 Sep 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/</guid>
      <description>프로그램을 순수 함수들의 조합으로 구성하는 방식</description>
    </item>
    <item>
      <title>추상화 (Abstraction)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstraction/</link>
      <pubDate>Sun, 22 Sep 2024 06:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstraction/</guid>
      <description>프로그래밍에서 핵심적인 개념으로, 복잡한 시스템이나 데이터를 단순화하여 필수적인 특징만을 강조하는 과정</description>
    </item>
    <item>
      <title>Abstract class</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstract-class/</link>
      <pubDate>Sun, 22 Sep 2024 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstract-class/</guid>
      <description>추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다. 추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.</description>
    </item>
    <item>
      <title>오버라이딩(Overriding)과 오버로딩(Overloading)</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/</guid>
      <description>오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 알아보고 비교 분석해보자.</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/encapsulation/</link>
      <pubDate>Sun, 22 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/encapsulation/</guid>
      <description>캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶고, 외부로부터 접근을 제한하는 것을 의미한다.</description>
    </item>
    <item>
      <title>Concurrent Engineering Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/concurrent-engineering-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/concurrent-engineering-model/</guid>
      <description>소프트웨어 개발 프로세스를 최적화하고 효율성을 높이기 위한 접근 방식</description>
    </item>
    <item>
      <title>Domain-Driven Development</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/domain-driven-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/domain-driven-development/</guid>
      <description>복잡한 소프트웨어를 개발할 때 비즈니스 도메인을 중심으로 설계와 개발을 진행하는 방법론</description>
    </item>
    <item>
      <title>Formal Methods Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/formal-methods-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/formal-methods-model/</guid>
      <description>소프트웨어 개발에서 수학적 기법을 사용하여 시스템을 명세, 개발, 분석 및 검증하는 엄격한 접근 방식</description>
    </item>
    <item>
      <title>Incremental Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/incremental-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/incremental-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식.</description>
    </item>
    <item>
      <title>Test-Driven Development</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/test-driven-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/test-driven-development/</guid>
      <description>실제 코드를 작성하기 전에 테스트 코드를 먼저 작성하는 접근 방식</description>
    </item>
    <item>
      <title>행동 주도 개발 (Behavior-Driven Development, BDD)</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/behavior-driven-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/behavior-driven-development/</guid>
      <description>테스트 주도 개발(TDD)에서 파생된 소프트웨어 개발 방법론으로, 사용자의 행동과 비즈니스 가치에 초점을 맞춘다.</description>
    </item>
    <item>
      <title>DevOps Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/devops-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/devops-model/</guid>
      <description>소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 방법론으로, 소프트웨어 개발 프로세스를 개선하고 더 빠르고 안정적인 제품 배포를 가능하게 한다.</description>
    </item>
    <item>
      <title>Prototyping Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/prototyping-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/prototyping-model/</guid>
      <description>최종 제품의 초기 버전 또는 모형을 만들어 사용자의 피드백을 받고 요구사항을 명확히 하는 방법.</description>
    </item>
    <item>
      <title>Rapid Application Development</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/rapid-application-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/rapid-application-development/</guid>
      <description>빠른 프로토타이핑과 반복적인 개발을 통해 신속하게 애플리케이션을 구축하는 접근 방식</description>
    </item>
    <item>
      <title>Agile Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/agile-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/agile-model/</guid>
      <description>소프트웨어 개발에서 사용되는 반복적이고 점진적인 접근 방식으로  빠르게 변화하는 요구사항에 유연하게 대응하며 고객 만족을 최우선으로 한다.</description>
    </item>
    <item>
      <title>Iterative Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/iterative-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/iterative-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분으로 나누어 반복적으로 개발하고 개선하는 방법</description>
    </item>
    <item>
      <title>Spiral Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/spiral-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/spiral-model/</guid>
      <description>위험 분석을 중심으로 반복적인 개발을 수행하며, 각 반복 주기마다 위험 요소를 평가하고 대응한다.</description>
    </item>
    <item>
      <title>V Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/v-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/v-model/</guid>
      <description>개발 단계와 테스트 단계를 병행하여 진행하는 검증(Verification)과 확인(Validation) 중심의 접근 방식이다.</description>
    </item>
    <item>
      <title>Waterfall Model</title>
      <link>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/waterfall-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/waterfall-model/</guid>
      <description>각 단계를 순차적으로 진행하며, 이전 단계가 완료되어야 다음 단계로 넘어가는 전통적인 모델.</description>
    </item>
    <item>
      <title>클린 코드 (Clean Code)</title>
      <link>https://buenhyden.github.io/til/2024/09/19/clean-code/</link>
      <pubDate>Thu, 19 Sep 2024 05:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/19/clean-code/</guid>
      <description>프로그램의 동작을 보장하면서도 가독성이 뛰어나고 유지보수가 쉬운 코드</description>
    </item>
    <item>
      <title>Secure Coding</title>
      <link>https://buenhyden.github.io/til/2024/09/19/secure-coding/</link>
      <pubDate>Thu, 19 Sep 2024 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/til/2024/09/19/secure-coding/</guid>
      <description>Secure Coding은 소프트웨어 개발 과정에서 보안 취약점을 최소화하고 안전한 소프트웨어를 만들기 위한 코딩 기법이다.</description>
    </item>
  </channel>
</rss>
